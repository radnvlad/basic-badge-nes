Disassembly Listing for badge1
Generated From:
/Users/nitro/basic-badge/firmware/badge1.X/dist/default/debug/badge1.X.debug.elf
May 30, 2018 1:54:23 AM

---  /Users/nitro/basic-badge/firmware/badge1.X/src/vt100.c  --------------------------------------------
1:                   #include <string.h>
2:                   #include <stdlib.h>
3:                   #include <stdio.h>
4:                   #include "vt100.h"
5:                   #include "badge.h"
6:                   #include "hw.h"
7:                   
8:                   #define MAX_BUF 50
9:                   
10:                  uint8_t msg1[50];
11:                  
12:                  uint8_t color_composite;
13:                  uint16_t count;
14:                  volatile uint16_t bufhead;
15:                  volatile uint16_t buftail;
16:                  volatile uint16_t bufsize;
17:                  static int8_t cx;
18:                  static int8_t cy;
19:                  static uint8_t showcursor;
20:                  /* parameters from setup */
21:                  static uint8_t newlineseq;
22:                  static uint8_t process_escseqs;
23:                  static uint8_t local_echo;
24:                  /* escape sequence processing */
25:                  static uint8_t in_esc;
26:                  static int8_t paramstr[MAX_ESC_LEN+1];
27:                  static int8_t *paramptr;
28:                  static uint8_t paramch;
29:                  /* current attributes */
30:                  static uint8_t graphicchars;  /* set to 1 with an SI and set to 0 with an SO */
31:                  static uint8_t revvideo;      /* reverse video attribute */
32:                  static termstate_t savedstate;/* state used for save/restore sequences */
33:                  /* Vertical margins */
34:                  static int8_t mtop;
35:                  static int8_t mbottom;
36:                  
37:                  /* reverse video */
38:                  static uint8_t revvideo;
39:                  
40:                  uint8_t cur_type,cur_blink;
41:                  
42:                  extern int8_t disp_buffer[DISP_BUFFER_HIGH+1][DISP_BUFFER_WIDE];
43:                  extern int8_t color_buffer[DISP_BUFFER_HIGH+1][DISP_BUFFER_WIDE];
44:                  volatile uint8_t buf[MAX_BUF];
45:                  
46:                  void video_set_color(uint8_t fg, uint8_t bg)
47:                  	{
48:                  	color_composite = (fg&0xF) | ((bg&0xF)<<4);
9D01AC48  00052900   SLL A1, A1, 4
9D01AC4C  3084000F   ANDI A0, A0, 15
9D01AC50  00A42825   OR A1, A1, A0
9D01AC54  03E00008   JR RA
9D01AC58  A38581C1   SB A1, -32319(GP)
9D01AFB0  2402000F   ADDIU V0, ZERO, 15
9D01AFB4  A38281C1   SB V0, -32319(GP)
49:                  	}
50:                  
51:                  void term_init (void)
52:                  	{
9D01AF78  27BDFFE8   ADDIU SP, SP, -24
9D01AF7C  AFBF0014   SW RA, 20(SP)
53:                  	video_reset_margins();
9D01AF80  0F406BD6   JAL video_reset_margins
9D01AF84  00000000   NOP
54:                  	reset_term();
9D01AF88  0F406B84   JAL reset_term
9D01AF8C  00000000   NOP
55:                  	process_escseqs = 1;
9D01AF90  24020001   ADDIU V0, ZERO, 1
9D01AF94  A382818D   SB V0, -32371(GP)
56:                  	buftail = 0;
9D01AF98  A78081C2   SH ZERO, -32318(GP)
57:                  	bufhead = 0;
9D01AF9C  A78081BA   SH ZERO, -32326(GP)
58:                  	bufsize = 0;
9D01AFA0  A78081B8   SH ZERO, -32328(GP)
59:                  	cur_blink = 1;
9D01AFA4  A38281C0   SB V0, -32320(GP)
60:                  	cur_type = 2;
9D01AFA8  24020002   ADDIU V0, ZERO, 2
9D01AFAC  A38281BC   SB V0, -32324(GP)
61:                  	video_set_color(15,0);
62:                  	}
9D01AFB8  8FBF0014   LW RA, 20(SP)
9D01AFBC  03E00008   JR RA
9D01AFC0  27BD0018   ADDIU SP, SP, 24
63:                  
64:                  void buf_enqueue(uint8_t c)
65:                  	{
66:                  	if (bufsize < MAX_BUF)
9D01AC5C  978281B8   LHU V0, -32328(GP)
9D01AC60  3042FFFF   ANDI V0, V0, -1
9D01AC64  2C420032   SLTIU V0, V0, 50
9D01AC68  10400012   BEQ V0, ZERO, 0x9D01ACB4
9D01AC6C  00000000   NOP
67:                  		{
68:                  		buf[buftail] = c;
9D01AC70  978381C2   LHU V1, -32318(GP)
9D01AC74  3063FFFF   ANDI V1, V1, -1
9D01AC78  3C02A000   LUI V0, -24576
9D01AC7C  244219AC   ADDIU V0, V0, 6572
9D01AC80  00621021   ADDU V0, V1, V0
9D01AC84  A0440000   SB A0, 0(V0)
69:                  		if (++buftail >= MAX_BUF) buftail = 0;
9D01AC88  978281C2   LHU V0, -32318(GP)
9D01AC8C  24420001   ADDIU V0, V0, 1
9D01AC90  3042FFFF   ANDI V0, V0, -1
9D01AC94  A78281C2   SH V0, -32318(GP)
9D01AC98  2C420032   SLTIU V0, V0, 50
9D01AC9C  50400001   BEQL V0, ZERO, 0x9D01ACA4
9D01ACA0  A78081C2   SH ZERO, -32318(GP)
70:                  		bufsize++;
9D01ACA4  978281B8   LHU V0, -32328(GP)
9D01ACA8  24420001   ADDIU V0, V0, 1
9D01ACAC  3042FFFF   ANDI V0, V0, -1
9D01ACB0  A78281B8   SH V0, -32328(GP)
9D01ACB4  03E00008   JR RA
9D01ACB8  00000000   NOP
71:                  		}
72:                  	}
73:                  
74:                  uint8_t buf_dequeue()
75:                  	{
76:                  	uint8_t ret = 0;
77:                  	if (bufsize > 0)
9D01ACBC  978381B8   LHU V1, -32328(GP)
9D01ACC0  3063FFFF   ANDI V1, V1, -1
9D01ACC4  10600013   BEQ V1, ZERO, .LBE2
9D01ACC8  00001021   ADDU V0, ZERO, ZERO
78:                  		{
79:                  		uint8_t c = buf[bufhead];
9D01ACCC  978381BA   LHU V1, -32326(GP)
9D01ACD0  3063FFFF   ANDI V1, V1, -1
9D01ACD4  3C02A000   LUI V0, -24576
9D01ACD8  244219AC   ADDIU V0, V0, 6572
9D01ACDC  00621021   ADDU V0, V1, V0
9D01ACE0  90420000   LBU V0, 0(V0)
9D01ACE4  304200FF   ANDI V0, V0, 255
80:                  		if (++bufhead >= MAX_BUF) bufhead = 0;
9D01ACE8  978381BA   LHU V1, -32326(GP)
9D01ACEC  24630001   ADDIU V1, V1, 1
9D01ACF0  3063FFFF   ANDI V1, V1, -1
9D01ACF4  A78381BA   SH V1, -32326(GP)
9D01ACF8  2C630032   SLTIU V1, V1, 50
9D01ACFC  50600001   BEQL V1, ZERO, 0x9D01AD04
9D01AD00  A78081BA   SH ZERO, -32326(GP)
81:                  		bufsize--;
9D01AD04  978381B8   LHU V1, -32328(GP)
9D01AD08  2463FFFF   ADDIU V1, V1, -1
9D01AD0C  3063FFFF   ANDI V1, V1, -1
9D01AD10  A78381B8   SH V1, -32328(GP)
82:                  		ret = c;
83:                  		}
84:                  	return ret;
85:                  	}
9D01AD14  03E00008   JR RA
9D01AD18  00000000   NOP
86:                  
87:                  uint8_t buf_size()
88:                  	{
89:                  	uint8_t sz;
90:                  	sz = bufsize;
9D01AD1C  978281B8   LHU V0, -32328(GP)
91:                  	return sz;
92:                  	}
9D01AD20  03E00008   JR RA
9D01AD24  304200FF   ANDI V0, V0, 255
93:                  
94:                  //jar
95:                  /*
96:                  ISR(USART_RX_vect)
97:                  {
98:                  	buf_enqueue(RCREG);
99:                  }
100:                 
101:                 */
102:                 
103:                 
104:                 
105:                 void receive_char(uint8_t c)
106:                 	{
9D01BCF0  27BDFFE8   ADDIU SP, SP, -24
9D01BCF4  AFBF0014   SW RA, 20(SP)
107:                 	if (!process_escseqs)
9D01BCF8  9382818D   LBU V0, -32371(GP)
9D01BCFC  14400005   BNE V0, ZERO, 0x9D01BD14
9D01BD00  00000000   NOP
108:                 		{
109:                 		video_putc_raw(c);
9D01BD04  0F406F1F   JAL video_putc_raw
9D01BD08  7C042420   SEB A0, A0
110:                 		return;
9D01BD0C  0B406F84   J 0x9D01BE10
9D01BD10  8FBF0014   LW RA, 20(SP)
111:                 		}
112:                 
113:                 	if (c)
9D01BD14  1080003D   BEQ A0, ZERO, .LVL207
9D01BD18  9382818C   LBU V0, -32372(GP)
114:                 		{
115:                 		if (in_esc)
9D01BD1C  10400005   BEQ V0, ZERO, 0x9D01BD34
9D01BD20  2402000D   ADDIU V0, ZERO, 13
116:                 			escseq_process(c);
9D01BD24  0F406ED3   JAL escseq_process
9D01BD28  7C042420   SEB A0, A0
9D01BD2C  0B406F84   J 0x9D01BE10
9D01BD30  8FBF0014   LW RA, 20(SP)
117:                 		else switch (c)
9D01BD34  10820035   BEQ A0, V0, .LVL207
9D01BD38  2C82000E   SLTIU V0, A0, 14
9D01BD3C  1040000F   BEQ V0, ZERO, 0x9D01BD7C
9D01BD40  2402000F   ADDIU V0, ZERO, 15
9D01BD44  24020008   ADDIU V0, ZERO, 8
9D01BD48  10820017   BEQ A0, V0, 0x9D01BDA8
9D01BD4C  2C820009   SLTIU V0, A0, 9
9D01BD50  10400006   BEQ V0, ZERO, 0x9D01BD6C
9D01BD54  2C82000A   SLTIU V0, A0, 10
9D01BD58  24020007   ADDIU V0, ZERO, 7
9D01BD5C  1082002C   BEQ A0, V0, 0x9D01BE10
9D01BD60  8FBF0014   LW RA, 20(SP)
9D01BD6C  10400016   BEQ V0, ZERO, 0x9D01BDC8
9D01BD70  2C820020   SLTIU V0, A0, 32
9D01BD74  0B406F7F   J 0x9D01BDFC
9D01BD78  00000000   NOP
9D01BD7C  1082001B   BEQ A0, V0, 0x9D01BDEC
9D01BD80  2C82000F   SLTIU V0, A0, 15
9D01BD84  14400016   BNE V0, ZERO, 0x9D01BDE0
9D01BD88  2402001B   ADDIU V0, ZERO, 27
9D01BD8C  10820019   BEQ A0, V0, 0x9D01BDF4
9D01BD90  24020001   ADDIU V0, ZERO, 1
9D01BD94  2402007F   ADDIU V0, ZERO, 127
9D01BD98  14820018   BNE A0, V0, 0x9D01BDFC
9D01BD9C  2C820020   SLTIU V0, A0, 32
118:                 				{
119:                 				case 0x07: /* BEL */
120:                 					break;   /* ignore bells */
121:                 				case '\b': /* backspace */
122:                 					video_cback();
9D01BDA8  0F406C3F   JAL video_cback
9D01BDAC  00000000   NOP
123:                 					video_putc_raw(' ');
9D01BDB0  0F406F1F   JAL video_putc_raw
9D01BDB4  24040020   ADDIU A0, ZERO, 32
124:                 					video_cback();
9D01BDB8  0F406C3F   JAL video_cback
9D01BDBC  00000000   NOP
125:                 					break;
9D01BDC0  0B406F84   J 0x9D01BE10
9D01BDC4  8FBF0014   LW RA, 20(SP)
126:                 				case 0x0A: /* LF, VT, and FF all print a linefeed */
127:                 				case 0x0B:
128:                 				case 0x0C:
129:                 					video_setx(0);
9D01BDC8  0F406BA5   JAL video_setx
9D01BDCC  00002021   ADDU A0, ZERO, ZERO
130:                 					video_lf();
9D01BDD0  0F406C24   JAL video_lf
9D01BDD4  00000000   NOP
131:                 					break;
9D01BDD8  0B406F84   J 0x9D01BE10
9D01BDDC  8FBF0014   LW RA, 20(SP)
132:                 				case 0x0D: /* CR */
133:                 //       video_setx(0);
134:                 					break;
135:                 				case 0x0E: /* SO; enable box-drawing characters */
136:                 					graphicchars = 1;
9D01BDE0  24020001   ADDIU V0, ZERO, 1
137:                 					break;
9D01BDE4  0B406F83   J .LVL207
9D01BDE8  A3828185   SB V0, -32379(GP)
138:                 				case 0x0F: /* SI; return to normal characters */
139:                 					graphicchars = 0;
140:                 					break;
9D01BDEC  0B406F83   J .LVL207
9D01BDF0  A3808185   SB ZERO, -32379(GP)
141:                 				case 0x1B: /* ESC */
142:                 					in_esc = ESC_GOT_1B;
143:                 					break;
9D01BDF4  0B406F83   J .LVL207
9D01BDF8  A382818C   SB V0, -32372(GP)
144:                 				case 0x7F: /* DEL */
145:                 					break;
146:                 				default:
147:                 					if (c >= ' ')
9D01BD64  0B406F7F   J 0x9D01BDFC
9D01BD68  2C820020   SLTIU V0, A0, 32
9D01BDFC  14400004   BNE V0, ZERO, 0x9D01BE10
9D01BE00  8FBF0014   LW RA, 20(SP)
148:                 						{
149:                 //jar
150:                 						/*
151:                 						          if (graphicchars && c >= '_' && c <= '~')
152:                 						            c -= 95;
153:                 						          c |= revvideo;
154:                 						*/
155:                 						video_putc_raw(c);
9D01BE04  0F406F1F   JAL video_putc_raw
9D01BE08  7C042420   SEB A0, A0
156:                 						}
157:                 				}
158:                 		}
159:                 	}
9D01BDA0  0B406F84   J 0x9D01BE10
9D01BDA4  8FBF0014   LW RA, 20(SP)
9D01BE0C  8FBF0014   LW RA, 20(SP)
9D01BE10  03E00008   JR RA
9D01BE14  27BD0018   ADDIU SP, SP, 24
160:                 
161:                 
162:                 void escseq_process(int8_t c)
163:                 	{
9D01BB4C  27BDFFE8   ADDIU SP, SP, -24
164:                 	/* CAN and SUB interrupt escape sequences */
165:                 	if (c == 0x18 || c == 0x1A)
9D01BB50  2402FFFD   ADDIU V0, ZERO, -3
9D01BB54  00821824   AND V1, A0, V0
9D01BB58  24020018   ADDIU V0, ZERO, 24
9D01BB5C  14620003   BNE V1, V0, 0x9D01BB6C
9D01BB60  AFBF0014   SW RA, 20(SP)
166:                 		{
167:                 		in_esc = NOT_IN_ESC;
168:                 		return;
9D01BB64  0B406EEC   J .LVL183
9D01BB68  A380818C   SB ZERO, -32372(GP)
169:                 		}
170:                 
171:                 	if (in_esc == ESC_CSI)
9D01BB6C  9382818C   LBU V0, -32372(GP)
9D01BB70  24030002   ADDIU V1, ZERO, 2
9D01BB74  14430005   BNE V0, V1, 0x9D01BB8C
9D01BB78  24030003   ADDIU V1, ZERO, 3
172:                 		escseq_process_csi(c);
9D01BB7C  0F406DCD   JAL escseq_process_csi
9D01BB80  00000000   NOP
9D01BB84  0B406EED   J 0x9D01BBB4
9D01BB88  8FBF0014   LW RA, 20(SP)
173:                 	else if (in_esc == ESC_NONCSI)
9D01BB8C  14430003   BNE V0, V1, 0x9D01BB9C
9D01BB90  24030001   ADDIU V1, ZERO, 1
9D01BB94  0B406EEC   J .LVL183
9D01BB98  A380818C   SB ZERO, -32372(GP)
174:                 		{
175:                 		/* received a non-CSI sequence that requires a parameter
176:                 		 * (ESC #, ESC %, etc)
177:                 		 * These aren't supported, so eat this character */
178:                 		in_esc = NOT_IN_ESC;
179:                 		}
180:                 	else if (in_esc == ESC_GOT_1B)
9D01BB9C  14430005   BNE V0, V1, 0x9D01BBB4
9D01BBA0  8FBF0014   LW RA, 20(SP)
181:                 		{
182:                 		in_esc = ESC_NONCSI;
9D01BBA4  24020003   ADDIU V0, ZERO, 3
183:                 		escseq_process_noncsi(c);
9D01BBA8  0F406C73   JAL escseq_process_noncsi
9D01BBAC  A382818C   SB V0, -32372(GP)
184:                 		}
185:                 	}
9D01BBB0  8FBF0014   LW RA, 20(SP)
9D01BBB4  03E00008   JR RA
9D01BBB8  27BD0018   ADDIU SP, SP, 24
186:                 
187:                 /* Process sequences that begin with ESC */
188:                 void escseq_process_noncsi(int8_t c)
189:                 	{
9D01B1CC  27BDFFE8   ADDIU SP, SP, -24
190:                 	switch (c)
9D01B1D0  2484FFDD   ADDIU A0, A0, -35
9D01B1D4  308200FF   ANDI V0, A0, 255
9D01B1D8  2C420041   SLTIU V0, V0, 65
9D01B1DC  10400074   BEQ V0, ZERO, .LVL86, .L116
9D01B1E0  AFBF0014   SW RA, 20(SP)
9D01B1E4  308400FF   ANDI A0, A0, 255
9D01B1E8  00042080   SLL A0, A0, 2
9D01B1EC  3C029D02   LUI V0, -25342
9D01B1F0  2442B204   ADDIU V0, V0, -19964
9D01B1F4  00442021   ADDU A0, V0, A0
9D01B1F8  8C820000   LW V0, 0(A0)
9D01B1FC  00400008   JR V0
9D01B200  00000000   NOP
191:                 		{
192:                 		case '[': /* got the [; this is a CSI sequence */
193:                 			escseq_csi_start();
9D01B308  0F406B4A   JAL escseq_csi_start
9D01B30C  00000000   NOP
194:                 			in_esc = ESC_CSI;
9D01B310  24020002   ADDIU V0, ZERO, 2
195:                 			break;
9D01B314  0B406CED   J 0x9D01B3B4
9D01B318  A382818C   SB V0, -32372(GP)
196:                 		case '%': /* non-CSI codes that require parameters */
197:                 		case '#': /* (we don't support these) */
198:                 		case '(':
199:                 		case ')':
200:                 			break;  /* return without setting in_esc to NOT_IN_ESC */
201:                 		case '7': /* save cursor position and attributes */
202:                 			save_term_state();
9D01B31C  0F406B7A   JAL save_term_state
9D01B320  00000000   NOP
203:                 			goto esc_done;
9D01B324  0B406CED   J 0x9D01B3B4
9D01B328  A380818C   SB ZERO, -32372(GP)
204:                 		case '8': /* restore cursor position and attributes */
205:                 			restore_term_state();
9D01B32C  0F406B7F   JAL restore_term_state
9D01B330  00000000   NOP
206:                 			goto esc_done;
9D01B334  0B406CED   J 0x9D01B3B4
9D01B338  A380818C   SB ZERO, -32372(GP)
207:                 		case 'E': /* next line */
208:                 			video_movesol(); /* fall through */
209:                 		case 'D': /* index */
210:                 
211:                 			if (video_gety() == video_bottom_margin())
9D01B340  8383818F   LB V1, -32369(GP)
9D01B344  8382817C   LB V0, -32388(GP)
9D01B348  14620005   BNE V1, V0, 0x9D01B360
9D01B34C  00000000   NOP
212:                 				video_scrollup();
213:                 			else
214:                 				video_movey(1);
9D01B360  0F406BFE   JAL video_movey
9D01B364  24040001   ADDIU A0, ZERO, 1
215:                 			goto esc_done;
216:                 		case 'M': /* reverse index */
217:                 			if (video_gety() == video_top_margin())
9D01B370  8383818F   LB V1, -32369(GP)
9D01B374  8382817D   LB V0, -32387(GP)
9D01B378  14620005   BNE V1, V0, 0x9D01B390
9D01B37C  00000000   NOP
218:                 				video_scrolldown();
219:                 			else
220:                 				video_movey(-1);
9D01B390  0F406BFE   JAL video_movey
9D01B394  2404FFFF   ADDIU A0, ZERO, -1
221:                 			goto esc_done;
222:                 		case 'c': /* reset */
223:                 			video_clrscr();
9D01B3A0  0F406C60   JAL video_clrscr
9D01B3A4  00000000   NOP
224:                 			reset_term();
9D01B3A8  0F406B84   JAL reset_term
9D01B3AC  00000000   NOP
225:                 			goto esc_done;
226:                 		default: /* other non-CSI codes */
227:                 esc_done:
228:                 			in_esc = NOT_IN_ESC; /* unimplemented */
9D01B358  0B406CED   J 0x9D01B3B4
9D01B35C  A380818C   SB ZERO, -32372(GP)
9D01B368  0B406CED   J 0x9D01B3B4
9D01B36C  A380818C   SB ZERO, -32372(GP)
9D01B388  0B406CED   J 0x9D01B3B4
9D01B38C  A380818C   SB ZERO, -32372(GP)
9D01B398  0B406CED   J 0x9D01B3B4
9D01B39C  A380818C   SB ZERO, -32372(GP)
9D01B3B0  A380818C   SB ZERO, -32372(GP)
229:                 			break;
230:                 		}
231:                 	}
9D01B3B4  8FBF0014   LW RA, 20(SP)
9D01B3B8  03E00008   JR RA
9D01B3BC  27BD0018   ADDIU SP, SP, 24
232:                 
233:                 /* Process sequences that begin with ESC [ */
234:                 void escseq_process_csi(int8_t c)
235:                 	{
9D01B734  27BDFFE0   ADDIU SP, SP, -32
9D01B738  AFBF001C   SW RA, 28(SP)
9D01B73C  AFB20018   SW S2, 24(SP)
9D01B740  AFB10014   SW S1, 20(SP)
236:                 	if ((c >= '0' && c <= '9') || c == ';' || c == '?') /* digit or separator */
9D01B744  2482FFD0   ADDIU V0, A0, -48
9D01B748  304200FF   ANDI V0, V0, 255
9D01B74C  2C42000A   SLTIU V0, V0, 10
9D01B750  14400006   BNE V0, ZERO, 0x9D01B76C
9D01B754  AFB00010   SW S0, 16(SP)
9D01B758  2402FFFB   ADDIU V0, ZERO, -5
9D01B75C  00821824   AND V1, A0, V0
9D01B760  2402003B   ADDIU V0, ZERO, 59
9D01B764  5462000D   BNEL V1, V0, 0x9D01B79C
9D01B768  2484FFBF   ADDIU A0, A0, -65
237:                 		{
238:                 		/* save the character */
239:                 		if (paramch >= MAX_ESC_LEN) /* received too many characters */
9D01B76C  93828186   LBU V0, -32378(GP)
9D01B770  2C430030   SLTIU V1, V0, 48
9D01B774  14600003   BNE V1, ZERO, 0x9D01B784
9D01B778  3C03A001   LUI V1, -24575
240:                 			{
241:                 			in_esc = NOT_IN_ESC;
242:                 			return;
9D01B77C  0B406ECD   J 0x9D01BB34
9D01B780  A380818C   SB ZERO, -32372(GP)
243:                 			}
244:                 		paramstr[paramch] = c;
9D01B784  2463B690   ADDIU V1, V1, -18800
9D01B788  00431821   ADDU V1, V0, V1
9D01B78C  A0640000   SB A0, 0(V1)
245:                 		paramch++;
9D01B790  24420001   ADDIU V0, V0, 1
9D01B794  0B406ECD   J 0x9D01BB34
9D01B798  A3828186   SB V0, -32378(GP)
246:                 		}
247:                 	else
248:                 		{
249:                 		/* take the appropriate action */
250:                 		switch (c)
9D01B79C  308200FF   ANDI V0, A0, 255
9D01B7A0  2C420032   SLTIU V0, V0, 50
9D01B7A4  104000E2   BEQ V0, ZERO, .LVL179, .LBE53
9D01B7A8  308400FF   ANDI A0, A0, 255
9D01B7AC  00042080   SLL A0, A0, 2
9D01B7B0  3C029D02   LUI V0, -25342
9D01B7B4  2442B7C8   ADDIU V0, V0, -18488
9D01B7B8  00441021   ADDU V0, V0, A0
9D01B7BC  8C420000   LW V0, 0(V0)
9D01B7C0  00400008   JR V0
9D01B7C4  00000000   NOP
251:                 			{
252:                 			case 'A': /* cursor up */
253:                 				video_movey(-escseq_get_param(1));
9D01B8A0  0F406B5C   JAL escseq_get_param
9D01B8A4  24040001   ADDIU A0, ZERO, 1
9D01B8A8  00021023   SUBU V0, ZERO, V0
9D01B8AC  0F406BFE   JAL video_movey
9D01B8B0  7C022420   SEB A0, V0
254:                 				break;
9D01B8B4  0B406ECD   J 0x9D01BB34
9D01B8B8  A380818C   SB ZERO, -32372(GP)
255:                 			case 'B': /* cursor down */
256:                 				video_movey(escseq_get_param(1));
9D01B8BC  0F406B5C   JAL escseq_get_param
9D01B8C0  24040001   ADDIU A0, ZERO, 1
9D01B8C4  0F406BFE   JAL video_movey
9D01B8C8  7C022420   SEB A0, V0
257:                 				break;
9D01B8CC  0B406ECD   J 0x9D01BB34
9D01B8D0  A380818C   SB ZERO, -32372(GP)
258:                 			case 'C': /* cursor forward */
259:                 				video_movex(escseq_get_param(1));
9D01B8D4  0F406B5C   JAL escseq_get_param
9D01B8D8  24040001   ADDIU A0, ZERO, 1
9D01B8DC  0F406BF1   JAL video_movex
9D01B8E0  7C022420   SEB A0, V0
260:                 				break;
9D01B8E4  0B406ECD   J 0x9D01BB34
9D01B8E8  A380818C   SB ZERO, -32372(GP)
261:                 			case 'D': /* cursor back */
262:                 				video_movex(-escseq_get_param(1));
9D01B8EC  0F406B5C   JAL escseq_get_param
9D01B8F0  24040001   ADDIU A0, ZERO, 1
9D01B8F4  00021023   SUBU V0, ZERO, V0
9D01B8F8  0F406BF1   JAL video_movex
9D01B8FC  7C022420   SEB A0, V0
263:                 				break;
9D01B900  0B406ECD   J 0x9D01BB34
9D01B904  A380818C   SB ZERO, -32372(GP)
264:                 			case 'E': /* cursor to next line */
265:                 				video_movey(escseq_get_param(1));
9D01B908  0F406B5C   JAL escseq_get_param
9D01B90C  24040001   ADDIU A0, ZERO, 1
9D01B910  0F406BFE   JAL video_movey
9D01B914  7C022420   SEB A0, V0
266:                 				video_movesol();
267:                 				break;
268:                 			case 'F': /* cursor to previous line */
269:                 				video_movey(-escseq_get_param(1));
9D01B920  0F406B5C   JAL escseq_get_param
9D01B924  24040001   ADDIU A0, ZERO, 1
9D01B928  00021023   SUBU V0, ZERO, V0
9D01B92C  0F406BFE   JAL video_movey
9D01B930  7C022420   SEB A0, V0
270:                 				video_movesol();
271:                 				break;
272:                 			case 'G': /* cursor horizontal absolute */
273:                 				video_setx(escseq_get_param(1)-1); /* one-indexed */
9D01B93C  0F406B5C   JAL escseq_get_param
9D01B940  24040001   ADDIU A0, ZERO, 1
9D01B944  2442FFFF   ADDIU V0, V0, -1
9D01B948  0F406BA5   JAL video_setx
9D01B94C  7C022420   SEB A0, V0
274:                 				break;
9D01B950  0B406ECD   J 0x9D01BB34
9D01B954  A380818C   SB ZERO, -32372(GP)
275:                 			case 'H':
276:                 			case 'f': /* horizonal and vertical position */
277:                 				{
278:                 				uint8_t y = escseq_get_param(1);
9D01B958  0F406B5C   JAL escseq_get_param
9D01B95C  24040001   ADDIU A0, ZERO, 1
9D01B960  00408021   ADDU S0, V0, ZERO
279:                 				uint8_t x = escseq_get_param(1);
9D01B964  0F406B5C   JAL escseq_get_param
9D01B968  24040001   ADDIU A0, ZERO, 1
280:                 				video_gotoxy(x-1, y-1);
9D01B96C  2442FFFF   ADDIU V0, V0, -1
9D01B970  2605FFFF   ADDIU A1, S0, -1
9D01B974  7C022420   SEB A0, V0
9D01B978  0F406BAF   JAL video_gotoxy
9D01B97C  7C052C20   SEB A1, A1
281:                 				break;
9D01B980  0B406ECD   J 0x9D01BB34
9D01B984  A380818C   SB ZERO, -32372(GP)
282:                 				}
283:                 			case 'J': /* erase */
284:                 				video_erase(escseq_get_param(0));
9D01B988  0F406B5C   JAL escseq_get_param
9D01B98C  00002021   ADDU A0, ZERO, ZERO
9D01B990  0F406D25   JAL video_erase
9D01B994  00402021   ADDU A0, V0, ZERO
285:                 				break;
9D01B998  0B406ECD   J 0x9D01BB34
9D01B99C  A380818C   SB ZERO, -32372(GP)
286:                 			case 'K': /* erase in line */
287:                 				video_eraseline(escseq_get_param(0));
9D01B9A0  0F406B5C   JAL escseq_get_param
9D01B9A4  00002021   ADDU A0, ZERO, ZERO
9D01B9A8  0F406D7F   JAL video_eraseline
9D01B9AC  00402021   ADDU A0, V0, ZERO
288:                 				break;
9D01B9B0  0B406ECD   J 0x9D01BB34
9D01B9B4  A380818C   SB ZERO, -32372(GP)
289:                 			case 'L': /* erase in line */
290:                 //jar
291:                 				_video_scrolldown_lin(video_gety());
9D01B9B8  938B818F   LBU T3, -32369(GP)
292:                 				break;
293:                 			case 'M': /* erase in line */
294:                 //jar
295:                 				_video_scrollup_lin(video_gety());
296:                 				break;
297:                 
298:                 			case 'm': /* set graphic rendition */
299:                 				while (paramptr) /* read attributes until we reach the end */
9D01BAF4  8F828188   LW V0, -32376(GP)
9D01BAF8  1440FFF4   BNE V0, ZERO, .LBE51, .LBE50
9D01BAFC  00000000   NOP
9D01BB00  0B406ECD   J 0x9D01BB34
9D01BB04  A380818C   SB ZERO, -32372(GP)
300:                 					{
301:                 					uint8_t attr = escseq_get_param(0);
9D01BACC  0F406B5C   JAL escseq_get_param
9D01BAD0  00002021   ADDU A0, ZERO, ZERO
302:                 					if (attr == 0 || attr == 27)
9D01B890  2410001B   ADDIU S0, ZERO, 27
9D01BAD4  50400007   BEQL V0, ZERO, 0x9D01BAF4
9D01BAD8  A3808184   SB ZERO, -32380(GP)
9D01BADC  14500003   BNE V0, S0, 0x9D01BAEC
9D01BAE0  00000000   NOP
303:                 						revvideo = 0;
9D01BAE4  0B406EBD   J 0x9D01BAF4
9D01BAE8  A3808184   SB ZERO, -32380(GP)
304:                 					else if (attr == 7)
9D01B894  24110007   ADDIU S1, ZERO, 7
9D01BAEC  50510001   BEQL V0, S1, 0x9D01BAF4
9D01BAF0  A3928184   SB S2, -32380(GP)
305:                 						revvideo = 0x80;
9D01B898  0B406EBD   J 0x9D01BAF4
9D01B89C  2412FF80   ADDIU S2, ZERO, -128
306:                 					}
307:                 				break;
308:                 			case 'r': /* set top and bottom margins */
309:                 				{
310:                 				uint8_t top = escseq_get_param(1);
9D01BB08  0F406B5C   JAL escseq_get_param
9D01BB0C  24040001   ADDIU A0, ZERO, 1
9D01BB10  00408021   ADDU S0, V0, ZERO
311:                 				uint8_t bottom = escseq_get_param(DISP_BUFFER_HIGH);
9D01BB14  0F406B5C   JAL escseq_get_param
9D01BB18  24040014   ADDIU A0, ZERO, 20
312:                 				video_set_margins(top-1, bottom-1);
9D01BB1C  2604FFFF   ADDIU A0, S0, -1
9D01BB20  2442FFFF   ADDIU V0, V0, -1
9D01BB24  7C042420   SEB A0, A0
9D01BB28  0F406BC1   JAL video_set_margins
9D01BB2C  7C022C20   SEB A1, V0
313:                 				break;
314:                 				}
315:                 			default: /* unknown */
316:                 				break;
317:                 			}
318:                 
319:                 		in_esc = NOT_IN_ESC;
9D01BB30  A380818C   SB ZERO, -32372(GP)
320:                 		}
321:                 	}
9D01BB34  8FBF001C   LW RA, 28(SP)
9D01BB38  8FB20018   LW S2, 24(SP)
9D01BB3C  8FB10014   LW S1, 20(SP)
9D01BB40  8FB00010   LW S0, 16(SP)
9D01BB44  03E00008   JR RA
9D01BB48  27BD0020   ADDIU SP, SP, 32
322:                 
323:                 void escseq_csi_start()
324:                 	{
325:                 	paramch = 0;
9D01AD28  A3808186   SB ZERO, -32378(GP)
326:                 	memset(paramstr, 0, MAX_ESC_LEN+1);
9D01AD2C  3C02A001   LUI V0, -24575
9D01AD30  AC40B690   SW ZERO, -18800(V0)
9D01AD34  2442B690   ADDIU V0, V0, -18800
9D01AD38  AC400004   SW ZERO, 4(V0)
9D01AD3C  AC400008   SW ZERO, 8(V0)
9D01AD40  AC40000C   SW ZERO, 12(V0)
9D01AD44  AC400010   SW ZERO, 16(V0)
9D01AD48  AC400014   SW ZERO, 20(V0)
9D01AD4C  AC400018   SW ZERO, 24(V0)
9D01AD50  AC40001C   SW ZERO, 28(V0)
9D01AD54  AC400020   SW ZERO, 32(V0)
9D01AD58  AC400024   SW ZERO, 36(V0)
9D01AD5C  AC400028   SW ZERO, 40(V0)
9D01AD60  AC40002C   SW ZERO, 44(V0)
9D01AD64  A0400030   SB ZERO, 48(V0)
327:                 	paramptr = &paramstr[0];
9D01AD68  03E00008   JR RA
9D01AD6C  AF828188   SW V0, -32376(GP)
328:                 	}
329:                 
330:                 uint8_t escseq_get_param(uint8_t defaultval)
331:                 	{
9D01AD70  27BDFFE0   ADDIU SP, SP, -32
9D01AD74  AFBF001C   SW RA, 28(SP)
9D01AD78  AFB10018   SW S1, 24(SP)
9D01AD7C  AFB00014   SW S0, 20(SP)
332:                 	uint8_t val;
333:                 	int8_t *startptr;
334:                 	int8_t *endptr;
335:                 
336:                 	if (!paramptr)
9D01AD80  8F908188   LW S0, -32376(GP)
9D01AD84  12000012   BEQ S0, ZERO, 0x9D01ADD0
9D01AD88  00808821   ADDU S1, A0, ZERO
337:                 		return defaultval;
338:                 
339:                 	val = defaultval;
340:                 	startptr = paramptr;
341:                 	/* get everything up to the semicolon, move past it */
342:                 	endptr = strchr(paramptr, ';');
9D01AD8C  02002021   ADDU A0, S0, ZERO
9D01AD90  0F40E513   JAL strchr
9D01AD94  2405003B   ADDIU A1, ZERO, 59
343:                 	if (endptr)
9D01AD98  10400004   BEQ V0, ZERO, 0x9D01ADAC
9D01AD9C  24430001   ADDIU V1, V0, 1
344:                 		{
345:                 		*endptr = '\0'; /* replace the semicolon to make atoi stop here */
9D01ADA0  A0400000   SB ZERO, 0(V0)
9D01ADA4  0B406B6C   J 0x9D01ADB0
9D01ADA8  AF838188   SW V1, -32376(GP)
346:                 		paramptr = endptr+1;
347:                 		}
348:                 	else
349:                 		paramptr = NULL;
9D01ADAC  AF808188   SW ZERO, -32376(GP)
350:                 
351:                 	/* ascii to integer, as long as the string isn't empty */
352:                 	/* default value is given if the string is empty */
353:                 	if (*startptr)
9D01ADB0  82020000   LB V0, 0(S0)
9D01ADB4  10400007   BEQ V0, ZERO, 0x9D01ADD4
9D01ADB8  02201021   ADDU V0, S1, ZERO
354:                 		val = atoi(startptr); /* will read up to the null */
9D01ADBC  02002021   ADDU A0, S0, ZERO
9D01ADC0  00002821   ADDU A1, ZERO, ZERO
9D01ADC4  0F40D18C   JAL strtol
9D01ADC8  2406000A   ADDIU A2, ZERO, 10
9D01ADCC  305100FF   ANDI S1, V0, 255
355:                 
356:                 
357:                 	return val;
358:                 	}
9D01ADD0  02201021   ADDU V0, S1, ZERO
9D01ADD4  8FBF001C   LW RA, 28(SP)
9D01ADD8  8FB10018   LW S1, 24(SP)
9D01ADDC  8FB00014   LW S0, 20(SP)
9D01ADE0  03E00008   JR RA
9D01ADE4  27BD0020   ADDIU SP, SP, 32
359:                 
360:                 void save_term_state()
361:                 	{
362:                 //jar
363:                 //  savedstate.cx = video_getx();
364:                 //  savedstate.cy = video_gety();
365:                 	savedstate.graphicchars = graphicchars;
9D01ADE8  93828185   LBU V0, -32379(GP)
9D01ADEC  A3828182   SB V0, -32382(GP)
366:                 	savedstate.revvideo = revvideo;
9D01ADF0  93828184   LBU V0, -32380(GP)
9D01ADF4  03E00008   JR RA
9D01ADF8  A3828183   SB V0, -32381(GP)
367:                 	}
368:                 
369:                 void restore_term_state()
370:                 	{
371:                 //jar
372:                 //  video_gotoxy(savedstate.cx, savedstate.cy);
373:                 	graphicchars = savedstate.graphicchars;
9D01ADFC  93828182   LBU V0, -32382(GP)
9D01AE00  A3828185   SB V0, -32379(GP)
374:                 	revvideo = savedstate.revvideo;
9D01AE04  93828183   LBU V0, -32381(GP)
9D01AE08  03E00008   JR RA
9D01AE0C  A3828184   SB V0, -32380(GP)
375:                 	}
376:                 
377:                 void reset_term()
378:                 	{
9D01AE10  27BDFFE8   ADDIU SP, SP, -24
9D01AE14  AFBF0014   SW RA, 20(SP)
379:                 	graphicchars = 0;
9D01AE18  A3808185   SB ZERO, -32379(GP)
380:                 	revvideo = 0;
9D01AE1C  A3808184   SB ZERO, -32380(GP)
381:                 	in_esc = 0;
382:                 	save_term_state();
9D01AE20  0F406B7A   JAL save_term_state
9D01AE24  A380818C   SB ZERO, -32372(GP)
383:                 	}
9D01AE28  8FBF0014   LW RA, 20(SP)
9D01AE2C  03E00008   JR RA
9D01AE30  27BD0018   ADDIU SP, SP, 24
384:                 
385:                 
386:                 void video_reset_margins()
387:                 	{
9D01AF58  27BDFFE8   ADDIU SP, SP, -24
9D01AF5C  AFBF0014   SW RA, 20(SP)
388:                 	video_set_margins(0, DISP_BUFFER_HIGH-1);
9D01AF60  00002021   ADDU A0, ZERO, ZERO
9D01AF64  0F406BC1   JAL video_set_margins
9D01AF68  24050013   ADDIU A1, ZERO, 19
389:                 	}
9D01AF6C  8FBF0014   LW RA, 20(SP)
9D01AF70  03E00008   JR RA
9D01AF74  27BD0018   ADDIU SP, SP, 24
390:                 
391:                 void video_set_margins(int8_t top, int8_t bottom)
392:                 	{
9D01AF04  27BDFFE8   ADDIU SP, SP, -24
9D01AF08  00041027   NOR V0, ZERO, A0
9D01AF0C  000217C3   SRA V0, V0, 31
9D01AF10  00442024   AND A0, V0, A0
9D01AF14  00A01021   ADDU V0, A1, ZERO
9D01AF18  28A50014   SLTI A1, A1, 20
9D01AF1C  14A00002   BNE A1, ZERO, 0x9D01AF28
9D01AF20  AFBF0014   SW RA, 20(SP)
9D01AF24  24020013   ADDIU V0, ZERO, 19
9D01AF28  7C021420   SEB V0, V0
393:                 	/* sanitize input */
394:                 	if (top < 0) top = 0;
395:                 	if (bottom >= DISP_BUFFER_HIGH) bottom = DISP_BUFFER_HIGH-1;
396:                 	if (top >= bottom)
9D01AF2C  0082182A   SLT V1, A0, V0
397:                 		{
398:                 		top = 0;
399:                 		bottom = DISP_BUFFER_HIGH-1;
9D01AF30  24050013   ADDIU A1, ZERO, 19
9D01AF34  00A3100A   MOVZ V0, A1, V1
9D01AF38  0003200A   MOVZ A0, ZERO, V1
400:                 		}
401:                 
402:                 	mtop = top;
9D01AF3C  A384817D   SB A0, -32387(GP)
403:                 	mbottom = bottom;
9D01AF40  A382817C   SB V0, -32388(GP)
404:                 	video_gotoxy(mtop, 0);
9D01AF44  0F406BAF   JAL video_gotoxy
9D01AF48  00002821   ADDU A1, ZERO, ZERO
405:                 	}
9D01AF4C  8FBF0014   LW RA, 20(SP)
9D01AF50  03E00008   JR RA
9D01AF54  27BD0018   ADDIU SP, SP, 24
406:                 
407:                 int8_t video_top_margin()
408:                 	{
409:                 	return mtop;
410:                 	}
9D01AE34  03E00008   JR RA
9D01AE38  8382817D   LB V0, -32387(GP)
411:                 
412:                 int8_t video_bottom_margin()
413:                 	{
414:                 	return mbottom;
415:                 	}
9D01AE3C  03E00008   JR RA
9D01AE40  8382817C   LB V0, -32388(GP)
416:                 
417:                 void video_set_reverse(uint8_t val)
418:                 	{
419:                 	revvideo = (val) ? 0x80 : 0;
9D01AE44  24020080   ADDIU V0, ZERO, 128
9D01AE48  0004100A   MOVZ V0, ZERO, A0
9D01AE4C  03E00008   JR RA
9D01AE50  A3828184   SB V0, -32380(GP)
420:                 	}
421:                 
422:                 static void _video_scrollup()
423:                 	{
424:                 	uint8_t i,j;
425:                 //jar
426:                 	/*
427:                 	  memmove(&disp_buffer[mtop], &disp_buffer[mtop+1], (mbottom-mtop)*DISP_BUFFER_WIDE);
428:                 	  memset(&disp_buffer[mbottom], revvideo, DISP_BUFFER_WIDE);
429:                 	*/
430:                 	for (j=1; j<(mbottom+1); j++)
9D01A97C  838B817C   LB T3, -32388(GP)
9D01A980  25680001   ADDIU T0, T3, 1
9D01A984  29020002   SLTI V0, T0, 2
9D01A988  14400023   BNE V0, ZERO, 0x9D01AA18
9D01A98C  3C0AA000   LUI T2, -24576
9D01A990  24020001   ADDIU V0, ZERO, 1
9D01A994  24060001   ADDIU A2, ZERO, 1
9D01A998  3C07A000   LUI A3, -24576
9D01A99C  24E71E5C   ADDIU A3, A3, 7772
9D01A9A0  254A1B14   ADDIU T2, T2, 6932
9D01A9A4  0B406A77   J 0x9D01A9DC
9D01A9A8  24E90028   ADDIU T1, A3, 40
9D01A9C8  24C60001   ADDIU A2, A2, 1
9D01A9CC  30C600FF   ANDI A2, A2, 255
9D01A9D0  00C8182A   SLT V1, A2, T0
9D01A9D4  10600010   BEQ V1, ZERO, 0x9D01AA18
9D01A9D8  00C01021   ADDU V0, A2, ZERO
9D01A9DC  000228C0   SLL A1, V0, 3
9D01A9E0  00021140   SLL V0, V0, 5
9D01A9E4  00A22821   ADDU A1, A1, V0
9D01A9E8  00E51021   ADDU V0, A3, A1
9D01A9EC  01451821   ADDU V1, T2, A1
9D01A9F0  0B406A6B   J 0x9D01A9AC
9D01A9F4  01252821   ADDU A1, T1, A1
9D01A9F8  00E21821   ADDU V1, A3, V0
9D01AA3C  00001021   ADDU V0, ZERO, ZERO
431:                 		{
432:                 		for (i=0; i<DISP_BUFFER_WIDE; i++)
9D01A9C0  1445FFFA   BNE V0, A1, 0x9D01A9AC
9D01A9C4  24630001   ADDIU V1, V1, 1
433:                 			{
434:                 			disp_buffer[j-1][i] = disp_buffer[j][i];
9D01A9AC  90440000   LBU A0, 0(V0)
9D01A9B0  A044FFD8   SB A0, -40(V0)
435:                 			color_buffer[j-1][i] = color_buffer[j][i];
9D01A9B4  90640000   LBU A0, 0(V1)
9D01A9B8  A064FFD8   SB A0, -40(V1)
9D01A9BC  24420001   ADDIU V0, V0, 1
436:                 			}
437:                 		}
438:                 	for (i=0; i<DISP_BUFFER_WIDE; i++)
9D01AA08  1444FFFB   BNE V0, A0, 0x9D01A9F8
9D01AA0C  A0600000   SB ZERO, 0(V1)
9D01AA10  03E00008   JR RA
9D01AA14  00000000   NOP
9D01AA18  000B10C0   SLL V0, T3, 3
9D01AA1C  000B5940   SLL T3, T3, 5
9D01AA20  004B1021   ADDU V0, V0, T3
9D01AA24  3C07A000   LUI A3, -24576
9D01AA28  24E71E5C   ADDIU A3, A3, 7772
9D01AA2C  00E23821   ADDU A3, A3, V0
9D01AA30  3C06A000   LUI A2, -24576
9D01AA34  24C61B14   ADDIU A2, A2, 6932
9D01AA38  00C23021   ADDU A2, A2, V0
9D01AA44  0B406A7E   J 0x9D01A9F8
9D01AA48  24040028   ADDIU A0, ZERO, 40
439:                 		{
440:                 		disp_buffer[mbottom][i] = ' ';
9D01A9FC  A0650000   SB A1, 0(V1)
9D01AA00  00C21821   ADDU V1, A2, V0
9D01AA04  24420001   ADDIU V0, V0, 1
9D01AA40  24050020   ADDIU A1, ZERO, 32
9D01AA44  0B406A7E   J 0x9D01A9F8
9D01AA48  24040028   ADDIU A0, ZERO, 40
441:                 		color_buffer[mbottom][i] = 0;
442:                 		}
443:                 
444:                 	}
445:                 
446:                 static void _video_scrollup_lin(uint8_t lin)
447:                 	{
448:                 	uint8_t i,j;
449:                 //jar
450:                 	/*
451:                 	  memmove(&disp_buffer[mtop], &disp_buffer[mtop+1], (mbottom-mtop)*DISP_BUFFER_WIDE);
452:                 	  memset(&disp_buffer[mbottom], revvideo, DISP_BUFFER_WIDE);
453:                 	*/
454:                 	for (j=(lin+1); j<(mbottom+1); j++)
9D01BA48  9386818F   LBU A2, -32369(GP)
9D01BA9C  24C60001   ADDIU A2, A2, 1
455:                 		{
456:                 		for (i=0; i<DISP_BUFFER_WIDE; i++)
9D01BA94  1445FFFA   BNE V0, A1, 0x9D01BA80
457:                 			{
458:                 			disp_buffer[j-1][i] = disp_buffer[j][i];
9D01BA80  90440000   LBU A0, 0(V0)
459:                 			color_buffer[j-1][i] = color_buffer[j][i];
9D01BA88  90640000   LBU A0, 0(V1)
9D01BA8C  A064FFD8   SB A0, -40(V1)
9D01BA90  24420001   ADDIU V0, V0, 1
9D01BA94  1445FFFA   BNE V0, A1, 0x9D01BA80
9D01BA98  24630001   ADDIU V1, V1, 1
9D01BA9C  24C60001   ADDIU A2, A2, 1
9D01BAA0  30C600FF   ANDI A2, A2, 255
9D01BAA4  00C8182A   SLT V1, A2, T0
9D01BAA8  10600021   BEQ V1, ZERO, .LVL179, .LBE53
9D01BAAC  00C01021   ADDU V0, A2, ZERO
9D01BAB0  000228C0   SLL A1, V0, 3
9D01BAB4  00021140   SLL V0, V0, 5
9D01BAB8  00A22821   ADDU A1, A1, V0
9D01BABC  00E51021   ADDU V0, A3, A1
9D01BAC0  01451821   ADDU V1, T2, A1
9D01BAC4  0B406EA0   J 0x9D01BA80
9D01BAC8  01252821   ADDU A1, T1, A1
460:                 			}
461:                 		}
462:                 	/*
463:                 	for (i=0;i<DISP_BUFFER_WIDE;i++)
464:                 		{
465:                 		disp_buffer[lin][i] = ' ';
466:                 		}
467:                 	*/
468:                 	}
469:                 
470:                 static void _video_scrolldown()
471:                 	{
472:                 	uint8_t i,j;
473:                 //  memmove(&disp_buffer[mtop+1], &disp_buffer[mtop], (mbottom-mtop)*DISP_BUFFER_WIDE);
474:                 //  memset(&disp_buffer[mtop], revvideo, DISP_BUFFER_WIDE);
475:                 	for (j=mbottom; j>0; j--)
9D01AA4C  9389817C   LBU T1, -32388(GP)
9D01AA50  11200028   BEQ T1, ZERO, 0x9D01AAF4
9D01AA54  3C0AA000   LUI T2, -24576
9D01AA58  254A1E5C   ADDIU T2, T2, 7772
9D01AA5C  3C0BA000   LUI T3, -24576
9D01AA60  0B406AA9   J 0x9D01AAA4
9D01AA64  256B1B14   ADDIU T3, T3, 6932
9D01AA94  2529FFFF   ADDIU T1, T1, -1
9D01AA98  312900FF   ANDI T1, T1, 255
9D01AA9C  51200016   BEQL T1, ZERO, 0x9D01AAF8
9D01AAA0  8383817D   LB V1, -32387(GP)
476:                 		{
477:                 		for (i=0; i<DISP_BUFFER_WIDE; i++)
9D01AA8C  1448FFF6   BNE V0, T0, 0x9D01AA68
9D01AA90  24630001   ADDIU V1, V1, 1
478:                 			{
479:                 			disp_buffer[j][i] = disp_buffer[j-1][i];
9D01AA68  80470000   LB A3, 0(V0)
9D01AA6C  00453021   ADDU A2, V0, A1
9D01AA70  00C43021   ADDU A2, A2, A0
9D01AA74  A0C70028   SB A3, 40(A2)
9D01AAA4  2522FFFF   ADDIU V0, T1, -1
9D01AAA8  000218C0   SLL V1, V0, 3
9D01AAAC  00021140   SLL V0, V0, 5
9D01AAB0  00621821   ADDU V1, V1, V0
9D01AAB4  01431021   ADDU V0, T2, V1
9D01AAB8  01631821   ADDU V1, T3, V1
9D01AABC  000920C0   SLL A0, T1, 3
9D01AAC0  00092940   SLL A1, T1, 5
9D01AAC4  00852021   ADDU A0, A0, A1
9D01AAC8  01444021   ADDU T0, T2, A0
9D01AACC  0B406A9A   J 0x9D01AA68
9D01AAD0  00042823   SUBU A1, ZERO, A0
9D01AAD4  00E21821   ADDU V1, A3, V0
480:                 			color_buffer[j][i] = color_buffer[j-1][i];
9D01AA78  80670000   LB A3, 0(V1)
9D01AA7C  00653021   ADDU A2, V1, A1
9D01AA80  00C43021   ADDU A2, A2, A0
9D01AA84  A0C70028   SB A3, 40(A2)
9D01AA88  24420001   ADDIU V0, V0, 1
481:                 			}
482:                 		}
483:                 	for (i=0; i<DISP_BUFFER_WIDE; i++)
9D01AAE4  1444FFFB   BNE V0, A0, 0x9D01AAD4
9D01AAE8  A0600000   SB ZERO, 0(V1)
9D01AAEC  03E00008   JR RA
9D01AAF0  00000000   NOP
9D01AAF4  8383817D   LB V1, -32387(GP)
9D01AAF8  000310C0   SLL V0, V1, 3
9D01AAFC  00031940   SLL V1, V1, 5
9D01AB00  00431021   ADDU V0, V0, V1
9D01AB04  3C07A000   LUI A3, -24576
9D01AB08  24E71E5C   ADDIU A3, A3, 7772
9D01AB0C  00E23821   ADDU A3, A3, V0
9D01AB10  3C06A000   LUI A2, -24576
9D01AB14  24C61B14   ADDIU A2, A2, 6932
9D01AB18  00C23021   ADDU A2, A2, V0
9D01AB24  0B406AB5   J 0x9D01AAD4
9D01AB28  24040028   ADDIU A0, ZERO, 40
484:                 		{
485:                 		disp_buffer[mtop][i] = ' ';
9D01AAD8  A0650000   SB A1, 0(V1)
9D01AADC  00C21821   ADDU V1, A2, V0
9D01AAE0  24420001   ADDIU V0, V0, 1
9D01AB1C  00001021   ADDU V0, ZERO, ZERO
9D01AB20  24050020   ADDIU A1, ZERO, 32
9D01AB24  0B406AB5   J 0x9D01AAD4
9D01AB28  24040028   ADDIU A0, ZERO, 40
486:                 		color_buffer[mtop][i] = 0;
487:                 		}
488:                 	}
489:                 
490:                 static void _video_scrolldown_lin(uint8_t line)
491:                 	{
492:                 	uint8_t i,j;
493:                 //  memmove(&disp_buffer[mtop+1], &disp_buffer[mtop], (mbottom-mtop)*DISP_BUFFER_WIDE);
494:                 //  memset(&disp_buffer[mtop], revvideo, DISP_BUFFER_WIDE);
495:                 	for (j=mbottom; j>(line); j--)
9D01B9BC  9389817C   LBU T1, -32388(GP)
9D01BA08  2529FFFF   ADDIU T1, T1, -1
496:                 		{
497:                 		for (i=0; i<DISP_BUFFER_WIDE; i++)
9D01BA00  1448FFF6   BNE V0, T0, 0x9D01B9DC
498:                 			{
499:                 			disp_buffer[j][i] = disp_buffer[j-1][i];
9D01B9DC  80470000   LB A3, 0(V0)
9D01BA18  2522FFFF   ADDIU V0, T1, -1
500:                 			color_buffer[j][i] = color_buffer[j-1][i];
9D01B9EC  80670000   LB A3, 0(V1)
9D01B9F0  00A33021   ADDU A2, A1, V1
9D01B9F4  00C43021   ADDU A2, A2, A0
9D01B9F8  A0C70028   SB A3, 40(A2)
9D01B9FC  24420001   ADDIU V0, V0, 1
9D01BA00  1448FFF6   BNE V0, T0, 0x9D01B9DC
9D01BA04  24630001   ADDIU V1, V1, 1
9D01BA08  2529FFFF   ADDIU T1, T1, -1
9D01BA0C  312900FF   ANDI T1, T1, 255
9D01BA10  51690048   BEQL T3, T1, 0x9D01BB34
9D01BA14  A380818C   SB ZERO, -32372(GP)
9D01BA18  2522FFFF   ADDIU V0, T1, -1
9D01BA1C  000218C0   SLL V1, V0, 3
9D01BA20  00021140   SLL V0, V0, 5
9D01BA24  00621821   ADDU V1, V1, V0
9D01BA28  01431021   ADDU V0, T2, V1
9D01BA2C  01831821   ADDU V1, T4, V1
9D01BA30  000920C0   SLL A0, T1, 3
9D01BA34  00092940   SLL A1, T1, 5
9D01BA38  00852021   ADDU A0, A0, A1
9D01BA3C  01444021   ADDU T0, T2, A0
9D01BA40  0B406E77   J 0x9D01B9DC
9D01BA44  00042823   SUBU A1, ZERO, A0
501:                 			}
502:                 		}
503:                 	/*
504:                 	for (i=0;i<DISP_BUFFER_WIDE;i++)
505:                 		{
506:                 		disp_buffer[mtop][i] = '-';
507:                 		}
508:                 	*/
509:                 	}
510:                 
511:                 
512:                 
513:                 void video_scrollup()
514:                 	{
9D01AE54  27BDFFE8   ADDIU SP, SP, -24
9D01AE58  AFBF0014   SW RA, 20(SP)
515:                 	CURSOR_INVERT();
516:                 	_video_scrollup();
9D01AE5C  0F406A5F   JAL .Letext0, .LFE45, .LFB27, _video_scrollup, .Ltext0
9D01AE60  00000000   NOP
9D01B350  0F406A5F   JAL .Letext0, .LFE45, .LFB27, _video_scrollup, .Ltext0
9D01B354  00000000   NOP
517:                 	CURSOR_INVERT();
518:                 	}
9D01AE64  8FBF0014   LW RA, 20(SP)
9D01AE68  03E00008   JR RA
9D01AE6C  27BD0018   ADDIU SP, SP, 24
519:                 
520:                 void video_scrolldown()
521:                 	{
9D01AE70  27BDFFE8   ADDIU SP, SP, -24
9D01AE74  AFBF0014   SW RA, 20(SP)
522:                 	CURSOR_INVERT();
523:                 	_video_scrolldown();
9D01AE78  0F406A93   JAL .LFB29, _video_scrolldown, .LFE27
9D01AE7C  00000000   NOP
9D01B380  0F406A93   JAL .LFB29, _video_scrolldown, .LFE27
9D01B384  00000000   NOP
524:                 	CURSOR_INVERT();
525:                 	}
9D01AE80  8FBF0014   LW RA, 20(SP)
9D01AE84  03E00008   JR RA
9D01AE88  27BD0018   ADDIU SP, SP, 24
526:                 
527:                 void video_movesol()
528:                 	{
529:                 	CURSOR_INVERT();
530:                 	cx = 0;
9D01AE8C  03E00008   JR RA
9D01AE90  A3808190   SB ZERO, -32368(GP)
9D01B33C  A3808190   SB ZERO, -32368(GP)
9D01B918  0B406ECC   J .LVL179, .LBE53
9D01B91C  A3808190   SB ZERO, -32368(GP)
9D01B934  0B406ECC   J .LVL179, .LBE53
9D01B938  A3808190   SB ZERO, -32368(GP)
9D01B93C  0F406B5C   JAL escseq_get_param
9D01B940  24040001   ADDIU A0, ZERO, 1
9D01B944  2442FFFF   ADDIU V0, V0, -1
9D01B948  0F406BA5   JAL video_setx
9D01B94C  7C022420   SEB A0, V0
9D01B950  0B406ECD   J 0x9D01BB34
9D01B954  A380818C   SB ZERO, -32372(GP)
9D01B958  0F406B5C   JAL escseq_get_param
9D01B95C  24040001   ADDIU A0, ZERO, 1
9D01B960  00408021   ADDU S0, V0, ZERO
9D01B964  0F406B5C   JAL escseq_get_param
9D01B968  24040001   ADDIU A0, ZERO, 1
9D01B96C  2442FFFF   ADDIU V0, V0, -1
9D01B970  2605FFFF   ADDIU A1, S0, -1
9D01B974  7C022420   SEB A0, V0
9D01B978  0F406BAF   JAL video_gotoxy
9D01B97C  7C052C20   SEB A1, A1
9D01B980  0B406ECD   J 0x9D01BB34
9D01B984  A380818C   SB ZERO, -32372(GP)
9D01B988  0F406B5C   JAL escseq_get_param
9D01B98C  00002021   ADDU A0, ZERO, ZERO
9D01B990  0F406D25   JAL video_erase
9D01B994  00402021   ADDU A0, V0, ZERO
9D01B998  0B406ECD   J 0x9D01BB34
9D01B99C  A380818C   SB ZERO, -32372(GP)
9D01B9A0  0F406B5C   JAL escseq_get_param
9D01B9A4  00002021   ADDU A0, ZERO, ZERO
9D01B9A8  0F406D7F   JAL video_eraseline
9D01B9AC  00402021   ADDU A0, V0, ZERO
9D01B9B0  0B406ECD   J 0x9D01BB34
9D01B9B4  A380818C   SB ZERO, -32372(GP)
9D01B9B8  938B818F   LBU T3, -32369(GP)
9D01B9BC  9389817C   LBU T1, -32388(GP)
9D01B9C0  0169102B   SLTU V0, T3, T1
9D01B9C4  1040005A   BEQ V0, ZERO, .LVL179, .LBE53
9D01B9C8  3C0AA000   LUI T2, -24576
9D01B9CC  254A1E5C   ADDIU T2, T2, 7772
9D01B9D0  3C0CA000   LUI T4, -24576
9D01B9D4  0B406E86   J .LBE49
9D01B9D8  258C1B14   ADDIU T4, T4, 6932
9D01B9DC  80470000   LB A3, 0(V0)
9D01B9E0  00453021   ADDU A2, V0, A1
9D01B9E4  00C43021   ADDU A2, A2, A0
9D01B9E8  A0C70028   SB A3, 40(A2)
9D01B9EC  80670000   LB A3, 0(V1)
9D01B9F0  00A33021   ADDU A2, A1, V1
9D01B9F4  00C43021   ADDU A2, A2, A0
9D01B9F8  A0C70028   SB A3, 40(A2)
9D01B9FC  24420001   ADDIU V0, V0, 1
9D01BA00  1448FFF6   BNE V0, T0, 0x9D01B9DC
9D01BA04  24630001   ADDIU V1, V1, 1
9D01BA08  2529FFFF   ADDIU T1, T1, -1
9D01BA0C  312900FF   ANDI T1, T1, 255
9D01BA10  51690048   BEQL T3, T1, 0x9D01BB34
9D01BA14  A380818C   SB ZERO, -32372(GP)
9D01BA18  2522FFFF   ADDIU V0, T1, -1
9D01BA1C  000218C0   SLL V1, V0, 3
9D01BA20  00021140   SLL V0, V0, 5
9D01BA24  00621821   ADDU V1, V1, V0
9D01BA28  01431021   ADDU V0, T2, V1
9D01BA2C  01831821   ADDU V1, T4, V1
9D01BA30  000920C0   SLL A0, T1, 3
9D01BA34  00092940   SLL A1, T1, 5
9D01BA38  00852021   ADDU A0, A0, A1
9D01BA3C  01444021   ADDU T0, T2, A0
9D01BA40  0B406E77   J 0x9D01B9DC
9D01BA44  00042823   SUBU A1, ZERO, A0
9D01BA48  9386818F   LBU A2, -32369(GP)
9D01BA4C  24C60001   ADDIU A2, A2, 1
9D01BA50  30C600FF   ANDI A2, A2, 255
9D01BA54  8388817C   LB T0, -32388(GP)
9D01BA58  25080001   ADDIU T0, T0, 1
9D01BA5C  00C8182A   SLT V1, A2, T0
9D01BA60  10600033   BEQ V1, ZERO, .LVL179, .LBE53
9D01BA64  00C01021   ADDU V0, A2, ZERO
9D01BA68  3C07A000   LUI A3, -24576
9D01BA6C  24E71E5C   ADDIU A3, A3, 7772
9D01BA70  3C0AA000   LUI T2, -24576
9D01BA74  254A1B14   ADDIU T2, T2, 6932
9D01BA78  0B406EAC   J 0x9D01BAB0
9D01BA7C  24E90028   ADDIU T1, A3, 40
9D01BA80  90440000   LBU A0, 0(V0)
9D01BA84  A044FFD8   SB A0, -40(V0)
9D01BA88  90640000   LBU A0, 0(V1)
9D01BA8C  A064FFD8   SB A0, -40(V1)
9D01BA90  24420001   ADDIU V0, V0, 1
9D01BA94  1445FFFA   BNE V0, A1, 0x9D01BA80
9D01BA98  24630001   ADDIU V1, V1, 1
9D01BA9C  24C60001   ADDIU A2, A2, 1
9D01BAA0  30C600FF   ANDI A2, A2, 255
9D01BAA4  00C8182A   SLT V1, A2, T0
9D01BAA8  10600021   BEQ V1, ZERO, .LVL179, .LBE53
9D01BAAC  00C01021   ADDU V0, A2, ZERO
9D01BAB0  000228C0   SLL A1, V0, 3
9D01BAB4  00021140   SLL V0, V0, 5
9D01BAB8  00A22821   ADDU A1, A1, V0
9D01BABC  00E51021   ADDU V0, A3, A1
9D01BAC0  01451821   ADDU V1, T2, A1
9D01BAC4  0B406EA0   J 0x9D01BA80
9D01BAC8  01252821   ADDU A1, T1, A1
9D01BACC  0F406B5C   JAL escseq_get_param
9D01BAD0  00002021   ADDU A0, ZERO, ZERO
9D01BAD4  50400007   BEQL V0, ZERO, 0x9D01BAF4
9D01BAD8  A3808184   SB ZERO, -32380(GP)
9D01BADC  14500003   BNE V0, S0, 0x9D01BAEC
9D01BAE0  00000000   NOP
9D01BAE4  0B406EBD   J 0x9D01BAF4
9D01BAE8  A3808184   SB ZERO, -32380(GP)
9D01BAEC  50510001   BEQL V0, S1, 0x9D01BAF4
9D01BAF0  A3928184   SB S2, -32380(GP)
9D01BAF4  8F828188   LW V0, -32376(GP)
9D01BAF8  1440FFF4   BNE V0, ZERO, .LBE51, .LBE50
9D01BAFC  00000000   NOP
9D01BB00  0B406ECD   J 0x9D01BB34
9D01BB04  A380818C   SB ZERO, -32372(GP)
9D01BB08  0F406B5C   JAL escseq_get_param
9D01BB0C  24040001   ADDIU A0, ZERO, 1
9D01BB10  00408021   ADDU S0, V0, ZERO
9D01BB14  0F406B5C   JAL escseq_get_param
9D01BB18  24040014   ADDIU A0, ZERO, 20
9D01BB1C  2604FFFF   ADDIU A0, S0, -1
9D01BB20  2442FFFF   ADDIU V0, V0, -1
9D01BB24  7C042420   SEB A0, A0
9D01BB28  0F406BC1   JAL video_set_margins
9D01BB2C  7C022C20   SEB A1, V0
9D01BB30  A380818C   SB ZERO, -32372(GP)
9D01BB34  8FBF001C   LW RA, 28(SP)
9D01BB38  8FB20018   LW S2, 24(SP)
9D01BB3C  8FB10014   LW S1, 20(SP)
9D01BB40  8FB00010   LW S0, 16(SP)
9D01BB44  03E00008   JR RA
9D01BB48  27BD0020   ADDIU SP, SP, 32
531:                 	CURSOR_INVERT();
532:                 	}
533:                 
534:                 void video_setx(int8_t x)
535:                 	{
536:                 	CURSOR_INVERT();
537:                 	cx = x;
538:                 	if (cx < 0) cx = 0;
9D01AE94  04810003   BGEZ A0, 0x9D01AEA4
9D01AE98  A3848190   SB A0, -32368(GP)
9D01AE9C  03E00008   JR RA
9D01AEA0  A3808190   SB ZERO, -32368(GP)
539:                 	if (cx >= DISP_BUFFER_WIDE) cx = DISP_BUFFER_WIDE-1;
9D01AEA4  28840028   SLTI A0, A0, 40
9D01AEA8  14800002   BNE A0, ZERO, 0x9D01AEB4
9D01AEAC  24020027   ADDIU V0, ZERO, 39
9D01AEB0  A3828190   SB V0, -32368(GP)
9D01AEB4  03E00008   JR RA
9D01AEB8  00000000   NOP
540:                 	CURSOR_INVERT();
541:                 	}
542:                 
543:                 /* Absolute positioning does not respect top/bottom margins */
544:                 void video_gotoxy(int8_t x, int8_t y)
545:                 	{
546:                 	CURSOR_INVERT();
547:                 	cx = x;
548:                 	if (cx < 0) cx = 0;
9D01AEBC  04810003   BGEZ A0, 0x9D01AECC
9D01AEC0  A3848190   SB A0, -32368(GP)
9D01AEC4  0B406BB7   J 0x9D01AEDC
9D01AEC8  A3808190   SB ZERO, -32368(GP)
549:                 	if (cx >= DISP_BUFFER_WIDE) cx = DISP_BUFFER_WIDE-1;
9D01AECC  28840028   SLTI A0, A0, 40
9D01AED0  14800002   BNE A0, ZERO, 0x9D01AEDC
9D01AED4  24020027   ADDIU V0, ZERO, 39
9D01AED8  A3828190   SB V0, -32368(GP)
550:                 	cy = y;
551:                 	if (cy < 0) cy = 0;
9D01AEDC  04A10003   BGEZ A1, 0x9D01AEEC
9D01AEE0  A385818F   SB A1, -32369(GP)
9D01AEE4  03E00008   JR RA
9D01AEE8  A380818F   SB ZERO, -32369(GP)
552:                 	if (cy >= DISP_BUFFER_HIGH) cy = DISP_BUFFER_HIGH-1;
9D01AEEC  28A50014   SLTI A1, A1, 20
9D01AEF0  14A00002   BNE A1, ZERO, 0x9D01AEFC
9D01AEF4  24020013   ADDIU V0, ZERO, 19
9D01AEF8  A382818F   SB V0, -32369(GP)
9D01AEFC  03E00008   JR RA
9D01AF00  00000000   NOP
553:                 	CURSOR_INVERT();
554:                 	}
555:                 
556:                 void video_movex(int8_t dx)
557:                 	{
558:                 	CURSOR_INVERT();
559:                 	cx += dx;
9D01AFC4  93828190   LBU V0, -32368(GP)
9D01AFC8  00822021   ADDU A0, A0, V0
9D01AFCC  7C042420   SEB A0, A0
560:                 	if (cx < 0) cx = 0;
9D01AFD0  04810003   BGEZ A0, 0x9D01AFE0
9D01AFD4  A3848190   SB A0, -32368(GP)
9D01AFD8  03E00008   JR RA
9D01AFDC  A3808190   SB ZERO, -32368(GP)
561:                 	if (cx >= DISP_BUFFER_WIDE) cx = DISP_BUFFER_WIDE-1;
9D01AFE0  28840028   SLTI A0, A0, 40
9D01AFE4  14800002   BNE A0, ZERO, 0x9D01AFF0
9D01AFE8  24020027   ADDIU V0, ZERO, 39
9D01AFEC  A3828190   SB V0, -32368(GP)
9D01AFF0  03E00008   JR RA
9D01AFF4  00000000   NOP
562:                 	CURSOR_INVERT();
563:                 	}
564:                 
565:                 void video_movey(int8_t dy)
566:                 	{
567:                 	CURSOR_INVERT();
568:                 	cy += dy;
9D01AFF8  9382818F   LBU V0, -32369(GP)
9D01AFFC  00822021   ADDU A0, A0, V0
9D01B000  7C042420   SEB A0, A0
9D01B004  A384818F   SB A0, -32369(GP)
569:                 	if (cy < mtop) cy = mtop;
9D01B008  8382817D   LB V0, -32387(GP)
9D01B00C  0082202A   SLT A0, A0, V0
9D01B010  54800001   BNEL A0, ZERO, 0x9D01B018
9D01B014  A382818F   SB V0, -32369(GP)
570:                 	if (cy > mbottom) cy = mbottom;
9D01B018  8382817C   LB V0, -32388(GP)
9D01B01C  8383818F   LB V1, -32369(GP)
9D01B020  0043182A   SLT V1, V0, V1
9D01B024  54600001   BNEL V1, ZERO, 0x9D01B02C
9D01B028  A382818F   SB V0, -32369(GP)
9D01B02C  03E00008   JR RA
9D01B030  00000000   NOP
571:                 	CURSOR_INVERT();
572:                 	}
573:                 
574:                 static void _video_lfwd()
575:                 	{
9D01AB2C  27BDFFE8   ADDIU SP, SP, -24
9D01AB30  AFBF0014   SW RA, 20(SP)
576:                 	cx = 0;
9D01AB34  A3808190   SB ZERO, -32368(GP)
577:                 	if (++cy > mbottom)
9D01AB38  9382818F   LBU V0, -32369(GP)
9D01AB3C  24420001   ADDIU V0, V0, 1
9D01AB40  7C021420   SEB V0, V0
9D01AB44  A382818F   SB V0, -32369(GP)
9D01AB48  8383817C   LB V1, -32388(GP)
9D01AB4C  0062102A   SLT V0, V1, V0
9D01AB50  10400004   BEQ V0, ZERO, 0x9D01AB64
9D01AB54  8FBF0014   LW RA, 20(SP)
578:                 		{
579:                 		cy = mbottom;
580:                 		_video_scrollup();
9D01AB58  0F406A5F   JAL .Letext0, .LFE45, .LFB27, _video_scrollup, .Ltext0
9D01AB5C  A383818F   SB V1, -32369(GP)
581:                 		}
582:                 	}
9D01AB60  8FBF0014   LW RA, 20(SP)
9D01AB64  03E00008   JR RA
9D01AB68  27BD0018   ADDIU SP, SP, 24
583:                 
584:                 static void _video_cfwd()
585:                 	{
9D01AB6C  27BDFFE8   ADDIU SP, SP, -24
9D01AB70  AFBF0014   SW RA, 20(SP)
586:                 	if (++cx > DISP_BUFFER_WIDE)
9D01AB74  93828190   LBU V0, -32368(GP)
9D01AB78  24420001   ADDIU V0, V0, 1
9D01AB7C  7C021420   SEB V0, V0
9D01AB80  A3828190   SB V0, -32368(GP)
9D01AB84  28420029   SLTI V0, V0, 41
9D01AB88  14400004   BNE V0, ZERO, 0x9D01AB9C
9D01AB8C  8FBF0014   LW RA, 20(SP)
587:                 		_video_lfwd();
9D01AB90  0F406ACB   JAL .LFB38, _video_lfwd, .LFE29
9D01AB94  00000000   NOP
588:                 	}
9D01AB98  8FBF0014   LW RA, 20(SP)
9D01AB9C  03E00008   JR RA
9D01ABA0  27BD0018   ADDIU SP, SP, 24
589:                 
590:                 void video_cfwd()
591:                 	{
9D01B034  27BDFFE8   ADDIU SP, SP, -24
9D01B038  AFBF0014   SW RA, 20(SP)
592:                 	CURSOR_INVERT();
593:                 	_video_cfwd();
9D01B03C  0F406ADB   JAL .LFB39, _video_cfwd, .LFE38
9D01B040  00000000   NOP
594:                 	CURSOR_INVERT();
595:                 	}
9D01B044  8FBF0014   LW RA, 20(SP)
9D01B048  03E00008   JR RA
9D01B04C  27BD0018   ADDIU SP, SP, 24
596:                 
597:                 void video_lfwd()
598:                 	{
9D01B050  27BDFFE8   ADDIU SP, SP, -24
9D01B054  AFBF0014   SW RA, 20(SP)
599:                 	CURSOR_INVERT();
600:                 	cx = 0;
9D01B058  A3808190   SB ZERO, -32368(GP)
601:                 	if (++cy > mbottom)
9D01B05C  9382818F   LBU V0, -32369(GP)
9D01B060  24420001   ADDIU V0, V0, 1
9D01B064  7C021420   SEB V0, V0
9D01B068  A382818F   SB V0, -32369(GP)
9D01B06C  8383817C   LB V1, -32388(GP)
9D01B070  0062102A   SLT V0, V1, V0
9D01B074  10400004   BEQ V0, ZERO, 0x9D01B088
9D01B078  8FBF0014   LW RA, 20(SP)
602:                 		{
603:                 		cy = mbottom;
604:                 		_video_scrollup();
9D01B07C  0F406A5F   JAL .Letext0, .LFE45, .LFB27, _video_scrollup, .Ltext0
9D01B080  A383818F   SB V1, -32369(GP)
605:                 		}
606:                 	CURSOR_INVERT();
607:                 	}
9D01B084  8FBF0014   LW RA, 20(SP)
9D01B088  03E00008   JR RA
9D01B08C  27BD0018   ADDIU SP, SP, 24
608:                 
609:                 void video_lf()
610:                 	{
9D01B090  27BDFFE8   ADDIU SP, SP, -24
9D01B094  AFBF0014   SW RA, 20(SP)
611:                 	CURSOR_INVERT();
612:                 	if (++cy > mbottom)
9D01B098  9382818F   LBU V0, -32369(GP)
9D01B09C  24420001   ADDIU V0, V0, 1
9D01B0A0  7C021420   SEB V0, V0
9D01B0A4  A382818F   SB V0, -32369(GP)
9D01B0A8  8383817C   LB V1, -32388(GP)
9D01B0AC  0062102A   SLT V0, V1, V0
9D01B0B0  10400004   BEQ V0, ZERO, 0x9D01B0C4
9D01B0B4  8FBF0014   LW RA, 20(SP)
613:                 		{
614:                 		cy = mbottom;
615:                 		_video_scrollup();
9D01B0B8  0F406A5F   JAL .Letext0, .LFE45, .LFB27, _video_scrollup, .Ltext0
9D01B0BC  A383818F   SB V1, -32369(GP)
616:                 		}
617:                 	CURSOR_INVERT();
618:                 	}
9D01B0C0  8FBF0014   LW RA, 20(SP)
9D01B0C4  03E00008   JR RA
9D01B0C8  27BD0018   ADDIU SP, SP, 24
619:                 
620:                 static void _video_lback()
621:                 	{
622:                 	cx = DISP_BUFFER_WIDE-1;
9D01B118  A3828190   SB V0, -32368(GP)
623:                 	if (--cy < 0)
9D01B11C  9382818F   LBU V0, -32369(GP)
624:                 		{
625:                 		cx = 0;
9D01B130  A3808190   SB ZERO, -32368(GP)
626:                 		cy = mtop;
9D01B134  9382817D   LBU V0, -32387(GP)
9D01B138  A382818F   SB V0, -32369(GP)
9D01B13C  03E00008   JR RA
9D01B140  00000000   NOP
627:                 		}
628:                 	}
629:                 
630:                 void video_lback()
631:                 	{
632:                 	CURSOR_INVERT();
633:                 	cx = DISP_BUFFER_WIDE-1;
9D01B0CC  24020027   ADDIU V0, ZERO, 39
9D01B0D0  A3828190   SB V0, -32368(GP)
634:                 	if (--cy < 0)
9D01B0D4  9382818F   LBU V0, -32369(GP)
9D01B0D8  2442FFFF   ADDIU V0, V0, -1
9D01B0DC  7C021420   SEB V0, V0
9D01B0E0  04410004   BGEZ V0, 0x9D01B0F4
9D01B0E4  A382818F   SB V0, -32369(GP)
635:                 		{
636:                 		cx = 0;
9D01B0E8  A3808190   SB ZERO, -32368(GP)
637:                 		cy = mtop;
9D01B0EC  9382817D   LBU V0, -32387(GP)
9D01B0F0  A382818F   SB V0, -32369(GP)
9D01B0F4  03E00008   JR RA
9D01B0F8  00000000   NOP
638:                 		}
639:                 	CURSOR_INVERT();
640:                 	}
641:                 
642:                 void video_cback()
643:                 	{
644:                 	CURSOR_INVERT();
645:                 	if (--cx < 0)
9D01B0FC  93828190   LBU V0, -32368(GP)
9D01B100  2442FFFF   ADDIU V0, V0, -1
9D01B104  7C021420   SEB V0, V0
9D01B108  04420003   BLTZL V0, .LBB9
9D01B10C  24020027   ADDIU V0, ZERO, 39
9D01B110  03E00008   JR RA
9D01B114  A3828190   SB V0, -32368(GP)
9D01B118  A3828190   SB V0, -32368(GP)
9D01B11C  9382818F   LBU V0, -32369(GP)
9D01B120  2442FFFF   ADDIU V0, V0, -1
9D01B124  7C021420   SEB V0, V0
9D01B128  04410004   BGEZ V0, 0x9D01B13C
9D01B12C  A382818F   SB V0, -32369(GP)
9D01B130  A3808190   SB ZERO, -32368(GP)
9D01B134  9382817D   LBU V0, -32387(GP)
9D01B138  A382818F   SB V0, -32369(GP)
9D01B13C  03E00008   JR RA
9D01B140  00000000   NOP
646:                 		_video_lback();
647:                 	CURSOR_INVERT();
648:                 	}
649:                 
650:                 int8_t video_getx()
651:                 	{
652:                 	return cx;
653:                 	}
9D01B144  03E00008   JR RA
9D01B148  83828190   LB V0, -32368(GP)
654:                 
655:                 int8_t video_gety(void)
656:                 	{
657:                 	return cy;
658:                 	}
9D01B14C  03E00008   JR RA
9D01B150  8382818F   LB V0, -32369(GP)
659:                 
660:                 int8_t video_charat(int8_t x, int8_t y)
661:                 	{
662:                 	return disp_buffer[cy][cx];
9D01B154  8382818F   LB V0, -32369(GP)
9D01B158  83838190   LB V1, -32368(GP)
9D01B15C  000220C0   SLL A0, V0, 3
9D01B160  00021140   SLL V0, V0, 5
9D01B164  00821021   ADDU V0, A0, V0
9D01B168  00431021   ADDU V0, V0, V1
9D01B16C  3C03A000   LUI V1, -24576
9D01B170  24631E5C   ADDIU V1, V1, 7772
9D01B174  00431021   ADDU V0, V0, V1
663:                 	}
9D01B178  03E00008   JR RA
9D01B17C  80420000   LB V0, 0(V0)
664:                 
665:                 void video_clrscr()
666:                 	{
9D01B180  27BDFFE8   ADDIU SP, SP, -24
9D01B184  AFBF0014   SW RA, 20(SP)
667:                 	CURSOR_INVERT();
668:                 	video_reset_margins();
9D01B188  0F406BD6   JAL video_reset_margins
9D01B18C  00000000   NOP
669:                 	memset(disp_buffer, revvideo, DISP_BUFFER_WIDE*DISP_BUFFER_HIGH);
9D01B190  3C04A000   LUI A0, -24576
9D01B194  24841E5C   ADDIU A0, A0, 7772
9D01B198  93858184   LBU A1, -32380(GP)
9D01B19C  0F40E9FC   JAL .Letext0, .LFE0, memset
9D01B1A0  24060320   ADDIU A2, ZERO, 800
670:                 	memset(color_buffer, 0, DISP_BUFFER_WIDE*DISP_BUFFER_HIGH);
9D01B1A4  3C04A000   LUI A0, -24576
9D01B1A8  24841B14   ADDIU A0, A0, 6932
9D01B1AC  00002821   ADDU A1, ZERO, ZERO
9D01B1B0  0F40E9FC   JAL .Letext0, .LFE0, memset
9D01B1B4  24060320   ADDIU A2, ZERO, 800
671:                 	cx = cy = 0;
9D01B1B8  A380818F   SB ZERO, -32369(GP)
9D01B1BC  A3808190   SB ZERO, -32368(GP)
672:                 	CURSOR_INVERT();
673:                 	}
9D01B1C0  8FBF0014   LW RA, 20(SP)
9D01B1C4  03E00008   JR RA
9D01B1C8  27BD0018   ADDIU SP, SP, 24
674:                 
675:                 void video_clrline()
676:                 	{
9D01B3C0  27BDFFE8   ADDIU SP, SP, -24
9D01B3C4  AFBF0014   SW RA, 20(SP)
9D01B3C8  AFB00010   SW S0, 16(SP)
677:                 	CURSOR_INVERT();
678:                 	memset(&disp_buffer[cy], revvideo, DISP_BUFFER_WIDE);
9D01B3CC  8382818F   LB V0, -32369(GP)
9D01B3D0  000280C0   SLL S0, V0, 3
9D01B3D4  00021140   SLL V0, V0, 5
9D01B3D8  02028021   ADDU S0, S0, V0
9D01B3DC  3C04A000   LUI A0, -24576
9D01B3E0  24841E5C   ADDIU A0, A0, 7772
9D01B3E4  00902021   ADDU A0, A0, S0
9D01B3E8  93858184   LBU A1, -32380(GP)
9D01B3EC  0F40E9FC   JAL .Letext0, .LFE0, memset
9D01B3F0  24060028   ADDIU A2, ZERO, 40
679:                 	memset(&color_buffer[cy], 0, DISP_BUFFER_WIDE);
9D01B3F4  3C04A000   LUI A0, -24576
9D01B3F8  24841B14   ADDIU A0, A0, 6932
9D01B3FC  00902021   ADDU A0, A0, S0
9D01B400  00002821   ADDU A1, ZERO, ZERO
9D01B404  0F40E9FC   JAL .Letext0, .LFE0, memset
9D01B408  24060028   ADDIU A2, ZERO, 40
680:                 	cx = 0;
9D01B40C  A3808190   SB ZERO, -32368(GP)
681:                 	CURSOR_INVERT();
682:                 	}
9D01B410  8FBF0014   LW RA, 20(SP)
9D01B414  8FB00010   LW S0, 16(SP)
9D01B418  03E00008   JR RA
9D01B41C  27BD0018   ADDIU SP, SP, 24
683:                 
684:                 void video_clreol()
685:                 	{
9D01B420  27BDFFE0   ADDIU SP, SP, -32
9D01B424  AFBF001C   SW RA, 28(SP)
9D01B428  AFB10018   SW S1, 24(SP)
9D01B42C  AFB00014   SW S0, 20(SP)
686:                 	memset(&disp_buffer[cy][cx], revvideo, DISP_BUFFER_WIDE-cx);
9D01B430  8383818F   LB V1, -32369(GP)
9D01B434  83828190   LB V0, -32368(GP)
9D01B438  24100028   ADDIU S0, ZERO, 40
9D01B43C  02028023   SUBU S0, S0, V0
9D01B440  000388C0   SLL S1, V1, 3
9D01B444  00031940   SLL V1, V1, 5
9D01B448  02238821   ADDU S1, S1, V1
9D01B44C  02228821   ADDU S1, S1, V0
9D01B450  3C04A000   LUI A0, -24576
9D01B454  24841E5C   ADDIU A0, A0, 7772
9D01B458  00912021   ADDU A0, A0, S1
9D01B45C  93858184   LBU A1, -32380(GP)
9D01B460  0F40E9FC   JAL .Letext0, .LFE0, memset
9D01B464  02003021   ADDU A2, S0, ZERO
687:                 	memset(&color_buffer[cy][cx], 0, DISP_BUFFER_WIDE-cx);
9D01B468  3C04A000   LUI A0, -24576
9D01B46C  24841B14   ADDIU A0, A0, 6932
9D01B470  00912021   ADDU A0, A0, S1
9D01B474  00002821   ADDU A1, ZERO, ZERO
9D01B478  0F40E9FC   JAL .Letext0, .LFE0, memset
9D01B47C  02003021   ADDU A2, S0, ZERO
688:                 	}
9D01B480  8FBF001C   LW RA, 28(SP)
9D01B484  8FB10018   LW S1, 24(SP)
9D01B488  8FB00014   LW S0, 20(SP)
9D01B48C  03E00008   JR RA
9D01B490  27BD0020   ADDIU SP, SP, 32
689:                 
690:                 void video_erase(uint8_t erasemode)
691:                 	{
692:                 	uint8_t x,y;
693:                 	CURSOR_INVERT();
694:                 	switch(erasemode)
9D01B494  24020001   ADDIU V0, ZERO, 1
9D01B498  1082000C   BEQ A0, V0, 0x9D01B4CC
9D01B49C  838C8190   LB T4, -32368(GP)
9D01B4A0  10800015   BEQ A0, ZERO, 0x9D01B4F8
9D01B4A4  24020002   ADDIU V0, ZERO, 2
9D01B4A8  14820031   BNE A0, V0, 0x9D01B570
9D01B4AC  3C05A000   LUI A1, -24576
9D01B4B0  24A51E5C   ADDIU A1, A1, 7772
9D01B4B4  3C06A000   LUI A2, -24576
9D01B4B8  24C61B14   ADDIU A2, A2, 6932
9D01B4BC  24A80028   ADDIU T0, A1, 40
695:                 		{
696:                 		case 0: /* erase from cursor to end of screen */
697:                 //jar
698:                 //      memset(&disp_buffer[cy][cx], revvideo,
699:                 //          (DISP_BUFFER_WIDE*DISP_BUFFER_HIGH)-(cy*DISP_BUFFER_WIDE+cx));
700:                 			for (x=cx; x<DISP_BUFFER_WIDE; x++)
9D01B4F8  93858190   LBU A1, -32368(GP)
9D01B4FC  2CA20028   SLTIU V0, A1, 40
9D01B500  1040001B   BEQ V0, ZERO, 0x9D01B570
9D01B504  938C818F   LBU T4, -32369(GP)
9D01B524  240A0028   ADDIU T2, ZERO, 40
9D01B560  24A50001   ADDIU A1, A1, 1
9D01B564  30A500FF   ANDI A1, A1, 255
9D01B568  14AAFFEF   BNE A1, T2, 0x9D01B528
9D01B56C  00000000   NOP
9D01B570  03E00008   JR RA
9D01B574  00000000   NOP
701:                 				for (y=cy; y<DISP_BUFFER_HIGH; y++)
9D01B508  2D8B0014   SLTIU T3, T4, 20
9D01B520  24060014   ADDIU A2, ZERO, 20
9D01B528  5160000E   BEQL T3, ZERO, 0x9D01B564
9D01B52C  24A50001   ADDIU A1, A1, 1
9D01B530  01801021   ADDU V0, T4, ZERO
9D01B550  24420001   ADDIU V0, V0, 1
9D01B554  304200FF   ANDI V0, V0, 255
9D01B558  1446FFF6   BNE V0, A2, 0x9D01B534
9D01B55C  A0600000   SB ZERO, 0(V1)
702:                 					{
703:                 					disp_buffer[y][x] = ' ';
9D01B50C  3C09A000   LUI T1, -24576
9D01B510  25291E5C   ADDIU T1, T1, 7772
9D01B514  24080020   ADDIU T0, ZERO, 32
9D01B534  000220C0   SLL A0, V0, 3
9D01B538  00021940   SLL V1, V0, 5
9D01B53C  00831821   ADDU V1, A0, V1
9D01B540  00651821   ADDU V1, V1, A1
9D01B544  00692021   ADDU A0, V1, T1
9D01B548  A0880000   SB T0, 0(A0)
704:                 					color_buffer[y][x] = 0;
9D01B518  3C07A000   LUI A3, -24576
9D01B51C  24E71B14   ADDIU A3, A3, 6932
9D01B54C  00671821   ADDU V1, V1, A3
705:                 					}
706:                 			break;
707:                 		case 1: /* erase from beginning of screen to cursor */
708:                 //jar
709:                 //      memset(disp_buffer, revvideo, cy*DISP_BUFFER_WIDE+cx+1);
710:                 			for (x=0; x<cx; x++)
9D01B4CC  19800028   BLEZ T4, 0x9D01B570
9D01B4D0  838B818F   LB T3, -32369(GP)
9D01B4D8  00002821   ADDU A1, ZERO, ZERO
9D01B4DC  00005021   ADDU T2, ZERO, ZERO
9D01B5AC  254A0001   ADDIU T2, T2, 1
9D01B5B0  314A00FF   ANDI T2, T2, 255
9D01B5B4  014C102A   SLT V0, T2, T4
9D01B5B8  1040FFED   BEQ V0, ZERO, 0x9D01B570
9D01B5BC  01402821   ADDU A1, T2, ZERO
9D01B5F4  0B406D74   J 0x9D01B5D0
9D01B5F8  00001021   ADDU V0, ZERO, ZERO
711:                 				for (y=0; y<cy; y++)
9D01B4D4  01604821   ADDU T1, T3, ZERO
9D01B598  24420001   ADDIU V0, V0, 1
9D01B59C  304200FF   ANDI V0, V0, 255
9D01B5A0  0049202A   SLT A0, V0, T1
9D01B5A4  1480FFF4   BNE A0, ZERO, 0x9D01B578
9D01B5A8  00401821   ADDU V1, V0, ZERO
9D01B5C0  1960FFFA   BLEZ T3, 0x9D01B5AC
9D01B5C4  00001021   ADDU V0, ZERO, ZERO
9D01B5C8  0B406D5E   J 0x9D01B578
9D01B5CC  00001821   ADDU V1, ZERO, ZERO
9D01B5D0  00A22021   ADDU A0, A1, V0
712:                 					{
713:                 					disp_buffer[y][x] = ' ';
9D01B4E0  3C08A000   LUI T0, -24576
9D01B4E4  25081E5C   ADDIU T0, T0, 7772
9D01B4E8  24070020   ADDIU A3, ZERO, 32
9D01B578  000320C0   SLL A0, V1, 3
9D01B57C  00031940   SLL V1, V1, 5
9D01B580  00831821   ADDU V1, A0, V1
9D01B584  00651821   ADDU V1, V1, A1
9D01B588  00682021   ADDU A0, V1, T0
9D01B58C  A0870000   SB A3, 0(A0)
714:                 					color_buffer[y][x] = 0;
9D01B4EC  3C06A000   LUI A2, -24576
9D01B4F0  0B406D70   J 0x9D01B5C0
9D01B4F4  24C61B14   ADDIU A2, A2, 6932
9D01B590  00661821   ADDU V1, V1, A2
9D01B594  A0600000   SB ZERO, 0(V1)
715:                 					}
716:                 			break;
717:                 		case 2: /* erase entire screen */
718:                 //jar
719:                 //      memset(disp_buffer, revvideo, DISP_BUFFER_WIDE*DISP_BUFFER_HIGH);
720:                 			for (x=0; x<DISP_BUFFER_WIDE; x++)
9D01B5EC  10A8FFE0   BEQ A1, T0, 0x9D01B570
9D01B5F0  24C60001   ADDIU A2, A2, 1
721:                 				for (y=0; y<DISP_BUFFER_HIGH; y++)
9D01B4C4  0B406D7D   J 0x9D01B5F4
9D01B4C8  24070320   ADDIU A3, ZERO, 800
9D01B5E0  1447FFFB   BNE V0, A3, 0x9D01B5D0
9D01B5E4  A0830000   SB V1, 0(A0)
9D01B5E8  24A50001   ADDIU A1, A1, 1
722:                 					{
723:                 					disp_buffer[y][x] = ' ';
9D01B4C0  24030020   ADDIU V1, ZERO, 32
9D01B5D4  A0830000   SB V1, 0(A0)
9D01B5D8  00C22021   ADDU A0, A2, V0
9D01B5DC  24420028   ADDIU V0, V0, 40
9D01B5E0  1447FFFB   BNE V0, A3, 0x9D01B5D0
9D01B5E4  A0830000   SB V1, 0(A0)
9D01B5E8  24A50001   ADDIU A1, A1, 1
9D01B5EC  10A8FFE0   BEQ A1, T0, 0x9D01B570
9D01B5F0  24C60001   ADDIU A2, A2, 1
9D01B5F4  0B406D74   J 0x9D01B5D0
9D01B5F8  00001021   ADDU V0, ZERO, ZERO
724:                 					color_buffer[y][x] = ' ';
725:                 					}
726:                 			break;
727:                 		}
728:                 	CURSOR_INVERT();
729:                 	}
730:                 
731:                 void video_eraseline(uint8_t erasemode)
732:                 	{
733:                 	uint8_t y,x;
734:                 	CURSOR_INVERT();
735:                 	switch(erasemode)
9D01B5FC  24020001   ADDIU V0, ZERO, 1
9D01B600  10820007   BEQ A0, V0, 0x9D01B620
9D01B604  83898190   LB T1, -32368(GP)
9D01B608  10800009   BEQ A0, ZERO, 0x9D01B630
9D01B60C  24020002   ADDIU V0, ZERO, 2
9D01B610  10820034   BEQ A0, V0, 0x9D01B6E4
9D01B614  8383818F   LB V1, -32369(GP)
9D01B618  03E00008   JR RA
9D01B61C  00000000   NOP
736:                 		{
737:                 		case 0: /* erase from cursor to end of line */
738:                 //jar
739:                 			for (x=cx; x<DISP_BUFFER_WIDE; x++)
9D01B630  93828190   LBU V0, -32368(GP)
9D01B634  2C430028   SLTIU V1, V0, 40
9D01B638  1060FFF7   BEQ V1, ZERO, 0x9D01B618
9D01B63C  8383818F   LB V1, -32369(GP)
9D01B660  24050028   ADDIU A1, ZERO, 40
9D01B674  24420001   ADDIU V0, V0, 1
9D01B678  304200FF   ANDI V0, V0, 255
9D01B67C  1445FFF9   BNE V0, A1, 0x9D01B664
9D01B680  A0600000   SB ZERO, 0(V1)
9D01B684  03E00008   JR RA
9D01B688  00000000   NOP
740:                 				{
741:                 				disp_buffer[cy][x] = ' ';
9D01B640  000348C0   SLL T1, V1, 3
9D01B644  00031940   SLL V1, V1, 5
9D01B648  01234821   ADDU T1, T1, V1
9D01B64C  3C08A000   LUI T0, -24576
9D01B650  25081E5C   ADDIU T0, T0, 7772
9D01B654  24070020   ADDIU A3, ZERO, 32
9D01B664  01221821   ADDU V1, T1, V0
9D01B668  00682021   ADDU A0, V1, T0
9D01B66C  A0870000   SB A3, 0(A0)
742:                 				color_buffer[cy][x] = 0;
9D01B658  3C06A000   LUI A2, -24576
9D01B65C  24C61B14   ADDIU A2, A2, 6932
9D01B670  00661821   ADDU V1, V1, A2
743:                 				}
744:                 //      memset(&disp_buffer[cy][cx], revvideo, DISP_BUFFER_WIDE-cx);
745:                 			break;
746:                 		case 1: /* erase from beginning of line to cursor */
747:                 //jar
748:                 			for (x=0; x<cx; x++)
9D01B620  1D20001A   BGTZ T1, 0x9D01B68C
9D01B624  8384818F   LB A0, -32369(GP)
9D01B628  03E00008   JR RA
9D01B62C  00000000   NOP
9D01B68C  00001821   ADDU V1, ZERO, ZERO
9D01B690  00001021   ADDU V0, ZERO, ZERO
9D01B6C8  24420001   ADDIU V0, V0, 1
9D01B6CC  304200FF   ANDI V0, V0, 255
9D01B6D0  0049202A   SLT A0, V0, T1
9D01B6D4  1480FFF7   BNE A0, ZERO, 0x9D01B6B4
9D01B6D8  00401821   ADDU V1, V0, ZERO
9D01B6DC  03E00008   JR RA
9D01B6E0  00000000   NOP
9D01B6E4  000310C0   SLL V0, V1, 3
9D01B6E8  00031940   SLL V1, V1, 5
9D01B6EC  00431021   ADDU V0, V0, V1
9D01B6F0  3C07A000   LUI A3, -24576
9D01B6F4  24E71E5C   ADDIU A3, A3, 7772
9D01B6F8  00E23821   ADDU A3, A3, V0
9D01B6FC  3C06A000   LUI A2, -24576
9D01B700  24C61B14   ADDIU A2, A2, 6932
9D01B704  00C23021   ADDU A2, A2, V0
749:                 				{
750:                 				disp_buffer[cy][x] = ' ';
9D01B694  000440C0   SLL T0, A0, 3
9D01B698  00042140   SLL A0, A0, 5
9D01B69C  01044021   ADDU T0, T0, A0
9D01B6A0  3C07A000   LUI A3, -24576
9D01B6A4  24E71E5C   ADDIU A3, A3, 7772
9D01B6A8  24060020   ADDIU A2, ZERO, 32
9D01B6B4  01031821   ADDU V1, T0, V1
9D01B6B8  00672021   ADDU A0, V1, A3
9D01B6BC  A0860000   SB A2, 0(A0)
751:                 				color_buffer[cy][x] = 0;
9D01B6AC  3C05A000   LUI A1, -24576
9D01B6B0  24A51B14   ADDIU A1, A1, 6932
9D01B6C0  00651821   ADDU V1, V1, A1
9D01B6C4  A0600000   SB ZERO, 0(V1)
752:                 				}
753:                 
754:                 //      memset(&disp_buffer[cy], revvideo, cx+1);
755:                 			break;
756:                 		case 2: /* erase entire line */
757:                 //jar
758:                 			for (x=0; x<DISP_BUFFER_WIDE; x++)
9D01B710  24040028   ADDIU A0, ZERO, 40
9D01B714  00E21821   ADDU V1, A3, V0
9D01B724  1444FFFB   BNE V0, A0, 0x9D01B714
9D01B728  A0600000   SB ZERO, 0(V1)
9D01B72C  03E00008   JR RA
9D01B730  00000000   NOP
759:                 				{
760:                 				disp_buffer[cy][x] = ' ';
9D01B708  00001021   ADDU V0, ZERO, ZERO
9D01B70C  24050020   ADDIU A1, ZERO, 32
9D01B718  A0650000   SB A1, 0(V1)
9D01B71C  00C21821   ADDU V1, A2, V0
9D01B720  24420001   ADDIU V0, V0, 1
9D01B724  1444FFFB   BNE V0, A0, 0x9D01B714
9D01B728  A0600000   SB ZERO, 0(V1)
9D01B72C  03E00008   JR RA
9D01B730  00000000   NOP
761:                 				color_buffer[cy][x] = 0;
762:                 				}
763:                 
764:                 //      memset(&disp_buffer[cy], revvideo, DISP_BUFFER_WIDE);
765:                 			break;
766:                 		}
767:                 	CURSOR_INVERT();
768:                 	}
769:                 
770:                 /* Does not respect top/bottom margins */
771:                 void video_putcxy(int8_t x, int8_t y, int8_t c)
772:                 	{
773:                 	if (x < 0 || x >= DISP_BUFFER_WIDE) return;
9D01BBBC  308200FF   ANDI V0, A0, 255
9D01BBC0  2C420028   SLTIU V0, V0, 40
9D01BBC4  10400012   BEQ V0, ZERO, 0x9D01BC10
9D01BBC8  30A200FF   ANDI V0, A1, 255
774:                 	if (y < 0 || y >= DISP_BUFFER_HIGH) return;
9D01BBCC  2C420014   SLTIU V0, V0, 20
9D01BBD0  1040000F   BEQ V0, ZERO, 0x9D01BC10
9D01BBD4  000510C0   SLL V0, A1, 3
775:                 	disp_buffer[y][x] = c ^ revvideo;
9D01BBD8  00052940   SLL A1, A1, 5
9D01BBDC  00452821   ADDU A1, V0, A1
9D01BBE0  00A42021   ADDU A0, A1, A0
9D01BBE4  3C02A000   LUI V0, -24576
9D01BBE8  24421E5C   ADDIU V0, V0, 7772
9D01BBEC  00821021   ADDU V0, A0, V0
9D01BBF0  93838184   LBU V1, -32380(GP)
9D01BBF4  00C33026   XOR A2, A2, V1
9D01BBF8  A0460000   SB A2, 0(V0)
776:                 	color_buffer[y][x] = color_composite;
9D01BBFC  3C02A000   LUI V0, -24576
9D01BC00  24421B14   ADDIU V0, V0, 6932
9D01BC04  00822021   ADDU A0, A0, V0
9D01BC08  938281C1   LBU V0, -32319(GP)
9D01BC0C  A0820000   SB V0, 0(A0)
9D01BC10  03E00008   JR RA
9D01BC14  00000000   NOP
777:                 	}
778:                 
779:                 /* Does not respect top/bottom margins */
780:                 void video_putsxy(int8_t x, int8_t y, int8_t *str)
781:                 	{
9D01BEE0  27BDFFD8   ADDIU SP, SP, -40
9D01BEE4  AFBF0024   SW RA, 36(SP)
9D01BEE8  AFB40020   SW S4, 32(SP)
9D01BEEC  AFB3001C   SW S3, 28(SP)
9D01BEF0  AFB20018   SW S2, 24(SP)
9D01BEF4  AFB10014   SW S1, 20(SP)
9D01BEF8  AFB00010   SW S0, 16(SP)
782:                 	int16_t len;
783:                 	if (x < 0 || x >= DISP_BUFFER_WIDE) return;
9D01BEFC  308200FF   ANDI V0, A0, 255
9D01BF00  2C420028   SLTIU V0, V0, 40
9D01BF04  10400026   BEQ V0, ZERO, .LVL232
9D01BF08  00808021   ADDU S0, A0, ZERO
784:                 	if (y < 0 || y >= DISP_BUFFER_HIGH) return;
9D01BF0C  30A200FF   ANDI V0, A1, 255
9D01BF10  2C420014   SLTIU V0, V0, 20
9D01BF14  10400022   BEQ V0, ZERO, .LVL232
9D01BF18  00A08821   ADDU S1, A1, ZERO
9D01BF1C  00C09821   ADDU S3, A2, ZERO
785:                 	len = strlen(str);
9D01BF20  0F40DBFE   JAL strlen
9D01BF24  00C02021   ADDU A0, A2, ZERO
9D01BF28  7C029620   SEH S2, V0
786:                 	if (len > DISP_BUFFER_WIDE-x) len = DISP_BUFFER_WIDE-x;
9D01BF2C  24020028   ADDIU V0, ZERO, 40
9D01BF30  00501023   SUBU V0, V0, S0
9D01BF34  0052102A   SLT V0, V0, S2
9D01BF38  10400003   BEQ V0, ZERO, 0x9D01BF48
9D01BF3C  0011A0C0   SLL S4, S1, 3
9D01BF40  24120028   ADDIU S2, ZERO, 40
9D01BF44  02509023   SUBU S2, S2, S0
787:                 	memcpy((int8_t *)(&disp_buffer[y][x]), str, len);
9D01BF48  00111140   SLL V0, S1, 5
9D01BF4C  0282A021   ADDU S4, S4, V0
9D01BF50  0290A021   ADDU S4, S4, S0
9D01BF54  3C04A000   LUI A0, -24576
9D01BF58  24841E5C   ADDIU A0, A0, 7772
9D01BF5C  00942021   ADDU A0, A0, S4
9D01BF60  02602821   ADDU A1, S3, ZERO
9D01BF64  0F40DBA4   JAL .Letext0, .LFE1, memcpy
9D01BF68  02403021   ADDU A2, S2, ZERO
788:                 	memset((int8_t *)(&color_buffer[y][x]), color_composite, len);
9D01BF6C  3C04A000   LUI A0, -24576
9D01BF70  24841B14   ADDIU A0, A0, 6932
9D01BF74  00942021   ADDU A0, A0, S4
9D01BF78  938581C1   LBU A1, -32319(GP)
9D01BF7C  0F40E9FC   JAL .Letext0, .LFE0, memset
9D01BF80  02403021   ADDU A2, S2, ZERO
789:                 	if (revvideo) video_invert_range(x, y, len);
9D01BF84  93828184   LBU V0, -32380(GP)
9D01BF88  10400006   BEQ V0, ZERO, 0x9D01BFA4
9D01BF8C  8FBF0024   LW RA, 36(SP)
9D01BF90  02002021   ADDU A0, S0, ZERO
9D01BF94  02202821   ADDU A1, S1, ZERO
9D01BF98  0F406FA3   JAL video_invert_range
9D01BF9C  324600FF   ANDI A2, S2, 255
790:                 	}
9D01BFA0  8FBF0024   LW RA, 36(SP)
9D01BFA4  8FB40020   LW S4, 32(SP)
9D01BFA8  8FB3001C   LW S3, 28(SP)
9D01BFAC  8FB20018   LW S2, 24(SP)
9D01BFB0  8FB10014   LW S1, 20(SP)
9D01BFB4  8FB00010   LW S0, 16(SP)
9D01BFB8  03E00008   JR RA
9D01BFBC  27BD0028   ADDIU SP, SP, 40
791:                 
792:                 
793:                 /* Does not respect top/bottom margins */
794:                 void video_putline(int8_t y, int8_t *str)
795:                 	{
9D01BFC0  27BDFFE0   ADDIU SP, SP, -32
9D01BFC4  AFBF001C   SW RA, 28(SP)
9D01BFC8  AFB20018   SW S2, 24(SP)
9D01BFCC  AFB10014   SW S1, 20(SP)
9D01BFD0  AFB00010   SW S0, 16(SP)
796:                 	if (y < 0 || y >= DISP_BUFFER_HIGH) return;
9D01BFD4  308200FF   ANDI V0, A0, 255
9D01BFD8  2C420014   SLTIU V0, V0, 20
9D01BFDC  10400019   BEQ V0, ZERO, .LVL238
9D01BFE0  00808021   ADDU S0, A0, ZERO
9D01BFE4  00A08821   ADDU S1, A1, ZERO
797:                 	/* strncpy fills unused bytes in the destination with nulls */
798:                 	strncpy((int8_t *)(&disp_buffer[y]), str, DISP_BUFFER_WIDE);
9D01BFE8  000490C0   SLL S2, A0, 3
9D01BFEC  00041140   SLL V0, A0, 5
9D01BFF0  02429021   ADDU S2, S2, V0
9D01BFF4  3C04A000   LUI A0, -24576
9D01BFF8  24841E5C   ADDIU A0, A0, 7772
9D01BFFC  00922021   ADDU A0, A0, S2
9D01C000  0F40E397   JAL .LFE23, strncpy
9D01C004  24060028   ADDIU A2, ZERO, 40
799:                 	memset((int8_t *)(&color_buffer[y]), color_composite, strlen(str));
9D01C008  0F40DBFE   JAL strlen
9D01C00C  02202021   ADDU A0, S1, ZERO
9D01C010  3C04A000   LUI A0, -24576
9D01C014  24841B14   ADDIU A0, A0, 6932
9D01C018  00922021   ADDU A0, A0, S2
9D01C01C  938581C1   LBU A1, -32319(GP)
9D01C020  0F40E9FC   JAL .Letext0, .LFE0, memset
9D01C024  00403021   ADDU A2, V0, ZERO
800:                 	if (revvideo) video_invert_range(0, y, DISP_BUFFER_WIDE);
9D01C028  93828184   LBU V0, -32380(GP)
9D01C02C  10400006   BEQ V0, ZERO, 0x9D01C048
9D01C030  8FBF001C   LW RA, 28(SP)
9D01C034  00002021   ADDU A0, ZERO, ZERO
9D01C038  02002821   ADDU A1, S0, ZERO
9D01C03C  0F406FA3   JAL video_invert_range
9D01C040  24060028   ADDIU A2, ZERO, 40
801:                 	}
9D01C044  8FBF001C   LW RA, 28(SP)
9D01C048  8FB20018   LW S2, 24(SP)
9D01C04C  8FB10014   LW S1, 20(SP)
9D01C050  8FB00010   LW S0, 16(SP)
9D01C054  03E00008   JR RA
9D01C058  27BD0020   ADDIU SP, SP, 32
802:                 
803:                 void video_setc(int8_t c)
804:                 	{
805:                 	CURSOR_INVERT();
806:                 	disp_buffer[cy][cx] = c ^ revvideo;
9D01BC18  8383818F   LB V1, -32369(GP)
9D01BC1C  83858190   LB A1, -32368(GP)
9D01BC20  000310C0   SLL V0, V1, 3
9D01BC24  00031940   SLL V1, V1, 5
9D01BC28  00431021   ADDU V0, V0, V1
9D01BC2C  00451021   ADDU V0, V0, A1
9D01BC30  3C03A000   LUI V1, -24576
9D01BC34  24631E5C   ADDIU V1, V1, 7772
9D01BC38  00431821   ADDU V1, V0, V1
9D01BC3C  93858184   LBU A1, -32380(GP)
9D01BC40  00852026   XOR A0, A0, A1
9D01BC44  A0640000   SB A0, 0(V1)
807:                 	color_buffer[cy][cx] = color_composite;
9D01BC48  3C03A000   LUI V1, -24576
9D01BC4C  24631B14   ADDIU V1, V1, 6932
9D01BC50  00431021   ADDU V0, V0, V1
9D01BC54  938381C1   LBU V1, -32319(GP)
9D01BC58  03E00008   JR RA
9D01BC5C  A0430000   SB V1, 0(V0)
808:                 	CURSOR_INVERT();
809:                 	}
810:                 
811:                 static void _video_putc(int8_t c)
812:                 	{
9D01ABA4  27BDFFE8   ADDIU SP, SP, -24
9D01ABA8  AFBF0014   SW RA, 20(SP)
9D01ABAC  AFB00010   SW S0, 16(SP)
813:                 	/* If the last character printed exceeded the right boundary,
814:                 	 * we have to go to a new line. */
815:                 	if (cx >= DISP_BUFFER_WIDE) _video_lfwd();
9D01ABB0  83828190   LB V0, -32368(GP)
9D01ABB4  28420028   SLTI V0, V0, 40
9D01ABB8  14400003   BNE V0, ZERO, .LVL23
9D01ABBC  00808021   ADDU S0, A0, ZERO
9D01ABC0  0F406ACB   JAL .LFB38, _video_lfwd, .LFE29
9D01ABC4  00000000   NOP
816:                 
817:                 	if (c == '\r') cx = 0;
9D01ABC8  2402000D   ADDIU V0, ZERO, 13
9D01ABCC  16020003   BNE S0, V0, 0x9D01ABDC
9D01ABD0  2402000A   ADDIU V0, ZERO, 10
9D01ABD4  0B406B0E   J .LVL25
9D01ABD8  A3808190   SB ZERO, -32368(GP)
818:                 	else if (c == '\n') _video_lfwd();
9D01ABDC  16020005   BNE S0, V0, 0x9D01ABF4
9D01ABE0  8383818F   LB V1, -32369(GP)
9D01ABE4  0F406ACB   JAL .LFB38, _video_lfwd, .LFE29
9D01ABE8  00000000   NOP
9D01ABEC  0B406B0F   J 0x9D01AC3C
9D01ABF0  8FBF0014   LW RA, 20(SP)
819:                 	else
820:                 		{
821:                 		disp_buffer[cy][cx] = c ^ revvideo;
9D01ABF4  83848190   LB A0, -32368(GP)
9D01ABF8  000310C0   SLL V0, V1, 3
9D01ABFC  00031940   SLL V1, V1, 5
9D01AC00  00431021   ADDU V0, V0, V1
9D01AC04  00441021   ADDU V0, V0, A0
9D01AC08  3C03A000   LUI V1, -24576
9D01AC0C  24631E5C   ADDIU V1, V1, 7772
9D01AC10  00431821   ADDU V1, V0, V1
9D01AC14  93848184   LBU A0, -32380(GP)
9D01AC18  02048026   XOR S0, S0, A0
9D01AC1C  A0700000   SB S0, 0(V1)
822:                 		color_buffer[cy][cx] = color_composite;
9D01AC20  3C03A000   LUI V1, -24576
9D01AC24  24631B14   ADDIU V1, V1, 6932
9D01AC28  00431021   ADDU V0, V0, V1
9D01AC2C  938381C1   LBU V1, -32319(GP)
823:                 		_video_cfwd();
9D01AC30  0F406ADB   JAL .LFB39, _video_cfwd, .LFE38
9D01AC34  A0430000   SB V1, 0(V0)
824:                 		}
825:                 	}
9D01AC38  8FBF0014   LW RA, 20(SP)
9D01AC3C  8FB00010   LW S0, 16(SP)
9D01AC40  03E00008   JR RA
9D01AC44  27BD0018   ADDIU SP, SP, 24
826:                 
827:                 void video_putc(int8_t c)
828:                 	{
9D01BC60  27BDFFE8   ADDIU SP, SP, -24
9D01BC64  AFBF0014   SW RA, 20(SP)
829:                 	CURSOR_INVERT();
830:                 	_video_putc(c);
9D01BC68  0F406AE9   JAL .LFB58, _video_putc, .LFE39
9D01BC6C  00000000   NOP
831:                 	CURSOR_INVERT();
832:                 	}
9D01BC70  8FBF0014   LW RA, 20(SP)
9D01BC74  03E00008   JR RA
9D01BC78  27BD0018   ADDIU SP, SP, 24
833:                 
834:                 void video_putc_raw(int8_t c)
835:                 	{
9D01BC7C  27BDFFE8   ADDIU SP, SP, -24
9D01BC80  AFBF0014   SW RA, 20(SP)
9D01BC84  AFB00010   SW S0, 16(SP)
836:                 	CURSOR_INVERT();
837:                 
838:                 	/* If the last character printed exceeded the right boundary,
839:                 	 * we have to go to a new line. */
840:                 	if (cx >= DISP_BUFFER_WIDE) _video_lfwd();
9D01BC88  83828190   LB V0, -32368(GP)
9D01BC8C  28420028   SLTI V0, V0, 40
9D01BC90  14400003   BNE V0, ZERO, .LVL193
9D01BC94  00808021   ADDU S0, A0, ZERO
9D01BC98  0F406ACB   JAL .LFB38, _video_lfwd, .LFE29
9D01BC9C  00000000   NOP
841:                 //jar
842:                 //  disp_buffer[cy][cx] = c ^ revvideo;
843:                 	disp_buffer[cy][cx] = c;
9D01BCA0  8383818F   LB V1, -32369(GP)
9D01BCA4  83848190   LB A0, -32368(GP)
9D01BCA8  000310C0   SLL V0, V1, 3
9D01BCAC  00031940   SLL V1, V1, 5
9D01BCB0  00431021   ADDU V0, V0, V1
9D01BCB4  00441021   ADDU V0, V0, A0
9D01BCB8  3C03A000   LUI V1, -24576
9D01BCBC  24631E5C   ADDIU V1, V1, 7772
9D01BCC0  00431821   ADDU V1, V0, V1
9D01BCC4  A0700000   SB S0, 0(V1)
844:                 	color_buffer[cy][cx] = color_composite;
9D01BCC8  3C03A000   LUI V1, -24576
9D01BCCC  24631B14   ADDIU V1, V1, 6932
9D01BCD0  00431021   ADDU V0, V0, V1
9D01BCD4  938381C1   LBU V1, -32319(GP)
845:                 	_video_cfwd();
9D01BCD8  0F406ADB   JAL .LFB39, _video_cfwd, .LFE38
9D01BCDC  A0430000   SB V1, 0(V0)
846:                 	CURSOR_INVERT();
847:                 	}
9D01BCE0  8FBF0014   LW RA, 20(SP)
9D01BCE4  8FB00010   LW S0, 16(SP)
9D01BCE8  03E00008   JR RA
9D01BCEC  27BD0018   ADDIU SP, SP, 24
848:                 
849:                 void video_puts(int8_t *str)
850:                 	{
9D01BE18  27BDFFE8   ADDIU SP, SP, -24
9D01BE1C  AFBF0014   SW RA, 20(SP)
9D01BE20  AFB00010   SW S0, 16(SP)
851:                 	/* Characters are interpreted and printed one at a time. */
852:                 	int8_t c;
853:                 	CURSOR_INVERT();
854:                 	while ((c = *str++))
9D01BE24  24900001   ADDIU S0, A0, 1
9D01BE28  80840000   LB A0, 0(A0)
9D01BE2C  10800006   BEQ A0, ZERO, 0x9D01BE48
9D01BE30  8FBF0014   LW RA, 20(SP)
9D01BE3C  8204FFFF   LB A0, -1(S0)
9D01BE40  1480FFFC   BNE A0, ZERO, 0x9D01BE34
9D01BE44  8FBF0014   LW RA, 20(SP)
855:                 		_video_putc(c);
9D01BE34  0F406AE9   JAL .LFB58, _video_putc, .LFE39
9D01BE38  26100001   ADDIU S0, S0, 1
856:                 	CURSOR_INVERT();
857:                 	}
9D01BE48  8FB00010   LW S0, 16(SP)
9D01BE4C  03E00008   JR RA
9D01BE50  27BD0018   ADDIU SP, SP, 24
858:                 
859:                 void video_show_cursor()
860:                 	{
861:                 	if (!showcursor)
9D01BE54  9382818E   LBU V0, -32370(GP)
9D01BE58  14400002   BNE V0, ZERO, 0x9D01BE64
9D01BE5C  2402FF80   ADDIU V0, ZERO, -128
862:                 		{
863:                 		showcursor = 0x80;
9D01BE60  A382818E   SB V0, -32370(GP)
9D01BE64  03E00008   JR RA
9D01BE68  00000000   NOP
864:                 		CURSOR_INVERT();
865:                 		}
866:                 	}
867:                 
868:                 void video_hide_cursor()
869:                 	{
870:                 	if (showcursor)
9D01BE6C  9382818E   LBU V0, -32370(GP)
9D01BE70  54400001   BNEL V0, ZERO, 0x9D01BE78
9D01BE74  A380818E   SB ZERO, -32370(GP)
9D01BE78  03E00008   JR RA
9D01BE7C  00000000   NOP
871:                 		{
872:                 		CURSOR_INVERT();
873:                 		showcursor = 0;
874:                 		}
875:                 	}
876:                 
877:                 uint8_t video_cursor_visible()
878:                 	{
879:                 	return showcursor != 0;
9D01BE80  9382818E   LBU V0, -32370(GP)
880:                 	}
9D01BE84  03E00008   JR RA
9D01BE88  0002102B   SLTU V0, ZERO, V0
881:                 
882:                 void video_invert_range(int8_t x, int8_t y, uint8_t rangelen)
883:                 	{
884:                 	int8_t *start = &disp_buffer[y][x];
9D01BE8C  000510C0   SLL V0, A1, 3
9D01BE90  00052940   SLL A1, A1, 5
9D01BE94  00451021   ADDU V0, V0, A1
9D01BE98  00442021   ADDU A0, V0, A0
9D01BE9C  3C02A000   LUI V0, -24576
9D01BEA0  24421E5C   ADDIU V0, V0, 7772
885:                 	uint8_t i;
886:                 	for (i = 0; i < rangelen; i++)
9D01BEA4  10C0000C   BEQ A2, ZERO, 0x9D01BED8
9D01BEA8  00441021   ADDU V0, V0, A0
9D01BEAC  24C5FFFF   ADDIU A1, A2, -1
9D01BEB0  30A500FF   ANDI A1, A1, 255
9D01BEB4  24A50001   ADDIU A1, A1, 1
9D01BEB8  00452821   ADDU A1, V0, A1
9D01BED0  5445FFFC   BNEL V0, A1, 0x9D01BEC4
9D01BED4  90430000   LBU V1, 0(V0)
9D01BED8  03E00008   JR RA
9D01BEDC  00000000   NOP
887:                 		{
888:                 		*start ^= 0x80;
9D01BEBC  2404FF80   ADDIU A0, ZERO, -128
9D01BEC0  90430000   LBU V1, 0(V0)
9D01BEC4  00641826   XOR V1, V1, A0
9D01BEC8  A0430000   SB V1, 0(V0)
889:                 		start++;
9D01BECC  24420001   ADDIU V0, V0, 1
9D01BED0  5445FFFC   BNEL V0, A1, 0x9D01BEC4
9D01BED4  90430000   LBU V1, 0(V0)
9D01BED8  03E00008   JR RA
9D01BEDC  00000000   NOP
890:                 		}
891:                 	}
892:                 
893:                 static void CURSOR_INVERT(void)
894:                 	{
895:                 //jar
896:                 //  disp_buffer[cy][cx] ^= showcursor;
897:                 	}
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/vid_drv.c  ---------------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** vid_drv.c
21:                  **
22:                  ** Video driver
23:                  ** $Id: vid_drv.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <string.h>
27:                  #include <noftypes.h>
28:                  #include <log.h>
29:                  #include <bitmap.h>
30:                  #include <vid_drv.h>
31:                  #include <gui.h>
32:                  #include <osd.h>
33:                  
34:                  /* hardware surface */
35:                  static bitmap_t *screen = NULL;
36:                  
37:                  /* primary / backbuffer surfaces */
38:                  bitmap_t *primary_buffer = NULL; //, *back_buffer = NULL;
39:                  
40:                  static viddriver_t *driver = NULL;
41:                  
42:                  /* fast automagic loop unrolling */
43:                  #define  DUFFS_DEVICE(transfer, count) \
44:                  { \
45:                     register int n = (count + 7) / 8; \
46:                     switch (count % 8) \
47:                     { \
48:                     case 0:  do {  { transfer; } \
49:                     case 7:        { transfer; } \
50:                     case 6:        { transfer; } \
51:                     case 5:        { transfer; } \
52:                     case 4:        { transfer; } \
53:                     case 3:        { transfer; } \
54:                     case 2:        { transfer; } \
55:                     case 1:        { transfer; } \
56:                              } while (--n > 0); \
57:                     } \
58:                  }
59:                  
60:                  /* some system dependent replacement routines (for speed) */
61:                  INLINE int vid_memcmp(const void *p1, const void *p2, int len)
62:                  {
63:                     /* check for 32-bit aligned data */
64:                     if (0 == (((uint32) p1 & 3) | ((uint32) p2 & 3)))
65:                     {
66:                        uint32 *dw1 = (uint32 *) p1;
67:                        uint32 *dw2 = (uint32 *) p2;
68:                  
69:                        len >>= 2;
70:                  
71:                        DUFFS_DEVICE(if (*dw1++ != *dw2++) return -1, len);
72:                     }
73:                     else
74:                     /* fall back to 8-bit compares */
75:                     {
76:                        uint8 *b1 = (uint8 *) p1;
77:                        uint8 *b2 = (uint8 *) p2;
78:                        
79:                        DUFFS_DEVICE(if (*b1++ != *b2++) return -1, len);
80:                     }
81:                     
82:                     return 0;
83:                  }
84:                  
85:                  /* super-dooper assembly memcpy (thanks, SDL!) */
86:                  #if defined(__GNUC__) && defined(i386)
87:                  #define vid_memcpy(dest, src, len) \
88:                  { \
89:                     int u0, u1, u2; \
90:                     __asm__ __volatile__ ( \
91:                        "  cld            \n" \
92:                        "  rep            \n" \
93:                        "  movsl          \n" \
94:                        "  testb $2,%b4   \n" \
95:                        "  je    1f       \n" \
96:                        "  movsw          \n" \
97:                        "1:               \n" \
98:                        "  testb $1,%b4   \n" \
99:                        "  je 2f          \n" \
100:                       "  movsb          \n" \
101:                       "2:               \n" \
102:                       : "=&c" (u0), "=&D" (u1), "=&S" (u2) \
103:                       : "0" ((len)/4), "q" (len), "1" (dest), "2" (src) \
104:                       : "memory"); \
105:                 }
106:                 #else /* !(defined(__GNUC__) && defined(i386)) */
107:                 INLINE void vid_memcpy(void *dest, const void *src, int len)
108:                 {
109:                    uint32 *s = (uint32 *) src;
110:                    uint32 *d = (uint32 *) dest;
111:                 
112:                    ASSERT(0 == ((len & 3) | ((uint32) src & 3) | ((uint32) dest & 3)));
113:                    len >>= 2;
9D02EC64  00081083   SRA V0, T0, 2
114:                 
115:                    DUFFS_DEVICE(*d++ = *s++, len);
9D02EC68  24430007   ADDIU V1, V0, 7
9D02EC6C  2444000E   ADDIU A0, V0, 14
9D02EC70  286C0000   SLTI T4, V1, 0
9D02EC74  008C180B   MOVN V1, A0, T4
9D02EC78  000360C3   SRA T4, V1, 3
9D02EC7C  000847C3   SRA T0, T0, 31
9D02EC80  00084742   SRL T0, T0, 29
9D02EC84  00481021   ADDU V0, V0, T0
9D02EC88  30420007   ANDI V0, V0, 7
9D02EC8C  00481023   SUBU V0, V0, T0
9D02EC90  2C4B0008   SLTIU T3, V0, 8
9D02EC94  00021080   SLL V0, V0, 2
9D02EC98  3C0D9D03   LUI T5, -25341
9D02EC9C  25ADECBC   ADDIU T5, T5, -4932
9D02ECA0  01A26821   ADDU T5, T5, V0
9D02ECA8  5160004F   BEQL T3, ZERO, 0x9D02EDE8
9D02ECAC  00AE2821   ADDU A1, A1, T6
9D02ECB0  8DA40000   LW A0, 0(T5)
9D02ECB4  00800008   JR A0
9D02ECB8  00000000   NOP
9D02ECDC  01801021   ADDU V0, T4, ZERO
9D02ECE0  00E02021   ADDU A0, A3, ZERO
9D02ECE4  00A01821   ADDU V1, A1, ZERO
9D02ECE8  24880004   ADDIU T0, A0, 4
9D02ECEC  24690004   ADDIU T1, V1, 4
9D02ECF0  8C630000   LW V1, 0(V1)
9D02ECF4  0B40BB42   J 0x9D02ED08
9D02ECF8  AC830000   SW V1, 0(A0)
9D02ECFC  01801021   ADDU V0, T4, ZERO
9D02ED00  00E04021   ADDU T0, A3, ZERO
9D02ED04  00A04821   ADDU T1, A1, ZERO
9D02ED08  25030004   ADDIU V1, T0, 4
9D02ED0C  25260004   ADDIU A2, T1, 4
9D02ED10  8D240000   LW A0, 0(T1)
9D02ED14  0B40BB4A   J 0x9D02ED28
9D02ED18  AD040000   SW A0, 0(T0)
9D02ED1C  01801021   ADDU V0, T4, ZERO
9D02ED20  00E01821   ADDU V1, A3, ZERO
9D02ED24  00A03021   ADDU A2, A1, ZERO
9D02ED28  24640004   ADDIU A0, V1, 4
9D02ED2C  24C80004   ADDIU T0, A2, 4
9D02ED30  8CC60000   LW A2, 0(A2)
9D02ED34  0B40BB52   J 0x9D02ED48
9D02ED38  AC660000   SW A2, 0(V1)
9D02ED3C  01801021   ADDU V0, T4, ZERO
9D02ED40  00E02021   ADDU A0, A3, ZERO
9D02ED44  00A04021   ADDU T0, A1, ZERO
9D02ED48  24830004   ADDIU V1, A0, 4
9D02ED4C  25060004   ADDIU A2, T0, 4
9D02ED50  8D080000   LW T0, 0(T0)
9D02ED54  0B40BB5A   J 0x9D02ED68
9D02ED58  AC880000   SW T0, 0(A0)
9D02ED5C  01801021   ADDU V0, T4, ZERO
9D02ED60  00E01821   ADDU V1, A3, ZERO
9D02ED64  00A03021   ADDU A2, A1, ZERO
9D02ED68  24640004   ADDIU A0, V1, 4
9D02ED6C  24C90004   ADDIU T1, A2, 4
9D02ED70  8CC60000   LW A2, 0(A2)
9D02ED74  0B40BB62   J 0x9D02ED88
9D02ED78  AC660000   SW A2, 0(V1)
9D02ED7C  01801021   ADDU V0, T4, ZERO
9D02ED80  00E02021   ADDU A0, A3, ZERO
9D02ED84  00A04821   ADDU T1, A1, ZERO
9D02ED88  24860004   ADDIU A2, A0, 4
9D02ED8C  25280004   ADDIU T0, T1, 4
9D02ED90  8D230000   LW V1, 0(T1)
9D02ED94  0B40BB6A   J 0x9D02EDA8
9D02ED98  AC830000   SW V1, 0(A0)
9D02ED9C  01801021   ADDU V0, T4, ZERO
9D02EDA0  00E03021   ADDU A2, A3, ZERO
9D02EDA4  00A04021   ADDU T0, A1, ZERO
9D02EDA8  24C40004   ADDIU A0, A2, 4
9D02EDAC  25030004   ADDIU V1, T0, 4
9D02EDB0  8D080000   LW T0, 0(T0)
9D02EDB4  0B40BB72   J 0x9D02EDC8
9D02EDB8  ACC80000   SW T0, 0(A2)
9D02EDBC  01801021   ADDU V0, T4, ZERO
9D02EDC0  00E02021   ADDU A0, A3, ZERO
9D02EDC4  00A01821   ADDU V1, A1, ZERO
9D02EDC8  8C660000   LW A2, 0(V1)
9D02EDCC  2442FFFF   ADDIU V0, V0, -1
9D02EDD0  18400004   BLEZ V0, 0x9D02EDE4
9D02EDD4  AC860000   SW A2, 0(A0)
9D02EDD8  24840004   ADDIU A0, A0, 4
9D02EDDC  0B40BB3A   J 0x9D02ECE8
9D02EDE0  24630004   ADDIU V1, V1, 4
116:                 }
117:                 #endif /* !(defined(__GNUC__) && defined(i386)) */
118:                 
119:                 
120:                 /* TODO: any way to remove this filth (GUI needs it)? */
121:                 bitmap_t *vid_getbuffer(void)
122:                 {
123:                    return primary_buffer;
124:                 }
9D02EB44  03E00008   JR RA
9D02EB48  8F82812C   LW V0, -32468(GP)
125:                 
126:                 void vid_setpalette(rgb_t *p)
127:                 {
9D02EB4C  27BDFFE8   ADDIU SP, SP, -24
9D02EB50  AFBF0014   SW RA, 20(SP)
128:                    ASSERT(driver);
129:                    ASSERT(p);
130:                 
131:                    driver->set_palette(p);
9D02EB54  8F828128   LW V0, -32472(GP)
9D02EB58  8C420010   LW V0, 16(V0)
9D02EB5C  0040F809   JALR V0
9D02EB60  00000000   NOP
132:                 }
9D02EB64  8FBF0014   LW RA, 20(SP)
9D02EB68  03E00008   JR RA
9D02EB6C  27BD0018   ADDIU SP, SP, 24
133:                 
134:                 /* blits a bitmap onto primary buffer */
135:                 void vid_blit(bitmap_t *bitmap, int src_x, int src_y, int dest_x, int dest_y, 
136:                               int width, int height)
137:                 {
9D02EB70  8FA90010   LW T1, 16(SP)
9D02EB74  8FA80014   LW T0, 20(SP)
138:                    int bitmap_pitch, primary_pitch;
139:                    uint8 *dest_ptr, *src_ptr;
140:                 
141:                    ASSERT(bitmap);
142:                 
143:                    /* clip to source */
144:                    if (src_y >= bitmap->height)
9D02EB78  8C830004   LW V1, 4(A0)
9D02EB7C  00C3502A   SLT T2, A2, V1
9D02EB80  1140009C   BEQ T2, ZERO, 0x9D02EDF4
9D02EB84  8FA20018   LW V0, 24(SP)
145:                       return;
146:                    if (src_y + height > bitmap->height)
9D02EB88  00C25021   ADDU T2, A2, V0
9D02EB8C  006A502A   SLT T2, V1, T2
147:                       height = bitmap->height - src_y;
9D02EB90  00661823   SUBU V1, V1, A2
9D02EB94  006A100B   MOVN V0, V1, T2
148:                 
149:                    if (src_x >= bitmap->width)
9D02EB98  8C830000   LW V1, 0(A0)
9D02EB9C  00A3502A   SLT T2, A1, V1
9D02EBA0  11400094   BEQ T2, ZERO, 0x9D02EDF4
9D02EBA4  00A85021   ADDU T2, A1, T0
150:                       return;
151:                    if (src_x + width > bitmap->width)
9D02EBA8  006A502A   SLT T2, V1, T2
152:                       width = bitmap->width - src_x;
9D02EBAC  00651823   SUBU V1, V1, A1
9D02EBB0  006A400B   MOVN T0, V1, T2
153:                 
154:                    /* clip to dest */
155:                    if (dest_y + height <= 0)
9D02EBB4  01221821   ADDU V1, T1, V0
9D02EBB8  1860008E   BLEZ V1, 0x9D02EDF4
9D02EBBC  00000000   NOP
156:                    {
157:                       return;
158:                    }
159:                    else if (dest_y < 0)
9D02EBC0  05210004   BGEZ T1, 0x9D02EBD4
9D02EBC4  8F8A812C   LW T2, -32468(GP)
160:                    {
161:                       height += dest_y;
9D02EBCC  00601021   ADDU V0, V1, ZERO
162:                       src_y -= dest_y;
9D02EBC8  00C93023   SUBU A2, A2, T1
163:                       dest_y = 0;
9D02EBD0  00004821   ADDU T1, ZERO, ZERO
164:                    }
165:                 
166:                    if (dest_y >= primary_buffer->height)
9D02EBD4  8D430004   LW V1, 4(T2)
9D02EBD8  0123582A   SLT T3, T1, V1
9D02EBDC  11600085   BEQ T3, ZERO, 0x9D02EDF4
9D02EBE0  01225821   ADDU T3, T1, V0
167:                       return;
168:                    if (dest_y + height > primary_buffer->height)
9D02EBE4  006B582A   SLT T3, V1, T3
169:                       height = primary_buffer->height - dest_y;
9D02EBE8  00691823   SUBU V1, V1, T1
9D02EBEC  006B100B   MOVN V0, V1, T3
170:                 
171:                    if (dest_x + width <= 0)
9D02EBF0  00E81821   ADDU V1, A3, T0
9D02EBF4  1860007F   BLEZ V1, 0x9D02EDF4
9D02EBF8  00000000   NOP
172:                    {
173:                       return;
174:                    }
175:                    else if (dest_x < 0)
9D02EBFC  04E30005   BGEZL A3, 0x9D02EC14
9D02EC00  8D430000   LW V1, 0(T2)
176:                    {
177:                       width += dest_x;
9D02EC08  00604021   ADDU T0, V1, ZERO
178:                       src_x -= dest_x;
9D02EC04  00A72823   SUBU A1, A1, A3
179:                       dest_x = 0;
9D02EC0C  00003821   ADDU A3, ZERO, ZERO
180:                    }
181:                 
182:                    if (dest_x >= primary_buffer->width)
9D02EC10  8D430000   LW V1, 0(T2)
9D02EC14  00E3582A   SLT T3, A3, V1
9D02EC18  11600076   BEQ T3, ZERO, 0x9D02EDF4
9D02EC1C  00E85821   ADDU T3, A3, T0
183:                       return;
184:                    if (dest_x + width > primary_buffer->width)
9D02EC20  006B582A   SLT T3, V1, T3
185:                       width = primary_buffer->width - dest_x;   
9D02EC24  00671823   SUBU V1, V1, A3
9D02EC28  006B400B   MOVN T0, V1, T3
186:                 
187:                    src_ptr = bitmap->line[src_y] + src_x;
9D02EC2C  24C60004   ADDIU A2, A2, 4
9D02EC30  00063080   SLL A2, A2, 2
9D02EC34  00863021   ADDU A2, A0, A2
9D02EC38  8CC30004   LW V1, 4(A2)
9D02EC3C  00652821   ADDU A1, V1, A1
188:                    dest_ptr = primary_buffer->line[dest_y] + dest_x;
9D02EC40  25290004   ADDIU T1, T1, 4
9D02EC44  00094880   SLL T1, T1, 2
9D02EC48  01494821   ADDU T1, T2, T1
9D02EC4C  8D230004   LW V1, 4(T1)
9D02EC50  00673821   ADDU A3, V1, A3
189:                 
190:                    /* Avoid doing unnecessary indexed lookups */
191:                    bitmap_pitch = bitmap->pitch;
9D02EC54  8C8E0008   LW T6, 8(A0)
192:                    primary_pitch = primary_buffer->pitch;
9D02EC58  8D4F0008   LW T7, 8(T2)
193:                 
194:                    /* do the copy */
195:                    while (height--)
9D02EC5C  10400065   BEQ V0, ZERO, 0x9D02EDF4
9D02EC60  244AFFFF   ADDIU T2, V0, -1
9D02ECA4  2418FFFF   ADDIU T8, ZERO, -1
9D02EDE8  254AFFFF   ADDIU T2, T2, -1
9D02EDEC  1558FFAE   BNE T2, T8, 0x9D02ECA8
9D02EDF0  00EF3821   ADDU A3, A3, T7
9D02EDF4  03E00008   JR RA
9D02EDF8  00000000   NOP
196:                    {
197:                       vid_memcpy(dest_ptr, src_ptr, width);
198:                       src_ptr += bitmap_pitch;
9D02EDE4  00AE2821   ADDU A1, A1, T6
9D02EDE8  254AFFFF   ADDIU T2, T2, -1
9D02EDEC  1558FFAE   BNE T2, T8, 0x9D02ECA8
9D02EDF0  00EF3821   ADDU A3, A3, T7
9D02EDF4  03E00008   JR RA
9D02EDF8  00000000   NOP
199:                       dest_ptr += primary_pitch;
200:                    }
201:                 }
202:                 
203:                 static void vid_blitscreen(int num_dirties, rect_t *dirty_rects)
204:                 {
205:                    int src_x, src_y, dest_x, dest_y;
206:                    int blit_width, blit_height;
207:                 
208:                    screen = driver->lock_write();
209:                 
210:                    /* center in y direction */
211:                    if (primary_buffer->height <= screen->height)
212:                    {
213:                       src_y = 0;
214:                       blit_height = primary_buffer->height;
215:                       dest_y = (screen->height - blit_height) >> 1;
216:                    }
217:                    else
218:                    {
219:                       src_y = (primary_buffer->height - screen->height) >> 1;
220:                       blit_height = screen->height;
221:                       dest_y = 0;
222:                    }
223:                 
224:                    /* and in x */
225:                    if (primary_buffer->width <= screen->width)
226:                    {
227:                       src_x = 0;
228:                       blit_width = primary_buffer->width;
229:                       dest_x = (screen->width - blit_width) >> 1;
230:                    }
231:                    else
232:                    {
233:                       src_x = (primary_buffer->width - screen->width) >> 1;
234:                       blit_width = screen->width;
235:                       dest_x = 0;
236:                    }
237:                    
238:                    /* should we just copy the entire screen? */
239:                    if (-1 == num_dirties)
240:                    {
241:                       uint8 *dest, *src;
242:                 
243:                       src = primary_buffer->line[src_y] + src_x;
244:                       dest = screen->line[dest_y] + dest_x;
245:                 
246:                       while (blit_height--)
247:                       {
248:                          vid_memcpy(dest, src, primary_buffer->width);
249:                          src += primary_buffer->pitch;
250:                          dest += screen->pitch;
251:                       }
252:                    }
253:                    else
254:                    {
255:                       /* we need to blit just a bunch of dirties */
256:                       int i, j, height;
257:                       rect_t *rects = dirty_rects;
258:                 
259:                       for (i = 0; i < num_dirties && blit_height; i++)
260:                       {
261:                          height = rects->h;
262:                          if (blit_height < height)
263:                             height = blit_height;
264:                 
265:                          j = 0;
266:                          DUFFS_DEVICE(  
267:                          {
268:                             vid_memcpy(screen->line[dest_y + rects->y + j] + rects->x + dest_x,
269:                                        primary_buffer->line[src_y + rects->y + j] + rects->x + src_x,
270:                                        rects->w);
271:                             j++;
272:                             blit_height--;
273:                          }, height);
274:                 
275:                          rects++;
276:                       }
277:                    }
278:                 
279:                    if (driver->free_write)
280:                       driver->free_write(num_dirties, dirty_rects);
281:                 }
282:                 
283:                 /* TODO: this code is sickly */
284:                 
285:                 #define  CHUNK_WIDTH    256
286:                 #define  CHUNK_HEIGHT   16
287:                 #define  MAX_DIRTIES    ((256 / CHUNK_WIDTH) * (240 / CHUNK_HEIGHT))
288:                 #define  DIRTY_CUTOFF   ((3 * MAX_DIRTIES) / 4)
289:                 
290:                 #if 0
291:                 INLINE int calc_dirties(rect_t *list)
292:                 {
293:                    bool dirty;
294:                    int num_dirties = 0;
295:                    int i = 0, j, line_offset = 0;
296:                    int iterations = primary_buffer->height / CHUNK_HEIGHT;
297:                 
298:                    for (i = 0; i < iterations; i++)
299:                    {
300:                       dirty = false;
301:                 
302:                       j = line_offset;
303:                       DUFFS_DEVICE(
304:                       { 
305:                          if (vid_memcmp(back_buffer->line[j], primary_buffer->line[j], 
306:                                         CHUNK_WIDTH))
307:                          { 
308:                             dirty = true; 
309:                             break; 
310:                          } 
311:                 
312:                          j++; 
313:                       }, CHUNK_HEIGHT);
314:                 
315:                       if (true == dirty)
316:                       {
317:                          list->h = CHUNK_HEIGHT;
318:                          list->w = CHUNK_WIDTH;
319:                          list->x = 0;
320:                          list->y = line_offset;
321:                          list++;
322:                 
323:                          /* totally arbitrary at this point */
324:                          if (++num_dirties > DIRTY_CUTOFF)
325:                             return -1;
326:                       }
327:                 
328:                       line_offset += CHUNK_HEIGHT;
329:                    }
330:                 
331:                    return num_dirties;
332:                 }
333:                 #endif
334:                 
335:                 void vid_flush(void)
336:                 {
9D02EDFC  03E00008   JR RA
9D02EE00  00000000   NOP
337:                    bitmap_t *temp;
338:                    int num_dirties;
339:                    rect_t dirty_rects[MAX_DIRTIES];
340:                 
341:                    //ASSERT(driver);
342:                 
343:                 //   if (true == driver->invalidate)
344:                 //   {
345:                 //      driver->invalidate = false;
346:                 //      num_dirties = -1;
347:                 //   }
348:                    //else
349:                    //{
350:                       //num_dirties = calc_dirties(dirty_rects);
351:                       num_dirties = -1;
352:                    //}
353:                 
354:                    //if (driver->custom_blit)
355:                    //   driver->custom_blit(primary_buffer, num_dirties, dirty_rects);
356:                    //else
357:                       //vid_blitscreen(num_dirties, dirty_rects);
358:                 
359:                    /* Swap pointers to the main/back buffers */
360:                 //   temp = back_buffer;
361:                 //   back_buffer = primary_buffer;
362:                 //   primary_buffer = temp;
363:                 }
364:                 
365:                 /* emulated machine tells us which resolution it wants */
366:                 int vid_setmode(int width, int height)
367:                 {
9D02EE04  27BDFFE0   ADDIU SP, SP, -32
9D02EE08  AFBF001C   SW RA, 28(SP)
9D02EE0C  AFB10018   SW S1, 24(SP)
9D02EE10  AFB00014   SW S0, 20(SP)
9D02EE14  00808821   ADDU S1, A0, ZERO
368:                    if (NULL != primary_buffer)
9D02EE18  8F82812C   LW V0, -32468(GP)
9D02EE1C  10400003   BEQ V0, ZERO, .LVL59
9D02EE20  00A08021   ADDU S0, A1, ZERO
369:                       bmp_destroy(&primary_buffer);
9D02EE24  0F40D5FC   JAL bmp_destroy
9D02EE28  2784812C   ADDIU A0, GP, -32468
370:                 //   if (NULL != back_buffer)
371:                 //      bmp_destroy(&back_buffer);
372:                 
373:                    primary_buffer = bmp_create(width, height, 0); /* no overdraw */
9D02EE2C  02202021   ADDU A0, S1, ZERO
9D02EE30  02002821   ADDU A1, S0, ZERO
9D02EE34  0F40D5D1   JAL bmp_create
9D02EE38  00003021   ADDU A2, ZERO, ZERO
374:                    if (NULL == primary_buffer)
9D02EE3C  10400006   BEQ V0, ZERO, 0x9D02EE58
9D02EE40  AF82812C   SW V0, -32468(GP)
375:                       return -1;
9D02EE58  2402FFFF   ADDIU V0, ZERO, -1
376:                 
377:                    /* Create our backbuffer */
378:                 #if 0
379:                    back_buffer = bmp_create(width, height, 0); /* no overdraw */
380:                    if (NULL == back_buffer)
381:                    {
382:                       bmp_destroy(&primary_buffer);
383:                       return -1;
384:                    }
385:                    bmp_clear(back_buffer, GUI_BLACK);
386:                 #endif
387:                    bmp_clear(primary_buffer, GUI_BLACK);
9D02EE44  00402021   ADDU A0, V0, ZERO
9D02EE48  0F40D5C7   JAL bmp_clear
9D02EE4C  240500C0   ADDIU A1, ZERO, 192
388:                 
389:                    return 0;
9D02EE50  0B40BB97   J 0x9D02EE5C
9D02EE54  00001021   ADDU V0, ZERO, ZERO
390:                 }
9D02EE5C  8FBF001C   LW RA, 28(SP)
9D02EE60  8FB10018   LW S1, 24(SP)
9D02EE64  8FB00014   LW S0, 20(SP)
9D02EE68  03E00008   JR RA
9D02EE6C  27BD0020   ADDIU SP, SP, 32
391:                 
392:                 static int vid_findmode(int width, int height, viddriver_t *osd_driver)
393:                 {
394:                    if (osd_driver->init(width, height))
9D02EE90  8CC20004   LW V0, 4(A2)
9D02EE94  0040F809   JALR V0
9D02EE98  00C08021   ADDU S0, A2, ZERO
9D02EE9C  1040000A   BEQ V0, ZERO, 0x9D02EEC8
9D02EEA0  00408821   ADDU S1, V0, ZERO
395:                    {
396:                       driver = NULL;
9D02EEA4  AF808128   SW ZERO, -32472(GP)
397:                       return -1; /* mode not available! */
398:                    }
399:                 
400:                    /* we got our driver */
401:                    driver = osd_driver;
9D02EEC8  AF908128   SW S0, -32472(GP)
402:                 
403:                    /* re-assert dimensions, clear the surface */
404:                    screen = driver->lock_write();
9D02EECC  8E020018   LW V0, 24(S0)
9D02EED0  0040F809   JALR V0
9D02EED4  00000000   NOP
9D02EED8  AF828130   SW V0, -32464(GP)
405:                 
406:                    /* use custom pageclear, if necessary */
407:                    if (driver->clear)
9D02EEDC  8F838128   LW V1, -32472(GP)
9D02EEE0  8C630014   LW V1, 20(V1)
9D02EEE4  10600005   BEQ V1, ZERO, 0x9D02EEFC
9D02EEE8  00402021   ADDU A0, V0, ZERO
408:                       driver->clear(GUI_BLACK);
9D02EEEC  0060F809   JALR V1
9D02EEF0  240400C0   ADDIU A0, ZERO, 192
409:                    else
410:                       bmp_clear(screen, GUI_BLACK);
9D02EEFC  0F40D5C7   JAL bmp_clear
9D02EF00  240500C0   ADDIU A1, ZERO, 192
411:                 
412:                    /* release surface */
413:                    if (driver->free_write)
9D02EEF4  0B40BBC2   J 0x9D02EF08
9D02EEF8  8F828128   LW V0, -32472(GP)
9D02EF04  8F828128   LW V0, -32472(GP)
9D02EF08  8C42001C   LW V0, 28(V0)
9D02EF0C  50400005   BEQL V0, ZERO, 0x9D02EF24
9D02EF10  8F828130   LW V0, -32464(GP)
414:                       driver->free_write(-1, NULL);
9D02EF14  2404FFFF   ADDIU A0, ZERO, -1
9D02EF18  0040F809   JALR V0
9D02EF1C  00002821   ADDU A1, ZERO, ZERO
415:                 
416:                    log_printf("video driver: %s at %dx%d\n", driver->name,
9D02EF24  3C049D04   LUI A0, -25340
9D02EF28  2484BC2C   ADDIU A0, A0, -17364
9D02EF2C  8F838128   LW V1, -32472(GP)
9D02EF30  8C650000   LW A1, 0(V1)
9D02EF34  8C460000   LW A2, 0(V0)
9D02EF38  0F40F11B   JAL log_printf
9D02EF3C  8C470004   LW A3, 4(V0)
417:                               screen->width, screen->height);
9D02EF20  8F828130   LW V0, -32464(GP)
418:                 
419:                    return 0;
420:                 }
421:                 
422:                 /* This is the interface to the drivers, used in nofrendo.c */
423:                 int vid_init(int width, int height, viddriver_t *osd_driver)
424:                 {
9D02EE70  27BDFFD8   ADDIU SP, SP, -40
9D02EE74  AFBF0024   SW RA, 36(SP)
9D02EE78  AFB30020   SW S3, 32(SP)
9D02EE7C  AFB2001C   SW S2, 28(SP)
9D02EE80  AFB10018   SW S1, 24(SP)
9D02EE84  AFB00014   SW S0, 20(SP)
9D02EE88  00809821   ADDU S3, A0, ZERO
9D02EE8C  00A09021   ADDU S2, A1, ZERO
425:                    if (vid_findmode(width, height, osd_driver))
426:                    {
427:                       log_printf("video initialization failed for %s at %dx%d\n",
9D02EEA8  3C049D04   LUI A0, -25340
9D02EEAC  2484BBFC   ADDIU A0, A0, -17412
9D02EEB0  8E050000   LW A1, 0(S0)
9D02EEB4  02603021   ADDU A2, S3, ZERO
9D02EEB8  0F40F11B   JAL log_printf
9D02EEBC  02403821   ADDU A3, S2, ZERO
428:                                  osd_driver->name, width, height);
429:                       return -1;
9D02EEC0  0B40BBD3   J .LVL73
9D02EEC4  2411FFFF   ADDIU S1, ZERO, -1
430:                    }
431:                 	log_printf("vid_init done\n");
9D02EF40  3C049D04   LUI A0, -25340
9D02EF44  0F40F11B   JAL log_printf
9D02EF48  2484BC48   ADDIU A0, A0, -17336
432:                 
433:                    return 0;
434:                 }
9D02EF4C  02201021   ADDU V0, S1, ZERO
9D02EF50  8FBF0024   LW RA, 36(SP)
9D02EF54  8FB30020   LW S3, 32(SP)
9D02EF58  8FB2001C   LW S2, 28(SP)
9D02EF5C  8FB10018   LW S1, 24(SP)
9D02EF60  8FB00014   LW S0, 20(SP)
9D02EF64  03E00008   JR RA
9D02EF68  27BD0028   ADDIU SP, SP, 40
435:                 
436:                 void vid_shutdown(void)
437:                 {
9D02EF6C  27BDFFE8   ADDIU SP, SP, -24
9D02EF70  AFBF0014   SW RA, 20(SP)
438:                    if (NULL == driver)
9D02EF74  8F828128   LW V0, -32472(GP)
9D02EF78  1040000D   BEQ V0, ZERO, 0x9D02EFB0
9D02EF7C  8F83812C   LW V1, -32468(GP)
439:                       return;
440:                 
441:                    if (NULL != primary_buffer)
9D02EF80  50600007   BEQL V1, ZERO, 0x9D02EFA0
9D02EF84  8C420008   LW V0, 8(V0)
442:                       bmp_destroy(&primary_buffer);
9D02EF88  0F40D5FC   JAL bmp_destroy
9D02EF8C  2784812C   ADDIU A0, GP, -32468
443:                 #if 0
444:                    if (NULL != back_buffer)
445:                       bmp_destroy(&back_buffer);
446:                 #endif
447:                 
448:                    if (driver && driver->shutdown)
9D02EF90  8F828128   LW V0, -32472(GP)
9D02EF94  10400007   BEQ V0, ZERO, 0x9D02EFB4
9D02EF98  8FBF0014   LW RA, 20(SP)
9D02EF9C  8C420008   LW V0, 8(V0)
9D02EFA0  10400004   BEQ V0, ZERO, 0x9D02EFB4
9D02EFA4  8FBF0014   LW RA, 20(SP)
449:                       driver->shutdown();
9D02EFA8  0040F809   JALR V0
9D02EFAC  00000000   NOP
450:                 }
9D02EFB0  8FBF0014   LW RA, 20(SP)
9D02EFB4  03E00008   JR RA
9D02EFB8  27BD0018   ADDIU SP, SP, 24
451:                 
452:                 
453:                 /*
454:                 ** $Log: vid_drv.c,v $
455:                 ** Revision 1.2  2001/04/27 14:37:11  neil
456:                 ** wheeee
457:                 **
458:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
459:                 ** initial
460:                 **
461:                 ** Revision 1.40  2000/11/25 20:26:42  matt
462:                 ** not much
463:                 **
464:                 ** Revision 1.39  2000/11/16 14:27:27  matt
465:                 ** even more crash-proofness
466:                 **
467:                 ** Revision 1.38  2000/11/16 14:11:18  neil
468:                 ** Better *not* to crash in case of catastrophic failure in the driver
469:                 **
470:                 ** Revision 1.37  2000/11/13 00:55:16  matt
471:                 ** no dirties seems to be faster (!?!?)
472:                 **
473:                 ** Revision 1.36  2000/11/06 05:16:18  matt
474:                 ** minor clipping bug
475:                 **
476:                 ** Revision 1.35  2000/11/06 02:16:26  matt
477:                 ** cleanups
478:                 **
479:                 ** Revision 1.34  2000/11/05 22:53:13  matt
480:                 ** only one video driver per system, please
481:                 **
482:                 ** Revision 1.33  2000/11/05 16:37:18  matt
483:                 ** rolled rgb.h into bitmap.h
484:                 **
485:                 ** Revision 1.32  2000/11/05 06:23:41  matt
486:                 ** thinlib spawns changes
487:                 **
488:                 ** Revision 1.31  2000/10/10 13:58:14  matt
489:                 ** stroustrup squeezing his way in the door
490:                 **
491:                 ** Revision 1.30  2000/10/10 13:03:53  matt
492:                 ** Mr. Clean makes a guest appearance
493:                 **
494:                 ** Revision 1.29  2000/10/08 17:58:23  matt
495:                 ** lock_read() should not allow us to clear the bitmap
496:                 **
497:                 ** Revision 1.28  2000/09/18 02:06:48  matt
498:                 ** -pedantic is your friend
499:                 **
500:                 ** Revision 1.27  2000/08/16 02:53:05  matt
501:                 ** changed init() interface a wee bit
502:                 **
503:                 ** Revision 1.26  2000/08/14 02:45:59  matt
504:                 ** fixed nasty bug in vid_blitscreen
505:                 **
506:                 ** Revision 1.24  2000/08/11 01:44:37  matt
507:                 ** clipping bugfix
508:                 **
509:                 ** Revision 1.23  2000/07/31 04:28:47  matt
510:                 ** one million cleanups
511:                 **
512:                 ** Revision 1.22  2000/07/28 07:25:49  neil
513:                 ** Video driver has an invalidate flag, telling vid_drv not to calculate dirties for the next frame
514:                 **
515:                 ** Revision 1.21  2000/07/28 03:51:45  matt
516:                 ** lock_read used instead of lock_write in some places
517:                 **
518:                 ** Revision 1.20  2000/07/28 01:24:05  matt
519:                 ** dirty rectangle support
520:                 **
521:                 ** Revision 1.19  2000/07/27 23:49:52  matt
522:                 ** no more getmode
523:                 **
524:                 ** Revision 1.18  2000/07/27 04:30:37  matt
525:                 ** change to get_mode api
526:                 **
527:                 ** Revision 1.17  2000/07/27 04:05:58  matt
528:                 ** changed place where name goes
529:                 **
530:                 ** Revision 1.16  2000/07/27 01:16:22  matt
531:                 ** api changes for new main and dirty rects
532:                 **
533:                 ** Revision 1.15  2000/07/26 21:36:13  neil
534:                 ** Big honkin' change -- see the mailing list
535:                 **
536:                 ** Revision 1.14  2000/07/24 04:33:57  matt
537:                 ** skeleton of dirty rectangle code in place
538:                 **
539:                 ** Revision 1.13  2000/07/23 14:35:39  matt
540:                 ** cleanups
541:                 **
542:                 ** Revision 1.12  2000/07/18 19:41:26  neil
543:                 ** use screen->pitch in blitscreen, not screen_width
544:                 **
545:                 ** Revision 1.11  2000/07/11 04:30:16  matt
546:                 ** overdraw unnecessary!
547:                 **
548:                 ** Revision 1.10  2000/07/10 19:07:57  matt
549:                 ** added custom clear() member call to video driver
550:                 **
551:                 ** Revision 1.9  2000/07/10 03:06:49  matt
552:                 ** my dependency file is broken... *snif*
553:                 **
554:                 ** Revision 1.8  2000/07/10 03:04:15  matt
555:                 ** removed scanlines, backbuffer from custom blit
556:                 **
557:                 ** Revision 1.7  2000/07/10 01:03:20  neil
558:                 ** New video scheme allows for custom blitters to be determined by the driver at runtime
559:                 **
560:                 ** Revision 1.6  2000/07/09 03:34:46  matt
561:                 ** temporary cleanup
562:                 **
563:                 ** Revision 1.5  2000/07/08 23:48:29  neil
564:                 ** Another assumption GGI kills: pitch == width for hardware bitmaps
565:                 **
566:                 ** Revision 1.4  2000/07/07 20:18:03  matt
567:                 ** added overdraw, fixed some bugs in blitters
568:                 **
569:                 ** Revision 1.3  2000/07/07 18:33:55  neil
570:                 ** no need to lock for reading just to get the dimensions
571:                 **
572:                 ** Revision 1.2  2000/07/07 18:11:37  neil
573:                 ** Generalizing the video driver
574:                 **
575:                 ** Revision 1.1  2000/07/06 16:48:47  matt
576:                 ** initial revision
577:                 **
578:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/sndhrdw/vrcvisnd.c  ------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** vrcvisnd.c
21:                  **
22:                  ** VRCVI sound hardware emulation
23:                  ** $Id: vrcvisnd.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <vrcvisnd.h>
28:                  #include <nes_apu.h>
29:                  
30:                  typedef struct vrcvirectangle_s
31:                  {
32:                     bool enabled;
33:                  
34:                     uint8 reg[3];
35:                     
36:                     float accum;
37:                     uint8 adder;
38:                  
39:                     int32 freq;
40:                     int32 volume;
41:                     uint8 duty_flip;
42:                  } vrcvirectangle_t;
43:                  
44:                  typedef struct vrcvisawtooth_s
45:                  {
46:                     bool enabled;
47:                     
48:                     uint8 reg[3];
49:                     
50:                     float accum;
51:                     uint8 adder;
52:                     uint8 output_acc;
53:                  
54:                     int32 freq;
55:                     uint8 volume;
56:                  } vrcvisawtooth_t;
57:                  
58:                  typedef struct vrcvisnd_s
59:                  {
60:                     vrcvirectangle_t rectangle[2];
61:                     vrcvisawtooth_t saw;
62:                     float incsize;
63:                  } vrcvisnd_t;
64:                  
65:                  
66:                  static vrcvisnd_t vrcvi;
67:                  
68:                  /* VRCVI rectangle wave generation */
69:                  static int32 vrcvi_rectangle(vrcvirectangle_t *chan)
70:                  {
9D02FCA8  27BDFFD8   ADDIU SP, SP, -40
9D02FCAC  AFBF0024   SW RA, 36(SP)
9D02FCB0  AFB30020   SW S3, 32(SP)
9D02FCB4  AFB2001C   SW S2, 28(SP)
9D02FCB8  AFB10018   SW S1, 24(SP)
9D02FCBC  AFB00014   SW S0, 20(SP)
9D02FCC0  00809821   ADDU S3, A0, ZERO
71:                     /* reg0: 0-3=volume, 4-6=duty cycle
72:                     ** reg1: 8 bits of freq
73:                     ** reg2: 0-3=high freq, 7=enable
74:                     */
75:                  
76:                     chan->accum -= vrcvi.incsize; /* # of clocks per wave cycle */
9D02FCC4  8C840008   LW A0, 8(A0)
9D02FCC8  3C02A001   LUI V0, -24575
9D02FCCC  0F40D22B   JAL __subsf3
9D02FCD0  8C45AD2C   LW A1, -21204(V0)
9D02FCD4  00408021   ADDU S0, V0, ZERO
9D02FCD8  AE620008   SW V0, 8(S3)
77:                     while (chan->accum < 0)
9D02FCDC  00402021   ADDU A0, V0, ZERO
9D02FCE0  0F40EB16   JAL __lesf2
9D02FCE4  00002821   ADDU A1, ZERO, ZERO
9D02FCE8  04430013   BGEZL V0, 0x9D02FD38
9D02FCEC  8E630000   LW V1, 0(S3)
9D02FD18  00402021   ADDU A0, V0, ZERO
9D02FD1C  0F40EB16   JAL __lesf2
9D02FD20  00002821   ADDU A1, ZERO, ZERO
9D02FD24  0440FFF7   BLTZ V0, 0x9D02FD04
9D02FD28  02002021   ADDU A0, S0, ZERO
9D02FD2C  AE700008   SW S0, 8(S3)
9D02FD30  A271000C   SB S1, 12(S3)
78:                     {
79:                        chan->accum += chan->freq;
9D02FCF0  0F40EEE7   JAL sitofp
9D02FCF4  8E640010   LW A0, 16(S3)
9D02FCF8  00409021   ADDU S2, V0, ZERO
9D02FCFC  9271000C   LBU S1, 12(S3)
9D02FD00  02002021   ADDU A0, S0, ZERO
9D02FD04  0F40D22D   JAL fpadd
9D02FD08  02402821   ADDU A1, S2, ZERO
9D02FD0C  00408021   ADDU S0, V0, ZERO
80:                        chan->adder = (chan->adder + 1) & 0x0F;
9D02FD10  26230001   ADDIU V1, S1, 1
9D02FD14  3071000F   ANDI S1, V1, 15
81:                     }
82:                  
83:                     /* return if not enabled */
84:                     if (false == chan->enabled)
9D02FD34  8E630000   LW V1, 0(S3)
9D02FD38  10600007   BEQ V1, ZERO, 0x9D02FD58
9D02FD3C  00001021   ADDU V0, ZERO, ZERO
85:                        return 0;
86:                  
87:                     if (chan->adder < chan->duty_flip)
9D02FD40  9263000C   LBU V1, 12(S3)
9D02FD44  92620018   LBU V0, 24(S3)
9D02FD48  0062102B   SLTU V0, V1, V0
9D02FD4C  10400002   BEQ V0, ZERO, 0x9D02FD58
9D02FD50  8E620014   LW V0, 20(S3)
9D02FD54  00021023   SUBU V0, ZERO, V0
88:                        return -(chan->volume);
89:                     else
90:                        return chan->volume;
91:                  }
9D02FD58  8FBF0024   LW RA, 36(SP)
9D02FD5C  8FB30020   LW S3, 32(SP)
9D02FD60  8FB2001C   LW S2, 28(SP)
9D02FD64  8FB10018   LW S1, 24(SP)
9D02FD68  8FB00014   LW S0, 20(SP)
9D02FD6C  03E00008   JR RA
9D02FD70  27BD0028   ADDIU SP, SP, 40
92:                  
93:                  /* VRCVI sawtooth wave generation */
94:                  static int32 vrcvi_sawtooth(vrcvisawtooth_t *chan)
95:                  {
96:                     /* reg0: 0-5=phase accumulator bits
97:                     ** reg1: 8 bits of freq
98:                     ** reg2: 0-3=high freq, 7=enable
99:                     */
100:                 
101:                    chan->accum -= vrcvi.incsize; /* # of clocks per wav cycle */
9D02FDB8  2610ACDC   ADDIU S0, S0, -21284
9D02FDBC  8E040040   LW A0, 64(S0)
9D02FDC0  0F40D22B   JAL __subsf3
9D02FDC4  8E050050   LW A1, 80(S0)
102:                    while (chan->accum < 0)
9D02FE20  02002021   ADDU A0, S0, ZERO
9D02FE24  0F40EB16   JAL __lesf2
9D02FE28  00002821   ADDU A1, ZERO, ZERO
9D02FE2C  0440FFED   BLTZ V0, 0x9D02FDE4
9D02FE30  3C02A001   LUI V0, -24575
9D02FE34  2442ACDC   ADDIU V0, V0, -21284
9D02FE38  AC500040   SW S0, 64(V0)
9D02FE3C  A0520045   SB S2, 69(V0)
9D02FE40  A0510044   SB S1, 68(V0)
103:                    {
104:                       chan->accum += chan->freq;
9D02FDC8  8E150048   LW S5, 72(S0)
9D02FDE4  0F40EEE7   JAL sitofp
9D02FDE8  02A02021   ADDU A0, S5, ZERO
9D02FDEC  00402021   ADDU A0, V0, ZERO
9D02FDF0  0F40D22D   JAL fpadd
9D02FDF4  02002821   ADDU A1, S0, ZERO
9D02FDF8  02549021   ADDU S2, S2, S4
9D02FDFC  26310001   ADDIU S1, S1, 1
9D02FE00  323100FF   ANDI S1, S1, 255
9D02FE0C  0B40BF88   J 0x9D02FE20
9D02FE10  00408021   ADDU S0, V0, ZERO
9D02FE14  00408021   ADDU S0, V0, ZERO
105:                       chan->output_acc += chan->volume;
9D02FDCC  9214004C   LBU S4, 76(S0)
9D02FDD0  92120045   LBU S2, 69(S0)
9D02FDD4  92110044   LBU S1, 68(S0)
9D02FDD8  00408021   ADDU S0, V0, ZERO
106:                       
107:                       chan->adder++;
108:                       if (7 == chan->adder)
9D02FDDC  0B40BF88   J 0x9D02FE20
9D02FDE0  24130007   ADDIU S3, ZERO, 7
9D02FE04  12330003   BEQ S1, S3, 0x9D02FE14
9D02FE08  325200FF   ANDI S2, S2, 255
109:                       {
110:                          chan->adder = 0;
9D02FE1C  00008821   ADDU S1, ZERO, ZERO
111:                          chan->output_acc = 0;
9D02FE18  00009021   ADDU S2, ZERO, ZERO
112:                       }
113:                    }
114:                 
115:                    /* return if not enabled */
116:                    if (false == chan->enabled)
9D02FE44  8C430038   LW V1, 56(V0)
9D02FE48  10600005   BEQ V1, ZERO, 0x9D02FE60
9D02FE4C  00001021   ADDU V0, ZERO, ZERO
117:                       return 0;
118:                 
119:                    return (chan->output_acc >> 3) << 9;
9D02FE50  3C02A001   LUI V0, -24575
9D02FE54  9042AD21   LBU V0, -21215(V0)
9D02FE58  000210C2   SRL V0, V0, 3
9D02FE5C  00021240   SLL V0, V0, 9
120:                 }
121:                 
122:                 /* mix vrcvi sound channels together */
123:                 static int32 vrcvi_process(void)
124:                 {
9D02FD74  27BDFFD0   ADDIU SP, SP, -48
9D02FD78  AFBF002C   SW RA, 44(SP)
9D02FD7C  AFB60028   SW S6, 40(SP)
9D02FD80  AFB50024   SW S5, 36(SP)
9D02FD84  AFB40020   SW S4, 32(SP)
9D02FD88  AFB3001C   SW S3, 28(SP)
9D02FD8C  AFB20018   SW S2, 24(SP)
9D02FD90  AFB10014   SW S1, 20(SP)
9D02FD94  AFB00010   SW S0, 16(SP)
125:                    int32 output;
126:                 
127:                    output = vrcvi_rectangle(&vrcvi.rectangle[0]);
9D02FD98  3C10A001   LUI S0, -24575
9D02FD9C  0F40BF2A   JAL .LFB0, vrcvi_rectangle, .Ltext0
9D02FDA0  2604ACDC   ADDIU A0, S0, -21284
9D02FDA4  0040B021   ADDU S6, V0, ZERO
128:                    output += vrcvi_rectangle(&vrcvi.rectangle[1]);
9D02FDA8  3C04A001   LUI A0, -24575
9D02FDAC  0F40BF2A   JAL .LFB0, vrcvi_rectangle, .Ltext0
9D02FDB0  2484ACF8   ADDIU A0, A0, -21256
9D02FDB4  0056B021   ADDU S6, V0, S6
129:                    output += vrcvi_sawtooth(&vrcvi.saw);
130:                 
131:                    return output;
132:                 }
9D02FE60  02C21021   ADDU V0, S6, V0
9D02FE64  8FBF002C   LW RA, 44(SP)
9D02FE68  8FB60028   LW S6, 40(SP)
9D02FE6C  8FB50024   LW S5, 36(SP)
9D02FE70  8FB40020   LW S4, 32(SP)
9D02FE74  8FB3001C   LW S3, 28(SP)
9D02FE78  8FB20018   LW S2, 24(SP)
9D02FE7C  8FB10014   LW S1, 20(SP)
9D02FE80  8FB00010   LW S0, 16(SP)
9D02FE84  03E00008   JR RA
9D02FE88  27BD0030   ADDIU SP, SP, 48
133:                 
134:                 /* write to registers */
135:                 static void vrcvi_write(uint32 address, uint8 value)
136:                 {
137:                    int chan = (address >> 12) - 9;
9D02FE8C  00041302   SRL V0, A0, 12
9D02FE90  2446FFF7   ADDIU A2, V0, -9
138:                 
139:                    switch (address & 0xB003)
9D02FE94  3084B003   ANDI A0, A0, -20477
9D02FE98  3402A001   ORI V0, ZERO, -24575
9D02FE9C  10820032   BEQ A0, V0, 0x9D02FF68
9D02FEA0  3403A002   ORI V1, ZERO, -24574
9D02FEA4  0083182B   SLTU V1, A0, V1
9D02FEA8  10600012   BEQ V1, ZERO, 0x9D02FEF4
9D02FEAC  3402B000   ORI V0, ZERO, -20480
9D02FEB0  34029001   ORI V0, ZERO, -28671
9D02FEB4  1082002C   BEQ A0, V0, 0x9D02FF68
9D02FEB8  34029002   ORI V0, ZERO, -28670
9D02FEBC  0082102B   SLTU V0, A0, V0
9D02FEC0  10400006   BEQ V0, ZERO, 0x9D02FEDC
9D02FEC4  34029002   ORI V0, ZERO, -28670
9D02FEC8  34029000   ORI V0, ZERO, -28672
9D02FECC  10820019   BEQ A0, V0, 0x9D02FF34
9D02FED0  00061880   SLL V1, A2, 2
9D02FED4  03E00008   JR RA
9D02FED8  00000000   NOP
9D02FEDC  10820030   BEQ A0, V0, 0x9D02FFA0
9D02FEE0  3402A000   ORI V0, ZERO, -24576
9D02FEE4  10820013   BEQ A0, V0, 0x9D02FF34
9D02FEE8  00061880   SLL V1, A2, 2
9D02FEEC  03E00008   JR RA
9D02FEF0  00000000   NOP
9D02FEF4  1082003A   BEQ A0, V0, 0x9D02FFE0
9D02FEF8  3402B001   ORI V0, ZERO, -20479
9D02FEFC  0082102B   SLTU V0, A0, V0
9D02FF00  10400006   BEQ V0, ZERO, 0x9D02FF1C
9D02FF04  3402B001   ORI V0, ZERO, -20479
9D02FF08  3402A002   ORI V0, ZERO, -24574
9D02FF0C  10820025   BEQ A0, V0, 0x9D02FFA4
9D02FF10  00061880   SLL V1, A2, 2
9D02FF14  03E00008   JR RA
9D02FF18  00000000   NOP
9D02FF1C  10820036   BEQ A0, V0, 0x9D02FFF8
9D02FF20  3402B002   ORI V0, ZERO, -20478
9D02FF24  1082003F   BEQ A0, V0, 0x9D030024
9D02FF28  3C02A001   LUI V0, -24575
9D02FF2C  03E00008   JR RA
9D02FF30  00000000   NOP
140:                    {
141:                    case 0x9000:
142:                    case 0xA000:
143:                       vrcvi.rectangle[chan].reg[0] = value;
9D02FF34  00063140   SLL A2, A2, 5
9D02FF38  00C33023   SUBU A2, A2, V1
9D02FF3C  3C03A001   LUI V1, -24575
9D02FF40  2463ACDC   ADDIU V1, V1, -21284
9D02FF44  00C33021   ADDU A2, A2, V1
9D02FF48  A0C50004   SB A1, 4(A2)
144:                       vrcvi.rectangle[chan].volume = (value & 0x0F) << 8;
9D02FF4C  30A2000F   ANDI V0, A1, 15
9D02FF50  00021200   SLL V0, V0, 8
9D02FF54  ACC20014   SW V0, 20(A2)
145:                       vrcvi.rectangle[chan].duty_flip = (value >> 4) + 1;
9D02FF58  00052902   SRL A1, A1, 4
9D02FF5C  24A50001   ADDIU A1, A1, 1
146:                       break;
9D02FF60  03E00008   JR RA
9D02FF64  A0C50018   SB A1, 24(A2)
147:                 
148:                    case 0x9001:
149:                    case 0xA001:
150:                       vrcvi.rectangle[chan].reg[1] = value;
9D02FF68  00061880   SLL V1, A2, 2
9D02FF6C  00063140   SLL A2, A2, 5
9D02FF70  00C33023   SUBU A2, A2, V1
9D02FF74  3C03A001   LUI V1, -24575
9D02FF78  2463ACDC   ADDIU V1, V1, -21284
9D02FF7C  00C33021   ADDU A2, A2, V1
9D02FF80  A0C50005   SB A1, 5(A2)
151:                       vrcvi.rectangle[chan].freq = ((vrcvi.rectangle[chan].reg[2] & 0x0F) << 8) + value + 1;
9D02FF84  90C20006   LBU V0, 6(A2)
9D02FF88  3042000F   ANDI V0, V0, 15
9D02FF8C  00021200   SLL V0, V0, 8
9D02FF90  00452821   ADDU A1, V0, A1
9D02FF94  24A50001   ADDIU A1, A1, 1
152:                       break;
9D02FF98  03E00008   JR RA
9D02FF9C  ACC50010   SW A1, 16(A2)
153:                 
154:                    case 0x9002:
155:                    case 0xA002:
156:                       vrcvi.rectangle[chan].reg[2] = value;
9D02FFA0  00061880   SLL V1, A2, 2
9D02FFA4  00063140   SLL A2, A2, 5
9D02FFA8  00C33023   SUBU A2, A2, V1
9D02FFAC  3C03A001   LUI V1, -24575
9D02FFB0  2463ACDC   ADDIU V1, V1, -21284
9D02FFB4  00C33021   ADDU A2, A2, V1
9D02FFB8  A0C50006   SB A1, 6(A2)
157:                       vrcvi.rectangle[chan].freq = ((value & 0x0F) << 8) + vrcvi.rectangle[chan].reg[1] + 1;
9D02FFBC  30A2000F   ANDI V0, A1, 15
9D02FFC0  00021200   SLL V0, V0, 8
9D02FFC4  90C30005   LBU V1, 5(A2)
9D02FFC8  00431021   ADDU V0, V0, V1
9D02FFCC  24420001   ADDIU V0, V0, 1
9D02FFD0  ACC20010   SW V0, 16(A2)
158:                       vrcvi.rectangle[chan].enabled = (value & 0x80) ? true : false;
9D02FFD4  000529C2   SRL A1, A1, 7
159:                       break;
9D02FFD8  03E00008   JR RA
9D02FFDC  ACC50000   SW A1, 0(A2)
160:                 
161:                    case 0xB000:
162:                       vrcvi.saw.reg[0] = value;
9D02FFE0  3C02A001   LUI V0, -24575
9D02FFE4  2442ACDC   ADDIU V0, V0, -21284
9D02FFE8  A045003C   SB A1, 60(V0)
163:                       vrcvi.saw.volume = value & 0x3F;
9D02FFEC  30A5003F   ANDI A1, A1, 63
164:                       break;
9D02FFF0  03E00008   JR RA
9D02FFF4  A045004C   SB A1, 76(V0)
165:                 
166:                    case 0xB001:
167:                       vrcvi.saw.reg[1] = value;
9D02FFF8  3C02A001   LUI V0, -24575
9D02FFFC  2442ACDC   ADDIU V0, V0, -21284
9D030000  A045003D   SB A1, 61(V0)
168:                       vrcvi.saw.freq = (((vrcvi.saw.reg[2] & 0x0F) << 8) + value + 1) << 1;
9D030004  9043003E   LBU V1, 62(V0)
9D030008  3063000F   ANDI V1, V1, 15
9D03000C  00031A00   SLL V1, V1, 8
9D030010  00652821   ADDU A1, V1, A1
9D030014  24A50001   ADDIU A1, A1, 1
9D030018  00052840   SLL A1, A1, 1
169:                       break;
9D03001C  03E00008   JR RA
9D030020  AC450048   SW A1, 72(V0)
170:                 
171:                    case 0xB002:
172:                       vrcvi.saw.reg[2] = value;
9D030024  2442ACDC   ADDIU V0, V0, -21284
9D030028  A045003E   SB A1, 62(V0)
173:                       vrcvi.saw.freq = (((value & 0x0F) << 8) + vrcvi.saw.reg[1] + 1) << 1;
9D03002C  30A3000F   ANDI V1, A1, 15
9D030030  00031A00   SLL V1, V1, 8
9D030034  9044003D   LBU A0, 61(V0)
9D030038  00641821   ADDU V1, V1, A0
9D03003C  24630001   ADDIU V1, V1, 1
9D030040  00031840   SLL V1, V1, 1
9D030044  AC430048   SW V1, 72(V0)
174:                       vrcvi.saw.enabled = (value & 0x80) ? true : false;
9D030048  000529C2   SRL A1, A1, 7
9D03004C  03E00008   JR RA
9D030050  AC450038   SW A1, 56(V0)
175:                       break;
176:                 
177:                    default:
178:                       break;
179:                    }
180:                 }
181:                 
182:                 /* reset state of vrcvi sound channels */
183:                 static void vrcvi_reset(void)
184:                 {
9D030054  27BDFE70   ADDIU SP, SP, -400
9D030058  AFBF018C   SW RA, 396(SP)
9D03005C  AFB10188   SW S1, 392(SP)
9D030060  AFB00184   SW S0, 388(SP)
185:                    int i;
186:                    apu_t apu;
187:                 
188:                    /* get the phase period from the apu */
189:                    apu_getcontext(&apu);
9D030064  0F407892   JAL apu_getcontext
9D030068  27A40010   ADDIU A0, SP, 16
190:                    vrcvi.incsize = apu.cycle_rate;
9D03006C  8FA3015C   LW V1, 348(SP)
9D030070  3C02A001   LUI V0, -24575
9D030074  AC43AD2C   SW V1, -21204(V0)
9D030078  34109000   ORI S0, ZERO, -28672
191:                 
192:                    /* preload regs */
193:                    for (i = 0; i < 3; i++)
9D03007C  34119003   ORI S1, ZERO, -28669
9D0300A8  1611FFF6   BNE S0, S1, 0x9D030084
9D0300AC  02002021   ADDU A0, S0, ZERO
194:                    {
195:                       vrcvi_write(0x9000 + i, 0);
9D030080  02002021   ADDU A0, S0, ZERO
9D030084  0F40BFA3   JAL .LFB3, vrcvi_write, .LFE2
9D030088  00002821   ADDU A1, ZERO, ZERO
196:                       vrcvi_write(0xA000 + i, 0);
9D03008C  26041000   ADDIU A0, S0, 4096
9D030090  0F40BFA3   JAL .LFB3, vrcvi_write, .LFE2
9D030094  00002821   ADDU A1, ZERO, ZERO
197:                       vrcvi_write(0xB000 + i, 0);
9D030098  26042000   ADDIU A0, S0, 8192
9D03009C  0F40BFA3   JAL .LFB3, vrcvi_write, .LFE2
9D0300A0  00002821   ADDU A1, ZERO, ZERO
9D0300A4  26100001   ADDIU S0, S0, 1
198:                    }
199:                 }
9D0300B0  8FBF018C   LW RA, 396(SP)
9D0300B4  8FB10188   LW S1, 392(SP)
9D0300B8  8FB00184   LW S0, 388(SP)
9D0300BC  03E00008   JR RA
9D0300C0  27BD0190   ADDIU SP, SP, 400
200:                 
201:                 static apu_memwrite vrcvi_memwrite[] =
202:                 {
203:                    { 0x9000, 0x9002, vrcvi_write }, /* vrc6 */
204:                    { 0xA000, 0xA002, vrcvi_write },
205:                    { 0xB000, 0xB002, vrcvi_write },
206:                    {     -1,     -1, NULL }
207:                 };
208:                 
209:                 apuext_t vrcvi_ext =
210:                 {
211:                    NULL, /* no init */
212:                    NULL, /* no shutdown */
213:                    vrcvi_reset,
214:                    vrcvi_process,
215:                    NULL, /* no reads */
216:                    vrcvi_memwrite
217:                 };
218:                 
219:                 /*
220:                 ** $Log: vrcvisnd.c,v $
221:                 ** Revision 1.2  2001/04/27 14:37:11  neil
222:                 ** wheeee
223:                 **
224:                 ** Revision 1.1  2001/04/27 12:54:40  neil
225:                 ** blah
226:                 **
227:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
228:                 ** initial
229:                 **
230:                 ** Revision 1.2  2000/11/05 22:21:00  matt
231:                 ** help me!
232:                 **
233:                 ** Revision 1.1  2000/10/24 12:20:00  matt
234:                 ** changed directory structure
235:                 **
236:                 ** Revision 1.17  2000/10/10 13:58:18  matt
237:                 ** stroustrup squeezing his way in the door
238:                 **
239:                 ** Revision 1.16  2000/10/03 11:56:20  matt
240:                 ** better support for optional sound ext routines
241:                 **
242:                 ** Revision 1.15  2000/09/27 12:26:03  matt
243:                 ** changed sound accumulators back to floats
244:                 **
245:                 ** Revision 1.14  2000/09/15 13:38:40  matt
246:                 ** changes for optimized apu core
247:                 **
248:                 ** Revision 1.13  2000/09/15 04:58:07  matt
249:                 ** simplifying and optimizing APU core
250:                 **
251:                 ** Revision 1.12  2000/07/30 04:32:59  matt
252:                 ** no more apu_getcyclerate hack
253:                 **
254:                 ** Revision 1.11  2000/07/17 01:52:31  matt
255:                 ** made sure last line of all source files is a newline
256:                 **
257:                 ** Revision 1.10  2000/07/06 11:42:41  matt
258:                 ** forgot to remove FDS register range
259:                 **
260:                 ** Revision 1.9  2000/07/04 04:51:41  matt
261:                 ** cleanups
262:                 **
263:                 ** Revision 1.8  2000/07/03 02:18:53  matt
264:                 ** much better external module exporting
265:                 **
266:                 ** Revision 1.7  2000/06/20 04:06:16  matt
267:                 ** migrated external sound definition to apu module
268:                 **
269:                 ** Revision 1.6  2000/06/20 00:08:58  matt
270:                 ** changed to driver based API
271:                 **
272:                 ** Revision 1.5  2000/06/09 16:49:02  matt
273:                 ** removed all floating point from sound generation
274:                 **
275:                 ** Revision 1.4  2000/06/09 15:12:28  matt
276:                 ** initial revision
277:                 **
278:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/sndhrdw/nes_apu.c  -------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** nes_apu.c
21:                  **
22:                  ** NES APU emulation
23:                  ** $Id: nes_apu.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <string.h>
27:                  #include <noftypes.h>
28:                  #include <log.h>
29:                  #include <nes_apu.h>
30:                  #include "nes6502.h"
31:                   
32:                  
33:                  #define  APU_OVERSAMPLE
34:                  #define  APU_VOLUME_DECAY(x)  ((x) -= ((x) >> 7))
35:                  
36:                  /* the following seem to be the correct (empirically determined)
37:                  ** relative volumes between the sound channels
38:                  */
39:                  #define  APU_RECTANGLE_OUTPUT(channel) (apu.rectangle[channel].output_vol)
40:                  #define  APU_TRIANGLE_OUTPUT           (apu.triangle.output_vol + (apu.triangle.output_vol >> 2))
41:                  #define  APU_NOISE_OUTPUT              ((apu.noise.output_vol + apu.noise.output_vol + apu.noise.output_vol) >> 2)
42:                  #define  APU_DMC_OUTPUT                ((apu.dmc.output_vol + apu.dmc.output_vol + apu.dmc.output_vol) >> 2)
43:                  
44:                  /* active APU */
45:                  static apu_t apu;
46:                  
47:                  /* look up table madness */
48:                  static int32 decay_lut[16];
49:                  static int vbl_lut[32];
50:                  static int trilength_lut[128];
51:                  
52:                  /* noise lookups for both modes */
53:                  #ifndef REALTIME_NOISE
54:                  static int8 noise_long_lut[APU_NOISE_32K];
55:                  static int8 noise_short_lut[APU_NOISE_93];
56:                  #endif /* !REALTIME_NOISE */
57:                  
58:                  
59:                  /* vblank length table used for rectangles, triangle, noise */
60:                  static const uint8 vbl_length[32] =
61:                  {
62:                      5, 127,
63:                     10,   1,
64:                     19,   2,
65:                     40,   3,
66:                     80,   4,
67:                     30,   5,
68:                      7,   6,
69:                     13,   7,
70:                      6,   8,
71:                     12,   9,
72:                     24,  10,
73:                     48,  11,
74:                     96,  12,
75:                     36,  13,
76:                      8,  14,
77:                     16,  15
78:                  };
79:                  
80:                  /* frequency limit of rectangle channels */
81:                  static const int freq_limit[8] =
82:                  {
83:                     0x3FF, 0x555, 0x666, 0x71C, 0x787, 0x7C1, 0x7E0, 0x7F0
84:                  };
85:                  
86:                  /* noise frequency lookup table */
87:                  static const int noise_freq[16] =
88:                  {
89:                       4,    8,   16,   32,   64,   96,  128,  160,
90:                     202,  254,  380,  508,  762, 1016, 2034, 4068
91:                  };
92:                  
93:                  /* DMC transfer freqs */
94:                  const int dmc_clocks[16] =
95:                  {
96:                     428, 380, 340, 320, 286, 254, 226, 214,
97:                     190, 160, 142, 128, 106,  85,  72,  54
98:                  };
99:                  
100:                 /* ratios of pos/neg pulse for rectangle waves */
101:                 static const int duty_flip[4] = { 2, 4, 8, 12 };
102:                 
103:                 
104:                 void apu_setcontext(apu_t *src_apu)
105:                 {
106:                    apu = *src_apu;
9D01E1F0  00801021   ADDU V0, A0, ZERO
9D01E1F4  3C03A001   LUI V1, -24575
9D01E1F8  246392EC   ADDIU V1, V1, -27924
9D01E1FC  24840160   ADDIU A0, A0, 352
9D01E200  8C480000   LW T0, 0(V0)
9D01E204  8C470004   LW A3, 4(V0)
9D01E208  8C460008   LW A2, 8(V0)
9D01E20C  8C45000C   LW A1, 12(V0)
9D01E210  AC680000   SW T0, 0(V1)
9D01E214  AC670004   SW A3, 4(V1)
9D01E218  AC660008   SW A2, 8(V1)
9D01E21C  AC65000C   SW A1, 12(V1)
9D01E220  24420010   ADDIU V0, V0, 16
9D01E224  1444FFF6   BNE V0, A0, 0x9D01E200
9D01E228  24630010   ADDIU V1, V1, 16
9D01E22C  8C450000   LW A1, 0(V0)
9D01E230  8C440004   LW A0, 4(V0)
9D01E234  8C420008   LW V0, 8(V0)
9D01E238  AC650000   SW A1, 0(V1)
9D01E23C  AC640004   SW A0, 4(V1)
9D01E240  03E00008   JR RA
9D01E244  AC620008   SW V0, 8(V1)
107:                 }
108:                 
109:                 void apu_getcontext(apu_t *dest_apu)
110:                 {
111:                    *dest_apu = apu;
9D01E248  3C02A001   LUI V0, -24575
9D01E24C  244292EC   ADDIU V0, V0, -27924
9D01E250  24430160   ADDIU V1, V0, 352
9D01E254  8C480000   LW T0, 0(V0)
9D01E258  8C470004   LW A3, 4(V0)
9D01E25C  8C460008   LW A2, 8(V0)
9D01E260  8C45000C   LW A1, 12(V0)
9D01E264  AC880000   SW T0, 0(A0)
9D01E268  AC870004   SW A3, 4(A0)
9D01E26C  AC860008   SW A2, 8(A0)
9D01E270  AC85000C   SW A1, 12(A0)
9D01E274  24420010   ADDIU V0, V0, 16
9D01E278  1443FFF6   BNE V0, V1, 0x9D01E254
9D01E27C  24840010   ADDIU A0, A0, 16
9D01E280  8C450000   LW A1, 0(V0)
9D01E284  8C430004   LW V1, 4(V0)
9D01E288  8C420008   LW V0, 8(V0)
9D01E28C  AC850000   SW A1, 0(A0)
9D01E290  AC830004   SW V1, 4(A0)
9D01E294  03E00008   JR RA
9D01E298  AC820008   SW V0, 8(A0)
112:                 }
113:                 
114:                 void apu_setchan(int chan, bool enabled)
115:                 {
116:                    if (enabled)
9D01E29C  10A00008   BEQ A1, ZERO, 0x9D01E2C0
9D01E2A0  3C02A001   LUI V0, -24575
117:                       apu.mix_enable |= (1 << chan);
9D01E2A4  244292EC   ADDIU V0, V0, -27924
9D01E2A8  24030001   ADDIU V1, ZERO, 1
9D01E2AC  00832004   SLLV A0, V1, A0
9D01E2B0  90430140   LBU V1, 320(V0)
9D01E2B4  00832025   OR A0, A0, V1
9D01E2B8  03E00008   JR RA
9D01E2BC  A0440140   SB A0, 320(V0)
118:                    else
119:                       apu.mix_enable &= ~(1 << chan);
9D01E2C0  244292EC   ADDIU V0, V0, -27924
9D01E2C4  24030001   ADDIU V1, ZERO, 1
9D01E2C8  00832004   SLLV A0, V1, A0
9D01E2CC  00042027   NOR A0, ZERO, A0
9D01E2D0  90430140   LBU V1, 320(V0)
9D01E2D4  00832024   AND A0, A0, V1
9D01E2D8  03E00008   JR RA
9D01E2DC  A0440140   SB A0, 320(V0)
120:                 }
121:                 
122:                 /* emulation of the 15-bit shift register the
123:                 ** NES uses to generate pseudo-random series
124:                 ** for the white noise channel
125:                 */
126:                 #ifdef REALTIME_NOISE
127:                 INLINE int8 shift_register15(uint8 xor_tap)
128:                 {
129:                    static int sreg = 0x4000;
130:                    int bit0, tap, bit14;
131:                 
132:                    bit0 = sreg & 1;
9D01DE7C  32E20001   ANDI V0, S7, 1
133:                    tap = (sreg & xor_tap) ? 1 : 0;
9D01DE58  92F700FC   LBU S7, 252(S7)
9D01DE5C  AFB70020   SW S7, 32(SP)
9D01DE60  8F978018   LW S7, -32744(GP)
9D01DE80  8FA40020   LW A0, 32(SP)
9D01DE84  02E41824   AND V1, S7, A0
9D01DE88  0003182B   SLTU V1, ZERO, V1
134:                    bit14 = (bit0 ^ tap);
9D01DE8C  00621826   XOR V1, V1, V0
135:                    sreg >>= 1;
9D01DE94  0017B843   SRA S7, S7, 1
136:                    sreg |= (bit14 << 14);
9D01DE90  00031B80   SLL V1, V1, 14
9D01DE98  0077B825   OR S7, V1, S7
137:                    return (bit0 ^ 1);
138:                 }
139:                 #else /* !REALTIME_NOISE */
140:                 static void shift_register15(int8 *buf, int count)
141:                 {
142:                    static int sreg = 0x4000;
143:                    int bit0, bit1, bit6, bit14;
144:                 
145:                    if (count == APU_NOISE_93)
146:                    {
147:                       while (count--)
148:                       {
149:                          bit0 = sreg & 1;
150:                          bit6 = (sreg & 0x40) >> 6;
151:                          bit14 = (bit0 ^ bit6);
152:                          sreg >>= 1;
153:                          sreg |= (bit14 << 14);
154:                          *buf++ = bit0 ^ 1;
155:                       }
156:                    }
157:                    else /* 32K noise */
158:                    {
159:                       while (count--)
160:                       {
161:                          bit0 = sreg & 1;
162:                          bit1 = (sreg & 2) >> 1;
163:                          bit14 = (bit0 ^ bit1);
164:                          sreg >>= 1;
165:                          sreg |= (bit14 << 14);
166:                          *buf++ = bit0 ^ 1;
167:                       }
168:                    }
169:                 }
170:                 #endif /* !REALTIME_NOISE */
171:                 
172:                 /* RECTANGLE WAVE
173:                 ** ==============
174:                 ** reg0: 0-3=volume, 4=envelope, 5=hold, 6-7=duty cycle
175:                 ** reg1: 0-2=sweep shifts, 3=sweep inc/dec, 4-6=sweep length, 7=sweep on
176:                 ** reg2: 8 bits of freq
177:                 ** reg3: 0-2=high freq, 7-4=vbl length counter
178:                 */
179:                 #ifdef APU_OVERSAMPLE
180:                 
181:                 #define  APU_MAKE_RECTANGLE(ch) \
182:                 static int32 apu_rectangle_##ch(void) \
183:                 { \
184:                    int32 output, total; \
185:                    int num_times; \
186:                 \
187:                    APU_VOLUME_DECAY(apu.rectangle[ch].output_vol); \
188:                 \
189:                    if (false == apu.rectangle[ch].enabled || 0 == apu.rectangle[ch].vbl_length) \
190:                       return APU_RECTANGLE_OUTPUT(ch); \
191:                 \
192:                    /* vbl length counter */ \
193:                    if (false == apu.rectangle[ch].holdnote) \
194:                       apu.rectangle[ch].vbl_length--; \
195:                 \
196:                    /* envelope decay at a rate of (env_delay + 1) / 240 secs */ \
197:                    apu.rectangle[ch].env_phase -= 4; /* 240/60 */ \
198:                    while (apu.rectangle[ch].env_phase < 0) \
199:                    { \
200:                       apu.rectangle[ch].env_phase += apu.rectangle[ch].env_delay; \
201:                 \
202:                       if (apu.rectangle[ch].holdnote) \
203:                          apu.rectangle[ch].env_vol = (apu.rectangle[ch].env_vol + 1) & 0x0F; \
204:                       else if (apu.rectangle[ch].env_vol < 0x0F) \
205:                          apu.rectangle[ch].env_vol++; \
206:                    } \
207:                 \
208:                    /* TODO: find true relation of freq_limit to register values */ \
209:                    if (apu.rectangle[ch].freq < 8 \
210:                        || (false == apu.rectangle[ch].sweep_inc \
211:                            && apu.rectangle[ch].freq > apu.rectangle[ch].freq_limit)) \
212:                       return APU_RECTANGLE_OUTPUT(ch); \
213:                 \
214:                    /* frequency sweeping at a rate of (sweep_delay + 1) / 120 secs */ \
215:                    if (apu.rectangle[ch].sweep_on && apu.rectangle[ch].sweep_shifts) \
216:                    { \
217:                       apu.rectangle[ch].sweep_phase -= 2; /* 120/60 */ \
218:                       while (apu.rectangle[ch].sweep_phase < 0) \
219:                       { \
220:                          apu.rectangle[ch].sweep_phase += apu.rectangle[ch].sweep_delay; \
221:                 \
222:                          if (apu.rectangle[ch].sweep_inc) /* ramp up */ \
223:                          { \
224:                             if (0 == ch) \
225:                                apu.rectangle[ch].freq += ~(apu.rectangle[ch].freq >> apu.rectangle[ch].sweep_shifts); \
226:                             else \
227:                                apu.rectangle[ch].freq -= (apu.rectangle[ch].freq >> apu.rectangle[ch].sweep_shifts); \
228:                          } \
229:                          else /* ramp down */ \
230:                          { \
231:                             apu.rectangle[ch].freq += (apu.rectangle[ch].freq >> apu.rectangle[ch].sweep_shifts); \
232:                          } \
233:                       } \
234:                    } \
235:                 \
236:                    apu.rectangle[ch].accum -= apu.cycle_rate; \
237:                    if (apu.rectangle[ch].accum >= 0) \
238:                       return APU_RECTANGLE_OUTPUT(ch); \
239:                 \
240:                    if (apu.rectangle[ch].fixed_envelope) \
241:                       output = apu.rectangle[ch].volume << 8; /* fixed volume */ \
242:                    else \
243:                       output = (apu.rectangle[ch].env_vol ^ 0x0F) << 8; \
244:                 \
245:                    num_times = total = 0; \
246:                 \
247:                    while (apu.rectangle[ch].accum < 0) \
248:                    { \
249:                       apu.rectangle[ch].accum += apu.rectangle[ch].freq + 1; \
250:                       apu.rectangle[ch].adder = (apu.rectangle[ch].adder + 1) & 0x0F; \
251:                 \
252:                       if (apu.rectangle[ch].adder < apu.rectangle[ch].duty_flip) \
253:                          total += output; \
254:                       else \
255:                          total -= output; \
256:                 \
257:                       num_times++; \
258:                    } \
259:                 \
260:                    apu.rectangle[ch].output_vol = total / num_times; \
261:                    return APU_RECTANGLE_OUTPUT(ch); \
262:                 } 
263:                 
264:                 #else /* !APU_OVERSAMPLE */
265:                 #define  APU_MAKE_RECTANGLE(ch) \
266:                 static int32 apu_rectangle_##ch(void) \
267:                 { \
268:                    int32 output; \
269:                 \
270:                    APU_VOLUME_DECAY(apu.rectangle[ch].output_vol); \
271:                 \
272:                    if (false == apu.rectangle[ch].enabled || 0 == apu.rectangle[ch].vbl_length) \
273:                       return APU_RECTANGLE_OUTPUT(ch); \
274:                 \
275:                    /* vbl length counter */ \
276:                    if (false == apu.rectangle[ch].holdnote) \
277:                       apu.rectangle[ch].vbl_length--; \
278:                 \
279:                    /* envelope decay at a rate of (env_delay + 1) / 240 secs */ \
280:                    apu.rectangle[ch].env_phase -= 4; /* 240/60 */ \
281:                    while (apu.rectangle[ch].env_phase < 0) \
282:                    { \
283:                       apu.rectangle[ch].env_phase += apu.rectangle[ch].env_delay; \
284:                 \
285:                       if (apu.rectangle[ch].holdnote) \
286:                          apu.rectangle[ch].env_vol = (apu.rectangle[ch].env_vol + 1) & 0x0F; \
287:                       else if (apu.rectangle[ch].env_vol < 0x0F) \
288:                          apu.rectangle[ch].env_vol++; \
289:                    } \
290:                 \
291:                    /* TODO: find true relation of freq_limit to register values */ \
292:                    if (apu.rectangle[ch].freq < 8 || (false == apu.rectangle[ch].sweep_inc && apu.rectangle[ch].freq > apu.rectangle[ch].freq_limit)) \
293:                       return APU_RECTANGLE_OUTPUT(ch); \
294:                 \
295:                    /* frequency sweeping at a rate of (sweep_delay + 1) / 120 secs */ \
296:                    if (apu.rectangle[ch].sweep_on && apu.rectangle[ch].sweep_shifts) \
297:                    { \
298:                       apu.rectangle[ch].sweep_phase -= 2; /* 120/60 */ \
299:                       while (apu.rectangle[ch].sweep_phase < 0) \
300:                       { \
301:                          apu.rectangle[ch].sweep_phase += apu.rectangle[ch].sweep_delay; \
302:                 \
303:                          if (apu.rectangle[ch].sweep_inc) /* ramp up */ \
304:                          { \
305:                             if (0 == ch) \
306:                                apu.rectangle[ch].freq += ~(apu.rectangle[ch].freq >> apu.rectangle[ch].sweep_shifts); \
307:                             else \
308:                                apu.rectangle[ch].freq -= (apu.rectangle[ch].freq >> apu.rectangle[ch].sweep_shifts); \
309:                          } \
310:                          else /* ramp down */ \
311:                          { \
312:                             apu.rectangle[ch].freq += (apu.rectangle[ch].freq >> apu.rectangle[ch].sweep_shifts); \
313:                          } \
314:                       } \
315:                    } \
316:                 \
317:                    apu.rectangle[ch].accum -= apu.cycle_rate; \
318:                    if (apu.rectangle[ch].accum >= 0) \
319:                       return APU_RECTANGLE_OUTPUT(ch); \
320:                 \
321:                    while (apu.rectangle[ch].accum < 0) \
322:                    { \
323:                       apu.rectangle[ch].accum += (apu.rectangle[ch].freq + 1); \
324:                       apu.rectangle[ch].adder = (apu.rectangle[ch].adder + 1) & 0x0F; \
325:                    } \
326:                 \
327:                    if (apu.rectangle[ch].fixed_envelope) \
328:                       output = apu.rectangle[ch].volume << 8; /* fixed volume */ \
329:                    else \
330:                       output = (apu.rectangle[ch].env_vol ^ 0x0F) << 8; \
331:                 \
332:                    if (0 == apu.rectangle[ch].adder) \
333:                       apu.rectangle[ch].output_vol = output; \
334:                    else if (apu.rectangle[ch].adder == apu.rectangle[ch].duty_flip) \
335:                       apu.rectangle[ch].output_vol = -output; \
336:                 \
337:                    return APU_RECTANGLE_OUTPUT(ch); \
338:                 }
339:                 
340:                 #endif /* !APU_OVERSAMPLE */
341:                 
342:                 /* generate the functions */
343:                 APU_MAKE_RECTANGLE(0)
9D01D724  260292EC   ADDIU V0, S0, -27924
9D01D728  8C430010   LW V1, 16(V0)
9D01D72C  000389C3   SRA S1, V1, 7
9D01D730  00718823   SUBU S1, V1, S1
9D01D734  AC510010   SW S1, 16(V0)
9D01D738  8C420004   LW V0, 4(V0)
9D01D73C  10400086   BEQ V0, ZERO, 0x9D01D958
9D01D740  260292EC   ADDIU V0, S0, -27924
9D01D744  8C420044   LW V0, 68(V0)
9D01D748  10400083   BEQ V0, ZERO, 0x9D01D958
9D01D74C  260392EC   ADDIU V1, S0, -27924
9D01D750  8C650018   LW A1, 24(V1)
9D01D754  54A00004   BNEL A1, ZERO, 0x9D01D768
9D01D758  260292EC   ADDIU V0, S0, -27924
9D01D75C  2442FFFF   ADDIU V0, V0, -1
9D01D760  AC620044   SW V0, 68(V1)
9D01D764  260292EC   ADDIU V0, S0, -27924
9D01D768  90430040   LBU V1, 64(V0)
9D01D76C  8C46003C   LW A2, 60(V0)
9D01D770  8C420038   LW V0, 56(V0)
9D01D774  0B4075E9   J 0x9D01D7A4
9D01D778  2442FFFC   ADDIU V0, V0, -4
9D01D77C  50A00004   BEQL A1, ZERO, 0x9D01D790
9D01D780  2C64000F   SLTIU A0, V1, 15
9D01D784  24630001   ADDIU V1, V1, 1
9D01D788  0B4075E8   J 0x9D01D7A0
9D01D78C  3063000F   ANDI V1, V1, 15
9D01D790  50800004   BEQL A0, ZERO, 0x9D01D7A4
9D01D794  00461021   ADDU V0, V0, A2
9D01D798  24630001   ADDIU V1, V1, 1
9D01D79C  306300FF   ANDI V1, V1, 255
9D01D7A0  00461021   ADDU V0, V0, A2
9D01D7A4  0440FFF5   BLTZ V0, 0x9D01D77C
9D01D7A8  00402021   ADDU A0, V0, ZERO
9D01D7AC  260292EC   ADDIU V0, S0, -27924
9D01D7B0  AC440038   SW A0, 56(V0)
9D01D7B4  A0430040   SB V1, 64(V0)
9D01D7B8  8C42000C   LW V0, 12(V0)
9D01D7BC  28430008   SLTI V1, V0, 8
9D01D7C0  14600065   BNE V1, ZERO, 0x9D01D958
9D01D7C4  260392EC   ADDIU V1, S0, -27924
9D01D7C8  8C640030   LW A0, 48(V1)
9D01D7CC  54800005   BNEL A0, ZERO, 0x9D01D7E4
9D01D7D0  260292EC   ADDIU V0, S0, -27924
9D01D7D4  8C630034   LW V1, 52(V1)
9D01D7D8  0062102A   SLT V0, V1, V0
9D01D7DC  1440005E   BNE V0, ZERO, 0x9D01D958
9D01D7E0  260292EC   ADDIU V0, S0, -27924
9D01D7E4  8C420028   LW V0, 40(V0)
9D01D7E8  10400017   BEQ V0, ZERO, 0x9D01D848
9D01D7EC  261792EC   ADDIU S7, S0, -27924
9D01D7F0  260292EC   ADDIU V0, S0, -27924
9D01D7F4  9045002C   LBU A1, 44(V0)
9D01D7F8  50A00014   BEQL A1, ZERO, 0x9D01D84C
9D01D7FC  8EE40008   LW A0, 8(S7)
9D01D800  8C43000C   LW V1, 12(V0)
9D01D804  8C470024   LW A3, 36(V0)
9D01D808  8C420020   LW V0, 32(V0)
9D01D80C  0B40760C   J 0x9D01D830
9D01D810  2442FFFE   ADDIU V0, V0, -2
9D01D814  10800004   BEQ A0, ZERO, 0x9D01D828
9D01D818  00A33007   SRAV A2, V1, A1
9D01D81C  00063027   NOR A2, ZERO, A2
9D01D820  0B40760B   J 0x9D01D82C
9D01D824  00C31821   ADDU V1, A2, V1
9D01D828  00C31821   ADDU V1, A2, V1
9D01D82C  00471021   ADDU V0, V0, A3
9D01D830  0440FFF8   BLTZ V0, 0x9D01D814
9D01D834  00403021   ADDU A2, V0, ZERO
9D01D838  260292EC   ADDIU V0, S0, -27924
9D01D83C  AC43000C   SW V1, 12(V0)
9D01D840  AC460020   SW A2, 32(V0)
9D01D844  261792EC   ADDIU S7, S0, -27924
9D01D848  8EE40008   LW A0, 8(S7)
9D01D84C  0F40D22B   JAL __subsf3
9D01D850  8EE5014C   LW A1, 332(S7)
9D01D854  0040F021   ADDU FP, V0, ZERO
9D01D858  AEE20008   SW V0, 8(S7)
9D01D85C  00002021   ADDU A0, ZERO, ZERO
9D01D860  0F40EB16   JAL __lesf2
9D01D864  00402821   ADDU A1, V0, ZERO
9D01D868  1840003C   BLEZ V0, 0x9D01D95C
9D01D86C  32420002   ANDI V0, S2, 2
9D01D870  8EE20014   LW V0, 20(S7)
9D01D874  10400005   BEQ V0, ZERO, 0x9D01D88C
9D01D878  260292EC   ADDIU V0, S0, -27924
9D01D87C  92E2001C   LBU V0, 28(S7)
9D01D880  00021200   SLL V0, V0, 8
9D01D884  0B407627   J 0x9D01D89C
9D01D888  AFA20014   SW V0, 20(SP)
9D01D88C  90420040   LBU V0, 64(V0)
9D01D890  3842000F   XORI V0, V0, 15
9D01D894  00021200   SLL V0, V0, 8
9D01D898  AFA20014   SW V0, 20(SP)
9D01D89C  03C02021   ADDU A0, FP, ZERO
9D01D8A0  0F40EB16   JAL __lesf2
9D01D8A4  00002821   ADDU A1, ZERO, ZERO
9D01D8A8  04410022   BGEZ V0, 0x9D01D934
9D01D8AC  261192EC   ADDIU S1, S0, -27924
9D01D8B0  8E24000C   LW A0, 12(S1)
9D01D8B4  0F40EEE7   JAL sitofp
9D01D8B8  24840001   ADDIU A0, A0, 1
9D01D8BC  AFA20018   SW V0, 24(SP)
9D01D8C0  8E22004C   LW V0, 76(S1)
9D01D8C4  AFA2001C   SW V0, 28(SP)
9D01D8C8  92310048   LBU S1, 72(S1)
9D01D8CC  AFA00010   SW ZERO, 16(SP)
9D01D8D0  0000B821   ADDU S7, ZERO, ZERO
9D01D8D4  03C02021   ADDU A0, FP, ZERO
9D01D8D8  0F40D22D   JAL fpadd
9D01D8DC  8FA50018   LW A1, 24(SP)
9D01D8E0  0040F021   ADDU FP, V0, ZERO
9D01D8E4  26310001   ADDIU S1, S1, 1
9D01D8E8  3231000F   ANDI S1, S1, 15
9D01D8EC  8FA4001C   LW A0, 28(SP)
9D01D8F0  0224182A   SLT V1, S1, A0
9D01D8F4  8FA50014   LW A1, 20(SP)
9D01D8F8  02E51021   ADDU V0, S7, A1
9D01D8FC  02E5B823   SUBU S7, S7, A1
9D01D900  0043B80B   MOVN S7, V0, V1
9D01D904  8FA60010   LW A2, 16(SP)
9D01D908  24C60001   ADDIU A2, A2, 1
9D01D90C  AFA60010   SW A2, 16(SP)
9D01D910  03C02021   ADDU A0, FP, ZERO
9D01D914  0F40EB16   JAL __lesf2
9D01D918  00002821   ADDU A1, ZERO, ZERO
9D01D91C  0440FFEE   BLTZ V0, 0x9D01D8D8
9D01D920  03C02021   ADDU A0, FP, ZERO
9D01D924  260292EC   ADDIU V0, S0, -27924
9D01D928  AC5E0008   SW FP, 8(V0)
9D01D92C  0B40764F   J 0x9D01D93C
9D01D930  A0510048   SB S1, 72(V0)
9D01D934  AFA00010   SW ZERO, 16(SP)
9D01D938  0000B821   ADDU S7, ZERO, ZERO
9D01D93C  8FA30010   LW V1, 16(SP)
9D01D940  02E3001A   DIV S7, V1
9D01D944  006001F4   TEQ V1, ZERO
9D01D948  0000B812   MFLO S7
9D01D94C  00008812   MFLO S1
9D01D950  260292EC   ADDIU V0, S0, -27924
9D01D954  AC570010   SW S7, 16(V0)
344:                 APU_MAKE_RECTANGLE(1)
9D01D968  260292EC   ADDIU V0, S0, -27924
9D01D96C  8C430060   LW V1, 96(V0)
9D01D970  0003F1C3   SRA FP, V1, 7
9D01D974  007EF023   SUBU FP, V1, FP
9D01D978  AC5E0060   SW FP, 96(V0)
9D01D97C  8C420054   LW V0, 84(V0)
9D01D980  10400089   BEQ V0, ZERO, 0x9D01DBA8
9D01D984  03C01821   ADDU V1, FP, ZERO
9D01D988  260292EC   ADDIU V0, S0, -27924
9D01D98C  8C420094   LW V0, 148(V0)
9D01D990  50400086   BEQL V0, ZERO, 0x9D01DBAC
9D01D994  02238821   ADDU S1, S1, V1
9D01D998  260392EC   ADDIU V1, S0, -27924
9D01D99C  8C650068   LW A1, 104(V1)
9D01D9A0  54A00004   BNEL A1, ZERO, 0x9D01D9B4
9D01D9A4  260292EC   ADDIU V0, S0, -27924
9D01D9A8  2442FFFF   ADDIU V0, V0, -1
9D01D9AC  AC620094   SW V0, 148(V1)
9D01D9B0  260292EC   ADDIU V0, S0, -27924
9D01D9B4  90430090   LBU V1, 144(V0)
9D01D9B8  8C46008C   LW A2, 140(V0)
9D01D9BC  8C420088   LW V0, 136(V0)
9D01D9C0  0B40767C   J 0x9D01D9F0
9D01D9C4  2442FFFC   ADDIU V0, V0, -4
9D01D9C8  50A00004   BEQL A1, ZERO, 0x9D01D9DC
9D01D9CC  2C64000F   SLTIU A0, V1, 15
9D01D9D0  24630001   ADDIU V1, V1, 1
9D01D9D4  0B40767B   J 0x9D01D9EC
9D01D9D8  3063000F   ANDI V1, V1, 15
9D01D9DC  50800004   BEQL A0, ZERO, 0x9D01D9F0
9D01D9E0  00461021   ADDU V0, V0, A2
9D01D9E4  24630001   ADDIU V1, V1, 1
9D01D9E8  306300FF   ANDI V1, V1, 255
9D01D9EC  00461021   ADDU V0, V0, A2
9D01D9F0  0440FFF5   BLTZ V0, 0x9D01D9C8
9D01D9F4  00402021   ADDU A0, V0, ZERO
9D01D9F8  260292EC   ADDIU V0, S0, -27924
9D01D9FC  AC440088   SW A0, 136(V0)
9D01DA00  A0430090   SB V1, 144(V0)
9D01DA04  8C42005C   LW V0, 92(V0)
9D01DA08  28440008   SLTI A0, V0, 8
9D01DA0C  14800066   BNE A0, ZERO, 0x9D01DBA8
9D01DA10  03C01821   ADDU V1, FP, ZERO
9D01DA14  260392EC   ADDIU V1, S0, -27924
9D01DA18  8C640080   LW A0, 128(V1)
9D01DA1C  54800006   BNEL A0, ZERO, 0x9D01DA38
9D01DA20  260292EC   ADDIU V0, S0, -27924
9D01DA24  8C630084   LW V1, 132(V1)
9D01DA28  0062102A   SLT V0, V1, V0
9D01DA2C  1440005E   BNE V0, ZERO, 0x9D01DBA8
9D01DA30  03C01821   ADDU V1, FP, ZERO
9D01DA34  260292EC   ADDIU V0, S0, -27924
9D01DA38  8C420078   LW V0, 120(V0)
9D01DA3C  10400016   BEQ V0, ZERO, 0x9D01DA98
9D01DA40  261792EC   ADDIU S7, S0, -27924
9D01DA44  260292EC   ADDIU V0, S0, -27924
9D01DA48  9045007C   LBU A1, 124(V0)
9D01DA4C  50A00013   BEQL A1, ZERO, 0x9D01DA9C
9D01DA50  8EE40058   LW A0, 88(S7)
9D01DA54  8C43005C   LW V1, 92(V0)
9D01DA58  8C470074   LW A3, 116(V0)
9D01DA5C  8C420070   LW V0, 112(V0)
9D01DA60  0B4076A0   J 0x9D01DA80
9D01DA64  2442FFFE   ADDIU V0, V0, -2
9D01DA68  10800003   BEQ A0, ZERO, 0x9D01DA78
9D01DA6C  00A33007   SRAV A2, V1, A1
9D01DA70  0B40769F   J 0x9D01DA7C
9D01DA74  00661823   SUBU V1, V1, A2
9D01DA78  00C31821   ADDU V1, A2, V1
9D01DA7C  00471021   ADDU V0, V0, A3
9D01DA80  0440FFF9   BLTZ V0, 0x9D01DA68
9D01DA84  00403021   ADDU A2, V0, ZERO
9D01DA88  260292EC   ADDIU V0, S0, -27924
9D01DA8C  AC43005C   SW V1, 92(V0)
9D01DA90  AC460070   SW A2, 112(V0)
9D01DA94  261792EC   ADDIU S7, S0, -27924
9D01DA98  8EE40058   LW A0, 88(S7)
9D01DA9C  0F40D22B   JAL __subsf3
9D01DAA0  8EE5014C   LW A1, 332(S7)
9D01DAA4  AFA20010   SW V0, 16(SP)
9D01DAA8  AEE20058   SW V0, 88(S7)
9D01DAAC  00002021   ADDU A0, ZERO, ZERO
9D01DAB0  0F40EB16   JAL __lesf2
9D01DAB4  00402821   ADDU A1, V0, ZERO
9D01DAB8  1840003B   BLEZ V0, 0x9D01DBA8
9D01DABC  03C01821   ADDU V1, FP, ZERO
9D01DAC0  8EE20064   LW V0, 100(S7)
9D01DAC4  10400005   BEQ V0, ZERO, 0x9D01DADC
9D01DAC8  260292EC   ADDIU V0, S0, -27924
9D01DACC  92E2006C   LBU V0, 108(S7)
9D01DAD0  00021200   SLL V0, V0, 8
9D01DAD4  0B4076BB   J 0x9D01DAEC
9D01DAD8  AFA20018   SW V0, 24(SP)
9D01DADC  90420090   LBU V0, 144(V0)
9D01DAE0  3842000F   XORI V0, V0, 15
9D01DAE4  00021200   SLL V0, V0, 8
9D01DAE8  AFA20018   SW V0, 24(SP)
9D01DAEC  8FA40010   LW A0, 16(SP)
9D01DAF0  0F40EB16   JAL __lesf2
9D01DAF4  00002821   ADDU A1, ZERO, ZERO
9D01DAF8  04410023   BGEZ V0, 0x9D01DB88
9D01DAFC  261792EC   ADDIU S7, S0, -27924
9D01DB00  8EE4005C   LW A0, 92(S7)
9D01DB04  0F40EEE7   JAL sitofp
9D01DB08  24840001   ADDIU A0, A0, 1
9D01DB0C  AFA2001C   SW V0, 28(SP)
9D01DB10  8EE4009C   LW A0, 156(S7)
9D01DB14  AFA40020   SW A0, 32(SP)
9D01DB18  92F70098   LBU S7, 152(S7)
9D01DB1C  AFA00014   SW ZERO, 20(SP)
9D01DB20  0000F021   ADDU FP, ZERO, ZERO
9D01DB24  8FA40010   LW A0, 16(SP)
9D01DB28  0F40D22D   JAL fpadd
9D01DB2C  8FA5001C   LW A1, 28(SP)
9D01DB30  AFA20010   SW V0, 16(SP)
9D01DB34  26F70001   ADDIU S7, S7, 1
9D01DB38  32F7000F   ANDI S7, S7, 15
9D01DB3C  8FA50020   LW A1, 32(SP)
9D01DB40  02E5182A   SLT V1, S7, A1
9D01DB44  8FA60018   LW A2, 24(SP)
9D01DB48  03C61021   ADDU V0, FP, A2
9D01DB4C  03C6F023   SUBU FP, FP, A2
9D01DB50  0043F00B   MOVN FP, V0, V1
9D01DB54  8FA20014   LW V0, 20(SP)
9D01DB58  24420001   ADDIU V0, V0, 1
9D01DB5C  AFA20014   SW V0, 20(SP)
9D01DB60  8FA40010   LW A0, 16(SP)
9D01DB64  0F40EB16   JAL __lesf2
9D01DB68  00002821   ADDU A1, ZERO, ZERO
9D01DB6C  0440FFEE   BLTZ V0, 0x9D01DB28
9D01DB70  8FA40010   LW A0, 16(SP)
9D01DB74  260292EC   ADDIU V0, S0, -27924
9D01DB78  8FA30010   LW V1, 16(SP)
9D01DB7C  AC430058   SW V1, 88(V0)
9D01DB80  0B4076E4   J 0x9D01DB90
9D01DB84  A0570098   SB S7, 152(V0)
9D01DB88  AFA00014   SW ZERO, 20(SP)
9D01DB8C  0000F021   ADDU FP, ZERO, ZERO
9D01DB90  8FA20014   LW V0, 20(SP)
9D01DB94  03C2001A   DIV FP, V0
9D01DB98  004001F4   TEQ V0, ZERO
9D01DB9C  00001812   MFLO V1
9D01DBA0  260292EC   ADDIU V0, S0, -27924
9D01DBA4  AC430060   SW V1, 96(V0)
345:                 
346:                 
347:                 /* TRIANGLE WAVE
348:                 ** =============
349:                 ** reg0: 7=holdnote, 6-0=linear length counter
350:                 ** reg2: low 8 bits of frequency
351:                 ** reg3: 7-3=length counter, 2-0=high 3 bits of frequency
352:                 */
353:                 static int32 apu_triangle(void)
354:                 {
355:                    APU_VOLUME_DECAY(apu.triangle.output_vol);
9D01DBBC  260292EC   ADDIU V0, S0, -27924
9D01DBC0  8C4300B0   LW V1, 176(V0)
9D01DBC4  000321C3   SRA A0, V1, 7
9D01DBC8  00641823   SUBU V1, V1, A0
9D01DBCC  AC4300B0   SW V1, 176(V0)
356:                 
357:                    if (false == apu.triangle.enabled || 0 == apu.triangle.vbl_length)
9D01DBD0  8C4200A4   LW V0, 164(V0)
9D01DBD4  10400004   BEQ V0, ZERO, 0x9D01DBE8
9D01DBD8  260292EC   ADDIU V0, S0, -27924
9D01DBDC  8C4200C4   LW V0, 196(V0)
9D01DBE0  14400004   BNE V0, ZERO, 0x9D01DBF4
9D01DBE4  260492EC   ADDIU A0, S0, -27924
358:                       return APU_TRIANGLE_OUTPUT;
9D01DBE8  00031083   SRA V0, V1, 2
9D01DBEC  0B407744   J 0x9D01DD10
9D01DBF0  00621821   ADDU V1, V1, V0
359:                 
360:                    if (apu.triangle.counter_started)
9D01DBF4  8C8400BC   LW A0, 188(A0)
9D01DBF8  5080000B   BEQL A0, ZERO, 0x9D01DC28
9D01DBFC  260292EC   ADDIU V0, S0, -27924
361:                    {
362:                       if (apu.triangle.linear_length > 0)
9D01DC00  260492EC   ADDIU A0, S0, -27924
9D01DC04  8C8400C8   LW A0, 200(A0)
9D01DC08  18800167   BLEZ A0, 0x9D01E1A8
9D01DC0C  260592EC   ADDIU A1, S0, -27924
363:                          apu.triangle.linear_length--;
9D01DC10  2484FFFF   ADDIU A0, A0, -1
9D01DC14  0B40786A   J 0x9D01E1A8
9D01DC18  ACA400C8   SW A0, 200(A1)
364:                       if (apu.triangle.vbl_length && false == apu.triangle.holdnote)
9D01E1A8  260492EC   ADDIU A0, S0, -27924
9D01E1AC  8C8400B8   LW A0, 184(A0)
9D01E1B0  1080FE9A   BEQ A0, ZERO, 0x9D01DC1C
9D01E1B4  260492EC   ADDIU A0, S0, -27924
365:                          apu.triangle.vbl_length--;
9D01DC1C  2442FFFF   ADDIU V0, V0, -1
9D01DC20  0B407715   J 0x9D01DC54
9D01DC24  AC8200C4   SW V0, 196(A0)
366:                    }
367:                    else if (false == apu.triangle.holdnote && apu.triangle.write_latency)
9D01DC28  8C4200B8   LW V0, 184(V0)
9D01DC2C  1440000A   BNE V0, ZERO, 0x9D01DC58
9D01DC30  260292EC   ADDIU V0, S0, -27924
9D01DC34  8C4200C0   LW V0, 192(V0)
9D01DC38  50400007   BEQL V0, ZERO, 0x9D01DC58
9D01DC3C  260292EC   ADDIU V0, S0, -27924
368:                    {
369:                       if (--apu.triangle.write_latency == 0)
9D01DC40  2442FFFF   ADDIU V0, V0, -1
9D01DC44  260492EC   ADDIU A0, S0, -27924
9D01DC48  14400002   BNE V0, ZERO, 0x9D01DC54
9D01DC4C  AC8200C0   SW V0, 192(A0)
370:                          apu.triangle.counter_started = true;
9D01D708  24160001   ADDIU S6, ZERO, 1
9D01DC50  AC9600BC   SW S6, 188(A0)
371:                    }
372:                 
373:                    if (0 == apu.triangle.linear_length || apu.triangle.freq < 4) /* inaudible */
9D01DC54  260292EC   ADDIU V0, S0, -27924
9D01DC58  8C4200C8   LW V0, 200(V0)
9D01DC5C  10400006   BEQ V0, ZERO, 0x9D01DC78
9D01DC60  260292EC   ADDIU V0, S0, -27924
9D01DC64  8C4200AC   LW V0, 172(V0)
9D01DC68  AFA20014   SW V0, 20(SP)
9D01DC6C  28420004   SLTI V0, V0, 4
9D01DC70  10400004   BEQ V0, ZERO, 0x9D01DC84
9D01DC74  261792EC   ADDIU S7, S0, -27924
9D01E1B8  0B407716   J 0x9D01DC58
9D01E1BC  260292EC   ADDIU V0, S0, -27924
374:                       return APU_TRIANGLE_OUTPUT;
9D01DC78  00031083   SRA V0, V1, 2
9D01DC7C  0B407744   J 0x9D01DD10
9D01DC80  00621821   ADDU V1, V1, V0
375:                 
376:                    apu.triangle.accum -= apu.cycle_rate; \
9D01DC84  8EE400A8   LW A0, 168(S7)
9D01DC88  0F40D22B   JAL __subsf3
9D01DC8C  8EE5014C   LW A1, 332(S7)
9D01DC90  8EE300B0   LW V1, 176(S7)
9D01DC94  AFA30010   SW V1, 16(SP)
9D01DC98  92FE00B4   LBU FP, 180(S7)
9D01DC9C  0B407739   J 0x9D01DCE4
9D01DCA0  0040B821   ADDU S7, V0, ZERO
377:                    while (apu.triangle.accum < 0)
9D01DCE4  02E02021   ADDU A0, S7, ZERO
9D01DCE8  0F40EB16   JAL __lesf2
9D01DCEC  00002821   ADDU A1, ZERO, ZERO
9D01DCF0  0440FFEC   BLTZ V0, 0x9D01DCA4
9D01DCF4  260292EC   ADDIU V0, S0, -27924
9D01DCF8  8FA50010   LW A1, 16(SP)
9D01DCFC  AC4500B0   SW A1, 176(V0)
9D01DD00  AC5700A8   SW S7, 168(V0)
9D01DD04  A05E00B4   SB FP, 180(V0)
378:                    {
379:                       apu.triangle.accum += apu.triangle.freq;
9D01DCA4  0F40EEE7   JAL sitofp
9D01DCA8  8FA40014   LW A0, 20(SP)
9D01DCAC  00402021   ADDU A0, V0, ZERO
9D01DCB0  0F40D22D   JAL fpadd
9D01DCB4  02E02821   ADDU A1, S7, ZERO
9D01DCDC  0040B821   ADDU S7, V0, ZERO
380:                       apu.triangle.adder = (apu.triangle.adder + 1) & 0x1F;
9D01DCB8  27DE0001   ADDIU FP, FP, 1
9D01DCBC  33DE00FF   ANDI FP, FP, 255
9D01DCE0  33DE001F   ANDI FP, FP, 31
381:                 
382:                       if (apu.triangle.adder & 0x10)
9D01DCC0  33C50010   ANDI A1, FP, 16
9D01DCC4  30A500FF   ANDI A1, A1, 255
383:                          apu.triangle.output_vol -= (2 << 8);
9D01DCC8  8FA40010   LW A0, 16(SP)
9D01DCCC  2483FE00   ADDIU V1, A0, -512
9D01DCD0  24840200   ADDIU A0, A0, 512
9D01DCD4  0085180A   MOVZ V1, A0, A1
9D01DCD8  AFA30010   SW V1, 16(SP)
384:                       else
385:                          apu.triangle.output_vol += (2 << 8);
386:                    }
387:                 
388:                    return APU_TRIANGLE_OUTPUT;
9D01DD08  00051883   SRA V1, A1, 2
9D01DD0C  00A31821   ADDU V1, A1, V1
389:                 }
390:                 
391:                 
392:                 /* WHITE NOISE CHANNEL
393:                 ** ===================
394:                 ** reg0: 0-3=volume, 4=envelope, 5=hold
395:                 ** reg2: 7=small(93 byte) sample,3-0=freq lookup
396:                 ** reg3: 7-4=vbl length counter
397:                 */
398:                 /* TODO: AAAAAAAAAAAAAAAAAAAAAAAA!  #ifdef MADNESS! */
399:                 static int32 apu_noise(void)
400:                 {
401:                    int32 outvol;
402:                 
403:                 #if defined(APU_OVERSAMPLE) && defined(REALTIME_NOISE)
404:                 #else /* !(APU_OVERSAMPLE && REALTIME_NOISE) */
405:                    int32 noise_bit;
406:                 #endif /* !(APU_OVERSAMPLE && REALTIME_NOISE) */
407:                 #ifdef APU_OVERSAMPLE
408:                    int num_times;
409:                    int32 total;
410:                 #endif /* APU_OVERSAMPLE */
411:                 
412:                    APU_VOLUME_DECAY(apu.noise.output_vol);
9D01DD24  260292EC   ADDIU V0, S0, -27924
9D01DD28  8C4300DC   LW V1, 220(V0)
9D01DD2C  0003B9C3   SRA S7, V1, 7
9D01DD30  0077B823   SUBU S7, V1, S7
9D01DD34  AC5700DC   SW S7, 220(V0)
413:                 
414:                    if (false == apu.noise.enabled || 0 == apu.noise.vbl_length)
9D01DD38  8C4200D0   LW V0, 208(V0)
9D01DD3C  10400004   BEQ V0, ZERO, 0x9D01DD50
9D01DD40  260292EC   ADDIU V0, S0, -27924
9D01DD44  8C4200F8   LW V0, 248(V0)
9D01DD48  14400005   BNE V0, ZERO, 0x9D01DD60
9D01DD4C  260392EC   ADDIU V1, S0, -27924
415:                       return APU_NOISE_OUTPUT;
9D01DD50  00171040   SLL V0, S7, 1
9D01DD54  02E2B821   ADDU S7, S7, V0
9D01DD58  0B4077C6   J 0x9D01DF18
9D01DD5C  0017B883   SRA S7, S7, 2
416:                 
417:                    /* vbl length counter */
418:                    if (false == apu.noise.holdnote)
9D01DD60  8C6500F0   LW A1, 240(V1)
9D01DD64  54A00004   BNEL A1, ZERO, 0x9D01DD78
9D01DD68  260292EC   ADDIU V0, S0, -27924
419:                       apu.noise.vbl_length--;
9D01DD6C  2442FFFF   ADDIU V0, V0, -1
9D01DD70  AC6200F8   SW V0, 248(V1)
9D01DD74  260292EC   ADDIU V0, S0, -27924
9D01DD78  904300E8   LBU V1, 232(V0)
9D01DD7C  8C4600E4   LW A2, 228(V0)
420:                 
421:                    /* envelope decay at a rate of (env_delay + 1) / 240 secs */
422:                    apu.noise.env_phase -= 4; /* 240/60 */
9D01DD80  8C4200E0   LW V0, 224(V0)
9D01DD84  0B40776D   J 0x9D01DDB4
9D01DD88  2442FFFC   ADDIU V0, V0, -4
423:                    while (apu.noise.env_phase < 0)
9D01DDB4  0440FFF5   BLTZ V0, 0x9D01DD8C
9D01DDB8  00000000   NOP
9D01DDBC  3C06A001   LUI A2, -24575
9D01DDC0  24C692EC   ADDIU A2, A2, -27924
9D01DDC4  ACC200E0   SW V0, 224(A2)
9D01DDC8  A0C300E8   SB V1, 232(A2)
424:                    {
425:                       apu.noise.env_phase += apu.noise.env_delay;
426:                 
427:                       if (apu.noise.holdnote)
9D01DD8C  10A00004   BEQ A1, ZERO, 0x9D01DDA0
9D01DD90  2C64000F   SLTIU A0, V1, 15
428:                          apu.noise.env_vol = (apu.noise.env_vol + 1) & 0x0F;
9D01DD94  24630001   ADDIU V1, V1, 1
9D01DD98  0B40776C   J 0x9D01DDB0
9D01DD9C  3063000F   ANDI V1, V1, 15
429:                       else if (apu.noise.env_vol < 0x0F)
9D01DDA0  50800004   BEQL A0, ZERO, 0x9D01DDB4
9D01DDA4  00461021   ADDU V0, V0, A2
430:                          apu.noise.env_vol++;
9D01DDA8  24630001   ADDIU V1, V1, 1
9D01DDAC  306300FF   ANDI V1, V1, 255
9D01DDB0  00461021   ADDU V0, V0, A2
431:                    }
432:                 
433:                    apu.noise.accum -= apu.cycle_rate;
9D01DDCC  8CC400D4   LW A0, 212(A2)
9D01DDD0  0F40D22B   JAL __subsf3
9D01DDD4  8CC5014C   LW A1, 332(A2)
9D01DDD8  0040F021   ADDU FP, V0, ZERO
9D01DDDC  3C02A001   LUI V0, -24575
9D01DDE0  244292EC   ADDIU V0, V0, -27924
9D01DDE4  AC5E00D4   SW FP, 212(V0)
434:                    if (apu.noise.accum >= 0)
9D01DDE8  00002021   ADDU A0, ZERO, ZERO
9D01DDEC  0F40EB16   JAL __lesf2
9D01DDF0  03C02821   ADDU A1, FP, ZERO
9D01DDF4  1C400004   BGTZ V0, 0x9D01DE08
9D01DDF8  00171040   SLL V0, S7, 1
435:                       return APU_NOISE_OUTPUT;
9D01DDFC  02E2B821   ADDU S7, S7, V0
9D01DE00  0B4077C6   J 0x9D01DF18
9D01DE04  0017B883   SRA S7, S7, 2
436:                    
437:                 #ifdef APU_OVERSAMPLE
438:                    if (apu.noise.fixed_envelope)
9D01DE08  260292EC   ADDIU V0, S0, -27924
9D01DE0C  8C4200EC   LW V0, 236(V0)
9D01DE10  10400005   BEQ V0, ZERO, 0x9D01DE28
9D01DE14  260292EC   ADDIU V0, S0, -27924
439:                       outvol = apu.noise.volume << 8; /* fixed volume */
9D01DE18  904200F4   LBU V0, 244(V0)
9D01DE1C  00021200   SLL V0, V0, 8
9D01DE20  0B40778E   J 0x9D01DE38
9D01DE24  AFA20018   SW V0, 24(SP)
440:                    else
441:                       outvol = (apu.noise.env_vol ^ 0x0F) << 8;
9D01DE28  904200E8   LBU V0, 232(V0)
9D01DE2C  3842000F   XORI V0, V0, 15
9D01DE30  00021200   SLL V0, V0, 8
9D01DE34  AFA20018   SW V0, 24(SP)
442:                 
443:                    num_times = total = 0;
9D01DE64  AFA00014   SW ZERO, 20(SP)
9D01DE68  AFA00010   SW ZERO, 16(SP)
9D01DEE8  AFA00014   SW ZERO, 20(SP)
9D01DEEC  AFA00010   SW ZERO, 16(SP)
444:                 #endif /* APU_OVERSAMPLE */
445:                 
446:                    while (apu.noise.accum < 0)
9D01DE38  03C02021   ADDU A0, FP, ZERO
9D01DE3C  0F40EB16   JAL __lesf2
9D01DE40  00002821   ADDU A1, ZERO, ZERO
9D01DE44  04410028   BGEZ V0, 0x9D01DEE8
9D01DE48  261792EC   ADDIU S7, S0, -27924
9D01DEC4  03C02021   ADDU A0, FP, ZERO
9D01DEC8  0F40EB16   JAL __lesf2
9D01DECC  00002821   ADDU A1, ZERO, ZERO
9D01DED0  0440FFE7   BLTZ V0, 0x9D01DE70
9D01DED4  03C02021   ADDU A0, FP, ZERO
9D01DED8  260292EC   ADDIU V0, S0, -27924
9D01DEDC  AC5E00D4   SW FP, 212(V0)
9D01DEE0  0B4077BC   J 0x9D01DEF0
9D01DEE4  AF978018   SW S7, -32744(GP)
447:                    {
448:                       apu.noise.accum += apu.noise.freq;
9D01DE4C  0F40EEE7   JAL sitofp
9D01DE50  8EE400D8   LW A0, 216(S7)
9D01DE54  AFA2001C   SW V0, 28(SP)
9D01DE6C  03C02021   ADDU A0, FP, ZERO
9D01DE70  0F40D22D   JAL fpadd
9D01DE74  8FA5001C   LW A1, 28(SP)
9D01DE78  0040F021   ADDU FP, V0, ZERO
449:                 
450:                 #ifdef REALTIME_NOISE
451:                 
452:                 #ifdef APU_OVERSAMPLE
453:                       if (shift_register15(apu.noise.xor_tap))
454:                          total += outvol;
9D01DE9C  8FA50010   LW A1, 16(SP)
9D01DEA0  8FA60018   LW A2, 24(SP)
9D01DEA4  00A61821   ADDU V1, A1, A2
9D01DEA8  00A62023   SUBU A0, A1, A2
9D01DEAC  00561026   XOR V0, V0, S6
9D01DEB0  0082180A   MOVZ V1, A0, V0
9D01DEB4  AFA30010   SW V1, 16(SP)
455:                       else
456:                          total -= outvol;
457:                 
458:                       num_times++;
9D01DEB8  8FA20014   LW V0, 20(SP)
9D01DEBC  24420001   ADDIU V0, V0, 1
9D01DEC0  AFA20014   SW V0, 20(SP)
459:                 #else /* !APU_OVERSAMPLE */
460:                       noise_bit = shift_register15(apu.noise.xor_tap);
461:                 #endif /* !APU_OVERSAMPLE */
462:                 
463:                 #else /* !REALTIME_NOISE */
464:                       apu.noise.cur_pos++;
465:                 
466:                       if (apu.noise.short_sample)
467:                       {
468:                          if (APU_NOISE_93 == apu.noise.cur_pos)
469:                             apu.noise.cur_pos = 0;
470:                       }
471:                       else
472:                       {
473:                          if (APU_NOISE_32K == apu.noise.cur_pos)
474:                             apu.noise.cur_pos = 0;
475:                       }
476:                 
477:                 #ifdef APU_OVERSAMPLE
478:                       if (apu.noise.short_sample)
479:                          noise_bit = noise_short_lut[apu.noise.cur_pos];
480:                       else
481:                          noise_bit = noise_long_lut[apu.noise.cur_pos];
482:                 
483:                       if (noise_bit)
484:                          total += outvol;
485:                       else
486:                          total -= outvol;
487:                 
488:                       num_times++;
489:                 #endif /* APU_OVERSAMPLE */
490:                 #endif /* !REALTIME_NOISE */
491:                    }
492:                 
493:                 #ifdef APU_OVERSAMPLE
494:                    apu.noise.output_vol = total / num_times;
9D01DEF0  8FA30010   LW V1, 16(SP)
9D01DEF4  8FA40014   LW A0, 20(SP)
9D01DEF8  0064001A   DIV V1, A0
9D01DEFC  008001F4   TEQ A0, ZERO
9D01DF00  0000B812   MFLO S7
9D01DF04  260292EC   ADDIU V0, S0, -27924
9D01DF08  AC5700DC   SW S7, 220(V0)
495:                 #else /* !APU_OVERSAMPLE */
496:                    if (apu.noise.fixed_envelope)
497:                       outvol = apu.noise.volume << 8; /* fixed volume */
498:                    else
499:                       outvol = (apu.noise.env_vol ^ 0x0F) << 8;
500:                 
501:                 #ifndef REALTIME_NOISE
502:                    if (apu.noise.short_sample)
503:                       noise_bit = noise_short_lut[apu.noise.cur_pos];
504:                    else
505:                       noise_bit = noise_long_lut[apu.noise.cur_pos];
506:                 #endif /* !REALTIME_NOISE */
507:                 
508:                    if (noise_bit)
509:                       apu.noise.output_vol = outvol;
510:                    else
511:                       apu.noise.output_vol = -outvol;
512:                 #endif /* !APU_OVERSAMPLE */
513:                 
514:                    return APU_NOISE_OUTPUT;
9D01DF0C  00171040   SLL V0, S7, 1
9D01DF10  02E2B821   ADDU S7, S7, V0
9D01DF14  0017B883   SRA S7, S7, 2
515:                 }
516:                 
517:                 
518:                 INLINE void apu_dmcreload(void)
519:                 {
520:                    apu.dmc.address = apu.dmc.cached_addr;
9D01DFE4  8C630118   LW V1, 280(V1)
9D01E834  3C02A001   LUI V0, -24575
521:                    apu.dmc.dma_length = apu.dmc.cached_dmalength;
9D01DFEC  8C430120   LW V1, 288(V0)
9D01E844  8C430120   LW V1, 288(V0)
522:                    apu.dmc.irq_occurred = false;
9D01DFF4  0B40780C   J 0x9D01E030
9D01DFF8  AC400130   SW ZERO, 304(V0)
523:                 }
524:                 
525:                 /* DELTA MODULATION CHANNEL
526:                 ** =========================
527:                 ** reg0: 7=irq gen, 6=looping, 3-0=pointer to clock table
528:                 ** reg1: output dc level, 6 bits unsigned
529:                 ** reg2: 8 bits of 64-byte aligned address offset : $C000 + (value * 64)
530:                 ** reg3: length, (value * 16) + 1
531:                 */
532:                 static int32 apu_dmc(void)
533:                 {
534:                    int delta_bit;
535:                 
536:                    APU_VOLUME_DECAY(apu.dmc.output_vol);
9D01DF2C  8C430110   LW V1, 272(V0)
9D01DF30  000321C3   SRA A0, V1, 7
9D01DF34  00641823   SUBU V1, V1, A0
9D01DF38  AC430110   SW V1, 272(V0)
537:                 
538:                    /* only process when channel is alive */
539:                    if (apu.dmc.dma_length)
9D01DF3C  8C42011C   LW V0, 284(V0)
9D01DF40  1040005C   BEQ V0, ZERO, 0x9D01E0B4
9D01DF44  261292EC   ADDIU S2, S0, -27924
540:                    {
541:                       apu.dmc.accum -= apu.cycle_rate;
9D01DF48  8E440108   LW A0, 264(S2)
9D01DF4C  0F40D22B   JAL __subsf3
9D01DF50  8E45014C   LW A1, 332(S2)
9D01DF54  0B407826   J 0x9D01E098
9D01DF58  AE420108   SW V0, 264(S2)
542:                       
543:                       while (apu.dmc.accum < 0)
9D01E098  260292EC   ADDIU V0, S0, -27924
9D01E09C  8C570108   LW S7, 264(V0)
9D01E0A0  02E02021   ADDU A0, S7, ZERO
9D01E0A4  0F40EB16   JAL __lesf2
9D01E0A8  00002821   ADDU A1, ZERO, ZERO
9D01E0AC  0440FFAB   BLTZ V0, 0x9D01DF5C
9D01E0B0  261292EC   ADDIU S2, S0, -27924
544:                       {
545:                          apu.dmc.accum += apu.dmc.freq;
9D01DF5C  0F40EEE7   JAL sitofp
9D01DF60  8E44010C   LW A0, 268(S2)
9D01DF64  00402021   ADDU A0, V0, ZERO
9D01DF68  0F40D22D   JAL fpadd
9D01DF6C  02E02821   ADDU A1, S7, ZERO
9D01DF70  AE420108   SW V0, 264(S2)
546:                          
547:                          delta_bit = (apu.dmc.dma_length & 7) ^ 7;
9D01DF74  8E52011C   LW S2, 284(S2)
9D01DF78  00129027   NOR S2, ZERO, S2
9D01DF7C  32520007   ANDI S2, S2, 7
548:                          
549:                          if (7 == delta_bit)
9D01DF80  16540011   BNE S2, S4, 0x9D01DFC8
9D01DF84  260392EC   ADDIU V1, S0, -27924
550:                          {
551:                             apu.dmc.cur_byte = nes6502_getbyte(apu.dmc.address);
9D01DF88  261792EC   ADDIU S7, S0, -27924
9D01DF8C  0F4000BA   JAL nes6502_getbyte
9D01DF90  8EE40114   LW A0, 276(S7)
9D01DF94  A2E20124   SB V0, 292(S7)
552:                             
553:                             /* steal a cycle from CPU*/
554:                             nes6502_burn(1);
9D01DF98  0F402895   JAL nes6502_burn
9D01DF9C  02C02021   ADDU A0, S6, ZERO
555:                 
556:                             /* prevent wraparound */
557:                             if (0xFFFF == apu.dmc.address)
9D01DFA0  8EE20114   LW V0, 276(S7)
9D01DFA4  3405FFFF   ORI A1, ZERO, -1
9D01DFA8  14450004   BNE V0, A1, 0x9D01DFBC
9D01DFAC  260392EC   ADDIU V1, S0, -27924
558:                                apu.dmc.address = 0x8000;
9D01DFB0  34068000   ORI A2, ZERO, -32768
9D01DFB4  0B4077F2   J 0x9D01DFC8
9D01DFB8  AEE60114   SW A2, 276(S7)
559:                             else
560:                                apu.dmc.address++;
9D01DFBC  24420001   ADDIU V0, V0, 1
9D01DFC0  AC620114   SW V0, 276(V1)
561:                          }
562:                 
563:                          if (--apu.dmc.dma_length == 0)
9D01DFC4  260392EC   ADDIU V1, S0, -27924
9D01DFC8  8C62011C   LW V0, 284(V1)
9D01DFCC  2442FFFF   ADDIU V0, V0, -1
9D01DFD0  14400017   BNE V0, ZERO, 0x9D01E030
9D01DFD4  AC62011C   SW V0, 284(V1)
564:                          {
565:                             /* if loop bit set, we're cool to retrigger sample */
566:                             if (apu.dmc.looping)
9D01DFD8  8C620128   LW V0, 296(V1)
9D01DFDC  10400007   BEQ V0, ZERO, 0x9D01DFFC
9D01DFE0  00601021   ADDU V0, V1, ZERO
567:                             {
568:                                apu_dmcreload();
569:                             }
570:                             else
571:                             {
572:                                /* check to see if we should generate an irq */
573:                                if (apu.dmc.irq_gen)
9D01DFFC  260292EC   ADDIU V0, S0, -27924
9D01E000  8C42012C   LW V0, 300(V0)
9D01E004  10400007   BEQ V0, ZERO, 0x9D01E024
9D01E008  260292EC   ADDIU V0, S0, -27924
574:                                {
575:                                   apu.dmc.irq_occurred = true;
9D01E00C  AC560130   SW S6, 304(V0)
576:                                   if (apu.irq_callback)
9D01E010  8C420160   LW V0, 352(V0)
9D01E014  50400004   BEQL V0, ZERO, 0x9D01E028
9D01E018  260292EC   ADDIU V0, S0, -27924
577:                                      apu.irq_callback();
9D01E01C  0040F809   JALR V0
9D01E020  00000000   NOP
578:                                }
579:                 
580:                                /* bodge for timestamp queue */
581:                                apu.dmc.enabled = false;
9D01E024  260292EC   ADDIU V0, S0, -27924
9D01E028  0B40782D   J 0x9D01E0B4
9D01E02C  AC400104   SW ZERO, 260(V0)
582:                                break;
583:                             }
584:                          }
585:                 
586:                          /* positive delta */
587:                          if (apu.dmc.cur_byte & (1 << delta_bit))
9D01E030  260292EC   ADDIU V0, S0, -27924
9D01E034  90420124   LBU V0, 292(V0)
9D01E038  02429007   SRAV S2, V0, S2
9D01E03C  32520001   ANDI S2, S2, 1
9D01E040  1240000C   BEQ S2, ZERO, 0x9D01E074
9D01E044  260292EC   ADDIU V0, S0, -27924
588:                          {
589:                             if (apu.dmc.regs[1] < 0x7D)
9D01E048  90420101   LBU V0, 257(V0)
9D01E04C  2C43007D   SLTIU V1, V0, 125
9D01E050  50600012   BEQL V1, ZERO, 0x9D01E09C
9D01E054  260292EC   ADDIU V0, S0, -27924
590:                             {
591:                                apu.dmc.regs[1] += 2;
9D01E058  260392EC   ADDIU V1, S0, -27924
9D01E05C  24420002   ADDIU V0, V0, 2
9D01E060  A0620101   SB V0, 257(V1)
592:                                apu.dmc.output_vol += (2 << 8);
9D01E064  8C620110   LW V0, 272(V1)
9D01E068  24420200   ADDIU V0, V0, 512
9D01E06C  0B407826   J 0x9D01E098
9D01E070  AC620110   SW V0, 272(V1)
593:                             }
594:                          }
595:                          /* negative delta */
596:                          else            
597:                          {
598:                             if (apu.dmc.regs[1] > 1)
9D01E074  90430101   LBU V1, 257(V0)
9D01E078  2C620002   SLTIU V0, V1, 2
9D01E07C  14400006   BNE V0, ZERO, 0x9D01E098
9D01E080  260292EC   ADDIU V0, S0, -27924
599:                             {
600:                                apu.dmc.regs[1] -= 2;
9D01E084  2463FFFE   ADDIU V1, V1, -2
9D01E088  A0430101   SB V1, 257(V0)
601:                                apu.dmc.output_vol -= (2 << 8);
9D01E08C  8C430110   LW V1, 272(V0)
9D01E090  2463FE00   ADDIU V1, V1, -512
9D01E094  AC430110   SW V1, 272(V0)
602:                             }
603:                          }
604:                       }
605:                    }
606:                 
607:                    return APU_DMC_OUTPUT;
9D01E0B4  260292EC   ADDIU V0, S0, -27924
9D01E0B8  8C420110   LW V0, 272(V0)
9D01E0BC  00021840   SLL V1, V0, 1
9D01E0C0  00431021   ADDU V0, V0, V1
9D01E0C4  00021083   SRA V0, V0, 2
608:                 }
609:                 
610:                 
611:                 void apu_write(uint32 address, uint8 value)
612:                 {  
9D01E2F0  27BDFFE0   ADDIU SP, SP, -32
9D01E2F4  AFBF001C   SW RA, 28(SP)
9D01E2F8  AFB10018   SW S1, 24(SP)
9D01E2FC  AFB00014   SW S0, 20(SP)
613:                    int chan;
614:                 
615:                    switch (address)
9D01E2E0  2482C000   ADDIU V0, A0, -16384
9D01E2E4  2C430016   SLTIU V1, V0, 22
9D01E2E8  10600160   BEQ V1, ZERO, 0x9D01E86C
9D01E2EC  00021080   SLL V0, V0, 2
9D01E300  3C039D02   LUI V1, -25342
9D01E304  2463E318   ADDIU V1, V1, -7400
9D01E308  00621021   ADDU V0, V1, V0
9D01E30C  8C420000   LW V0, 0(V0)
9D01E310  00400008   JR V0
9D01E314  00A08021   ADDU S0, A1, ZERO
616:                    {
617:                    /* rectangles */
618:                    case APU_WRA0:
619:                    case APU_WRB0:
620:                       chan = (address & 4) >> 2;
9D01E370  7C840080   EXT A0, A0, 2, 1
621:                       apu.rectangle[chan].regs[0] = value;
9D01E374  00041100   SLL V0, A0, 4
9D01E378  00042180   SLL A0, A0, 6
9D01E37C  00442021   ADDU A0, V0, A0
9D01E380  3C02A001   LUI V0, -24575
9D01E384  244292EC   ADDIU V0, V0, -27924
9D01E388  00821021   ADDU V0, A0, V0
9D01E38C  A0450000   SB A1, 0(V0)
622:                       apu.rectangle[chan].volume = value & 0x0F;
9D01E390  30A3000F   ANDI V1, A1, 15
9D01E394  A043001C   SB V1, 28(V0)
623:                       apu.rectangle[chan].env_delay = decay_lut[value & 0x0F];
9D01E398  00031880   SLL V1, V1, 2
9D01E39C  3C04A001   LUI A0, -24575
9D01E3A0  248492AC   ADDIU A0, A0, -27988
9D01E3A4  00641821   ADDU V1, V1, A0
9D01E3A8  8C630000   LW V1, 0(V1)
9D01E3AC  AC43003C   SW V1, 60(V0)
624:                       apu.rectangle[chan].holdnote = (value & 0x20) ? true : false;
9D01E3B0  7CA30140   EXT V1, A1, 5, 1
9D01E3B4  AC430018   SW V1, 24(V0)
625:                       apu.rectangle[chan].fixed_envelope = (value & 0x10) ? true : false;
9D01E3B8  7CA30100   EXT V1, A1, 4, 1
9D01E3BC  AC430014   SW V1, 20(V0)
626:                       apu.rectangle[chan].duty_flip = duty_flip[value >> 6];
9D01E3C0  00058182   SRL S0, A1, 6
9D01E3C4  00108080   SLL S0, S0, 2
9D01E3C8  3C039D04   LUI V1, -25340
9D01E3CC  246399B4   ADDIU V1, V1, -26188
9D01E3D0  02031821   ADDU V1, S0, V1
9D01E3D4  8C630000   LW V1, 0(V1)
627:                       break;
9D01E3D8  0B407A17   J 0x9D01E85C
9D01E3DC  AC43004C   SW V1, 76(V0)
628:                 
629:                    case APU_WRA1:
630:                    case APU_WRB1:
631:                       chan = (address & 4) >> 2;
9D01E3E0  7C840080   EXT A0, A0, 2, 1
632:                       apu.rectangle[chan].regs[1] = value;
9D01E3E4  00041100   SLL V0, A0, 4
9D01E3E8  00042180   SLL A0, A0, 6
9D01E3EC  00442021   ADDU A0, V0, A0
9D01E3F0  3C02A001   LUI V0, -24575
9D01E3F4  244292EC   ADDIU V0, V0, -27924
9D01E3F8  00821021   ADDU V0, A0, V0
9D01E3FC  A0450001   SB A1, 1(V0)
633:                       apu.rectangle[chan].sweep_on = (value & 0x80) ? true : false;
9D01E400  000519C2   SRL V1, A1, 7
9D01E404  AC430028   SW V1, 40(V0)
634:                       apu.rectangle[chan].sweep_shifts = value & 7;
9D01E408  30A30007   ANDI V1, A1, 7
9D01E40C  A043002C   SB V1, 44(V0)
635:                       apu.rectangle[chan].sweep_delay = decay_lut[(value >> 4) & 7];
9D01E410  7CA51100   EXT A1, A1, 4, 3
9D01E414  00052880   SLL A1, A1, 2
9D01E418  3C04A001   LUI A0, -24575
9D01E41C  248492AC   ADDIU A0, A0, -27988
9D01E420  00A42021   ADDU A0, A1, A0
9D01E424  8C840000   LW A0, 0(A0)
9D01E428  AC440024   SW A0, 36(V0)
636:                       apu.rectangle[chan].sweep_inc = (value & 0x08) ? true : false;
9D01E42C  7E1000C0   EXT S0, S0, 3, 1
9D01E430  AC500030   SW S0, 48(V0)
637:                       apu.rectangle[chan].freq_limit = freq_limit[value & 7];
9D01E434  00031880   SLL V1, V1, 2
9D01E438  3C049D04   LUI A0, -25340
9D01E43C  24849A44   ADDIU A0, A0, -26044
9D01E440  00641821   ADDU V1, V1, A0
9D01E444  8C630000   LW V1, 0(V1)
638:                       break;
9D01E448  0B407A17   J 0x9D01E85C
9D01E44C  AC430034   SW V1, 52(V0)
639:                 
640:                    case APU_WRA2:
641:                    case APU_WRB2:
642:                       chan = (address & 4) >> 2;
9D01E450  7C840080   EXT A0, A0, 2, 1
643:                       apu.rectangle[chan].regs[2] = value;
9D01E454  00041100   SLL V0, A0, 4
9D01E458  00042180   SLL A0, A0, 6
9D01E45C  00442021   ADDU A0, V0, A0
9D01E460  3C02A001   LUI V0, -24575
9D01E464  244292EC   ADDIU V0, V0, -27924
9D01E468  00821021   ADDU V0, A0, V0
9D01E46C  A0450002   SB A1, 2(V0)
644:                       apu.rectangle[chan].freq = (apu.rectangle[chan].freq & ~0xFF) | value;
9D01E470  8C43000C   LW V1, 12(V0)
9D01E474  7C033804   INS V1, ZERO, 0, 8
9D01E478  00A38025   OR S0, A1, V1
645:                       break;
9D01E47C  0B407A17   J 0x9D01E85C
9D01E480  AC50000C   SW S0, 12(V0)
646:                 
647:                    case APU_WRA3:
648:                    case APU_WRB3:
649:                       chan = (address & 4) >> 2;
9D01E484  7C840080   EXT A0, A0, 2, 1
650:                       apu.rectangle[chan].regs[3] = value;
9D01E488  00041100   SLL V0, A0, 4
9D01E48C  00042180   SLL A0, A0, 6
9D01E490  00442021   ADDU A0, V0, A0
9D01E494  3C02A001   LUI V0, -24575
9D01E498  244292EC   ADDIU V0, V0, -27924
9D01E49C  00821021   ADDU V0, A0, V0
9D01E4A0  A0450003   SB A1, 3(V0)
651:                       apu.rectangle[chan].vbl_length = vbl_lut[value >> 3];
9D01E4A4  000520C2   SRL A0, A1, 3
9D01E4A8  00042080   SLL A0, A0, 2
9D01E4AC  3C03A001   LUI V1, -24575
9D01E4B0  2463922C   ADDIU V1, V1, -28116
9D01E4B4  00831821   ADDU V1, A0, V1
9D01E4B8  8C630000   LW V1, 0(V1)
9D01E4BC  AC430044   SW V1, 68(V0)
652:                       apu.rectangle[chan].env_vol = 0;
9D01E4C0  A0400040   SB ZERO, 64(V0)
653:                       apu.rectangle[chan].freq = ((value & 7) << 8) | (apu.rectangle[chan].freq & 0xFF);
9D01E4C4  30B00007   ANDI S0, A1, 7
9D01E4C8  00108200   SLL S0, S0, 8
9D01E4CC  9043000C   LBU V1, 12(V0)
9D01E4D0  02031825   OR V1, S0, V1
9D01E4D4  AC43000C   SW V1, 12(V0)
654:                       apu.rectangle[chan].adder = 0;
655:                       break;
9D01E4D8  0B407A17   J 0x9D01E85C
9D01E4DC  A0400048   SB ZERO, 72(V0)
656:                 
657:                    /* triangle */
658:                    case APU_WRC0:
659:                       apu.triangle.regs[0] = value;
9D01E4E0  3C02A001   LUI V0, -24575
9D01E4E4  244292EC   ADDIU V0, V0, -27924
9D01E4E8  A04500A0   SB A1, 160(V0)
660:                       apu.triangle.holdnote = (value & 0x80) ? true : false;
9D01E4EC  000519C2   SRL V1, A1, 7
9D01E4F0  AC4300B8   SW V1, 184(V0)
661:                 
662:                       if (false == apu.triangle.counter_started && apu.triangle.vbl_length)
9D01E4F4  8C4200BC   LW V0, 188(V0)
9D01E4F8  144000D8   BNE V0, ZERO, 0x9D01E85C
9D01E4FC  3C02A001   LUI V0, -24575
9D01E500  8C4293B0   LW V0, -27728(V0)
9D01E504  104000D6   BEQ V0, ZERO, 0x9D01E860
9D01E508  8FBF001C   LW RA, 28(SP)
663:                          apu.triangle.linear_length = trilength_lut[value & 0x7F];
9D01E50C  30B0007F   ANDI S0, A1, 127
9D01E510  00108080   SLL S0, S0, 2
9D01E514  3C02A001   LUI V0, -24575
9D01E518  2442902C   ADDIU V0, V0, -28628
9D01E51C  02021021   ADDU V0, S0, V0
9D01E520  8C430000   LW V1, 0(V0)
9D01E524  3C02A001   LUI V0, -24575
9D01E528  0B407A17   J 0x9D01E85C
9D01E52C  AC4393B4   SW V1, -27724(V0)
664:                 
665:                       break;
666:                 
667:                    case APU_WRC2:
668:                       apu.triangle.regs[1] = value;
9D01E530  3C02A001   LUI V0, -24575
9D01E534  244292EC   ADDIU V0, V0, -27924
9D01E538  A04500A1   SB A1, 161(V0)
669:                       apu.triangle.freq = (((apu.triangle.regs[2] & 7) << 8) + value) + 1;
9D01E53C  904300A2   LBU V1, 162(V0)
9D01E540  30630007   ANDI V1, V1, 7
9D01E544  00031A00   SLL V1, V1, 8
9D01E548  00658021   ADDU S0, V1, A1
9D01E54C  26100001   ADDIU S0, S0, 1
670:                       break;
9D01E550  0B407A17   J 0x9D01E85C
9D01E554  AC5000AC   SW S0, 172(V0)
671:                 
672:                    case APU_WRC3:
673:                 
674:                       apu.triangle.regs[2] = value;
9D01E558  3C11A001   LUI S1, -24575
9D01E55C  263192EC   ADDIU S1, S1, -27924
9D01E560  A22500A2   SB A1, 162(S1)
675:                   
676:                       /* this is somewhat of a hack.  there appears to be some latency on 
677:                       ** the Real Thing between when trireg0 is written to and when the 
678:                       ** linear length counter actually begins its countdown.  we want to 
679:                       ** prevent the case where the program writes to the freq regs first, 
680:                       ** then to reg 0, and the counter accidentally starts running because 
681:                       ** of the sound queue's timestamp processing.
682:                       **
683:                       ** set latency to a couple hundred cycles -- should be plenty of time 
684:                       ** for the 6502 code to do a couple of table dereferences and load up 
685:                       ** the other triregs
686:                       */
687:                       apu.triangle.write_latency = (int) (228 / apu.cycle_rate);
9D01E564  3C029D04   LUI V0, -25340
9D01E568  8C449A84   LW A0, -25980(V0)
9D01E56C  0F40D475   JAL __divsf3
9D01E570  8E25014C   LW A1, 332(S1)
9D01E574  0F40ECBC   JAL __fixsfsi
9D01E578  00402021   ADDU A0, V0, ZERO
9D01E57C  AE2200C0   SW V0, 192(S1)
688:                       apu.triangle.freq = (((value & 7) << 8) + apu.triangle.regs[1]) + 1;
9D01E580  32030007   ANDI V1, S0, 7
9D01E584  00031A00   SLL V1, V1, 8
9D01E588  922200A1   LBU V0, 161(S1)
9D01E58C  00621021   ADDU V0, V1, V0
9D01E590  24420001   ADDIU V0, V0, 1
9D01E594  AE2200AC   SW V0, 172(S1)
689:                       apu.triangle.vbl_length = vbl_lut[value >> 3];
9D01E598  001080C2   SRL S0, S0, 3
9D01E59C  00108080   SLL S0, S0, 2
9D01E5A0  3C02A001   LUI V0, -24575
9D01E5A4  2442922C   ADDIU V0, V0, -28116
9D01E5A8  02021021   ADDU V0, S0, V0
9D01E5AC  8C420000   LW V0, 0(V0)
9D01E5B0  AE2200C4   SW V0, 196(S1)
690:                       apu.triangle.counter_started = false;
9D01E5B4  AE2000BC   SW ZERO, 188(S1)
691:                       apu.triangle.linear_length = trilength_lut[apu.triangle.regs[0] & 0x7F];
9D01E5B8  922300A0   LBU V1, 160(S1)
9D01E5BC  3063007F   ANDI V1, V1, 127
9D01E5C0  00031880   SLL V1, V1, 2
9D01E5C4  3C02A001   LUI V0, -24575
9D01E5C8  2442902C   ADDIU V0, V0, -28628
9D01E5CC  00621021   ADDU V0, V1, V0
9D01E5D0  8C420000   LW V0, 0(V0)
692:                       break;
9D01E5D4  0B407A17   J 0x9D01E85C
9D01E5D8  AE2200C8   SW V0, 200(S1)
693:                 
694:                    /* noise */
695:                    case APU_WRD0:
696:                       apu.noise.regs[0] = value;
9D01E5DC  3C02A001   LUI V0, -24575
9D01E5E0  244292EC   ADDIU V0, V0, -27924
9D01E5E4  A04500CC   SB A1, 204(V0)
697:                       apu.noise.env_delay = decay_lut[value & 0x0F];
9D01E5E8  30A3000F   ANDI V1, A1, 15
9D01E5EC  00032880   SLL A1, V1, 2
9D01E5F0  3C04A001   LUI A0, -24575
9D01E5F4  248492AC   ADDIU A0, A0, -27988
9D01E5F8  00A42021   ADDU A0, A1, A0
9D01E5FC  8C840000   LW A0, 0(A0)
9D01E600  AC4400E4   SW A0, 228(V0)
698:                       apu.noise.holdnote = (value & 0x20) ? true : false;
9D01E604  7E040140   EXT A0, S0, 5, 1
9D01E608  AC4400F0   SW A0, 240(V0)
699:                       apu.noise.fixed_envelope = (value & 0x10) ? true : false;
9D01E60C  7E100100   EXT S0, S0, 4, 1
9D01E610  AC5000EC   SW S0, 236(V0)
700:                       apu.noise.volume = value & 0x0F;
701:                       break;
9D01E614  0B407A17   J 0x9D01E85C
9D01E618  A04300F4   SB V1, 244(V0)
702:                 
703:                    case APU_WRD2:
704:                       apu.noise.regs[1] = value;
9D01E61C  3C02A001   LUI V0, -24575
9D01E620  244292EC   ADDIU V0, V0, -27924
9D01E624  A04500CD   SB A1, 205(V0)
705:                       apu.noise.freq = noise_freq[value & 0x0F];
9D01E628  30A4000F   ANDI A0, A1, 15
9D01E62C  00042080   SLL A0, A0, 2
9D01E630  3C039D04   LUI V1, -25340
9D01E634  24639A04   ADDIU V1, V1, -26108
9D01E638  00831821   ADDU V1, A0, V1
9D01E63C  8C630000   LW V1, 0(V1)
9D01E640  AC4300D8   SW V1, 216(V0)
706:                 
707:                 #ifdef REALTIME_NOISE
708:                       apu.noise.xor_tap = (value & 0x80) ? 0x40: 0x02;
9D01E644  000581C2   SRL S0, A1, 7
9D01E648  24020040   ADDIU V0, ZERO, 64
9D01E64C  24030002   ADDIU V1, ZERO, 2
9D01E650  0070100A   MOVZ V0, V1, S0
9D01E654  00408021   ADDU S0, V0, ZERO
9D01E658  3C02A001   LUI V0, -24575
709:                 #else /* !REALTIME_NOISE */
710:                       /* detect transition from long->short sample */
711:                       if ((value & 0x80) && false == apu.noise.short_sample)
712:                       {
713:                          /* recalculate short noise buffer */
714:                          shift_register15(noise_short_lut, APU_NOISE_93);
715:                          apu.noise.cur_pos = 0;
716:                       }
717:                       apu.noise.short_sample = (value & 0x80) ? true : false;
718:                 #endif /* !REALTIME_NOISE */
719:                       break;
9D01E65C  0B407A17   J 0x9D01E85C
9D01E660  A05093E8   SB S0, -27672(V0)
720:                 
721:                    case APU_WRD3:
722:                       apu.noise.regs[2] = value;
9D01E664  3C02A001   LUI V0, -24575
9D01E668  244292EC   ADDIU V0, V0, -27924
9D01E66C  A04500CE   SB A1, 206(V0)
723:                       apu.noise.vbl_length = vbl_lut[value >> 3];
9D01E670  000580C2   SRL S0, A1, 3
9D01E674  00108080   SLL S0, S0, 2
9D01E678  3C03A001   LUI V1, -24575
9D01E67C  2463922C   ADDIU V1, V1, -28116
9D01E680  02031821   ADDU V1, S0, V1
9D01E684  8C630000   LW V1, 0(V1)
9D01E688  AC4300F8   SW V1, 248(V0)
724:                       apu.noise.env_vol = 0; /* reset envelope */
725:                       break;
9D01E68C  0B407A17   J 0x9D01E85C
9D01E690  A04000E8   SB ZERO, 232(V0)
726:                 
727:                    /* DMC */
728:                    case APU_WRE0:
729:                       apu.dmc.regs[0] = value;
9D01E694  3C02A001   LUI V0, -24575
9D01E698  244292EC   ADDIU V0, V0, -27924
9D01E69C  A0450100   SB A1, 256(V0)
730:                       apu.dmc.freq = dmc_clocks[value & 0x0F];
9D01E6A0  30A4000F   ANDI A0, A1, 15
9D01E6A4  00042080   SLL A0, A0, 2
9D01E6A8  3C039D04   LUI V1, -25340
9D01E6AC  246399C4   ADDIU V1, V1, -26172
9D01E6B0  00831821   ADDU V1, A0, V1
9D01E6B4  8C630000   LW V1, 0(V1)
9D01E6B8  AC43010C   SW V1, 268(V0)
731:                       apu.dmc.looping = (value & 0x40) ? true : false;
9D01E6BC  7CA30180   EXT V1, A1, 6, 1
732:                 
733:                       if (value & 0x80)
9D01E6C0  7C058420   SEB S0, A1
9D01E6C4  06010005   BGEZ S0, 0x9D01E6DC
9D01E6C8  AC430128   SW V1, 296(V0)
734:                       {
735:                          apu.dmc.irq_gen = true;
9D01E6CC  24030001   ADDIU V1, ZERO, 1
9D01E6D0  3C02A001   LUI V0, -24575
9D01E6D4  0B407A17   J 0x9D01E85C
9D01E6D8  AC439418   SW V1, -27624(V0)
736:                       }
737:                       else
738:                       {
739:                          apu.dmc.irq_gen = false;
9D01E6DC  3C02A001   LUI V0, -24575
9D01E6E0  244292EC   ADDIU V0, V0, -27924
9D01E6E4  AC40012C   SW ZERO, 300(V0)
740:                          apu.dmc.irq_occurred = false;
9D01E6E8  0B407A17   J 0x9D01E85C
9D01E6EC  AC400130   SW ZERO, 304(V0)
741:                       }
742:                       break;
743:                 
744:                    case APU_WRE1: /* 7-bit DAC */
745:                       /* add the _delta_ between written value and
746:                       ** current output level of the volume reg
747:                       */
748:                       value &= 0x7F; /* bit 7 ignored */
9D01E6F0  30B0007F   ANDI S0, A1, 127
749:                       apu.dmc.output_vol += ((value - apu.dmc.regs[1]) << 8);
9D01E6F4  3C02A001   LUI V0, -24575
9D01E6F8  244292EC   ADDIU V0, V0, -27924
9D01E6FC  90430101   LBU V1, 257(V0)
9D01E700  02031823   SUBU V1, S0, V1
9D01E704  00031A00   SLL V1, V1, 8
9D01E708  8C440110   LW A0, 272(V0)
9D01E70C  00831821   ADDU V1, A0, V1
9D01E710  AC430110   SW V1, 272(V0)
750:                       apu.dmc.regs[1] = value;
751:                       break;
9D01E714  0B407A17   J 0x9D01E85C
9D01E718  A0500101   SB S0, 257(V0)
752:                 
753:                    case APU_WRE2:
754:                       apu.dmc.regs[2] = value;
9D01E71C  3C02A001   LUI V0, -24575
9D01E720  244292EC   ADDIU V0, V0, -27924
9D01E724  A0450102   SB A1, 258(V0)
755:                       apu.dmc.cached_addr = 0xC000 + (uint16) (value << 6);
9D01E728  00058180   SLL S0, A1, 6
9D01E72C  3403C000   ORI V1, ZERO, -16384
9D01E730  02038021   ADDU S0, S0, V1
756:                       break;
9D01E734  0B407A17   J 0x9D01E85C
9D01E738  AC500118   SW S0, 280(V0)
757:                 
758:                    case APU_WRE3:
759:                       apu.dmc.regs[3] = value;
9D01E73C  3C02A001   LUI V0, -24575
9D01E740  244292EC   ADDIU V0, V0, -27924
9D01E744  A0450103   SB A1, 259(V0)
760:                       apu.dmc.cached_dmalength = ((value << 4) + 1) << 3;
9D01E748  000581C0   SLL S0, A1, 7
9D01E74C  26100008   ADDIU S0, S0, 8
761:                       break;
9D01E750  0B407A17   J 0x9D01E85C
9D01E754  AC500120   SW S0, 288(V0)
762:                 
763:                    case APU_SMASK:
764:                       /* bodge for timestamp queue */
765:                       apu.dmc.enabled = (value & 0x10) ? true : false;
9D01E758  7CA20100   EXT V0, A1, 4, 1
9D01E75C  3C03A001   LUI V1, -24575
9D01E760  246392EC   ADDIU V1, V1, -27924
9D01E764  AC620104   SW V0, 260(V1)
766:                       apu.enable_reg = value;
9D01E768  A0650134   SB A1, 308(V1)
767:                 
768:                       for (chan = 0; chan < 2; chan++)
769:                       {
770:                          if (value & (1 << chan))
9D01E76C  30A30001   ANDI V1, A1, 1
9D01E770  14600006   BNE V1, ZERO, 0x9D01E78C
9D01E774  24040001   ADDIU A0, ZERO, 1
9D01E794  7E030040   EXT V1, S0, 1, 1
9D01E798  10600005   BEQ V1, ZERO, 0x9D01E7B0
9D01E79C  3C03A001   LUI V1, -24575
771:                          {
772:                             apu.rectangle[chan].enabled = true;
9D01E78C  3C03A001   LUI V1, -24575
9D01E790  AC6492F0   SW A0, -27920(V1)
9D01E7A0  24040001   ADDIU A0, ZERO, 1
9D01E7A4  3C03A001   LUI V1, -24575
9D01E7A8  0B4079EF   J 0x9D01E7BC
9D01E7AC  AC649340   SW A0, -27840(V1)
773:                          }
774:                          else
775:                          {
776:                             apu.rectangle[chan].enabled = false;
9D01E778  3C03A001   LUI V1, -24575
9D01E77C  246392EC   ADDIU V1, V1, -27924
9D01E780  AC600004   SW ZERO, 4(V1)
9D01E7B0  246392EC   ADDIU V1, V1, -27924
9D01E7B4  AC600054   SW ZERO, 84(V1)
777:                             apu.rectangle[chan].vbl_length = 0;
9D01E784  0B4079E5   J 0x9D01E794
9D01E788  AC600044   SW ZERO, 68(V1)
9D01E7B8  AC600094   SW ZERO, 148(V1)
778:                          }
779:                       }
780:                 
781:                       if (value & 0x04)
9D01E7BC  32030004   ANDI V1, S0, 4
9D01E7C0  306300FF   ANDI V1, V1, 255
9D01E7C4  10600005   BEQ V1, ZERO, 0x9D01E7DC
9D01E7C8  3C03A001   LUI V1, -24575
782:                       {
783:                          apu.triangle.enabled = true;
9D01E7CC  24040001   ADDIU A0, ZERO, 1
9D01E7D0  3C03A001   LUI V1, -24575
9D01E7D4  0B4079FD   J 0x9D01E7F4
9D01E7D8  AC649390   SW A0, -27760(V1)
784:                       }
785:                       else
786:                       {
787:                          apu.triangle.enabled = false;
9D01E7DC  246392EC   ADDIU V1, V1, -27924
9D01E7E0  AC6000A4   SW ZERO, 164(V1)
788:                          apu.triangle.vbl_length = 0;
9D01E7E4  AC6000C4   SW ZERO, 196(V1)
789:                          apu.triangle.linear_length = 0;
9D01E7E8  AC6000C8   SW ZERO, 200(V1)
790:                          apu.triangle.counter_started = false;
9D01E7EC  AC6000BC   SW ZERO, 188(V1)
791:                          apu.triangle.write_latency = 0;
9D01E7F0  AC6000C0   SW ZERO, 192(V1)
792:                       }
793:                 
794:                       if (value & 0x08)
9D01E7F4  32100008   ANDI S0, S0, 8
9D01E7F8  321000FF   ANDI S0, S0, 255
9D01E7FC  12000005   BEQ S0, ZERO, 0x9D01E814
9D01E800  3C03A001   LUI V1, -24575
795:                       {
796:                          apu.noise.enabled = true;
9D01E804  24040001   ADDIU A0, ZERO, 1
9D01E808  3C03A001   LUI V1, -24575
9D01E80C  0B407A08   J 0x9D01E820
9D01E810  AC6493BC   SW A0, -27716(V1)
797:                       }
798:                       else
799:                       {
800:                          apu.noise.enabled = false;
9D01E814  246392EC   ADDIU V1, V1, -27924
9D01E818  AC6000D0   SW ZERO, 208(V1)
801:                          apu.noise.vbl_length = 0;
9D01E81C  AC6000F8   SW ZERO, 248(V1)
802:                       }
803:                 
804:                       if (value & 0x10)
9D01E820  1040000B   BEQ V0, ZERO, 0x9D01E850
9D01E824  3C02A001   LUI V0, -24575
805:                       {
806:                          if (0 == apu.dmc.dma_length)
9D01E828  8C429408   LW V0, -27640(V0)
9D01E82C  1440000A   BNE V0, ZERO, 0x9D01E858
9D01E830  3C02A001   LUI V0, -24575
807:                             apu_dmcreload();
808:                       }
809:                       else
810:                       {
811:                          apu.dmc.dma_length = 0;
9D01E850  AC409408   SW ZERO, -27640(V0)
812:                       }
813:                 
814:                       apu.dmc.irq_occurred = false;
9D01E854  3C02A001   LUI V0, -24575
9D01E858  AC40941C   SW ZERO, -27620(V0)
815:                       break;
816:                 
817:                       /* unused, but they get hit in some mem-clear loops */
818:                    case 0x4009:
819:                    case 0x400D:
820:                       break;
821:                    
822:                    default:
823:                       break;
824:                    }
825:                 }
9D01E85C  8FBF001C   LW RA, 28(SP)
9D01E860  8FB10018   LW S1, 24(SP)
9D01E864  8FB00014   LW S0, 20(SP)
9D01E868  27BD0020   ADDIU SP, SP, 32
9D01E86C  03E00008   JR RA
9D01E870  00000000   NOP
826:                 
827:                 /* Read from $4000-$4017 */
828:                 uint8 apu_read(uint32 address)
829:                 {
9D01E874  27BDFFE8   ADDIU SP, SP, -24
9D01E878  AFBF0014   SW RA, 20(SP)
9D01E87C  AFB00010   SW S0, 16(SP)
830:                    uint8 value;
831:                 
832:                    switch (address)
9D01E880  24024015   ADDIU V0, ZERO, 16405
9D01E884  14820031   BNE A0, V0, 0x9D01E94C
9D01E888  7C903A00   EXT S0, A0, 8, 8
833:                    {
834:                    case APU_SMASK:
835:                       value = 0;
9D01E8A4  0010802B   SLTU S0, ZERO, S0
836:                       /* Return 1 in 0-5 bit pos if a channel is playing */
837:                       if (apu.rectangle[0].enabled && apu.rectangle[0].vbl_length)
9D01E88C  3C02A001   LUI V0, -24575
9D01E890  8C4292F0   LW V0, -27920(V0)
9D01E894  10400004   BEQ V0, ZERO, 0x9D01E8A8
9D01E898  00008021   ADDU S0, ZERO, ZERO
9D01E89C  3C02A001   LUI V0, -24575
9D01E8A0  8C509330   LW S0, -27856(V0)
838:                          value |= 0x01;
839:                       if (apu.rectangle[1].enabled && apu.rectangle[1].vbl_length)
9D01E8A8  3C02A001   LUI V0, -24575
9D01E8AC  8C429340   LW V0, -27840(V0)
9D01E8B0  10400006   BEQ V0, ZERO, 0x9D01E8CC
9D01E8B4  3C02A001   LUI V0, -24575
9D01E8B8  3C02A001   LUI V0, -24575
9D01E8BC  8C439380   LW V1, -27776(V0)
840:                          value |= 0x02;
9D01E8C0  36020002   ORI V0, S0, 2
9D01E8C4  0043800B   MOVN S0, V0, V1
841:                       if (apu.triangle.enabled && apu.triangle.vbl_length)
9D01E8C8  3C02A001   LUI V0, -24575
9D01E8CC  8C429390   LW V0, -27760(V0)
9D01E8D0  10400006   BEQ V0, ZERO, 0x9D01E8EC
9D01E8D4  3C02A001   LUI V0, -24575
9D01E8D8  3C02A001   LUI V0, -24575
9D01E8DC  8C4393B0   LW V1, -27728(V0)
842:                          value |= 0x04;
9D01E8E0  36020004   ORI V0, S0, 4
9D01E8E4  0043800B   MOVN S0, V0, V1
843:                       if (apu.noise.enabled && apu.noise.vbl_length)
9D01E8E8  3C02A001   LUI V0, -24575
9D01E8EC  8C4293BC   LW V0, -27716(V0)
9D01E8F0  10400006   BEQ V0, ZERO, 0x9D01E90C
9D01E8F4  3C02A001   LUI V0, -24575
9D01E8F8  3C02A001   LUI V0, -24575
9D01E8FC  8C4393E4   LW V1, -27676(V0)
844:                          value |= 0x08;
9D01E900  36020008   ORI V0, S0, 8
9D01E904  0043800B   MOVN S0, V0, V1
845:                 
846:                       /* bodge for timestamp queue */
847:                       if (apu.dmc.enabled)
9D01E908  3C02A001   LUI V0, -24575
9D01E90C  8C4393F0   LW V1, -27664(V0)
848:                          value |= 0x10;
9D01E910  36020010   ORI V0, S0, 16
9D01E914  0043800B   MOVN S0, V0, V1
849:                 
850:                       if (apu.dmc.irq_occurred)
9D01E918  3C02A001   LUI V0, -24575
9D01E91C  8C43941C   LW V1, -27620(V0)
851:                          value |= 0x80;
9D01E920  36020080   ORI V0, S0, 128
9D01E924  0043800B   MOVN S0, V0, V1
852:                 
853:                       if (apu.irqclear_callback)
9D01E928  3C02A001   LUI V0, -24575
9D01E92C  8C429450   LW V0, -27568(V0)
9D01E930  50400007   BEQL V0, ZERO, 0x9D01E950
9D01E934  02001021   ADDU V0, S0, ZERO
854:                          value |= apu.irqclear_callback();
9D01E938  0040F809   JALR V0
9D01E93C  00000000   NOP
9D01E940  00501025   OR V0, V0, S0
9D01E944  0B407A53   J 0x9D01E94C
9D01E948  305000FF   ANDI S0, V0, 255
855:                 
856:                       break;
857:                 
858:                    default:
859:                       value = (address >> 8); /* heavy capacitance on data bus */
860:                       break;
861:                    }
862:                 
863:                    return value;
864:                 }
9D01E94C  02001021   ADDU V0, S0, ZERO
9D01E950  8FBF0014   LW RA, 20(SP)
9D01E954  8FB00010   LW S0, 16(SP)
9D01E958  03E00008   JR RA
9D01E95C  27BD0018   ADDIU SP, SP, 24
865:                 
866:                 #define CLIP_OUTPUT16(out) \
867:                 { \
868:                    /*out <<= 1;*/ \
869:                    if (out > 0x7FFF) \
870:                       out = 0x7FFF; \
871:                    else if (out < -0x8000) \
872:                       out = -0x8000; \
873:                 }
874:                 
875:                 void apu_process(void *buffer, int num_samples)
876:                 {
9D01D6C0  27BDFFB0   ADDIU SP, SP, -80
9D01D6C4  AFBF004C   SW RA, 76(SP)
9D01D6C8  AFBE0048   SW FP, 72(SP)
9D01D6CC  AFB70044   SW S7, 68(SP)
9D01D6D0  AFB60040   SW S6, 64(SP)
9D01D6D4  AFB5003C   SW S5, 60(SP)
9D01D6D8  AFB40038   SW S4, 56(SP)
9D01D6DC  AFB30034   SW S3, 52(SP)
9D01D6E0  AFB20030   SW S2, 48(SP)
9D01D6E4  AFB1002C   SW S1, 44(SP)
9D01D6E8  AFB00028   SW S0, 40(SP)
877:                    static int32 prev_sample = 0;
878:                 
879:                    int16 *buf16;
880:                    uint8 *buf8;
881:                 
882:                    if (NULL != buffer)
9D01D6EC  108002B4   BEQ A0, ZERO, 0x9D01E1C0
9D01D6F0  AFA40050   SW A0, 80(SP)
883:                    {
884:                       /* bleh */
885:                       apu.buffer = buffer;
9D01D6F4  3C02A001   LUI V0, -24575
9D01D6F8  AC449424   SW A0, -27612(V0)
9D01D6FC  00A09821   ADDU S3, A1, ZERO
886:                 
887:                       buf16 = (int16 *) buffer;
888:                       buf8 = (uint8 *) buffer;
9D01D700  0080A821   ADDU S5, A0, ZERO
889:                 
890:                       while (num_samples--)
9D01D70C  0B407866   J 0x9D01E198
9D01D710  24140007   ADDIU S4, ZERO, 7
9D01E198  1660FD5E   BNE S3, ZERO, 0x9D01D714
9D01E19C  260292EC   ADDIU V0, S0, -27924
9D01E1A0  0B407871   J 0x9D01E1C4
9D01E1A4  8FBF004C   LW RA, 76(SP)
891:                       {
892:                          int32 next_sample, accum = 0;
893:                 
894:                          if (apu.mix_enable & 0x01)
9D01D704  3C10A001   LUI S0, -24575
9D01D714  90520140   LBU S2, 320(V0)
9D01D718  32420001   ANDI V0, S2, 1
9D01D71C  1040008E   BEQ V0, ZERO, 0x9D01D958
9D01D720  00008821   ADDU S1, ZERO, ZERO
895:                             accum += apu_rectangle_0();
896:                          if (apu.mix_enable & 0x02)
9D01D958  32420002   ANDI V0, S2, 2
9D01D95C  304200FF   ANDI V0, V0, 255
9D01D960  10400093   BEQ V0, ZERO, 0x9D01DBB0
9D01D964  32420004   ANDI V0, S2, 4
897:                             accum += apu_rectangle_1();
9D01DBA8  02238821   ADDU S1, S1, V1
898:                          if (apu.mix_enable & 0x04)
9D01DBAC  32420004   ANDI V0, S2, 4
9D01DBB0  304200FF   ANDI V0, V0, 255
9D01DBB4  10400058   BEQ V0, ZERO, 0x9D01DD18
9D01DBB8  32420008   ANDI V0, S2, 8
899:                             accum += apu_triangle();
9D01DD10  02238821   ADDU S1, S1, V1
900:                          if (apu.mix_enable & 0x08)
9D01DD14  32420008   ANDI V0, S2, 8
9D01DD18  304200FF   ANDI V0, V0, 255
9D01DD1C  50400080   BEQL V0, ZERO, 0x9D01DF20
9D01DD20  32520010   ANDI S2, S2, 16
901:                             accum += apu_noise();
9D01DF18  02378821   ADDU S1, S1, S7
902:                          if (apu.mix_enable & 0x10)
9D01DF1C  32520010   ANDI S2, S2, 16
9D01DF20  325200FF   ANDI S2, S2, 255
9D01DF24  1240006A   BEQ S2, ZERO, 0x9D01E0D0
9D01DF28  260292EC   ADDIU V0, S0, -27924
903:                             accum += apu_dmc();
9D01E0C8  02228821   ADDU S1, S1, V0
904:                          if (apu.ext && (apu.mix_enable & 0x20))
9D01E0CC  260292EC   ADDIU V0, S0, -27924
9D01E0D0  8C420168   LW V0, 360(V0)
9D01E0D4  1040000A   BEQ V0, ZERO, 0x9D01E100
9D01E0D8  260392EC   ADDIU V1, S0, -27924
9D01E0DC  90630140   LBU V1, 320(V1)
9D01E0E0  30630020   ANDI V1, V1, 32
9D01E0E4  306300FF   ANDI V1, V1, 255
9D01E0E8  50600006   BEQL V1, ZERO, 0x9D01E104
9D01E0EC  260292EC   ADDIU V0, S0, -27924
905:                             accum += apu.ext->process();
9D01E0F0  8C42000C   LW V0, 12(V0)
9D01E0F4  0040F809   JALR V0
9D01E0F8  00000000   NOP
9D01E0FC  02228821   ADDU S1, S1, V0
906:                 
907:                          /* do any filtering */
908:                          if (APU_FILTER_NONE != apu.filter_type)
9D01E100  260292EC   ADDIU V0, S0, -27924
9D01E104  8C420144   LW V0, 324(V0)
9D01E108  1040000E   BEQ V0, ZERO, 0x9D01E144
9D01E10C  2A238000   SLTI V1, S1, -32768
909:                          {
910:                             next_sample = accum;
911:                 
912:                             if (APU_FILTER_LOWPASS == apu.filter_type)
9D01E110  54560005   BNEL V0, S6, 0x9D01E128
9D01E114  00111040   SLL V0, S1, 1
913:                             {
914:                                accum += prev_sample;
9D01E118  8F82811C   LW V0, -32484(GP)
9D01E11C  02221021   ADDU V0, S1, V0
9D01E120  0B40784E   J 0x9D01E138
9D01E124  00021043   SRA V0, V0, 1
915:                                accum >>= 1;
916:                             }
917:                             else
918:                                accum = (accum + accum + accum + prev_sample) >> 2;
9D01E128  00511021   ADDU V0, V0, S1
9D01E12C  8F83811C   LW V1, -32484(GP)
9D01E130  00431021   ADDU V0, V0, V1
9D01E134  00021083   SRA V0, V0, 2
919:                 
920:                             prev_sample = next_sample;
9D01E138  AF91811C   SW S1, -32484(GP)
9D01E13C  00408821   ADDU S1, V0, ZERO
9D01E140  2A238000   SLTI V1, S1, -32768
9D01E144  24028000   ADDIU V0, ZERO, -32768
9D01E148  0043880B   MOVN S1, V0, V1
9D01E14C  34028000   ORI V0, ZERO, -32768
9D01E150  0222182A   SLT V1, S1, V0
9D01E154  24027FFF   ADDIU V0, ZERO, 32767
9D01E158  0043880A   MOVZ S1, V0, V1
921:                          }
922:                 
923:                          /* do clipping */
924:                          CLIP_OUTPUT16(accum);
925:                 
926:                          /* signed 16-bit output, unsigned 8-bit */
927:                          if (16 == apu.sample_bits)
9D01E15C  260292EC   ADDIU V0, S0, -27924
9D01E160  8C430154   LW V1, 340(V0)
9D01E164  24020010   ADDIU V0, ZERO, 16
9D01E168  54620006   BNEL V1, V0, 0x9D01E184
9D01E16C  00118A03   SRA S1, S1, 8
928:                             *buf16++ = (int16) accum;
9D01E170  8FA30050   LW V1, 80(SP)
9D01E174  A4710000   SH S1, 0(V1)
9D01E178  24630002   ADDIU V1, V1, 2
9D01E17C  0B407865   J 0x9D01E194
9D01E180  AFA30050   SW V1, 80(SP)
929:                          else
930:                             *buf8++ = (accum >> 8) ^ 0x80;
9D01E184  2402FF80   ADDIU V0, ZERO, -128
9D01E188  02228826   XOR S1, S1, V0
9D01E18C  A2B10000   SB S1, 0(S5)
9D01E190  26B50001   ADDIU S5, S5, 1
9D01E194  2673FFFF   ADDIU S3, S3, -1
931:                       }
932:                    }
933:                 }
9D01E1C0  8FBF004C   LW RA, 76(SP)
9D01E1C4  8FBE0048   LW FP, 72(SP)
9D01E1C8  8FB70044   LW S7, 68(SP)
9D01E1CC  8FB60040   LW S6, 64(SP)
9D01E1D0  8FB5003C   LW S5, 60(SP)
9D01E1D4  8FB40038   LW S4, 56(SP)
9D01E1D8  8FB30034   LW S3, 52(SP)
9D01E1DC  8FB20030   LW S2, 48(SP)
9D01E1E0  8FB1002C   LW S1, 44(SP)
9D01E1E4  8FB00028   LW S0, 40(SP)
9D01E1E8  03E00008   JR RA
9D01E1EC  27BD0050   ADDIU SP, SP, 80
934:                 
935:                 /* set the filter type */
936:                 void apu_setfilter(int filter_type)
937:                 {
938:                    apu.filter_type = filter_type;
9D01E960  3C02A001   LUI V0, -24575
9D01E964  03E00008   JR RA
9D01E968  AC449430   SW A0, -27600(V0)
9D01EC18  24030002   ADDIU V1, ZERO, 2
9D01EC1C  3C02A001   LUI V0, -24575
9D01EC20  AC439430   SW V1, -27600(V0)
939:                 }
940:                 
941:                 void apu_reset(void)
942:                 {
9D01E96C  27BDFFE0   ADDIU SP, SP, -32
9D01E970  AFBF001C   SW RA, 28(SP)
9D01E974  AFB10018   SW S1, 24(SP)
9D01E978  AFB00014   SW S0, 20(SP)
943:                    uint32 address;
944:                 
945:                    /* initialize all channel members */
946:                    for (address = 0x4000; address <= 0x4013; address++)
9D01E97C  24104000   ADDIU S0, ZERO, 16384
9D01E980  24114014   ADDIU S1, ZERO, 16404
9D01E990  26100001   ADDIU S0, S0, 1
9D01E994  1611FFFC   BNE S0, S1, 0x9D01E988
9D01E998  02002021   ADDU A0, S0, ZERO
947:                       apu_write(address, 0);
9D01E984  02002021   ADDU A0, S0, ZERO
9D01E988  0F4078B8   JAL apu_write
9D01E98C  00002821   ADDU A1, ZERO, ZERO
948:                 
949:                    apu_write(0x4015, 0);
9D01E99C  24044015   ADDIU A0, ZERO, 16405
9D01E9A0  0F4078B8   JAL apu_write
9D01E9A4  00002821   ADDU A1, ZERO, ZERO
950:                 
951:                    if (apu.ext && NULL != apu.ext->reset)
9D01E9A8  3C02A001   LUI V0, -24575
9D01E9AC  8C429454   LW V0, -27564(V0)
9D01E9B0  10400007   BEQ V0, ZERO, 0x9D01E9D0
9D01E9B4  8FBF001C   LW RA, 28(SP)
9D01E9B8  8C420008   LW V0, 8(V0)
9D01E9BC  10400005   BEQ V0, ZERO, 0x9D01E9D4
9D01E9C0  8FB10018   LW S1, 24(SP)
952:                       apu.ext->reset();
9D01E9C4  0040F809   JALR V0
9D01E9C8  00000000   NOP
953:                 }
9D01E9CC  8FBF001C   LW RA, 28(SP)
9D01E9D0  8FB10018   LW S1, 24(SP)
9D01E9D4  8FB00014   LW S0, 20(SP)
9D01E9D8  03E00008   JR RA
9D01E9DC  27BD0020   ADDIU SP, SP, 32
954:                 
955:                 void apu_build_luts(int num_samples)
956:                 {
9D01E9E0  27BDFFD0   ADDIU SP, SP, -48
9D01E9E4  AFBF002C   SW RA, 44(SP)
9D01E9E8  AFB50028   SW S5, 40(SP)
9D01E9EC  AFB40024   SW S4, 36(SP)
9D01E9F0  AFB30020   SW S3, 32(SP)
9D01E9F4  AFB2001C   SW S2, 28(SP)
9D01E9F8  AFB10018   SW S1, 24(SP)
9D01E9FC  AFB00014   SW S0, 20(SP)
9D01EA00  00809821   ADDU S3, A0, ZERO
9D01EA04  00802821   ADDU A1, A0, ZERO
9D01EA08  3C02A001   LUI V0, -24575
9D01EA0C  244292AC   ADDIU V0, V0, -27988
9D01EA10  24440040   ADDIU A0, V0, 64
9D01EA14  02601821   ADDU V1, S3, ZERO
957:                    int i;
958:                 
959:                    /* lut used for enveloping and frequency sweeps */
960:                    for (i = 0; i < 16; i++)
9D01EA20  1444FFFD   BNE V0, A0, 0x9D01EA18
9D01EA24  00651821   ADDU V1, V1, A1
9D01EA28  3C029D04   LUI V0, -25340
9D01EA2C  24429A64   ADDIU V0, V0, -26012
9D01EA30  3C03A001   LUI V1, -24575
9D01EA34  2463922C   ADDIU V1, V1, -28116
9D01EA38  24450020   ADDIU A1, V0, 32
961:                       decay_lut[i] = num_samples * (i + 1);
9D01EA18  AC430000   SW V1, 0(V0)
9D01EA1C  24420004   ADDIU V0, V0, 4
962:                 
963:                    /* used for note length, based on vblanks and size of audio buffer */
964:                    for (i = 0; i < 32; i++)
9D01EA4C  1445FFFB   BNE V0, A1, 0x9D01EA3C
9D01EA50  24630004   ADDIU V1, V1, 4
9D01EA54  3C11A001   LUI S1, -24575
9D01EA58  2631902C   ADDIU S1, S1, -28628
9D01EA5C  00008021   ADDU S0, ZERO, ZERO
965:                       vbl_lut[i] = vbl_length[i] * num_samples;
9D01EA3C  90440000   LBU A0, 0(V0)
9D01EA40  70932002   MUL A0, A0, S3
9D01EA44  AC640000   SW A0, 0(V1)
9D01EA48  24420001   ADDIU V0, V0, 1
966:                 
967:                    /* triangle wave channel's linear length table */
968:                    for (i = 0; i < 128; i++)
9D01EA68  24140080   ADDIU S4, ZERO, 128
9D01EAA4  26100001   ADDIU S0, S0, 1
9D01EAA8  1614FFF0   BNE S0, S4, 0x9D01EA6C
9D01EAAC  26310004   ADDIU S1, S1, 4
969:                       trilength_lut[i] = (int) (0.25 * i * num_samples);
9D01EA60  3C029D04   LUI V0, -25340
9D01EA64  8C559A88   LW S5, -25976(V0)
9D01EA6C  0F40EEE7   JAL sitofp
9D01EA70  02002021   ADDU A0, S0, ZERO
9D01EA74  00402021   ADDU A0, V0, ZERO
9D01EA78  0F40D795   JAL __mulsf3
9D01EA7C  02A02821   ADDU A1, S5, ZERO
9D01EA80  00409021   ADDU S2, V0, ZERO
9D01EA84  0F40EEE7   JAL sitofp
9D01EA88  02602021   ADDU A0, S3, ZERO
9D01EA8C  02402021   ADDU A0, S2, ZERO
9D01EA90  0F40D795   JAL __mulsf3
9D01EA94  00402821   ADDU A1, V0, ZERO
9D01EA98  0F40ECBC   JAL __fixsfsi
9D01EA9C  00402021   ADDU A0, V0, ZERO
9D01EAA0  AE220000   SW V0, 0(S1)
970:                 
971:                 #ifndef REALTIME_NOISE
972:                    /* generate noise samples */
973:                    shift_register15(noise_long_lut, APU_NOISE_32K);
974:                    shift_register15(noise_short_lut, APU_NOISE_93);
975:                 #endif /* !REALTIME_NOISE */
976:                 }
9D01EAB0  8FBF002C   LW RA, 44(SP)
9D01EAB4  8FB50028   LW S5, 40(SP)
9D01EAB8  8FB40024   LW S4, 36(SP)
9D01EABC  8FB30020   LW S3, 32(SP)
9D01EAC0  8FB2001C   LW S2, 28(SP)
9D01EAC4  8FB10018   LW S1, 24(SP)
9D01EAC8  8FB00014   LW S0, 20(SP)
9D01EACC  03E00008   JR RA
9D01EAD0  27BD0030   ADDIU SP, SP, 48
977:                 
978:                 void apu_setparams(double base_freq, int sample_rate, int refresh_rate, int sample_bits)
979:                 {
9D01EAD4  27BDFFE0   ADDIU SP, SP, -32
9D01EAD8  AFBF001C   SW RA, 28(SP)
9D01EADC  AFB20018   SW S2, 24(SP)
9D01EAE0  AFB10014   SW S1, 20(SP)
9D01EAE4  AFB00010   SW S0, 16(SP)
9D01EAE8  00809021   ADDU S2, A0, ZERO
9D01EAEC  00A08021   ADDU S0, A1, ZERO
980:                    apu.sample_rate = sample_rate;
9D01EAF0  3C02A001   LUI V0, -24575
9D01EAF4  244292EC   ADDIU V0, V0, -27924
9D01EAF8  AC450150   SW A1, 336(V0)
981:                    apu.refresh_rate = refresh_rate;
9D01EAFC  AC460158   SW A2, 344(V0)
982:                    apu.sample_bits = sample_bits;
9D01EB00  AC470154   SW A3, 340(V0)
983:                    apu.num_samples = sample_rate / refresh_rate;
9D01EB04  00A6001A   DIV A1, A2
9D01EB08  00C001F4   TEQ A2, ZERO
9D01EB0C  00008812   MFLO S1
9D01EB10  AC51013C   SW S1, 316(V0)
984:                    if (0 == base_freq)
9D01EB14  0F40EB16   JAL __lesf2
9D01EB18  00002821   ADDU A1, ZERO, ZERO
9D01EB1C  14400006   BNE V0, ZERO, 0x9D01EB38
9D01EB20  3C02A001   LUI V0, -24575
985:                       apu.base_freq = APU_BASEFREQ;
9D01EB24  3C029D04   LUI V0, -25340
9D01EB28  8C439A8C   LW V1, -25972(V0)
9D01EB2C  3C02A001   LUI V0, -24575
9D01EB30  0B407ACF   J 0x9D01EB3C
9D01EB34  AC439434   SW V1, -27596(V0)
986:                    else
987:                       apu.base_freq = base_freq;
9D01EB38  AC529434   SW S2, -27596(V0)
988:                    apu.cycle_rate = (float) (apu.base_freq / sample_rate);
9D01EB3C  3C12A001   LUI S2, -24575
9D01EB40  265292EC   ADDIU S2, S2, -27924
9D01EB44  0F40EEE7   JAL sitofp
9D01EB48  02002021   ADDU A0, S0, ZERO
9D01EB4C  8E440148   LW A0, 328(S2)
9D01EB50  0F40D475   JAL __divsf3
9D01EB54  00402821   ADDU A1, V0, ZERO
9D01EB58  AE42014C   SW V0, 332(S2)
989:                 
990:                    /* build various lookup tables for apu */
991:                    apu_build_luts(apu.num_samples);
9D01EB5C  0F407A78   JAL apu_build_luts
9D01EB60  02202021   ADDU A0, S1, ZERO
992:                 
993:                    apu_reset();
9D01EB64  0F407A5B   JAL apu_reset
9D01EB68  00000000   NOP
994:                 }
9D01EB6C  8FBF001C   LW RA, 28(SP)
9D01EB70  8FB20018   LW S2, 24(SP)
9D01EB74  8FB10014   LW S1, 20(SP)
9D01EB78  8FB00010   LW S0, 16(SP)
9D01EB7C  03E00008   JR RA
9D01EB80  27BD0020   ADDIU SP, SP, 32
995:                 
996:                 /* Initializes emulated sound hardware, creates waveforms/voices */
997:                 apu_t *apu_create(double base_freq, int sample_rate, int refresh_rate, int sample_bits)
998:                 {
9D01EB84  27BDFFD8   ADDIU SP, SP, -40
9D01EB88  AFBF0024   SW RA, 36(SP)
9D01EB8C  AFB40020   SW S4, 32(SP)
9D01EB90  AFB3001C   SW S3, 28(SP)
9D01EB94  AFB20018   SW S2, 24(SP)
9D01EB98  AFB10014   SW S1, 20(SP)
9D01EB9C  AFB00010   SW S0, 16(SP)
9D01EBA0  0080A021   ADDU S4, A0, ZERO
9D01EBA4  00A09821   ADDU S3, A1, ZERO
9D01EBA8  00C09021   ADDU S2, A2, ZERO
9D01EBAC  00E08021   ADDU S0, A3, ZERO
999:                    apu_t *temp_apu;
1000:                   int channel;
1001:                
1002:                   temp_apu = malloc(sizeof(apu_t));
9D01EBB0  0F40DDB7   JAL _my_malloc
9D01EBB4  2404016C   ADDIU A0, ZERO, 364
1003:                   if (NULL == temp_apu)
9D01EBB8  1040001E   BEQ V0, ZERO, 0x9D01EC34
9D01EBBC  00408821   ADDU S1, V0, ZERO
1004:                      return NULL;
9D01EC34  00001021   ADDU V0, ZERO, ZERO
1005:                
1006:                   memset(temp_apu, 0, sizeof(apu_t));
9D01EBC0  00402021   ADDU A0, V0, ZERO
9D01EBC4  00002821   ADDU A1, ZERO, ZERO
9D01EBC8  0F40E9FC   JAL .Letext0, .LFE0, memset
9D01EBCC  2406016C   ADDIU A2, ZERO, 364
1007:                
1008:                   /* set the update routine */
1009:                   temp_apu->process = apu_process;
9D01EBD0  3C029D02   LUI V0, -25342
9D01EBD4  2442D6C0   ADDIU V0, V0, -10560
9D01EBD8  AE22015C   SW V0, 348(S1)
1010:                   temp_apu->ext = NULL;
1011:                
1012:                   /* clear the callbacks */
1013:                   temp_apu->irq_callback = NULL;
1014:                   temp_apu->irqclear_callback = NULL;
1015:                
1016:                   apu_setcontext(temp_apu);
9D01EBDC  0F40787C   JAL apu_setcontext
9D01EBE0  02202021   ADDU A0, S1, ZERO
1017:                
1018:                   apu_setparams(base_freq, sample_rate, refresh_rate, sample_bits);
9D01EBE4  02802021   ADDU A0, S4, ZERO
9D01EBE8  02602821   ADDU A1, S3, ZERO
9D01EBEC  02403021   ADDU A2, S2, ZERO
9D01EBF0  0F407AB5   JAL apu_setparams
9D01EBF4  02003821   ADDU A3, S0, ZERO
1019:                
1020:                   for (channel = 0; channel < 6; channel++)
9D01EBF8  00008021   ADDU S0, ZERO, ZERO
9D01EBFC  24120006   ADDIU S2, ZERO, 6
9D01EC0C  26100001   ADDIU S0, S0, 1
9D01EC10  1612FFFC   BNE S0, S2, 0x9D01EC04
9D01EC14  02002021   ADDU A0, S0, ZERO
1021:                      apu_setchan(channel, true);
9D01EC00  02002021   ADDU A0, S0, ZERO
9D01EC04  0F4078A7   JAL apu_setchan
9D01EC08  24050001   ADDIU A1, ZERO, 1
1022:                
1023:                   apu_setfilter(APU_FILTER_WEIGHTED);
1024:                
1025:                   apu_getcontext(temp_apu);
9D01EC24  0F407892   JAL apu_getcontext
9D01EC28  02202021   ADDU A0, S1, ZERO
1026:                
1027:                   return temp_apu;
9D01EC2C  0B407B0E   J 0x9D01EC38
9D01EC30  02201021   ADDU V0, S1, ZERO
1028:                }
9D01EC38  8FBF0024   LW RA, 36(SP)
9D01EC3C  8FB40020   LW S4, 32(SP)
9D01EC40  8FB3001C   LW S3, 28(SP)
9D01EC44  8FB20018   LW S2, 24(SP)
9D01EC48  8FB10014   LW S1, 20(SP)
9D01EC4C  8FB00010   LW S0, 16(SP)
9D01EC50  03E00008   JR RA
9D01EC54  27BD0028   ADDIU SP, SP, 40
1029:                
1030:                void apu_destroy(apu_t **src_apu)
1031:                {
9D01EC58  27BDFFE8   ADDIU SP, SP, -24
9D01EC5C  AFBF0014   SW RA, 20(SP)
9D01EC60  AFB00010   SW S0, 16(SP)
1032:                   if (*src_apu)
9D01EC64  8C820000   LW V0, 0(A0)
9D01EC68  1040000C   BEQ V0, ZERO, 0x9D01EC9C
9D01EC6C  00808021   ADDU S0, A0, ZERO
1033:                   {
1034:                      if ((*src_apu)->ext && NULL != (*src_apu)->ext->shutdown)
9D01EC70  8C420168   LW V0, 360(V0)
9D01EC74  10400006   BEQ V0, ZERO, 0x9D01EC90
9D01EC78  00000000   NOP
9D01EC7C  8C420004   LW V0, 4(V0)
9D01EC80  10400003   BEQ V0, ZERO, 0x9D01EC90
9D01EC84  00000000   NOP
1035:                         (*src_apu)->ext->shutdown();
9D01EC88  0040F809   JALR V0
9D01EC8C  00000000   NOP
1036:                      free(*src_apu);
9D01EC90  0F40DDCA   JAL _my_free
9D01EC94  02002021   ADDU A0, S0, ZERO
1037:                      *src_apu = NULL;
9D01EC98  AE000000   SW ZERO, 0(S0)
1038:                   }
1039:                }
9D01EC9C  8FBF0014   LW RA, 20(SP)
9D01ECA0  8FB00010   LW S0, 16(SP)
9D01ECA4  03E00008   JR RA
9D01ECA8  27BD0018   ADDIU SP, SP, 24
1040:                
1041:                void apu_setext(apu_t *src_apu, apuext_t *ext)
1042:                {
9D01ECC0  27BDFFE8   ADDIU SP, SP, -24
9D01ECC4  AFBF0014   SW RA, 20(SP)
1043:                   ASSERT(src_apu);
1044:                
1045:                   src_apu->ext = ext;
1046:                
1047:                   /* initialize it */
1048:                   if (src_apu->ext && NULL != src_apu->ext->init)
9D01ECAC  10A0000A   BEQ A1, ZERO, 0x9D01ECD8
9D01ECB0  AC850168   SW A1, 360(A0)
9D01ECB4  8CA20000   LW V0, 0(A1)
9D01ECB8  10400007   BEQ V0, ZERO, 0x9D01ECD8
9D01ECBC  00000000   NOP
1049:                      src_apu->ext->init();
9D01ECC8  0040F809   JALR V0
9D01ECCC  00000000   NOP
1050:                }
9D01ECD0  8FBF0014   LW RA, 20(SP)
9D01ECD4  27BD0018   ADDIU SP, SP, 24
9D01ECD8  03E00008   JR RA
9D01ECDC  00000000   NOP
1051:                
1052:                /*
1053:                ** $Log: nes_apu.c,v $
1054:                ** Revision 1.2  2001/04/27 14:37:11  neil
1055:                ** wheeee
1056:                **
1057:                ** Revision 1.1  2001/04/27 12:54:40  neil
1058:                ** blah
1059:                **
1060:                ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
1061:                ** initial
1062:                **
1063:                ** Revision 1.6  2000/12/08 02:36:14  matt
1064:                ** bye bye apu queue (for now)
1065:                **
1066:                ** Revision 1.5  2000/11/27 19:33:53  matt
1067:                ** no special treatment for nsf
1068:                **
1069:                ** Revision 1.4  2000/11/25 20:29:17  matt
1070:                ** weighted filter is now default
1071:                **
1072:                ** Revision 1.3  2000/11/21 13:28:19  matt
1073:                ** take care to zero allocated mem
1074:                **
1075:                ** Revision 1.2  2000/10/28 15:20:59  matt
1076:                ** irq callbacks in nes_apu
1077:                **
1078:                ** Revision 1.1  2000/10/24 12:19:59  matt
1079:                ** changed directory structure
1080:                **
1081:                ** Revision 1.44  2000/10/23 17:53:06  matt
1082:                ** set ptr to NULL after freeing
1083:                **
1084:                ** Revision 1.43  2000/10/17 11:56:42  matt
1085:                ** selectable apu base frequency
1086:                **
1087:                ** Revision 1.42  2000/10/13 12:16:01  matt
1088:                ** macro-ized the stuff that should be removed
1089:                **
1090:                ** Revision 1.41  2000/10/10 13:58:18  matt
1091:                ** stroustrup squeezing his way in the door
1092:                **
1093:                ** Revision 1.40  2000/10/03 11:56:20  matt
1094:                ** better support for optional sound ext routines
1095:                **
1096:                ** Revision 1.39  2000/09/27 12:26:03  matt
1097:                ** changed sound accumulators back to floats
1098:                **
1099:                ** Revision 1.38  2000/09/18 02:12:55  matt
1100:                ** more optimizations
1101:                **
1102:                ** Revision 1.37  2000/09/15 13:38:40  matt
1103:                ** changes for optimized apu core
1104:                **
1105:                ** Revision 1.36  2000/09/15 04:58:07  matt
1106:                ** simplifying and optimizing APU core
1107:                **
1108:                ** Revision 1.35  2000/09/07 21:57:14  matt
1109:                ** api change
1110:                **
1111:                ** Revision 1.34  2000/08/16 05:01:01  matt
1112:                ** small buglet fixed
1113:                **
1114:                ** Revision 1.33  2000/08/15 12:38:04  matt
1115:                ** removed debug output
1116:                **
1117:                ** Revision 1.32  2000/08/15 12:36:51  matt
1118:                ** calling apu_process with buffer=NULL causes silent emulation of APU
1119:                **
1120:                ** Revision 1.31  2000/08/11 02:27:21  matt
1121:                ** general cleanups, plus apu_setparams routine
1122:                **
1123:                ** Revision 1.30  2000/07/31 04:32:52  matt
1124:                ** fragsize problem fixed, perhaps
1125:                **
1126:                ** Revision 1.29  2000/07/30 04:32:59  matt
1127:                ** no more apu_getcyclerate hack
1128:                **
1129:                ** Revision 1.28  2000/07/28 03:15:46  matt
1130:                ** accuracy changes for rectangle frequency sweeps
1131:                **
1132:                ** Revision 1.27  2000/07/27 02:49:50  matt
1133:                ** eccentricity in sweeping hardware now emulated correctly
1134:                **
1135:                ** Revision 1.26  2000/07/25 02:25:14  matt
1136:                ** safer apu_destroy
1137:                **
1138:                ** Revision 1.25  2000/07/23 15:10:54  matt
1139:                ** hacks for win32
1140:                **
1141:                ** Revision 1.24  2000/07/17 01:52:31  matt
1142:                ** made sure last line of all source files is a newline
1143:                **
1144:                ** Revision 1.23  2000/07/10 19:24:55  matt
1145:                ** irqs are not supported in NSF playing mode
1146:                **
1147:                ** Revision 1.22  2000/07/10 13:54:32  matt
1148:                ** using generic nes_irq() now
1149:                **
1150:                ** Revision 1.21  2000/07/10 05:29:34  matt
1151:                ** moved joypad/oam dma from apu to ppu
1152:                **
1153:                ** Revision 1.20  2000/07/09 03:49:31  matt
1154:                ** apu irqs now draw an irq line (bleh)
1155:                **
1156:                ** Revision 1.19  2000/07/04 04:53:26  matt
1157:                ** minor changes, sound amplification
1158:                **
1159:                ** Revision 1.18  2000/07/03 02:18:53  matt
1160:                ** much better external module exporting
1161:                **
1162:                ** Revision 1.17  2000/06/26 11:01:55  matt
1163:                ** made triangle a tad quieter
1164:                **
1165:                ** Revision 1.16  2000/06/26 05:10:33  matt
1166:                ** fixed cycle rate generation accuracy
1167:                **
1168:                ** Revision 1.15  2000/06/26 05:00:37  matt
1169:                ** cleanups
1170:                **
1171:                ** Revision 1.14  2000/06/23 11:06:24  matt
1172:                ** more faithful mixing of channels
1173:                **
1174:                ** Revision 1.13  2000/06/23 03:29:27  matt
1175:                ** cleaned up external sound inteface
1176:                **
1177:                ** Revision 1.12  2000/06/20 00:08:39  matt
1178:                ** bugfix to rectangle wave
1179:                **
1180:                ** Revision 1.11  2000/06/13 13:48:58  matt
1181:                ** fixed triangle write latency for fixed point apu cycle rate
1182:                **
1183:                ** Revision 1.10  2000/06/12 01:14:36  matt
1184:                ** minor change to clipping extents
1185:                **
1186:                ** Revision 1.9  2000/06/09 20:00:56  matt
1187:                ** fixed noise hiccup in NSF player mode
1188:                **
1189:                ** Revision 1.8  2000/06/09 16:49:02  matt
1190:                ** removed all floating point from sound generation
1191:                **
1192:                ** Revision 1.7  2000/06/09 15:12:28  matt
1193:                ** initial revision
1194:                **
1195:                */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/sndhrdw/mmc5_snd.c  ------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** mmc5_snd.c
21:                  **
22:                  ** Nintendo MMC5 sound emulation
23:                  ** $Id: mmc5_snd.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <string.h>
27:                  #include <noftypes.h>
28:                  #include "mmc5_snd.h"
29:                  #include <nes_apu.h>
30:                  
31:                  /* TODO: encapsulate apu/mmc5 rectangle */
32:                  
33:                  #define  APU_OVERSAMPLE
34:                  #define  APU_VOLUME_DECAY(x)  ((x) -= ((x) >> 7))
35:                  
36:                  /* look up table madness */
37:                  static int32 decay_lut[16];
38:                  static int vbl_lut[32];
39:                  
40:                  /* various sound constants for sound emulation */
41:                  /* vblank length table used for rectangles, triangle, noise */
42:                  static const uint8 vbl_length[32] =
43:                  {
44:                     5, 127, 10, 1, 19,  2, 40,  3, 80,  4, 30,  5, 7,  6, 13,  7,
45:                     6,   8, 12, 9, 24, 10, 48, 11, 96, 12, 36, 13, 8, 14, 16, 15
46:                  };
47:                  
48:                  /* ratios of pos/neg pulse for rectangle waves
49:                  ** 2/16 = 12.5%, 4/16 = 25%, 8/16 = 50%, 12/16 = 75% 
50:                  ** (4-bit adder in rectangles, hence the 16)
51:                  */
52:                  static const int duty_lut[4] =
53:                  {
54:                     2, 4, 8, 12
55:                  };
56:                  
57:                  
58:                  #define  MMC5_WRA0    0x5000
59:                  #define  MMC5_WRA1    0x5001
60:                  #define  MMC5_WRA2    0x5002
61:                  #define  MMC5_WRA3    0x5003
62:                  #define  MMC5_WRB0    0x5004
63:                  #define  MMC5_WRB1    0x5005
64:                  #define  MMC5_WRB2    0x5006
65:                  #define  MMC5_WRB3    0x5007
66:                  #define  MMC5_SMASK   0x5015
67:                  
68:                  typedef struct mmc5rectangle_s
69:                  {
70:                     uint8 regs[4];
71:                  
72:                     bool enabled;
73:                     
74:                     float accum;
75:                     int32 freq;
76:                     int32 output_vol;
77:                     bool fixed_envelope;
78:                     bool holdnote;
79:                     uint8 volume;
80:                  
81:                     int32 env_phase;
82:                     int32 env_delay;
83:                     uint8 env_vol;
84:                  
85:                     int vbl_length;
86:                     uint8 adder;
87:                     int duty_flip;
88:                  } mmc5rectangle_t;
89:                  
90:                  typedef struct mmc5dac_s
91:                  {
92:                     int32 output;
93:                     bool enabled;
94:                  } mmc5dac_t;
95:                  
96:                  
97:                  static struct
98:                  {
99:                     float incsize;
100:                    uint8 mul[2];
101:                    mmc5rectangle_t rect[2];
102:                    mmc5dac_t dac;
103:                 } mmc5;
104:                 
105:                 
106:                 #define  MMC5_RECTANGLE_OUTPUT   chan->output_vol
107:                 static int32 mmc5_rectangle(mmc5rectangle_t *chan)
108:                 {
9D02D668  27BDFFC8   ADDIU SP, SP, -56
9D02D66C  AFBF0034   SW RA, 52(SP)
9D02D670  AFB70030   SW S7, 48(SP)
9D02D674  AFB6002C   SW S6, 44(SP)
9D02D678  AFB50028   SW S5, 40(SP)
9D02D67C  AFB40024   SW S4, 36(SP)
9D02D680  AFB30020   SW S3, 32(SP)
9D02D684  AFB2001C   SW S2, 28(SP)
9D02D688  AFB10018   SW S1, 24(SP)
9D02D68C  AFB00014   SW S0, 20(SP)
9D02D690  00808021   ADDU S0, A0, ZERO
109:                    int32 output;
110:                 
111:                 #ifdef APU_OVERSAMPLE
112:                    int num_times;
113:                    int32 total;
114:                 #endif /* APU_OVERSAMPLE */
115:                 
116:                    /* reg0: 0-3=volume, 4=envelope, 5=hold, 6-7=duty cycle
117:                    ** reg1: 0-2=sweep shifts, 3=sweep inc/dec, 4-6=sweep length, 7=sweep on
118:                    ** reg2: 8 bits of freq
119:                    ** reg3: 0-2=high freq, 7-4=vbl length counter
120:                    */
121:                 
122:                    APU_VOLUME_DECAY(chan->output_vol);
9D02D694  8C820010   LW V0, 16(A0)
9D02D698  000289C3   SRA S1, V0, 7
9D02D69C  00518823   SUBU S1, V0, S1
9D02D6A0  AC910010   SW S1, 16(A0)
123:                 
124:                    if (false == chan->enabled || 0 == chan->vbl_length)
9D02D6A4  8C820004   LW V0, 4(A0)
9D02D6A8  10400058   BEQ V0, ZERO, 0x9D02D80C
9D02D6AC  02201821   ADDU V1, S1, ZERO
9D02D6B0  8C82002C   LW V0, 44(A0)
9D02D6B4  50400056   BEQL V0, ZERO, 0x9D02D810
9D02D6B8  00601021   ADDU V0, V1, ZERO
125:                       return MMC5_RECTANGLE_OUTPUT;
126:                 
127:                    /* vbl length counter */
128:                    if (false == chan->holdnote)
9D02D6BC  8C840018   LW A0, 24(A0)
9D02D6C0  54800004   BNEL A0, ZERO, 0x9D02D6D4
9D02D6C4  8E020020   LW V0, 32(S0)
129:                       chan->vbl_length--;
9D02D6C8  2442FFFF   ADDIU V0, V0, -1
9D02D6CC  AE02002C   SW V0, 44(S0)
130:                 
131:                    /* envelope decay at a rate of (env_delay + 1) / 240 secs */
132:                    chan->env_phase -= 4; /* 240/60 */
9D02D6D0  8E020020   LW V0, 32(S0)
9D02D6D4  2442FFFC   ADDIU V0, V0, -4
133:                    while (chan->env_phase < 0)
9D02D6D8  0B40B5C6   J 0x9D02D718
9D02D6DC  AE020020   SW V0, 32(S0)
9D02D718  8E020020   LW V0, 32(S0)
9D02D71C  0442FFF0   BLTZL V0, 0x9D02D6E0
9D02D720  8E030024   LW V1, 36(S0)
134:                    {
135:                       chan->env_phase += chan->env_delay;
9D02D6E0  00431021   ADDU V0, V0, V1
136:                 
137:                       if (chan->holdnote)
9D02D6E4  10800006   BEQ A0, ZERO, 0x9D02D700
9D02D6E8  AE020020   SW V0, 32(S0)
138:                          chan->env_vol = (chan->env_vol + 1) & 0x0F;
9D02D6EC  92020028   LBU V0, 40(S0)
9D02D6F0  24420001   ADDIU V0, V0, 1
9D02D6F4  3042000F   ANDI V0, V0, 15
9D02D6F8  0B40B5C6   J 0x9D02D718
9D02D6FC  A2020028   SB V0, 40(S0)
139:                       else if (chan->env_vol < 0x0F)
9D02D700  92020028   LBU V0, 40(S0)
9D02D704  2C43000F   SLTIU V1, V0, 15
9D02D708  50600004   BEQL V1, ZERO, 0x9D02D71C
9D02D70C  8E020020   LW V0, 32(S0)
140:                          chan->env_vol++;
9D02D710  24420001   ADDIU V0, V0, 1
9D02D714  A2020028   SB V0, 40(S0)
141:                    }
142:                 
143:                    if (chan->freq < 4)
9D02D724  8E16000C   LW S6, 12(S0)
9D02D728  2AC20004   SLTI V0, S6, 4
9D02D72C  14400037   BNE V0, ZERO, 0x9D02D80C
9D02D730  02201821   ADDU V1, S1, ZERO
144:                       return MMC5_RECTANGLE_OUTPUT;
145:                 
146:                    chan->accum -= mmc5.incsize; /* # of cycles per sample */
9D02D734  8E040008   LW A0, 8(S0)
9D02D738  3C02A001   LUI V0, -24575
9D02D73C  0F40D22B   JAL __subsf3
9D02D740  8C45A3A8   LW A1, -23640(V0)
9D02D744  00409021   ADDU S2, V0, ZERO
9D02D748  AE020008   SW V0, 8(S0)
147:                    if (chan->accum >= 0)
9D02D74C  00002021   ADDU A0, ZERO, ZERO
9D02D750  0F40EB16   JAL __lesf2
9D02D754  00402821   ADDU A1, V0, ZERO
9D02D758  1840002C   BLEZ V0, 0x9D02D80C
9D02D75C  02201821   ADDU V1, S1, ZERO
148:                       return MMC5_RECTANGLE_OUTPUT;
149:                 
150:                 #ifdef APU_OVERSAMPLE
151:                    num_times = total = 0;
152:                 
153:                    if (chan->fixed_envelope)
9D02D760  8E020014   LW V0, 20(S0)
9D02D764  5040000B   BEQL V0, ZERO, 0x9D02D794
9D02D768  92150028   LBU S5, 40(S0)
154:                       output = chan->volume << 8; /* fixed volume */
9D02D76C  9215001C   LBU S5, 28(S0)
9D02D770  0015AA00   SLL S5, S5, 8
155:                    else
156:                       output = (chan->env_vol ^ 0x0F) << 8;
9D02D794  3AB5000F   XORI S5, S5, 15
9D02D798  0B40B5DD   J 0x9D02D774
9D02D79C  0015AA00   SLL S5, S5, 8
9D02D7A0  92130030   LBU S3, 48(S0)
157:                 #endif
158:                 
159:                    while (chan->accum < 0)
9D02D774  02402021   ADDU A0, S2, ZERO
9D02D778  0F40EB16   JAL __lesf2
9D02D77C  00002821   ADDU A1, ZERO, ZERO
9D02D780  00008821   ADDU S1, ZERO, ZERO
9D02D784  0441001D   BGEZ V0, 0x9D02D7FC
9D02D788  0000A021   ADDU S4, ZERO, ZERO
9D02D7E0  02402021   ADDU A0, S2, ZERO
9D02D7E4  0F40EB16   JAL __lesf2
9D02D7E8  00002821   ADDU A1, ZERO, ZERO
9D02D7EC  0440FFEF   BLTZ V0, 0x9D02D7AC
9D02D7F0  00000000   NOP
9D02D7F4  AE120008   SW S2, 8(S0)
9D02D7F8  A2130030   SB S3, 48(S0)
160:                    {
161:                       chan->accum += chan->freq;
9D02D7AC  0F40EEE7   JAL sitofp
9D02D7B0  02C02021   ADDU A0, S6, ZERO
9D02D7B4  02402021   ADDU A0, S2, ZERO
9D02D7B8  0F40D22D   JAL fpadd
9D02D7BC  00402821   ADDU A1, V0, ZERO
9D02D7C0  00409021   ADDU S2, V0, ZERO
162:                       chan->adder = (chan->adder + 1) & 0x0F;
9D02D7C4  26730001   ADDIU S3, S3, 1
9D02D7C8  3273000F   ANDI S3, S3, 15
163:                 
164:                 #ifdef APU_OVERSAMPLE
165:                       if (chan->adder < chan->duty_flip)
9D02D78C  0B40B5E8   J 0x9D02D7A0
9D02D790  8E170034   LW S7, 52(S0)
9D02D7A4  00008821   ADDU S1, ZERO, ZERO
9D02D7A8  0000A021   ADDU S4, ZERO, ZERO
9D02D7CC  0277182A   SLT V1, S3, S7
166:                          total += output;
9D02D7D0  02351021   ADDU V0, S1, S5
9D02D7D4  02358823   SUBU S1, S1, S5
9D02D7D8  0043880B   MOVN S1, V0, V1
167:                       else
168:                          total -= output;
169:                 
170:                       num_times++;
9D02D7DC  26940001   ADDIU S4, S4, 1
171:                 #endif
172:                    }
173:                 
174:                 #ifdef APU_OVERSAMPLE
175:                    chan->output_vol = total / num_times;
9D02D7FC  0234001A   DIV S1, S4
9D02D800  028001F4   TEQ S4, ZERO
9D02D804  00001812   MFLO V1
9D02D808  AE030010   SW V1, 16(S0)
176:                 #else
177:                    if (chan->fixed_envelope)
178:                       output = chan->volume << 8; /* fixed volume */
179:                    else
180:                       output = (chan->env_vol ^ 0x0F) << 8;
181:                 
182:                    if (0 == chan->adder)
183:                       chan->output_vol = output;
184:                    else if (chan->adder == chan->duty_flip)
185:                       chan->output_vol = -output;
186:                 #endif
187:                 
188:                    return MMC5_RECTANGLE_OUTPUT;
189:                 }
9D02D80C  00601021   ADDU V0, V1, ZERO
9D02D810  8FBF0034   LW RA, 52(SP)
9D02D814  8FB70030   LW S7, 48(SP)
9D02D818  8FB6002C   LW S6, 44(SP)
9D02D81C  8FB50028   LW S5, 40(SP)
9D02D820  8FB40024   LW S4, 36(SP)
9D02D824  8FB30020   LW S3, 32(SP)
9D02D828  8FB2001C   LW S2, 28(SP)
9D02D82C  8FB10018   LW S1, 24(SP)
9D02D830  8FB00014   LW S0, 20(SP)
9D02D834  03E00008   JR RA
9D02D838  27BD0038   ADDIU SP, SP, 56
190:                 
191:                 static uint8 mmc5_read(uint32 address)
192:                 {
193:                    uint32 retval;
194:                 
195:                    retval = (uint32) (mmc5.mul[0] * mmc5.mul[1]);
9D02D83C  3C03A001   LUI V1, -24575
9D02D840  2463A3A8   ADDIU V1, V1, -23640
9D02D844  90650004   LBU A1, 4(V1)
9D02D848  90620005   LBU V0, 5(V1)
196:                 
197:                    switch (address)
9D02D84C  24035205   ADDIU V1, ZERO, 20997
9D02D850  10830006   BEQ A0, V1, 0x9D02D86C
9D02D854  70A21002   MUL V0, A1, V0
198:                    {
199:                    case 0x5205:
200:                       return (uint8) retval;
201:                 
202:                    case 0x5206:
203:                       return (uint8) (retval >> 8);
204:                 
205:                    default:
206:                       return 0xFF;
9D02D858  00021202   SRL V0, V0, 8
9D02D85C  38845206   XORI A0, A0, 20998
9D02D860  240300FF   ADDIU V1, ZERO, 255
9D02D864  03E00008   JR RA
9D02D868  0064100B   MOVN V0, V1, A0
207:                    }
208:                 }
9D02D86C  03E00008   JR RA
9D02D870  304200FF   ANDI V0, V0, 255
209:                 
210:                 /* mix vrcvi sound channels together */
211:                 static int32 mmc5_process(void)
212:                 {
9D02D874  27BDFFE8   ADDIU SP, SP, -24
9D02D878  AFBF0014   SW RA, 20(SP)
9D02D87C  AFB00010   SW S0, 16(SP)
213:                    int32 accum;
214:                 
215:                    accum = mmc5_rectangle(&mmc5.rect[0]);
9D02D880  3C04A001   LUI A0, -24575
9D02D884  0F40B59A   JAL .Letext0, .LFE14, .LFB5, mmc5_rectangle, .Ltext0
9D02D888  2484A3B0   ADDIU A0, A0, -23632
9D02D88C  00408021   ADDU S0, V0, ZERO
216:                    accum += mmc5_rectangle(&mmc5.rect[1]);
9D02D890  3C04A001   LUI A0, -24575
9D02D894  0F40B59A   JAL .Letext0, .LFE14, .LFB5, mmc5_rectangle, .Ltext0
9D02D898  2484A3E8   ADDIU A0, A0, -23576
217:                    if (mmc5.dac.enabled)
9D02D89C  3C03A001   LUI V1, -24575
9D02D8A0  8C63A424   LW V1, -23516(V1)
9D02D8A4  10600004   BEQ V1, ZERO, 0x9D02D8B8
9D02D8A8  00501021   ADDU V0, V0, S0
218:                       accum += mmc5.dac.output;
9D02D8AC  3C03A001   LUI V1, -24575
9D02D8B0  8C63A420   LW V1, -23520(V1)
9D02D8B4  00431021   ADDU V0, V0, V1
219:                 
220:                    return accum;
221:                 }
9D02D8B8  8FBF0014   LW RA, 20(SP)
9D02D8BC  8FB00010   LW S0, 16(SP)
9D02D8C0  03E00008   JR RA
9D02D8C4  27BD0018   ADDIU SP, SP, 24
222:                 
223:                 /* write to registers */
224:                 static void mmc5_write(uint32 address, uint8 value)
225:                 {
226:                    int chan;
227:                 
228:                    switch (address)
9D02D8C8  24025007   ADDIU V0, ZERO, 20487
9D02D8CC  1082005B   BEQ A0, V0, 0x9D02DA3C
9D02D8D0  2C825008   SLTIU V0, A0, 20488
9D02D8D4  10400013   BEQ V0, ZERO, 0x9D02D924
9D02D8D8  24025015   ADDIU V0, ZERO, 20501
9D02D8DC  24025003   ADDIU V0, ZERO, 20483
9D02D8E0  10820056   BEQ A0, V0, 0x9D02DA3C
9D02D8E4  2C825004   SLTIU V0, A0, 20484
9D02D8E8  10400007   BEQ V0, ZERO, 0x9D02D908
9D02D8EC  24025000   ADDIU V0, ZERO, 20480
9D02D8F0  1082001D   BEQ A0, V0, 0x9D02D968
9D02D8F4  24025002   ADDIU V0, ZERO, 20482
9D02D8F8  1082003C   BEQ A0, V0, 0x9D02D9EC
9D02D8FC  7C840080   EXT A0, A0, 2, 1
9D02D900  03E00008   JR RA
9D02D904  00000000   NOP
9D02D908  24025004   ADDIU V0, ZERO, 20484
9D02D90C  10820016   BEQ A0, V0, 0x9D02D968
9D02D910  24025006   ADDIU V0, ZERO, 20486
9D02D914  10820035   BEQ A0, V0, 0x9D02D9EC
9D02D918  7C840080   EXT A0, A0, 2, 1
9D02D91C  03E00008   JR RA
9D02D920  00000000   NOP
9D02D924  1082006A   BEQ A0, V0, 0x9D02DAD0
9D02D928  2C825016   SLTIU V0, A0, 20502
9D02D92C  10400007   BEQ V0, ZERO, 0x9D02D94C
9D02D930  24025010   ADDIU V0, ZERO, 20496
9D02D934  1082007C   BEQ A0, V0, 0x9D02DB28
9D02D938  24025011   ADDIU V0, ZERO, 20497
9D02D93C  10820082   BEQ A0, V0, 0x9D02DB48
9D02D940  38A50080   XORI A1, A1, 128
9D02D944  03E00008   JR RA
9D02D948  00000000   NOP
9D02D94C  24025205   ADDIU V0, ZERO, 20997
9D02D950  10820081   BEQ A0, V0, 0x9D02DB58
9D02D954  24025206   ADDIU V0, ZERO, 20998
9D02D958  10820082   BEQ A0, V0, 0x9D02DB64
9D02D95C  3C02A001   LUI V0, -24575
9D02D960  03E00008   JR RA
9D02D964  00000000   NOP
229:                    {
230:                    /* rectangles */
231:                    case MMC5_WRA0:
232:                    case MMC5_WRB0:
233:                       chan = (address & 4) ? 1 : 0;
9D02D968  7C840080   EXT A0, A0, 2, 1
234:                       mmc5.rect[chan].regs[0] = value;
9D02D96C  000410C0   SLL V0, A0, 3
9D02D970  00041980   SLL V1, A0, 6
9D02D974  00621023   SUBU V0, V1, V0
9D02D978  3C03A001   LUI V1, -24575
9D02D97C  2463A3A8   ADDIU V1, V1, -23640
9D02D980  00431021   ADDU V0, V0, V1
9D02D984  A0450008   SB A1, 8(V0)
235:                 
236:                       mmc5.rect[chan].volume = value & 0x0F;
9D02D988  30A6000F   ANDI A2, A1, 15
9D02D98C  A0460024   SB A2, 36(V0)
237:                       mmc5.rect[chan].env_delay = decay_lut[value & 0x0F];
9D02D990  00063080   SLL A2, A2, 2
9D02D994  3C07A001   LUI A3, -24575
9D02D998  24E7A4A8   ADDIU A3, A3, -23384
9D02D99C  00C73021   ADDU A2, A2, A3
9D02D9A0  8CC60000   LW A2, 0(A2)
9D02D9A4  AC46002C   SW A2, 44(V0)
238:                       mmc5.rect[chan].holdnote = (value & 0x20) ? true : false;
9D02D9A8  7CA60140   EXT A2, A1, 5, 1
9D02D9AC  AC460020   SW A2, 32(V0)
239:                       mmc5.rect[chan].fixed_envelope = (value & 0x10) ? true : false;
9D02D9B0  7CA60100   EXT A2, A1, 4, 1
9D02D9B4  AC46001C   SW A2, 28(V0)
240:                       mmc5.rect[chan].duty_flip = duty_lut[value >> 6];
9D02D9B8  24840001   ADDIU A0, A0, 1
9D02D9BC  000410C0   SLL V0, A0, 3
9D02D9C0  00042180   SLL A0, A0, 6
9D02D9C4  00822023   SUBU A0, A0, V0
9D02D9C8  00641821   ADDU V1, V1, A0
9D02D9CC  00052982   SRL A1, A1, 6
9D02D9D0  00052880   SLL A1, A1, 2
9D02D9D4  3C029D04   LUI V0, -25340
9D02D9D8  2442C5A0   ADDIU V0, V0, -14944
9D02D9DC  00A22821   ADDU A1, A1, V0
9D02D9E0  8CA20000   LW V0, 0(A1)
241:                       break;
9D02D9E4  03E00008   JR RA
9D02D9E8  AC620004   SW V0, 4(V1)
242:                 
243:                    case MMC5_WRA1:
244:                    case MMC5_WRB1:
245:                       break;
246:                 
247:                    case MMC5_WRA2:
248:                    case MMC5_WRB2:
249:                       chan = (address & 4) ? 1 : 0;
250:                       mmc5.rect[chan].regs[2] = value;
9D02D9EC  000410C0   SLL V0, A0, 3
9D02D9F0  00041980   SLL V1, A0, 6
9D02D9F4  00621023   SUBU V0, V1, V0
9D02D9F8  3C03A001   LUI V1, -24575
9D02D9FC  2463A3A8   ADDIU V1, V1, -23640
9D02DA00  00431021   ADDU V0, V0, V1
9D02DA04  A045000A   SB A1, 10(V0)
251:                       if (mmc5.rect[chan].enabled)
9D02DA08  8C42000C   LW V0, 12(V0)
9D02DA0C  1040FFBC   BEQ V0, ZERO, 0x9D02D900
9D02DA10  000410C0   SLL V0, A0, 3
252:                          mmc5.rect[chan].freq = (((mmc5.rect[chan].regs[3] & 7) << 8) + value) + 1;
9D02DA14  00042180   SLL A0, A0, 6
9D02DA18  00822023   SUBU A0, A0, V0
9D02DA1C  00641021   ADDU V0, V1, A0
9D02DA20  9043000B   LBU V1, 11(V0)
9D02DA24  30630007   ANDI V1, V1, 7
9D02DA28  00031A00   SLL V1, V1, 8
9D02DA2C  00652821   ADDU A1, V1, A1
9D02DA30  24A50001   ADDIU A1, A1, 1
9D02DA34  03E00008   JR RA
9D02DA38  AC450014   SW A1, 20(V0)
253:                       break;
254:                 
255:                    case MMC5_WRA3:
256:                    case MMC5_WRB3:
257:                       chan = (address & 4) ? 1 : 0;
9D02DA3C  7C840080   EXT A0, A0, 2, 1
258:                       mmc5.rect[chan].regs[3] = value;
9D02DA40  000410C0   SLL V0, A0, 3
9D02DA44  00041980   SLL V1, A0, 6
9D02DA48  00621023   SUBU V0, V1, V0
9D02DA4C  3C03A001   LUI V1, -24575
9D02DA50  2463A3A8   ADDIU V1, V1, -23640
9D02DA54  00431021   ADDU V0, V0, V1
9D02DA58  A045000B   SB A1, 11(V0)
259:                 
260:                       if (mmc5.rect[chan].enabled)
9D02DA5C  8C42000C   LW V0, 12(V0)
9D02DA60  1040FFA7   BEQ V0, ZERO, 0x9D02D900
9D02DA64  3C03A001   LUI V1, -24575
261:                       {
262:                          mmc5.rect[chan].vbl_length = vbl_lut[value >> 3];
9D02DA68  2463A3A8   ADDIU V1, V1, -23640
9D02DA6C  000410C0   SLL V0, A0, 3
9D02DA70  00043180   SLL A2, A0, 6
9D02DA74  00C21023   SUBU V0, A2, V0
9D02DA78  00621021   ADDU V0, V1, V0
9D02DA7C  000538C2   SRL A3, A1, 3
9D02DA80  00073880   SLL A3, A3, 2
9D02DA84  3C06A001   LUI A2, -24575
9D02DA88  24C6A428   ADDIU A2, A2, -23512
9D02DA8C  00E63021   ADDU A2, A3, A2
9D02DA90  8CC60000   LW A2, 0(A2)
9D02DA94  AC460034   SW A2, 52(V0)
263:                          mmc5.rect[chan].env_vol = 0;
9D02DA98  A0400030   SB ZERO, 48(V0)
264:                          mmc5.rect[chan].freq = (((value & 7) << 8) + mmc5.rect[chan].regs[2]) + 1;
9D02DA9C  30A50007   ANDI A1, A1, 7
9D02DAA0  00052A00   SLL A1, A1, 8
9D02DAA4  9046000A   LBU A2, 10(V0)
9D02DAA8  00A62821   ADDU A1, A1, A2
9D02DAAC  24A50001   ADDIU A1, A1, 1
9D02DAB0  AC450014   SW A1, 20(V0)
265:                          mmc5.rect[chan].adder = 0;
9D02DAB4  24840001   ADDIU A0, A0, 1
9D02DAB8  000410C0   SLL V0, A0, 3
9D02DABC  00042180   SLL A0, A0, 6
9D02DAC0  00822023   SUBU A0, A0, V0
9D02DAC4  00831821   ADDU V1, A0, V1
9D02DAC8  03E00008   JR RA
9D02DACC  A0600000   SB ZERO, 0(V1)
266:                       }
267:                       break;
268:                    
269:                    case MMC5_SMASK:
270:                       if (value & 0x01)
9D02DAD0  30A20001   ANDI V0, A1, 1
9D02DAD4  10400005   BEQ V0, ZERO, 0x9D02DAEC
9D02DAD8  3C02A001   LUI V0, -24575
271:                       {
272:                          mmc5.rect[0].enabled = true;
9D02DADC  24030001   ADDIU V1, ZERO, 1
9D02DAE0  3C02A001   LUI V0, -24575
9D02DAE4  0B40B6BE   J 0x9D02DAF8
9D02DAE8  AC43A3B4   SW V1, -23628(V0)
273:                       }
274:                       else
275:                       {
276:                          mmc5.rect[0].enabled = false;
9D02DAEC  2442A3A8   ADDIU V0, V0, -23640
9D02DAF0  AC40000C   SW ZERO, 12(V0)
277:                          mmc5.rect[0].vbl_length = 0;
9D02DAF4  AC400034   SW ZERO, 52(V0)
278:                       }
279:                 
280:                       if (value & 0x02)
9D02DAF8  30A50002   ANDI A1, A1, 2
9D02DAFC  30A500FF   ANDI A1, A1, 255
9D02DB00  10A00005   BEQ A1, ZERO, 0x9D02DB18
9D02DB04  3C02A001   LUI V0, -24575
281:                       {
282:                          mmc5.rect[1].enabled = true;
9D02DB08  24030001   ADDIU V1, ZERO, 1
9D02DB0C  3C02A001   LUI V0, -24575
9D02DB10  03E00008   JR RA
9D02DB14  AC43A3EC   SW V1, -23572(V0)
283:                       }
284:                       else
285:                       {
286:                          mmc5.rect[1].enabled = false;
9D02DB18  2442A3A8   ADDIU V0, V0, -23640
9D02DB1C  AC400044   SW ZERO, 68(V0)
287:                          mmc5.rect[1].vbl_length = 0;
9D02DB20  03E00008   JR RA
9D02DB24  AC40006C   SW ZERO, 108(V0)
288:                       }
289:                 
290:                       break;
291:                 
292:                    case 0x5010:
293:                       if (value & 0x01)
9D02DB28  30A50001   ANDI A1, A1, 1
9D02DB2C  10A00004   BEQ A1, ZERO, 0x9D02DB40
9D02DB30  3C02A001   LUI V0, -24575
294:                          mmc5.dac.enabled = true;
9D02DB34  24030001   ADDIU V1, ZERO, 1
9D02DB38  03E00008   JR RA
9D02DB3C  AC43A424   SW V1, -23516(V0)
295:                       else
296:                          mmc5.dac.enabled = false;
9D02DB40  03E00008   JR RA
9D02DB44  AC40A424   SW ZERO, -23516(V0)
297:                       break;
298:                 
299:                    case 0x5011:
300:                       mmc5.dac.output = (value ^ 0x80) << 8;
9D02DB48  00052A00   SLL A1, A1, 8
9D02DB4C  3C02A001   LUI V0, -24575
301:                       break;
9D02DB50  03E00008   JR RA
9D02DB54  AC45A420   SW A1, -23520(V0)
302:                 
303:                    case 0x5205:
304:                       mmc5.mul[0] = value;
9D02DB58  3C02A001   LUI V0, -24575
305:                       break;
9D02DB5C  03E00008   JR RA
9D02DB60  A045A3AC   SB A1, -23636(V0)
306:                 
307:                    case 0x5206:
308:                       mmc5.mul[1] = value;
9D02DB64  A045A3AD   SB A1, -23635(V0)
9D02DB68  03E00008   JR RA
9D02DB6C  00000000   NOP
309:                       break;
310:                 
311:                    case 0x5114:
312:                    case 0x5115:
313:                       /* ???? */
314:                       break;
315:                    
316:                    default:
317:                       break;
318:                    }
319:                 }
320:                 
321:                 /* reset state of vrcvi sound channels */
322:                 static void mmc5_reset(void)
323:                 {
9D02DB70  27BDFE70   ADDIU SP, SP, -400
9D02DB74  AFBF018C   SW RA, 396(SP)
9D02DB78  AFB10188   SW S1, 392(SP)
9D02DB7C  AFB00184   SW S0, 388(SP)
324:                    int i;
325:                    apu_t apu;
326:                 
327:                 
328:                    /* get the phase period from the apu */
329:                    apu_getcontext(&apu);
9D02DB80  0F407892   JAL apu_getcontext
9D02DB84  27A40010   ADDIU A0, SP, 16
330:                    mmc5.incsize = apu.cycle_rate;
9D02DB88  8FA3015C   LW V1, 348(SP)
9D02DB8C  3C02A001   LUI V0, -24575
9D02DB90  AC43A3A8   SW V1, -23640(V0)
331:                 
332:                    for (i = 0x5000; i < 0x5008; i++)
9D02DB94  24105000   ADDIU S0, ZERO, 20480
9D02DB98  24115008   ADDIU S1, ZERO, 20488
9D02DBA8  26100001   ADDIU S0, S0, 1
9D02DBAC  1611FFFC   BNE S0, S1, 0x9D02DBA0
9D02DBB0  02002021   ADDU A0, S0, ZERO
333:                       mmc5_write(i, 0);
9D02DB9C  02002021   ADDU A0, S0, ZERO
9D02DBA0  0F40B632   JAL .LFB8, mmc5_write, .LFE7
9D02DBA4  00002821   ADDU A1, ZERO, ZERO
334:                 
335:                    mmc5_write(0x5010, 0);
9D02DBB4  24045010   ADDIU A0, ZERO, 20496
9D02DBB8  0F40B632   JAL .LFB8, mmc5_write, .LFE7
9D02DBBC  00002821   ADDU A1, ZERO, ZERO
336:                    mmc5_write(0x5011, 0);
9D02DBC0  24045011   ADDIU A0, ZERO, 20497
9D02DBC4  0F40B632   JAL .LFB8, mmc5_write, .LFE7
9D02DBC8  00002821   ADDU A1, ZERO, ZERO
337:                 }
9D02DBCC  8FBF018C   LW RA, 396(SP)
9D02DBD0  8FB10188   LW S1, 392(SP)
9D02DBD4  8FB00184   LW S0, 388(SP)
9D02DBD8  03E00008   JR RA
9D02DBDC  27BD0190   ADDIU SP, SP, 400
338:                 
339:                 static int mmc5_init(void)
340:                 {
9D02DBE0  27BDFE78   ADDIU SP, SP, -392
9D02DBE4  AFBF0184   SW RA, 388(SP)
341:                    int i, num_samples;
342:                    apu_t apu;
343:                 
344:                    apu_getcontext(&apu);
9D02DBE8  0F407892   JAL apu_getcontext
9D02DBEC  27A40010   ADDIU A0, SP, 16
345:                    num_samples = apu.num_samples;
9D02DBF0  8FA5014C   LW A1, 332(SP)
9D02DBF4  00A03021   ADDU A2, A1, ZERO
9D02DBF8  3C02A001   LUI V0, -24575
9D02DBFC  2442A4A8   ADDIU V0, V0, -23384
9D02DC00  24440040   ADDIU A0, V0, 64
9D02DC04  00A01821   ADDU V1, A1, ZERO
346:                 
347:                    /* lut used for enveloping and frequency sweeps */
348:                    for (i = 0; i < 16; i++)
9D02DC10  1444FFFD   BNE V0, A0, 0x9D02DC08
9D02DC14  00661821   ADDU V1, V1, A2
9D02DC18  3C029D04   LUI V0, -25340
9D02DC1C  2442C5B0   ADDIU V0, V0, -14928
9D02DC20  3C03A001   LUI V1, -24575
9D02DC24  2463A428   ADDIU V1, V1, -23512
9D02DC28  24460020   ADDIU A2, V0, 32
349:                       decay_lut[i] = num_samples * (i + 1);
9D02DC08  AC430000   SW V1, 0(V0)
9D02DC0C  24420004   ADDIU V0, V0, 4
350:                 
351:                    /* used for note length, based on vblanks and size of audio buffer */
352:                    for (i = 0; i < 32; i++)
9D02DC3C  1446FFFB   BNE V0, A2, 0x9D02DC2C
9D02DC40  24630004   ADDIU V1, V1, 4
353:                       vbl_lut[i] = vbl_length[i] * num_samples;
9D02DC2C  90440000   LBU A0, 0(V0)
9D02DC30  70852002   MUL A0, A0, A1
9D02DC34  AC640000   SW A0, 0(V1)
9D02DC38  24420001   ADDIU V0, V0, 1
354:                 
355:                    return 0;
356:                 }
9D02DC44  00001021   ADDU V0, ZERO, ZERO
9D02DC48  8FBF0184   LW RA, 388(SP)
9D02DC4C  03E00008   JR RA
9D02DC50  27BD0188   ADDIU SP, SP, 392
357:                 
358:                 static apu_memread mmc5_memread[] =
359:                 {
360:                    { 0x5205, 0x5206, mmc5_read },
361:                    {     -1,     -1, NULL }
362:                 };
363:                 
364:                 static apu_memwrite mmc5_memwrite[] =
365:                 {
366:                    { 0x5000, 0x5015, mmc5_write },
367:                    { 0x5114, 0x5115, mmc5_write },
368:                    { 0x5205, 0x5206, mmc5_write },
369:                    {     -1,     -1, NULL }
370:                 };
371:                 
372:                 apuext_t mmc5_ext =
373:                 {
374:                    mmc5_init,
375:                    NULL, /* no shutdown */
376:                    mmc5_reset,
377:                    mmc5_process,
378:                    mmc5_memread,
379:                    mmc5_memwrite
380:                 };
381:                 
382:                 /*
383:                 ** $Log: mmc5_snd.c,v $
384:                 ** Revision 1.2  2001/04/27 14:37:11  neil
385:                 ** wheeee
386:                 **
387:                 ** Revision 1.1  2001/04/27 12:54:40  neil
388:                 ** blah
389:                 **
390:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
391:                 ** initial
392:                 **
393:                 ** Revision 1.2  2000/11/13 00:57:08  matt
394:                 ** doesn't look as nasty now
395:                 **
396:                 ** Revision 1.1  2000/10/24 12:19:59  matt
397:                 ** changed directory structure
398:                 **
399:                 ** Revision 1.16  2000/10/17 11:56:42  matt
400:                 ** selectable apu base frequency
401:                 **
402:                 ** Revision 1.15  2000/10/10 14:04:29  matt
403:                 ** make way for bjarne
404:                 **
405:                 ** Revision 1.14  2000/10/10 13:58:18  matt
406:                 ** stroustrup squeezing his way in the door
407:                 **
408:                 ** Revision 1.13  2000/10/08 17:50:18  matt
409:                 ** appears $5114/$5115 do something
410:                 **
411:                 ** Revision 1.12  2000/10/03 11:56:20  matt
412:                 ** better support for optional sound ext routines
413:                 **
414:                 ** Revision 1.11  2000/09/27 12:26:03  matt
415:                 ** changed sound accumulators back to floats
416:                 **
417:                 ** Revision 1.10  2000/09/15 13:38:40  matt
418:                 ** changes for optimized apu core
419:                 **
420:                 ** Revision 1.9  2000/09/15 04:58:07  matt
421:                 ** simplifying and optimizing APU core
422:                 **
423:                 ** Revision 1.8  2000/07/30 04:32:59  matt
424:                 ** no more apu_getcyclerate hack
425:                 **
426:                 ** Revision 1.7  2000/07/17 01:52:31  matt
427:                 ** made sure last line of all source files is a newline
428:                 **
429:                 ** Revision 1.6  2000/07/04 04:51:41  matt
430:                 ** cleanups
431:                 **
432:                 ** Revision 1.5  2000/07/03 02:18:53  matt
433:                 ** much better external module exporting
434:                 **
435:                 ** Revision 1.4  2000/06/28 22:03:51  matt
436:                 ** fixed stupid oversight
437:                 **
438:                 ** Revision 1.3  2000/06/20 20:46:58  matt
439:                 ** minor cleanups
440:                 **
441:                 ** Revision 1.2  2000/06/20 04:06:16  matt
442:                 ** migrated external sound definition to apu module
443:                 **
444:                 ** Revision 1.1  2000/06/20 00:06:47  matt
445:                 ** initial revision
446:                 **
447:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/sndhrdw/fds_snd.c  -------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** fds_snd.c
21:                  **
22:                  ** Famicom Disk System sound emulation
23:                  ** $Id: fds_snd.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_apu.h>
28:                  #include <fds_snd.h>
29:                  
30:                  static int32 fds_incsize = 0;
31:                  
32:                  /* mix sound channels together */
33:                  static int32 fds_process(void)
34:                  {
35:                     int32 output;
36:                     output = 0;
37:                  
38:                     return output;
39:                  }
9D03BF1C  03E00008   JR RA
9D03BF20  00001021   ADDU V0, ZERO, ZERO
40:                  
41:                  /* write to registers */
42:                  static void fds_write(uint32 address, uint8 value)
43:                  {
9D03BF24  03E00008   JR RA
9D03BF28  00000000   NOP
44:                     UNUSED(address);
45:                     UNUSED(value);
46:                  }
47:                  
48:                  /* reset state of vrcvi sound channels */
49:                  static void fds_reset(void)
50:                  {
9D03BF2C  27BDFE78   ADDIU SP, SP, -392
9D03BF30  AFBF0184   SW RA, 388(SP)
51:                     apu_t apu;
52:                  
53:                     apu_getcontext(&apu);
9D03BF34  0F407892   JAL apu_getcontext
9D03BF38  27A40010   ADDIU A0, SP, 16
54:                  //   fds_incsize = apu.cycle_rate;
55:                     fds_incsize = (int32) (APU_BASEFREQ * 65536.0 / (float) apu.sample_rate);
9D03BF3C  0F40EEE7   JAL sitofp
9D03BF40  8FA40160   LW A0, 352(SP)
9D03BF44  3C039D04   LUI V1, -25340
9D03BF48  8C64CDD0   LW A0, -12848(V1)
9D03BF4C  0F40D475   JAL __divsf3
9D03BF50  00402821   ADDU A1, V0, ZERO
9D03BF54  0F40ECBC   JAL __fixsfsi
9D03BF58  00402021   ADDU A0, V0, ZERO
9D03BF5C  AF828120   SW V0, -32480(GP)
56:                  }
9D03BF60  8FBF0184   LW RA, 388(SP)
9D03BF64  03E00008   JR RA
9D03BF68  27BD0188   ADDIU SP, SP, 392
57:                  
58:                  static apu_memwrite fds_memwrite[] =
59:                  {
60:                     { 0x4040, 0x4092, fds_write }, 
61:                     {     -1,     -1, NULL }
62:                  };
63:                  
64:                  apuext_t fds_ext = 
65:                  {
66:                     NULL, /* no init */
67:                     NULL, /* no shutdown */
68:                     fds_reset,
69:                     fds_process,
70:                     NULL, /* no reads */
71:                     fds_memwrite
72:                  };
73:                  
74:                  /*
75:                  ** $Log: fds_snd.c,v $
76:                  ** Revision 1.2  2001/04/27 14:37:11  neil
77:                  ** wheeee
78:                  **
79:                  ** Revision 1.1  2001/04/27 12:54:40  neil
80:                  ** blah
81:                  **
82:                  ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
83:                  ** initial
84:                  **
85:                  ** Revision 1.1  2000/10/24 12:19:59  matt
86:                  ** changed directory structure
87:                  **
88:                  ** Revision 1.9  2000/10/11 12:13:15  matt
89:                  ** quelled warnings
90:                  **
91:                  ** Revision 1.8  2000/10/03 11:56:20  matt
92:                  ** better support for optional sound ext routines
93:                  **
94:                  ** Revision 1.7  2000/09/15 13:38:40  matt
95:                  ** changes for optimized apu core
96:                  **
97:                  ** Revision 1.6  2000/09/15 04:58:07  matt
98:                  ** simplifying and optimizing APU core
99:                  **
100:                 ** Revision 1.5  2000/07/30 04:32:59  matt
101:                 ** no more apu_getcyclerate hack
102:                 **
103:                 ** Revision 1.4  2000/07/17 01:52:30  matt
104:                 ** made sure last line of all source files is a newline
105:                 **
106:                 ** Revision 1.3  2000/07/03 02:18:53  matt
107:                 ** much better external module exporting
108:                 **
109:                 ** Revision 1.2  2000/06/20 04:06:16  matt
110:                 ** migrated external sound definition to apu module
111:                 **
112:                 ** Revision 1.1  2000/06/20 00:06:47  matt
113:                 ** initial revision
114:                 **
115:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/pcx.c  -------------------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** pcx.c
21:                  **
22:                  ** PCX format screen-saving routines
23:                  ** $Id: pcx.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <stdio.h>
27:                  #include <string.h>
28:                  #include <noftypes.h>
29:                  #include <bitmap.h>
30:                  #include <pcx.h>
31:                  
32:                  /* Save a PCX snapshot from a given NES bitmap */
33:                  int pcx_write(char *filename, bitmap_t *bmp, rgb_t *pal)
34:                  {
9D035848  27BDFF40   ADDIU SP, SP, -192
9D03584C  AFBF00BC   SW RA, 188(SP)
9D035850  AFBE00B8   SW FP, 184(SP)
9D035854  AFB700B4   SW S7, 180(SP)
9D035858  AFB600B0   SW S6, 176(SP)
9D03585C  AFB500AC   SW S5, 172(SP)
9D035860  AFB400A8   SW S4, 168(SP)
9D035864  AFB300A4   SW S3, 164(SP)
9D035868  AFB200A0   SW S2, 160(SP)
9D03586C  AFB1009C   SW S1, 156(SP)
9D035870  AFB00098   SW S0, 152(SP)
9D035874  00A0F021   ADDU FP, A1, ZERO
9D035878  AFA600C8   SW A2, 200(SP)
35:                     FILE *fp;
36:                     pcxheader_t header;
37:                     int i, line;
38:                     int width, height, x_min, y_min;
39:                  
40:                     ASSERT(bmp);
41:                  
42:                     width = bmp->width;
9D03587C  8CB30000   LW S3, 0(A1)
43:                     height = bmp->height;
9D035880  8CA20004   LW V0, 4(A1)
9D035884  AFA20090   SW V0, 144(SP)
44:                     x_min = 0;
45:                     y_min = 0;
46:                  
47:                     fp = fopen(filename, "wb");
9D035888  3C059D04   LUI A1, -25340
9D03588C  0F40DCB1   JAL .Letext0, .LFE3, fopen
9D035890  24A5CDD4   ADDIU A1, A1, -12844
48:                     if (NULL == fp)
9D035894  10400065   BEQ V0, ZERO, 0x9D035A2C
9D035898  0040A021   ADDU S4, V0, ZERO
49:                        return -1;
9D035A2C  2402FFFF   ADDIU V0, ZERO, -1
50:                  
51:                     /* Fill in the header nonsense */
52:                     memset(&header, 0, sizeof(header));
9D03589C  27A40010   ADDIU A0, SP, 16
9D0358A0  00002821   ADDU A1, ZERO, ZERO
9D0358A4  0F40E9FC   JAL .Letext0, .LFE0, memset
9D0358A8  24060080   ADDIU A2, ZERO, 128
53:                  
54:                     header.Manufacturer = 10;
9D0358AC  2402000A   ADDIU V0, ZERO, 10
9D0358B0  A3A20010   SB V0, 16(SP)
55:                     header.Version = 5;
9D0358B4  24020005   ADDIU V0, ZERO, 5
9D0358B8  A3A20011   SB V0, 17(SP)
56:                     header.Encoding = 1;
9D0358BC  24050001   ADDIU A1, ZERO, 1
9D0358C0  A3A50012   SB A1, 18(SP)
57:                     header.BitsPerPixel = 8;
9D0358C4  24020008   ADDIU V0, ZERO, 8
9D0358C8  A3A20013   SB V0, 19(SP)
58:                     header.Xmin = x_min;
59:                     header.Ymin = y_min;
60:                     header.Xmax = width - 1;
9D0358CC  3264FFFF   ANDI A0, S3, -1
9D0358D0  2483FFFF   ADDIU V1, A0, -1
9D0358D4  3063FFFF   ANDI V1, V1, -1
9D0358D8  A7A30018   SH V1, 24(SP)
61:                     header.Ymax = height - 1;
9D0358DC  8FA60090   LW A2, 144(SP)
9D0358E0  24C2FFFF   ADDIU V0, A2, -1
9D0358E4  3042FFFF   ANDI V0, V0, -1
9D0358E8  A7A2001A   SH V0, 26(SP)
62:                     header.NPlanes = 1;
9D0358EC  A3A50051   SB A1, 81(SP)
63:                     header.BytesPerLine = width;
9D0358F0  A7A40052   SH A0, 82(SP)
64:                     header.PaletteInfo = 1;
9D0358F4  24040001   ADDIU A0, ZERO, 1
9D0358F8  A7A40054   SH A0, 84(SP)
65:                     header.HscreenSize = width - 1;
9D0358FC  A7A30056   SH V1, 86(SP)
66:                     header.VscreenSize = height - 1;
9D035900  A7A20058   SH V0, 88(SP)
67:                  
68:                     fwrite(&header, 1, sizeof(header), fp);
9D035904  27A40010   ADDIU A0, SP, 16
9D035908  24050001   ADDIU A1, ZERO, 1
9D03590C  24060080   ADDIU A2, ZERO, 128
9D035910  0F40F1FB   JAL fwrite
9D035914  02803821   ADDU A3, S4, ZERO
69:                  
70:                     /* RLE encoding */
71:                     for (line = 0; line < height; line++)
9D035918  8FA20090   LW V0, 144(SP)
9D03591C  1840002F   BLEZ V0, 0x9D0359DC
9D035920  2404000C   ADDIU A0, ZERO, 12
9D035924  0000B821   ADDU S7, ZERO, ZERO
9D0359C8  26F70001   ADDIU S7, S7, 1
9D0359CC  8FA60090   LW A2, 144(SP)
9D0359D0  16E6FFD6   BNE S7, A2, 0x9D03592C
9D0359D4  27DE0004   ADDIU FP, FP, 4
72:                     {
73:                        uint8 last, *mem;
74:                        int xpos = 0;
9D035934  00008821   ADDU S1, ZERO, ZERO
9D035938  2465003F   ADDIU A1, V1, 63
9D03593C  00608021   ADDU S0, V1, ZERO
75:                  
76:                        mem = bmp->line[line + y_min] + x_min;
77:                  
78:                        while (xpos < width)
9D03592C  1A600026   BLEZ S3, .LBE2
9D035930  8FC30014   LW V1, 20(FP)
9D0359BC  02B3A82A   SLT S5, S5, S3
9D0359C0  16A0FFDD   BNE S5, ZERO, 0x9D035938
9D0359C4  02001821   ADDU V1, S0, ZERO
79:                        {
80:                           int rle_count = 0;
81:                  
82:                           do
83:                           {
84:                              last = *mem++;
9D035940  26100001   ADDIU S0, S0, 1
9D035944  9202FFFF   LBU V0, -1(S0)
85:                              xpos++;
9D035948  26310001   ADDIU S1, S1, 1
9D035974  0220A821   ADDU S5, S1, ZERO
9D035978  00409021   ADDU S2, V0, ZERO
86:                              rle_count++;
87:                           }
88:                           while (*mem == last && xpos < width && rle_count < 0x3F);
9D03594C  92120000   LBU S2, 0(S0)
9D035950  16420008   BNE S2, V0, 0x9D035974
9D035954  02032023   SUBU A0, S0, V1
9D035958  0233102A   SLT V0, S1, S3
9D03595C  10400007   BEQ V0, ZERO, 0x9D03597C
9D035960  0220A821   ADDU S5, S1, ZERO
9D035964  5605FFF7   BNEL S0, A1, 0x9D035944
9D035968  26100001   ADDIU S0, S0, 1
9D03596C  0B40D660   J 0x9D035980
9D035970  28820002   SLTI V0, A0, 2
89:                  
90:                           if (rle_count > 1 || 0xC0 == (last & 0xC0))
9D035928  241600C0   ADDIU S6, ZERO, 192
9D03597C  28820002   SLTI V0, A0, 2
9D035980  50400005   BEQL V0, ZERO, 0x9D035998
9D035984  348400C0   ORI A0, A0, 192
9D035988  324200C0   ANDI V0, S2, 192
9D03598C  54560009   BNEL V0, S6, 0x9D0359B4
9D035990  02402021   ADDU A0, S2, ZERO
91:                           {
92:                              fputc(0xC0 | rle_count, fp);
9D035994  348400C0   ORI A0, A0, 192
9D035998  0F40E951   JAL .Letext0, .LFE0, fputc
9D03599C  02802821   ADDU A1, S4, ZERO
93:                              fputc(last, fp);
9D0359A0  02402021   ADDU A0, S2, ZERO
9D0359A4  0F40E951   JAL .Letext0, .LFE0, fputc
9D0359A8  02802821   ADDU A1, S4, ZERO
9D0359AC  0B40D670   J 0x9D0359C0
9D0359B0  02B3A82A   SLT S5, S5, S3
94:                           }
95:                           else
96:                           {
97:                              fputc(last, fp);
9D0359B4  0F40E951   JAL .Letext0, .LFE0, fputc
9D0359B8  02802821   ADDU A1, S4, ZERO
98:                           }
99:                        }
100:                    }
101:                 
102:                    /* Write palette */
103:                    fputc(0x0C, fp); /* $0C signifies 256 color palette */
9D0359D8  2404000C   ADDIU A0, ZERO, 12
9D0359DC  0F40E951   JAL .Letext0, .LFE0, fputc
9D0359E0  02802821   ADDU A1, S4, ZERO
9D0359E4  8FB000C8   LW S0, 200(SP)
9D0359E8  24110100   ADDIU S1, ZERO, 256
104:                    for (i = 0; i < 256; i++)
9D035A14  1620FFF5   BNE S1, ZERO, 0x9D0359EC
9D035A18  2610000C   ADDIU S0, S0, 12
105:                    {
106:                       fputc(pal[i].r, fp);
9D0359EC  8E040000   LW A0, 0(S0)
9D0359F0  0F40E951   JAL .Letext0, .LFE0, fputc
9D0359F4  02802821   ADDU A1, S4, ZERO
107:                       fputc(pal[i].g, fp);
9D0359F8  8E040004   LW A0, 4(S0)
9D0359FC  0F40E951   JAL .Letext0, .LFE0, fputc
9D035A00  02802821   ADDU A1, S4, ZERO
108:                       fputc(pal[i].b, fp);
9D035A04  8E040008   LW A0, 8(S0)
9D035A08  0F40E951   JAL .Letext0, .LFE0, fputc
9D035A0C  02802821   ADDU A1, S4, ZERO
9D035A10  2631FFFF   ADDIU S1, S1, -1
109:                    }
110:                 
111:                    /* We're done! */
112:                    fclose(fp);
9D035A1C  0F40EBD5   JAL .Letext0, .LFE1, fclose
9D035A20  02802021   ADDU A0, S4, ZERO
113:                    return 0;
9D035A24  0B40D68C   J 0x9D035A30
9D035A28  00001021   ADDU V0, ZERO, ZERO
114:                 }
9D035A30  8FBF00BC   LW RA, 188(SP)
9D035A34  8FBE00B8   LW FP, 184(SP)
9D035A38  8FB700B4   LW S7, 180(SP)
9D035A3C  8FB600B0   LW S6, 176(SP)
9D035A40  8FB500AC   LW S5, 172(SP)
9D035A44  8FB400A8   LW S4, 168(SP)
9D035A48  8FB300A4   LW S3, 164(SP)
9D035A4C  8FB200A0   LW S2, 160(SP)
9D035A50  8FB1009C   LW S1, 156(SP)
9D035A54  8FB00098   LW S0, 152(SP)
9D035A58  03E00008   JR RA
9D035A5C  27BD00C0   ADDIU SP, SP, 192
115:                 
116:                 /*
117:                 ** $Log: pcx.c,v $
118:                 ** Revision 1.2  2001/04/27 14:37:11  neil
119:                 ** wheeee
120:                 **
121:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
122:                 ** initial
123:                 **
124:                 ** Revision 1.8  2000/11/06 05:17:48  matt
125:                 ** better!
126:                 **
127:                 ** Revision 1.7  2000/11/05 16:37:18  matt
128:                 ** rolled rgb.h into bitmap.h
129:                 **
130:                 ** Revision 1.6  2000/07/17 01:52:27  matt
131:                 ** made sure last line of all source files is a newline
132:                 **
133:                 ** Revision 1.5  2000/06/26 04:55:13  matt
134:                 ** changed routine name, big whoop
135:                 **
136:                 ** Revision 1.4  2000/06/09 15:12:25  matt
137:                 ** initial revision
138:                 **
139:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/nofrendo.c  --------------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** nofrendo.c
21:                  **
22:                  ** Entry point of program
23:                  ** Note: all architectures should call these functions
24:                  ** $Id: nofrendo.c,v 1.3 2001/04/27 14:37:11 neil Exp $
25:                  */
26:                  
27:                  #include <stdio.h>
28:                  #include <stdlib.h>
29:                  #include <noftypes.h>
30:                  #include <nofrendo.h>
31:                  #include <event.h>
32:                  #include <nofconfig.h>
33:                  #include <log.h>
34:                  #include <osd.h>
35:                  #include <gui.h>
36:                  #include <vid_drv.h>
37:                  
38:                  /* emulated system includes */
39:                  #include <nes.h>
40:                  
41:                  /* our global machine structure */
42:                  static struct
43:                  {
44:                     char *filename, *nextfilename;
45:                     system_t type, nexttype;
46:                  
47:                     union 
48:                     {
49:                        nes_t *nes;
50:                     } machine;
51:                  
52:                     int refresh_rate;
53:                  
54:                     bool quit;
55:                  } console;
56:                  
57:                  /* our happy little timer ISR */
58:                  volatile int nofrendo_ticks = 0;
59:                  static void timer_isr(void)
60:                  {
61:                     nofrendo_ticks++;
62:                  }
63:                  
64:                  static void timer_isr_end(void) {} /* code marker for djgpp */
65:                  
66:                  static void shutdown_everything(void)
67:                  {
68:                     if (console.filename)
69:                     {
70:                        free(console.filename);
71:                        console.filename = NULL;
72:                     }
73:                     if (console.nextfilename)
74:                     {
75:                        free(console.nextfilename);
76:                        console.nextfilename = NULL;
77:                     }
78:                  
79:                     config.close();
80:                     //osd_shutdown();
81:                     gui_shutdown();
82:                     vid_shutdown();
83:                     log_shutdown();
84:                  }
85:                  
86:                  /* End the current context */
87:                  void main_eject(void)
88:                  {
9D03380C  27BDFFE8   ADDIU SP, SP, -24
9D033810  AFBF0014   SW RA, 20(SP)
9D033814  AFB00010   SW S0, 16(SP)
89:                     switch (console.type)
9D033818  3C02A001   LUI V0, -24575
9D03381C  8C43B854   LW V1, -18348(V0)
9D033820  24020002   ADDIU V0, ZERO, 2
9D033824  14620007   BNE V1, V0, 0x9D033844
9D033828  3C02A001   LUI V0, -24575
90:                     {
91:                     case system_nes:
92:                        nes_poweroff();
9D03382C  0F408DFE   JAL nes_poweroff
9D033830  00000000   NOP
93:                        nes_destroy(&(console.machine.nes));
9D033834  3C04A001   LUI A0, -24575
9D033838  0F408DDA   JAL nes_destroy
9D03383C  2484B85C   ADDIU A0, A0, -18340
94:                        break;
95:                  
96:                     default:
97:                        break;
98:                     }
99:                  
100:                    if (NULL != console.filename)
9D033840  3C02A001   LUI V0, -24575
9D033844  8C42B84C   LW V0, -18356(V0)
9D033848  10400004   BEQ V0, ZERO, 0x9D03385C
9D03384C  3C10A001   LUI S0, -24575
101:                    {
102:                       free(console.filename);
9D033850  0F40DDCA   JAL _my_free
9D033854  2604B84C   ADDIU A0, S0, -18356
103:                       console.filename = NULL;
9D033858  AE00B84C   SW ZERO, -18356(S0)
104:                    }
105:                    console.type = system_unknown;
9D03385C  3C02A001   LUI V0, -24575
9D033860  AC40B854   SW ZERO, -18348(V0)
106:                 }
9D033864  8FBF0014   LW RA, 20(SP)
9D033868  8FB00010   LW S0, 16(SP)
9D03386C  03E00008   JR RA
9D033870  27BD0018   ADDIU SP, SP, 24
107:                 
108:                 /* Act on the user's quit requests */
109:                 void main_quit(void)
110:                 {
9D033874  27BDFFE8   ADDIU SP, SP, -24
9D033878  AFBF0014   SW RA, 20(SP)
9D03387C  AFB00010   SW S0, 16(SP)
111:                    console.quit = true;
9D033880  3C10A001   LUI S0, -24575
9D033884  2610B84C   ADDIU S0, S0, -18356
9D033888  24020001   ADDIU V0, ZERO, 1
112:                 
113:                    main_eject();
9D03388C  0F40CE03   JAL main_eject
9D033890  AE020018   SW V0, 24(S0)
114:                 
115:                    /* if there's a pending filename / system, clear */
116:                    if (NULL != console.nextfilename)
9D033894  8E020004   LW V0, 4(S0)
9D033898  10400007   BEQ V0, ZERO, 0x9D0338B8
9D03389C  3C02A001   LUI V0, -24575
117:                    {
118:                       free(console.nextfilename);
9D0338A0  3C04A001   LUI A0, -24575
9D0338A4  0F40DDCA   JAL _my_free
9D0338A8  2484B850   ADDIU A0, A0, -18352
119:                       console.nextfilename = NULL;
9D0338AC  3C02A001   LUI V0, -24575
9D0338B0  AC40B850   SW ZERO, -18352(V0)
120:                    }
121:                    console.nexttype = system_unknown;
9D0338B4  3C02A001   LUI V0, -24575
9D0338B8  AC40B858   SW ZERO, -18344(V0)
122:                 }
9D0338BC  8FBF0014   LW RA, 20(SP)
9D0338C0  8FB00010   LW S0, 16(SP)
9D0338C4  03E00008   JR RA
9D0338C8  27BD0018   ADDIU SP, SP, 24
123:                 
124:                 extern unsigned char _binary_SuperMarioBros_nes_start[];
125:                 
126:                 /* brute force system autodetection */
127:                 static system_t detect_systemtype(const char *filename)
128:                 {
129:                    if (NULL == filename)
9D033718  50800006   BEQL A0, ZERO, 0x9D033734
130:                       return system_unknown;
131:                 
132:                    if (0 == nes_isourfile(filename))
9D033720  0F408CFC   JAL nes_isourfile
133:                       return system_nes;
9D033728  24050002   ADDIU A1, ZERO, 2
134:                    
135:                    /* can't figure out what this thing is */
136:                    return system_unknown;
137:                 }
138:                 
139:                 static int install_timer(int hertz)
140:                 {
141:                    //return osd_installtimer(hertz, (void *) timer_isr,
142:                    //                        (int) timer_isr_end - (int) timer_isr,
143:                    //                        (void *) &nofrendo_ticks, 
144:                    //                        sizeof(nofrendo_ticks));
145:                 }
146:                 
147:                 /* This assumes there is no current context */
148:                 static int internal_insert(const char *filename, system_t type)
149:                 {
9D0336FC  27BDFFE0   ADDIU SP, SP, -32
9D033700  AFBF001C   SW RA, 28(SP)
9D033704  AFB10018   SW S1, 24(SP)
9D033708  AFB00014   SW S0, 20(SP)
150:                    /* autodetect system type? */
151:                    if (system_autodetect == type)
9D03370C  24020001   ADDIU V0, ZERO, 1
9D033710  14A20008   BNE A1, V0, 0x9D033734
9D033714  00808821   ADDU S1, A0, ZERO
152:                       type = detect_systemtype(filename);
153:                 
154:                    //console.filename = strdup(filename);
155:                    console.type = type;
9D033734  3C10A001   LUI S0, -24575
9D033738  2610B84C   ADDIU S0, S0, -18356
9D03373C  AE050008   SW A1, 8(S0)
156:                 
157:                    /* set up the event system for this system type */
158:                    event_set_system(type);
9D033740  0F409F3D   JAL event_set_system
9D033744  00A02021   ADDU A0, A1, ZERO
159:                 
160:                    switch (console.type)
9D033748  8E030008   LW V1, 8(S0)
9D03374C  24020002   ADDIU V0, ZERO, 2
9D033750  1462001A   BNE V1, V0, 0x9D0337BC
9D033754  3C049D04   LUI A0, -25340
161:                    {
162:                    case system_nes:
163:                       gui_setrefresh(NES_REFRESH_RATE);
9D033758  0F409308   JAL gui_setrefresh
9D03375C  2404003C   ADDIU A0, ZERO, 60
164:                 
165:                       console.machine.nes = nes_create();
9D033760  0F408F75   JAL nes_create
9D033764  00000000   NOP
9D033768  3C03A001   LUI V1, -24575
166:                       if (NULL == console.machine.nes)
9D03376C  14400006   BNE V0, ZERO, 0x9D033788
9D033770  AC62B85C   SW V0, -18340(V1)
167:                       {
168:                          log_printf("Failed to create NES instance.\n");
9D033774  3C049D04   LUI A0, -25340
9D033778  0F40F11B   JAL log_printf
9D03377C  2484BC58   ADDIU A0, A0, -17320
169:                          return -1;
9D033780  0B40CDFD   J 0x9D0337F4
9D033784  2410FFFF   ADDIU S0, ZERO, -1
170:                       }
171:                 
172:                       if (nes_insertcart(&_binary_SuperMarioBros_nes_start, console.machine.nes))
9D033788  3C049D01   LUI A0, -25343
9D03378C  2484A274   ADDIU A0, A0, -23948
9D033790  0F408E08   JAL nes_insertcart
9D033794  00402821   ADDU A1, V0, ZERO
9D033798  14400015   BNE V0, ZERO, 0x9D0337F0
9D03379C  00408021   ADDU S0, V0, ZERO
173:                          return -1;
9D0337F0  2410FFFF   ADDIU S0, ZERO, -1
174:                 
175:                       // was visible height!!!
176:                       vid_setmode(NES_SCREEN_WIDTH, NES_SCREEN_HEIGHT);
9D0337A0  24040100   ADDIU A0, ZERO, 256
9D0337A4  0F40BB81   JAL vid_setmode
9D0337A8  240500F0   ADDIU A1, ZERO, 240
177:                 
178:                       if (install_timer(NES_REFRESH_RATE))
179:                          return -1;
180:                 
181:                       nes_emulate();
9D0337AC  0F408D5A   JAL nes_emulate
9D0337B0  00000000   NOP
182:                       break;
183:                    
184:                    case system_unknown:
185:                    default:
186:                       log_printf("system type unknown, playing nofrendo NES intro.\n");
9D0337BC  0F40F11B   JAL log_printf
9D0337C0  2484BC78   ADDIU A0, A0, -17288
187:                       if (NULL != console.filename)
9D0337C4  3C02A001   LUI V0, -24575
9D0337C8  8C42B84C   LW V0, -18356(V0)
9D0337CC  10400003   BEQ V0, ZERO, .LVL13
9D0337D0  3C04A001   LUI A0, -24575
188:                          free(console.filename);
9D0337D4  0F40DDCA   JAL _my_free
9D0337D8  2484B84C   ADDIU A0, A0, -18356
189:                 
190:                       /* oooh, recursion */
191:                       return internal_insert(filename, system_nes);
9D0337DC  02202021   ADDU A0, S1, ZERO
9D0337E0  0F40CDBF   JAL .Letext0, .LFE7, .LFB10, internal_insert, .Ltext0
9D0337E4  24050002   ADDIU A1, ZERO, 2
9D0337E8  0B40CDFD   J 0x9D0337F4
9D0337EC  00408021   ADDU S0, V0, ZERO
192:                    }
193:                 
194:                    return 0;
9D0337B4  0B40CDFE   J 0x9D0337F8
9D0337B8  02001021   ADDU V0, S0, ZERO
195:                 }
9D0337F4  02001021   ADDU V0, S0, ZERO
9D0337F8  8FBF001C   LW RA, 28(SP)
9D0337FC  8FB10018   LW S1, 24(SP)
9D033800  8FB00014   LW S0, 20(SP)
9D033804  03E00008   JR RA
9D033808  27BD0020   ADDIU SP, SP, 32
196:                 
197:                 /* This tells main_loop to load this next image */
198:                 void main_insert(const char *filename, system_t type)
199:                 {
9D0338CC  27BDFFE8   ADDIU SP, SP, -24
9D0338D0  AFBF0014   SW RA, 20(SP)
9D0338D4  AFB00010   SW S0, 16(SP)
200:                    console.nextfilename = strdup(filename);
9D0338D8  0F40DDEE   JAL _my_strdup
9D0338DC  00A08021   ADDU S0, A1, ZERO
9D0338E0  3C03A001   LUI V1, -24575
9D0338E4  2463B84C   ADDIU V1, V1, -18356
9D0338E8  AC620004   SW V0, 4(V1)
201:                    console.nexttype = type;
202:                 
203:                    main_eject();
9D0338EC  0F40CE03   JAL main_eject
9D0338F0  AC70000C   SW S0, 12(V1)
204:                 }
9D0338F4  8FBF0014   LW RA, 20(SP)
9D0338F8  8FB00010   LW S0, 16(SP)
9D0338FC  03E00008   JR RA
9D033900  27BD0018   ADDIU SP, SP, 24
205:                 
206:                 int nofrendo_main(int argc, char *argv[])
207:                 {
9D033948  27BDFFE8   ADDIU SP, SP, -24
9D03394C  AFBF0014   SW RA, 20(SP)
208:                    /* initialize our system structure */
209:                    console.filename = NULL;
9D033950  3C02A001   LUI V0, -24575
9D033954  AC40B84C   SW ZERO, -18356(V0)
210:                    console.nextfilename = NULL;
9D033958  2442B84C   ADDIU V0, V0, -18356
9D03395C  AC400004   SW ZERO, 4(V0)
211:                    console.type = system_unknown;
9D033960  AC400008   SW ZERO, 8(V0)
212:                    console.nexttype = system_unknown;
9D033964  AC40000C   SW ZERO, 12(V0)
213:                    console.refresh_rate = 0;
9D033968  AC400014   SW ZERO, 20(V0)
214:                    console.quit = false;
215:                    
216:                    if (log_init())
9D03396C  0F40F115   JAL log_init
9D033970  AC400018   SW ZERO, 24(V0)
9D033974  14400007   BNE V0, ZERO, .LVL32
9D033978  2402FFFF   ADDIU V0, ZERO, -1
217:                       return -1;
218:                 
219:                    event_init();
9D03397C  0F409F34   JAL event_init
9D033980  00000000   NOP
220:                 
221:                    //return osd_main(argc, argv);
222:                    main_loop("test",system_nes);
9D033984  3C049D04   LUI A0, -25340
9D033988  2484BCAC   ADDIU A0, A0, -17236
9D03398C  0F40CE41   JAL main_loop
9D033990  24050002   ADDIU A1, ZERO, 2
223:                 }
9D033994  8FBF0014   LW RA, 20(SP)
9D033998  03E00008   JR RA
9D03399C  27BD0018   ADDIU SP, SP, 24
224:                 
225:                 /* This is the final leg of main() */
226:                 int main_loop(const char *filename, system_t type)
227:                 {
9D033904  27BDFFE8   ADDIU SP, SP, -24
9D033908  AFBF0014   SW RA, 20(SP)
9D03390C  AFB00010   SW S0, 16(SP)
228:                    vidinfo_t video;
229:                 
230:                    /* register shutdown, in case of assertions, etc. */
231:                 //   atexit(shutdown_everything);
232:                 
233:                 //   if (config.open())
234:                 //s      return -1;
235:                 
236:                    //if (osd_init())
237:                    //   return -1;
238:                 
239:                    //if (gui_init())
240:                    //   return -1;
241:                 
242:                    //osd_getvideoinfo(&video);
243:                 //   if (vid_init(video.default_width, video.default_height, video.driver))
244:                 //      return -1;
245:                 //	printf("vid_init done\n");
246:                 
247:                    console.nextfilename = strdup(filename);
9D033910  0F40DDEE   JAL _my_strdup
9D033914  00A08021   ADDU S0, A1, ZERO
9D033918  3C03A001   LUI V1, -24575
9D03391C  2463B84C   ADDIU V1, V1, -18356
9D033920  AC620004   SW V0, 4(V1)
248:                    console.nexttype = type;
9D033924  AC70000C   SW S0, 12(V1)
249:                 
250:                    //while (false == console.quit)
251:                    //{
252:                       if (internal_insert(console.nextfilename, console.nexttype))
9D033928  00402021   ADDU A0, V0, ZERO
9D03392C  0F40CDBF   JAL .Letext0, .LFE7, .LFB10, internal_insert, .Ltext0
9D033930  02002821   ADDU A1, S0, ZERO
253:                          return 1;
254:                    //}
255:                 
256:                    return 0;
257:                 }
9D033934  0002102B   SLTU V0, ZERO, V0
9D033938  8FBF0014   LW RA, 20(SP)
9D03393C  8FB00010   LW S0, 16(SP)
9D033940  03E00008   JR RA
9D033944  27BD0018   ADDIU SP, SP, 24
258:                 
259:                 /*
260:                 ** $Log: nofrendo.c,v $
261:                 ** Revision 1.3  2001/04/27 14:37:11  neil
262:                 ** wheeee
263:                 **
264:                 ** Revision 1.2  2001/04/27 11:10:08  neil
265:                 ** compile
266:                 **
267:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
268:                 ** initial
269:                 **
270:                 ** Revision 1.48  2000/11/27 12:47:08  matt
271:                 ** free them strings
272:                 **
273:                 ** Revision 1.47  2000/11/25 20:26:05  matt
274:                 ** removed fds "system"
275:                 **
276:                 ** Revision 1.46  2000/11/25 01:51:53  matt
277:                 ** bool stinks sometimes
278:                 **
279:                 ** Revision 1.45  2000/11/20 13:22:12  matt
280:                 ** standardized timer ISR, added nofrendo_ticks
281:                 **
282:                 ** Revision 1.44  2000/11/05 22:53:13  matt
283:                 ** only one video driver per system, please
284:                 **
285:                 ** Revision 1.43  2000/11/01 14:15:35  matt
286:                 ** multi-system event system, or whatever
287:                 **
288:                 ** Revision 1.42  2000/10/28 15:16:24  matt
289:                 ** removed nsf_init
290:                 **
291:                 ** Revision 1.41  2000/10/27 12:58:44  matt
292:                 ** gui_init can now fail
293:                 **
294:                 ** Revision 1.40  2000/10/26 22:48:57  matt
295:                 ** prelim NSF support
296:                 **
297:                 ** Revision 1.39  2000/10/25 13:42:02  matt
298:                 ** strdup - giddyap!
299:                 **
300:                 ** Revision 1.38  2000/10/25 01:23:08  matt
301:                 ** basic system autodetection
302:                 **
303:                 ** Revision 1.37  2000/10/23 17:50:47  matt
304:                 ** adding fds support
305:                 **
306:                 ** Revision 1.36  2000/10/23 15:52:04  matt
307:                 ** better system handling
308:                 **
309:                 ** Revision 1.35  2000/10/21 19:25:59  matt
310:                 ** many more cleanups
311:                 **
312:                 ** Revision 1.34  2000/10/10 13:58:13  matt
313:                 ** stroustrup squeezing his way in the door
314:                 **
315:                 ** Revision 1.33  2000/10/10 13:03:54  matt
316:                 ** Mr. Clean makes a guest appearance
317:                 **
318:                 ** Revision 1.32  2000/09/15 04:58:06  matt
319:                 ** simplifying and optimizing APU core
320:                 **
321:                 ** Revision 1.31  2000/09/10 23:19:14  matt
322:                 ** i'm a sloppy coder
323:                 **
324:                 ** Revision 1.30  2000/09/07 01:30:57  matt
325:                 ** nes6502_init deprecated
326:                 **
327:                 ** Revision 1.29  2000/08/16 03:17:49  matt
328:                 ** bpb
329:                 **
330:                 ** Revision 1.28  2000/08/16 02:58:19  matt
331:                 ** changed video interface a wee bit
332:                 **
333:                 ** Revision 1.27  2000/07/31 04:28:46  matt
334:                 ** one million cleanups
335:                 **
336:                 ** Revision 1.26  2000/07/30 04:31:26  matt
337:                 ** automagic loading of the nofrendo intro
338:                 **
339:                 ** Revision 1.25  2000/07/27 01:16:36  matt
340:                 ** sorted out the video problems
341:                 **
342:                 ** Revision 1.24  2000/07/26 21:54:53  neil
343:                 ** eject has to clear the nextfilename and nextsystem
344:                 **
345:                 ** Revision 1.23  2000/07/26 21:36:13  neil
346:                 ** Big honkin' change -- see the mailing list
347:                 **
348:                 ** Revision 1.22  2000/07/25 02:21:36  matt
349:                 ** safer xxx_destroy calls
350:                 **
351:                 ** Revision 1.21  2000/07/23 16:46:47  matt
352:                 ** fixed crash in win32 by reodering shutdown calls
353:                 **
354:                 ** Revision 1.20  2000/07/23 15:18:23  matt
355:                 ** removed unistd.h from includes
356:                 **
357:                 ** Revision 1.19  2000/07/23 00:48:15  neil
358:                 ** Win32 SDL
359:                 **
360:                 ** Revision 1.18  2000/07/21 13:42:06  neil
361:                 ** get_options removed, as it should be handled by osd_main
362:                 **
363:                 ** Revision 1.17  2000/07/21 04:53:48  matt
364:                 ** moved palette calls out of nofrendo.c and into ppu_create
365:                 **
366:                 ** Revision 1.16  2000/07/21 02:40:43  neil
367:                 ** more main fixes
368:                 **
369:                 ** Revision 1.15  2000/07/21 02:09:07  neil
370:                 ** new main structure?
371:                 **
372:                 ** Revision 1.14  2000/07/20 17:05:12  neil
373:                 ** Moved osd_init before setup_video
374:                 **
375:                 ** Revision 1.13  2000/07/11 15:01:05  matt
376:                 ** moved config.close() into registered atexit() routine
377:                 **
378:                 ** Revision 1.12  2000/07/11 13:35:38  bsittler
379:                 ** Changed the config API, implemented config file "nofrendo.cfg". The
380:                 ** GGI drivers use the group [GGI]. Visual= and Mode= keys are understood.
381:                 **
382:                 ** Revision 1.11  2000/07/11 04:32:21  matt
383:                 ** less magic number nastiness for screen dimensions
384:                 **
385:                 ** Revision 1.10  2000/07/10 03:04:15  matt
386:                 ** removed scanlines, backbuffer from custom blit
387:                 **
388:                 ** Revision 1.9  2000/07/07 04:39:54  matt
389:                 ** removed garbage dpp shite
390:                 **
391:                 ** Revision 1.8  2000/07/06 16:48:25  matt
392:                 ** new video driver
393:                 **
394:                 ** Revision 1.7  2000/07/05 17:26:16  neil
395:                 ** Moved the externs in nofrendo.c to osd.h
396:                 **
397:                 ** Revision 1.6  2000/06/26 04:55:44  matt
398:                 ** cleaned up main()
399:                 **
400:                 ** Revision 1.5  2000/06/20 20:41:21  matt
401:                 ** moved <stdlib.h> include to top (duh)
402:                 **
403:                 ** Revision 1.4  2000/06/09 15:12:25  matt
404:                 ** initial revision
405:                 **
406:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/nes/nesstate.c  ----------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** nesstate.c
21:                  **
22:                  ** state saving/loading
23:                  ** $Id: nesstate.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <stdio.h>
27:                  #include <string.h>
28:                  #include <noftypes.h>
29:                  #include <nesstate.h>
30:                  #include <gui.h>
31:                  #include <nes.h>
32:                  #include <log.h>
33:                  #include <osd.h>
34:                  #include <libsnss.h>
35:                  #include "nes6502.h"
36:                  
37:                  #define  FIRST_STATE_SLOT  0
38:                  #define  LAST_STATE_SLOT   9
39:                  
40:                  static int state_slot = FIRST_STATE_SLOT;
41:                  
42:                  /* Set the state-save slot to use (0 - 9) */
43:                  void state_setslot(int slot)
44:                  {
9D025998  27BDFFE8   ADDIU SP, SP, -24
9D02599C  AFBF0014   SW RA, 20(SP)
45:                     /* Don't send a message if we're already at that slot */
46:                     if (state_slot != slot && slot >= FIRST_STATE_SLOT
9D0259A0  8F828110   LW V0, -32496(GP)
9D0259A4  10440009   BEQ V0, A0, .LVL2
9D0259A8  00803021   ADDU A2, A0, ZERO
47:                         && slot <= LAST_STATE_SLOT)
9D0259AC  2C82000A   SLTIU V0, A0, 10
9D0259B0  10400007   BEQ V0, ZERO, 0x9D0259D0
9D0259B4  8FBF0014   LW RA, 20(SP)
48:                     {
49:                        state_slot = slot;
9D0259B8  AF848110   SW A0, -32496(GP)
50:                        gui_sendmsg(GUI_WHITE, "State slot set to %d", slot);
9D0259BC  240400C4   ADDIU A0, ZERO, 196
9D0259C0  3C059D04   LUI A1, -25340
9D0259C4  0F409253   JAL gui_sendmsg
9D0259C8  24A5A338   ADDIU A1, A1, -23752
51:                     }
52:                  }
9D0259CC  8FBF0014   LW RA, 20(SP)
9D0259D0  03E00008   JR RA
9D0259D4  27BD0018   ADDIU SP, SP, 24
53:                  
54:                  static int save_baseblock(nes_t *state, SNSS_FILE *snssFile)
55:                  {
56:                     int i;
57:                  
58:                     ASSERT(state);
59:                  
60:                     nes6502_getcontext(state->cpu);
9D025A3C  0F400099   JAL nes6502_getcontext
61:                     ppu_getcontext(state->ppu);
9D025A44  0F4062C8   JAL ppu_getcontext
62:                  
63:                     snssFile->baseBlock.regA = state->cpu->a_reg;
9D025A4C  8E020000   LW V0, 0(S0)
64:                     snssFile->baseBlock.regX = state->cpu->x_reg;
9D025A58  8E020000   LW V0, 0(S0)
65:                     snssFile->baseBlock.regY = state->cpu->y_reg;
9D025A64  8E020000   LW V0, 0(S0)
66:                     snssFile->baseBlock.regFlags = state->cpu->p_reg;
9D025A70  8E020000   LW V0, 0(S0)
67:                     snssFile->baseBlock.regStack = state->cpu->s_reg;
9D025A7C  8E020000   LW V0, 0(S0)
68:                     snssFile->baseBlock.regPc = state->cpu->pc_reg;
9D025A88  8E020000   LW V0, 0(S0)
69:                  
70:                     snssFile->baseBlock.reg2000 = state->ppu->ctrl0;
9D025A94  8E020304   LW V0, 772(S0)
71:                     snssFile->baseBlock.reg2001 = state->ppu->ctrl1;
9D025AA0  8E020304   LW V0, 772(S0)
72:                  
73:                     memcpy(snssFile->baseBlock.cpuRam, state->cpu->mem_page[0], 0x800);
9D025AAC  8E020000   LW V0, 0(S0)
74:                     memcpy(snssFile->baseBlock.spriteRam, state->ppu->oam, 0x100);
9D025B08  8E040304   LW A0, 772(S0)
75:                     memcpy(snssFile->baseBlock.ppuRam, state->ppu->nametab, 0x1000);
9D025B64  8E030304   LW V1, 772(S0)
76:                  
77:                     /* Mask off priority color bits */
78:                     for (i = 0; i < 32; i++)
9D025BBC  00001821   ADDU V1, ZERO, ZERO
9D025BD8  24630001   ADDIU V1, V1, 1
79:                        snssFile->baseBlock.palette[i] = state->ppu->palette[i] & 0x3F;
9D025BC8  8E040304   LW A0, 772(S0)
80:                  
81:                     snssFile->baseBlock.mirrorState[0] = (state->ppu->page[8] + 0x2000 - state->ppu->nametab) / 0x400;
9D025BE4  8E030304   LW V1, 772(S0)
82:                     snssFile->baseBlock.mirrorState[1] = (state->ppu->page[9] + 0x2400 - state->ppu->nametab) / 0x400;
9D025C08  8E030304   LW V1, 772(S0)
83:                     snssFile->baseBlock.mirrorState[2] = (state->ppu->page[10] + 0x2800 - state->ppu->nametab) / 0x400;
9D025C2C  8E030304   LW V1, 772(S0)
84:                     snssFile->baseBlock.mirrorState[3] = (state->ppu->page[11] + 0x2C00 - state->ppu->nametab) / 0x400;
9D025C50  8E030304   LW V1, 772(S0)
85:                  
86:                     snssFile->baseBlock.vramAddress = state->ppu->vaddr;
9D025C74  8E020304   LW V0, 772(S0)
87:                     snssFile->baseBlock.spriteRamAddress = state->ppu->oam_addr;
9D025C80  8E020304   LW V0, 772(S0)
88:                     snssFile->baseBlock.tileXOffset = state->ppu->tile_xofs;
9D025C8C  8E020304   LW V0, 772(S0)
9D025C90  8C42116C   LW V0, 4460(V0)
9D025C94  A2221945   SB V0, 6469(S1)
89:                  
90:                     return 0;
91:                  }
92:                  
93:                  static bool save_vramblock(nes_t *state, SNSS_FILE *snssFile)
94:                  {
95:                     ASSERT(state);
96:                  
97:                     if (NULL == state->rominfo->vram)
9D025CAC  8E020310   LW V0, 784(S0)
9D025CB0  8C43000C   LW V1, 12(V0)
9D025CB4  10600015   BEQ V1, ZERO, 0x9D025D0C
9D025CB8  8FA40010   LW A0, 16(SP)
98:                        return -1;
99:                  
100:                    if (state->rominfo->vram_banks > 2)
9D025CBC  8C45001C   LW A1, 28(V0)
9D025CC0  28A20003   SLTI V0, A1, 3
9D025CC4  54400006   BNEL V0, ZERO, 0x9D025CE0
9D025CC8  00052B40   SLL A1, A1, 13
101:                    {
102:                       log_printf("too many VRAM banks: %d\n", state->rominfo->vram_banks);
9D025CCC  3C049D04   LUI A0, -25340
9D025CD0  0F40F11B   JAL log_printf
9D025CD4  2484A358   ADDIU A0, A0, -23720
103:                       return -1;
104:                    }
105:                 
106:                    snssFile->vramBlock.vramSize = VRAM_8K * state->rominfo->vram_banks;
9D025CE0  30A6FFFF   ANDI A2, A1, -1
9D025CE4  A4861946   SH A2, 6470(A0)
107:                 
108:                    memcpy(snssFile->vramBlock.vram, state->rominfo->vram, snssFile->vramBlock.vramSize);
9D025CE8  8E020310   LW V0, 784(S0)
9D025CEC  24841948   ADDIU A0, A0, 6472
9D025CF0  0F40DBA4   JAL .Letext0, .LFE1, memcpy
9D025CF4  8C45000C   LW A1, 12(V0)
109:                    return 0;
110:                 }
111:                 
112:                 static int save_sramblock(nes_t *state, SNSS_FILE *snssFile)
113:                 {
114:                    int i;
115:                    bool written = false;
116:                    int sram_length;
117:                 
118:                    ASSERT(state);
119:                 
120:                    sram_length = state->rominfo->sram_banks * SRAM_1K;
9D025D10  8E020310   LW V0, 784(S0)
9D025D14  8C450018   LW A1, 24(V0)
9D025D18  00053280   SLL A2, A1, 10
121:                 
122:                    /* Check to see if any SRAM was written to */
123:                    for (i = 0; i < sram_length; i++)
9D025D1C  18C0001F   BLEZ A2, .LBB25
9D025D20  8FB10010   LW S1, 16(SP)
9D025D48  1446FFFC   BNE V0, A2, 0x9D025D3C
9D025D4C  24420001   ADDIU V0, V0, 1
124:                    {
125:                       if (state->rominfo->sram[i])
9D025D24  8C430008   LW V1, 8(V0)
9D025D28  90620000   LBU V0, 0(V1)
9D025D2C  144000AB   BNE V0, ZERO, 0x9D025FDC
9D025D30  24620001   ADDIU V0, V1, 1
9D025D34  0B409752   J 0x9D025D48
9D025D38  00663021   ADDU A2, V1, A2
9D025D3C  9043FFFF   LBU V1, -1(V0)
9D025D40  546000A7   BNEL V1, ZERO, 0x9D025FE0
9D025D44  28A20009   SLTI V0, A1, 9
126:                       {
127:                          written = true;
128:                          break;
129:                       }
130:                    }
131:                 
132:                    if (false == written)
133:                       return -1;
134:                 
135:                    if (state->rominfo->sram_banks > 8)
9D025FDC  28A20009   SLTI V0, A1, 9
9D025FE0  5440FF61   BNEL V0, ZERO, 0x9D025D68
9D025FE4  00052A80   SLL A1, A1, 10
136:                    {
137:                       log_printf("Unsupported number of SRAM banks: %d\n", state->rominfo->sram_banks);
9D025D58  0F40F11B   JAL log_printf
9D025D5C  2484A374   ADDIU A0, A0, -23692
9D025FE8  0B409756   J 0x9D025D58
9D025FEC  3C049D04   LUI A0, -25340
138:                       return -1;
139:                    }
140:                 
141:                    snssFile->sramBlock.sramSize = SRAM_1K * state->rominfo->sram_banks;
9D025D68  30A6FFFF   ANDI A2, A1, -1
9D025D6C  A4865948   SH A2, 22856(A0)
142:                 
143:                    /* TODO: this should not always be true!! */
144:                    snssFile->sramBlock.sramEnabled = true;
9D025D70  24020001   ADDIU V0, ZERO, 1
9D025D74  A082594A   SB V0, 22858(A0)
145:                 
146:                    memcpy(snssFile->sramBlock.sram, state->rominfo->sram, snssFile->sramBlock.sramSize);
9D025D78  8E020310   LW V0, 784(S0)
9D025D7C  2484594B   ADDIU A0, A0, 22859
9D025D80  0F40DBA4   JAL .Letext0, .LFE1, memcpy
9D025D84  8C450008   LW A1, 8(V0)
147:                 
148:                    return 0;
149:                 }
150:                 
151:                 static int save_soundblock(nes_t *state, SNSS_FILE *snssFile)
152:                 {
153:                    ASSERT(state);
154:                 
155:                    apu_getcontext(state->apu);
9D025D9C  0F407892   JAL apu_getcontext
156:                 
157:                    /* rect 0 */
158:                    snssFile->soundBlock.soundRegisters[0x00] = state->apu->rectangle[0].regs[0];
9D025DA4  8E020308   LW V0, 776(S0)
159:                    snssFile->soundBlock.soundRegisters[0x01] = state->apu->rectangle[0].regs[1];
9D025DB0  8E020308   LW V0, 776(S0)
160:                    snssFile->soundBlock.soundRegisters[0x02] = state->apu->rectangle[0].regs[2];
9D025DBC  8E020308   LW V0, 776(S0)
161:                    snssFile->soundBlock.soundRegisters[0x03] = state->apu->rectangle[0].regs[3];
9D025DC8  8E020308   LW V0, 776(S0)
162:                    /* rect 1 */
163:                    snssFile->soundBlock.soundRegisters[0x04] = state->apu->rectangle[1].regs[0];
9D025DD4  8E020308   LW V0, 776(S0)
164:                    snssFile->soundBlock.soundRegisters[0x05] = state->apu->rectangle[1].regs[1];
9D025DE0  8E020308   LW V0, 776(S0)
165:                    snssFile->soundBlock.soundRegisters[0x06] = state->apu->rectangle[1].regs[2];
9D025DEC  8E020308   LW V0, 776(S0)
166:                    snssFile->soundBlock.soundRegisters[0x07] = state->apu->rectangle[1].regs[3];
9D025DF8  8E020308   LW V0, 776(S0)
167:                    /* triangle */
168:                    snssFile->soundBlock.soundRegisters[0x08] = state->apu->triangle.regs[0];
9D025E04  8E020308   LW V0, 776(S0)
169:                    snssFile->soundBlock.soundRegisters[0x0A] = state->apu->triangle.regs[1];
9D025E10  8E020308   LW V0, 776(S0)
170:                    snssFile->soundBlock.soundRegisters[0x0B] = state->apu->triangle.regs[2];
9D025E1C  8E020308   LW V0, 776(S0)
171:                    /* noise */
172:                    snssFile->soundBlock.soundRegisters[0X0C] = state->apu->noise.regs[0];
9D025E28  8E020308   LW V0, 776(S0)
173:                    snssFile->soundBlock.soundRegisters[0X0E] = state->apu->noise.regs[1];
9D025E34  8E020308   LW V0, 776(S0)
174:                    snssFile->soundBlock.soundRegisters[0x0F] = state->apu->noise.regs[2];
9D025E40  8E020308   LW V0, 776(S0)
175:                    /* dmc */
176:                    snssFile->soundBlock.soundRegisters[0x10] = state->apu->dmc.regs[0];
9D025E4C  8E020308   LW V0, 776(S0)
177:                    snssFile->soundBlock.soundRegisters[0x11] = state->apu->dmc.regs[1];
9D025E58  8E020308   LW V0, 776(S0)
178:                    snssFile->soundBlock.soundRegisters[0x12] = state->apu->dmc.regs[2];
9D025E64  8E020308   LW V0, 776(S0)
179:                    snssFile->soundBlock.soundRegisters[0x13] = state->apu->dmc.regs[3];
9D025E70  8E020308   LW V0, 776(S0)
180:                    /* control */
181:                    snssFile->soundBlock.soundRegisters[0x15] = state->apu->enable_reg;
9D025E7C  8E020308   LW V0, 776(S0)
182:                 
183:                    return 0;
184:                 }
185:                 
186:                 static int save_mapperblock(nes_t *state, SNSS_FILE *snssFile)
187:                 {
188:                    int i;
189:                    ASSERT(state);
190:                 
191:                    mmc_getcontext(state->mmc);
9D025E9C  0F40B416   JAL mmc_getcontext
9D025EA0  8E04030C   LW A0, 780(S0)
192:                 
193:                    /* TODO: filthy hack in snss standard */
194:                    /* We don't need to write mapper state for mapper 0 */
195:                    if (0 == state->mmc->intf->number)
9D025EA4  8E02030C   LW V0, 780(S0)
9D025EA8  8C420000   LW V0, 0(V0)
9D025EAC  8C420000   LW V0, 0(V0)
9D025EB0  10400035   BEQ V0, ZERO, 0x9D025F88
9D025EB4  00000000   NOP
196:                       return -1;
197:                 
198:                    nes6502_getcontext(state->cpu);
9D025EB8  0F400099   JAL nes6502_getcontext
9D025EBC  8E040000   LW A0, 0(S0)
9D025EC0  24020008   ADDIU V0, ZERO, 8
199:                 
200:                    /* TODO: snss spec should be updated, using 4kB ROM pages.. */
201:                    for (i = 0; i < 4; i++)
9D025EC4  24060010   ADDIU A2, ZERO, 16
9D025EC8  02621821   ADDU V1, S3, V0
9D025EF0  1446FFF5   BNE V0, A2, 0x9D025EC8
9D025EF4  A4647944   SH A0, 31044(V1)
202:                       snssFile->mapperBlock.prgPages[i] = (state->cpu->mem_page[(i + 4) * 2] - state->rominfo->rom) >> 13;
9D025ECC  8E050000   LW A1, 0(S0)
9D025ED0  00022080   SLL A0, V0, 2
9D025ED4  00A42821   ADDU A1, A1, A0
9D025ED8  8E040310   LW A0, 784(S0)
9D025EDC  8CA50000   LW A1, 0(A1)
9D025EE0  8C840000   LW A0, 0(A0)
9D025EE4  00A42023   SUBU A0, A1, A0
9D025EE8  00042343   SRA A0, A0, 13
9D025EEC  24420002   ADDIU V0, V0, 2
203:                 
204:                    if (state->rominfo->vrom_banks)
9D025EF8  8E020310   LW V0, 784(S0)
9D025EFC  8C420014   LW V0, 20(V0)
9D025F00  10400012   BEQ V0, ZERO, 0x9D025F4C
9D025F04  02601821   ADDU V1, S3, ZERO
9D025F08  02609021   ADDU S2, S3, ZERO
9D025F0C  00008821   ADDU S1, ZERO, ZERO
9D025F4C  00001021   ADDU V0, ZERO, ZERO
205:                    {
206:                       for (i = 0; i < 8; i++)
9D025F10  24140008   ADDIU S4, ZERO, 8
9D025F38  26310001   ADDIU S1, S1, 1
9D025F3C  1634FFF5   BNE S1, S4, 0x9D025F14
9D025F40  26520002   ADDIU S2, S2, 2
207:                          snssFile->mapperBlock.chrPages[i] = (ppu_getpage(i) - state->rominfo->vrom + (i * 0x400)) >> 10;
9D025F14  0F406378   JAL ppu_getpage
9D025F18  02202021   ADDU A0, S1, ZERO
9D025F1C  00111A80   SLL V1, S1, 10
9D025F20  8E040310   LW A0, 784(S0)
9D025F24  8C850004   LW A1, 4(A0)
9D025F28  00451023   SUBU V0, V0, A1
9D025F2C  00621821   ADDU V1, V1, V0
9D025F30  00031A83   SRA V1, V1, 10
9D025F34  A6437954   SH V1, 31060(S2)
208:                    }
209:                    else
210:                    {
211:                       /* bleh! slight hack */
212:                       for (i = 0; i < 8; i++)
9D025F50  24040008   ADDIU A0, ZERO, 8
9D025F58  24420001   ADDIU V0, V0, 1
9D025F5C  1444FFFD   BNE V0, A0, 0x9D025F54
9D025F60  24630002   ADDIU V1, V1, 2
213:                          snssFile->mapperBlock.chrPages[i] = i;
9D025F54  A4627954   SH V0, 31060(V1)
214:                    }
215:                 
216:                    if (state->mmc->intf->get_state)
9D025F44  0B4097DA   J 0x9D025F68
9D025F48  8E02030C   LW V0, 780(S0)
9D025F64  8E02030C   LW V0, 780(S0)
9D025F68  8C420000   LW V0, 0(V0)
9D025F6C  8C420014   LW V0, 20(V0)
9D025F70  5040001F   BEQL V0, ZERO, 0x9D025FF0
9D025F74  8FA40010   LW A0, 16(SP)
217:                       state->mmc->intf->get_state(&snssFile->mapperBlock);
9D025F78  0040F809   JALR V0
9D025F7C  2664794C   ADDIU A0, S3, 31052
218:                 
219:                    return 0;
220:                 }
221:                 
222:                 static void load_baseblock(nes_t *state, SNSS_FILE *snssFile)
223:                 {
224:                    int i;
225:                    
226:                    ASSERT(state);
227:                 
228:                    nes6502_getcontext(state->cpu);
9D026118  0F400099   JAL nes6502_getcontext
229:                    ppu_getcontext(state->ppu);
9D026120  0F4062C8   JAL ppu_getcontext
230:                 
231:                    state->cpu->a_reg = snssFile->baseBlock.regA;
9D026128  8E220000   LW V0, 0(S1)
232:                    state->cpu->x_reg = snssFile->baseBlock.regX;
9D026134  8E220000   LW V0, 0(S1)
233:                    state->cpu->y_reg = snssFile->baseBlock.regY;
9D026140  8E220000   LW V0, 0(S1)
234:                    state->cpu->p_reg = snssFile->baseBlock.regFlags;
9D02614C  8E220000   LW V0, 0(S1)
235:                    state->cpu->s_reg = snssFile->baseBlock.regStack;
9D026158  8E220000   LW V0, 0(S1)
236:                    state->cpu->pc_reg = snssFile->baseBlock.regPc;
9D026164  8E220000   LW V0, 0(S1)
237:                 
238:                    state->ppu->ctrl0 = snssFile->baseBlock.reg2000;
9D026170  8E220304   LW V0, 772(S1)
239:                    state->ppu->ctrl1 = snssFile->baseBlock.reg2001;
9D02617C  8E220304   LW V0, 772(S1)
240:                 
241:                    memcpy(state->cpu->mem_page[0], snssFile->baseBlock.cpuRam, 0x800);
9D026188  8E220000   LW V0, 0(S1)
242:                    memcpy(state->ppu->oam, snssFile->baseBlock.spriteRam, 0x100);
9D0261E4  8E220304   LW V0, 772(S1)
243:                    memcpy(state->ppu->nametab, snssFile->baseBlock.ppuRam, 0x1000);
9D026240  2603091E   ADDIU V1, S0, 2334
244:                    memcpy(state->ppu->palette, snssFile->baseBlock.palette, 0x20);
9D026298  8E2B0304   LW T3, 772(S1)
245:                 
246:                    /* TODO: argh, this is to handle nofrendo's filthy sprite priority method */
247:                    for (i = 0; i < 8; i++)
9D026324  00001021   ADDU V0, ZERO, ZERO
9D02632C  24050008   ADDIU A1, ZERO, 8
9D026344  24420001   ADDIU V0, V0, 1
248:                       state->ppu->palette[i << 2] = state->ppu->palette[0] | 0x80;//BG_TRANS_MASK;
9D026328  2406FF80   ADDIU A2, ZERO, -128
9D026330  8E230304   LW V1, 772(S1)
249:                 
250:                    for (i = 0; i < 4; i++)
9D026358  2407000C   ADDIU A3, ZERO, 12
9D026398  1447FFF0   BNE V0, A3, 0x9D02635C
251:                    {
252:                       state->ppu->page[i + 8] = state->ppu->page[i + 12] =
9D026374  2446044C   ADDIU A2, V0, 1100
253:                          state->ppu->nametab + (snssFile->baseBlock.mirrorState[i] * 0x400) - (0x2000 + (i * 0x400));
9D02635C  8E230304   LW V1, 772(S1)
254:                    }
255:                 
256:                    state->ppu->vaddr = snssFile->baseBlock.vramAddress;
9D0263A0  8E220304   LW V0, 772(S1)
257:                    state->ppu->oam_addr = snssFile->baseBlock.spriteRamAddress;
9D0263AC  8E220304   LW V0, 772(S1)
258:                    state->ppu->tile_xofs = snssFile->baseBlock.tileXOffset;
9D0263B8  8E220304   LW V0, 772(S1)
259:                 
260:                    /* do some extra handling */
261:                    state->ppu->flipflop = 0;
9D0263C4  8E220304   LW V0, 772(S1)
262:                    state->ppu->strikeflag = false;
9D0263CC  8E220304   LW V0, 772(S1)
263:                 
264:                    nes6502_setcontext(state->cpu);
9D0263D4  0F400073   JAL nes6502_setcontext
265:                    ppu_setcontext(state->ppu);
9D0263DC  0F40628D   JAL ppu_setcontext
266:                 
267:                    ppu_write(PPU_CTRL0, state->ppu->ctrl0);
9D0263E4  8E220304   LW V0, 772(S1)
268:                    ppu_write(PPU_CTRL1, state->ppu->ctrl1);
9D0263F4  8E220304   LW V0, 772(S1)
269:                    ppu_write(PPU_VADDR, (uint8) (state->ppu->vaddr >> 8));
9D026404  8E220304   LW V0, 772(S1)
270:                    ppu_write(PPU_VADDR, (uint8) (state->ppu->vaddr & 0xFF));
9D026414  8E220304   LW V0, 772(S1)
9D026418  24042006   ADDIU A0, ZERO, 8198
9D02641C  0F406484   JAL ppu_write
9D026420  90451164   LBU A1, 4452(V0)
271:                 }
272:                 
273:                 static void load_vramblock(nes_t *state, SNSS_FILE *snssFile)
274:                 {
275:                    ASSERT(state);
276:                 
277:                    ASSERT(snssFile->vramBlock.vramSize <= VRAM_8K); /* can't handle more than this! */
278:                    memcpy(state->rominfo->vram, snssFile->vramBlock.vram, snssFile->vramBlock.vramSize);
9D026430  8E230310   LW V1, 784(S1)
9D026434  8C64000C   LW A0, 12(V1)
9D026438  24451948   ADDIU A1, V0, 6472
9D02643C  0F40DBA4   JAL .Letext0, .LFE1, memcpy
9D026440  94461946   LHU A2, 6470(V0)
279:                 }
280:                 
281:                 static void load_sramblock(nes_t *state, SNSS_FILE *snssFile)
282:                 {
283:                    ASSERT(state);
284:                 
285:                    ASSERT(snssFile->sramBlock.sramSize <= SRAM_8K); /* can't handle more than this! */
286:                    memcpy(state->rominfo->sram, snssFile->sramBlock.sram, snssFile->sramBlock.sramSize);
9D026450  8E230310   LW V1, 784(S1)
9D026454  8C640008   LW A0, 8(V1)
9D026458  2445594B   ADDIU A1, V0, 22859
9D02645C  0F40DBA4   JAL .Letext0, .LFE1, memcpy
9D026460  94465948   LHU A2, 22856(V0)
287:                 }
288:                 
289:                 static void load_controllerblock(nes_t *state, SNSS_FILE *snssFile)
290:                 {
291:                    UNUSED(state);
292:                    UNUSED(snssFile);
293:                 }
294:                 
295:                 static void load_soundblock(nes_t *state, SNSS_FILE *snssFile)
296:                 {
297:                    int i;
298:                 
299:                    ASSERT(state);
300:                 
301:                    for (i = 0; i < 0x15; i++)
9D026554  2A020015   SLTI V0, S0, 21
302:                    {
303:                       if (i != 0x13) /* do NOT trigger OAM DMA! */
9D026534  0B409950   J .LBB52, .LBB53
9D026538  24120014   ADDIU S2, ZERO, 20
9D02653C  26100001   ADDIU S0, S0, 1
9D026540  1212FFFE   BEQ S0, S2, 0x9D02653C
9D026544  02701021   ADDU V0, S3, S0
304:                          apu_write(0x4000 + i, snssFile->soundBlock.soundRegisters[i]);
9D026548  26043FFF   ADDIU A0, S0, 16383
9D02654C  0F4078B8   JAL apu_write
9D026550  904579E4   LBU A1, 31204(V0)
9D026554  2A020015   SLTI V0, S0, 21
9D026558  5440FFF9   BNEL V0, ZERO, .LBB52, .LBB53
9D02655C  26100001   ADDIU S0, S0, 1
305:                    }
306:                 }
307:                 
308:                 /* TODO: magic numbers galore */
309:                 static void load_mapperblock(nes_t *state, SNSS_FILE *snssFile)
310:                 {
311:                    int i;
312:                    
313:                    ASSERT(state);
314:                 
315:                    mmc_getcontext(state->mmc);
9D026470  0F40B416   JAL mmc_getcontext
9D026474  8E24030C   LW A0, 780(S1)
9D026478  02609021   ADDU S2, S3, ZERO
9D02647C  34108000   ORI S0, ZERO, -32768
316:                 
317:                    for (i = 0; i < 4; i++)
9D026480  3C170001   LUI S7, 1
9D026498  1617FFFA   BNE S0, S7, 0x9D026484
9D02649C  26520002   ADDIU S2, S2, 2
318:                       mmc_bankrom(8, 0x8000 + (i * 0x2000), snssFile->mapperBlock.prgPages[i]);
9D026484  24040008   ADDIU A0, ZERO, 8
9D026488  02002821   ADDU A1, S0, ZERO
9D02648C  0F40B479   JAL mmc_bankrom
9D026490  9646794C   LHU A2, 31052(S2)
9D026494  26102000   ADDIU S0, S0, 8192
319:                 
320:                    if (state->rominfo->vrom_banks)
9D0264A0  8E220310   LW V0, 784(S1)
9D0264A4  8C420014   LW V0, 20(V0)
9D0264A8  1040000C   BEQ V0, ZERO, 0x9D0264DC
9D0264AC  00008021   ADDU S0, ZERO, ZERO
321:                    {
322:                       for (i = 0; i < 8; i++)
9D0264B0  24120010   ADDIU S2, ZERO, 16
9D0264B4  02701021   ADDU V0, S3, S0
9D0264CC  5612FFFA   BNEL S0, S2, 0x9D0264B8
9D0264D0  02701021   ADDU V0, S3, S0
323:                          mmc_bankvrom(1, i * 0x400, snssFile->mapperBlock.chrPages[i]);
9D0264B8  24040001   ADDIU A0, ZERO, 1
9D0264BC  00102A40   SLL A1, S0, 9
9D0264C0  0F40B41B   JAL mmc_bankvrom
9D0264C4  94467954   LHU A2, 31060(V0)
9D0264C8  26100002   ADDIU S0, S0, 2
324:                    }
325:                    else
326:                    {
327:                       ASSERT(state->rominfo->vram);
328:                 
329:                       for (i = 0; i < 8; i++)
9D0264DC  24120008   ADDIU S2, ZERO, 8
9D0264F4  26100001   ADDIU S0, S0, 1
9D0264F8  5612FFFA   BNEL S0, S2, 0x9D0264E4
9D0264FC  8E220310   LW V0, 784(S1)
330:                          ppu_setpage(1, i, state->rominfo->vram);
9D0264E0  8E220310   LW V0, 784(S1)
9D0264E4  24040001   ADDIU A0, ZERO, 1
9D0264E8  02002821   ADDU A1, S0, ZERO
9D0264EC  0F406314   JAL ppu_setpage
9D0264F0  8C46000C   LW A2, 12(V0)
331:                    }
332:                 
333:                    if (state->mmc->intf->set_state)
9D0264D4  0B409941   J 0x9D026504
9D0264D8  8E22030C   LW V0, 780(S1)
9D026500  8E22030C   LW V0, 780(S1)
9D026504  8C420000   LW V0, 0(V0)
9D026508  8C420018   LW V0, 24(V0)
9D02650C  10400003   BEQ V0, ZERO, .LVL108
9D026510  00000000   NOP
334:                       state->mmc->intf->set_state(&snssFile->mapperBlock);
9D026514  0040F809   JALR V0
9D026518  2664794C   ADDIU A0, S3, 31052
335:                 
336:                    mmc_setcontext(state->mmc);
9D02651C  0F40B411   JAL mmc_setcontext
9D026520  8E24030C   LW A0, 780(S1)
337:                 }
338:                 
339:                 
340:                 int state_save(void)
341:                 {
9D0259D8  27BDFDC8   ADDIU SP, SP, -568
9D0259DC  AFBF0234   SW RA, 564(SP)
9D0259E0  AFB40230   SW S4, 560(SP)
9D0259E4  AFB3022C   SW S3, 556(SP)
9D0259E8  AFB20228   SW S2, 552(SP)
9D0259EC  AFB10224   SW S1, 548(SP)
342:                    SNSS_FILE *snssFile;
343:                    SNSS_RETURN_CODE status;
344:                    char fn[PATH_MAX + 1], ext[5];
345:                    nes_t *machine;
346:                 
347:                    /* get the pointer to our NES machine context */
348:                    machine = nes_getcontextptr();
9D0259F0  0F408D03   JAL nes_getcontextptr
9D0259F4  AFB00220   SW S0, 544(SP)
9D0259F8  00408021   ADDU S0, V0, ZERO
349:                    ASSERT(machine);
350:                    
351:                    /* build our filename using the image's name and the slot number */
352:                    strncpy(fn, machine->rominfo->filename, PATH_MAX - 4);
9D0259FC  8C450310   LW A1, 784(V0)
9D025A00  27A40014   ADDIU A0, SP, 20
9D025A04  24A50029   ADDIU A1, A1, 41
9D025A08  0F40E397   JAL .LFE23, strncpy
9D025A0C  240601FC   ADDIU A2, ZERO, 508
353:                    
354:                    ASSERT(state_slot >= FIRST_STATE_SLOT && state_slot <= LAST_STATE_SLOT);
355:                    sprintf(ext, ".ss%d", state_slot);
9D025A10  27A40218   ADDIU A0, SP, 536
9D025A14  3C059D04   LUI A1, -25340
9D025A18  24A5A350   ADDIU A1, A1, -23728
9D025A1C  0F40EDE4   JAL _sprintf_cdnopuxX, _sprintf_cdnopsuxX
9D025A20  8F868110   LW A2, -32496(GP)
356:                    //osd_newextension(fn, ext);
357:                 
358:                    /* open our state file for writing */
359:                    status = SNSS_OpenFile(&snssFile, fn, SNSS_OPEN_WRITE);
9D025A24  27A40010   ADDIU A0, SP, 16
9D025A28  27A50014   ADDIU A1, SP, 20
9D025A2C  0F408649   JAL SNSS_OpenFile
9D025A30  24060001   ADDIU A2, ZERO, 1
360:                    if (SNSS_OK != status)
9D025A34  1440015E   BNE V0, ZERO, .L6
9D025A38  8FB10010   LW S1, 16(SP)
361:                       goto _error;
362:                 
363:                    /* now get all of our blocks */
364:                    if (0 == save_baseblock(machine, snssFile))
365:                    {
366:                       status = SNSS_WriteBlock(snssFile, SNSS_BASR);
9D025C98  8FA40010   LW A0, 16(SP)
9D025C9C  0F4087E9   JAL SNSS_WriteBlock
9D025CA0  00002821   ADDU A1, ZERO, ZERO
367:                       if (SNSS_OK != status)
9D025CA4  144000C2   BNE V0, ZERO, .L6
9D025CA8  00000000   NOP
368:                          goto _error;
369:                    }
370:                 
371:                    if (0 == save_vramblock(machine, snssFile))
372:                    {
373:                       status = SNSS_WriteBlock(snssFile, SNSS_VRAM);
9D025CF8  8FA40010   LW A0, 16(SP)
9D025CFC  0F4087E9   JAL SNSS_WriteBlock
9D025D00  24050001   ADDIU A1, ZERO, 1
374:                       if (SNSS_OK != status)
9D025D04  144000AA   BNE V0, ZERO, .L6
9D025D08  00000000   NOP
375:                          goto _error;
376:                    }
377:                 
378:                    if (0 == save_sramblock(machine, snssFile))
9D025CD8  0B409744   J .LBB18
9D025CDC  8FA40010   LW A0, 16(SP)
9D025D0C  8FA40010   LW A0, 16(SP)
379:                    {
380:                       status = SNSS_WriteBlock(snssFile, SNSS_SRAM);
9D025D88  8FA40010   LW A0, 16(SP)
9D025D8C  0F4087E9   JAL SNSS_WriteBlock
9D025D90  24050002   ADDIU A1, ZERO, 2
381:                       if (SNSS_OK != status)
9D025D94  14400086   BNE V0, ZERO, .L6
9D025D98  8FB10010   LW S1, 16(SP)
382:                          goto _error;
383:                    }
384:                 
385:                    if (0 == save_soundblock(machine, snssFile))
9D025D50  0B409767   J .LBB25
9D025D54  8FB10010   LW S1, 16(SP)
9D025D60  0B409767   J .LBB25
9D025D64  8FB10010   LW S1, 16(SP)
386:                    {
387:                       status = SNSS_WriteBlock(snssFile, SNSS_SOUN);
9D025E88  8FA40010   LW A0, 16(SP)
9D025E8C  0F4087E9   JAL SNSS_WriteBlock
9D025E90  24050005   ADDIU A1, ZERO, 5
388:                       if (SNSS_OK != status)
9D025E94  14400046   BNE V0, ZERO, .L6
9D025E98  8FB30010   LW S3, 16(SP)
389:                          goto _error;
390:                    }
391:                 
392:                    if (0 == save_mapperblock(machine, snssFile))
393:                    {
394:                       status = SNSS_WriteBlock(snssFile, SNSS_MPRD);
9D025F80  0B4097FC   J 0x9D025FF0
9D025F84  8FA40010   LW A0, 16(SP)
9D025FF0  0F4087E9   JAL SNSS_WriteBlock
9D025FF4  24050003   ADDIU A1, ZERO, 3
395:                       if (SNSS_OK != status)
9D025FF8  1040FFE3   BEQ V0, ZERO, 0x9D025F88
9D025FFC  00000000   NOP
9D026000  0B4097EC   J .L6
9D026004  00000000   NOP
396:                          goto _error;
397:                    }
398:                 
399:                    /* close the file, we're done */
400:                    status = SNSS_CloseFile(&snssFile);
9D025F88  0F4086A1   JAL SNSS_CloseFile
9D025F8C  27A40010   ADDIU A0, SP, 16
401:                    if (SNSS_OK != status)
9D025F90  14400007   BNE V0, ZERO, .L6
9D025F94  3C059D04   LUI A1, -25340
402:                       goto _error;
403:                 
404:                    gui_sendmsg(GUI_GREEN, "State %d saved", state_slot);
9D025F98  240400C6   ADDIU A0, ZERO, 198
9D025F9C  24A5A39C   ADDIU A1, A1, -23652
9D025FA0  0F409253   JAL gui_sendmsg
9D025FA4  8F868110   LW A2, -32496(GP)
405:                    return 0;
9D025FA8  0B409802   J 0x9D026008
9D025FAC  00001021   ADDU V0, ZERO, ZERO
406:                 
407:                 _error:
408:                    gui_sendmsg(GUI_RED, "error: %s", SNSS_GetErrorString(status));
9D025FB0  0F40861D   JAL SNSS_GetErrorString
9D025FB4  00402021   ADDU A0, V0, ZERO
9D025FB8  240400C5   ADDIU A0, ZERO, 197
9D025FBC  3C059D04   LUI A1, -25340
9D025FC0  24A5A3AC   ADDIU A1, A1, -23636
9D025FC4  0F409253   JAL gui_sendmsg
9D025FC8  00403021   ADDU A2, V0, ZERO
409:                    SNSS_CloseFile(&snssFile);
9D025FCC  0F4086A1   JAL SNSS_CloseFile
9D025FD0  27A40010   ADDIU A0, SP, 16
410:                    return -1;
9D025FD4  0B409802   J 0x9D026008
9D025FD8  2402FFFF   ADDIU V0, ZERO, -1
411:                 }
9D026008  8FBF0234   LW RA, 564(SP)
9D02600C  8FB40230   LW S4, 560(SP)
9D026010  8FB3022C   LW S3, 556(SP)
9D026014  8FB20228   LW S2, 552(SP)
9D026018  8FB10224   LW S1, 548(SP)
9D02601C  8FB00220   LW S0, 544(SP)
9D026020  03E00008   JR RA
9D026024  27BD0238   ADDIU SP, SP, 568
412:                 
413:                 int state_load(void)
414:                 {
9D026028  27BDFDB0   ADDIU SP, SP, -592
9D02602C  AFBF024C   SW RA, 588(SP)
9D026030  AFB70248   SW S7, 584(SP)
9D026034  AFB60244   SW S6, 580(SP)
9D026038  AFB50240   SW S5, 576(SP)
9D02603C  AFB4023C   SW S4, 572(SP)
9D026040  AFB30238   SW S3, 568(SP)
9D026044  AFB20234   SW S2, 564(SP)
9D026048  AFB10230   SW S1, 560(SP)
415:                    SNSS_FILE *snssFile;
416:                    SNSS_RETURN_CODE status;
417:                    SNSS_BLOCK_TYPE block_type;
418:                    char fn[PATH_MAX + 1], ext[5];
419:                    unsigned int i;
420:                    nes_t *machine;
421:                 
422:                    /* get our machine's context pointer */
423:                    machine = nes_getcontextptr();
9D02604C  0F408D03   JAL nes_getcontextptr
9D026050  AFB0022C   SW S0, 556(SP)
9D026054  00408821   ADDU S1, V0, ZERO
424:                    ASSERT(machine);
425:                 
426:                    /* build the state name using the ROM's name and the slot number */
427:                    strncpy(fn, machine->rominfo->filename, PATH_MAX - 4);
9D026058  8C450310   LW A1, 784(V0)
9D02605C  27A40018   ADDIU A0, SP, 24
9D026060  24A50029   ADDIU A1, A1, 41
9D026064  0F40E397   JAL .LFE23, strncpy
9D026068  240601FC   ADDIU A2, ZERO, 508
428:                 
429:                    ASSERT(state_slot >= FIRST_STATE_SLOT && state_slot <= LAST_STATE_SLOT);
430:                    sprintf(ext, ".ss%d", state_slot);
9D02606C  27A4021C   ADDIU A0, SP, 540
9D026070  3C059D04   LUI A1, -25340
9D026074  24A5A350   ADDIU A1, A1, -23728
9D026078  0F40EDE4   JAL _sprintf_cdnopuxX, _sprintf_cdnopsuxX
9D02607C  8F868110   LW A2, -32496(GP)
431:                    //osd_newextension(fn, ext);
432:                    
433:                    /* open our file for writing */
434:                    status = SNSS_OpenFile(&snssFile, fn, SNSS_OPEN_READ);
9D026080  27A40010   ADDIU A0, SP, 16
9D026084  27A50018   ADDIU A1, SP, 24
9D026088  0F408649   JAL SNSS_OpenFile
9D02608C  00003021   ADDU A2, ZERO, ZERO
435:                    if (SNSS_OK != status)
9D026090  14400147   BNE V0, ZERO, .L43
9D026094  8FA50010   LW A1, 16(SP)
436:                       goto _error;
437:                 
438:                    /* iterate through all present blocks */
439:                    for (i = 0; i < snssFile->headerBlock.numberOfBlocks; i++)
9D026098  8CA20010   LW V0, 16(A1)
9D02609C  1040013A   BEQ V0, ZERO, 0x9D026588
9D0260A0  0000A021   ADDU S4, ZERO, ZERO
9D026424  0B40995D   J 0x9D026574
9D026428  26940001   ADDIU S4, S4, 1
9D026444  0B40995D   J 0x9D026574
9D026448  26940001   ADDIU S4, S4, 1
9D026464  0B40995D   J 0x9D026574
9D026468  26940001   ADDIU S4, S4, 1
9D026524  0B40995D   J 0x9D026574
9D026528  26940001   ADDIU S4, S4, 1
9D026560  0B40995D   J 0x9D026574
9D026564  26940001   ADDIU S4, S4, 1
9D026570  26940001   ADDIU S4, S4, 1
9D026574  8FA50010   LW A1, 16(SP)
9D026578  8CA20010   LW V0, 16(A1)
9D02657C  0282102B   SLTU V0, S4, V0
9D026580  1440FECC   BNE V0, ZERO, 0x9D0260B4
9D026584  00000000   NOP
440:                    {
441:                       status = SNSS_GetNextBlockType(&block_type, snssFile);
9D0260B4  0F4086CE   JAL SNSS_GetNextBlockType
9D0260B8  27A40014   ADDIU A0, SP, 20
442:                       if (SNSS_OK != status)
9D0260BC  1440013C   BNE V0, ZERO, .L43
9D0260C0  00000000   NOP
443:                          goto _error;
444:                 
445:                       status = SNSS_ReadBlock(snssFile, block_type);
9D0260C4  8FA40010   LW A0, 16(SP)
9D0260C8  0F408741   JAL SNSS_ReadBlock
9D0260CC  8FA50014   LW A1, 20(SP)
446:                       if (SNSS_OK != status)
9D0260D0  14400137   BNE V0, ZERO, .L43
9D0260D4  00000000   NOP
447:                          goto _error;
448:                 
449:                       switch (block_type)
9D0260AC  3C159D02   LUI S5, -25342
9D0260B0  26B560FC   ADDIU S5, S5, 24828
9D0260D8  8FA20014   LW V0, 20(SP)
9D0260DC  2C420006   SLTIU V0, V0, 6
9D0260E0  10400121   BEQ V0, ZERO, 0x9D026568
9D0260E4  8FA20014   LW V0, 20(SP)
9D0260E8  00021080   SLL V0, V0, 2
9D0260EC  02A21021   ADDU V0, S5, V0
9D0260F0  8C420000   LW V0, 0(V0)
9D0260F4  00400008   JR V0
9D0260F8  00000000   NOP
450:                       {
451:                       case SNSS_BASR:
452:                          load_baseblock(machine, snssFile);
9D026114  8FB00010   LW S0, 16(SP)
453:                          break;
454:                 
455:                       case SNSS_VRAM:
456:                          load_vramblock(machine, snssFile);
9D02642C  8FA20010   LW V0, 16(SP)
457:                          break;
458:                 
459:                       case SNSS_SRAM:
460:                          load_sramblock(machine, snssFile);
9D02644C  8FA20010   LW V0, 16(SP)
461:                          break;
462:                       
463:                       case SNSS_MPRD:
464:                          load_mapperblock(machine, snssFile);
9D02646C  8FB30010   LW S3, 16(SP)
465:                          break;
466:                       
467:                       case SNSS_CNTR:
468:                          load_controllerblock(machine, snssFile);
469:                          break;
470:                       
471:                       case SNSS_SOUN:
472:                          load_soundblock(machine, snssFile);
9D02652C  8FB30010   LW S3, 16(SP)
9D026530  24100001   ADDIU S0, ZERO, 1
473:                          break;
474:                       
475:                       case SNSS_UNKNOWN_BLOCK:
476:                       default:
477:                          log_printf("unknown SNSS block type\n");
9D0260A4  3C169D04   LUI S6, -25340
9D0260A8  26D6A3B8   ADDIU S6, S6, -23624
9D026568  0F40F11B   JAL log_printf
9D02656C  02C02021   ADDU A0, S6, ZERO
478:                          break;
479:                       }
480:                    }
481:                 
482:                    /* close file, we're done */
483:                    status = SNSS_CloseFile(&snssFile);
9D026588  0F4086A1   JAL SNSS_CloseFile
9D02658C  27A40010   ADDIU A0, SP, 16
484:                    if (SNSS_OK != status)
9D026590  14400007   BNE V0, ZERO, .L43
9D026594  3C059D04   LUI A1, -25340
485:                       goto _error;
486:                 
487:                    gui_sendmsg(GUI_GREEN, "State %d restored", state_slot);
9D026598  240400C6   ADDIU A0, ZERO, 198
9D02659C  24A5A3D4   ADDIU A1, A1, -23596
9D0265A0  0F409253   JAL gui_sendmsg
9D0265A4  8F868110   LW A2, -32496(GP)
488:                 
489:                    return 0;
9D0265A8  0B409976   J 0x9D0265D8
9D0265AC  00001021   ADDU V0, ZERO, ZERO
490:                 
491:                 _error:
492:                    gui_sendmsg(GUI_RED, "error: %s", SNSS_GetErrorString(status));
9D0265B0  0F40861D   JAL SNSS_GetErrorString
9D0265B4  00402021   ADDU A0, V0, ZERO
9D0265B8  240400C5   ADDIU A0, ZERO, 197
9D0265BC  3C059D04   LUI A1, -25340
9D0265C0  24A5A3AC   ADDIU A1, A1, -23636
9D0265C4  0F409253   JAL gui_sendmsg
9D0265C8  00403021   ADDU A2, V0, ZERO
493:                    SNSS_CloseFile(&snssFile);
9D0265CC  0F4086A1   JAL SNSS_CloseFile
9D0265D0  27A40010   ADDIU A0, SP, 16
494:                    return -1;
9D0265D4  2402FFFF   ADDIU V0, ZERO, -1
495:                 }
9D0265D8  8FBF024C   LW RA, 588(SP)
9D0265DC  8FB70248   LW S7, 584(SP)
9D0265E0  8FB60244   LW S6, 580(SP)
9D0265E4  8FB50240   LW S5, 576(SP)
9D0265E8  8FB4023C   LW S4, 572(SP)
9D0265EC  8FB30238   LW S3, 568(SP)
9D0265F0  8FB20234   LW S2, 564(SP)
9D0265F4  8FB10230   LW S1, 560(SP)
9D0265F8  8FB0022C   LW S0, 556(SP)
9D0265FC  03E00008   JR RA
9D026600  27BD0250   ADDIU SP, SP, 592
496:                 
497:                 /*
498:                 ** $Log: nesstate.c,v $
499:                 ** Revision 1.2  2001/04/27 14:37:11  neil
500:                 ** wheeee
501:                 **
502:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
503:                 ** initial
504:                 **
505:                 ** Revision 1.4  2000/11/11 14:52:33  matt
506:                 ** states finally bleepin' work again
507:                 **
508:                 ** Revision 1.3  2000/11/09 14:07:28  matt
509:                 ** state load fixed, state save mostly fixed
510:                 **
511:                 ** Revision 1.2  2000/10/25 00:23:16  matt
512:                 ** makefiles updated for new directory structure
513:                 **
514:                 ** Revision 1.1  2000/10/24 12:20:28  matt
515:                 ** initial revision
516:                 **
517:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/nes/nesinput.c  ----------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** nesinput.c
21:                  **
22:                  ** Event handling system routines
23:                  ** $Id: nesinput.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nesinput.h>
28:                  #include <log.h>
29:                  
30:                  /* TODO: make a linked list of inputs sources, so they
31:                  **       can be removed if need be
32:                  */
33:                  
34:                  static nesinput_t *nes_input[MAX_CONTROLLERS];
35:                  static int active_entries = 0;
36:                  
37:                  /* read counters */
38:                  static int pad0_readcount, pad1_readcount, ppad_readcount, ark_readcount;
39:                  
40:                  
41:                  static int retrieve_type(int type)
42:                  {
43:                     int i, value = 0;
9D0339B8  00001021   ADDU V0, ZERO, ZERO
44:                  
45:                     for (i = 0; i < active_entries; i++)
9D0339A0  8F878108   LW A3, -32504(GP)
9D0339A4  18E0000F   BLEZ A3, 0x9D0339E4
9D0339A8  3C03A001   LUI V1, -24575
9D0339AC  2463AB40   ADDIU V1, V1, -21696
9D0339B0  00073880   SLL A3, A3, 2
9D0339B4  00673821   ADDU A3, V1, A3
9D0339D4  5467FFFA   BNEL V1, A3, 0x9D0339C0
9D0339D8  8C650000   LW A1, 0(V1)
9D0339DC  03E00008   JR RA
9D0339E0  00000000   NOP
46:                     {
47:                        ASSERT(nes_input[i]);
48:                  
49:                        if (type == nes_input[i]->type)
9D0339BC  8C650000   LW A1, 0(V1)
9D0339C0  8CA60000   LW A2, 0(A1)
9D0339C4  14C40003   BNE A2, A0, 0x9D0339D4
9D0339C8  24630004   ADDIU V1, V1, 4
50:                           value |= nes_input[i]->data;
9D0339CC  8CA50004   LW A1, 4(A1)
9D0339D0  00451025   OR V0, V0, A1
51:                     }
52:                  
53:                     return value;
54:                  }
9D0339E4  03E00008   JR RA
9D0339E8  00001021   ADDU V0, ZERO, ZERO
55:                  
56:                  static uint8 get_pad0(void)
57:                  {
58:                     uint8 value;
59:                  
60:                     value = (uint8) retrieve_type(INP_JOYPAD0);
9D033A0C  0F40CE68   JAL .LFB0, retrieve_type, .Ltext0, .Letext0, .LFE12
61:                  
62:                     /* mask out left/right simultaneous keypresses */
63:                     if ((value & INP_PAD_UP) && (value & INP_PAD_DOWN))
9D033A18  30420030   ANDI V0, V0, 48
64:                        value &= ~(INP_PAD_UP | INP_PAD_DOWN);
9D033A1C  306400CF   ANDI A0, V1, 207
65:                  
66:                     if ((value & INP_PAD_LEFT) && (value & INP_PAD_RIGHT))
9D033A28  30620040   ANDI V0, V1, 64
67:                        value &= ~(INP_PAD_LEFT | INP_PAD_RIGHT);
9D033A38  3062003F   ANDI V0, V1, 63
68:                  
69:                     /* return (0x40 | value) due to bus conflicts */
70:                     return (0x40 | ((value >> pad0_readcount++) & 1));
9D033A44  8F918104   LW S1, -32508(GP)
9D033A48  26220001   ADDIU V0, S1, 1
9D033A4C  AF828104   SW V0, -32508(GP)
9D033A50  02238807   SRAV S1, V1, S1
9D033A54  32310001   ANDI S1, S1, 1
9D033A58  36310040   ORI S1, S1, 64
9D033A5C  323100FF   ANDI S1, S1, 255
71:                  }
72:                  
73:                  static uint8 get_pad1(void)
74:                  {
75:                     uint8 value;
76:                  
77:                     value = (uint8) retrieve_type(INP_JOYPAD1);
9D033A6C  0F40CE68   JAL .LFB0, retrieve_type, .Ltext0, .Letext0, .LFE12
78:                  
79:                     /* mask out left/right simultaneous keypresses */
80:                     if ((value & INP_PAD_UP) && (value & INP_PAD_DOWN))
9D033A78  30420030   ANDI V0, V0, 48
81:                        value &= ~(INP_PAD_UP | INP_PAD_DOWN);
9D033A7C  306400CF   ANDI A0, V1, 207
82:                  
83:                     if ((value & INP_PAD_LEFT) && (value & INP_PAD_RIGHT))
9D033A88  30620040   ANDI V0, V1, 64
84:                        value &= ~(INP_PAD_LEFT | INP_PAD_RIGHT);
9D033A98  3062003F   ANDI V0, V1, 63
85:                  
86:                     /* return (0x40 | value) due to bus conflicts */
87:                     return (0x40 | ((value >> pad1_readcount++) & 1));
9D033AA4  8F828100   LW V0, -32512(GP)
9D033AA8  24440001   ADDIU A0, V0, 1
9D033AAC  AF848100   SW A0, -32512(GP)
9D033AB0  00431007   SRAV V0, V1, V0
9D033AB4  30420001   ANDI V0, V0, 1
9D033AB8  34420040   ORI V0, V0, 64
88:                  }
89:                  
90:                  static uint8 get_zapper(void)
91:                  {
92:                     return (uint8) (retrieve_type(INP_ZAPPER));
9D033ACC  0F40CE68   JAL .LFB0, retrieve_type, .Ltext0, .Letext0, .LFE12
9D033AD0  24040004   ADDIU A0, ZERO, 4
93:                  }
94:                  
95:                  static uint8 get_powerpad(void)
96:                  {
97:                     int value;
98:                     uint8 ret_val = 0;
9D033B00  24050010   ADDIU A1, ZERO, 16
99:                     
100:                    value = retrieve_type(INP_POWERPAD);
9D033AE8  0F40CE68   JAL .LFB0, retrieve_type, .Ltext0, .Letext0, .LFE12
101:                 
102:                    if (((value >> 8) >> ppad_readcount) & 1)
9D033AF0  8F8380FC   LW V1, -32516(GP)
103:                       ret_val |= 0x10;
104:                    if (((value & 0xFF) >> ppad_readcount) & 1)
9D033B08  304200FF   ANDI V0, V0, 255
105:                       ret_val |= 0x08;
9D033B1C  34A40008   ORI A0, A1, 8
106:                 
107:                    ppad_readcount++;
9D033B24  24630001   ADDIU V1, V1, 1
9D033B28  AF8380FC   SW V1, -32516(GP)
108:                 
109:                    return ret_val;
110:                 }
111:                 
112:                 static uint8 get_vsdips0(void)
113:                 {
114:                    return (retrieve_type(INP_VSDIPSW0));
9D033B3C  0F40CE68   JAL .LFB0, retrieve_type, .Ltext0, .Letext0, .LFE12
9D033B40  24040020   ADDIU A0, ZERO, 32
115:                 }
116:                 
117:                 static uint8 get_vsdips1(void)
118:                 {
119:                    return (retrieve_type(INP_VSDIPSW1));
9D033B58  0F40CE68   JAL .LFB0, retrieve_type, .Ltext0, .Letext0, .LFE12
9D033B5C  24040040   ADDIU A0, ZERO, 64
120:                 }
121:                 
122:                 static uint8 get_arkanoid(void)
123:                 {
124:                    uint8 value = retrieve_type(INP_ARKANOID);
9D033B74  0F40CE68   JAL .LFB0, retrieve_type, .Ltext0, .Letext0, .LFE12
9D033B78  24040010   ADDIU A0, ZERO, 16
125:                 
126:                    if ((value >> (7 - ark_readcount++)) & 1)
9D033B7C  8F8380F8   LW V1, -32520(GP)
9D033B80  24640001   ADDIU A0, V1, 1
9D033B84  AF8480F8   SW A0, -32520(GP)
9D033B88  304200FF   ANDI V0, V0, 255
9D033B8C  24040007   ADDIU A0, ZERO, 7
9D033B90  00831823   SUBU V1, A0, V1
9D033B94  00621807   SRAV V1, V0, V1
9D033B98  30630001   ANDI V1, V1, 1
127:                       return 0x02;
9D033B9C  24020002   ADDIU V0, ZERO, 2
9D033BA0  0003100A   MOVZ V0, ZERO, V1
128:                    else
129:                       return 0;
130:                 }
131:                 
132:                 /* return input state for all types indicated (can be ORed together) */
133:                 uint8 input_get(int types)
134:                 {
9D0339EC  27BDFFE0   ADDIU SP, SP, -32
9D0339F0  AFBF001C   SW RA, 28(SP)
9D0339F4  AFB10018   SW S1, 24(SP)
9D0339F8  AFB00014   SW S0, 20(SP)
9D0339FC  00808021   ADDU S0, A0, ZERO
135:                    uint8 value = 0;
136:                 
137:                    if (types & INP_JOYPAD0)
9D033A00  30820001   ANDI V0, A0, 1
9D033A04  10400016   BEQ V0, ZERO, .LBE17, .LBE16
9D033A08  00008821   ADDU S1, ZERO, ZERO
138:                       value |= get_pad0();
139:                    if (types & INP_JOYPAD1)
9D033A60  32020002   ANDI V0, S0, 2
9D033A64  10400017   BEQ V0, ZERO, 0x9D033AC4
9D033A68  32020004   ANDI V0, S0, 4
140:                       value |= get_pad1();
9D033ABC  02228825   OR S1, S1, V0
141:                    if (types & INP_ZAPPER)
9D033AC0  32020004   ANDI V0, S0, 4
9D033AC4  10400006   BEQ V0, ZERO, 0x9D033AE0
9D033AC8  32020008   ANDI V0, S0, 8
142:                       value |= get_zapper();
9D033AD4  02221025   OR V0, S1, V0
9D033AD8  305100FF   ANDI S1, V0, 255
143:                    if (types & INP_POWERPAD)
9D033ADC  32020008   ANDI V0, S0, 8
9D033AE0  10400014   BEQ V0, ZERO, 0x9D033B34
9D033AE4  32020020   ANDI V0, S0, 32
144:                       value |= get_powerpad();
9D033B2C  00918825   OR S1, A0, S1
145:                    if (types & INP_VSDIPSW0)
9D033B30  32020020   ANDI V0, S0, 32
9D033B34  10400006   BEQ V0, ZERO, 0x9D033B50
9D033B38  32020040   ANDI V0, S0, 64
146:                       value |= get_vsdips0();
9D033B44  02221025   OR V0, S1, V0
9D033B48  305100FF   ANDI S1, V0, 255
147:                    if (types & INP_VSDIPSW1)
9D033B4C  32020040   ANDI V0, S0, 64
9D033B50  50400006   BEQL V0, ZERO, 0x9D033B6C
9D033B54  32100010   ANDI S0, S0, 16
148:                       value |= get_vsdips1();
9D033B60  02221025   OR V0, S1, V0
9D033B64  305100FF   ANDI S1, V0, 255
149:                    if (types & INP_ARKANOID)
9D033B68  32100010   ANDI S0, S0, 16
9D033B6C  1200000F   BEQ S0, ZERO, 0x9D033BAC
9D033B70  02201021   ADDU V0, S1, ZERO
150:                       value |= get_arkanoid();
9D033BA4  00518825   OR S1, V0, S1
151:                 
152:                    return value;
153:                 }
9D033BA8  02201021   ADDU V0, S1, ZERO
9D033BAC  8FBF001C   LW RA, 28(SP)
9D033BB0  8FB10018   LW S1, 24(SP)
9D033BB4  8FB00014   LW S0, 20(SP)
9D033BB8  03E00008   JR RA
9D033BBC  27BD0020   ADDIU SP, SP, 32
154:                 
155:                 /* register an input type */
156:                 void input_register(nesinput_t *input)
157:                 {
158:                    if (NULL == input)
9D033BC0  10800008   BEQ A0, ZERO, 0x9D033BE4
9D033BC4  8F828108   LW V0, -32504(GP)
159:                       return;
160:                 
161:                    nes_input[active_entries] = input;
9D033BC8  00022880   SLL A1, V0, 2
9D033BCC  3C03A001   LUI V1, -24575
9D033BD0  2463AB40   ADDIU V1, V1, -21696
9D033BD4  00A31821   ADDU V1, A1, V1
9D033BD8  AC640000   SW A0, 0(V1)
162:                    active_entries++;
9D033BDC  24420001   ADDIU V0, V0, 1
9D033BE0  AF828108   SW V0, -32504(GP)
9D033BE4  03E00008   JR RA
9D033BE8  00000000   NOP
163:                 }
164:                 
165:                 void input_event(nesinput_t *input, int state, int value)
166:                 {
167:                    ASSERT(input);
168:                 
169:                    if (state == INP_STATE_MAKE)
9D033BEC  24020001   ADDIU V0, ZERO, 1
9D033BF0  54A20005   BNEL A1, V0, 0x9D033C08
9D033BF4  00063027   NOR A2, ZERO, A2
170:                       input->data |= value;   /* OR it in */
9D033BF8  8C820004   LW V0, 4(A0)
9D033BFC  00463025   OR A2, V0, A2
9D033C00  03E00008   JR RA
9D033C04  AC860004   SW A2, 4(A0)
171:                    else /* break state */
172:                       input->data &= ~value;  /* mask it out */
9D033C08  8C820004   LW V0, 4(A0)
9D033C0C  00463024   AND A2, V0, A2
9D033C10  03E00008   JR RA
9D033C14  AC860004   SW A2, 4(A0)
173:                 }
174:                 
175:                 void input_strobe(void)
176:                 {
177:                    pad0_readcount = 0;
9D033C18  AF808104   SW ZERO, -32508(GP)
178:                    pad1_readcount = 0;
9D033C1C  AF808100   SW ZERO, -32512(GP)
179:                    ppad_readcount = 0;
9D033C20  AF8080FC   SW ZERO, -32516(GP)
180:                    ark_readcount = 0;
9D033C24  03E00008   JR RA
9D033C28  AF8080F8   SW ZERO, -32520(GP)
181:                 }
182:                 
183:                 /*
184:                 ** $Log: nesinput.c,v $
185:                 ** Revision 1.2  2001/04/27 14:37:11  neil
186:                 ** wheeee
187:                 **
188:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
189:                 ** initial
190:                 **
191:                 ** Revision 1.1  2000/10/24 12:20:28  matt
192:                 ** changed directory structure
193:                 **
194:                 ** Revision 1.9  2000/09/10 23:25:03  matt
195:                 ** minor changes
196:                 **
197:                 ** Revision 1.8  2000/07/31 04:27:59  matt
198:                 ** one million cleanups
199:                 **
200:                 ** Revision 1.7  2000/07/23 15:11:45  matt
201:                 ** removed unused variables
202:                 **
203:                 ** Revision 1.6  2000/07/17 01:52:28  matt
204:                 ** made sure last line of all source files is a newline
205:                 **
206:                 ** Revision 1.5  2000/07/04 04:56:50  matt
207:                 ** include changes
208:                 **
209:                 ** Revision 1.4  2000/06/09 15:12:26  matt
210:                 ** initial revision
211:                 **
212:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/nes/nes_rom.c  -----------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** nes_rom.c
21:                  **
22:                  ** NES ROM loading/saving related functions
23:                  ** $Id: nes_rom.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  /* TODO: make this a generic ROM loading routine */
27:                  
28:                  #include <stdio.h>
29:                  #include <string.h>
30:                  #include <noftypes.h>
31:                  #include <nes_rom.h>
32:                  #include <intro.h>
33:                  #include <nes_mmc.h>
34:                  #include <nes_ppu.h>
35:                  #include <nes.h>
36:                  #include <gui.h>
37:                  #include <log.h>
38:                  #include <osd.h>
39:                  
40:                  extern char *osd_getromdata();
41:                  
42:                  /* Max length for displayed filename */
43:                  #define  ROM_DISP_MAXLEN   20
44:                  
45:                  
46:                  #ifdef ZLIB
47:                  #include <zlib.h>
48:                  #define  _fopen            gzopen
49:                  #define  _fclose           gzclose
50:                  #define  _fread(B,N,L,F)   gzread((F),(B),(L)*(N))
51:                  #else
52:                  #define  _fopen            fopen
53:                  #define  _fclose           fclose
54:                  #define  _fread(B,N,L,F)   fread((B),(N),(L),(F))
55:                  #endif
56:                  
57:                  #define  ROM_FOURSCREEN    0x08
58:                  #define  ROM_TRAINER       0x04
59:                  #define  ROM_BATTERY       0x02
60:                  #define  ROM_MIRRORTYPE    0x01
61:                  #define  ROM_INES_MAGIC    "NES\x1A"
62:                  
63:                  //ToDo: packed - JD
64:                  typedef struct inesheader_s
65:                  {
66:                     uint8 ines_magic[4]    ;
67:                     uint8 rom_banks        ;
68:                     uint8 vrom_banks       ;
69:                     uint8 rom_type         ;
70:                     uint8 mapper_hinybble  ;
71:                     uint8 reserved[8]      ;
72:                  } inesheader_t;
73:                  
74:                  
75:                  #define  TRAINER_OFFSET    0x1000
76:                  #define  TRAINER_LENGTH    0x200
77:                  #define  VRAM_LENGTH       0x2000
78:                  
79:                  #define  ROM_BANK_LENGTH   0x4000
80:                  #define  VROM_BANK_LENGTH  0x2000
81:                  
82:                  #define  SRAM_BANK_LENGTH  0x0400
83:                  #define  VRAM_BANK_LENGTH  0x2000
84:                  
85:                  /* Save battery-backed RAM */
86:                  static void rom_savesram(rominfo_t *rominfo)
87:                  {
9D02B224  27BDFDD8   ADDIU SP, SP, -552
9D02B228  AFBF0224   SW RA, 548(SP)
9D02B22C  AFB10220   SW S1, 544(SP)
9D02B230  AFB0021C   SW S0, 540(SP)
88:                     FILE *fp;
89:                     char fn[PATH_MAX + 1];
90:                  
91:                     ASSERT(rominfo);
92:                  
93:                     if (rominfo->flags & ROM_FLAG_BATTERY)
9D02B234  90820028   LBU V0, 40(A0)
9D02B238  30420001   ANDI V0, V0, 1
9D02B23C  10400016   BEQ V0, ZERO, .LVL14
9D02B240  00808021   ADDU S0, A0, ZERO
94:                     {
95:                        strncpy(fn, rominfo->filename, PATH_MAX);
9D02B244  27A40010   ADDIU A0, SP, 16
9D02B248  26050029   ADDIU A1, S0, 41
9D02B24C  0F40E397   JAL .LFE23, strncpy
9D02B250  24060200   ADDIU A2, ZERO, 512
96:                        //osd_newextension(fn, ".sav");
97:                  
98:                        fp = fopen(fn, "wb");
9D02B254  27A40010   ADDIU A0, SP, 16
9D02B258  3C059D03   LUI A1, -25341
9D02B25C  0F40DCB1   JAL .Letext0, .LFE3, fopen
9D02B260  24A55C84   ADDIU A1, A1, 23684
99:                        if (NULL != fp)
9D02B264  1040000C   BEQ V0, ZERO, .LVL14
9D02B268  00408821   ADDU S1, V0, ZERO
100:                       {
101:                          fwrite(rominfo->sram, SRAM_BANK_LENGTH, rominfo->sram_banks, fp);
9D02B26C  8E040008   LW A0, 8(S0)
9D02B270  24050400   ADDIU A1, ZERO, 1024
9D02B274  8E060018   LW A2, 24(S0)
9D02B278  0F40F1FB   JAL fwrite
9D02B27C  00403821   ADDU A3, V0, ZERO
102:                          fclose(fp);
9D02B280  0F40EBD5   JAL .Letext0, .LFE1, fclose
9D02B284  02202021   ADDU A0, S1, ZERO
103:                          log_printf("Wrote battery RAM to %s.\n", fn);
9D02B288  3C049D03   LUI A0, -25341
9D02B28C  24845C88   ADDIU A0, A0, 23688
9D02B290  0F40F11B   JAL log_printf
9D02B294  27A50010   ADDIU A1, SP, 16
104:                       }
105:                    }
106:                 }
9D02B298  8FBF0224   LW RA, 548(SP)
9D02B29C  8FB10220   LW S1, 544(SP)
9D02B2A0  8FB0021C   LW S0, 540(SP)
9D02B2A4  03E00008   JR RA
9D02B2A8  27BD0228   ADDIU SP, SP, 552
107:                 
108:                 /* Load battery-backed RAM from disk */
109:                 static void rom_loadsram(rominfo_t *rominfo)
110:                 {
9D02B19C  27BDFDD8   ADDIU SP, SP, -552
9D02B1A0  AFBF0224   SW RA, 548(SP)
9D02B1A4  AFB10220   SW S1, 544(SP)
9D02B1A8  AFB0021C   SW S0, 540(SP)
111:                    FILE *fp;
112:                    char fn[PATH_MAX + 1];
113:                 
114:                    ASSERT(rominfo);
115:                 
116:                    if (rominfo->flags & ROM_FLAG_BATTERY)
9D02B1AC  90820028   LBU V0, 40(A0)
9D02B1B0  30420001   ANDI V0, V0, 1
9D02B1B4  10400016   BEQ V0, ZERO, .LVL6
9D02B1B8  00808021   ADDU S0, A0, ZERO
117:                    {
118:                       strncpy(fn, rominfo->filename, PATH_MAX);
9D02B1BC  27A40010   ADDIU A0, SP, 16
9D02B1C0  26050029   ADDIU A1, S0, 41
9D02B1C4  0F40E397   JAL .LFE23, strncpy
9D02B1C8  24060200   ADDIU A2, ZERO, 512
119:                       //osd_newextension(fn, ".sav");
120:                 
121:                       fp = fopen(fn, "rb");
9D02B1CC  27A40010   ADDIU A0, SP, 16
9D02B1D0  3C059D03   LUI A1, -25341
9D02B1D4  0F40DCB1   JAL .Letext0, .LFE3, fopen
9D02B1D8  24A55C64   ADDIU A1, A1, 23652
122:                       if (NULL != fp)
9D02B1DC  1040000C   BEQ V0, ZERO, .LVL6
9D02B1E0  00408821   ADDU S1, V0, ZERO
123:                       {
124:                          fread(rominfo->sram, SRAM_BANK_LENGTH, rominfo->sram_banks, fp);
9D02B1E4  8E040008   LW A0, 8(S0)
9D02B1E8  24050400   ADDIU A1, ZERO, 1024
9D02B1EC  8E060018   LW A2, 24(S0)
9D02B1F0  0F40CC64   JAL .Letext0, .LFE1, fread
9D02B1F4  00403821   ADDU A3, V0, ZERO
125:                          fclose(fp);
9D02B1F8  0F40EBD5   JAL .Letext0, .LFE1, fclose
9D02B1FC  02202021   ADDU A0, S1, ZERO
126:                          log_printf("Read battery RAM from %s.\n", fn);
9D02B200  3C049D03   LUI A0, -25341
9D02B204  24845C68   ADDIU A0, A0, 23656
9D02B208  0F40F11B   JAL log_printf
9D02B20C  27A50010   ADDIU A1, SP, 16
127:                       }
128:                    }
129:                 }
9D02B210  8FBF0224   LW RA, 548(SP)
9D02B214  8FB10220   LW S1, 544(SP)
9D02B218  8FB0021C   LW S0, 540(SP)
9D02B21C  03E00008   JR RA
9D02B220  27BD0228   ADDIU SP, SP, 552
130:                 
131:                 /* Allocate space for SRAM */
132:                 static int rom_allocsram(rominfo_t *rominfo)
133:                 {
134:                    /* Load up SRAM */
135:                    rominfo->sram = malloc(SRAM_BANK_LENGTH * rominfo->sram_banks);
9D02B834  8E240018   LW A0, 24(S1)
136:                    if (NULL == rominfo->sram)
9D02B840  14400007   BNE V0, ZERO, 0x9D02B860
137:                    {
138:                       gui_sendmsg(GUI_RED, "Could not allocate space for battery RAM");
9D02B848  240400C5   ADDIU A0, ZERO, 197
139:                       return -1;
140:                    }
141:                 
142:                    /* make damn sure SRAM is clear */
143:                    memset(rominfo->sram, 0, SRAM_BANK_LENGTH * rominfo->sram_banks);
9D02B860  8E260018   LW A2, 24(S1)
9D02B864  00402021   ADDU A0, V0, ZERO
9D02B868  00002821   ADDU A1, ZERO, ZERO
9D02B86C  0F40E9FC   JAL .Letext0, .LFE0, memset
9D02B870  00063280   SLL A2, A2, 10
144:                    return 0;
145:                 }
146:                 
147:                 /* If there's a trainer, load it in at $7000 */
148:                 static void rom_loadtrainer(unsigned char **rom, rominfo_t *rominfo)
149:                 {
150:                    ASSERT(rom);
151:                    ASSERT(rominfo);
152:                 
153:                    if (rominfo->flags & ROM_FLAG_TRAINER)
9D02B878  90430028   LBU V1, 40(V0)
154:                    {
155:                 //      fread(rominfo->sram + TRAINER_OFFSET, TRAINER_LENGTH, 1, fp);
156:                       memcpy(rominfo->sram + TRAINER_OFFSET, *rom, TRAINER_LENGTH);
9D02B88C  8C420008   LW V0, 8(V0)
157:                       rom+=TRAINER_LENGTH;
158:                       log_printf("Read in trainer at $7000\n");
9D02B8E8  3C049D03   LUI A0, -25341
9D02B8EC  0F40F11B   JAL log_printf
9D02B8F0  24845E04   ADDIU A0, A0, 24068
159:                    }
160:                 }
161:                 
162:                 static int rom_loadrom(unsigned char **rom, rominfo_t *rominfo)
163:                 {
164:                    ASSERT(rom);
165:                    ASSERT(rominfo);
166:                 
167:                    /* Allocate ROM space, and load it up! */
168:                 /*
169:                    rominfo->rom = malloc((rominfo->rom_banks * ROM_BANK_LENGTH));
170:                    if (NULL == rominfo->rom)
171:                    {
172:                       gui_sendmsg(GUI_RED, "Could not allocate space for ROM image");
173:                       return -1;
174:                    }
175:                    _fread(rominfo->rom, ROM_BANK_LENGTH, rominfo->rom_banks, fp);
176:                 */
177:                    rominfo->rom=*rom;
9D02B8F8  AE300000   SW S0, 0(S1)
178:                    *rom+=ROM_BANK_LENGTH*rominfo->rom_banks;
9D02B908  00031B80   SLL V1, V1, 14
9D02B90C  02038021   ADDU S0, S0, V1
179:                 
180:                 
181:                    /* If there's VROM, allocate and stuff it in */
182:                    if (rominfo->vrom_banks)
9D02B8FC  8E220014   LW V0, 20(S1)
9D02B900  10400005   BEQ V0, ZERO, 0x9D02B918
9D02B904  8E230010   LW V1, 16(S1)
183:                    {
184:                 /*
185:                       rominfo->vrom = malloc((rominfo->vrom_banks * VROM_BANK_LENGTH));
186:                       if (NULL == rominfo->vrom)
187:                       {
188:                          gui_sendmsg(GUI_RED, "Could not allocate space for VROM");
189:                          return -1;
190:                       }
191:                       _fread(rominfo->vrom, VROM_BANK_LENGTH, rominfo->vrom_banks, fp);
192:                 */
193:                       rominfo->vrom=*rom;
9D02B910  0B40AE63   J 0x9D02B98C
9D02B914  AE300004   SW S0, 4(S1)
194:                       *rom+=VROM_BANK_LENGTH*rominfo->vrom_banks;
195:                 
196:                    }
197:                    else
198:                    {
199:                       rominfo->vram = malloc(VRAM_LENGTH);
9D02B918  0F40DDB7   JAL _my_malloc
9D02B91C  24042000   ADDIU A0, ZERO, 8192
200:                       if (NULL == rominfo->vram)
9D02B920  14400007   BNE V0, ZERO, 0x9D02B940
9D02B924  AE22000C   SW V0, 12(S1)
201:                       {
202:                          gui_sendmsg(GUI_RED, "Could not allocate space for VRAM");
9D02B928  240400C5   ADDIU A0, ZERO, 197
9D02B92C  3C059D03   LUI A1, -25341
9D02B930  0F409253   JAL gui_sendmsg
9D02B934  24A55E20   ADDIU A1, A1, 24096
9D02B938  0B40AE56   J .L47
9D02B93C  00000000   NOP
203:                          return -1;
204:                       }
205:                       memset(rominfo->vram, 0, VRAM_LENGTH);
9D02B940  00402021   ADDU A0, V0, ZERO
9D02B944  00002821   ADDU A1, ZERO, ZERO
9D02B948  0F40E9FC   JAL .Letext0, .LFE0, memset
9D02B94C  24062000   ADDIU A2, ZERO, 8192
9D02B950  0B40AE63   J 0x9D02B98C
9D02B954  00000000   NOP
206:                    }
207:                 
208:                    return 0;
209:                 }
210:                 
211:                 /* If we've got a VS. system game, load in the palette, as well */
212:                 static void rom_checkforpal(rominfo_t *rominfo)
213:                 {
214:                    FILE *fp;
215:                    rgb_t vs_pal[64];
216:                    char filename[PATH_MAX + 1];
217:                    int i;
218:                 
219:                    ASSERT(rominfo);
220:                 
221:                    strncpy(filename, rominfo->filename, PATH_MAX);
222:                    //osd_newextension(filename, ".pal");
223:                 
224:                    fp = fopen(filename, "rb");
225:                    if (NULL == fp)
226:                       return; /* no palette found  */
227:                 
228:                    for (i = 0; i < 64; i++)
229:                    {
230:                       vs_pal[i].r = fgetc(fp);
231:                       vs_pal[i].g = fgetc(fp);
232:                       vs_pal[i].b = fgetc(fp);
233:                    }
234:                 
235:                    fclose(fp);
236:                    /* TODO: this should really be a *SYSTEM* flag */
237:                    rominfo->flags |= ROM_FLAG_VERSUS;
238:                    /* TODO: bad, BAD idea, calling nes_getcontextptr... */
239:                    ppu_setpal(nes_getcontextptr()->ppu, vs_pal);
240:                    log_printf("Game specific palette found -- assuming VS. UniSystem\n");
241:                 }
242:                 
243:                 static FILE *rom_findrom(const char *filename, rominfo_t *rominfo)
244:                 {
245:                    FILE *fp;
246:                 
247:                    ASSERT(rominfo);
248:                 
249:                    if (NULL == filename)
9D02B2AC  1080002C   BEQ A0, ZERO, 0x9D02B360
9D02B2B0  3C059D03   LUI A1, -25341
250:                       return NULL;
251:                 
252:                    /* Make a copy of the name so we can extend it */
253:                    //osd_fullname(rominfo->filename, filename);
254:                 
255:                    fp = _fopen(rominfo->filename, "rb");
9D02B2C0  27A40049   ADDIU A0, SP, 73
9D02B2C4  0F40DCB1   JAL .Letext0, .LFE3, fopen
9D02B2C8  24A55C64   ADDIU A1, A1, 23652
256:                    if (NULL == fp)
9D02B2CC  14400015   BNE V0, ZERO, 0x9D02B324
9D02B2D0  00408021   ADDU S0, V0, ZERO
257:                    {
258:                       /* Didn't find the file?  Maybe the .NES extension was omitted */
259:                       if (NULL == strrchr(rominfo->filename, '.'))
9D02B2D4  27A40049   ADDIU A0, SP, 73
9D02B2D8  0F40F1E9   JAL .Letext0, .LFE0, strrchr
9D02B2DC  2405002E   ADDIU A1, ZERO, 46
9D02B2E0  1440000A   BNE V0, ZERO, 0x9D02B30C
9D02B2E4  27A40049   ADDIU A0, SP, 73
260:                          strncat(rominfo->filename, ".nes", PATH_MAX - strlen(rominfo->filename));
9D02B2E8  0F40DBFE   JAL strlen
9D02B2EC  27A40049   ADDIU A0, SP, 73
9D02B2F0  27A40049   ADDIU A0, SP, 73
9D02B2F4  3C059D03   LUI A1, -25341
9D02B2F8  24A55CA4   ADDIU A1, A1, 23716
9D02B2FC  24060200   ADDIU A2, ZERO, 512
9D02B300  0F40EA26   JAL strncat
9D02B304  00C23023   SUBU A2, A2, V0
261:                 
262:                       /* this will either return NULL or a valid file pointer */
263:                       fp = _fopen(rominfo->filename, "rb");
9D02B308  27A40049   ADDIU A0, SP, 73
9D02B30C  3C059D03   LUI A1, -25341
9D02B310  0F40DCB1   JAL .Letext0, .LFE3, fopen
9D02B314  24A55C64   ADDIU A1, A1, 23652
9D02B318  00408021   ADDU S0, V0, ZERO
264:                    }
265:                 
266:                    return fp;
267:                 }
268:                 
269:                 /* Add ROM name to a list with dirty headers */
270:                 static int rom_adddirty(char *filename)
271:                 {
272:                 #ifdef NOFRENDO_DEBUG
273:                 #define  MAX_BUFFER_LENGTH    255
274:                    char buffer[MAX_BUFFER_LENGTH + 1];
275:                    bool found = false;
276:                 
277:                    FILE *fp = fopen("dirtyrom.txt", "rt");
278:                    if (NULL == fp)
279:                       return -1;
280:                 
281:                    while (fgets(buffer, MAX_BUFFER_LENGTH, fp))
282:                    {
283:                       if (0 == strncmp(filename, buffer, strlen(filename)))
284:                       {
285:                          found = true;
286:                          break;
287:                       }
288:                    }
289:                 
290:                    if (false == found)
291:                    {
292:                       /* close up the file, open it back up for writing */
293:                       fclose(fp);
294:                       fp = fopen("dirtyrom.txt", "at");
295:                       fprintf(fp, "%s -- dirty header\n", filename);
296:                    }
297:                 
298:                    fclose(fp);
299:                 #endif /* NOFRENDO_DEBUG */
300:                 
301:                    return 0;
302:                 }
303:                 
304:                 /* return 0 if this *is* an iNES file */
305:                 int rom_checkmagic(const char *filename)
306:                 {
9D02B2B4  27BDFDA8   ADDIU SP, SP, -600
9D02B2B8  AFBF0254   SW RA, 596(SP)
9D02B2BC  AFB00250   SW S0, 592(SP)
307:                    inesheader_t head;
308:                    rominfo_t rominfo;
309:                    FILE *fp;
310:                 
311:                    fp = rom_findrom(filename, &rominfo);
312:                    if (NULL == fp)
9D02B31C  12000012   BEQ S0, ZERO, 0x9D02B368
9D02B320  2402FFFF   ADDIU V0, ZERO, -1
313:                       return -1;
9D02B360  03E00008   JR RA
9D02B364  2402FFFF   ADDIU V0, ZERO, -1
314:                 
315:                    _fread(&head, 1, sizeof(head), fp);
9D02B324  27A40010   ADDIU A0, SP, 16
9D02B328  24050001   ADDIU A1, ZERO, 1
9D02B32C  24060010   ADDIU A2, ZERO, 16
9D02B330  0F40CC64   JAL .Letext0, .LFE1, fread
9D02B334  02003821   ADDU A3, S0, ZERO
316:                 
317:                    _fclose(fp);
9D02B338  0F40EBD5   JAL .Letext0, .LFE1, fclose
9D02B33C  02002021   ADDU A0, S0, ZERO
318:                 
319:                    if (0 == memcmp(head.ines_magic, ROM_INES_MAGIC, 4))
9D02B340  27A40010   ADDIU A0, SP, 16
9D02B344  3C059D03   LUI A1, -25341
9D02B348  24A55CAC   ADDIU A1, A1, 23724
9D02B34C  0F40EB64   JAL .LFE0, memcmp
9D02B350  24060004   ADDIU A2, ZERO, 4
9D02B354  0002102B   SLTU V0, ZERO, V0
9D02B358  0B40ACDA   J 0x9D02B368
9D02B35C  00021023   SUBU V0, ZERO, V0
320:                       /* not an iNES file */
321:                       return 0;
322:                 
323:                    return -1;
324:                 }
9D02B368  8FBF0254   LW RA, 596(SP)
9D02B36C  8FB00250   LW S0, 592(SP)
9D02B370  03E00008   JR RA
9D02B374  27BD0258   ADDIU SP, SP, 600
325:                 
326:                 static int rom_getheader(unsigned char **rom, rominfo_t *rominfo)
327:                 {
328:                 #define  RESERVED_LENGTH   8
329:                    inesheader_t head;
330:                    uint8 reserved[RESERVED_LENGTH];
331:                    bool header_dirty;
332:                 
333:                    ASSERT(rom);
334:                    ASSERT(*rom);
335:                    ASSERT(rominfo);
336:                 
337:                    /* Read in the header */
338:                 //   _fread(&head, 1, sizeof(head), fp);
339:                 	printf("Head: %p (%x %x %x %x)\n", *rom, (*rom)[0], (*rom)[1], (*rom)[2], (*rom)[3]);
9D02B65C  92060000   LBU A2, 0(S0)
9D02B660  92070001   LBU A3, 1(S0)
9D02B664  92020002   LBU V0, 2(S0)
9D02B668  AFA20010   SW V0, 16(SP)
9D02B66C  92020003   LBU V0, 3(S0)
9D02B670  AFA20014   SW V0, 20(SP)
9D02B674  3C049D03   LUI A0, -25341
9D02B678  24845D14   ADDIU A0, A0, 23828
9D02B67C  0F40F0C5   JAL _printf_cdnopuxX
9D02B680  02002821   ADDU A1, S0, ZERO
340:                 	memcpy(&head, *rom, sizeof(head));
9D02B684  8A050003   LWL A1, 3(S0)
9D02B688  9A050000   LWR A1, 0(S0)
9D02B68C  8A040007   LWL A0, 7(S0)
9D02B690  9A040004   LWR A0, 4(S0)
9D02B694  8A03000B   LWL V1, 11(S0)
9D02B698  9A030008   LWR V1, 8(S0)
9D02B69C  8A02000F   LWL V0, 15(S0)
9D02B6A0  9A02000C   LWR V0, 12(S0)
9D02B6A4  AFA5001C   SW A1, 28(SP)
9D02B6A8  AFA40020   SW A0, 32(SP)
9D02B6AC  AFA30024   SW V1, 36(SP)
9D02B6B0  AFA20028   SW V0, 40(SP)
341:                 	*rom+=sizeof(head);
9D02B6B4  26100010   ADDIU S0, S0, 16
342:                 
343:                    if (memcmp(head.ines_magic, ROM_INES_MAGIC, 4))
9D02B6B8  27A4001C   ADDIU A0, SP, 28
9D02B6BC  3C059D03   LUI A1, -25341
9D02B6C0  24A55CAC   ADDIU A1, A1, 23724
9D02B6C4  0F40EB64   JAL .LFE0, memcmp
9D02B6C8  24060004   ADDIU A2, ZERO, 4
9D02B6CC  50400008   BEQL V0, ZERO, 0x9D02B6F0
9D02B6D0  93A20020   LBU V0, 32(SP)
344:                    {
345:                       gui_sendmsg(GUI_RED, "%s is not a valid ROM image", rominfo->filename);
9D02B6D4  240400C5   ADDIU A0, ZERO, 197
9D02B6D8  3C059D03   LUI A1, -25341
9D02B6DC  24A55D2C   ADDIU A1, A1, 23852
9D02B6E0  0F409253   JAL gui_sendmsg
9D02B6E4  26260029   ADDIU A2, S1, 41
9D02B6E8  0B40AE56   J .L47
9D02B6EC  00000000   NOP
346:                       return -1;
347:                    }
348:                 
349:                    rominfo->rom_banks = head.rom_banks;
9D02B6F0  AE220010   SW V0, 16(S1)
350:                    rominfo->vrom_banks = head.vrom_banks;
9D02B6F4  93A20021   LBU V0, 33(SP)
9D02B6F8  AE220014   SW V0, 20(S1)
351:                    /* iNES assumptions */
352:                    rominfo->sram_banks = 8; /* 1kB banks, so 8KB */
9D02B6FC  24020008   ADDIU V0, ZERO, 8
9D02B700  AE220018   SW V0, 24(S1)
353:                    rominfo->vram_banks = 1; /* 8kB banks, so 8KB */
9D02B704  24020001   ADDIU V0, ZERO, 1
9D02B708  AE22001C   SW V0, 28(S1)
354:                    rominfo->mirror = (head.rom_type & ROM_MIRRORTYPE) ? MIRROR_VERT : MIRROR_HORIZ;
9D02B70C  93A20022   LBU V0, 34(SP)
9D02B710  30430001   ANDI V1, V0, 1
9D02B714  AE230024   SW V1, 36(S1)
355:                    rominfo->flags = 0;
9D02B728  0B40ADCD   J 0x9D02B734
9D02B72C  A2200028   SB ZERO, 40(S1)
356:                    if (head.rom_type & ROM_BATTERY)
9D02B718  30430002   ANDI V1, V0, 2
9D02B71C  306300FF   ANDI V1, V1, 255
9D02B720  14600003   BNE V1, ZERO, 0x9D02B730
9D02B724  24030001   ADDIU V1, ZERO, 1
357:                       rominfo->flags |= ROM_FLAG_BATTERY;
9D02B730  A2230028   SB V1, 40(S1)
358:                    if (head.rom_type & ROM_TRAINER)
9D02B734  30430004   ANDI V1, V0, 4
9D02B738  306300FF   ANDI V1, V1, 255
9D02B73C  10600005   BEQ V1, ZERO, 0x9D02B754
9D02B740  30430008   ANDI V1, V0, 8
359:                       rominfo->flags |= ROM_FLAG_TRAINER;
9D02B744  92230028   LBU V1, 40(S1)
9D02B748  34630002   ORI V1, V1, 2
9D02B74C  A2230028   SB V1, 40(S1)
360:                    if (head.rom_type & ROM_FOURSCREEN)
9D02B750  30430008   ANDI V1, V0, 8
9D02B754  306300FF   ANDI V1, V1, 255
9D02B758  10600004   BEQ V1, ZERO, 0x9D02B76C
9D02B75C  00029102   SRL S2, V0, 4
361:                       rominfo->flags |= ROM_FLAG_FOURSCREEN;
9D02B760  92230028   LBU V1, 40(S1)
9D02B764  34630004   ORI V1, V1, 4
9D02B768  A2230028   SB V1, 40(S1)
362:                    /* TODO: fourscreen a mirroring type? */
363:                    rominfo->mapper_number = head.rom_type >> 4;
9D02B76C  AE320020   SW S2, 32(S1)
364:                 
365:                    /* Do a compare - see if we've got a clean extended header */
366:                    memset(reserved, 0, RESERVED_LENGTH);
9D02B770  AFA0002C   SW ZERO, 44(SP)
9D02B774  AFA00030   SW ZERO, 48(SP)
367:                    if (0 == memcmp(head.reserved, reserved, RESERVED_LENGTH))
9D02B778  27A40024   ADDIU A0, SP, 36
9D02B77C  27A5002C   ADDIU A1, SP, 44
9D02B780  0F40EB64   JAL .LFE0, memcmp
9D02B784  24060008   ADDIU A2, ZERO, 8
9D02B788  54400006   BNEL V0, ZERO, 0x9D02B7A4
9D02B78C  93B20023   LBU S2, 35(SP)
368:                    {
369:                       /* We were clean */
370:                       header_dirty = false;
371:                       rominfo->mapper_number |= (head.mapper_hinybble & 0xF0);
9D02B790  93A20023   LBU V0, 35(SP)
9D02B794  304200F0   ANDI V0, V0, 240
9D02B798  00529025   OR S2, V0, S2
9D02B79C  0B40ADFE   J 0x9D02B7F8
9D02B7A0  AE320020   SW S2, 32(S1)
372:                    }
373:                    else
374:                    {
375:                       header_dirty = true;
376:                 
377:                       /* @!?#@! DiskDude. */
378:                       if (('D' == head.mapper_hinybble) && (0 == memcmp(head.reserved, "iskDude!", 8)))
9D02B7A4  24020044   ADDIU V0, ZERO, 68
9D02B7A8  1642000D   BNE S2, V0, 0x9D02B7E0
9D02B7AC  3C049D03   LUI A0, -25341
9D02B7B0  27A40024   ADDIU A0, SP, 36
9D02B7B4  3C059D03   LUI A1, -25341
9D02B7B8  24A55D48   ADDIU A1, A1, 23880
9D02B7BC  0F40EB64   JAL .LFE0, memcmp
9D02B7C0  24060008   ADDIU A2, ZERO, 8
9D02B7C4  54400006   BNEL V0, ZERO, 0x9D02B7E0
9D02B7C8  3C049D03   LUI A0, -25341
379:                          log_printf("`DiskDude!' found in ROM header, ignoring high mapper nybble\n");
9D02B7CC  3C049D03   LUI A0, -25341
9D02B7D0  0F40F11B   JAL log_printf
9D02B7D4  24845D54   ADDIU A0, A0, 23892
380:                       else
381:                       {
382:                          log_printf("ROM header dirty, possible problem\n");
9D02B7E0  0F40F11B   JAL log_printf
9D02B7E4  24845D94   ADDIU A0, A0, 23956
383:                          rominfo->mapper_number |= (head.mapper_hinybble & 0xF0);
9D02B7E8  325200F0   ANDI S2, S2, 240
9D02B7EC  8E220020   LW V0, 32(S1)
9D02B7F0  00529025   OR S2, V0, S2
9D02B7F4  AE320020   SW S2, 32(S1)
384:                       }
385:                 
386:                       rom_adddirty(rominfo->filename);
387:                    }
388:                 
389:                    /* TODO: this is an ugly hack, but necessary, I guess */
390:                    /* Check for VS unisystem mapper */
391:                    if (99 == rominfo->mapper_number)
9D02B7D8  0B40ADFF   J 0x9D02B7FC
9D02B7DC  8E230020   LW V1, 32(S1)
9D02B7F8  8E230020   LW V1, 32(S1)
9D02B7FC  24020063   ADDIU V0, ZERO, 99
9D02B800  1462005C   BNE V1, V0, 0x9D02B974
9D02B804  8FA20018   LW V0, 24(SP)
392:                       rominfo->flags |= ROM_FLAG_VERSUS;
9D02B808  92220028   LBU V0, 40(S1)
9D02B80C  34420008   ORI V0, V0, 8
9D02B810  0B40AE5C   J 0x9D02B970
9D02B814  A2220028   SB V0, 40(S1)
393:                 
394:                    return 0;
395:                 }
396:                 
397:                 /* Build the info string for ROM display */
398:                 char *rom_getinfo(rominfo_t *rominfo)
399:                 {
9D02B378  27BDFBD0   ADDIU SP, SP, -1072
9D02B37C  AFBF042C   SW RA, 1068(SP)
9D02B380  AFB10428   SW S1, 1064(SP)
9D02B384  AFB00424   SW S0, 1060(SP)
9D02B388  00808021   ADDU S0, A0, ZERO
400:                    static char info[PATH_MAX + 1];
401:                    char romname[PATH_MAX + 1], temp[PATH_MAX + 1];
402:                 
403:                    /* Look to see if we were given a path along with filename */
404:                    /* TODO: strip extensions */
405:                    if (strrchr(rominfo->filename, PATH_SEP))
9D02B38C  24910029   ADDIU S1, A0, 41
9D02B390  02202021   ADDU A0, S1, ZERO
9D02B394  0F40F1E9   JAL .Letext0, .LFE0, strrchr
9D02B398  2405002F   ADDIU A1, ZERO, 47
9D02B39C  10400006   BEQ V0, ZERO, 0x9D02B3B8
9D02B3A0  24450001   ADDIU A1, V0, 1
406:                       strncpy(romname, strrchr(rominfo->filename, PATH_SEP) + 1, PATH_MAX);
9D02B3A4  27A40018   ADDIU A0, SP, 24
9D02B3A8  0F40E397   JAL .LFE23, strncpy
9D02B3AC  24060200   ADDIU A2, ZERO, 512
9D02B3B0  0B40ACF2   J .LVL34
9D02B3B4  00000000   NOP
407:                    else
408:                       strncpy(romname, rominfo->filename, PATH_MAX);
9D02B3B8  27A40018   ADDIU A0, SP, 24
9D02B3BC  02202821   ADDU A1, S1, ZERO
9D02B3C0  0F40E397   JAL .LFE23, strncpy
9D02B3C4  24060200   ADDIU A2, ZERO, 512
409:                 
410:                    /* If our filename is too long, truncate our displayed filename */
411:                    if (strlen(romname) > ROM_DISP_MAXLEN)
9D02B3C8  0F40DBFE   JAL strlen
9D02B3CC  27A40018   ADDIU A0, SP, 24
9D02B3D0  2C420015   SLTIU V0, V0, 21
9D02B3D4  1440000C   BNE V0, ZERO, 0x9D02B408
9D02B3D8  3C04A001   LUI A0, -24575
412:                    {
413:                       strncpy(info, romname, ROM_DISP_MAXLEN - 3);
9D02B3DC  2484A1A4   ADDIU A0, A0, -24156
9D02B3E0  27A50018   ADDIU A1, SP, 24
9D02B3E4  0F40E397   JAL .LFE23, strncpy
9D02B3E8  24060011   ADDIU A2, ZERO, 17
414:                       strcpy(info + (ROM_DISP_MAXLEN - 3), "...");
9D02B3EC  3C02A001   LUI V0, -24575
9D02B3F0  3C039D03   LUI V1, -25341
9D02B3F4  8C635CB4   LW V1, 23732(V1)
9D02B3F8  2444A1B5   ADDIU A0, V0, -24139
9D02B3FC  A8830003   SWL V1, 3(A0)
9D02B400  0B40AD05   J .LVL37
9D02B404  B843A1B5   SWR V1, -24139(V0)
415:                    }
416:                    else
417:                    {
418:                       strcpy(info, romname);
9D02B408  2484A1A4   ADDIU A0, A0, -24156
9D02B40C  0F40D947   JAL .LFE23, strcpy
9D02B410  27A50018   ADDIU A1, SP, 24
419:                    }
420:                 
421:                    sprintf(temp, " [%d] %dk/%dk %c", rominfo->mapper_number,
9D02B414  8E060020   LW A2, 32(S0)
9D02B418  8E070010   LW A3, 16(S0)
9D02B41C  8E030014   LW V1, 20(S0)
9D02B420  000318C0   SLL V1, V1, 3
9D02B424  8E020024   LW V0, 36(S0)
9D02B428  38420001   XORI V0, V0, 1
9D02B42C  24040056   ADDIU A0, ZERO, 86
9D02B430  24050048   ADDIU A1, ZERO, 72
9D02B434  00A2200B   MOVN A0, A1, V0
9D02B438  AFA30010   SW V1, 16(SP)
9D02B43C  AFA40014   SW A0, 20(SP)
9D02B440  27A4021C   ADDIU A0, SP, 540
9D02B444  3C059D03   LUI A1, -25341
9D02B448  24A55CB8   ADDIU A1, A1, 23736
9D02B44C  0F40EDE4   JAL _sprintf_cdnopuxX, _sprintf_cdnopsuxX
9D02B450  00073900   SLL A3, A3, 4
422:                            rominfo->rom_banks * 16, rominfo->vrom_banks * 8,
423:                            (rominfo->mirror == MIRROR_VERT) ? 'V' : 'H');
424:                    
425:                    /* Stick it on there! */
426:                    strncat(info, temp, PATH_MAX - strlen(info));
9D02B454  3C11A001   LUI S1, -24575
9D02B458  0F40DBFE   JAL strlen
9D02B45C  2624A1A4   ADDIU A0, S1, -24156
9D02B460  2624A1A4   ADDIU A0, S1, -24156
9D02B464  27A5021C   ADDIU A1, SP, 540
9D02B468  24060200   ADDIU A2, ZERO, 512
9D02B46C  0F40EA26   JAL strncat
9D02B470  00C23023   SUBU A2, A2, V0
427:                 
428:                    if (rominfo->flags & ROM_FLAG_BATTERY)
9D02B474  92020028   LBU V0, 40(S0)
9D02B478  30420001   ANDI V0, V0, 1
9D02B47C  5040000A   BEQL V0, ZERO, 0x9D02B4A8
9D02B480  92020028   LBU V0, 40(S0)
429:                       strncat(info, "B", PATH_MAX - strlen(info));
9D02B484  0F40DBFE   JAL strlen
9D02B488  2624A1A4   ADDIU A0, S1, -24156
9D02B48C  2624A1A4   ADDIU A0, S1, -24156
9D02B490  3C059D03   LUI A1, -25341
9D02B494  24A55CCC   ADDIU A1, A1, 23756
9D02B498  24060200   ADDIU A2, ZERO, 512
9D02B49C  0F40EA26   JAL strncat
9D02B4A0  00C23023   SUBU A2, A2, V0
430:                    if (rominfo->flags & ROM_FLAG_TRAINER)
9D02B4A4  92020028   LBU V0, 40(S0)
9D02B4A8  30420002   ANDI V0, V0, 2
9D02B4AC  304200FF   ANDI V0, V0, 255
9D02B4B0  5040000B   BEQL V0, ZERO, 0x9D02B4E0
9D02B4B4  92020028   LBU V0, 40(S0)
431:                       strncat(info, "T", PATH_MAX - strlen(info));
9D02B4B8  3C11A001   LUI S1, -24575
9D02B4BC  0F40DBFE   JAL strlen
9D02B4C0  2624A1A4   ADDIU A0, S1, -24156
9D02B4C4  2624A1A4   ADDIU A0, S1, -24156
9D02B4C8  3C059D03   LUI A1, -25341
9D02B4CC  24A55CD0   ADDIU A1, A1, 23760
9D02B4D0  24060200   ADDIU A2, ZERO, 512
9D02B4D4  0F40EA26   JAL strncat
9D02B4D8  00C23023   SUBU A2, A2, V0
432:                    if (rominfo->flags & ROM_FLAG_FOURSCREEN)
9D02B4DC  92020028   LBU V0, 40(S0)
9D02B4E0  30420004   ANDI V0, V0, 4
9D02B4E4  304200FF   ANDI V0, V0, 255
9D02B4E8  1040000B   BEQ V0, ZERO, 0x9D02B518
9D02B4EC  3C02A001   LUI V0, -24575
433:                       strncat(info, "4", PATH_MAX - strlen(info));
9D02B4F0  3C10A001   LUI S0, -24575
9D02B4F4  0F40DBFE   JAL strlen
9D02B4F8  2604A1A4   ADDIU A0, S0, -24156
9D02B4FC  2604A1A4   ADDIU A0, S0, -24156
9D02B500  3C059D03   LUI A1, -25341
9D02B504  24A55CD4   ADDIU A1, A1, 23764
9D02B508  24060200   ADDIU A2, ZERO, 512
9D02B50C  0F40EA26   JAL strncat
9D02B510  00C23023   SUBU A2, A2, V0
434:                 
435:                    return info;
436:                 }
9D02B514  3C02A001   LUI V0, -24575
9D02B518  2442A1A4   ADDIU V0, V0, -24156
9D02B51C  8FBF042C   LW RA, 1068(SP)
9D02B520  8FB10428   LW S1, 1064(SP)
9D02B524  8FB00424   LW S0, 1060(SP)
9D02B528  03E00008   JR RA
9D02B52C  27BD0430   ADDIU SP, SP, 1072
437:                 
438:                 /* Load a ROM image into memory */
439:                 rominfo_t *rom_load(const char *rom)
440:                 {
9D02B620  27BDFFB8   ADDIU SP, SP, -72
9D02B624  AFBF0044   SW RA, 68(SP)
9D02B628  AFB20040   SW S2, 64(SP)
9D02B62C  AFB1003C   SW S1, 60(SP)
9D02B630  AFB00038   SW S0, 56(SP)
9D02B634  00808021   ADDU S0, A0, ZERO
441:                    rominfo_t *rominfo;
442:                 
443:                    rominfo = malloc(sizeof(rominfo_t));
9D02B638  0F40DDB7   JAL _my_malloc
9D02B63C  2404022C   ADDIU A0, ZERO, 556
444:                    if (NULL == rominfo)
9D02B640  104000C9   BEQ V0, ZERO, 0x9D02B968
9D02B644  AFA20018   SW V0, 24(SP)
445:                       return NULL;
9D02B968  0B40AE6D   J 0x9D02B9B4
9D02B96C  00001021   ADDU V0, ZERO, ZERO
446:                 
447:                    memset(rominfo, 0, sizeof(rominfo_t));
9D02B648  00402021   ADDU A0, V0, ZERO
9D02B64C  00002821   ADDU A1, ZERO, ZERO
9D02B650  0F40E9FC   JAL .Letext0, .LFE0, memset
9D02B654  2406022C   ADDIU A2, ZERO, 556
448:                 
449:                    /* Get the header and stick it into rominfo struct */
450:                 	if (rom_getheader(&rom, rominfo))
9D02B658  8FB10018   LW S1, 24(SP)
451:                       goto _fail;
452:                 
453:                    /* Make sure we really support the mapper */
454:                    if (false == mmc_peek(rominfo->mapper_number))
9D02B970  8FA20018   LW V0, 24(SP)
9D02B974  0F40B4F7   JAL mmc_peek
9D02B978  8C440020   LW A0, 32(V0)
9D02B97C  1440FFAD   BNE V0, ZERO, .LBB24
9D02B980  8FB10018   LW S1, 24(SP)
9D02B984  0B40AE06   J 0x9D02B818
9D02B988  240400C5   ADDIU A0, ZERO, 197
455:                    {
456:                       gui_sendmsg(GUI_RED, "Mapper %d not yet implemented", rominfo->mapper_number);
9D02B818  3C059D03   LUI A1, -25341
9D02B81C  24A55DB8   ADDIU A1, A1, 23992
9D02B820  8FA20018   LW V0, 24(SP)
9D02B824  0F409253   JAL gui_sendmsg
9D02B828  8C460020   LW A2, 32(V0)
457:                       goto _fail;
9D02B82C  0B40AE56   J .L47
9D02B830  00000000   NOP
458:                    }
459:                 
460:                    /* iNES format doesn't tell us if we need SRAM, so
461:                    ** we have to always allocate it -- bleh!
462:                    ** UNIF, TAKE ME AWAY!  AAAAAAAAAA!!!
463:                    */
464:                    if (rom_allocsram(rominfo))
465:                       goto _fail;
466:                 
467:                       rom_loadtrainer(&rom, rominfo);
9D02B874  8FA20018   LW V0, 24(SP)
468:                 
469:                 	if (rom_loadrom(&rom, rominfo))
9D02B8F4  8FB10018   LW S1, 24(SP)
470:                       goto _fail;
471:                 
472:                    rom_loadsram(rominfo);
9D02B98C  0F40AC67   JAL .LFB6, rom_loadsram, .Ltext0, .Letext0, .LFE17
9D02B990  8FA40018   LW A0, 24(SP)
473:                 
474:                    /* See if there's a palette we can load up */
475:                 //   rom_checkforpal(rominfo);
476:                 
477:                    gui_sendmsg(GUI_GREEN, "ROM loaded: %s", rom_getinfo(rominfo));
9D02B994  0F40ACDE   JAL rom_getinfo
9D02B998  8FA40018   LW A0, 24(SP)
9D02B99C  240400C6   ADDIU A0, ZERO, 198
9D02B9A0  3C059D03   LUI A1, -25341
9D02B9A4  24A55E44   ADDIU A1, A1, 24132
9D02B9A8  0F409253   JAL gui_sendmsg
9D02B9AC  00403021   ADDU A2, V0, ZERO
478:                 
479:                    return rominfo;
9D02B9B0  8FA20018   LW V0, 24(SP)
480:                 
481:                 _fail:
482:                    rom_free(&rominfo);
9D02B958  0F40AD4C   JAL rom_free
9D02B95C  27A40018   ADDIU A0, SP, 24
483:                    return NULL;
9D02B960  0B40AE6D   J 0x9D02B9B4
9D02B964  00001021   ADDU V0, ZERO, ZERO
484:                 }
9D02B9B4  8FBF0044   LW RA, 68(SP)
9D02B9B8  8FB20040   LW S2, 64(SP)
9D02B9BC  8FB1003C   LW S1, 60(SP)
9D02B9C0  8FB00038   LW S0, 56(SP)
9D02B9C4  03E00008   JR RA
9D02B9C8  27BD0048   ADDIU SP, SP, 72
485:                 
486:                 /* Free a ROM */
487:                 void rom_free(rominfo_t **rominfo)
488:                 {
9D02B530  27BDFFE8   ADDIU SP, SP, -24
9D02B534  AFBF0014   SW RA, 20(SP)
9D02B538  AFB00010   SW S0, 16(SP)
489:                    if (NULL == *rominfo)
9D02B53C  8C820000   LW V0, 0(A0)
9D02B540  14400007   BNE V0, ZERO, 0x9D02B560
9D02B544  00808021   ADDU S0, A0, ZERO
490:                    {
491:                       gui_sendmsg(GUI_GREEN, "ROM not loaded");
9D02B548  240400C6   ADDIU A0, ZERO, 198
9D02B54C  3C059D03   LUI A1, -25341
9D02B550  0F409253   JAL gui_sendmsg
9D02B554  24A55CD8   ADDIU A1, A1, 23768
492:                       return;
9D02B558  0B40AD85   J 0x9D02B614
9D02B55C  8FBF0014   LW RA, 20(SP)
493:                    }
494:                 
495:                    /* Restore palette if we loaded in a VS jobber */
496:                    if ((*rominfo)->flags & ROM_FLAG_VERSUS)
9D02B560  90420028   LBU V0, 40(V0)
9D02B564  30420008   ANDI V0, V0, 8
9D02B568  304200FF   ANDI V0, V0, 255
9D02B56C  10400008   BEQ V0, ZERO, .LVL54
9D02B570  00000000   NOP
497:                    {
498:                       /* TODO: bad idea calling nes_getcontextptr... */
499:                       ppu_setdefaultpal(nes_getcontextptr()->ppu);
9D02B574  0F408D03   JAL nes_getcontextptr
9D02B578  00000000   NOP
9D02B57C  0F4065A1   JAL ppu_setdefaultpal
9D02B580  8C440304   LW A0, 772(V0)
500:                       log_printf("Default NES palette restored\n");
9D02B584  3C049D03   LUI A0, -25341
9D02B588  0F40F11B   JAL log_printf
9D02B58C  24845CE8   ADDIU A0, A0, 23784
501:                    }
502:                 
503:                    rom_savesram(*rominfo);
9D02B590  0F40AC89   JAL .LFB5, rom_savesram, .LFE6
9D02B594  8E040000   LW A0, 0(S0)
504:                 
505:                    if ((*rominfo)->sram)
9D02B598  8E040000   LW A0, 0(S0)
9D02B59C  8C820008   LW V0, 8(A0)
9D02B5A0  50400005   BEQL V0, ZERO, 0x9D02B5B8
9D02B5A4  8C820000   LW V0, 0(A0)
506:                       free((*rominfo)->sram);
9D02B5A8  0F40DDCA   JAL _my_free
9D02B5AC  24840008   ADDIU A0, A0, 8
507:                    if ((*rominfo)->rom)
9D02B5B0  8E040000   LW A0, 0(S0)
9D02B5B4  8C820000   LW V0, 0(A0)
9D02B5B8  50400004   BEQL V0, ZERO, 0x9D02B5CC
9D02B5BC  8E040000   LW A0, 0(S0)
508:                       free((*rominfo)->rom);
9D02B5C0  0F40DDCA   JAL _my_free
9D02B5C4  00000000   NOP
509:                    if ((*rominfo)->vrom)
9D02B5C8  8E040000   LW A0, 0(S0)
9D02B5CC  8C820004   LW V0, 4(A0)
9D02B5D0  50400004   BEQL V0, ZERO, 0x9D02B5E4
9D02B5D4  8E040000   LW A0, 0(S0)
510:                       free((*rominfo)->vrom);
9D02B5D8  0F40DDCA   JAL _my_free
9D02B5DC  24840004   ADDIU A0, A0, 4
511:                    if ((*rominfo)->vram)
9D02B5E0  8E040000   LW A0, 0(S0)
9D02B5E4  8C82000C   LW V0, 12(A0)
9D02B5E8  10400003   BEQ V0, ZERO, .LVL59
9D02B5EC  00000000   NOP
512:                       free((*rominfo)->vram);
9D02B5F0  0F40DDCA   JAL _my_free
9D02B5F4  2484000C   ADDIU A0, A0, 12
513:                 
514:                    free(*rominfo);
9D02B5F8  0F40DDCA   JAL _my_free
9D02B5FC  02002021   ADDU A0, S0, ZERO
515:                 
516:                    gui_sendmsg(GUI_GREEN, "ROM freed");
9D02B600  240400C6   ADDIU A0, ZERO, 198
9D02B604  3C059D03   LUI A1, -25341
9D02B608  0F409253   JAL gui_sendmsg
9D02B60C  24A55D08   ADDIU A1, A1, 23816
517:                 }
9D02B610  8FBF0014   LW RA, 20(SP)
9D02B614  8FB00010   LW S0, 16(SP)
9D02B618  03E00008   JR RA
9D02B61C  27BD0018   ADDIU SP, SP, 24
518:                 
519:                 /*
520:                 ** $Log: nes_rom.c,v $
521:                 ** Revision 1.2  2001/04/27 14:37:11  neil
522:                 ** wheeee
523:                 **
524:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
525:                 ** initial
526:                 **
527:                 ** Revision 1.8  2000/11/21 13:28:40  matt
528:                 ** take care to zero allocated mem
529:                 **
530:                 ** Revision 1.7  2000/11/09 14:07:28  matt
531:                 ** state load fixed, state save mostly fixed
532:                 **
533:                 ** Revision 1.6  2000/10/28 14:24:54  matt
534:                 ** where did I put that underscore?
535:                 **
536:                 ** Revision 1.5  2000/10/27 12:56:35  matt
537:                 ** api change for ppu palette functions
538:                 **
539:                 ** Revision 1.4  2000/10/26 22:51:44  matt
540:                 ** correct NULL filename handling
541:                 **
542:                 ** Revision 1.3  2000/10/25 01:23:08  matt
543:                 ** basic system autodetection
544:                 **
545:                 ** Revision 1.2  2000/10/25 00:23:16  matt
546:                 ** makefiles updated for new directory structure
547:                 **
548:                 ** Revision 1.1  2000/10/24 12:20:28  matt
549:                 ** changed directory structure
550:                 **
551:                 ** Revision 1.19  2000/10/21 14:35:58  matt
552:                 ** typo
553:                 **
554:                 ** Revision 1.18  2000/10/17 03:22:37  matt
555:                 ** cleaning up rom module
556:                 **
557:                 ** Revision 1.17  2000/10/10 13:58:13  matt
558:                 ** stroustrup squeezing his way in the door
559:                 **
560:                 ** Revision 1.16  2000/10/10 13:03:54  matt
561:                 ** Mr. Clean makes a guest appearance
562:                 **
563:                 ** Revision 1.15  2000/07/31 04:28:46  matt
564:                 ** one million cleanups
565:                 **
566:                 ** Revision 1.14  2000/07/30 04:31:26  matt
567:                 ** automagic loading of the nofrendo intro
568:                 **
569:                 ** Revision 1.13  2000/07/25 02:20:58  matt
570:                 ** cleanups
571:                 **
572:                 ** Revision 1.12  2000/07/20 01:53:27  matt
573:                 ** snprintf() ain't no standard function, eh?
574:                 **
575:                 ** Revision 1.11  2000/07/19 16:06:54  neil
576:                 ** little error fixed (tempinfo vs rominfo->info)
577:                 **
578:                 ** Revision 1.10  2000/07/19 15:59:39  neil
579:                 ** PATH_MAX, strncpy, snprintf, and strncat are our friends
580:                 **
581:                 ** Revision 1.9  2000/07/17 01:52:27  matt
582:                 ** made sure last line of all source files is a newline
583:                 **
584:                 ** Revision 1.8  2000/07/06 16:47:50  matt
585:                 ** new ppu palette setting calls
586:                 **
587:                 ** Revision 1.7  2000/07/05 23:21:54  neil
588:                 ** fclose(fp) should not be done if fp == NULL
589:                 **
590:                 ** Revision 1.6  2000/07/04 04:45:14  matt
591:                 ** changed include
592:                 **
593:                 ** Revision 1.5  2000/06/26 04:56:10  matt
594:                 ** minor cleanup
595:                 **
596:                 ** Revision 1.4  2000/06/09 15:12:25  matt
597:                 ** initial revision
598:                 **
599:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/nes/nes_ppu.c  -----------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** nes_ppu.c
21:                  **
22:                  ** NES PPU emulation
23:                  ** $Id: nes_ppu.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <string.h>
27:                  #include <stdlib.h>
28:                  #include <noftypes.h>
29:                  #include <nes_ppu.h>
30:                  #include <nes.h>
31:                  #include <gui.h>
32:                  #include "nes6502.h"
33:                  #include <log.h>
34:                  #include <nes_mmc.h>
35:                  
36:                  #include <bitmap.h>
37:                  #include <vid_drv.h>
38:                  #include <nes_pal.h>
39:                  #include <nesinput.h>
40:                  
41:                  
42:                  /* PPU access */
43:                  #define  PPU_MEM(x)           ppu.page[(x) >> 10][(x)]
44:                  
45:                  /* Background (color 0) and solid sprite pixel flags */
46:                  #define  BG_TRANS             0x80
47:                  #define  SP_PIXEL             0x40
48:                  #define  BG_CLEAR(V)          ((V) & BG_TRANS)
49:                  #define  BG_SOLID(V)          (0 == BG_CLEAR(V))
50:                  #define  SP_CLEAR(V)          (0 == ((V) & SP_PIXEL))
51:                  
52:                  /* Full BG color */
53:                  #define  FULLBG               (ppu.palette[0] | BG_TRANS)
54:                  
55:                  /* the NES PPU */
56:                  static ppu_t ppu;
57:                  
58:                  
59:                  void ppu_displaysprites(bool display)
60:                  {
61:                     ppu.drawsprites = display;
9D018A28  3C02A000   LUI V0, -24576
9D018A2C  03E00008   JR RA
9D018A30  AC447FCC   SW A0, 32716(V0)
62:                  }
63:                  
64:                  void ppu_setcontext(ppu_t *src_ppu)
65:                  {
66:                     int nametab[4];
67:                     ASSERT(src_ppu);
68:                     ppu = *src_ppu;
9D018A34  00801021   ADDU V0, A0, ZERO
9D018A38  3C03A000   LUI V1, -24576
9D018A3C  24636218   ADDIU V1, V1, 25112
9D018A40  24851DB0   ADDIU A1, A0, 7600
9D018A44  8C490000   LW T1, 0(V0)
9D018A48  8C480004   LW T0, 4(V0)
9D018A4C  8C470008   LW A3, 8(V0)
9D018A50  8C46000C   LW A2, 12(V0)
9D018A54  AC690000   SW T1, 0(V1)
9D018A58  AC680004   SW T0, 4(V1)
9D018A5C  AC670008   SW A3, 8(V1)
9D018A60  AC66000C   SW A2, 12(V1)
9D018A64  24420010   ADDIU V0, V0, 16
9D018A68  1445FFF6   BNE V0, A1, 0x9D018A44
9D018A6C  24630010   ADDIU V1, V1, 16
9D018A70  8C450000   LW A1, 0(V0)
9D018A74  8C420004   LW V0, 4(V0)
9D018A78  AC650000   SW A1, 0(V1)
9D018A7C  AC620004   SW V0, 4(V1)
69:                  
70:                     /* we can't just copy contexts here, because more than likely,
71:                     ** the top 8 pages of the ppu are pointing to internal PPU memory,
72:                     ** which means we need to recalculate the page pointers.
73:                     ** TODO: we can either get rid of the page pointing in the code,
74:                     ** or add more robust checks to make sure that pages 8-15 are
75:                     ** definitely pointing to internal PPU RAM, not just something
76:                     ** that some crazy mapper paged in.
77:                     */
78:                     nametab[0] = (src_ppu->page[8] - src_ppu->nametab + 0x2000) >> 10;
9D018AA4  8C861140   LW A2, 4416(A0)
9D018AA8  00C43023   SUBU A2, A2, A0
9D018AAC  24C62000   ADDIU A2, A2, 8192
79:                     nametab[1] = (src_ppu->page[9] - src_ppu->nametab + 0x2400) >> 10;
9D018A80  8C851144   LW A1, 4420(A0)
9D018A84  00A42823   SUBU A1, A1, A0
9D018A88  24A52400   ADDIU A1, A1, 9216
80:                     nametab[2] = (src_ppu->page[10] - src_ppu->nametab + 0x2800) >> 10;
9D018A8C  8C871148   LW A3, 4424(A0)
9D018A90  00E43823   SUBU A3, A3, A0
9D018A94  24E72800   ADDIU A3, A3, 10240
81:                     nametab[3] = (src_ppu->page[11] - src_ppu->nametab + 0x2C00) >> 10;
9D018A98  8C83114C   LW V1, 4428(A0)
9D018A9C  00641823   SUBU V1, V1, A0
9D018AA0  24632C00   ADDIU V1, V1, 11264
82:                  
83:                     ppu.page[8] = ppu.nametab + (nametab[0] << 10) - 0x2000;
9D018AB0  7C064804   INS A2, ZERO, 0, 10
9D018AB4  24C6E000   ADDIU A2, A2, -8192
9D018AB8  3C02A000   LUI V0, -24576
9D018ABC  24426218   ADDIU V0, V0, 25112
9D018AC0  00463021   ADDU A2, V0, A2
9D018AC4  AC461140   SW A2, 4416(V0)
84:                     ppu.page[9] = ppu.nametab + (nametab[1] << 10) - 0x2400;
9D018AC8  7C054804   INS A1, ZERO, 0, 10
9D018ACC  24A5DC00   ADDIU A1, A1, -9216
9D018AD0  00452821   ADDU A1, V0, A1
9D018AD4  AC451144   SW A1, 4420(V0)
85:                     ppu.page[10] = ppu.nametab + (nametab[2] << 10) - 0x2800;
9D018AD8  2408FC00   ADDIU T0, ZERO, -1024
9D018ADC  00E82024   AND A0, A3, T0
9D018AE0  2484D800   ADDIU A0, A0, -10240
9D018AE4  00442021   ADDU A0, V0, A0
9D018AE8  AC441148   SW A0, 4424(V0)
86:                     ppu.page[11] = ppu.nametab + (nametab[3] << 10) - 0x2C00;
9D018AEC  7C034804   INS V1, ZERO, 0, 10
9D018AF0  2463D400   ADDIU V1, V1, -11264
9D018AF4  00431821   ADDU V1, V0, V1
9D018AF8  AC43114C   SW V1, 4428(V0)
87:                     ppu.page[12] = ppu.page[8] - 0x1000;
9D018AFC  24C6F000   ADDIU A2, A2, -4096
9D018B00  AC461150   SW A2, 4432(V0)
88:                     ppu.page[13] = ppu.page[9] - 0x1000;
9D018B04  24A5F000   ADDIU A1, A1, -4096
9D018B08  AC451154   SW A1, 4436(V0)
89:                     ppu.page[14] = ppu.page[10] - 0x1000;
9D018B0C  2484F000   ADDIU A0, A0, -4096
9D018B10  AC441158   SW A0, 4440(V0)
90:                     ppu.page[15] = ppu.page[11] - 0x1000;
9D018B14  2463F000   ADDIU V1, V1, -4096
9D018B18  03E00008   JR RA
9D018B1C  AC43115C   SW V1, 4444(V0)
91:                  }
92:                  
93:                  void ppu_getcontext(ppu_t *dest_ppu)
94:                  {
95:                     int nametab[4];
96:                     
97:                     ASSERT(dest_ppu);
98:                     *dest_ppu = ppu;
9D018B20  3C02A000   LUI V0, -24576
9D018B24  24426218   ADDIU V0, V0, 25112
9D018B28  00801821   ADDU V1, A0, ZERO
9D018B2C  24451DB0   ADDIU A1, V0, 7600
9D018B30  8C490000   LW T1, 0(V0)
9D018B34  8C480004   LW T0, 4(V0)
9D018B38  8C470008   LW A3, 8(V0)
9D018B3C  8C46000C   LW A2, 12(V0)
9D018B40  AC690000   SW T1, 0(V1)
9D018B44  AC680004   SW T0, 4(V1)
9D018B48  AC670008   SW A3, 8(V1)
9D018B4C  AC66000C   SW A2, 12(V1)
9D018B50  24420010   ADDIU V0, V0, 16
9D018B54  1445FFF6   BNE V0, A1, 0x9D018B30
9D018B58  24630010   ADDIU V1, V1, 16
9D018B5C  8C450000   LW A1, 0(V0)
9D018B60  8C420004   LW V0, 4(V0)
9D018B64  AC650000   SW A1, 0(V1)
9D018B68  AC620004   SW V0, 4(V1)
99:                  
100:                    /* we can't just copy contexts here, because more than likely,
101:                    ** the top 8 pages of the ppu are pointing to internal PPU memory,
102:                    ** which means we need to recalculate the page pointers.
103:                    ** TODO: we can either get rid of the page pointing in the code,
104:                    ** or add more robust checks to make sure that pages 8-15 are
105:                    ** definitely pointing to internal PPU RAM, not just something
106:                    ** that some crazy mapper paged in.
107:                    */
108:                    nametab[0] = (ppu.page[8] - ppu.nametab + 0x2000) >> 10;
9D018B6C  3C02A000   LUI V0, -24576
9D018B70  24426218   ADDIU V0, V0, 25112
9D018BA4  24062000   ADDIU A2, ZERO, 8192
9D018BA8  00C23023   SUBU A2, A2, V0
9D018BAC  8C421140   LW V0, 4416(V0)
9D018BB0  00463021   ADDU A2, V0, A2
109:                    nametab[1] = (ppu.page[9] - ppu.nametab + 0x2400) >> 10;
9D018B74  24052400   ADDIU A1, ZERO, 9216
9D018B78  00A22823   SUBU A1, A1, V0
9D018B7C  8C431144   LW V1, 4420(V0)
9D018B80  00652821   ADDU A1, V1, A1
110:                    nametab[2] = (ppu.page[10] - ppu.nametab + 0x2800) >> 10;
9D018B84  24032800   ADDIU V1, ZERO, 10240
9D018B88  00621823   SUBU V1, V1, V0
9D018B8C  8C461148   LW A2, 4424(V0)
9D018B90  00C31821   ADDU V1, A2, V1
111:                    nametab[3] = (ppu.page[11] - ppu.nametab + 0x2C00) >> 10;
9D018B94  24072C00   ADDIU A3, ZERO, 11264
9D018B98  00E23823   SUBU A3, A3, V0
9D018B9C  8C46114C   LW A2, 4428(V0)
9D018BA0  00C73821   ADDU A3, A2, A3
112:                 
113:                    dest_ppu->page[8] = dest_ppu->nametab + (nametab[0] << 10) - 0x2000;
9D018BB4  7C064804   INS A2, ZERO, 0, 10
9D018BB8  24C6E000   ADDIU A2, A2, -8192
9D018BBC  00863021   ADDU A2, A0, A2
9D018BC0  AC861140   SW A2, 4416(A0)
114:                    dest_ppu->page[9] = dest_ppu->nametab + (nametab[1] << 10) - 0x2400;
9D018BC4  7C054804   INS A1, ZERO, 0, 10
9D018BC8  24A5DC00   ADDIU A1, A1, -9216
9D018BCC  00852821   ADDU A1, A0, A1
9D018BD0  AC851144   SW A1, 4420(A0)
115:                    dest_ppu->page[10] = dest_ppu->nametab + (nametab[2] << 10) - 0x2800;
9D018BD4  7C034804   INS V1, ZERO, 0, 10
9D018BD8  2463D800   ADDIU V1, V1, -10240
9D018BDC  00831821   ADDU V1, A0, V1
9D018BE0  AC831148   SW V1, 4424(A0)
116:                    dest_ppu->page[11] = dest_ppu->nametab + (nametab[3] << 10) - 0x2C00;
9D018BE4  2408FC00   ADDIU T0, ZERO, -1024
9D018BE8  00E81024   AND V0, A3, T0
9D018BEC  2442D400   ADDIU V0, V0, -11264
9D018BF0  00821021   ADDU V0, A0, V0
9D018BF4  AC82114C   SW V0, 4428(A0)
117:                    dest_ppu->page[12] = dest_ppu->page[8] - 0x1000;
9D018BF8  24C6F000   ADDIU A2, A2, -4096
9D018BFC  AC861150   SW A2, 4432(A0)
118:                    dest_ppu->page[13] = dest_ppu->page[9] - 0x1000;
9D018C00  24A5F000   ADDIU A1, A1, -4096
9D018C04  AC851154   SW A1, 4436(A0)
119:                    dest_ppu->page[14] = dest_ppu->page[10] - 0x1000;
9D018C08  2463F000   ADDIU V1, V1, -4096
9D018C0C  AC831158   SW V1, 4440(A0)
120:                    dest_ppu->page[15] = dest_ppu->page[11] - 0x1000;
9D018C10  2442F000   ADDIU V0, V0, -4096
9D018C14  03E00008   JR RA
9D018C18  AC82115C   SW V0, 4444(A0)
121:                 }
122:                 
123:                 ppu_t *ppu_create(void)
124:                 {
9D0196A4  27BDFFE8   ADDIU SP, SP, -24
9D0196A8  AFBF0014   SW RA, 20(SP)
9D0196AC  AFB00010   SW S0, 16(SP)
125:                    static bool pal_generated = false;
126:                    ppu_t *temp;
127:                 
128:                    temp = malloc(sizeof(ppu_t));
9D0196B0  0F40DDB7   JAL _my_malloc
9D0196B4  24041DB8   ADDIU A0, ZERO, 7608
129:                    if (NULL == temp)
9D0196B8  10400012   BEQ V0, ZERO, 0x9D019704
9D0196BC  00408021   ADDU S0, V0, ZERO
130:                       return NULL;
9D019704  00001021   ADDU V0, ZERO, ZERO
131:                 
132:                    memset(temp, 0, sizeof(ppu_t));
9D0196C0  00402021   ADDU A0, V0, ZERO
9D0196C4  00002821   ADDU A1, ZERO, ZERO
9D0196C8  0F40E9FC   JAL .Letext0, .LFE0, memset
9D0196CC  24061DB8   ADDIU A2, ZERO, 7608
133:                 
134:                    temp->latchfunc = NULL;
135:                    temp->vromswitch = NULL;
136:                    temp->vram_present = false;
137:                    temp->drawsprites = true;
9D0196D0  24020001   ADDIU V0, ZERO, 1
9D0196D4  AE021DB4   SW V0, 7604(S0)
138:                 
139:                    /* TODO: probably a better way to do this... */
140:                    if (false == pal_generated)
9D0196D8  8F82810C   LW V0, -32500(GP)
9D0196DC  14400005   BNE V0, ZERO, 0x9D0196F4
9D0196E0  00000000   NOP
141:                    {
142:                       pal_generate();
9D0196E4  0F40C32A   JAL pal_generate
9D0196E8  00000000   NOP
143:                       pal_generated = true;
9D0196EC  24020001   ADDIU V0, ZERO, 1
9D0196F0  AF82810C   SW V0, -32500(GP)
144:                    }
145:                 
146:                    ppu_setdefaultpal(temp);
9D0196F4  0F4065A1   JAL ppu_setdefaultpal
9D0196F8  02002021   ADDU A0, S0, ZERO
147:                 
148:                    return temp;
9D0196FC  0B4065C2   J 0x9D019708
9D019700  02001021   ADDU V0, S0, ZERO
149:                 }
9D019708  8FBF0014   LW RA, 20(SP)
9D01970C  8FB00010   LW S0, 16(SP)
9D019710  03E00008   JR RA
9D019714  27BD0018   ADDIU SP, SP, 24
150:                 
151:                 void ppu_destroy(ppu_t **src_ppu)
152:                 {
9D018C1C  27BDFFE8   ADDIU SP, SP, -24
9D018C20  AFBF0014   SW RA, 20(SP)
9D018C24  AFB00010   SW S0, 16(SP)
153:                    if (*src_ppu)
9D018C28  8C820000   LW V0, 0(A0)
9D018C2C  10400004   BEQ V0, ZERO, 0x9D018C40
9D018C30  00808021   ADDU S0, A0, ZERO
154:                    {
155:                       free(*src_ppu);
9D018C34  0F40DDCA   JAL _my_free
9D018C38  00000000   NOP
156:                       *src_ppu = NULL;
9D018C3C  AE000000   SW ZERO, 0(S0)
157:                    }
158:                 }
9D018C40  8FBF0014   LW RA, 20(SP)
9D018C44  8FB00010   LW S0, 16(SP)
9D018C48  03E00008   JR RA
9D018C4C  27BD0018   ADDIU SP, SP, 24
159:                 
160:                 void ppu_setpage(int size, int page_num, uint8 *location)
161:                 {
162:                    /* deliberately fall through */
163:                    switch (size)
9D018C50  24020002   ADDIU V0, ZERO, 2
9D018C54  10820029   BEQ A0, V0, 0x9D018CFC
9D018C58  28820003   SLTI V0, A0, 3
9D018C5C  50400006   BEQL V0, ZERO, 0x9D018C78
9D018C60  24020004   ADDIU V0, ZERO, 4
9D018C64  24030001   ADDIU V1, ZERO, 1
9D018C68  1083002B   BEQ A0, V1, 0x9D018D18
9D018C6C  00A01021   ADDU V0, A1, ZERO
9D018C70  03E00008   JR RA
9D018C74  00000000   NOP
9D018C78  10820015   BEQ A0, V0, 0x9D018CD0
9D018C7C  24020008   ADDIU V0, ZERO, 8
9D018C80  1482FFFB   BNE A0, V0, 0x9D018C70
9D018C84  24A30448   ADDIU V1, A1, 1096
164:                    {
165:                    case 8:  
166:                       ppu.page[page_num++] = location;
9D018C88  00031880   SLL V1, V1, 2
9D018C8C  3C02A000   LUI V0, -24576
9D018C90  24426218   ADDIU V0, V0, 25112
9D018C94  00621821   ADDU V1, V1, V0
9D018C98  AC660000   SW A2, 0(V1)
167:                       ppu.page[page_num++] = location;
9D018C9C  24A30449   ADDIU V1, A1, 1097
9D018CA0  00031880   SLL V1, V1, 2
9D018CA4  00621821   ADDU V1, V1, V0
9D018CA8  AC660000   SW A2, 0(V1)
168:                       ppu.page[page_num++] = location;
9D018CAC  24A4044A   ADDIU A0, A1, 1098
9D018CB0  00042080   SLL A0, A0, 2
9D018CB4  00822021   ADDU A0, A0, V0
9D018CB8  AC860000   SW A2, 0(A0)
169:                       ppu.page[page_num++] = location;
9D018CBC  24A3044B   ADDIU V1, A1, 1099
9D018CC0  24A50004   ADDIU A1, A1, 4
9D018CC4  00031880   SLL V1, V1, 2
9D018CC8  00621021   ADDU V0, V1, V0
9D018CCC  AC460000   SW A2, 0(V0)
170:                    case 4:  
171:                       ppu.page[page_num++] = location;
9D018CD0  24A40448   ADDIU A0, A1, 1096
9D018CD4  00042080   SLL A0, A0, 2
9D018CD8  3C02A000   LUI V0, -24576
9D018CDC  24426218   ADDIU V0, V0, 25112
9D018CE0  00822021   ADDU A0, A0, V0
9D018CE4  AC860000   SW A2, 0(A0)
172:                       ppu.page[page_num++] = location;
9D018CE8  24A30449   ADDIU V1, A1, 1097
9D018CEC  24A50002   ADDIU A1, A1, 2
9D018CF0  00031880   SLL V1, V1, 2
9D018CF4  00621021   ADDU V0, V1, V0
9D018CF8  AC460000   SW A2, 0(V0)
173:                    case 2:
174:                       ppu.page[page_num++] = location;
9D018CFC  24A20001   ADDIU V0, A1, 1
9D018D00  24A50448   ADDIU A1, A1, 1096
9D018D04  00052880   SLL A1, A1, 2
9D018D08  3C03A000   LUI V1, -24576
9D018D0C  24636218   ADDIU V1, V1, 25112
9D018D10  00A32821   ADDU A1, A1, V1
9D018D14  ACA60000   SW A2, 0(A1)
175:                    case 1:
176:                       ppu.page[page_num++] = location;
9D018D18  24420448   ADDIU V0, V0, 1096
9D018D1C  00021080   SLL V0, V0, 2
9D018D20  3C03A000   LUI V1, -24576
9D018D24  24636218   ADDIU V1, V1, 25112
9D018D28  00431021   ADDU V0, V0, V1
9D018D2C  AC460000   SW A2, 0(V0)
9D018D30  03E00008   JR RA
9D018D34  00000000   NOP
177:                       break;
178:                    }
179:                 }
180:                 
181:                 /* make sure $3000-$3F00 mirrors $2000-$2F00 */
182:                 void ppu_mirrorhipages(void)
183:                 {
184:                    ppu.page[12] = ppu.page[8] - 0x1000;
9D018D38  3C02A000   LUI V0, -24576
9D018D3C  24426218   ADDIU V0, V0, 25112
9D018D40  8C431140   LW V1, 4416(V0)
9D018D44  2463F000   ADDIU V1, V1, -4096
9D018D48  AC431150   SW V1, 4432(V0)
185:                    ppu.page[13] = ppu.page[9] - 0x1000;
9D018D4C  8C431144   LW V1, 4420(V0)
9D018D50  2463F000   ADDIU V1, V1, -4096
9D018D54  AC431154   SW V1, 4436(V0)
186:                    ppu.page[14] = ppu.page[10] - 0x1000;
9D018D58  8C431148   LW V1, 4424(V0)
9D018D5C  2463F000   ADDIU V1, V1, -4096
9D018D60  AC431158   SW V1, 4440(V0)
187:                    ppu.page[15] = ppu.page[11] - 0x1000;
9D018D64  8C43114C   LW V1, 4428(V0)
9D018D68  2463F000   ADDIU V1, V1, -4096
9D018D6C  03E00008   JR RA
9D018D70  AC43115C   SW V1, 4444(V0)
188:                 }
189:                 
190:                 void ppu_mirror(int nt1, int nt2, int nt3, int nt4)
191:                 {
192:                    ppu.page[8] = ppu.nametab + (nt1 << 10) - 0x2000;
9D018D74  00042280   SLL A0, A0, 10
9D018D78  2483E000   ADDIU V1, A0, -8192
9D018D7C  3C02A000   LUI V0, -24576
9D018D80  24426218   ADDIU V0, V0, 25112
9D018D84  00431821   ADDU V1, V0, V1
9D018D88  AC431140   SW V1, 4416(V0)
193:                    ppu.page[9] = ppu.nametab + (nt2 << 10) - 0x2400;
9D018D8C  00052A80   SLL A1, A1, 10
9D018D90  24A4DC00   ADDIU A0, A1, -9216
9D018D94  00442021   ADDU A0, V0, A0
9D018D98  AC441144   SW A0, 4420(V0)
194:                    ppu.page[10] = ppu.nametab + (nt3 << 10) - 0x2800;
9D018D9C  00063280   SLL A2, A2, 10
9D018DA0  24C5D800   ADDIU A1, A2, -10240
9D018DA4  00452821   ADDU A1, V0, A1
9D018DA8  AC451148   SW A1, 4424(V0)
195:                    ppu.page[11] = ppu.nametab + (nt4 << 10) - 0x2C00;
9D018DAC  00073A80   SLL A3, A3, 10
9D018DB0  24E6D400   ADDIU A2, A3, -11264
9D018DB4  00463021   ADDU A2, V0, A2
9D018DB8  AC46114C   SW A2, 4428(V0)
196:                    ppu.page[12] = ppu.page[8] - 0x1000;
9D018DBC  2463F000   ADDIU V1, V1, -4096
9D018DC0  AC431150   SW V1, 4432(V0)
197:                    ppu.page[13] = ppu.page[9] - 0x1000;
9D018DC4  2484F000   ADDIU A0, A0, -4096
9D018DC8  AC441154   SW A0, 4436(V0)
198:                    ppu.page[14] = ppu.page[10] - 0x1000;
9D018DCC  24A5F000   ADDIU A1, A1, -4096
9D018DD0  AC451158   SW A1, 4440(V0)
199:                    ppu.page[15] = ppu.page[11] - 0x1000;
9D018DD4  24C6F000   ADDIU A2, A2, -4096
9D018DD8  03E00008   JR RA
9D018DDC  AC46115C   SW A2, 4444(V0)
200:                 }
201:                 
202:                 /* bleh, for snss */
203:                 uint8 *ppu_getpage(int page)
204:                 {
205:                    return ppu.page[page];
9D018DE0  24840448   ADDIU A0, A0, 1096
9D018DE4  00041080   SLL V0, A0, 2
9D018DE8  3C03A000   LUI V1, -24576
9D018DEC  24636218   ADDIU V1, V1, 25112
9D018DF0  00431021   ADDU V0, V0, V1
206:                 }
9D018DF4  03E00008   JR RA
9D018DF8  8C420000   LW V0, 0(V0)
207:                 
208:                 static void mem_trash(uint8 *buffer, int length)
209:                 {
210:                    int i;
211:                 
212:                    for (i = 0; i < length; i++)
9D018E38  1611FFFB   BNE S0, S1, .LBB4, .LBB5
213:                       buffer[i] = (uint8) rand();
9D018E28  0F40EF88   JAL .Letext0, .LFE0, rand
9D018E2C  00000000   NOP
9D018E30  A2020000   SB V0, 0(S0)
9D018E34  26100001   ADDIU S0, S0, 1
9D018E38  1611FFFB   BNE S0, S1, .LBB4, .LBB5
9D018E3C  3C02A000   LUI V0, -24576
214:                 }
215:                 
216:                 /* reset state of ppu */
217:                 void ppu_reset(int reset_type)
218:                 {
9D018E08  27BDFFE0   ADDIU SP, SP, -32
9D018E0C  AFBF001C   SW RA, 28(SP)
9D018E10  AFB10018   SW S1, 24(SP)
9D018E14  AFB00014   SW S0, 20(SP)
9D018E18  3C10A000   LUI S0, -24576
9D018E1C  26107218   ADDIU S0, S0, 29208
9D018E20  3C11A000   LUI S1, -24576
9D018E24  26317318   ADDIU S1, S1, 29464
219:                    if (HARD_RESET == reset_type)
9D018DFC  24020001   ADDIU V0, ZERO, 1
9D018E00  14820022   BNE A0, V0, 0x9D018E8C
9D018E04  3C02A000   LUI V0, -24576
220:                       mem_trash(ppu.oam, 256);
221:                 
222:                    ppu.ctrl0 = 0;
9D018E40  24426218   ADDIU V0, V0, 25112
9D018E44  A0401160   SB ZERO, 4448(V0)
9D018E8C  24426218   ADDIU V0, V0, 25112
9D018E90  A0401160   SB ZERO, 4448(V0)
223:                    ppu.ctrl1 = PPU_CTRL1F_OBJON | PPU_CTRL1F_BGON;
9D018E48  24030018   ADDIU V1, ZERO, 24
9D018E4C  A0431161   SB V1, 4449(V0)
9D018E94  24030018   ADDIU V1, ZERO, 24
9D018E98  A0431161   SB V1, 4449(V0)
224:                    ppu.stat = 0;
9D018E50  A0401162   SB ZERO, 4450(V0)
9D018E9C  A0401162   SB ZERO, 4450(V0)
225:                    ppu.flipflop = 0;
9D018E54  AC401170   SW ZERO, 4464(V0)
9D018EA0  AC401170   SW ZERO, 4464(V0)
226:                    ppu.vaddr = ppu.vaddr_latch = 0x2000;
9D018E58  24032000   ADDIU V1, ZERO, 8192
9D018E5C  AC431168   SW V1, 4456(V0)
9D018E60  AC431164   SW V1, 4452(V0)
9D018EA4  24032000   ADDIU V1, ZERO, 8192
9D018EA8  AC431168   SW V1, 4456(V0)
9D018EAC  AC431164   SW V1, 4452(V0)
227:                    ppu.oam_addr = 0;
9D018E64  A0401163   SB ZERO, 4451(V0)
9D018EB0  A0401163   SB ZERO, 4451(V0)
228:                    ppu.tile_xofs = 0;
9D018E68  AC40116C   SW ZERO, 4460(V0)
9D018EB4  AC40116C   SW ZERO, 4460(V0)
229:                 
230:                    ppu.latch = 0;
9D018E6C  A0401198   SB ZERO, 4504(V0)
9D018EB8  A0401198   SB ZERO, 4504(V0)
231:                    ppu.vram_accessible = true;
9D018E70  24030001   ADDIU V1, ZERO, 1
9D018E74  AC431DAC   SW V1, 7596(V0)
9D018EBC  24030001   ADDIU V1, ZERO, 1
9D018EC0  03E00008   JR RA
9D018EC4  AC431DAC   SW V1, 7596(V0)
232:                 }
9D018E78  8FBF001C   LW RA, 28(SP)
9D018E7C  8FB10018   LW S1, 24(SP)
9D018E80  8FB00014   LW S0, 20(SP)
9D018E84  03E00008   JR RA
9D018E88  27BD0020   ADDIU SP, SP, 32
9D018E8C  24426218   ADDIU V0, V0, 25112
9D018E90  A0401160   SB ZERO, 4448(V0)
9D018E94  24030018   ADDIU V1, ZERO, 24
9D018E98  A0431161   SB V1, 4449(V0)
9D018E9C  A0401162   SB ZERO, 4450(V0)
9D018EA0  AC401170   SW ZERO, 4464(V0)
9D018EA4  24032000   ADDIU V1, ZERO, 8192
9D018EA8  AC431168   SW V1, 4456(V0)
9D018EAC  AC431164   SW V1, 4452(V0)
9D018EB0  A0401163   SB ZERO, 4451(V0)
9D018EB4  AC40116C   SW ZERO, 4460(V0)
9D018EB8  A0401198   SB ZERO, 4504(V0)
9D018EBC  24030001   ADDIU V1, ZERO, 1
9D018EC0  03E00008   JR RA
9D018EC4  AC431DAC   SW V1, 7596(V0)
233:                 
234:                 /* we render a scanline of graphics first so we know exactly
235:                 ** where the sprite 0 strike is going to occur (in terms of
236:                 ** cpu cycles), using the relation that 3 pixels == 1 cpu cycle
237:                 */
238:                 static void ppu_setstrike(int x_loc)
239:                 {
9D0189C8  27BDFFE0   ADDIU SP, SP, -32
9D0189CC  AFBF001C   SW RA, 28(SP)
9D0189D0  AFB10018   SW S1, 24(SP)
9D0189D4  AFB00014   SW S0, 20(SP)
9D0189D8  00808021   ADDU S0, A0, ZERO
240:                    if (false == ppu.strikeflag)
9D0189B8  3C02A000   LUI V0, -24576
9D0189BC  8C4273B4   LW V0, 29620(V0)
9D0189C0  14400017   BNE V0, ZERO, 0x9D018A20
9D0189C4  24020001   ADDIU V0, ZERO, 1
241:                    {
242:                       ppu.strikeflag = true;
9D0189DC  3C11A000   LUI S1, -24576
9D0189E0  26316218   ADDIU S1, S1, 25112
9D0189E4  AE22119C   SW V0, 4508(S1)
243:                 
244:                       /* 3 pixels per cpu cycle */
245:                       ppu.strike_cycle = nes6502_getcycles(false) + (x_loc / 3);
9D0189E8  0F4000C4   JAL nes6502_getcycles
9D0189EC  00002021   ADDU A0, ZERO, ZERO
9D0189F0  3C035555   LUI V1, 21845
9D0189F4  24635556   ADDIU V1, V1, 21846
9D0189F8  02030018   MULT 0, S0, V1
9D0189FC  00001810   MFHI V1
9D018A00  001087C3   SRA S0, S0, 31
9D018A04  00708023   SUBU S0, V1, S0
9D018A08  00501021   ADDU V0, V0, S0
9D018A0C  AE2211A0   SW V0, 4512(S1)
246:                    }
247:                 }
9D018A10  8FBF001C   LW RA, 28(SP)
9D018A14  8FB10018   LW S1, 24(SP)
9D018A18  8FB00014   LW S0, 20(SP)
9D018A1C  27BD0020   ADDIU SP, SP, 32
9D018A20  03E00008   JR RA
9D018A24  00000000   NOP
248:                 
249:                 static void ppu_oamdma(uint8 value)
250:                 {
251:                    uint32 cpu_address;
252:                    uint8 oam_loc;
253:                 
254:                    cpu_address = (uint32) (value << 8);
9D018F04  00058200   SLL S0, A1, 8
255:                 
256:                    /* Sprite DMA starts at the current SPRRAM address */
257:                    oam_loc = ppu.oam_addr;
9D018F08  3C02A000   LUI V0, -24576
9D018F0C  9052737B   LBU S2, 29563(V0)
258:                    do
259:                    {
260:                       ppu.oam[oam_loc++] = nes6502_getbyte(cpu_address++);
9D018F10  3C13A000   LUI S3, -24576
9D018F14  26736218   ADDIU S3, S3, 25112
9D018F18  26510001   ADDIU S1, S2, 1
9D018F1C  323100FF   ANDI S1, S1, 255
9D018F20  26140001   ADDIU S4, S0, 1
9D018F24  0F4000BA   JAL nes6502_getbyte
9D018F28  02002021   ADDU A0, S0, ZERO
9D018F2C  02539021   ADDU S2, S2, S3
9D018F30  A2421000   SB V0, 4096(S2)
9D018F40  0B4063C6   J 0x9D018F18
9D018F44  02808021   ADDU S0, S4, ZERO
261:                    }
262:                    while (oam_loc != ppu.oam_addr);
9D018F34  92621163   LBU V0, 4451(S3)
9D018F38  10510003   BEQ V0, S1, 0x9D018F48
9D018F3C  02209021   ADDU S2, S1, ZERO
263:                 
264:                    /* TODO: enough with houdini */
265:                    cpu_address -= 256;
266:                    /* Odd address in $2003 */
267:                    if ((ppu.oam_addr >> 2) & 1)
9D018F48  7E310080   EXT S1, S1, 2, 1
9D018F4C  12200015   BEQ S1, ZERO, 0x9D018FA4
9D018F50  2604FF01   ADDIU A0, S0, -255
9D018F54  3C11A000   LUI S1, -24576
9D018F58  26316218   ADDIU S1, S1, 25112
9D018F5C  2614FF05   ADDIU S4, S0, -251
9D018F60  02209021   ADDU S2, S1, ZERO
268:                    {
269:                       for (oam_loc = 4; oam_loc < 8; oam_loc++)
9D018F70  12740003   BEQ S3, S4, 0x9D018F80
9D018F74  26520001   ADDIU S2, S2, 1
270:                          ppu.oam[oam_loc] = nes6502_getbyte(cpu_address++);
9D018F64  0F4000BA   JAL nes6502_getbyte
9D018F68  24930001   ADDIU S3, A0, 1
9D018F6C  A2421004   SB V0, 4100(S2)
9D018F78  0B4063D9   J 0x9D018F64
9D018F7C  02602021   ADDU A0, S3, ZERO
271:                       cpu_address += 248;
9D018F80  2604FFFD   ADDIU A0, S0, -3
9D018F84  26100001   ADDIU S0, S0, 1
272:                       for (oam_loc = 0; oam_loc < 4; oam_loc++)
9D018F94  1250000E   BEQ S2, S0, 0x9D018FD0
9D018F98  26310001   ADDIU S1, S1, 1
273:                          ppu.oam[oam_loc] = nes6502_getbyte(cpu_address++);
9D018F88  0F4000BA   JAL nes6502_getbyte
9D018F8C  24920001   ADDIU S2, A0, 1
9D018F90  A2221000   SB V0, 4096(S1)
9D018F9C  0B4063E2   J 0x9D018F88
9D018FA0  02402021   ADDU A0, S2, ZERO
9D018FA4  2612FF09   ADDIU S2, S0, -247
9D018FA8  3C02A000   LUI V0, -24576
9D018FAC  24426218   ADDIU V0, V0, 25112
9D018FB0  00508023   SUBU S0, V0, S0
274:                    }
275:                    /* Even address in $2003 */
276:                    else
277:                    {
278:                       for (oam_loc = 0; oam_loc < 8; oam_loc++)
9D018FC0  12320003   BEQ S1, S2, 0x9D018FD0
9D018FC4  A06210FE   SB V0, 4350(V1)
279:                          ppu.oam[oam_loc] = nes6502_getbyte(cpu_address++);
9D018FB4  0F4000BA   JAL nes6502_getbyte
9D018FB8  24910001   ADDIU S1, A0, 1
9D018FBC  02111821   ADDU V1, S0, S1
9D018FC8  0B4063ED   J 0x9D018FB4
9D018FCC  02202021   ADDU A0, S1, ZERO
280:                    }
281:                 
282:                    /* make the CPU spin for DMA cycles */
283:                    nes6502_burn(513);
9D018FD0  0F402895   JAL nes6502_burn
9D018FD4  24040201   ADDIU A0, ZERO, 513
284:                    nes6502_release();
9D018FD8  0F40289B   JAL nes6502_release
9D018FDC  00000000   NOP
285:                 }
286:                 
287:                 /* TODO: this isn't the PPU! */
288:                 void ppu_writehigh(uint32 address, uint8 value)
289:                 {
9D018EC8  27BDFFD8   ADDIU SP, SP, -40
9D018ECC  AFBF0024   SW RA, 36(SP)
9D018ED0  AFB40020   SW S4, 32(SP)
9D018ED4  AFB3001C   SW S3, 28(SP)
9D018ED8  AFB20018   SW S2, 24(SP)
9D018EDC  AFB10014   SW S1, 20(SP)
9D018EE0  AFB00010   SW S0, 16(SP)
290:                    switch (address)
9D018EE4  24024016   ADDIU V0, ZERO, 16406
9D018EE8  1082003F   BEQ A0, V0, 0x9D018FE8
9D018EEC  00A08021   ADDU S0, A1, ZERO
9D018EF0  24024017   ADDIU V0, ZERO, 16407
9D018EF4  1082004D   BEQ A0, V0, 0x9D01902C
9D018EF8  24024014   ADDIU V0, ZERO, 16404
9D018EFC  1482004E   BNE A0, V0, 0x9D019038
9D018F00  8FBF0024   LW RA, 36(SP)
291:                    {
292:                    case PPU_OAMDMA:
293:                       ppu_oamdma(value);
294:                       break;
295:                 
296:                    case PPU_JOY0:
297:                       /* VS system VROM switching - bleh!*/
298:                       if (ppu.vromswitch)
9D018FE8  3C02A000   LUI V0, -24576
9D018FEC  8C4273C0   LW V0, 29632(V0)
9D018FF0  50400004   BEQL V0, ZERO, 0x9D019004
9D018FF4  32100001   ANDI S0, S0, 1
299:                          ppu.vromswitch(value);
9D018FF8  0040F809   JALR V0
9D018FFC  00A02021   ADDU A0, A1, ZERO
300:                 
301:                       /* see if we need to strobe them joypads */
302:                       value &= 1;
9D019000  32100001   ANDI S0, S0, 1
303:                       
304:                       if (0 == value && ppu.strobe)
9D019004  16000006   BNE S0, ZERO, .LVL83
9D019008  3C02A000   LUI V0, -24576
9D01900C  904273B2   LBU V0, 29618(V0)
9D019010  10400004   BEQ V0, ZERO, 0x9D019024
9D019014  3C02A000   LUI V0, -24576
305:                          input_strobe();
9D019018  0F40CF06   JAL input_strobe
9D01901C  00000000   NOP
306:                 
307:                       ppu.strobe = value;
9D019020  3C02A000   LUI V0, -24576
308:                       break;
9D019024  0B40640D   J .LVL85
9D019028  A05073B2   SB S0, 29618(V0)
309:                 
310:                    case PPU_JOY1: /* frame IRQ control */
311:                       nes_setfiq(value);
9D01902C  0F408D4D   JAL nes_setfiq
9D019030  00A02021   ADDU A0, A1, ZERO
312:                       break;
313:                 
314:                    default:
315:                       break;
316:                    }
317:                 }
9D018FE0  0B40640E   J 0x9D019038
9D018FE4  8FBF0024   LW RA, 36(SP)
9D019034  8FBF0024   LW RA, 36(SP)
9D019038  8FB40020   LW S4, 32(SP)
9D01903C  8FB3001C   LW S3, 28(SP)
9D019040  8FB20018   LW S2, 24(SP)
9D019044  8FB10014   LW S1, 20(SP)
9D019048  8FB00010   LW S0, 16(SP)
9D01904C  03E00008   JR RA
9D019050  27BD0028   ADDIU SP, SP, 40
318:                 
319:                 /* TODO: this isn't the PPU! */
320:                 uint8 ppu_readhigh(uint32 address)
321:                 {
9D019054  27BDFFE8   ADDIU SP, SP, -24
322:                    uint8 value;
323:                 
324:                    switch (address)
9D019058  24024016   ADDIU V0, ZERO, 16406
9D01905C  10820006   BEQ A0, V0, 0x9D019078
9D019060  AFBF0014   SW RA, 20(SP)
9D019064  24024017   ADDIU V0, ZERO, 16407
9D019068  10820007   BEQ A0, V0, 0x9D019088
9D01906C  00000000   NOP
325:                    {
326:                    case PPU_JOY0:
327:                       value = input_get(INP_JOYPAD0);
9D019078  0F40CE7B   JAL input_get
9D01907C  24040001   ADDIU A0, ZERO, 1
328:                       break;
9D019080  0B406427   J 0x9D01909C
9D019084  8FBF0014   LW RA, 20(SP)
329:                 
330:                    case PPU_JOY1:
331:                       /* TODO: better input handling */
332:                       value = input_get(INP_ZAPPER | INP_JOYPAD1 
9D019088  0F40CE7B   JAL input_get
9D01908C  24040006   ADDIU A0, ZERO, 6
333:                                         /*| INP_ARKANOID*/ 
334:                                         /*| INP_POWERPAD*/);
335:                       break;
9D019090  0B406427   J 0x9D01909C
9D019094  8FBF0014   LW RA, 20(SP)
336:                 
337:                    default:
338:                       value = 0xFF;
9D019070  0B406426   J 0x9D019098
9D019074  240200FF   ADDIU V0, ZERO, 255
339:                       break;
340:                    }
341:                 
342:                    return value;
343:                 }
9D019098  8FBF0014   LW RA, 20(SP)
9D01909C  03E00008   JR RA
9D0190A0  27BD0018   ADDIU SP, SP, 24
344:                 
345:                 /* Read from $2000-$2007 */
346:                 uint8 ppu_read(uint32 address)
347:                 {
9D0190A4  27BDFFE0   ADDIU SP, SP, -32
9D0190A8  AFBF001C   SW RA, 28(SP)
9D0190AC  AFB10018   SW S1, 24(SP)
348:                    uint8 value;
349:                    
350:                    /* handle mirrored reads up to $3FFF */
351:                    switch (address & 0x2007)
9D0190B0  30842007   ANDI A0, A0, 8199
9D0190B4  24022002   ADDIU V0, ZERO, 8194
9D0190B8  10820006   BEQ A0, V0, 0x9D0190D4
9D0190BC  AFB00014   SW S0, 20(SP)
9D0190C0  24022007   ADDIU V0, ZERO, 8199
9D0190C4  5082001A   BEQL A0, V0, 0x9D019130
9D0190C8  3C02A000   LUI V0, -24576
352:                    {
353:                    case PPU_STAT:
354:                       value = (ppu.stat & 0xE0) | (ppu.latch & 0x1F);
9D0190D4  3C02A000   LUI V0, -24576
9D0190D8  24426218   ADDIU V0, V0, 25112
9D0190DC  90431198   LBU V1, 4504(V0)
9D0190E0  3063001F   ANDI V1, V1, 31
9D0190E4  90501162   LBU S0, 4450(V0)
9D0190E8  321000E0   ANDI S0, S0, 224
355:                 
356:                       if (ppu.strikeflag)
9D0190EC  8C42119C   LW V0, 4508(V0)
9D0190F0  10400008   BEQ V0, ZERO, 0x9D019114
9D0190F4  02038025   OR S0, S0, V1
357:                       {
358:                          if (nes6502_getcycles(false) >= ppu.strike_cycle)
9D0190F8  0F4000C4   JAL nes6502_getcycles
9D0190FC  00002021   ADDU A0, ZERO, ZERO
9D019100  3C03A000   LUI V1, -24576
9D019104  8C6373B8   LW V1, 29624(V1)
9D019108  0043102B   SLTU V0, V0, V1
359:                             value |= PPU_STATF_STRIKE;
9D01910C  36040040   ORI A0, S0, 64
9D019110  0082800A   MOVZ S0, A0, V0
360:                       }
361:                 
362:                       /* clear both vblank flag and vram address flipflop */
363:                       ppu.stat &= ~PPU_STATF_VBLANK;
9D019114  3C02A000   LUI V0, -24576
9D019118  24426218   ADDIU V0, V0, 25112
9D01911C  90431162   LBU V1, 4450(V0)
9D019120  3063007F   ANDI V1, V1, 127
9D019124  A0431162   SB V1, 4450(V0)
364:                       ppu.flipflop = 0;
365:                       break;
9D019128  0B40647E   J 0x9D0191F8
9D01912C  AC401170   SW ZERO, 4464(V0)
366:                 
367:                    case PPU_VDATA:
368:                       /* buffered VRAM reads */
369:                       value = ppu.latch = ppu.vdata_latch;
9D019130  24426218   ADDIU V0, V0, 25112
9D019134  90501199   LBU S0, 4505(V0)
9D019138  A0501198   SB S0, 4504(V0)
370:                 
371:                       /* VRAM only accessible during VBL */
372:                       if ((ppu.bg_on || ppu.obj_on) && !ppu.vram_accessible)
9D01913C  8C421188   LW V0, 4488(V0)
9D019140  14400006   BNE V0, ZERO, 0x9D01915C
9D019144  3C02A000   LUI V0, -24576
9D019148  3C02A000   LUI V0, -24576
9D01914C  8C4273A4   LW V0, 29604(V0)
9D019150  10400012   BEQ V0, ZERO, .LBB18
9D019154  3C02A000   LUI V0, -24576
9D019158  3C02A000   LUI V0, -24576
9D01915C  8C427FC4   LW V0, 32708(V0)
9D019160  5440000E   BNEL V0, ZERO, .LBB18
9D019164  3C02A000   LUI V0, -24576
373:                       {
374:                          ppu.vdata_latch = 0xFF;
9D019168  3C02A000   LUI V0, -24576
9D01916C  24426218   ADDIU V0, V0, 25112
9D019170  2403FFFF   ADDIU V1, ZERO, -1
9D019174  A0431199   SB V1, 4505(V0)
375:                          log_printf("VRAM read at $%04X, scanline %d\n", 
9D019180  3C049D04   LUI A0, -25340
9D019184  2484BECC   ADDIU A0, A0, -16692
9D019188  02202821   ADDU A1, S1, ZERO
9D01918C  0F40F11B   JAL log_printf
9D019190  8C460320   LW A2, 800(V0)
9D019194  0B406476   J 0x9D0191D8
9D019198  3C02A000   LUI V0, -24576
376:                                     ppu.vaddr, nes_getcontextptr()->scanline);
9D019178  0F408D03   JAL nes_getcontextptr
9D01917C  8C511164   LW S1, 4452(V0)
377:                       }
378:                       else
379:                       {
380:                          uint32 addr = ppu.vaddr;
9D01919C  8C42737C   LW V0, 29564(V0)
381:                          if (addr >= 0x3000)
9D0191A0  2C443000   SLTIU A0, V0, 12288
382:                             addr -= 0x1000;
9D0191A4  2443F000   ADDIU V1, V0, -4096
9D0191A8  0064100A   MOVZ V0, V1, A0
383:                          ppu.vdata_latch = PPU_MEM(addr);
9D0191AC  00022282   SRL A0, V0, 10
9D0191B0  24840448   ADDIU A0, A0, 1096
9D0191B4  00042080   SLL A0, A0, 2
9D0191B8  3C03A000   LUI V1, -24576
9D0191BC  24636218   ADDIU V1, V1, 25112
9D0191C0  00832021   ADDU A0, A0, V1
9D0191C4  8C840000   LW A0, 0(A0)
9D0191C8  00821021   ADDU V0, A0, V0
9D0191CC  90420000   LBU V0, 0(V0)
9D0191D0  A0621199   SB V0, 4505(V1)
384:                       }
385:                 
386:                       ppu.vaddr += ppu.vaddr_inc;
9D0191DC  8C441174   LW A0, 4468(V0)
9D0191E0  8C431164   LW V1, 4452(V0)
9D0191E4  00831821   ADDU V1, A0, V1
387:                       ppu.vaddr &= 0x3FFF;
9D0191D4  3C02A000   LUI V0, -24576
9D0191D8  24426218   ADDIU V0, V0, 25112
9D0191E8  30633FFF   ANDI V1, V1, 16383
388:                       break;
9D0191EC  0B40647E   J 0x9D0191F8
9D0191F0  AC431164   SW V1, 4452(V0)
389:                 
390:                    case PPU_OAMDATA:
391:                    case PPU_CTRL0:
392:                    case PPU_CTRL1:
393:                    case PPU_OAMADDR:
394:                    case PPU_SCROLL:
395:                    case PPU_VADDR:
396:                    default:
397:                       value = ppu.latch;
9D0190CC  0B40647D   J 0x9D0191F4
9D0190D0  3C02A000   LUI V0, -24576
9D0191F4  905073B0   LBU S0, 29616(V0)
398:                       break;
399:                    }
400:                 
401:                    return value;
402:                 }
9D0191F8  02001021   ADDU V0, S0, ZERO
9D0191FC  8FBF001C   LW RA, 28(SP)
9D019200  8FB10018   LW S1, 24(SP)
9D019204  8FB00014   LW S0, 20(SP)
9D019208  03E00008   JR RA
9D01920C  27BD0020   ADDIU SP, SP, 32
403:                 
404:                 /* Write to $2000-$2007 */
405:                 void ppu_write(uint32 address, uint8 value)
406:                 {
9D019448  27BDFFE8   ADDIU SP, SP, -24
9D01944C  AFBF0014   SW RA, 20(SP)
9D019450  AFB00010   SW S0, 16(SP)
407:                    /* write goes into ppu latch... */
408:                    ppu.latch = value;
9D019210  3C02A000   LUI V0, -24576
9D019214  A04573B0   SB A1, 29616(V0)
409:                    
410:                    switch (address & 0x2007)
9D019218  30842007   ANDI A0, A0, 8199
9D01921C  2484E000   ADDIU A0, A0, -8192
9D019220  2C820008   SLTIU V0, A0, 8
9D019224  104000E2   BEQ V0, ZERO, 0x9D0195B0
9D019228  00042080   SLL A0, A0, 2
9D01922C  3C029D02   LUI V0, -25342
9D019230  24429244   ADDIU V0, V0, -28092
9D019234  00442021   ADDU A0, V0, A0
9D019238  8C820000   LW V0, 0(A0)
9D01923C  00400008   JR V0
9D019240  00000000   NOP
411:                    {
412:                    case PPU_CTRL0:
413:                       ppu.ctrl0 = value;
9D019264  3C02A000   LUI V0, -24576
9D019268  A0457378   SB A1, 29560(V0)
414:                 
415:                       ppu.obj_height = (value & PPU_CTRL0F_OBJ16) ? 16 : 8;
9D01926C  30A30020   ANDI V1, A1, 32
9D019270  306300FF   ANDI V1, V1, 255
9D019274  24020010   ADDIU V0, ZERO, 16
9D019278  24040008   ADDIU A0, ZERO, 8
9D01927C  0083100A   MOVZ V0, A0, V1
9D019280  00401821   ADDU V1, V0, ZERO
9D019284  3C02A000   LUI V0, -24576
9D019288  A0437394   SB V1, 29588(V0)
416:                       ppu.bg_base = (value & PPU_CTRL0F_BGADDR) ? 0x1000 : 0;
9D01928C  30A30010   ANDI V1, A1, 16
9D019290  306300FF   ANDI V1, V1, 255
9D019294  24021000   ADDIU V0, ZERO, 4096
9D019298  0003100A   MOVZ V0, ZERO, V1
9D01929C  00401821   ADDU V1, V0, ZERO
9D0192A0  3C02A000   LUI V0, -24576
9D0192A4  AC43739C   SW V1, 29596(V0)
417:                       ppu.obj_base = (value & PPU_CTRL0F_OBJADDR) ? 0x1000 : 0;
9D0192A8  30A30008   ANDI V1, A1, 8
9D0192AC  306300FF   ANDI V1, V1, 255
9D0192B0  24021000   ADDIU V0, ZERO, 4096
9D0192B4  0003100A   MOVZ V0, ZERO, V1
9D0192B8  00401821   ADDU V1, V0, ZERO
9D0192BC  3C02A000   LUI V0, -24576
9D0192C0  AC437398   SW V1, 29592(V0)
418:                       ppu.vaddr_inc = (value & PPU_CTRL0F_ADDRINC) ? 32 : 1;
9D0192C4  30A30004   ANDI V1, A1, 4
9D0192C8  306300FF   ANDI V1, V1, 255
9D0192CC  24020020   ADDIU V0, ZERO, 32
9D0192D0  24040001   ADDIU A0, ZERO, 1
9D0192D4  0083100A   MOVZ V0, A0, V1
9D0192D8  00401821   ADDU V1, V0, ZERO
9D0192DC  3C02A000   LUI V0, -24576
9D0192E0  24426218   ADDIU V0, V0, 25112
9D0192E4  AC431174   SW V1, 4468(V0)
419:                       ppu.tile_nametab = value & PPU_CTRL0F_NAMETAB;      
9D0192E8  30A50003   ANDI A1, A1, 3
9D0192EC  AC451178   SW A1, 4472(V0)
420:                 
421:                       /* Mask out bits 10 & 11 in the ppu latch */
422:                       ppu.vaddr_latch &= ~0x0C00;
9D0192F4  8C431168   LW V1, 4456(V0)
9D0192F8  7C035A84   INS V1, ZERO, 10, 2
423:                       ppu.vaddr_latch |= ((value & 3) << 10);
9D0192F0  00052A80   SLL A1, A1, 10
9D0192FC  00A32825   OR A1, A1, V1
424:                       break;
9D019300  03E00008   JR RA
9D019304  AC451168   SW A1, 4456(V0)
425:                 
426:                    case PPU_CTRL1:
427:                       ppu.ctrl1 = value;
9D019308  3C02A000   LUI V0, -24576
9D01930C  24426218   ADDIU V0, V0, 25112
9D019310  A0451161   SB A1, 4449(V0)
428:                 
429:                       ppu.obj_on = (value & PPU_CTRL1F_OBJON) ? true : false;
9D019314  7CA30100   EXT V1, A1, 4, 1
9D019318  AC43118C   SW V1, 4492(V0)
430:                       ppu.bg_on = (value & PPU_CTRL1F_BGON) ? true : false;
9D01931C  7CA300C0   EXT V1, A1, 3, 1
9D019320  AC431188   SW V1, 4488(V0)
431:                       ppu.obj_mask = (value & PPU_CTRL1F_OBJMASK) ? false : true;
9D019324  38A30004   XORI V1, A1, 4
9D019328  7C630080   EXT V1, V1, 2, 1
9D01932C  AC431190   SW V1, 4496(V0)
432:                       ppu.bg_mask = (value & PPU_CTRL1F_BGMASK) ? false : true;
9D019330  38A50002   XORI A1, A1, 2
9D019334  7CA50040   EXT A1, A1, 1, 1
433:                       break;
9D019338  03E00008   JR RA
9D01933C  AC451194   SW A1, 4500(V0)
434:                 
435:                    case PPU_OAMADDR:
436:                       ppu.oam_addr = value;
9D019340  3C02A000   LUI V0, -24576
437:                       break;
9D019344  03E00008   JR RA
9D019348  A045737B   SB A1, 29563(V0)
438:                 
439:                    case PPU_OAMDATA:
440:                       ppu.oam[ppu.oam_addr++] = value;
9D01934C  3C02A000   LUI V0, -24576
9D019350  24426218   ADDIU V0, V0, 25112
9D019354  90431163   LBU V1, 4451(V0)
9D019358  24640001   ADDIU A0, V1, 1
9D01935C  A0441163   SB A0, 4451(V0)
9D019360  00621021   ADDU V0, V1, V0
441:                       break;
9D019364  03E00008   JR RA
9D019368  A0451000   SB A1, 4096(V0)
442:                 
443:                    case PPU_SCROLL:
444:                       if (0 == ppu.flipflop)
9D01936C  3C02A000   LUI V0, -24576
9D019370  8C427388   LW V0, 29576(V0)
9D019374  1440000A   BNE V0, ZERO, 0x9D0193A0
9D019378  3C02A000   LUI V0, -24576
445:                       {
446:                          /* Mask out bits 4 - 0 in the ppu latch */
447:                          ppu.vaddr_latch &= ~0x001F;
9D019384  8C431168   LW V1, 4456(V0)
9D019388  7C032004   INS V1, ZERO, 0, 5
448:                          ppu.vaddr_latch |= (value >> 3);    /* Tile number */
9D01937C  24426218   ADDIU V0, V0, 25112
9D019380  000520C2   SRL A0, A1, 3
9D01938C  00831825   OR V1, A0, V1
9D019390  AC431168   SW V1, 4456(V0)
449:                          ppu.tile_xofs = (value & 7);  /* Tile offset (0-7 pix) */
9D019394  30A50007   ANDI A1, A1, 7
9D019398  0B4064F3   J 0x9D0193CC
9D01939C  AC45116C   SW A1, 4460(V0)
450:                       }
451:                       else
452:                       {
453:                          /* Mask out bits 14-12 and 9-5 in the ppu latch */
454:                          ppu.vaddr_latch &= ~0x73E0;
9D0193B8  8C451168   LW A1, 4456(V0)
9D0193BC  24038C1F   ADDIU V1, ZERO, -29665
9D0193C0  00A31824   AND V1, A1, V1
455:                          ppu.vaddr_latch |= ((value & 0xF8) << 2);   /* Tile number */
9D0193A4  30A400F8   ANDI A0, A1, 248
9D0193A8  00042080   SLL A0, A0, 2
9D0193B4  00852025   OR A0, A0, A1
456:                          ppu.vaddr_latch |= ((value & 7) << 12);     /* Tile offset (0-7 pix) */
9D0193A0  24426218   ADDIU V0, V0, 25112
9D0193AC  30A50007   ANDI A1, A1, 7
9D0193B0  00052B00   SLL A1, A1, 12
9D0193C4  00831825   OR V1, A0, V1
9D0193C8  AC431168   SW V1, 4456(V0)
457:                       }
458:                 
459:                       ppu.flipflop ^= 1;
9D0193CC  3C02A000   LUI V0, -24576
9D0193D0  24426218   ADDIU V0, V0, 25112
9D0193D4  8C431170   LW V1, 4464(V0)
9D0193D8  38630001   XORI V1, V1, 1
9D0193DC  AC431170   SW V1, 4464(V0)
9D0193E0  03E00008   JR RA
9D0193E4  00000000   NOP
460:                 
461:                       break;
462:                 
463:                    case PPU_VADDR:
464:                       if (0 == ppu.flipflop)
9D0193E8  3C02A000   LUI V0, -24576
9D0193EC  8C427388   LW V0, 29576(V0)
9D0193F0  14400009   BNE V0, ZERO, 0x9D019418
9D0193F4  3C02A000   LUI V0, -24576
465:                       {
466:                          /* Mask out bits 15-8 in ppu latch */
467:                          ppu.vaddr_latch &= ~0xFF00;
9D019404  8C431168   LW V1, 4456(V0)
9D019408  7C037A04   INS V1, ZERO, 8, 8
468:                          ppu.vaddr_latch |= ((value & 0x3F) << 8);
9D0193F8  24426218   ADDIU V0, V0, 25112
9D0193FC  30A5003F   ANDI A1, A1, 63
9D019400  00052A00   SLL A1, A1, 8
9D01940C  00A31825   OR V1, A1, V1
9D019410  0B40650C   J 0x9D019430
9D019414  AC431168   SW V1, 4456(V0)
469:                       }
470:                       else
471:                       {
472:                          /* Mask out bits 7-0 in ppu latch */
473:                          ppu.vaddr_latch &= ~0x00FF;
9D019418  24426218   ADDIU V0, V0, 25112
9D01941C  8C431168   LW V1, 4456(V0)
9D019420  7C033804   INS V1, ZERO, 0, 8
474:                          ppu.vaddr_latch |= value;
9D019424  00A32825   OR A1, A1, V1
9D019428  AC451168   SW A1, 4456(V0)
475:                          ppu.vaddr = ppu.vaddr_latch;
9D01942C  AC451164   SW A1, 4452(V0)
476:                       }
477:                       
478:                       ppu.flipflop ^= 1;
9D019430  3C02A000   LUI V0, -24576
9D019434  24426218   ADDIU V0, V0, 25112
9D019438  8C431170   LW V1, 4464(V0)
9D01943C  38630001   XORI V1, V1, 1
479:                 
480:                       break;
9D019440  03E00008   JR RA
9D019444  AC431170   SW V1, 4464(V0)
481:                 
482:                    case PPU_VDATA:
483:                       if (ppu.vaddr < 0x3F00)
9D019454  3C02A000   LUI V0, -24576
9D019458  8C50737C   LW S0, 29564(V0)
9D01945C  2E023F00   SLTIU V0, S0, 16128
9D019460  10400033   BEQ V0, ZERO, 0x9D019530
9D019464  3202000F   ANDI V0, S0, 15
484:                       {
485:                          /* VRAM only accessible during scanlines 241-260 */
486:                          if ((ppu.bg_on || ppu.obj_on) && !ppu.vram_accessible)
9D019468  3C02A000   LUI V0, -24576
9D01946C  8C4273A0   LW V0, 29600(V0)
9D019470  14400006   BNE V0, ZERO, 0x9D01948C
9D019474  3C02A000   LUI V0, -24576
9D019478  3C02A000   LUI V0, -24576
9D01947C  8C4273A4   LW V0, 29604(V0)
9D019480  10400018   BEQ V0, ZERO, .LBB19
9D019484  3C02A000   LUI V0, -24576
9D019488  3C02A000   LUI V0, -24576
9D01948C  8C427FC4   LW V0, 32708(V0)
9D019490  14400014   BNE V0, ZERO, .LBB19
9D019494  3C02A000   LUI V0, -24576
487:                          {
488:                             log_printf("VRAM write to $%04X, scanline %d\n", 
9D0194A0  3C049D04   LUI A0, -25340
9D0194A4  2484BEF0   ADDIU A0, A0, -16656
9D0194A8  02002821   ADDU A1, S0, ZERO
9D0194AC  0F40F11B   JAL log_printf
9D0194B0  8C460320   LW A2, 800(V0)
489:                                        ppu.vaddr, nes_getcontextptr()->scanline);
9D019498  0F408D03   JAL nes_getcontextptr
9D01949C  00000000   NOP
490:                             PPU_MEM(ppu.vaddr) = 0xFF; /* corrupt */
9D0194B4  3C03A000   LUI V1, -24576
9D0194B8  24636218   ADDIU V1, V1, 25112
9D0194BC  8C621164   LW V0, 4452(V1)
9D0194C0  00022282   SRL A0, V0, 10
9D0194C4  24840448   ADDIU A0, A0, 1096
9D0194C8  00042080   SLL A0, A0, 2
9D0194CC  00831821   ADDU V1, A0, V1
9D0194D0  8C630000   LW V1, 0(V1)
9D0194D4  00621021   ADDU V0, V1, V0
9D0194D8  2403FFFF   ADDIU V1, ZERO, -1
9D0194DC  0B406562   J 0x9D019588
9D0194E0  A0430000   SB V1, 0(V0)
491:                          }
492:                          else 
493:                          {
494:                             uint32 addr = ppu.vaddr;
495:                 
496:                             if (false == ppu.vram_present && addr >= 0x3000)
9D0194E4  8C427FC8   LW V0, 32712(V0)
9D0194E8  14400008   BNE V0, ZERO, 0x9D01950C
9D0194EC  00101A82   SRL V1, S0, 10
9D0194F0  2E023000   SLTIU V0, S0, 12288
9D0194F4  14400006   BNE V0, ZERO, 0x9D019510
9D0194F8  24630448   ADDIU V1, V1, 1096
497:                                ppu.vaddr -= 0x1000;
9D0194FC  2603F000   ADDIU V1, S0, -4096
9D019500  3C02A000   LUI V0, -24576
9D019504  AC43737C   SW V1, 29564(V0)
498:                 
499:                             PPU_MEM(addr) = value;
9D019508  00101A82   SRL V1, S0, 10
9D01950C  24630448   ADDIU V1, V1, 1096
9D019510  00031880   SLL V1, V1, 2
9D019514  3C02A000   LUI V0, -24576
9D019518  24426218   ADDIU V0, V0, 25112
9D01951C  00621021   ADDU V0, V1, V0
9D019520  8C420000   LW V0, 0(V0)
9D019524  00508021   ADDU S0, V0, S0
9D019528  0B406562   J 0x9D019588
9D01952C  A2050000   SB A1, 0(S0)
500:                          }
501:                       }
502:                       else
503:                       {
504:                          if (0 == (ppu.vaddr & 0x0F))
9D019530  5440000E   BNEL V0, ZERO, .LBE20
9D019534  32020003   ANDI V0, S0, 3
505:                          {
506:                             int i;
507:                 
508:                             for (i = 0; i < 8; i ++)
9D01954C  24040008   ADDIU A0, ZERO, 8
9D019558  24420001   ADDIU V0, V0, 1
9D01955C  1444FFFC   BNE V0, A0, 0x9D019550
9D019560  A0651100   SB A1, 4352(V1)
9D019564  0B406563   J 0x9D01958C
9D019568  3C02A000   LUI V0, -24576
509:                                ppu.palette[i << 2] = (value & 0x3F) | BG_TRANS;
9D019538  3C06A000   LUI A2, -24576
9D01953C  24C66218   ADDIU A2, A2, 25112
9D019540  30A5003F   ANDI A1, A1, 63
9D019544  2403FF80   ADDIU V1, ZERO, -128
9D019548  00A32825   OR A1, A1, V1
9D019550  00021880   SLL V1, V0, 2
9D019554  00661821   ADDU V1, V1, A2
510:                          }
511:                          else if (ppu.vaddr & 3)
9D01956C  10400007   BEQ V0, ZERO, 0x9D01958C
9D019570  3C02A000   LUI V0, -24576
512:                          {
513:                             ppu.palette[ppu.vaddr & 0x1F] = value & 0x3F;
9D019574  3210001F   ANDI S0, S0, 31
9D019578  24426218   ADDIU V0, V0, 25112
9D01957C  02021021   ADDU V0, S0, V0
9D019580  30A5003F   ANDI A1, A1, 63
9D019584  A0451100   SB A1, 4352(V0)
514:                          }
515:                       }
516:                 
517:                       ppu.vaddr += ppu.vaddr_inc;
9D019590  8C441174   LW A0, 4468(V0)
9D019594  8C431164   LW V1, 4452(V0)
9D019598  00831821   ADDU V1, A0, V1
518:                       ppu.vaddr &= 0x3FFF;
9D019588  3C02A000   LUI V0, -24576
9D01958C  24426218   ADDIU V0, V0, 25112
9D01959C  30633FFF   ANDI V1, V1, 16383
9D0195A0  AC431164   SW V1, 4452(V0)
519:                       break;
520:                 
521:                    default:
522:                       break;
523:                    }
524:                 }
9D0195A4  8FBF0014   LW RA, 20(SP)
9D0195A8  8FB00010   LW S0, 16(SP)
9D0195AC  27BD0018   ADDIU SP, SP, 24
9D0195B0  03E00008   JR RA
9D0195B4  00000000   NOP
525:                 
526:                 /* Builds a 256 color 8-bit palette based on a 64-color NES palette
527:                 ** Note that we set it up 3 times so that we flip bits on the primary
528:                 ** NES buffer for priorities
529:                 */
530:                 static void ppu_buildpalette(ppu_t *src_ppu, rgb_t *pal)
531:                 {
532:                    int i;
533:                 
534:                    /* Set it up 3 times, for sprite priority/BG transparency trickery */
535:                    for (i = 0; i < 64; i++)
9D0195F8  14C0FFF1   BNE A2, ZERO, .LBB25, .LBB26
536:                    {
537:                       src_ppu->curpal[i].r = src_ppu->curpal[i + 64].r 
9D0195CC  AC43FA00   SW V1, -1536(V0)
538:                                            = src_ppu->curpal[i + 128].r = pal[i].r;
9D0195C0  8CA30000   LW V1, 0(A1)
539:                       src_ppu->curpal[i].g = src_ppu->curpal[i + 64].g
9D0195DC  AC43FA04   SW V1, -1532(V0)
540:                                            = src_ppu->curpal[i + 128].g = pal[i].g;
9D0195D0  8CA30004   LW V1, 4(A1)
541:                       src_ppu->curpal[i].b = src_ppu->curpal[i + 64].b
9D0195EC  AC43FA08   SW V1, -1528(V0)
542:                                            = src_ppu->curpal[i + 128].b = pal[i].b;
9D0195E0  8CA30008   LW V1, 8(A1)
543:                    }
544:                 
545:                    for (i = 0; i < GUI_TOTALCOLORS; i++)
9D01962C  1467FFF8   BNE V1, A3, 0x9D019610
546:                    {
547:                       src_ppu->curpal[i + 192].r = gui_pal[i].r;
9D019610  8C660000   LW A2, 0(V1)
548:                       src_ppu->curpal[i + 192].g = gui_pal[i].g;
9D019618  8C660004   LW A2, 4(V1)
549:                       src_ppu->curpal[i + 192].b = gui_pal[i].b;
9D019620  8C660008   LW A2, 8(V1)
9D019624  ACA61AB4   SW A2, 6836(A1)
9D019628  2463000C   ADDIU V1, V1, 12
9D01962C  1467FFF8   BNE V1, A3, 0x9D019610
9D019630  24A5000C   ADDIU A1, A1, 12
550:                    }
551:                 }
552:                 
553:                 uint16 myPalette[256];
554:                 
555:                 /* copy nes palette over to hardware */
556:                 static void set_palette(rgb_t *pal)
557:                 {
558:                 	uint16 c;
559:                 
560:                    int i;
561:                 
562:                    for (i = 0; i < 256; i++)
9D019674  1466FFF3   BNE V1, A2, .LBB27, .LBB28
563:                    {
564:                       c=(pal[i].b>>3)+((pal[i].g>>2)<<5)+((pal[i].r>>3)<<11);
9D019644  8C450004   LW A1, 4(V0)
565:                       //myPalette[i]=(c>>8)|((c&0xff)<<8);
566:                       myPalette[i]=c;
9D01966C  A4640000   SH A0, 0(V1)
9D019670  24630002   ADDIU V1, V1, 2
9D019674  1466FFF3   BNE V1, A2, .LBB27, .LBB28
9D019678  2442000C   ADDIU V0, V0, 12
567:                    }
568:                 
569:                 }
570:                 
571:                 /* build the emulator specific palette based on a 64-entry palette
572:                 ** input palette can be either nes_palette or a 64-entry RGB palette
573:                 ** read in from disk (i.e. for VS games)
574:                 */
575:                 void ppu_setpal(ppu_t *src_ppu, rgb_t *pal)
576:                 {
9D0195B8  248217AC   ADDIU V0, A0, 6060
9D0195BC  24060040   ADDIU A2, ZERO, 64
577:                    ppu_buildpalette(src_ppu, pal);
578:                    //vid_setpalette(src_ppu->curpal);
579:                    set_palette(src_ppu->curpal);
9D019634  248211AC   ADDIU V0, A0, 4524
9D019638  3C03A000   LUI V1, -24576
9D01963C  246303D8   ADDIU V1, V1, 984
9D019640  24660200   ADDIU A2, V1, 512
580:                 }
9D01967C  03E00008   JR RA
9D019680  00000000   NOP
581:                 
582:                 void ppu_setdefaultpal(ppu_t *src_ppu)
583:                 {
9D019684  27BDFFE8   ADDIU SP, SP, -24
9D019688  AFBF0014   SW RA, 20(SP)
584:                    ppu_setpal(src_ppu, nes_palette);
9D01968C  3C05A000   LUI A1, -24576
9D019690  0F40656E   JAL ppu_setpal
9D019694  24A505D8   ADDIU A1, A1, 1496
585:                 }
9D019698  8FBF0014   LW RA, 20(SP)
9D01969C  03E00008   JR RA
9D0196A0  27BD0018   ADDIU SP, SP, 24
586:                 
587:                 void ppu_setlatchfunc(ppulatchfunc_t func)
588:                 {
589:                    ppu.latchfunc = func;
9D019718  3C02A000   LUI V0, -24576
9D01971C  03E00008   JR RA
9D019720  AC4473BC   SW A0, 29628(V0)
590:                 }
591:                 
592:                 void ppu_setvromswitch(ppuvromswitch_t func)
593:                 {
594:                    ppu.vromswitch = func;
9D019724  3C02A000   LUI V0, -24576
9D019728  03E00008   JR RA
9D01972C  AC4473C0   SW A0, 29632(V0)
595:                 }
596:                 
597:                 /* rendering routines */
598:                 INLINE void draw_bgtile(uint8 *surface, uint8 pat1, uint8 pat2, 
599:                                         const uint8 *colors)
600:                 {
601:                    uint32 pattern = ((pat2 & 0xAA) << 8) | ((pat2 & 0x55) << 1)
9D0199E8  2416FFAA   ADDIU S6, ZERO, -86
9D019A3C  00B61824   AND V1, A1, S6
9D019A40  00031A00   SLL V1, V1, 8
9D019A44  30A50055   ANDI A1, A1, 85
9D019A48  00052840   SLL A1, A1, 1
9D019A4C  00651825   OR V1, V1, A1
9D01A500  240DFFAA   ADDIU T5, ZERO, -86
9D01A67C  006DA824   AND S5, V1, T5
9D01A680  0015AA00   SLL S5, S5, 8
9D01A684  30630055   ANDI V1, V1, 85
9D01A688  00031840   SLL V1, V1, 1
9D01A68C  02A3A825   OR S5, S5, V1
9D01A850  240BFFAA   ADDIU T3, ZERO, -86
9D01A898  014B1824   AND V1, T2, T3
9D01A89C  00031A00   SLL V1, V1, 8
9D01A8A0  314A0055   ANDI T2, T2, 85
9D01A8A4  000A5040   SLL T2, T2, 1
9D01A8A8  006A1825   OR V1, V1, T2
602:                                     | ((pat1 & 0xAA) << 7) | (pat1 & 0x55);
9D019A50  30860055   ANDI A2, A0, 85
9D019A54  00661825   OR V1, V1, A2
9D019A58  00962024   AND A0, A0, S6
9D019A5C  000421C0   SLL A0, A0, 7
9D019A60  00641825   OR V1, V1, A0
9D01A690  32630055   ANDI V1, S3, 85
9D01A694  02A31825   OR V1, S5, V1
9D01A698  026D9824   AND S3, S3, T5
9D01A69C  001399C0   SLL S3, S3, 7
9D01A6A0  00731825   OR V1, V1, S3
9D01A8AC  31320055   ANDI S2, T1, 85
9D01A8B0  00721825   OR V1, V1, S2
9D01A8B4  012B4824   AND T1, T1, T3
9D01A8B8  000949C0   SLL T1, T1, 7
9D01A8BC  00691825   OR V1, V1, T1
603:                    
604:                    *surface++ = colors[(pattern >> 14) & 3];
9D019A64  00032382   SRL A0, V1, 14
9D019A68  00442021   ADDU A0, V0, A0
9D019A6C  90840000   LBU A0, 0(A0)
9D019A70  A2040000   SB A0, 0(S0)
9D01A6A4  00039B82   SRL S3, V1, 14
9D01A6A8  00F39821   ADDU S3, A3, S3
9D01A6AC  92730000   LBU S3, 0(S3)
9D01A6B0  A0530000   SB S3, 0(V0)
9D01A8C0  00034B82   SRL T1, V1, 14
9D01A8C4  00E94821   ADDU T1, A3, T1
9D01A8C8  91290000   LBU T1, 0(T1)
9D01A8CC  A0490000   SB T1, 0(V0)
605:                    *surface++ = colors[(pattern >> 6) & 3];
9D019A74  7C640980   EXT A0, V1, 6, 2
9D019A78  00442021   ADDU A0, V0, A0
9D019A7C  90840000   LBU A0, 0(A0)
9D019A80  A2040001   SB A0, 1(S0)
9D01A6B4  7C730980   EXT S3, V1, 6, 2
9D01A6B8  00F39821   ADDU S3, A3, S3
9D01A6BC  92730000   LBU S3, 0(S3)
9D01A6C0  A0530001   SB S3, 1(V0)
9D01A8D0  7C690980   EXT T1, V1, 6, 2
9D01A8D4  00E94821   ADDU T1, A3, T1
9D01A8D8  91290000   LBU T1, 0(T1)
9D01A8DC  A0490001   SB T1, 1(V0)
606:                    *surface++ = colors[(pattern >> 12) & 3];
9D019A84  7C640B00   EXT A0, V1, 12, 2
9D019A88  00442021   ADDU A0, V0, A0
9D019A8C  90840000   LBU A0, 0(A0)
9D019A90  A2040002   SB A0, 2(S0)
9D01A6C4  7C730B00   EXT S3, V1, 12, 2
9D01A6C8  00F39821   ADDU S3, A3, S3
9D01A6CC  92730000   LBU S3, 0(S3)
9D01A6D0  A0530002   SB S3, 2(V0)
9D01A8E0  7C690B00   EXT T1, V1, 12, 2
9D01A8E4  00E94821   ADDU T1, A3, T1
9D01A8E8  91290000   LBU T1, 0(T1)
9D01A8EC  A0490002   SB T1, 2(V0)
607:                    *surface++ = colors[(pattern >> 4) & 3];
9D019A94  7C640900   EXT A0, V1, 4, 2
9D019A98  00442021   ADDU A0, V0, A0
9D019A9C  90840000   LBU A0, 0(A0)
9D019AA0  A2040003   SB A0, 3(S0)
9D01A6D4  7C730900   EXT S3, V1, 4, 2
9D01A6D8  00F39821   ADDU S3, A3, S3
9D01A6DC  92730000   LBU S3, 0(S3)
9D01A6E0  A0530003   SB S3, 3(V0)
9D01A8F0  7C690900   EXT T1, V1, 4, 2
9D01A8F4  00E94821   ADDU T1, A3, T1
9D01A8F8  91290000   LBU T1, 0(T1)
9D01A8FC  A0490003   SB T1, 3(V0)
608:                    *surface++ = colors[(pattern >> 10) & 3];
9D019AA4  7C640A80   EXT A0, V1, 10, 2
9D019AA8  00442021   ADDU A0, V0, A0
9D019AAC  90840000   LBU A0, 0(A0)
9D019AB0  A2040004   SB A0, 4(S0)
9D01A6E4  7C730A80   EXT S3, V1, 10, 2
9D01A6E8  00F39821   ADDU S3, A3, S3
9D01A6EC  92730000   LBU S3, 0(S3)
9D01A6F0  A0530004   SB S3, 4(V0)
9D01A900  7C690A80   EXT T1, V1, 10, 2
9D01A904  00E94821   ADDU T1, A3, T1
9D01A908  91290000   LBU T1, 0(T1)
9D01A90C  A0490004   SB T1, 4(V0)
609:                    *surface++ = colors[(pattern >> 2) & 3];
9D019AB4  7C640880   EXT A0, V1, 2, 2
9D019AB8  00442021   ADDU A0, V0, A0
9D019ABC  90840000   LBU A0, 0(A0)
9D019AC0  A2040005   SB A0, 5(S0)
9D01A6F4  7C730880   EXT S3, V1, 2, 2
9D01A6F8  00F39821   ADDU S3, A3, S3
9D01A6FC  92730000   LBU S3, 0(S3)
9D01A700  A0530005   SB S3, 5(V0)
9D01A910  7C690880   EXT T1, V1, 2, 2
9D01A914  00E94821   ADDU T1, A3, T1
9D01A918  91290000   LBU T1, 0(T1)
9D01A91C  A0490005   SB T1, 5(V0)
610:                    *surface++ = colors[(pattern >> 8) & 3];
9D019AC4  7C640A00   EXT A0, V1, 8, 2
9D019AC8  00442021   ADDU A0, V0, A0
9D019ACC  90840000   LBU A0, 0(A0)
9D019AD0  A2040006   SB A0, 6(S0)
9D01A704  7C730A00   EXT S3, V1, 8, 2
9D01A708  00F39821   ADDU S3, A3, S3
9D01A70C  92730000   LBU S3, 0(S3)
9D01A710  A0530006   SB S3, 6(V0)
9D01A920  7C690A00   EXT T1, V1, 8, 2
9D01A924  00E94821   ADDU T1, A3, T1
9D01A928  91290000   LBU T1, 0(T1)
9D01A92C  A0490006   SB T1, 6(V0)
611:                    *surface = colors[pattern & 3];
9D019AD4  30630003   ANDI V1, V1, 3
9D019AD8  00431021   ADDU V0, V0, V1
9D019ADC  90420000   LBU V0, 0(V0)
9D019AE0  A2020007   SB V0, 7(S0)
9D01A714  30630003   ANDI V1, V1, 3
9D01A718  00E31821   ADDU V1, A3, V1
9D01A71C  90630000   LBU V1, 0(V1)
9D01A720  A0430007   SB V1, 7(V0)
9D01A930  30630003   ANDI V1, V1, 3
9D01A934  00E31821   ADDU V1, A3, V1
9D01A938  90630000   LBU V1, 0(V1)
9D01A93C  A0430007   SB V1, 7(V0)
612:                 }
613:                 
614:                 INLINE int draw_oamtile(uint8 *surface, uint8 attrib, uint8 pat1, 
615:                                         uint8 pat2, const uint8 *col_tbl, bool check_strike)
616:                 {
617:                    int strike_pixel = -1;
9D019EA0  29AD0000   SLTI T5, T5, 0
9D019EA4  2402FFFF   ADDIU V0, ZERO, -1
9D019EA8  24040007   ADDIU A0, ZERO, 7
9D019EAC  004D200B   MOVN A0, V0, T5
618:                    uint32 color = ((pat2 & 0xAA) << 8) | ((pat2 & 0x55) << 1)
9D019D80  2403FFAA   ADDIU V1, ZERO, -86
9D019D84  00433024   AND A2, V0, V1
9D019D88  00063200   SLL A2, A2, 8
9D019D8C  30420055   ANDI V0, V0, 85
9D019D90  00021040   SLL V0, V0, 1
9D019D94  00C23025   OR A2, A2, V0
619:                                   | ((pat1 & 0xAA) << 7) | (pat1 & 0x55);
9D019D98  30820055   ANDI V0, A0, 85
9D019D9C  00C23025   OR A2, A2, V0
9D019DA0  00831024   AND V0, A0, V1
9D019DA4  000211C0   SLL V0, V0, 7
9D019DA8  00C21025   OR V0, A2, V0
620:                 
621:                    /* sprite is not 100% transparent */
622:                    if (color)
9D019DAC  104000F1   BEQ V0, ZERO, .LVL301
9D019DB0  32E30040   ANDI V1, S7, 64
623:                    {
624:                       uint8 colors[8];
625:                 
626:                       /* swap pixels around if our tile is flipped */
627:                       if (0 == (attrib & OAMF_HFLIP))
9D019DB4  306300FF   ANDI V1, V1, 255
9D019DB8  5460000A   BNEL V1, ZERO, 0x9D019DE4
9D019DBC  00026382   SRL T4, V0, 14
628:                       {
629:                          colors[0] = (color >> 14) & 3;
9D019DC0  00021B82   SRL V1, V0, 14
630:                          colors[1] = (color >> 6) & 3;
9D019DC4  7C460980   EXT A2, V0, 6, 2
631:                          colors[2] = (color >> 12) & 3;
9D019DC8  7C470B00   EXT A3, V0, 12, 2
632:                          colors[3] = (color >> 4) & 3;
9D019DCC  7C480900   EXT T0, V0, 4, 2
633:                          colors[4] = (color >> 10) & 3;
9D019DD0  7C490A80   EXT T1, V0, 10, 2
634:                          colors[5] = (color >> 2) & 3;
9D019DD4  7C4A0880   EXT T2, V0, 2, 2
635:                          colors[6] = (color >> 8) & 3;
9D019DD8  7C4B0A00   EXT T3, V0, 8, 2
636:                          colors[7] = color & 3;
9D019DDC  0B406780   J 0x9D019E00
9D019DE0  304C0003   ANDI T4, V0, 3
637:                       }
638:                       else
639:                       {
640:                          colors[7] = (color >> 14) & 3;
641:                          colors[6] = (color >> 6) & 3;
9D019DE4  7C4B0980   EXT T3, V0, 6, 2
642:                          colors[5] = (color >> 12) & 3;
9D019DE8  7C4A0B00   EXT T2, V0, 12, 2
643:                          colors[4] = (color >> 4) & 3;
9D019DEC  7C490900   EXT T1, V0, 4, 2
644:                          colors[3] = (color >> 10) & 3;
9D019DF0  7C480A80   EXT T0, V0, 10, 2
645:                          colors[2] = (color >> 2) & 3;
9D019DF4  7C470880   EXT A3, V0, 2, 2
646:                          colors[1] = (color >> 8) & 3;
9D019DF8  7C460A00   EXT A2, V0, 8, 2
647:                          colors[0] = color & 3;
9D019DFC  30430003   ANDI V1, V0, 3
648:                       }
649:                 
650:                       /* check for solid sprite pixel overlapping solid bg pixel */
651:                       if (check_strike)
9D019E00  11A0002B   BEQ T5, ZERO, 0x9D019EB0
9D019E04  2404FFFF   ADDIU A0, ZERO, -1
652:                       {
653:                          if (colors[0] && BG_SOLID(surface[0]))
9D019E08  10600004   BEQ V1, ZERO, 0x9D019E1C
9D019E0C  00000000   NOP
9D019E10  82C20000   LB V0, 0(S6)
9D019E14  04410195   BGEZ V0, 0x9D01A46C
9D019E18  32E20020   ANDI V0, S7, 32
654:                             strike_pixel = 0;
655:                          else if (colors[1] && BG_SOLID(surface[1]))
9D019E1C  10C00004   BEQ A2, ZERO, 0x9D019E30
9D019E20  00000000   NOP
9D019E24  82C20001   LB V0, 1(S6)
9D019E28  04410021   BGEZ V0, 0x9D019EB0
9D019E2C  24040001   ADDIU A0, ZERO, 1
656:                             strike_pixel = 1;
657:                          else if (colors[2] && BG_SOLID(surface[2]))
9D019E30  10E00004   BEQ A3, ZERO, 0x9D019E44
9D019E34  00000000   NOP
9D019E38  82C20002   LB V0, 2(S6)
9D019E3C  0441001C   BGEZ V0, 0x9D019EB0
9D019E40  24040002   ADDIU A0, ZERO, 2
658:                             strike_pixel = 2;
659:                          else if (colors[3] && BG_SOLID(surface[3]))
9D019E44  11000004   BEQ T0, ZERO, 0x9D019E58
9D019E48  00000000   NOP
9D019E4C  82C20003   LB V0, 3(S6)
9D019E50  04410017   BGEZ V0, 0x9D019EB0
9D019E54  24040003   ADDIU A0, ZERO, 3
660:                             strike_pixel = 3;
661:                          else if (colors[4] && BG_SOLID(surface[4]))
9D019E58  11200004   BEQ T1, ZERO, 0x9D019E6C
9D019E5C  00000000   NOP
9D019E60  82C20004   LB V0, 4(S6)
9D019E64  04410012   BGEZ V0, 0x9D019EB0
9D019E68  24040004   ADDIU A0, ZERO, 4
662:                             strike_pixel = 4;
663:                          else if (colors[5] && BG_SOLID(surface[5]))
9D019E6C  11400004   BEQ T2, ZERO, 0x9D019E80
9D019E70  00000000   NOP
9D019E74  82C20005   LB V0, 5(S6)
9D019E78  0441000D   BGEZ V0, 0x9D019EB0
9D019E7C  24040005   ADDIU A0, ZERO, 5
664:                             strike_pixel = 5;
665:                          else if (colors[6] && BG_SOLID(surface[6]))
9D019E80  11600004   BEQ T3, ZERO, 0x9D019E94
9D019E84  00000000   NOP
9D019E88  82C20006   LB V0, 6(S6)
9D019E8C  04410008   BGEZ V0, 0x9D019EB0
9D019E90  24040006   ADDIU A0, ZERO, 6
666:                             strike_pixel = 6;
667:                          else if (colors[7] && BG_SOLID(surface[7]))
9D019E94  11800006   BEQ T4, ZERO, 0x9D019EB0
9D019E98  2404FFFF   ADDIU A0, ZERO, -1
9D019E9C  82CD0007   LB T5, 7(S6)
668:                             strike_pixel = 7;
669:                       }
670:                 
671:                       /* draw the character */
672:                       if (attrib & OAMF_BEHIND)
9D019EB0  32E20020   ANDI V0, S7, 32
9D019EB4  304200FF   ANDI V0, V0, 255
9D019EB8  1040005A   BEQ V0, ZERO, 0x9D01A024
9D019EBC  00000000   NOP
9D01A46C  304200FF   ANDI V0, V0, 255
9D01A470  1040FEEE   BEQ V0, ZERO, 0x9D01A02C
9D01A474  00002021   ADDU A0, ZERO, ZERO
673:                       {
674:                          if (colors[0])
9D019EC0  1060000A   BEQ V1, ZERO, 0x9D019EEC
9D019EC4  00000000   NOP
9D019EC8  92C20000   LBU V0, 0(S6)
675:                             surface[0] = SP_PIXEL | (BG_CLEAR(surface[0]) ? col_tbl[colors[0]] : surface[0]);
9D019ECC  7C026C20   SEB T5, V0
9D019ED0  05A10005   BGEZ T5, 0x9D019EE8
9D019ED4  34420040   ORI V0, V0, 64
9D019ED8  00A31821   ADDU V1, A1, V1
9D019EDC  90620000   LBU V0, 0(V1)
9D019EE0  34420040   ORI V0, V0, 64
9D019EE4  304200FF   ANDI V0, V0, 255
9D019EE8  A2C20000   SB V0, 0(S6)
9D01A478  0B4067B3   J 0x9D019ECC
9D01A47C  92C20000   LBU V0, 0(S6)
676:                          if (colors[1])
9D019EEC  10C0000A   BEQ A2, ZERO, 0x9D019F18
9D019EF0  00000000   NOP
677:                             surface[1] = SP_PIXEL | (BG_CLEAR(surface[1]) ? col_tbl[colors[1]] : surface[1]);
9D019EF4  92C20001   LBU V0, 1(S6)
9D019EF8  7C021C20   SEB V1, V0
9D019EFC  04610005   BGEZ V1, 0x9D019F14
9D019F00  34420040   ORI V0, V0, 64
9D019F04  00A63021   ADDU A2, A1, A2
9D019F08  90C20000   LBU V0, 0(A2)
9D019F0C  34420040   ORI V0, V0, 64
9D019F10  304200FF   ANDI V0, V0, 255
9D019F14  A2C20001   SB V0, 1(S6)
678:                          if (colors[2])
9D019F18  10E0000A   BEQ A3, ZERO, 0x9D019F44
9D019F1C  00000000   NOP
679:                             surface[2] = SP_PIXEL | (BG_CLEAR(surface[2]) ? col_tbl[colors[2]] : surface[2]);
9D019F20  92C20002   LBU V0, 2(S6)
9D019F24  7C021C20   SEB V1, V0
9D019F28  04610005   BGEZ V1, 0x9D019F40
9D019F2C  34420040   ORI V0, V0, 64
9D019F30  00A73821   ADDU A3, A1, A3
9D019F34  90E20000   LBU V0, 0(A3)
9D019F38  34420040   ORI V0, V0, 64
9D019F3C  304200FF   ANDI V0, V0, 255
9D019F40  A2C20002   SB V0, 2(S6)
680:                          if (colors[3])
9D019F44  1100000A   BEQ T0, ZERO, 0x9D019F70
9D019F48  00000000   NOP
681:                             surface[3] = SP_PIXEL | (BG_CLEAR(surface[3]) ? col_tbl[colors[3]] : surface[3]);
9D019F4C  92C20003   LBU V0, 3(S6)
9D019F50  7C021C20   SEB V1, V0
9D019F54  04610005   BGEZ V1, 0x9D019F6C
9D019F58  34420040   ORI V0, V0, 64
9D019F5C  00A84021   ADDU T0, A1, T0
9D019F60  91020000   LBU V0, 0(T0)
9D019F64  34420040   ORI V0, V0, 64
9D019F68  304200FF   ANDI V0, V0, 255
9D019F6C  A2C20003   SB V0, 3(S6)
682:                          if (colors[4])
9D019F70  1120000A   BEQ T1, ZERO, 0x9D019F9C
9D019F74  00000000   NOP
683:                             surface[4] = SP_PIXEL | (BG_CLEAR(surface[4]) ? col_tbl[colors[4]] : surface[4]);
9D019F78  92C20004   LBU V0, 4(S6)
9D019F7C  7C021C20   SEB V1, V0
9D019F80  04610005   BGEZ V1, 0x9D019F98
9D019F84  34420040   ORI V0, V0, 64
9D019F88  00A94821   ADDU T1, A1, T1
9D019F8C  91220000   LBU V0, 0(T1)
9D019F90  34420040   ORI V0, V0, 64
9D019F94  304200FF   ANDI V0, V0, 255
9D019F98  A2C20004   SB V0, 4(S6)
684:                          if (colors[5])
9D019F9C  1140000A   BEQ T2, ZERO, 0x9D019FC8
9D019FA0  00000000   NOP
685:                             surface[5] = SP_PIXEL | (BG_CLEAR(surface[5]) ? col_tbl[colors[5]] : surface[5]);
9D019FA4  92C20005   LBU V0, 5(S6)
9D019FA8  7C021C20   SEB V1, V0
9D019FAC  04610005   BGEZ V1, 0x9D019FC4
9D019FB0  34420040   ORI V0, V0, 64
9D019FB4  00AA5021   ADDU T2, A1, T2
9D019FB8  91420000   LBU V0, 0(T2)
9D019FBC  34420040   ORI V0, V0, 64
9D019FC0  304200FF   ANDI V0, V0, 255
9D019FC4  A2C20005   SB V0, 5(S6)
686:                          if (colors[6])
9D019FC8  1160000A   BEQ T3, ZERO, 0x9D019FF4
9D019FCC  00000000   NOP
687:                             surface[6] = SP_PIXEL | (BG_CLEAR(surface[6]) ? col_tbl[colors[6]] : surface[6]);
9D019FD0  92C20006   LBU V0, 6(S6)
9D019FD4  7C021C20   SEB V1, V0
9D019FD8  04610005   BGEZ V1, 0x9D019FF0
9D019FDC  34420040   ORI V0, V0, 64
9D019FE0  00AB5821   ADDU T3, A1, T3
9D019FE4  91620000   LBU V0, 0(T3)
9D019FE8  34420040   ORI V0, V0, 64
9D019FEC  304200FF   ANDI V0, V0, 255
9D019FF0  A2C20006   SB V0, 6(S6)
688:                          if (colors[7])
9D019FF4  1180005B   BEQ T4, ZERO, 0x9D01A164
9D019FF8  00000000   NOP
689:                             surface[7] = SP_PIXEL | (BG_CLEAR(surface[7]) ? col_tbl[colors[7]] : surface[7]);
9D019FFC  92C20007   LBU V0, 7(S6)
9D01A000  7C021C20   SEB V1, V0
9D01A004  04610005   BGEZ V1, 0x9D01A01C
9D01A008  34420040   ORI V0, V0, 64
9D01A00C  00AC2821   ADDU A1, A1, T4
9D01A010  90A20000   LBU V0, 0(A1)
9D01A014  34420040   ORI V0, V0, 64
9D01A018  304200FF   ANDI V0, V0, 255
9D01A01C  0B406859   J 0x9D01A164
9D01A020  A2C20007   SB V0, 7(S6)
690:                       }
691:                       else
692:                       {
693:                          if (colors[0] && SP_CLEAR(surface[0]))
9D01A024  10600009   BEQ V1, ZERO, 0x9D01A04C
9D01A028  00000000   NOP
9D01A02C  92C20000   LBU V0, 0(S6)
9D01A030  30420040   ANDI V0, V0, 64
9D01A034  304200FF   ANDI V0, V0, 255
9D01A038  14400004   BNE V0, ZERO, 0x9D01A04C
9D01A03C  00A31821   ADDU V1, A1, V1
694:                             surface[0] = SP_PIXEL | col_tbl[colors[0]];
9D01A040  90620000   LBU V0, 0(V1)
9D01A044  34420040   ORI V0, V0, 64
9D01A048  A2C20000   SB V0, 0(S6)
695:                          if (colors[1] && SP_CLEAR(surface[1]))
9D01A04C  10C00009   BEQ A2, ZERO, 0x9D01A074
9D01A050  00000000   NOP
9D01A054  92C20001   LBU V0, 1(S6)
9D01A058  30420040   ANDI V0, V0, 64
9D01A05C  304200FF   ANDI V0, V0, 255
9D01A060  14400004   BNE V0, ZERO, 0x9D01A074
9D01A064  00A63021   ADDU A2, A1, A2
696:                             surface[1] = SP_PIXEL | col_tbl[colors[1]];
9D01A068  90C20000   LBU V0, 0(A2)
9D01A06C  34420040   ORI V0, V0, 64
9D01A070  A2C20001   SB V0, 1(S6)
697:                          if (colors[2] && SP_CLEAR(surface[2]))
9D01A074  10E00009   BEQ A3, ZERO, 0x9D01A09C
9D01A078  00000000   NOP
9D01A07C  92C20002   LBU V0, 2(S6)
9D01A080  30420040   ANDI V0, V0, 64
9D01A084  304200FF   ANDI V0, V0, 255
9D01A088  14400004   BNE V0, ZERO, 0x9D01A09C
9D01A08C  00A73821   ADDU A3, A1, A3
698:                             surface[2] = SP_PIXEL | col_tbl[colors[2]];
9D01A090  90E20000   LBU V0, 0(A3)
9D01A094  34420040   ORI V0, V0, 64
9D01A098  A2C20002   SB V0, 2(S6)
699:                          if (colors[3] && SP_CLEAR(surface[3]))
9D01A09C  11000009   BEQ T0, ZERO, 0x9D01A0C4
9D01A0A0  00000000   NOP
9D01A0A4  92C20003   LBU V0, 3(S6)
9D01A0A8  30420040   ANDI V0, V0, 64
9D01A0AC  304200FF   ANDI V0, V0, 255
9D01A0B0  14400004   BNE V0, ZERO, 0x9D01A0C4
9D01A0B4  00A84021   ADDU T0, A1, T0
700:                             surface[3] = SP_PIXEL | col_tbl[colors[3]];
9D01A0B8  91020000   LBU V0, 0(T0)
9D01A0BC  34420040   ORI V0, V0, 64
9D01A0C0  A2C20003   SB V0, 3(S6)
701:                          if (colors[4] && SP_CLEAR(surface[4]))
9D01A0C4  11200009   BEQ T1, ZERO, 0x9D01A0EC
9D01A0C8  00000000   NOP
9D01A0CC  92C20004   LBU V0, 4(S6)
9D01A0D0  30420040   ANDI V0, V0, 64
9D01A0D4  304200FF   ANDI V0, V0, 255
9D01A0D8  14400004   BNE V0, ZERO, 0x9D01A0EC
9D01A0DC  00A94821   ADDU T1, A1, T1
702:                             surface[4] = SP_PIXEL | col_tbl[colors[4]];
9D01A0E0  91220000   LBU V0, 0(T1)
9D01A0E4  34420040   ORI V0, V0, 64
9D01A0E8  A2C20004   SB V0, 4(S6)
703:                          if (colors[5] && SP_CLEAR(surface[5]))
9D01A0EC  11400009   BEQ T2, ZERO, 0x9D01A114
9D01A0F0  00000000   NOP
9D01A0F4  92C20005   LBU V0, 5(S6)
9D01A0F8  30420040   ANDI V0, V0, 64
9D01A0FC  304200FF   ANDI V0, V0, 255
9D01A100  14400004   BNE V0, ZERO, 0x9D01A114
9D01A104  00AA5021   ADDU T2, A1, T2
704:                             surface[5] = SP_PIXEL | col_tbl[colors[5]];
9D01A108  91420000   LBU V0, 0(T2)
9D01A10C  34420040   ORI V0, V0, 64
9D01A110  A2C20005   SB V0, 5(S6)
705:                          if (colors[6] && SP_CLEAR(surface[6]))
9D01A114  11600009   BEQ T3, ZERO, 0x9D01A13C
9D01A118  00000000   NOP
9D01A11C  92C20006   LBU V0, 6(S6)
9D01A120  30420040   ANDI V0, V0, 64
9D01A124  304200FF   ANDI V0, V0, 255
9D01A128  14400004   BNE V0, ZERO, 0x9D01A13C
9D01A12C  00AB5821   ADDU T3, A1, T3
706:                             surface[6] = SP_PIXEL | col_tbl[colors[6]];
9D01A130  91620000   LBU V0, 0(T3)
9D01A134  34420040   ORI V0, V0, 64
9D01A138  A2C20006   SB V0, 6(S6)
707:                          if (colors[7] && SP_CLEAR(surface[7]))
9D01A13C  11800009   BEQ T4, ZERO, 0x9D01A164
9D01A140  00000000   NOP
9D01A144  92C20007   LBU V0, 7(S6)
9D01A148  30420040   ANDI V0, V0, 64
9D01A14C  304200FF   ANDI V0, V0, 255
9D01A150  14400004   BNE V0, ZERO, 0x9D01A164
9D01A154  00AC2821   ADDU A1, A1, T4
708:                             surface[7] = SP_PIXEL | col_tbl[colors[7]];
9D01A158  90A20000   LBU V0, 0(A1)
9D01A15C  34420040   ORI V0, V0, 64
9D01A160  A2C20007   SB V0, 7(S6)
709:                       }
710:                    }
711:                 
712:                    return strike_pixel;
713:                 }
714:                 
715:                 static void ppu_renderbg(uint8 *vidbuf)
716:                 {
717:                    uint8 *bmp_ptr, *data_ptr, *tile_ptr, *attrib_ptr;
718:                    uint32 refresh_vaddr, bg_offset, attrib_base;
719:                    int tile_count;
720:                    uint8 tile_index, x_tile, y_tile;
721:                    uint8 col_high, attrib, attrib_shift;
722:                 
723:                    /* draw a line of transparent background color if bg is disabled */
724:                    if (false == ppu.bg_on)
9D0198E8  1440000A   BNE V0, ZERO, 0x9D019914
9D0198EC  3C03A000   LUI V1, -24576
725:                    {
726:                       memset(vidbuf, FULLBG, NES_SCREEN_WIDTH);
9D0198F0  3C02A000   LUI V0, -24576
9D0198F4  90457318   LBU A1, 29464(V0)
9D0198F8  30A5007F   ANDI A1, A1, 127
9D0198FC  8FA40028   LW A0, 40(SP)
9D019900  34A50080   ORI A1, A1, 128
9D019904  0F40E9FC   JAL .Letext0, .LFE0, memset
9D019908  24060100   ADDIU A2, ZERO, 256
9D01A464  0B40663D   J 0x9D0198F4
9D01A468  3C02A000   LUI V0, -24576
727:                       return;
728:                    }
729:                 
730:                    bmp_ptr = vidbuf - ppu.tile_xofs; /* scroll x */
9D019914  24636218   ADDIU V1, V1, 25112
9D019918  8C70116C   LW S0, 4460(V1)
9D01991C  8FA60028   LW A2, 40(SP)
9D019920  00D08023   SUBU S0, A2, S0
731:                    refresh_vaddr = 0x2000 + (ppu.vaddr & 0x0FE0); /* mask out x tile */
9D019924  8C621164   LW V0, 4452(V1)
9D019928  30440FE0   ANDI A0, V0, 4064
9D01992C  24842000   ADDIU A0, A0, 8192
9D019930  AFA40020   SW A0, 32(SP)
732:                    x_tile = ppu.vaddr & 0x1F;
9D019934  304400FF   ANDI A0, V0, 255
9D019938  3091001F   ANDI S1, A0, 31
733:                    y_tile = (ppu.vaddr >> 5) & 0x1F; /* to simplify calculations */
9D01993C  7C453940   EXT A1, V0, 5, 8
734:                    bg_offset = ((ppu.vaddr >> 12) & 7) + ppu.bg_base; /* offset in y tile */
9D019940  7C421300   EXT V0, V0, 12, 3
9D019944  8C661184   LW A2, 4484(V1)
9D019948  00463021   ADDU A2, V0, A2
9D01994C  AFA60010   SW A2, 16(SP)
735:                 
736:                    /* calculate initial values */
737:                    tile_ptr = &PPU_MEM(refresh_vaddr + x_tile); /* pointer to tile index */
9D019950  8FA70020   LW A3, 32(SP)
9D019954  02271021   ADDU V0, S1, A3
9D019958  00023282   SRL A2, V0, 10
9D01995C  24C60448   ADDIU A2, A2, 1096
9D019960  00063080   SLL A2, A2, 2
9D019964  00C33021   ADDU A2, A2, V1
9D019968  8CC60000   LW A2, 0(A2)
9D01996C  00C21021   ADDU V0, A2, V0
738:                    attrib_base = (refresh_vaddr & 0x2C00) + 0x3C0 + ((y_tile & 0x1C) << 1);
9D019970  30E72C00   ANDI A3, A3, 11264
9D019974  24E703C0   ADDIU A3, A3, 960
9D019978  30A6001C   ANDI A2, A1, 28
9D01997C  00063040   SLL A2, A2, 1
9D019980  00E63021   ADDU A2, A3, A2
9D019984  AFA60024   SW A2, 36(SP)
739:                    attrib_ptr = &PPU_MEM(attrib_base + (x_tile >> 2));
9D019988  00113082   SRL A2, S1, 2
9D01998C  8FA70024   LW A3, 36(SP)
9D019990  00E63021   ADDU A2, A3, A2
9D019994  00063A82   SRL A3, A2, 10
9D019998  24E70448   ADDIU A3, A3, 1096
9D01999C  00073880   SLL A3, A3, 2
9D0199A0  00E31821   ADDU V1, A3, V1
9D0199A4  8C630000   LW V1, 0(V1)
9D0199A8  00661821   ADDU V1, V1, A2
740:                    attrib = *attrib_ptr++;
9D0199AC  24660001   ADDIU A2, V1, 1
9D0199B0  AFA60018   SW A2, 24(SP)
9D0199B4  90630000   LBU V1, 0(V1)
9D0199B8  AFA3001C   SW V1, 28(SP)
741:                    attrib_shift = (x_tile & 2) + ((y_tile & 2) << 1);
9D0199BC  30B70002   ANDI S7, A1, 2
9D0199C0  0017B840   SLL S7, S7, 1
9D0199C4  30840002   ANDI A0, A0, 2
9D0199C8  02E4B821   ADDU S7, S7, A0
742:                    col_high = ((attrib >> attrib_shift) & 3) << 2;
9D0199CC  02E3F007   SRAV FP, V1, S7
9D0199D0  33DE0003   ANDI FP, FP, 3
9D0199D4  001EF080   SLL FP, FP, 2
9D0199D8  26070108   ADDIU A3, S0, 264
9D0199DC  AFA70014   SW A3, 20(SP)
743:                 
744:                    /* ppu fetches 33 tiles */
745:                    tile_count = 33;
746:                    while (tile_count--)
9D019B8C  8FA70014   LW A3, 20(SP)
9D019B90  1607FF96   BNE S0, A3, 0x9D0199EC
9D019B94  02A01021   ADDU V0, S5, ZERO
747:                    {
748:                       /* Tile number from nametable */
749:                       tile_index = *tile_ptr++;
9D0199EC  24550001   ADDIU S5, V0, 1
9D0199F0  90450000   LBU A1, 0(V0)
750:                       data_ptr = &PPU_MEM(bg_offset + (tile_index << 4));
9D0199E0  3C12A000   LUI S2, -24576
9D0199E4  26526218   ADDIU S2, S2, 25112
9D0199F4  00059900   SLL S3, A1, 4
9D0199F8  8FA20010   LW V0, 16(SP)
9D0199FC  02629821   ADDU S3, S3, V0
9D019A00  00131282   SRL V0, S3, 10
9D019A04  24420448   ADDIU V0, V0, 1096
9D019A08  00021080   SLL V0, V0, 2
9D019A0C  00521021   ADDU V0, V0, S2
9D019A10  8C420000   LW V0, 0(V0)
9D019A14  00539821   ADDU S3, V0, S3
751:                 
752:                       /* Handle $FD/$FE tile VROM switching (PunchOut) */
753:                       if (ppu.latchfunc)
9D019A18  8E4211A4   LW V0, 4516(S2)
9D019A1C  50400004   BEQL V0, ZERO, 0x9D019A30
9D019A20  92640000   LBU A0, 0(S3)
754:                          ppu.latchfunc(ppu.bg_base, tile_index);
9D019A24  0040F809   JALR V0
9D019A28  8E441184   LW A0, 4484(S2)
755:                 
756:                       draw_bgtile(bmp_ptr, data_ptr[0], data_ptr[8], ppu.palette + col_high);
9D019A2C  92640000   LBU A0, 0(S3)
9D019A30  92650008   LBU A1, 8(S3)
9D019A34  27C21100   ADDIU V0, FP, 4352
9D019A38  02421021   ADDU V0, S2, V0
757:                       bmp_ptr += 8;
758:                 
759:                       x_tile++;
9D019AE4  26310001   ADDIU S1, S1, 1
9D019AE8  323100FF   ANDI S1, S1, 255
760:                 
761:                       if (0 == (x_tile & 1))     /* check every 2 tiles */
9D019AEC  32220001   ANDI V0, S1, 1
9D019AF0  14400026   BNE V0, ZERO, 0x9D019B8C
9D019AF4  26100008   ADDIU S0, S0, 8
762:                       {
763:                          if (0 == (x_tile & 3))  /* check every 4 tiles */
9D019AF8  32220003   ANDI V0, S1, 3
9D019AFC  5440001F   BNEL V0, ZERO, 0x9D019B7C
9D019B00  3AF70002   XORI S7, S7, 2
764:                          {
765:                             if (32 == x_tile)    /* check every 32 tiles */
9D019B04  24030020   ADDIU V1, ZERO, 32
9D019B08  16230016   BNE S1, V1, 0x9D019B64
9D019B0C  8FA20018   LW V0, 24(SP)
766:                             {
767:                                x_tile = 0;
9D019B5C  00008821   ADDU S1, ZERO, ZERO
768:                                refresh_vaddr ^= (1 << 10); /* switch nametable */
9D019B10  8FA60020   LW A2, 32(SP)
9D019B14  38C60400   XORI A2, A2, 1024
9D019B18  AFA60020   SW A2, 32(SP)
769:                                attrib_base ^= (1 << 10);
9D019B1C  8FA70024   LW A3, 36(SP)
9D019B20  38E70400   XORI A3, A3, 1024
9D019B24  AFA70024   SW A3, 36(SP)
770:                 
771:                                /* recalculate pointers */
772:                                tile_ptr = &PPU_MEM(refresh_vaddr);
9D019B28  00061282   SRL V0, A2, 10
9D019B2C  24420448   ADDIU V0, V0, 1096
9D019B30  00021080   SLL V0, V0, 2
9D019B34  00521021   ADDU V0, V0, S2
9D019B38  8C550000   LW S5, 0(V0)
9D019B3C  02A6A821   ADDU S5, S5, A2
773:                                attrib_ptr = &PPU_MEM(attrib_base);
9D019B40  00071282   SRL V0, A3, 10
9D019B44  24420448   ADDIU V0, V0, 1096
9D019B48  00021080   SLL V0, V0, 2
9D019B4C  00521021   ADDU V0, V0, S2
9D019B50  8C420000   LW V0, 0(V0)
9D019B54  00471021   ADDU V0, V0, A3
9D019B58  AFA20018   SW V0, 24(SP)
774:                             }
775:                 
776:                             /* Get the attribute byte */
777:                             attrib = *attrib_ptr++;
9D019B60  8FA20018   LW V0, 24(SP)
9D019B64  90420000   LBU V0, 0(V0)
9D019B68  AFA2001C   SW V0, 28(SP)
9D019B6C  8FA30018   LW V1, 24(SP)
9D019B70  24630001   ADDIU V1, V1, 1
9D019B74  AFA30018   SW V1, 24(SP)
778:                          }
779:                 
780:                          attrib_shift ^= 2;
9D019B78  3AF70002   XORI S7, S7, 2
781:                          col_high = ((attrib >> attrib_shift) & 3) << 2;
9D019B7C  8FA6001C   LW A2, 28(SP)
9D019B80  02E6F007   SRAV FP, A2, S7
9D019B84  33DE0003   ANDI FP, FP, 3
9D019B88  001EF080   SLL FP, FP, 2
782:                       }
783:                    }
784:                 
785:                    /* Blank left hand column if need be */
786:                    if (ppu.bg_mask)
9D019B98  3C02A000   LUI V0, -24576
9D019B9C  8C4273AC   LW V0, 29612(V0)
9D019BA0  1040000D   BEQ V0, ZERO, .LBE55
9D019BA4  3C02A000   LUI V0, -24576
787:                    {
788:                       uint32 *buf_ptr = (uint32 *) vidbuf;
789:                       uint32 bg_clear = FULLBG | FULLBG << 8 | FULLBG << 16 | FULLBG << 24;
9D019BA8  90427318   LBU V0, 29464(V0)
9D019BAC  3042007F   ANDI V0, V0, 127
9D019BB0  34420080   ORI V0, V0, 128
9D019BB4  00022200   SLL A0, V0, 8
9D019BB8  00021C00   SLL V1, V0, 16
9D019BBC  00831825   OR V1, A0, V1
9D019BC0  00621825   OR V1, V1, V0
9D019BC4  00021600   SLL V0, V0, 24
9D019BC8  00621025   OR V0, V1, V0
790:                 
791:                       ((uint32 *) buf_ptr)[0] = bg_clear;
9D019BCC  8FA30028   LW V1, 40(SP)
9D019BD0  AC620000   SW V0, 0(V1)
792:                       ((uint32 *) buf_ptr)[1] = bg_clear;
9D019BD4  AC620004   SW V0, 4(V1)
793:                    }
794:                 }
795:                 
796:                 /* OAM entry */
797:                 typedef struct obj_s
798:                 {
799:                    uint8 y_loc;
800:                    uint8 tile;
801:                    uint8 atr;
802:                    uint8 x_loc;
803:                 } obj_t;
804:                 
805:                 /* TODO: fetch valid OAM a scanline before, like the Real Thing */
806:                 static void ppu_renderoam(uint8 *vidbuf, int scanline)
807:                 {
808:                    uint8 *buf_ptr;
809:                    uint32 vram_offset, savecol[2];
810:                    int sprite_num, spritecount;
811:                    obj_t *sprite_ptr;
812:                    uint8 sprite_height;
813:                 
814:                    if (false == ppu.obj_on)
9D019BF8  8C4273A4   LW V0, 29604(V0)
9D019BFC  10400221   BEQ V0, ZERO, 0x9D01A484
9D019C00  8FBF005C   LW RA, 92(SP)
815:                       return;
816:                 
817:                    /* Get our buffer pointer */
818:                    buf_ptr = vidbuf;
819:                 
820:                    /* Save left hand column? */
821:                    if (ppu.obj_mask)
9D019C04  3C02A000   LUI V0, -24576
9D019C08  8C4273A8   LW V0, 29608(V0)
9D019C0C  10400008   BEQ V0, ZERO, 0x9D019C30
9D019C10  3C02A000   LUI V0, -24576
822:                    {
823:                       savecol[0] = ((uint32 *) buf_ptr)[0];
9D019C14  8FA70028   LW A3, 40(SP)
9D019C18  8CE70000   LW A3, 0(A3)
9D019C1C  AFA7002C   SW A3, 44(SP)
824:                       savecol[1] = ((uint32 *) buf_ptr)[1];
9D019C20  8FA20028   LW V0, 40(SP)
9D019C24  8C420004   LW V0, 4(V0)
9D019C28  AFA20030   SW V0, 48(SP)
825:                    }
826:                 
827:                    sprite_height = ppu.obj_height;
9D019C2C  3C02A000   LUI V0, -24576
9D019C30  24426218   ADDIU V0, V0, 25112
9D019C34  9055117C   LBU S5, 4476(V0)
828:                    vram_offset = ppu.obj_base;
9D019C38  8C421180   LW V0, 4480(V0)
9D019C3C  AFA20018   SW V0, 24(SP)
829:                    spritecount = 0;
9D019C40  AFA00010   SW ZERO, 16(SP)
830:                 
831:                    sprite_ptr = (obj_t *) ppu.oam;
9D019C48  3C10A000   LUI S0, -24576
9D019C4C  26107218   ADDIU S0, S0, 29208
832:                 
833:                    for (sprite_num = 0; sprite_num < 64; sprite_num++, sprite_ptr++)
9D019C44  00009021   ADDU S2, ZERO, ZERO
9D019C58  3C13A000   LUI S3, -24576
9D019C5C  26737318   ADDIU S3, S3, 29464
9D01A1A0  26100004   ADDIU S0, S0, 4
9D01A1A4  1613FEAE   BNE S0, S3, 0x9D019C60
9D01A1A8  26520001   ADDIU S2, S2, 1
834:                    {
835:                       uint8 *data_ptr, *bmp_ptr;
836:                       uint32 vram_adr;
837:                       int y_offset;
838:                       uint8 tile_index, attrib, col_high;
839:                       uint8 sprite_y, sprite_x;
840:                       bool check_strike;
841:                       int strike_pixel;
842:                 
843:                       sprite_y = sprite_ptr->y_loc + 1;
9D019C60  92020000   LBU V0, 0(S0)
9D019C64  24510001   ADDIU S1, V0, 1
844:                 
845:                       /* Check to see if sprite is out of range */
846:                       if ((sprite_y > scanline) || (sprite_y <= (scanline - sprite_height))
9D019C50  0295A823   SUBU S5, S4, S5
9D019C68  323100FF   ANDI S1, S1, 255
9D019C6C  0291182A   SLT V1, S4, S1
9D019C70  5460014C   BNEL V1, ZERO, 0x9D01A1A4
9D019C74  26100004   ADDIU S0, S0, 4
9D019C78  02B1182A   SLT V1, S5, S1
9D019C7C  50600149   BEQL V1, ZERO, 0x9D01A1A4
9D019C80  26100004   ADDIU S0, S0, 4
847:                           || (0 == sprite_y) || (sprite_y >= 240))
9D019C84  24420011   ADDIU V0, V0, 17
9D019C88  304200FF   ANDI V0, V0, 255
9D019C8C  2C420011   SLTIU V0, V0, 17
9D019C90  54400144   BNEL V0, ZERO, 0x9D01A1A4
9D019C94  26100004   ADDIU S0, S0, 4
848:                          continue;
849:                 
850:                       sprite_x = sprite_ptr->x_loc;
851:                       tile_index = sprite_ptr->tile;
9D019C98  92030001   LBU V1, 1(S0)
9D019C9C  AFA30014   SW V1, 20(SP)
852:                       attrib = sprite_ptr->atr;
9D019CA0  92170002   LBU S7, 2(S0)
853:                 
854:                       bmp_ptr = buf_ptr + sprite_x;
9D019CA4  92160003   LBU S6, 3(S0)
9D019CA8  8FA60028   LW A2, 40(SP)
855:                 
856:                       /* Handle $FD/$FE tile VROM switching (PunchOut) */
857:                       if (ppu.latchfunc)
9D019C54  3C1EA000   LUI FP, -24576
9D019CAC  27C26218   ADDIU V0, FP, 25112
9D019CB0  8C4211A4   LW V0, 4516(V0)
9D019CB4  10400004   BEQ V0, ZERO, .LVL243
9D019CB8  00D6B021   ADDU S6, A2, S6
858:                          ppu.latchfunc(vram_offset, tile_index);
9D019CBC  8FA40018   LW A0, 24(SP)
9D019CC0  0040F809   JALR V0
9D019CC4  00602821   ADDU A1, V1, ZERO
859:                 
860:                       /* Get upper two bits of color */
861:                       col_high = ((attrib & 3) << 2);
9D019CC8  32E50003   ANDI A1, S7, 3
862:                 
863:                       /* 8x16 even sprites use $0000, odd use $1000 */
864:                       if (16 == ppu.obj_height)
9D019CCC  27C26218   ADDIU V0, FP, 25112
9D019CD0  9044117C   LBU A0, 4476(V0)
9D019CD4  24070010   ADDIU A3, ZERO, 16
9D019CD8  14870008   BNE A0, A3, 0x9D019CFC
9D019CDC  00052880   SLL A1, A1, 2
865:                          vram_adr = ((tile_index & 1) << 12) | ((tile_index & 0xFE) << 4);
9D019CE0  8FA20014   LW V0, 20(SP)
9D019CE4  304300FE   ANDI V1, V0, 254
9D019CE8  00031900   SLL V1, V1, 4
9D019CEC  30420001   ANDI V0, V0, 1
9D019CF0  00021300   SLL V0, V0, 12
9D019CF4  0B406743   J 0x9D019D0C
9D019CF8  00621025   OR V0, V1, V0
866:                       else
867:                          vram_adr = vram_offset + (tile_index << 4);
9D019CFC  8FA30014   LW V1, 20(SP)
9D019D00  00031100   SLL V0, V1, 4
9D019D04  8FA60018   LW A2, 24(SP)
9D019D08  00461021   ADDU V0, V0, A2
868:                 
869:                       /* Get the address of the tile */
870:                       data_ptr = &PPU_MEM(vram_adr);
9D019D0C  00023282   SRL A2, V0, 10
9D019D10  24C60448   ADDIU A2, A2, 1096
9D019D14  00063080   SLL A2, A2, 2
9D019D18  27C36218   ADDIU V1, FP, 25112
9D019D1C  00C31821   ADDU V1, A2, V1
9D019D20  8C630000   LW V1, 0(V1)
9D019D24  00621821   ADDU V1, V1, V0
871:                 
872:                       /* Calculate offset (line within the sprite) */
873:                       y_offset = scanline - sprite_y;
9D019D28  02918823   SUBU S1, S4, S1
874:                       if (y_offset > 7)
9D019D2C  2A260008   SLTI A2, S1, 8
875:                          y_offset += 8;
9D019D30  26220008   ADDIU V0, S1, 8
9D019D34  0046880A   MOVZ S1, V0, A2
876:                 
877:                       /* Account for vertical flippage */
878:                       if (attrib & OAMF_VFLIP)
9D019D38  7C173420   SEB A2, S7
9D019D3C  04C10006   BGEZ A2, 0x9D019D58
9D019D40  00711021   ADDU V0, V1, S1
879:                       {
880:                          if (16 == ppu.obj_height)
881:                             y_offset -= 23;
9D019D44  2626FFE9   ADDIU A2, S1, -23
9D019D48  2631FFF9   ADDIU S1, S1, -7
9D019D4C  38820010   XORI V0, A0, 16
9D019D50  0222300B   MOVN A2, S1, V0
882:                          else
883:                             y_offset -= 7;
884:                 
885:                          data_ptr -= y_offset;
9D019D54  00661023   SUBU V0, V1, A2
886:                       }
887:                       else
888:                       {
889:                          data_ptr += y_offset;
890:                       }
891:                 
892:                       /* if we're on sprite 0 and sprite 0 strike flag isn't set,
893:                       ** check for a strike 
894:                       */
895:                       check_strike = (0 == sprite_num) && (false == ppu.strikeflag);
9D019D58  16400004   BNE S2, ZERO, 0x9D019D6C
9D019D5C  00006821   ADDU T5, ZERO, ZERO
9D019D60  27C36218   ADDIU V1, FP, 25112
9D019D64  8C6D119C   LW T5, 4508(V1)
9D019D68  2DAD0001   SLTIU T5, T5, 1
896:                       strike_pixel = draw_oamtile(bmp_ptr, attrib, data_ptr[0], data_ptr[8], ppu.palette + 16 + col_high, check_strike);
9D019D6C  90440000   LBU A0, 0(V0)
9D019D70  90420008   LBU V0, 8(V0)
9D019D74  24A31110   ADDIU V1, A1, 4368
9D019D78  27C56218   ADDIU A1, FP, 25112
9D019D7C  00A32821   ADDU A1, A1, V1
897:                       if (strike_pixel >= 0)
9D01A164  04800004   BLTZ A0, 0x9D01A178
9D01A168  8FA70010   LW A3, 16(SP)
898:                          ppu_setstrike(strike_pixel);
9D01A16C  0F40626E   JAL .LFB19, ppu_setstrike, .Ltext0
9D01A170  00000000   NOP
899:                 
900:                       /* maximum of 8 sprites per scanline */
901:                       if (++spritecount == PPU_MAXSPRITE)
9D01A174  8FA70010   LW A3, 16(SP)
9D01A178  24E70001   ADDIU A3, A3, 1
9D01A17C  24020008   ADDIU V0, ZERO, 8
9D01A180  14E20007   BNE A3, V0, 0x9D01A1A0
9D01A184  AFA70010   SW A3, 16(SP)
902:                       {
903:                          ppu.stat |= PPU_STATF_MAXSPRITE;
9D01A188  3C02A000   LUI V0, -24576
9D01A18C  24426218   ADDIU V0, V0, 25112
9D01A190  90431162   LBU V1, 4450(V0)
9D01A194  34630020   ORI V1, V1, 32
9D01A198  0B40686B   J 0x9D01A1AC
9D01A19C  A0431162   SB V1, 4450(V0)
904:                          break;
905:                       }
906:                    }
907:                 
908:                    /* Restore lefthand column */
909:                    if (ppu.obj_mask)
9D01A1AC  3C02A000   LUI V0, -24576
9D01A1B0  8C4273A8   LW V0, 29608(V0)
9D01A1B4  104000B2   BEQ V0, ZERO, 0x9D01A480
9D01A1B8  8FA3002C   LW V1, 44(SP)
910:                    {
911:                       ((uint32 *) buf_ptr)[0] = savecol[0];
9D01A1BC  8FA20028   LW V0, 40(SP)
9D01A1C0  AC430000   SW V1, 0(V0)
912:                       ((uint32 *) buf_ptr)[1] = savecol[1];
9D01A1C4  8FA60030   LW A2, 48(SP)
9D01A1C8  0B406920   J 0x9D01A480
9D01A1CC  AC460004   SW A2, 4(V0)
913:                    }
914:                 }
915:                 
916:                 /* Fake rendering a line */
917:                 /* This is needed for sprite 0 hits when we're skipping drawing a frame */
918:                 static void ppu_fakeoam(int scanline)
919:                 {
920:                    uint8 *data_ptr;
921:                    obj_t *sprite_ptr;
922:                    uint32 vram_adr, color;
923:                    int y_offset;
924:                    uint8 pat1, pat2;
925:                    uint8 tile_index, attrib;
926:                    uint8 sprite_height, sprite_y, sprite_x;
927:                 
928:                    /* we don't need to be here if strike flag is set */
929:                 
930:                    if (false == ppu.obj_on || ppu.strikeflag)
9D01A1D0  8C4273A4   LW V0, 29604(V0)
9D01A1D4  104000AA   BEQ V0, ZERO, 0x9D01A480
9D01A1D8  3C02A000   LUI V0, -24576
9D01A1DC  8C4273B4   LW V0, 29620(V0)
9D01A1E0  144000A7   BNE V0, ZERO, 0x9D01A480
9D01A1E4  3C02A000   LUI V0, -24576
931:                       return;
932:                 
933:                    sprite_height = ppu.obj_height;
9D01A1E8  24426218   ADDIU V0, V0, 25112
9D01A1EC  9045117C   LBU A1, 4476(V0)
934:                    sprite_ptr = (obj_t *) ppu.oam;
935:                    sprite_y = sprite_ptr->y_loc + 1;
9D01A1F0  90431000   LBU V1, 4096(V0)
9D01A1F4  24620001   ADDIU V0, V1, 1
936:                 
937:                    /* Check to see if sprite is out of range */
938:                    if ((sprite_y > scanline) || (sprite_y <= (scanline - sprite_height)) 
9D01A1F8  304200FF   ANDI V0, V0, 255
9D01A1FC  0282202A   SLT A0, S4, V0
9D01A200  1480009F   BNE A0, ZERO, 0x9D01A480
9D01A204  02852023   SUBU A0, S4, A1
9D01A208  0082202A   SLT A0, A0, V0
9D01A20C  1080009C   BEQ A0, ZERO, 0x9D01A480
9D01A210  24630010   ADDIU V1, V1, 16
939:                        || (0 == sprite_y) || (sprite_y > 240))
9D01A214  306300FF   ANDI V1, V1, 255
9D01A218  2C630010   SLTIU V1, V1, 16
9D01A21C  14600098   BNE V1, ZERO, 0x9D01A480
9D01A220  3C03A000   LUI V1, -24576
940:                       return;
941:                 
942:                    sprite_x = sprite_ptr->x_loc;
9D01A224  24636218   ADDIU V1, V1, 25112
9D01A228  90641003   LBU A0, 4099(V1)
943:                    tile_index = sprite_ptr->tile;
9D01A22C  90671001   LBU A3, 4097(V1)
944:                    attrib = sprite_ptr->atr;
9D01A230  90661002   LBU A2, 4098(V1)
945:                 
946:                    /* 8x16 even sprites use $0000, odd use $1000 */
947:                    if (16 == ppu.obj_height)
9D01A234  24030010   ADDIU V1, ZERO, 16
9D01A238  54A30007   BNEL A1, V1, 0x9D01A258
9D01A23C  00073900   SLL A3, A3, 4
948:                       vram_adr = ((tile_index & 1) << 12) | ((tile_index & 0xFE) << 4);
9D01A240  30E800FE   ANDI T0, A3, 254
9D01A244  00084100   SLL T0, T0, 4
9D01A248  30E30001   ANDI V1, A3, 1
9D01A24C  00031B00   SLL V1, V1, 12
9D01A250  0B406899   J 0x9D01A264
9D01A254  01031825   OR V1, T0, V1
949:                    else
950:                       vram_adr = ppu.obj_base + (tile_index << 4);
9D01A258  3C03A000   LUI V1, -24576
9D01A25C  8C637398   LW V1, 29592(V1)
9D01A260  00E31821   ADDU V1, A3, V1
951:                 
952:                    data_ptr = &PPU_MEM(vram_adr);
9D01A264  00034282   SRL T0, V1, 10
9D01A268  25080448   ADDIU T0, T0, 1096
9D01A26C  00084080   SLL T0, T0, 2
9D01A270  3C07A000   LUI A3, -24576
9D01A274  24E76218   ADDIU A3, A3, 25112
9D01A278  01073821   ADDU A3, T0, A3
9D01A27C  8CE70000   LW A3, 0(A3)
9D01A280  00E33821   ADDU A3, A3, V1
953:                 
954:                    /* Calculate offset (line within the sprite) */
955:                    y_offset = scanline - sprite_y;
9D01A284  02821023   SUBU V0, S4, V0
956:                    if (y_offset > 7)
9D01A288  28480008   SLTI T0, V0, 8
957:                       y_offset += 8;
9D01A28C  24430008   ADDIU V1, V0, 8
9D01A290  0068100A   MOVZ V0, V1, T0
958:                 
959:                    /* Account for vertical flippage */
960:                    if (attrib & OAMF_VFLIP)
9D01A294  7C064420   SEB T0, A2
9D01A298  05010006   BGEZ T0, 0x9D01A2B4
9D01A29C  00E21821   ADDU V1, A3, V0
961:                    {
962:                       if (16 == ppu.obj_height)
963:                          y_offset -= 23;
9D01A2A0  2448FFE9   ADDIU T0, V0, -23
9D01A2A4  2442FFF9   ADDIU V0, V0, -7
9D01A2A8  38A30010   XORI V1, A1, 16
9D01A2AC  0043400B   MOVN T0, V0, V1
964:                       else
965:                          y_offset -= 7;
966:                       data_ptr -= y_offset;
9D01A2B0  00E81823   SUBU V1, A3, T0
967:                    }
968:                    else
969:                    {
970:                       data_ptr += y_offset;
971:                    }
972:                 
973:                    /* check for a solid sprite 0 pixel */
974:                    pat1 = data_ptr[0];
9D01A2B4  90650000   LBU A1, 0(V1)
975:                    pat2 = data_ptr[8];
9D01A2B8  90620008   LBU V0, 8(V1)
976:                    color = ((pat2 & 0xAA) << 8) | ((pat2 & 0x55) << 1)
9D01A2BC  2403FFAA   ADDIU V1, ZERO, -86
9D01A2C0  00433824   AND A3, V0, V1
9D01A2C4  00073A00   SLL A3, A3, 8
9D01A2C8  30420055   ANDI V0, V0, 85
9D01A2CC  00021040   SLL V0, V0, 1
9D01A2D0  00E23825   OR A3, A3, V0
977:                                   | ((pat1 & 0xAA) << 7) | (pat1 & 0x55);
9D01A2D4  30A20055   ANDI V0, A1, 85
9D01A2D8  00E23825   OR A3, A3, V0
9D01A2DC  00A31024   AND V0, A1, V1
9D01A2E0  000211C0   SLL V0, V0, 7
9D01A2E4  00E21025   OR V0, A3, V0
978:                 
979:                    if (color)
9D01A2E8  10400065   BEQ V0, ZERO, 0x9D01A480
9D01A2EC  30C30040   ANDI V1, A2, 64
980:                    {
981:                       uint8 colors[8];
982:                 
983:                       /* buckle up, it's going to get ugly... */
984:                       if (0 == (attrib & OAMF_HFLIP))
9D01A2F0  306300FF   ANDI V1, V1, 255
9D01A2F4  5460000A   BNEL V1, ZERO, 0x9D01A320
9D01A2F8  00023382   SRL A2, V0, 14
985:                       {
986:                          colors[0] = (color >> 14) & 3;
9D01A2FC  00021B82   SRL V1, V0, 14
987:                          colors[1] = (color >> 6) & 3;
9D01A300  7C450980   EXT A1, V0, 6, 2
988:                          colors[2] = (color >> 12) & 3;
9D01A304  7C4B0B00   EXT T3, V0, 12, 2
989:                          colors[3] = (color >> 4) & 3;
9D01A308  7C4A0900   EXT T2, V0, 4, 2
990:                          colors[4] = (color >> 10) & 3;
9D01A30C  7C490A80   EXT T1, V0, 10, 2
991:                          colors[5] = (color >> 2) & 3;
9D01A310  7C480880   EXT T0, V0, 2, 2
992:                          colors[6] = (color >> 8) & 3;
9D01A314  7C470A00   EXT A3, V0, 8, 2
993:                          colors[7] = color & 3;
9D01A318  0B4068CF   J 0x9D01A33C
9D01A31C  30460003   ANDI A2, V0, 3
994:                       }
995:                       else
996:                       {
997:                          colors[7] = (color >> 14) & 3;
998:                          colors[6] = (color >> 6) & 3;
9D01A320  7C470980   EXT A3, V0, 6, 2
999:                          colors[5] = (color >> 12) & 3;
9D01A324  7C480B00   EXT T0, V0, 12, 2
1000:                         colors[4] = (color >> 4) & 3;
9D01A328  7C490900   EXT T1, V0, 4, 2
1001:                         colors[3] = (color >> 10) & 3;
9D01A32C  7C4A0A80   EXT T2, V0, 10, 2
1002:                         colors[2] = (color >> 2) & 3;
9D01A330  7C4B0880   EXT T3, V0, 2, 2
1003:                         colors[1] = (color >> 8) & 3;
9D01A334  7C450A00   EXT A1, V0, 8, 2
1004:                         colors[0] = color & 3;
9D01A338  30430003   ANDI V1, V0, 3
1005:                      }
1006:                
1007:                      if (colors[0])
9D01A33C  10600005   BEQ V1, ZERO, 0x9D01A354
9D01A340  00000000   NOP
1008:                         ppu_setstrike(sprite_x + 0);
9D01A344  0F40626E   JAL .LFB19, ppu_setstrike, .Ltext0
9D01A348  00000000   NOP
1009:                      else if (colors[1])
9D01A354  10A00005   BEQ A1, ZERO, 0x9D01A36C
9D01A358  00000000   NOP
1010:                         ppu_setstrike(sprite_x + 1);
9D01A35C  0F40626E   JAL .LFB19, ppu_setstrike, .Ltext0
9D01A360  24840001   ADDIU A0, A0, 1
1011:                      else if (colors[2])
9D01A36C  11600005   BEQ T3, ZERO, 0x9D01A384
9D01A370  00000000   NOP
1012:                         ppu_setstrike(sprite_x + 2);
9D01A374  0F40626E   JAL .LFB19, ppu_setstrike, .Ltext0
9D01A378  24840002   ADDIU A0, A0, 2
1013:                      else if (colors[3])
9D01A384  11400005   BEQ T2, ZERO, 0x9D01A39C
9D01A388  00000000   NOP
1014:                         ppu_setstrike(sprite_x + 3);
9D01A38C  0F40626E   JAL .LFB19, ppu_setstrike, .Ltext0
9D01A390  24840003   ADDIU A0, A0, 3
1015:                      else if (colors[4])
9D01A39C  11200005   BEQ T1, ZERO, 0x9D01A3B4
9D01A3A0  00000000   NOP
1016:                         ppu_setstrike(sprite_x + 4);
9D01A3A4  0F40626E   JAL .LFB19, ppu_setstrike, .Ltext0
9D01A3A8  24840004   ADDIU A0, A0, 4
1017:                      else if (colors[5])
9D01A3B4  11000005   BEQ T0, ZERO, 0x9D01A3CC
9D01A3B8  00000000   NOP
1018:                         ppu_setstrike(sprite_x + 5);
9D01A3BC  0F40626E   JAL .LFB19, ppu_setstrike, .Ltext0
9D01A3C0  24840005   ADDIU A0, A0, 5
1019:                      else if (colors[6])
9D01A3CC  10E00005   BEQ A3, ZERO, 0x9D01A3E4
9D01A3D0  00000000   NOP
1020:                         ppu_setstrike(sprite_x + 6);
9D01A3D4  0F40626E   JAL .LFB19, ppu_setstrike, .Ltext0
9D01A3D8  24840006   ADDIU A0, A0, 6
1021:                      else if (colors[7])
9D01A3E4  50C00027   BEQL A2, ZERO, 0x9D01A484
9D01A3E8  8FBF005C   LW RA, 92(SP)
1022:                         ppu_setstrike(sprite_x + 7);
9D01A3EC  0F40626E   JAL .LFB19, ppu_setstrike, .Ltext0
9D01A3F0  24840007   ADDIU A0, A0, 7
1023:                   }
1024:                }
1025:                
1026:                bool ppu_enabled(void)
1027:                {
1028:                   return (ppu.bg_on || ppu.obj_on);
9D019730  3C02A000   LUI V0, -24576
9D019734  8C4373A0   LW V1, 29600(V0)
9D019738  14600004   BNE V1, ZERO, 0x9D01974C
9D01973C  24020001   ADDIU V0, ZERO, 1
9D019740  3C02A000   LUI V0, -24576
9D019744  8C4273A4   LW V0, 29604(V0)
9D019748  0002102B   SLTU V0, ZERO, V0
1029:                }
9D01974C  03E00008   JR RA
9D019750  00000000   NOP
1030:                
1031:                static void ppu_renderscanline(bitmap_t *bmp, int scanline, bool draw_flag)
1032:                {
1033:                   uint8 *buf = bmp->line[scanline];
9D019878  24A30004   ADDIU V1, A1, 4
9D01987C  00031880   SLL V1, V1, 2
9D019880  00832021   ADDU A0, A0, V1
9D019884  8C840004   LW A0, 4(A0)
9D019888  AFA40028   SW A0, 40(SP)
1034:                
1035:                   /* start scanline - transfer ppu latch into vaddr */
1036:                   if (ppu.bg_on || ppu.obj_on)
9D01988C  8C421188   LW V0, 4488(V0)
9D019890  14400004   BNE V0, ZERO, 0x9D0198A4
9D019894  3C03A000   LUI V1, -24576
9D019898  8C6373A4   LW V1, 29604(V1)
9D01989C  106002EF   BEQ V1, ZERO, 0x9D01A45C
9D0198A0  8FA70068   LW A3, 104(SP)
1037:                   {
1038:                      if (0 == scanline)
9D0198A4  16800005   BNE S4, ZERO, 0x9D0198BC
9D0198A8  3C03A000   LUI V1, -24576
1039:                      {
1040:                         ppu.vaddr = ppu.vaddr_latch;
9D0198AC  24636218   ADDIU V1, V1, 25112
9D0198B0  8C641168   LW A0, 4456(V1)
9D0198B4  0B406637   J 0x9D0198DC
9D0198B8  AC641164   SW A0, 4452(V1)
1041:                      }
1042:                      else
1043:                      {
1044:                         ppu.vaddr &= ~0x041F;
9D0198C8  8C661164   LW A2, 4452(V1)
9D0198CC  2404FBE0   ADDIU A0, ZERO, -1056
9D0198D0  00C42024   AND A0, A2, A0
1045:                         ppu.vaddr |= (ppu.vaddr_latch & 0x041F);
9D0198BC  24636218   ADDIU V1, V1, 25112
9D0198C0  8C651168   LW A1, 4456(V1)
9D0198C4  30A5041F   ANDI A1, A1, 1055
9D0198D4  00A42025   OR A0, A1, A0
9D0198D8  AC641164   SW A0, 4452(V1)
1046:                      }
1047:                   }
1048:                
1049:                   if (draw_flag)
9D0198DC  8FA30068   LW V1, 104(SP)
9D0198E0  5060023B   BEQL V1, ZERO, .LBB88
9D0198E4  3C02A000   LUI V0, -24576
9D01A45C  50E0FF5C   BEQL A3, ZERO, .LBB88
9D01A460  3C02A000   LUI V0, -24576
1050:                      ppu_renderbg(buf);
1051:                
1052:                   /* TODO: fetch obj data 1 scanline before */
1053:                   if (true == ppu.drawsprites && true == draw_flag)
9D01990C  0B4066F7   J 0x9D019BDC
9D019910  3C02A000   LUI V0, -24576
9D019BD8  3C02A000   LUI V0, -24576
9D019BDC  8C437FCC   LW V1, 32716(V0)
9D019BE0  24020001   ADDIU V0, ZERO, 1
9D019BE4  5462017A   BNEL V1, V0, .LBB88
9D019BE8  3C02A000   LUI V0, -24576
9D019BEC  8FA60068   LW A2, 104(SP)
9D019BF0  14C20177   BNE A2, V0, .LBB88
9D019BF4  3C02A000   LUI V0, -24576
1054:                      ppu_renderoam(buf, scanline);
1055:                   else
1056:                      ppu_fakeoam(scanline);
1057:                }
1058:                
1059:                
1060:                void ppu_endscanline(int scanline)
1061:                {
1062:                   /* modify vram address at end of scanline */
1063:                   if (scanline < 240 && (ppu.bg_on || ppu.obj_on))
9D019754  288400F0   SLTI A0, A0, 240
9D019758  10800025   BEQ A0, ZERO, 0x9D0197F0
9D01975C  3C02A000   LUI V0, -24576
9D019760  8C4273A0   LW V0, 29600(V0)
9D019764  14400005   BNE V0, ZERO, 0x9D01977C
9D019768  3C02A000   LUI V0, -24576
9D01976C  3C02A000   LUI V0, -24576
9D019770  8C4273A4   LW V0, 29604(V0)
9D019774  1040001E   BEQ V0, ZERO, 0x9D0197F0
9D019778  3C02A000   LUI V0, -24576
1064:                   {
1065:                      int ytile;
1066:                
1067:                      /* check for max 3 bit y tile offset */
1068:                      if (7 == (ppu.vaddr >> 12))
9D01977C  8C42737C   LW V0, 29564(V0)
9D019780  00022302   SRL A0, V0, 12
9D019784  24030007   ADDIU V1, ZERO, 7
9D019788  54830017   BNEL A0, V1, 0x9D0197E8
9D01978C  24421000   ADDIU V0, V0, 4096
1069:                      {
1070:                         ppu.vaddr &= ~0x7000;      /* clear y tile offset */
9D019790  24038FFF   ADDIU V1, ZERO, -28673
9D019794  00432024   AND A0, V0, V1
1071:                         ytile = (ppu.vaddr >> 5) & 0x1F;
9D019798  7C832140   EXT V1, A0, 5, 5
1072:                
1073:                         if (29 == ytile)
9D01979C  2405001D   ADDIU A1, ZERO, 29
9D0197A0  54650007   BNEL V1, A1, 0x9D0197C0
9D0197A4  2405001F   ADDIU A1, ZERO, 31
1074:                         {
1075:                            ppu.vaddr &= ~0x03E0;   /* clear y tile */
9D0197A8  24038C1F   ADDIU V1, ZERO, -29665
9D0197AC  00431024   AND V0, V0, V1
1076:                            ppu.vaddr ^= 0x0800;    /* toggle nametable */
9D0197B0  38420800   XORI V0, V0, 2048
9D0197B4  3C03A000   LUI V1, -24576
9D0197B8  03E00008   JR RA
9D0197BC  AC62737C   SW V0, 29564(V1)
1077:                         }
1078:                         else if (31 == ytile)
9D0197C0  54650006   BNEL V1, A1, 0x9D0197DC
9D0197C4  24840020   ADDIU A0, A0, 32
1079:                         {
1080:                            ppu.vaddr &= ~0x03E0;   /* clear y tile */
9D0197C8  24038C1F   ADDIU V1, ZERO, -29665
9D0197CC  00431024   AND V0, V0, V1
9D0197D0  3C03A000   LUI V1, -24576
9D0197D4  03E00008   JR RA
9D0197D8  AC62737C   SW V0, 29564(V1)
1081:                         }
1082:                         else
1083:                         {
1084:                            ppu.vaddr += 0x20;      /* increment y tile */
9D0197DC  3C02A000   LUI V0, -24576
9D0197E0  03E00008   JR RA
9D0197E4  AC44737C   SW A0, 29564(V0)
1085:                         }
1086:                      }
1087:                      else
1088:                      {
1089:                         ppu.vaddr += 0x1000;       /* increment tile y offset */
9D0197E8  3C03A000   LUI V1, -24576
9D0197EC  AC62737C   SW V0, 29564(V1)
9D0197F0  03E00008   JR RA
9D0197F4  00000000   NOP
1090:                      }
1091:                   }
1092:                }
1093:                
1094:                void ppu_checknmi(void)
1095:                {
9D019808  27BDFFE8   ADDIU SP, SP, -24
9D01980C  AFBF0014   SW RA, 20(SP)
1096:                   if (ppu.ctrl0 & PPU_CTRL0F_NMI)
9D0197F8  3C02A000   LUI V0, -24576
9D0197FC  80427378   LB V0, 29560(V0)
9D019800  04410007   BGEZ V0, 0x9D019820
9D019804  00000000   NOP
1097:                      nes_nmi();
9D019810  0F408D53   JAL nes_nmi
9D019814  00000000   NOP
1098:                }
9D019818  8FBF0014   LW RA, 20(SP)
9D01981C  27BD0018   ADDIU SP, SP, 24
9D019820  03E00008   JR RA
9D019824  00000000   NOP
1099:                
1100:                void ppu_scanline(bitmap_t *bmp, int scanline, bool draw_flag)
1101:                {
9D019828  27BDFFA0   ADDIU SP, SP, -96
9D01982C  AFBF005C   SW RA, 92(SP)
9D019830  AFBE0058   SW FP, 88(SP)
9D019834  AFB70054   SW S7, 84(SP)
9D019838  AFB60050   SW S6, 80(SP)
9D01983C  AFB5004C   SW S5, 76(SP)
9D019840  AFB40048   SW S4, 72(SP)
9D019844  AFB30044   SW S3, 68(SP)
9D019848  AFB20040   SW S2, 64(SP)
9D01984C  AFB1003C   SW S1, 60(SP)
9D019850  AFB00038   SW S0, 56(SP)
9D019854  00A0A021   ADDU S4, A1, ZERO
1102:                   if (scanline < 240)
9D019858  28A200F0   SLTI V0, A1, 240
9D01985C  104002E7   BEQ V0, ZERO, 0x9D01A3FC
9D019860  AFA60068   SW A2, 104(SP)
1103:                   {
1104:                      /* Lower the Max Sprite per scanline flag */
1105:                      ppu.stat &= ~PPU_STATF_MAXSPRITE;
9D019864  3C02A000   LUI V0, -24576
9D019868  24426218   ADDIU V0, V0, 25112
9D01986C  90431162   LBU V1, 4450(V0)
9D019870  7C032944   INS V1, ZERO, 5, 1
9D019874  A0431162   SB V1, 4450(V0)
1106:                      ppu_renderscanline(bmp, scanline, draw_flag);
1107:                   }
1108:                   else if (241 == scanline)
9D01A3FC  240200F1   ADDIU V0, ZERO, 241
9D01A400  14A2000A   BNE A1, V0, 0x9D01A42C
9D01A404  24020105   ADDIU V0, ZERO, 261
1109:                   {
1110:                      ppu.stat |= PPU_STATF_VBLANK;
9D01A408  3C02A000   LUI V0, -24576
9D01A40C  24426218   ADDIU V0, V0, 25112
9D01A410  90441162   LBU A0, 4450(V0)
9D01A414  2403FF80   ADDIU V1, ZERO, -128
9D01A418  00831825   OR V1, A0, V1
9D01A41C  A0431162   SB V1, 4450(V0)
1111:                      ppu.vram_accessible = true;
9D01A420  24030001   ADDIU V1, ZERO, 1
9D01A424  0B406920   J 0x9D01A480
9D01A428  AC431DAC   SW V1, 7596(V0)
1112:                   }
1113:                   else if (261 == scanline)
9D01A42C  14A20015   BNE A1, V0, 0x9D01A484
9D01A430  8FBF005C   LW RA, 92(SP)
1114:                   {
1115:                      ppu.stat &= ~PPU_STATF_VBLANK;
9D01A434  3C02A000   LUI V0, -24576
9D01A438  24426218   ADDIU V0, V0, 25112
9D01A43C  90431162   LBU V1, 4450(V0)
9D01A440  3063007F   ANDI V1, V1, 127
9D01A444  A0431162   SB V1, 4450(V0)
1116:                      ppu.strikeflag = false;
9D01A448  AC40119C   SW ZERO, 4508(V0)
1117:                      ppu.strike_cycle = (uint32) -1;
9D01A44C  2403FFFF   ADDIU V1, ZERO, -1
9D01A450  AC4311A0   SW V1, 4512(V0)
1118:                
1119:                      ppu.vram_accessible = false;
9D01A454  0B406920   J 0x9D01A480
9D01A458  AC401DAC   SW ZERO, 7596(V0)
1120:                   }
1121:                }
9D01A34C  0B406921   J 0x9D01A484
9D01A350  8FBF005C   LW RA, 92(SP)
9D01A364  0B406921   J 0x9D01A484
9D01A368  8FBF005C   LW RA, 92(SP)
9D01A37C  0B406921   J 0x9D01A484
9D01A380  8FBF005C   LW RA, 92(SP)
9D01A394  0B406921   J 0x9D01A484
9D01A398  8FBF005C   LW RA, 92(SP)
9D01A3AC  0B406921   J 0x9D01A484
9D01A3B0  8FBF005C   LW RA, 92(SP)
9D01A3C4  0B406921   J 0x9D01A484
9D01A3C8  8FBF005C   LW RA, 92(SP)
9D01A3DC  0B406921   J 0x9D01A484
9D01A3E0  8FBF005C   LW RA, 92(SP)
9D01A3F4  0B406921   J 0x9D01A484
9D01A3F8  8FBF005C   LW RA, 92(SP)
9D01A480  8FBF005C   LW RA, 92(SP)
9D01A484  8FBE0058   LW FP, 88(SP)
9D01A488  8FB70054   LW S7, 84(SP)
9D01A48C  8FB60050   LW S6, 80(SP)
9D01A490  8FB5004C   LW S5, 76(SP)
9D01A494  8FB40048   LW S4, 72(SP)
9D01A498  8FB30044   LW S3, 68(SP)
9D01A49C  8FB20040   LW S2, 64(SP)
9D01A4A0  8FB1003C   LW S1, 60(SP)
9D01A4A4  8FB00038   LW S0, 56(SP)
9D01A4A8  03E00008   JR RA
9D01A4AC  27BD0060   ADDIU SP, SP, 96
1122:                
1123:                /*
1124:                bool ppu_checkzapperhit(bitmap_t *bmp, int x, int y)
1125:                {
1126:                   uint8 pixel = bmp->line[y][x] & 0x3F;
1127:                
1128:                   if (0x20 == pixel || 0x30 == pixel)
1129:                      return true;
1130:                
1131:                   return false;
1132:                }
1133:                */
1134:                
1135:                /*************************************************/
1136:                /* TODO: all this stuff should go somewhere else */
1137:                /*************************************************/
1138:                INLINE void draw_box(bitmap_t *bmp, int x, int y, int height)
1139:                {
1140:                   int i;
1141:                   uint8 *vid;
1142:                
1143:                   vid = bmp->line[y] + x;
9D01A548  25220004   ADDIU V0, T1, 4
9D01A54C  00021080   SLL V0, V0, 2
9D01A550  00821021   ADDU V0, A0, V0
9D01A554  8C430004   LW V1, 4(V0)
9D01A558  00681821   ADDU V1, V1, T0
9D01A55C  2467000A   ADDIU A3, V1, 10
1144:                
1145:                   for (i = 0; i < 10; i++)
9D01A564  1467FFFE   BNE V1, A3, 0x9D01A560
9D01A568  A06BFFFF   SB T3, -1(V1)
1146:                      *vid++ = GUI_GRAY;
9D01A4EC  240BFFC2   ADDIU T3, ZERO, -62
9D01A560  24630001   ADDIU V1, V1, 1
1147:                   vid += (bmp->pitch - 10);
9D01A56C  8C820008   LW V0, 8(A0)
9D01A570  2442FFF6   ADDIU V0, V0, -10
1148:                   for (i = 0; i < height; i++)
9D01A574  19800097   BLEZ T4, 0x9D01A7D4
9D01A578  00E21021   ADDU V0, A3, V0
9D01A57C  00001821   ADDU V1, ZERO, ZERO
9D01A590  24630001   ADDIU V1, V1, 1
9D01A594  006C382A   SLT A3, V1, T4
9D01A598  54E0FFFA   BNEL A3, ZERO, 0x9D01A584
9D01A59C  A04B0009   SB T3, 9(V0)
9D01A5A0  0B40696A   J 0x9D01A5A8
9D01A5A4  2443000A   ADDIU V1, V0, 10
9D01A670  0263400B   MOVN T0, S3, V1
9D01A7DC  00004821   ADDU T1, ZERO, ZERO
1149:                   {
1150:                      vid[0] = vid[9] = GUI_GRAY;
9D01A580  A04B0009   SB T3, 9(V0)
9D01A584  A04B0000   SB T3, 0(V0)
1151:                      vid += bmp->pitch;
9D01A588  8C870008   LW A3, 8(A0)
9D01A58C  00471021   ADDU V0, V0, A3
1152:                   }
1153:                   for (i = 0; i < 10; i++)
9D01A5AC  1443FFFE   BNE V0, V1, 0x9D01A5A8
9D01A5B0  A04BFFFF   SB T3, -1(V0)
1154:                      *vid++ = GUI_GRAY;
9D01A5A8  24420001   ADDIU V0, V0, 1
1155:                }
1156:                
1157:                INLINE void draw_deadsprite(bitmap_t *bmp, int x, int y, int height)
1158:                {
1159:                   int i, j, index;
1160:                   uint8 *vid;
1161:                   uint8 colbuf[8] = { GUI_BLACK, GUI_BLACK, GUI_BLACK, GUI_BLACK,
9D01A4F0  3C199D04   LUI T9, -25340
9D01A744  88430003   LWL V1, 3(V0)
9D01A748  9B23BF14   LWR V1, -16620(T9)
9D01A74C  88470007   LWL A3, 7(V0)
9D01A750  98470004   LWR A3, 4(V0)
9D01A754  AFA30000   SW V1, 0(SP)
9D01A758  AFA70004   SW A3, 4(SP)
1162:                                       GUI_BLACK, GUI_BLACK, GUI_BLACK, GUI_DKGRAY };
1163:                
1164:                   vid = bmp->line[y] + x;
9D01A75C  25220005   ADDIU V0, T1, 5
9D01A760  00021080   SLL V0, V0, 2
9D01A764  00821021   ADDU V0, A0, V0
9D01A76C  8C490004   LW T1, 4(V0)
1165:                
1166:                   for (i = 0; i < height; i++)
9D01A770  19800013   BLEZ T4, 0x9D01A7C0
9D01A774  01284821   ADDU T1, T1, T0
9D01A778  00009821   ADDU S3, ZERO, ZERO
9D01A784  00001021   ADDU V0, ZERO, ZERO
9D01A7B0  26730001   ADDIU S3, S3, 1
9D01A7B4  026C102A   SLT V0, S3, T4
9D01A7B8  5440FFF1   BNEL V0, ZERO, 0x9D01A780
9D01A7BC  00131843   SRA V1, S3, 1
1167:                   {
1168:                      index = i;
1169:                
1170:                      if (height == 16)
1171:                         index >>= 1;
9D01A4F4  01857026   XOR T6, T4, A1
9D01A77C  00131843   SRA V1, S3, 1
9D01A780  026E180B   MOVN V1, S3, T6
1172:                
1173:                      for (j = 0; j < 8; j++)
9D01A4F8  240A0008   ADDIU T2, ZERO, 8
9D01A79C  24420001   ADDIU V0, V0, 1
9D01A7A0  144AFFF9   BNE V0, T2, 0x9D01A788
9D01A7A4  30E30007   ANDI V1, A3, 7
1174:                      {
1175:                         *(vid + j) = colbuf[index++];
9D01A788  24670001   ADDIU A3, V1, 1
9D01A78C  01224021   ADDU T0, T1, V0
9D01A790  03A31821   ADDU V1, SP, V1
9D01A794  90630000   LBU V1, 0(V1)
9D01A798  A1030000   SB V1, 0(T0)
1176:                         index &= 7;
1177:                      }
1178:                
1179:                      vid += bmp->pitch;
9D01A7A8  8C820008   LW V0, 8(A0)
9D01A7AC  01224821   ADDU T1, T1, V0
1180:                   }
1181:                }
1182:                
1183:                
1184:                /* Stuff for the OAM viewer */
1185:                static void draw_sprite(bitmap_t *bmp, int x, int y, uint8 tile_num, uint8 attrib)
1186:                {
1187:                   int line, height;
1188:                   int col_high, vram_adr;
1189:                   uint8 *vid, *data_ptr;
1190:                
1191:                   vid = bmp->line[y] + x;
9D01A5D0  25220005   ADDIU V0, T1, 5
9D01A5D4  00021080   SLL V0, V0, 2
9D01A5D8  00821021   ADDU V0, A0, V0
9D01A5E0  8C420004   LW V0, 4(V0)
1192:                
1193:                   /* Get upper two bits of color */
1194:                   col_high = ((attrib & 3) << 2);
9D01A5E4  91E70002   LBU A3, 2(T7)
9D01A5E8  30E70003   ANDI A3, A3, 3
9D01A5EC  00079880   SLL S3, A3, 2
1195:                
1196:                   /* 8x16 even sprites use $0000, odd use $1000 */
1197:                   height = ppu.obj_height;
9D01A4FC  3C06A000   LUI A2, -24576
9D01A5F0  24C76218   ADDIU A3, A2, 25112
9D01A5F4  90F4117C   LBU S4, 4476(A3)
1198:                   if (16 == height)
9D01A5F8  1685000E   BNE S4, A1, 0x9D01A634
9D01A5FC  00481021   ADDU V0, V0, T0
1199:                      vram_adr = ((tile_num & 1) << 12) | ((tile_num & 0xFE) << 4);
9D01A600  306700FE   ANDI A3, V1, 254
9D01A604  00073900   SLL A3, A3, 4
9D01A608  30630001   ANDI V1, V1, 1
9D01A60C  00031B00   SLL V1, V1, 12
9D01A610  00E31825   OR V1, A3, V1
1200:                   /* else just use the offset from $2000 */
1201:                   else
1202:                      vram_adr = ppu.obj_base + (tile_num << 4);
9D01A634  00031900   SLL V1, V1, 4
9D01A638  24C76218   ADDIU A3, A2, 25112
9D01A63C  8CE81180   LW T0, 4480(A3)
9D01A640  00681821   ADDU V1, V1, T0
1203:                
1204:                   data_ptr = &PPU_MEM(vram_adr);
9D01A614  00034283   SRA T0, V1, 10
9D01A618  25080448   ADDIU T0, T0, 1096
9D01A61C  00084080   SLL T0, T0, 2
9D01A620  24C76218   ADDIU A3, A2, 25112
9D01A624  01073821   ADDU A3, T0, A3
9D01A628  8CE80000   LW T0, 0(A3)
9D01A62C  0B4069F7   J 0x9D01A7DC
9D01A630  01034021   ADDU T0, T0, V1
9D01A644  00034283   SRA T0, V1, 10
9D01A648  25080448   ADDIU T0, T0, 1096
9D01A64C  00084080   SLL T0, T0, 2
9D01A650  01073821   ADDU A3, T0, A3
9D01A654  8CE80000   LW T0, 0(A3)
1205:                
1206:                   for (line = 0; line < height; line++)
9D01A658  1E800060   BGTZ S4, 0x9D01A7DC
9D01A65C  01034021   ADDU T0, T0, V1
9D01A72C  25290001   ADDIU T1, T1, 1
9D01A730  0134182A   SLT V1, T1, S4
9D01A734  1460FFCC   BNE V1, ZERO, 0x9D01A668
9D01A738  25130001   ADDIU S3, T0, 1
1207:                   {
1208:                      if (line == 8)
1209:                         data_ptr += 8;
9D01A668  25080009   ADDIU T0, T0, 9
9D01A66C  012A1826   XOR V1, T1, T2
1210:                
1211:                      draw_bgtile(vid, data_ptr[0], data_ptr[8], ppu.palette + 16 + col_high);
9D01A674  91130000   LBU S3, 0(T0)
9D01A678  91030008   LBU V1, 8(T0)
9D01A7E0  26731110   ADDIU S3, S3, 4368
9D01A7E4  24C76218   ADDIU A3, A2, 25112
9D01A7E8  0B40699D   J 0x9D01A674
9D01A7EC  00F33821   ADDU A3, A3, S3
1212:                      //draw_oamtile(vid, attrib, data_ptr[0], data_ptr[8], ppu.palette + 16 + col_high);
1213:                
1214:                      data_ptr++;
1215:                      vid += bmp->pitch;
9D01A724  8C830008   LW V1, 8(A0)
9D01A728  00431021   ADDU V0, V0, V1
1216:                   }
1217:                }
1218:                
1219:                void ppu_dumpoam(bitmap_t *bmp, int x_loc, int y_loc)
1220:                {
9D01A4B0  27BDFFE0   ADDIU SP, SP, -32
9D01A4B4  AFB5001C   SW S5, 28(SP)
9D01A4B8  AFB40018   SW S4, 24(SP)
9D01A4BC  AFB30014   SW S3, 20(SP)
9D01A4C0  AFB20010   SW S2, 16(SP)
9D01A4C4  AFB1000C   SW S1, 12(SP)
9D01A4C8  AFB00008   SW S0, 8(SP)
9D01A4CC  00A08021   ADDU S0, A1, ZERO
9D01A4D0  00C09021   ADDU S2, A2, ZERO
1221:                   int sprite, x_pos, y_pos, height;
1222:                   obj_t *spr_ptr;
1223:                
1224:                   spr_ptr = (obj_t *) ppu.oam;
9D01A4DC  3C0FA000   LUI T7, -24576
9D01A4E0  25EF7218   ADDIU T7, T7, 29208
1225:                   height = ppu.obj_height;
9D01A4D4  3C02A000   LUI V0, -24576
9D01A4D8  904C7394   LBU T4, 29588(V0)
1226:                
1227:                   for (sprite = 0; sprite < 64; sprite++)
9D01A4E4  0000C021   ADDU T8, ZERO, ZERO
9D01A504  3C11A000   LUI S1, -24576
9D01A508  26317318   ADDIU S1, S1, 29464
9D01A7C4  15F1FF51   BNE T7, S1, 0x9D01A50C
9D01A7C8  27180001   ADDIU T8, T8, 1
9D01A7CC  0B4069FC   J 0x9D01A7F0
9D01A7D0  8FB5001C   LW S5, 28(SP)
9D01A7D4  0B40696A   J 0x9D01A5A8
9D01A7D8  2443000A   ADDIU V1, V0, 10
1228:                   {
1229:                      x_pos = ((sprite & 0x0F) << 3) + (sprite & 0x0F) + x_loc;
9D01A50C  3302000F   ANDI V0, T8, 15
9D01A510  000240C0   SLL T0, V0, 3
9D01A514  00481021   ADDU V0, V0, T0
1230:                      if (height == 16)
9D01A4E8  24050010   ADDIU A1, ZERO, 16
9D01A518  15850006   BNE T4, A1, 0x9D01A534
9D01A51C  00504021   ADDU T0, V0, S0
1231:                         y_pos = (sprite & 0xF0) + (sprite >> 4) + y_loc;
9D01A520  330900F0   ANDI T1, T8, 240
9D01A524  00181103   SRA V0, T8, 4
9D01A528  01224821   ADDU T1, T1, V0
9D01A52C  0B406952   J 0x9D01A548
9D01A530  01324821   ADDU T1, T1, S2
1232:                      else
1233:                         y_pos = ((sprite & 0xF0) >> 1) + (sprite >> 4) + y_loc;
9D01A534  330900F0   ANDI T1, T8, 240
9D01A538  00094843   SRA T1, T1, 1
9D01A53C  00181103   SRA V0, T8, 4
9D01A540  01224821   ADDU T1, T1, V0
9D01A544  01324821   ADDU T1, T1, S2
1234:                
1235:                      draw_box(bmp, x_pos, y_pos, height);
1236:                
1237:                      if (spr_ptr->y_loc && spr_ptr->y_loc < 240)
9D01A5B4  91E20000   LBU V0, 0(T7)
9D01A5B8  2442FFFF   ADDIU V0, V0, -1
9D01A5BC  304200FF   ANDI V0, V0, 255
9D01A5C0  2C4200EF   SLTIU V0, V0, 239
9D01A5C4  5040005F   BEQL V0, ZERO, 0x9D01A744
9D01A5C8  2722BF14   ADDIU V0, T9, -16620
1238:                         draw_sprite(bmp, x_pos + 1, y_pos + 1, spr_ptr->tile, spr_ptr->atr);
9D01A5CC  91E30001   LBU V1, 1(T7)
9D01A5DC  25080001   ADDIU T0, T0, 1
1239:                      else
1240:                         draw_deadsprite(bmp, x_pos + 1, y_pos + 1, height);
9D01A768  25080001   ADDIU T0, T0, 1
1241:                
1242:                      spr_ptr++;
9D01A660  0B4069F1   J 0x9D01A7C4
9D01A664  25EF0004   ADDIU T7, T7, 4
9D01A73C  0B4069F1   J 0x9D01A7C4
9D01A740  25EF0004   ADDIU T7, T7, 4
9D01A7C0  25EF0004   ADDIU T7, T7, 4
1243:                   }
1244:                }
9D01A7F0  8FB40018   LW S4, 24(SP)
9D01A7F4  8FB30014   LW S3, 20(SP)
9D01A7F8  8FB20010   LW S2, 16(SP)
9D01A7FC  8FB1000C   LW S1, 12(SP)
9D01A800  8FB00008   LW S0, 8(SP)
9D01A804  03E00008   JR RA
9D01A808  27BD0020   ADDIU SP, SP, 32
1245:                
1246:                /* More of a debugging thing than anything else */
1247:                void ppu_dumppattern(bitmap_t *bmp, int table_num, int x_loc, int y_loc, int col)
1248:                {
9D01A80C  27BDFFF0   ADDIU SP, SP, -16
9D01A810  AFB2000C   SW S2, 12(SP)
9D01A814  AFB10008   SW S1, 8(SP)
9D01A818  AFB00004   SW S0, 4(SP)
1249:                   int x_tile, y_tile;
1250:                   uint8 *bmp_ptr, *data_ptr, *ptr;
1251:                   int tile_num, line;
1252:                   uint8 col_high;
1253:                
1254:                   tile_num = 0;
9D01A83C  0000C821   ADDU T9, ZERO, ZERO
1255:                   col_high = col << 2;
9D01A81C  8FA20020   LW V0, 32(SP)
9D01A820  00021080   SLL V0, V0, 2
9D01A824  304200FF   ANDI V0, V0, 255
1256:                
1257:                   for (y_tile = 0; y_tile < 16; y_tile++)
9D01A854  24110100   ADDIU S1, ZERO, 256
9D01A960  1731FFBD   BNE T9, S1, 0x9D01A858
9D01A964  26100020   ADDIU S0, S0, 32
1258:                   {
1259:                      /* Get our pointer to the bitmap */
1260:                      bmp_ptr = bmp->line[y_loc] + x_loc;
9D01A858  8E0D0000   LW T5, 0(S0)
9D01A85C  01A66821   ADDU T5, T5, A2
9D01A860  25AF0080   ADDIU T7, T5, 128
9D01A864  03207021   ADDU T6, T9, ZERO
1261:                
1262:                      for (x_tile = 0; x_tile < 16; x_tile++)
9D01A954  15AFFFC4   BNE T5, T7, 0x9D01A868
9D01A958  25CE0001   ADDIU T6, T6, 1
9D01A95C  27390010   ADDIU T9, T9, 16
1263:                      {
1264:                         data_ptr = &PPU_MEM((table_num << 12) + (tile_num << 4));
9D01A828  00052B00   SLL A1, A1, 12
9D01A82C  24E70004   ADDIU A3, A3, 4
9D01A830  00078080   SLL S0, A3, 2
9D01A834  00908021   ADDU S0, A0, S0
9D01A838  26100004   ADDIU S0, S0, 4
9D01A840  3C18A000   LUI T8, -24576
9D01A844  27186218   ADDIU T8, T8, 25112
9D01A868  000E4100   SLL T0, T6, 4
9D01A86C  00A84021   ADDU T0, A1, T0
9D01A870  00081283   SRA V0, T0, 10
9D01A874  24420448   ADDIU V0, V0, 1096
9D01A878  00021080   SLL V0, V0, 2
9D01A87C  00581021   ADDU V0, V0, T8
9D01A880  8C420000   LW V0, 0(V0)
9D01A884  00484021   ADDU T0, V0, T0
9D01A888  250C0008   ADDIU T4, T0, 8
9D01A88C  01A01021   ADDU V0, T5, ZERO
1265:                         ptr = bmp_ptr;
1266:                
1267:                         for (line = 0; line < 8; line ++)
9D01A948  150CFFD1   BNE T0, T4, 0x9D01A890
9D01A94C  00431021   ADDU V0, V0, V1
1268:                         {
1269:                            draw_bgtile(ptr, data_ptr[0], data_ptr[8], ppu.palette + col_high);
9D01A848  24421100   ADDIU V0, V0, 4352
9D01A84C  03023821   ADDU A3, T8, V0
9D01A890  91090000   LBU T1, 0(T0)
9D01A894  910A0008   LBU T2, 8(T0)
1270:                            data_ptr++;
9D01A940  25080001   ADDIU T0, T0, 1
1271:                            ptr += bmp->pitch;
9D01A944  8C830008   LW V1, 8(A0)
1272:                         }
1273:                
1274:                         bmp_ptr += 8;
9D01A950  25AD0008   ADDIU T5, T5, 8
1275:                         tile_num++;
1276:                      }
1277:                      y_loc += 8;
1278:                   }
1279:                }
9D01A968  8FB2000C   LW S2, 12(SP)
9D01A96C  8FB10008   LW S1, 8(SP)
9D01A970  8FB00004   LW S0, 4(SP)
9D01A974  03E00008   JR RA
9D01A978  27BD0010   ADDIU SP, SP, 16
1280:                
1281:                /*
1282:                ** $Log: nes_ppu.c,v $
1283:                ** Revision 1.2  2001/04/27 14:37:11  neil
1284:                ** wheeee
1285:                **
1286:                ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
1287:                ** initial
1288:                **
1289:                ** Revision 1.14  2000/11/29 12:58:23  matt
1290:                ** timing/fiq fixes
1291:                **
1292:                ** Revision 1.13  2000/11/27 19:36:15  matt
1293:                ** more timing fixes
1294:                **
1295:                ** Revision 1.12  2000/11/26 15:51:13  matt
1296:                ** frame IRQ emulation
1297:                **
1298:                ** Revision 1.11  2000/11/25 20:30:39  matt
1299:                ** scanline emulation simplifications/timing fixes
1300:                **
1301:                ** Revision 1.10  2000/11/24 14:56:02  matt
1302:                ** fixed a long-standing sprite 0 strike bug
1303:                **
1304:                ** Revision 1.9  2000/11/20 13:23:17  matt
1305:                ** PPU fixes
1306:                **
1307:                ** Revision 1.8  2000/11/19 13:47:30  matt
1308:                ** problem with frame irqs fixed
1309:                **
1310:                ** Revision 1.7  2000/11/19 13:40:19  matt
1311:                ** more accurate ppu behavior
1312:                **
1313:                ** Revision 1.6  2000/11/14 12:09:37  matt
1314:                ** only generate the palette once, please
1315:                **
1316:                ** Revision 1.5  2000/11/11 14:51:43  matt
1317:                ** context get/set fixed
1318:                **
1319:                ** Revision 1.4  2000/11/09 12:35:50  matt
1320:                ** fixed timing problem with VRAM reads/writes
1321:                **
1322:                ** Revision 1.3  2000/11/05 16:35:41  matt
1323:                ** rolled rgb.h into bitmap.h
1324:                **
1325:                ** Revision 1.2  2000/10/27 12:55:03  matt
1326:                ** palette generating functions now take *this pointers
1327:                **
1328:                ** Revision 1.1  2000/10/24 12:20:28  matt
1329:                ** changed directory structure
1330:                **
1331:                ** Revision 1.33  2000/10/23 15:53:08  matt
1332:                ** better system handling
1333:                **
1334:                ** Revision 1.32  2000/10/22 15:02:32  matt
1335:                ** simplified mirroring
1336:                **
1337:                ** Revision 1.31  2000/10/21 21:36:04  matt
1338:                ** ppu cleanups / fixes
1339:                **
1340:                ** Revision 1.30  2000/10/21 19:26:59  matt
1341:                ** many more cleanups
1342:                **
1343:                ** Revision 1.29  2000/10/10 13:58:15  matt
1344:                ** stroustrup squeezing his way in the door
1345:                **
1346:                ** Revision 1.28  2000/10/08 17:54:32  matt
1347:                ** reject VRAM access out of VINT period
1348:                **
1349:                ** Revision 1.27  2000/09/15 04:58:07  matt
1350:                ** simplifying and optimizing APU core
1351:                **
1352:                ** Revision 1.26  2000/09/08 11:57:29  matt
1353:                ** no more nes_fiq
1354:                **
1355:                ** Revision 1.25  2000/09/07 21:57:31  matt
1356:                ** api change
1357:                **
1358:                ** Revision 1.24  2000/07/31 04:27:59  matt
1359:                ** one million cleanups
1360:                **
1361:                ** Revision 1.23  2000/07/30 06:13:12  matt
1362:                ** default to no FIQs on startup
1363:                **
1364:                ** Revision 1.22  2000/07/30 04:32:32  matt
1365:                ** emulation of the NES frame IRQ
1366:                **
1367:                ** Revision 1.21  2000/07/25 02:25:53  matt
1368:                ** safer xxx_destroy calls
1369:                **
1370:                ** Revision 1.20  2000/07/23 15:12:43  matt
1371:                ** removed unused variables, changed INLINE
1372:                **
1373:                ** Revision 1.19  2000/07/21 04:50:39  matt
1374:                ** moved palette calls out of nofrendo.c and into ppu_create
1375:                **
1376:                ** Revision 1.18  2000/07/17 05:12:55  matt
1377:                ** nes_ppu.c is no longer a scary place to be-- cleaner & faster
1378:                **
1379:                ** Revision 1.17  2000/07/17 01:52:28  matt
1380:                ** made sure last line of all source files is a newline
1381:                **
1382:                ** Revision 1.16  2000/07/11 04:42:39  matt
1383:                ** updated for new screen dimension defines
1384:                **
1385:                ** Revision 1.15  2000/07/10 19:10:16  matt
1386:                ** should bomb out now if a game tries to write to VROM
1387:                **
1388:                ** Revision 1.14  2000/07/10 05:28:30  matt
1389:                ** moved joypad/oam dma from apu to ppu
1390:                **
1391:                ** Revision 1.13  2000/07/10 03:03:16  matt
1392:                ** added ppu_getcontext() routine
1393:                **
1394:                ** Revision 1.12  2000/07/09 03:46:05  matt
1395:                ** using pitch instead of width...
1396:                **
1397:                ** Revision 1.11  2000/07/06 16:42:40  matt
1398:                ** better palette setting interface
1399:                **
1400:                ** Revision 1.10  2000/07/05 22:49:25  matt
1401:                ** changed mmc2 (punchout) tile-access switching
1402:                **
1403:                ** Revision 1.9  2000/07/04 23:13:26  matt
1404:                ** added an irq line drawing debug feature hack
1405:                **
1406:                ** Revision 1.8  2000/06/26 04:58:08  matt
1407:                ** accuracy changes
1408:                **
1409:                ** Revision 1.7  2000/06/22 02:13:49  matt
1410:                ** more accurate emulation of $2002
1411:                **
1412:                ** Revision 1.6  2000/06/20 20:42:47  matt
1413:                ** accuracy changes
1414:                **
1415:                ** Revision 1.5  2000/06/20 00:05:12  matt
1416:                ** tested and verified STAT quirk, added code
1417:                **
1418:                ** Revision 1.4  2000/06/09 15:12:26  matt
1419:                ** initial revision
1420:                **
1421:                */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/nes/nes_pal.c  -----------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** nes_pal.c
21:                  **
22:                  ** NES RGB palette
23:                  ** $Id: nes_pal.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <math.h>
27:                  #include <noftypes.h>
28:                  #include <bitmap.h>
29:                  #include <nes_pal.h>
30:                  
31:                  #ifndef PI
32:                  #define PI 3.1415926535897932384626433832795
33:                  #endif
34:                  
35:                  /* my NES palette, converted to RGB */
36:                  rgb_t shady_palette[] =
37:                  {
38:                     {0x80,0x80,0x80}, {0x00,0x00,0xBB}, {0x37,0x00,0xBF}, {0x84,0x00,0xA6},
39:                     {0xBB,0x00,0x6A}, {0xB7,0x00,0x1E}, {0xB3,0x00,0x00}, {0x91,0x26,0x00},
40:                     {0x7B,0x2B,0x00}, {0x00,0x3E,0x00}, {0x00,0x48,0x0D}, {0x00,0x3C,0x22},
41:                     {0x00,0x2F,0x66}, {0x00,0x00,0x00}, {0x05,0x05,0x05}, {0x05,0x05,0x05},
42:                  
43:                     {0xC8,0xC8,0xC8}, {0x00,0x59,0xFF}, {0x44,0x3C,0xFF}, {0xB7,0x33,0xCC},
44:                     {0xFF,0x33,0xAA}, {0xFF,0x37,0x5E}, {0xFF,0x37,0x1A}, {0xD5,0x4B,0x00},
45:                     {0xC4,0x62,0x00}, {0x3C,0x7B,0x00}, {0x1E,0x84,0x15}, {0x00,0x95,0x66},
46:                     {0x00,0x84,0xC4}, {0x11,0x11,0x11}, {0x09,0x09,0x09}, {0x09,0x09,0x09},
47:                  
48:                     {0xFF,0xFF,0xFF}, {0x00,0x95,0xFF}, {0x6F,0x84,0xFF}, {0xD5,0x6F,0xFF},
49:                     {0xFF,0x77,0xCC}, {0xFF,0x6F,0x99}, {0xFF,0x7B,0x59}, {0xFF,0x91,0x5F},
50:                     {0xFF,0xA2,0x33}, {0xA6,0xBF,0x00}, {0x51,0xD9,0x6A}, {0x4D,0xD5,0xAE},
51:                     {0x00,0xD9,0xFF}, {0x66,0x66,0x66}, {0x0D,0x0D,0x0D}, {0x0D,0x0D,0x0D},
52:                  
53:                     {0xFF,0xFF,0xFF}, {0x84,0xBF,0xFF}, {0xBB,0xBB,0xFF}, {0xD0,0xBB,0xFF},
54:                     {0xFF,0xBF,0xEA}, {0xFF,0xBF,0xCC}, {0xFF,0xC4,0xB7}, {0xFF,0xCC,0xAE},
55:                     {0xFF,0xD9,0xA2}, {0xCC,0xE1,0x99}, {0xAE,0xEE,0xB7}, {0xAA,0xF7,0xEE},
56:                     {0xB3,0xEE,0xFF}, {0xDD,0xDD,0xDD}, {0x11,0x11,0x11}, {0x11,0x11,0x11}
57:                  };
58:                  
59:                  /* dynamic palette building routines,
60:                  ** care of Kevin Horton (khorton@iquest.net)
61:                  */
62:                  
63:                  /* our global palette */
64:                  rgb_t nes_palette[64];
65:                  
66:                  
67:                  static float hue = 334.0f;
68:                  static float tint = 0.4f;
69:                  
70:                  #include <gui.h>
71:                  
72:                  void pal_dechue(void)
73:                  {
9D030F6C  27BDFFE8   ADDIU SP, SP, -24
9D030F70  AFBF0014   SW RA, 20(SP)
74:                     hue -= 0.5f;
9D030F74  8F848014   LW A0, -32748(GP)
9D030F78  3C029D04   LUI V0, -25340
9D030F7C  0F40D22B   JAL __subsf3
9D030F80  8C45A27C   LW A1, -23940(V0)
9D030F84  AF828014   SW V0, -32748(GP)
75:                     gui_sendmsg(GUI_GREEN, "hue: %.02f", hue);
9D030F88  240400C6   ADDIU A0, ZERO, 198
9D030F8C  3C059D04   LUI A1, -25340
9D030F90  24A5A1D0   ADDIU A1, A1, -24112
9D030F94  0F409253   JAL gui_sendmsg
9D030F98  00403021   ADDU A2, V0, ZERO
76:                     pal_generate();
9D030F9C  0F40C32A   JAL pal_generate
9D030FA0  00000000   NOP
77:                  }
9D030FA4  8FBF0014   LW RA, 20(SP)
9D030FA8  03E00008   JR RA
9D030FAC  27BD0018   ADDIU SP, SP, 24
78:                  void pal_inchue(void)
79:                  {
9D030FB0  27BDFFE8   ADDIU SP, SP, -24
9D030FB4  AFBF0014   SW RA, 20(SP)
80:                     hue += 0.5f;
9D030FB8  8F848014   LW A0, -32748(GP)
9D030FBC  3C029D04   LUI V0, -25340
9D030FC0  0F40D22D   JAL fpadd
9D030FC4  8C45A27C   LW A1, -23940(V0)
9D030FC8  AF828014   SW V0, -32748(GP)
81:                     gui_sendmsg(GUI_GREEN, "hue: %.02f", hue);
9D030FCC  240400C6   ADDIU A0, ZERO, 198
9D030FD0  3C059D04   LUI A1, -25340
9D030FD4  24A5A1D0   ADDIU A1, A1, -24112
9D030FD8  0F409253   JAL gui_sendmsg
9D030FDC  00403021   ADDU A2, V0, ZERO
82:                     pal_generate();
9D030FE0  0F40C32A   JAL pal_generate
9D030FE4  00000000   NOP
83:                  }
9D030FE8  8FBF0014   LW RA, 20(SP)
9D030FEC  03E00008   JR RA
9D030FF0  27BD0018   ADDIU SP, SP, 24
84:                  void pal_dectint(void)
85:                  {
9D030FF4  27BDFFE8   ADDIU SP, SP, -24
9D030FF8  AFBF0014   SW RA, 20(SP)
86:                     tint -= 0.01f;
9D030FFC  8F848010   LW A0, -32752(GP)
9D031000  3C029D04   LUI V0, -25340
9D031004  0F40D22B   JAL __subsf3
9D031008  8C45A280   LW A1, -23936(V0)
9D03100C  AF828010   SW V0, -32752(GP)
87:                     gui_sendmsg(GUI_GREEN, "tint: %.02f", tint);
9D031010  240400C6   ADDIU A0, ZERO, 198
9D031014  3C059D04   LUI A1, -25340
9D031018  24A5A1DC   ADDIU A1, A1, -24100
9D03101C  0F409253   JAL gui_sendmsg
9D031020  00403021   ADDU A2, V0, ZERO
88:                     pal_generate();
9D031024  0F40C32A   JAL pal_generate
9D031028  00000000   NOP
89:                  }
9D03102C  8FBF0014   LW RA, 20(SP)
9D031030  03E00008   JR RA
9D031034  27BD0018   ADDIU SP, SP, 24
90:                  void pal_inctint(void)
91:                  {
9D031038  27BDFFE8   ADDIU SP, SP, -24
9D03103C  AFBF0014   SW RA, 20(SP)
92:                     tint += 0.01f;
9D031040  8F848010   LW A0, -32752(GP)
9D031044  3C029D04   LUI V0, -25340
9D031048  0F40D22D   JAL fpadd
9D03104C  8C45A280   LW A1, -23936(V0)
9D031050  AF828010   SW V0, -32752(GP)
93:                     gui_sendmsg(GUI_GREEN, "tint: %.02f", tint);
9D031054  240400C6   ADDIU A0, ZERO, 198
9D031058  3C059D04   LUI A1, -25340
9D03105C  24A5A1DC   ADDIU A1, A1, -24100
9D031060  0F409253   JAL gui_sendmsg
9D031064  00403021   ADDU A2, V0, ZERO
94:                     pal_generate();
9D031068  0F40C32A   JAL pal_generate
9D03106C  00000000   NOP
95:                  }
9D031070  8FBF0014   LW RA, 20(SP)
9D031074  03E00008   JR RA
9D031078  27BD0018   ADDIU SP, SP, 24
96:                  
97:                  static const float brightness[4][4] = 
98:                  {
99:                     { 0.50f, 0.75f, 1.00f, 1.00f },
100:                    { 0.29f, 0.45f, 0.73f, 0.90f },
101:                    { 0.00f, 0.24f, 0.47f, 0.77f },
102:                    { 0.02f, 0.04f, 0.05f, 0.07f }
103:                 };
104:                 
105:                 static const int col_angles[16] =
106:                 {
107:                    0, 240, 210, 180, 150, 120, 90, 60, 30, 0, 330, 300, 270, 0, 0, 0
108:                 };
109:                 
110:                 void pal_generate(void)
111:                 {
9D030CA8  27BDFFB8   ADDIU SP, SP, -72
9D030CAC  AFBF0044   SW RA, 68(SP)
9D030CB0  AFBE0040   SW FP, 64(SP)
9D030CB4  AFB7003C   SW S7, 60(SP)
9D030CB8  AFB60038   SW S6, 56(SP)
9D030CBC  AFB50034   SW S5, 52(SP)
9D030CC0  AFB40030   SW S4, 48(SP)
9D030CC4  AFB3002C   SW S3, 44(SP)
9D030CC8  AFB20028   SW S2, 40(SP)
9D030CCC  AFB10024   SW S1, 36(SP)
9D030CD0  AFB00020   SW S0, 32(SP)
112:                    int x, z;
113:                    float s, y, theta;
114:                    int r, g, b;
115:                 
116:                    for (x = 0; x < 4; x++)
9D030CF0  AFA00018   SW ZERO, 24(SP)
9D030CF4  0B40C3C4   J 0x9D030F10
9D030CF8  241500FF   ADDIU S5, ZERO, 255
9D030EF0  8FA20018   LW V0, 24(SP)
9D030EF4  24420001   ADDIU V0, V0, 1
9D030EF8  AFA20018   SW V0, 24(SP)
9D030EFC  8FA30010   LW V1, 16(SP)
9D030F00  24630004   ADDIU V1, V1, 4
9D030F04  24040004   ADDIU A0, ZERO, 4
9D030F08  1044000C   BEQ V0, A0, 0x9D030F3C
9D030F0C  AFA30010   SW V1, 16(SP)
9D030F10  3C029D04   LUI V0, -25340
9D030F14  2454A1E8   ADDIU S4, V0, -24088
9D030F18  8FA30018   LW V1, 24(SP)
9D030F1C  00038980   SLL S1, V1, 6
9D030F20  00031200   SLL V0, V1, 8
9D030F24  00518823   SUBU S1, V0, S1
9D030F28  3C04A000   LUI A0, -24576
9D030F2C  248405D8   ADDIU A0, A0, 1496
9D030F30  00918821   ADDU S1, A0, S1
117:                    {
118:                       for (z = 0; z < 16; z++)
9D030EDC  26100001   ADDIU S0, S0, 1
9D030EE0  26940004   ADDIU S4, S4, 4
9D030EE4  24040010   ADDIU A0, ZERO, 16
9D030EE8  1604FF84   BNE S0, A0, 0x9D030CFC
9D030EEC  2631000C   ADDIU S1, S1, 12
119:                       {
120:                          switch (z)
9D030CFC  2404000D   ADDIU A0, ZERO, 13
9D030D00  1204000E   BEQ S0, A0, 0x9D030D3C
9D030D04  2A02000E   SLTI V0, S0, 14
9D030D08  10400005   BEQ V0, ZERO, 0x9D030D20
9D030D0C  2A020010   SLTI V0, S0, 16
9D030D10  12000007   BEQ S0, ZERO, 0x9D030D30
9D030D14  8FA20010   LW V0, 16(SP)
9D030D20  5440000A   BNEL V0, ZERO, 0x9D030D4C
9D030D24  8FA40010   LW A0, 16(SP)
121:                          {
122:                          case 0:
123:                             /* is color $x0?  If so, get luma */
124:                             s = 0;
125:                             y = brightness[0][x];
9D030D30  8C530000   LW S3, 0(V0)
126:                             break;
9D030D34  0B40C358   J 0x9D030D60
9D030D38  00009021   ADDU S2, ZERO, ZERO
127:                 
128:                          case 13:
129:                             /* is color $xD?  If so, get luma */
130:                             s = 0;
131:                             y = brightness[2][x];
9D030D3C  8FA30010   LW V1, 16(SP)
9D030D40  8C730020   LW S3, 32(V1)
132:                             break;
9D030D44  0B40C358   J 0x9D030D60
9D030D48  00009021   ADDU S2, ZERO, ZERO
133:                 
134:                          case 14:
135:                          case 15:
136:                             /* is color $xE/F?  If so, set to black */
137:                             s = 0;
138:                             y = brightness[3][x];
9D030D4C  8C930030   LW S3, 48(A0)
139:                             
140:                             break;
9D030D50  0B40C358   J 0x9D030D60
9D030D54  00009021   ADDU S2, ZERO, ZERO
141:                 
142:                          default:
143:                             s = tint;                  /* grab tint */
9D030CD4  8F828010   LW V0, -32752(GP)
9D030CD8  AFA2001C   SW V0, 28(SP)
9D030D5C  8FB2001C   LW S2, 28(SP)
144:                             y = brightness[1][x];      /* grab default luminance */
9D030D18  0B40C357   J 0x9D030D5C
9D030D1C  8C530010   LW S3, 16(V0)
9D030D28  0B40C356   J 0x9D030D58
9D030D2C  8FA20010   LW V0, 16(SP)
9D030D58  8C530010   LW S3, 16(V0)
145:                             break;
146:                          }
147:                 
148:                          theta = (float) (PI * ((col_angles[z] + hue) / 180.0));
9D030CDC  8F838014   LW V1, -32748(GP)
9D030CE0  AFA30014   SW V1, 20(SP)
9D030CE4  3C029D04   LUI V0, -25340
9D030CE8  2442A228   ADDIU V0, V0, -24024
9D030CEC  AFA20010   SW V0, 16(SP)
9D030D60  0F40EEE7   JAL sitofp
9D030D64  8E840000   LW A0, 0(S4)
9D030D68  00402021   ADDU A0, V0, ZERO
9D030D6C  0F40D22D   JAL fpadd
9D030D70  8FA50014   LW A1, 20(SP)
9D030D74  00402021   ADDU A0, V0, ZERO
9D030D78  3C039D04   LUI V1, -25340
9D030D7C  2463A268   ADDIU V1, V1, -23960
9D030D80  0F40D475   JAL __divsf3
9D030D84  8C650000   LW A1, 0(V1)
9D030D88  00402021   ADDU A0, V0, ZERO
9D030D8C  3C029D04   LUI V0, -25340
9D030D90  2442A26C   ADDIU V0, V0, -23956
9D030D94  0F40D795   JAL __mulsf3
9D030D98  8C450000   LW A1, 0(V0)
9D030D9C  0040F021   ADDU FP, V0, ZERO
149:                 
150:                          r = (int) (256.0 * (y + s * sin(theta)));
9D030DA0  0F40E0B3   JAL fpsin, sinf
9D030DA4  00402021   ADDU A0, V0, ZERO
9D030DA8  0040B021   ADDU S6, V0, ZERO
9D030DAC  00402021   ADDU A0, V0, ZERO
9D030DB0  0F40D795   JAL __mulsf3
9D030DB4  02402821   ADDU A1, S2, ZERO
9D030DB8  00402021   ADDU A0, V0, ZERO
9D030DBC  0F40D22D   JAL fpadd
9D030DC0  02602821   ADDU A1, S3, ZERO
9D030DC4  00402021   ADDU A0, V0, ZERO
9D030DC8  3C039D04   LUI V1, -25340
9D030DCC  2463A270   ADDIU V1, V1, -23952
9D030DD0  0F40D795   JAL __mulsf3
9D030DD4  8C650000   LW A1, 0(V1)
9D030DD8  0F40ECBC   JAL __fixsfsi
9D030DDC  00402021   ADDU A0, V0, ZERO
9D030DE0  0040B821   ADDU S7, V0, ZERO
151:                          g = (int) (256.0 * (y - ((27 / 53.0) * s * sin(theta)) + ((10 / 53.0) * s * cos(theta))));
9D030DE4  0F40E140   JAL fpcos, cosf
9D030DE8  03C02021   ADDU A0, FP, ZERO
9D030DEC  0040F021   ADDU FP, V0, ZERO
9D030DF0  02402021   ADDU A0, S2, ZERO
9D030DF4  3C029D04   LUI V0, -25340
9D030DF8  2442A274   ADDIU V0, V0, -23948
9D030DFC  0F40D795   JAL __mulsf3
9D030E00  8C450000   LW A1, 0(V0)
9D030E04  02C02021   ADDU A0, S6, ZERO
9D030E08  0F40D795   JAL __mulsf3
9D030E0C  00402821   ADDU A1, V0, ZERO
9D030E10  02602021   ADDU A0, S3, ZERO
9D030E14  0F40D22B   JAL __subsf3
9D030E18  00402821   ADDU A1, V0, ZERO
9D030E1C  0040B021   ADDU S6, V0, ZERO
9D030E20  02402021   ADDU A0, S2, ZERO
9D030E24  3C039D04   LUI V1, -25340
9D030E28  2463A278   ADDIU V1, V1, -23944
9D030E2C  0F40D795   JAL __mulsf3
9D030E30  8C650000   LW A1, 0(V1)
9D030E34  00402021   ADDU A0, V0, ZERO
9D030E38  0F40D795   JAL __mulsf3
9D030E3C  03C02821   ADDU A1, FP, ZERO
9D030E40  02C02021   ADDU A0, S6, ZERO
9D030E44  0F40D22D   JAL fpadd
9D030E48  00402821   ADDU A1, V0, ZERO
9D030E4C  00402021   ADDU A0, V0, ZERO
9D030E50  3C029D04   LUI V0, -25340
9D030E54  2442A270   ADDIU V0, V0, -23952
9D030E58  0F40D795   JAL __mulsf3
9D030E5C  8C450000   LW A1, 0(V0)
9D030E60  0F40ECBC   JAL __fixsfsi
9D030E64  00402021   ADDU A0, V0, ZERO
9D030E68  0040B021   ADDU S6, V0, ZERO
152:                          b = (int) (256.0 * (y - (s * cos(theta))));
9D030E6C  02402021   ADDU A0, S2, ZERO
9D030E70  0F40D795   JAL __mulsf3
9D030E74  03C02821   ADDU A1, FP, ZERO
9D030E78  02602021   ADDU A0, S3, ZERO
9D030E7C  0F40D22B   JAL __subsf3
9D030E80  00402821   ADDU A1, V0, ZERO
9D030E84  00402021   ADDU A0, V0, ZERO
9D030E88  3C039D04   LUI V1, -25340
9D030E8C  2463A270   ADDIU V1, V1, -23952
9D030E90  0F40D795   JAL __mulsf3
9D030E94  8C650000   LW A1, 0(V1)
9D030E98  0F40ECBC   JAL __fixsfsi
9D030E9C  00402021   ADDU A0, V0, ZERO
9D030EA0  2AE30000   SLTI V1, S7, 0
9D030EA4  0003B80B   MOVN S7, ZERO, V1
9D030EA8  2AC30000   SLTI V1, S6, 0
9D030EAC  0003B00B   MOVN S6, ZERO, V1
9D030EB0  28430000   SLTI V1, V0, 0
9D030EB4  0003100B   MOVN V0, ZERO, V1
9D030EB8  2AE30100   SLTI V1, S7, 256
9D030EBC  02A3B80A   MOVZ S7, S5, V1
153:                 
154:                          if (r > 255)
155:                             r = 255;
156:                          else if (r < 0)
157:                             r = 0;
158:                 
159:                          if (g > 255)
160:                             g = 255;
161:                          else if (g < 0)
162:                             g = 0;
163:                 
164:                          if (b > 255)
165:                             b = 255;
166:                          else if (b < 0)
167:                             b = 0;
168:                 
169:                          nes_palette[(x << 4) + z].r = r;
9D030EC0  AE370000   SW S7, 0(S1)
9D030EC4  2AC30100   SLTI V1, S6, 256
9D030EC8  02A3B00A   MOVZ S6, S5, V1
9D030F34  0B40C33F   J 0x9D030CFC
9D030F38  00008021   ADDU S0, ZERO, ZERO
170:                          nes_palette[(x << 4) + z].g = g;
9D030ECC  AE360004   SW S6, 4(S1)
9D030ED0  28430100   SLTI V1, V0, 256
9D030ED4  02A3100A   MOVZ V0, S5, V1
171:                          nes_palette[(x << 4) + z].b = b;
9D030ED8  AE220008   SW V0, 8(S1)
172:                       }
173:                    }   
174:                 }
9D030F3C  8FBF0044   LW RA, 68(SP)
9D030F40  8FBE0040   LW FP, 64(SP)
9D030F44  8FB7003C   LW S7, 60(SP)
9D030F48  8FB60038   LW S6, 56(SP)
9D030F4C  8FB50034   LW S5, 52(SP)
9D030F50  8FB40030   LW S4, 48(SP)
9D030F54  8FB3002C   LW S3, 44(SP)
9D030F58  8FB20028   LW S2, 40(SP)
9D030F5C  8FB10024   LW S1, 36(SP)
9D030F60  8FB00020   LW S0, 32(SP)
9D030F64  03E00008   JR RA
9D030F68  27BD0048   ADDIU SP, SP, 72
175:                 
176:                 /*
177:                 ** $Log: nes_pal.c,v $
178:                 ** Revision 1.2  2001/04/27 14:37:11  neil
179:                 ** wheeee
180:                 **
181:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
182:                 ** initial
183:                 **
184:                 ** Revision 1.3  2000/11/06 02:17:18  matt
185:                 ** no more double->float warnings
186:                 **
187:                 ** Revision 1.2  2000/11/05 16:35:41  matt
188:                 ** rolled rgb.h into bitmap.h
189:                 **
190:                 ** Revision 1.1  2000/10/24 12:20:28  matt
191:                 ** changed directory structure
192:                 **
193:                 ** Revision 1.9  2000/07/17 01:52:28  matt
194:                 ** made sure last line of all source files is a newline
195:                 **
196:                 ** Revision 1.8  2000/07/10 13:49:31  matt
197:                 ** renamed my palette and extern'ed it
198:                 **
199:                 ** Revision 1.7  2000/06/26 04:59:13  matt
200:                 ** selectable tint/hue hack (just for the time being)
201:                 **
202:                 ** Revision 1.6  2000/06/21 21:48:19  matt
203:                 ** changed range multiplier from 255.0 to 256.0
204:                 **
205:                 ** Revision 1.5  2000/06/20 20:42:47  matt
206:                 ** accuracy changes
207:                 **
208:                 ** Revision 1.4  2000/06/09 15:12:26  matt
209:                 ** initial revision
210:                 **
211:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/nes/nes_mmc.c  -----------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** nes_mmc.c
21:                  **
22:                  ** NES Memory Management Controller (mapper) emulation
23:                  ** $Id: nes_mmc.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <string.h>
27:                  #include <noftypes.h>
28:                  #include "nes6502.h"
29:                  #include <nes_mmc.h>
30:                  #include <nes_ppu.h>
31:                  #include <libsnss.h>
32:                  #include <log.h>
33:                  #include <mmclist.h>
34:                  #include <nes_rom.h>
35:                  
36:                  #define  MMC_8KROM         (mmc.cart->rom_banks * 2)
37:                  #define  MMC_16KROM        (mmc.cart->rom_banks)
38:                  #define  MMC_32KROM        (mmc.cart->rom_banks / 2)
39:                  #define  MMC_8KVROM        (mmc.cart->vrom_banks)
40:                  #define  MMC_4KVROM        (mmc.cart->vrom_banks * 2)
41:                  #define  MMC_2KVROM        (mmc.cart->vrom_banks * 4)
42:                  #define  MMC_1KVROM        (mmc.cart->vrom_banks * 8)
43:                  
44:                  #define  MMC_LAST8KROM     (MMC_8KROM - 1)
45:                  #define  MMC_LAST16KROM    (MMC_16KROM - 1)
46:                  #define  MMC_LAST32KROM    (MMC_32KROM - 1)
47:                  #define  MMC_LAST8KVROM    (MMC_8KVROM - 1)
48:                  #define  MMC_LAST4KVROM    (MMC_4KVROM - 1)
49:                  #define  MMC_LAST2KVROM    (MMC_2KVROM - 1)
50:                  #define  MMC_LAST1KVROM    (MMC_1KVROM - 1)
51:                  
52:                  static mmc_t mmc;
53:                  
54:                  rominfo_t *mmc_getinfo(void)
55:                  {
56:                     return mmc.cart;
57:                  }
9D02D03C  03E00008   JR RA
9D02D040  8F8280F4   LW V0, -32524(GP)
58:                  
59:                  void mmc_setcontext(mmc_t *src_mmc)
60:                  {
61:                     ASSERT(src_mmc);
62:                  
63:                     mmc = *src_mmc;
9D02D044  8C830000   LW V1, 0(A0)
9D02D048  8C820004   LW V0, 4(A0)
9D02D04C  AF8380F0   SW V1, -32528(GP)
9D02D050  03E00008   JR RA
9D02D054  AF8280F4   SW V0, -32524(GP)
64:                  }
65:                  
66:                  void mmc_getcontext(mmc_t *dest_mmc)
67:                  {
68:                     *dest_mmc = mmc;
9D02D058  8F8280F0   LW V0, -32528(GP)
9D02D05C  AC820000   SW V0, 0(A0)
9D02D060  8F8280F4   LW V0, -32524(GP)
9D02D064  03E00008   JR RA
9D02D068  AC820004   SW V0, 4(A0)
69:                  }
70:                  
71:                  /* VROM bankswitching */
72:                  void mmc_bankvrom(int size, uint32 address, int bank)
73:                  {
9D02D06C  27BDFFE8   ADDIU SP, SP, -24
9D02D070  AFBF0014   SW RA, 20(SP)
9D02D074  00801021   ADDU V0, A0, ZERO
74:                     if (0 == mmc.cart->vrom_banks)
9D02D078  8F8480F4   LW A0, -32524(GP)
9D02D07C  8C830014   LW V1, 20(A0)
9D02D080  10600055   BEQ V1, ZERO, .LVL31
9D02D084  24070002   ADDIU A3, ZERO, 2
75:                        return;
76:                  
77:                     switch (size)
9D02D088  10470020   BEQ V0, A3, 0x9D02D10C
9D02D08C  28470003   SLTI A3, V0, 3
9D02D090  10E00006   BEQ A3, ZERO, 0x9D02D0AC
9D02D094  24070004   ADDIU A3, ZERO, 4
9D02D098  24070001   ADDIU A3, ZERO, 1
9D02D09C  5047000A   BEQL V0, A3, 0x9D02D0C8
9D02D0A0  2402FFFF   ADDIU V0, ZERO, -1
9D02D0AC  50470029   BEQL V0, A3, 0x9D02D154
9D02D0B0  2402FFFF   ADDIU V0, ZERO, -1
9D02D0B4  24050008   ADDIU A1, ZERO, 8
9D02D0B8  50450037   BEQL V0, A1, 0x9D02D198
9D02D0BC  2462FFFF   ADDIU V0, V1, -1
78:                     {
79:                     case 1:
80:                        if (bank == MMC_LASTBANK)
9D02D0C8  54C20004   BNEL A2, V0, 0x9D02D0DC
9D02D0CC  000318C0   SLL V1, V1, 3
81:                           bank = MMC_LAST1KVROM;
9D02D0D0  000330C0   SLL A2, V1, 3
9D02D0D4  24C6FFFF   ADDIU A2, A2, -1
82:                        ppu_setpage(1, address >> 10, &mmc.cart->vrom[(bank % MMC_1KVROM) << 10] - address);
9D02D0D8  000318C0   SLL V1, V1, 3
9D02D0DC  00C3001A   DIV A2, V1
9D02D0E0  006001F4   TEQ V1, ZERO
9D02D0E4  00001010   MFHI V0
9D02D0E8  00021A80   SLL V1, V0, 10
9D02D0EC  00651823   SUBU V1, V1, A1
9D02D0F0  8C860004   LW A2, 4(A0)
9D02D0F4  24040001   ADDIU A0, ZERO, 1
9D02D0F8  00052A82   SRL A1, A1, 10
9D02D0FC  0F406314   JAL ppu_setpage
9D02D100  00C33021   ADDU A2, A2, V1
83:                        break;
9D02D104  0B40B477   J 0x9D02D1DC
9D02D108  8FBF0014   LW RA, 20(SP)
84:                  
85:                     case 2:
86:                        if (bank == MMC_LASTBANK)
9D02D10C  2402FFFF   ADDIU V0, ZERO, -1
9D02D110  54C20004   BNEL A2, V0, 0x9D02D124
9D02D114  00031880   SLL V1, V1, 2
87:                           bank = MMC_LAST2KVROM;
9D02D118  00033080   SLL A2, V1, 2
9D02D11C  24C6FFFF   ADDIU A2, A2, -1
88:                        ppu_setpage(2, address >> 10, &mmc.cart->vrom[(bank % MMC_2KVROM) << 11] - address);
9D02D120  00031880   SLL V1, V1, 2
9D02D124  00C3001A   DIV A2, V1
9D02D128  006001F4   TEQ V1, ZERO
9D02D12C  00001010   MFHI V0
9D02D130  00021AC0   SLL V1, V0, 11
9D02D134  00651823   SUBU V1, V1, A1
9D02D138  8C860004   LW A2, 4(A0)
9D02D13C  24040002   ADDIU A0, ZERO, 2
9D02D140  00052A82   SRL A1, A1, 10
9D02D144  0F406314   JAL ppu_setpage
9D02D148  00C33021   ADDU A2, A2, V1
89:                        break;
9D02D14C  0B40B477   J 0x9D02D1DC
9D02D150  8FBF0014   LW RA, 20(SP)
90:                  
91:                     case 4:
92:                        if (bank == MMC_LASTBANK)
9D02D154  54C20004   BNEL A2, V0, 0x9D02D168
9D02D158  00031840   SLL V1, V1, 1
93:                           bank = MMC_LAST4KVROM;
9D02D15C  00033040   SLL A2, V1, 1
9D02D160  24C6FFFF   ADDIU A2, A2, -1
94:                        ppu_setpage(4, address >> 10, &mmc.cart->vrom[(bank % MMC_4KVROM) << 12] - address);
9D02D164  00031840   SLL V1, V1, 1
9D02D168  00C3001A   DIV A2, V1
9D02D16C  006001F4   TEQ V1, ZERO
9D02D170  00001010   MFHI V0
9D02D174  00021B00   SLL V1, V0, 12
9D02D178  00651823   SUBU V1, V1, A1
9D02D17C  8C860004   LW A2, 4(A0)
9D02D180  24040004   ADDIU A0, ZERO, 4
9D02D184  00052A82   SRL A1, A1, 10
9D02D188  0F406314   JAL ppu_setpage
9D02D18C  00C33021   ADDU A2, A2, V1
95:                        break;
9D02D190  0B40B477   J 0x9D02D1DC
9D02D194  8FBF0014   LW RA, 20(SP)
96:                  
97:                     case 8:
98:                        if (bank == MMC_LASTBANK)
99:                           bank = MMC_LAST8KVROM;
9D02D198  00062827   NOR A1, ZERO, A2
9D02D19C  0045300A   MOVZ A2, V0, A1
100:                       ppu_setpage(8, 0, &mmc.cart->vrom[(bank % MMC_8KVROM) << 13]);
9D02D1A0  00C3001A   DIV A2, V1
9D02D1A4  006001F4   TEQ V1, ZERO
9D02D1A8  00001010   MFHI V0
9D02D1AC  00021B40   SLL V1, V0, 13
9D02D1B0  8C860004   LW A2, 4(A0)
9D02D1B4  24040008   ADDIU A0, ZERO, 8
9D02D1B8  00002821   ADDU A1, ZERO, ZERO
9D02D1BC  0F406314   JAL ppu_setpage
9D02D1C0  00C33021   ADDU A2, A2, V1
101:                       break;
9D02D1C4  0B40B477   J 0x9D02D1DC
9D02D1C8  8FBF0014   LW RA, 20(SP)
102:                 
103:                    default:
104:                       log_printf("invalid VROM bank size %d\n", size);
9D02D0A4  0B40B473   J 0x9D02D1CC
9D02D0A8  3C049D04   LUI A0, -25340
9D02D0C0  0B40B473   J 0x9D02D1CC
9D02D0C4  3C049D04   LUI A0, -25340
9D02D1CC  2484B16C   ADDIU A0, A0, -20116
9D02D1D0  0F40F11B   JAL log_printf
9D02D1D4  00402821   ADDU A1, V0, ZERO
105:                    }
106:                 }
9D02D1D8  8FBF0014   LW RA, 20(SP)
9D02D1DC  03E00008   JR RA
9D02D1E0  27BD0018   ADDIU SP, SP, 24
107:                 
108:                 /* ROM bankswitching */
109:                 void mmc_bankrom(int size, uint32 address, int bank)
110:                 {
9D02D1E4  27BDFF80   ADDIU SP, SP, -128
9D02D1E8  AFBF007C   SW RA, 124(SP)
9D02D1EC  AFB20078   SW S2, 120(SP)
9D02D1F0  AFB10074   SW S1, 116(SP)
9D02D1F4  AFB00070   SW S0, 112(SP)
9D02D1F8  00808821   ADDU S1, A0, ZERO
9D02D1FC  00A09021   ADDU S2, A1, ZERO
9D02D200  00C08021   ADDU S0, A2, ZERO
111:                    nes6502_context mmc_cpu;
112:                 
113:                    nes6502_getcontext(&mmc_cpu); 
9D02D204  0F400099   JAL nes6502_getcontext
9D02D208  27A40010   ADDIU A0, SP, 16
114:                 
115:                    switch (size)
9D02D20C  24020010   ADDIU V0, ZERO, 16
9D02D210  1222001F   BEQ S1, V0, 0x9D02D290
9D02D214  24020020   ADDIU V0, ZERO, 32
9D02D218  12220042   BEQ S1, V0, 0x9D02D324
9D02D21C  24020008   ADDIU V0, ZERO, 8
9D02D220  56220063   BNEL S1, V0, 0x9D02D3B0
9D02D224  3C049D04   LUI A0, -25340
116:                    {
117:                    case 8:
118:                       if (bank == MMC_LASTBANK)
9D02D228  2402FFFF   ADDIU V0, ZERO, -1
9D02D22C  16020005   BNE S0, V0, .LBB2
9D02D230  00129302   SRL S2, S2, 12
119:                          bank = MMC_LAST8KROM;
9D02D234  8F8280F4   LW V0, -32524(GP)
9D02D238  8C500010   LW S0, 16(V0)
9D02D23C  00108040   SLL S0, S0, 1
9D02D240  2610FFFF   ADDIU S0, S0, -1
120:                       {
121:                          int page = address >> NES6502_BANKSHIFT;
122:                          mmc_cpu.mem_page[page] = &mmc.cart->rom[(bank % MMC_8KROM) << 13];
9D02D244  8F8280F4   LW V0, -32524(GP)
9D02D248  8C430010   LW V1, 16(V0)
9D02D24C  00031840   SLL V1, V1, 1
9D02D250  0203001A   DIV S0, V1
9D02D254  006001F4   TEQ V1, ZERO
9D02D258  00002010   MFHI A0
9D02D25C  00048340   SLL S0, A0, 13
9D02D260  8C420000   LW V0, 0(V0)
9D02D264  00508021   ADDU S0, V0, S0
9D02D268  00121080   SLL V0, S2, 2
9D02D26C  27A30010   ADDIU V1, SP, 16
9D02D270  00621021   ADDU V0, V1, V0
9D02D274  AC500000   SW S0, 0(V0)
123:                          mmc_cpu.mem_page[page + 1] = mmc_cpu.mem_page[page] + 0x1000;
9D02D278  26520001   ADDIU S2, S2, 1
9D02D27C  00129080   SLL S2, S2, 2
9D02D280  00729021   ADDU S2, V1, S2
9D02D284  26101000   ADDIU S0, S0, 4096
124:                       }
125:                 
126:                       break;
9D02D288  0B40B4EF   J .LVL51
9D02D28C  AE500000   SW S0, 0(S2)
127:                 
128:                    case 16:
129:                       if (bank == MMC_LASTBANK)
9D02D290  2402FFFF   ADDIU V0, ZERO, -1
9D02D294  16020004   BNE S0, V0, .LBB3
9D02D298  00129302   SRL S2, S2, 12
130:                          bank = MMC_LAST16KROM;
9D02D29C  8F8280F4   LW V0, -32524(GP)
9D02D2A0  8C500010   LW S0, 16(V0)
9D02D2A4  2610FFFF   ADDIU S0, S0, -1
131:                       {
132:                          int page = address >> NES6502_BANKSHIFT;
133:                          mmc_cpu.mem_page[page] = &mmc.cart->rom[(bank % MMC_16KROM) << 14];
9D02D2A8  8F8280F4   LW V0, -32524(GP)
9D02D2AC  8C430010   LW V1, 16(V0)
9D02D2B0  0203001A   DIV S0, V1
9D02D2B4  006001F4   TEQ V1, ZERO
9D02D2B8  00002010   MFHI A0
9D02D2BC  00048380   SLL S0, A0, 14
9D02D2C0  8C420000   LW V0, 0(V0)
9D02D2C4  00508021   ADDU S0, V0, S0
9D02D2C8  00121080   SLL V0, S2, 2
9D02D2CC  27A40010   ADDIU A0, SP, 16
9D02D2D0  00821021   ADDU V0, A0, V0
9D02D2D4  AC500000   SW S0, 0(V0)
134:                          mmc_cpu.mem_page[page + 1] = mmc_cpu.mem_page[page] + 0x1000;
9D02D2D8  26430001   ADDIU V1, S2, 1
9D02D2DC  00031880   SLL V1, V1, 2
9D02D2E0  00831821   ADDU V1, A0, V1
9D02D2E4  26101000   ADDIU S0, S0, 4096
9D02D2E8  AC700000   SW S0, 0(V1)
135:                          mmc_cpu.mem_page[page + 2] = mmc_cpu.mem_page[page] + 0x2000;
9D02D2EC  26430002   ADDIU V1, S2, 2
9D02D2F0  00031880   SLL V1, V1, 2
9D02D2F4  00831821   ADDU V1, A0, V1
9D02D2F8  8C440000   LW A0, 0(V0)
9D02D2FC  24842000   ADDIU A0, A0, 8192
9D02D300  AC640000   SW A0, 0(V1)
136:                          mmc_cpu.mem_page[page + 3] = mmc_cpu.mem_page[page] + 0x3000;
9D02D304  26520003   ADDIU S2, S2, 3
9D02D308  00129080   SLL S2, S2, 2
9D02D30C  27A30010   ADDIU V1, SP, 16
9D02D310  00729021   ADDU S2, V1, S2
9D02D314  8C420000   LW V0, 0(V0)
9D02D318  24423000   ADDIU V0, V0, 12288
137:                       }
138:                       break;
9D02D31C  0B40B4EF   J .LVL51
9D02D320  AE420000   SW V0, 0(S2)
139:                 
140:                    case 32:
141:                       if (bank == MMC_LASTBANK)
9D02D324  2402FFFF   ADDIU V0, ZERO, -1
9D02D328  16020007   BNE S0, V0, 0x9D02D348
9D02D32C  8F8280F4   LW V0, -32524(GP)
142:                          bank = MMC_LAST32KROM;
9D02D330  8C420010   LW V0, 16(V0)
9D02D334  000287C2   SRL S0, V0, 31
9D02D338  02028021   ADDU S0, S0, V0
9D02D33C  00108043   SRA S0, S0, 1
9D02D340  2610FFFF   ADDIU S0, S0, -1
143:                 
144:                       mmc_cpu.mem_page[8] = &mmc.cart->rom[(bank % MMC_32KROM) << 15];
9D02D344  8F8280F4   LW V0, -32524(GP)
9D02D348  8C430010   LW V1, 16(V0)
9D02D34C  000327C2   SRL A0, V1, 31
9D02D350  00831821   ADDU V1, A0, V1
9D02D354  00031843   SRA V1, V1, 1
9D02D358  0203001A   DIV S0, V1
9D02D35C  006001F4   TEQ V1, ZERO
9D02D360  00002010   MFHI A0
9D02D364  000483C0   SLL S0, A0, 15
9D02D368  8C420000   LW V0, 0(V0)
9D02D36C  00508021   ADDU S0, V0, S0
9D02D370  AFB00030   SW S0, 48(SP)
145:                       mmc_cpu.mem_page[9] = mmc_cpu.mem_page[8] + 0x1000;
9D02D374  26021000   ADDIU V0, S0, 4096
9D02D378  AFA20034   SW V0, 52(SP)
146:                       mmc_cpu.mem_page[10] = mmc_cpu.mem_page[8] + 0x2000;
9D02D37C  26022000   ADDIU V0, S0, 8192
9D02D380  AFA20038   SW V0, 56(SP)
147:                       mmc_cpu.mem_page[11] = mmc_cpu.mem_page[8] + 0x3000;
9D02D384  26023000   ADDIU V0, S0, 12288
9D02D388  AFA2003C   SW V0, 60(SP)
148:                       mmc_cpu.mem_page[12] = mmc_cpu.mem_page[8] + 0x4000;
9D02D38C  26024000   ADDIU V0, S0, 16384
9D02D390  AFA20040   SW V0, 64(SP)
149:                       mmc_cpu.mem_page[13] = mmc_cpu.mem_page[8] + 0x5000;
9D02D394  26025000   ADDIU V0, S0, 20480
9D02D398  AFA20044   SW V0, 68(SP)
150:                       mmc_cpu.mem_page[14] = mmc_cpu.mem_page[8] + 0x6000;
9D02D39C  26026000   ADDIU V0, S0, 24576
9D02D3A0  AFA20048   SW V0, 72(SP)
151:                       mmc_cpu.mem_page[15] = mmc_cpu.mem_page[8] + 0x7000;
9D02D3A4  26107000   ADDIU S0, S0, 28672
152:                       break;
9D02D3A8  0B40B4EF   J .LVL51
9D02D3AC  AFB0004C   SW S0, 76(SP)
153:                 
154:                    default:
155:                       log_printf("invalid ROM bank size %d\n", size);
9D02D3B0  2484B188   ADDIU A0, A0, -20088
9D02D3B4  0F40F11B   JAL log_printf
9D02D3B8  02202821   ADDU A1, S1, ZERO
156:                       break;
157:                    }
158:                 
159:                    nes6502_setcontext(&mmc_cpu);
9D02D3BC  0F400073   JAL nes6502_setcontext
9D02D3C0  27A40010   ADDIU A0, SP, 16
160:                 }
9D02D3C4  8FBF007C   LW RA, 124(SP)
9D02D3C8  8FB20078   LW S2, 120(SP)
9D02D3CC  8FB10074   LW S1, 116(SP)
9D02D3D0  8FB00070   LW S0, 112(SP)
9D02D3D4  03E00008   JR RA
9D02D3D8  27BD0080   ADDIU SP, SP, 128
161:                 
162:                 /* Check to see if this mapper is supported */
163:                 bool mmc_peek(int map_num)
164:                 {
165:                    mapintf_t **map_ptr = mappers;
9D02D3F8  3C02A001   LUI V0, -24575
9D02D3FC  0B40B503   J 0x9D02D40C
9D02D400  2442A9A8   ADDIU V0, V0, -22104
166:                 
167:                    while (NULL != *map_ptr)
9D02D3DC  3C02A001   LUI V0, -24575
9D02D3E0  8C42A9A8   LW V0, -22104(V0)
9D02D3E4  1040000F   BEQ V0, ZERO, 0x9D02D424
9D02D3E8  00000000   NOP
9D02D410  8C430000   LW V1, 0(V0)
9D02D414  5460FFFB   BNEL V1, ZERO, 0x9D02D404
9D02D418  8C630000   LW V1, 0(V1)
9D02D41C  03E00008   JR RA
9D02D420  00001021   ADDU V0, ZERO, ZERO
168:                    {
169:                       if ((*map_ptr)->number == map_num)
9D02D3EC  8C420000   LW V0, 0(V0)
9D02D3F0  1044000E   BEQ V0, A0, 0x9D02D42C
9D02D3F4  00000000   NOP
9D02D404  1064000B   BEQ V1, A0, 0x9D02D434
9D02D408  00000000   NOP
170:                          return true;
9D02D42C  03E00008   JR RA
9D02D430  24020001   ADDIU V0, ZERO, 1
171:                       map_ptr++;
9D02D40C  24420004   ADDIU V0, V0, 4
172:                    }
173:                 
174:                    return false;
9D02D424  03E00008   JR RA
9D02D428  00001021   ADDU V0, ZERO, ZERO
175:                 }
9D02D434  03E00008   JR RA
9D02D438  24020001   ADDIU V0, ZERO, 1
176:                 
177:                 static void mmc_setpages(void)
178:                 {
179:                    log_printf("setting up mapper %d\n", mmc.intf->number);
9D02D444  3C049D04   LUI A0, -25340
9D02D448  2484B1A4   ADDIU A0, A0, -20060
9D02D44C  8F8280F0   LW V0, -32528(GP)
9D02D450  0F40F11B   JAL log_printf
9D02D454  8C450000   LW A1, 0(V0)
180:                 
181:                    /* Switch ROM into CPU space, set VROM/VRAM (done for ALL ROMs) */
182:                    mmc_bankrom(16, 0x8000, 0);
9D02D458  24040010   ADDIU A0, ZERO, 16
9D02D45C  34058000   ORI A1, ZERO, -32768
9D02D460  0F40B479   JAL mmc_bankrom
9D02D464  00003021   ADDU A2, ZERO, ZERO
183:                    mmc_bankrom(16, 0xC000, MMC_LASTBANK);
9D02D468  24040010   ADDIU A0, ZERO, 16
9D02D46C  3405C000   ORI A1, ZERO, -16384
9D02D470  0F40B479   JAL mmc_bankrom
9D02D474  2406FFFF   ADDIU A2, ZERO, -1
184:                    mmc_bankvrom(8, 0x0000, 0);
9D02D478  24040008   ADDIU A0, ZERO, 8
9D02D47C  00002821   ADDU A1, ZERO, ZERO
9D02D480  0F40B41B   JAL mmc_bankvrom
9D02D484  00003021   ADDU A2, ZERO, ZERO
185:                 
186:                    if (mmc.cart->flags & ROM_FLAG_FOURSCREEN)
9D02D488  8F8280F4   LW V0, -32524(GP)
9D02D48C  90430028   LBU V1, 40(V0)
9D02D490  30630004   ANDI V1, V1, 4
9D02D494  306300FF   ANDI V1, V1, 255
9D02D498  50600008   BEQL V1, ZERO, 0x9D02D4BC
9D02D49C  8C430024   LW V1, 36(V0)
187:                    {
188:                       ppu_mirror(0, 1, 2, 3);
9D02D4A0  00002021   ADDU A0, ZERO, ZERO
9D02D4A4  24050001   ADDIU A1, ZERO, 1
9D02D4A8  24060002   ADDIU A2, ZERO, 2
9D02D4AC  0F40635D   JAL ppu_mirror
9D02D4B0  24070003   ADDIU A3, ZERO, 3
189:                    }
190:                    else
191:                    {
192:                       if (MIRROR_VERT == mmc.cart->mirror)
9D02D4BC  24020001   ADDIU V0, ZERO, 1
9D02D4C0  14620007   BNE V1, V0, 0x9D02D4E0
9D02D4C4  00002021   ADDU A0, ZERO, ZERO
193:                          ppu_mirror(0, 1, 0, 1);
9D02D4C8  24050001   ADDIU A1, ZERO, 1
9D02D4CC  00003021   ADDU A2, ZERO, ZERO
9D02D4D0  0F40635D   JAL ppu_mirror
9D02D4D4  24070001   ADDIU A3, ZERO, 1
194:                       else
195:                          ppu_mirror(0, 0, 1, 1);
9D02D4E0  00002821   ADDU A1, ZERO, ZERO
9D02D4E4  24060001   ADDIU A2, ZERO, 1
9D02D4E8  0F40635D   JAL ppu_mirror
9D02D4EC  24070001   ADDIU A3, ZERO, 1
196:                    }
197:                 
198:                    /* if we have no VROM, switch in VRAM */
199:                    /* TODO: fix this hack implementation */
200:                    if (0 == mmc.cart->vrom_banks)
9D02D4B4  0B40B53D   J 0x9D02D4F4
9D02D4B8  8F8280F4   LW V0, -32524(GP)
9D02D4D8  0B40B53D   J 0x9D02D4F4
9D02D4DC  8F8280F4   LW V0, -32524(GP)
9D02D4F0  8F8280F4   LW V0, -32524(GP)
9D02D4F4  8C430014   LW V1, 20(V0)
9D02D4F8  14600006   BNE V1, ZERO, .LVL69
9D02D4FC  24040008   ADDIU A0, ZERO, 8
201:                    {
202:                       ASSERT(mmc.cart->vram);
203:                 
204:                       ppu_setpage(8, 0, mmc.cart->vram);
9D02D500  00002821   ADDU A1, ZERO, ZERO
9D02D504  0F406314   JAL ppu_setpage
9D02D508  8C46000C   LW A2, 12(V0)
205:                       ppu_mirrorhipages();
9D02D50C  0F40634E   JAL ppu_mirrorhipages
9D02D510  00000000   NOP
206:                    }
207:                 }
208:                 
209:                 /* Mapper initialization routine */
210:                 void mmc_reset(void)
211:                 {
9D02D43C  27BDFFE8   ADDIU SP, SP, -24
9D02D440  AFBF0014   SW RA, 20(SP)
212:                    mmc_setpages();
213:                 
214:                    ppu_setlatchfunc(NULL);
9D02D514  0F4065C6   JAL ppu_setlatchfunc
9D02D518  00002021   ADDU A0, ZERO, ZERO
215:                    ppu_setvromswitch(NULL);
9D02D51C  0F4065C9   JAL ppu_setvromswitch
9D02D520  00002021   ADDU A0, ZERO, ZERO
216:                 
217:                    if (mmc.intf->init)
9D02D524  8F8280F0   LW V0, -32528(GP)
9D02D528  8C420008   LW V0, 8(V0)
9D02D52C  50400004   BEQL V0, ZERO, 0x9D02D540
9D02D530  3C049D04   LUI A0, -25340
218:                       mmc.intf->init();
9D02D534  0040F809   JALR V0
9D02D538  00000000   NOP
219:                 
220:                    log_printf("reset memory mapper\n");
9D02D53C  3C049D04   LUI A0, -25340
9D02D540  0F40F11B   JAL log_printf
9D02D544  2484B1BC   ADDIU A0, A0, -20036
221:                 }
9D02D548  8FBF0014   LW RA, 20(SP)
9D02D54C  03E00008   JR RA
9D02D550  27BD0018   ADDIU SP, SP, 24
222:                 
223:                 
224:                 void mmc_destroy(mmc_t **nes_mmc)
225:                 {
9D02D560  27BDFFE8   ADDIU SP, SP, -24
9D02D564  AFBF0014   SW RA, 20(SP)
226:                    if (*nes_mmc)
9D02D554  8C820000   LW V0, 0(A0)
9D02D558  10400007   BEQ V0, ZERO, 0x9D02D578
9D02D55C  00000000   NOP
227:                       free(*nes_mmc);
9D02D568  0F40DDCA   JAL _my_free
9D02D56C  00000000   NOP
228:                 }
9D02D570  8FBF0014   LW RA, 20(SP)
9D02D574  27BD0018   ADDIU SP, SP, 24
9D02D578  03E00008   JR RA
9D02D57C  00000000   NOP
229:                 
230:                 mmc_t *mmc_create(rominfo_t *rominfo)
231:                 {
9D02D580  27BDFFE0   ADDIU SP, SP, -32
9D02D584  AFBF001C   SW RA, 28(SP)
9D02D588  AFB20018   SW S2, 24(SP)
9D02D58C  AFB10014   SW S1, 20(SP)
9D02D590  AFB00010   SW S0, 16(SP)
232:                    mmc_t *temp;
233:                    mapintf_t **map_ptr;
234:                   
235:                    for (map_ptr = mappers; (*map_ptr)->number != rominfo->mapper_number; map_ptr++)
9D02D594  3C02A001   LUI V0, -24575
9D02D598  8C42A9A8   LW V0, -22104(V0)
9D02D59C  8C850020   LW A1, 32(A0)
9D02D5A0  8C430000   LW V1, 0(V0)
9D02D5A4  1065000E   BEQ V1, A1, 0x9D02D5E0
9D02D5A8  00809021   ADDU S2, A0, ZERO
9D02D5B4  0B40B571   J 0x9D02D5C4
9D02D5B8  2610A9A8   ADDIU S0, S0, -22104
9D02D5C4  26100004   ADDIU S0, S0, 4
9D02D5C8  8E020000   LW V0, 0(S0)
9D02D5CC  8C430000   LW V1, 0(V0)
9D02D5D0  1465FFFA   BNE V1, A1, 0x9D02D5BC
9D02D5D4  00000000   NOP
9D02D5D8  0B40B57A   J 0x9D02D5E8
9D02D5DC  00000000   NOP
9D02D5E0  3C10A001   LUI S0, -24575
9D02D5E4  2610A9A8   ADDIU S0, S0, -22104
236:                    {
237:                       if (NULL == *map_ptr)
9D02D5AC  10400026   BEQ V0, ZERO, 0x9D02D648
9D02D5B0  3C10A001   LUI S0, -24575
9D02D5BC  10400024   BEQ V0, ZERO, 0x9D02D650
9D02D5C0  00001021   ADDU V0, ZERO, ZERO
238:                          return NULL; /* Should *never* happen */
9D02D648  0B40B594   J 0x9D02D650
9D02D64C  00001021   ADDU V0, ZERO, ZERO
239:                    }
240:                 
241:                    temp = malloc(sizeof(mmc_t));
9D02D5E8  0F40DDB7   JAL _my_malloc
9D02D5EC  24040008   ADDIU A0, ZERO, 8
242:                    if (NULL == temp)
9D02D5F0  10400017   BEQ V0, ZERO, 0x9D02D650
9D02D5F4  00408821   ADDU S1, V0, ZERO
243:                       return NULL;
244:                 
245:                    memset(temp, 0, sizeof(mmc_t));
9D02D5F8  A0400000   SB ZERO, 0(V0)
9D02D5FC  A0400001   SB ZERO, 1(V0)
9D02D600  A0400002   SB ZERO, 2(V0)
9D02D604  A0400003   SB ZERO, 3(V0)
9D02D608  A0400004   SB ZERO, 4(V0)
9D02D60C  A0400005   SB ZERO, 5(V0)
9D02D610  A0400006   SB ZERO, 6(V0)
9D02D614  A0400007   SB ZERO, 7(V0)
246:                 
247:                    temp->intf = *map_ptr;
9D02D618  8E020000   LW V0, 0(S0)
9D02D61C  AE220000   SW V0, 0(S1)
248:                    temp->cart = rominfo;
9D02D620  AE320004   SW S2, 4(S1)
249:                 
250:                    mmc_setcontext(temp);
9D02D624  0F40B411   JAL mmc_setcontext
9D02D628  02202021   ADDU A0, S1, ZERO
251:                 
252:                    log_printf("created memory mapper: %s\n", (*map_ptr)->name);
9D02D62C  8E020000   LW V0, 0(S0)
9D02D630  3C049D04   LUI A0, -25340
9D02D634  2484B1D4   ADDIU A0, A0, -20012
9D02D638  0F40F11B   JAL log_printf
9D02D63C  8C450004   LW A1, 4(V0)
253:                 
254:                    return temp;
9D02D640  0B40B594   J 0x9D02D650
9D02D644  02201021   ADDU V0, S1, ZERO
255:                 }
9D02D650  8FBF001C   LW RA, 28(SP)
9D02D654  8FB20018   LW S2, 24(SP)
9D02D658  8FB10014   LW S1, 20(SP)
9D02D65C  8FB00010   LW S0, 16(SP)
9D02D660  03E00008   JR RA
9D02D664  27BD0020   ADDIU SP, SP, 32
256:                 
257:                 
258:                 /*
259:                 ** $Log: nes_mmc.c,v $
260:                 ** Revision 1.2  2001/04/27 14:37:11  neil
261:                 ** wheeee
262:                 **
263:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
264:                 ** initial
265:                 **
266:                 ** Revision 1.4  2000/11/21 13:28:40  matt
267:                 ** take care to zero allocated mem
268:                 **
269:                 ** Revision 1.3  2000/10/27 12:55:58  matt
270:                 ** nes6502 now uses 4kB banks across the boards
271:                 **
272:                 ** Revision 1.2  2000/10/25 00:23:16  matt
273:                 ** makefiles updated for new directory structure
274:                 **
275:                 ** Revision 1.1  2000/10/24 12:20:28  matt
276:                 ** changed directory structure
277:                 **
278:                 ** Revision 1.28  2000/10/22 19:17:24  matt
279:                 ** mapper cleanups galore
280:                 **
281:                 ** Revision 1.27  2000/10/22 15:02:32  matt
282:                 ** simplified mirroring
283:                 **
284:                 ** Revision 1.26  2000/10/21 19:38:56  matt
285:                 ** that two year old crap code *was* flushed
286:                 **
287:                 ** Revision 1.25  2000/10/21 19:26:59  matt
288:                 ** many more cleanups
289:                 **
290:                 ** Revision 1.24  2000/10/17 03:22:57  matt
291:                 ** cleaning up rom module
292:                 **
293:                 ** Revision 1.23  2000/10/10 13:58:15  matt
294:                 ** stroustrup squeezing his way in the door
295:                 **
296:                 ** Revision 1.22  2000/08/16 02:51:55  matt
297:                 ** random cleanups
298:                 **
299:                 ** Revision 1.21  2000/07/31 04:27:59  matt
300:                 ** one million cleanups
301:                 **
302:                 ** Revision 1.20  2000/07/25 02:25:53  matt
303:                 ** safer xxx_destroy calls
304:                 **
305:                 ** Revision 1.19  2000/07/23 15:11:45  matt
306:                 ** removed unused variables
307:                 **
308:                 ** Revision 1.18  2000/07/15 23:50:03  matt
309:                 ** migrated state get/set from nes_mmc.c to state.c
310:                 **
311:                 ** Revision 1.17  2000/07/11 03:15:09  melanson
312:                 ** Added support for mappers 16, 34, and 231
313:                 **
314:                 ** Revision 1.16  2000/07/10 05:27:41  matt
315:                 ** cleaned up mapper-specific callbacks
316:                 **
317:                 ** Revision 1.15  2000/07/10 03:02:49  matt
318:                 ** minor change on loading state
319:                 **
320:                 ** Revision 1.14  2000/07/06 17:38:49  matt
321:                 ** replaced missing string.h include
322:                 **
323:                 ** Revision 1.13  2000/07/06 02:47:11  matt
324:                 ** mapper addition madness
325:                 **
326:                 ** Revision 1.12  2000/07/05 05:04:15  matt
327:                 ** added more mappers
328:                 **
329:                 ** Revision 1.11  2000/07/04 23:12:58  matt
330:                 ** brand spankin' new mapper interface implemented
331:                 **
332:                 ** Revision 1.10  2000/07/04 04:56:36  matt
333:                 ** modifications for new SNSS
334:                 **
335:                 ** Revision 1.9  2000/06/29 14:17:18  matt
336:                 ** uses snsslib now
337:                 **
338:                 ** Revision 1.8  2000/06/29 03:09:24  matt
339:                 ** modified to support new snss code
340:                 **
341:                 ** Revision 1.7  2000/06/26 04:57:54  matt
342:                 ** bugfix - irqs/mmcstate not cleared on reset
343:                 **
344:                 ** Revision 1.6  2000/06/23 11:01:10  matt
345:                 ** updated for new external sound interface
346:                 **
347:                 ** Revision 1.5  2000/06/20 04:04:57  matt
348:                 ** hacked to use new external soundchip struct
349:                 **
350:                 ** Revision 1.4  2000/06/09 15:12:26  matt
351:                 ** initial revision
352:                 **
353:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/nes/nes.c  ---------------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** nes.c
21:                  **
22:                  ** NES hardware related routines
23:                  ** $Id: nes.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <stdio.h>
27:                  #include <string.h>
28:                  #include <stdlib.h>
29:                  #include <noftypes.h>
30:                  #include "nes6502.h"
31:                  #include <log.h>
32:                  #include <osd.h>
33:                  #include <gui.h>
34:                  #include <nes.h>
35:                  #include <nes_apu.h>
36:                  #include <nes_ppu.h>
37:                  #include <nes_rom.h>
38:                  #include <nes_mmc.h>
39:                  #include <vid_drv.h>
40:                  #include <nofrendo.h>
41:                  #include "../../disp.h"
42:                  
43:                  #define  NES_CLOCK_DIVIDER    12
44:                  //#define  NES_MASTER_CLOCK     21477272.727272727272
45:                  #define  NES_MASTER_CLOCK     (236250000 / 11)
46:                  #define  NES_SCANLINE_CYCLES  (1364.0 / NES_CLOCK_DIVIDER)
47:                  #define  NES_FIQ_PERIOD       (NES_MASTER_CLOCK / NES_CLOCK_DIVIDER / 60)
48:                  
49:                  #define  NES_RAMSIZE          0x800
50:                  
51:                  #define  NES_SKIP_LIMIT       (NES_REFRESH_RATE / 5)   /* 12 or 10, depending on PAL/NTSC */
52:                  
53:                  static nes_t nes;
54:                  
55:                  /* find out if a file is ours */
56:                  int nes_isourfile(const char *filename)
57:                  {
9D0233F0  27BDFFE8   ADDIU SP, SP, -24
9D0233F4  AFBF0014   SW RA, 20(SP)
58:                     return rom_checkmagic(filename);
9D0233F8  0F40ACAB   JAL rom_checkmagic
9D0233FC  00000000   NOP
59:                  }
9D023400  8FBF0014   LW RA, 20(SP)
9D023404  03E00008   JR RA
9D023408  27BD0018   ADDIU SP, SP, 24
60:                  
61:                  /* TODO: just asking for problems -- please remove */
62:                  nes_t *nes_getcontextptr(void)
63:                  {
64:                     return &nes;
65:                  }
9D02340C  3C02A001   LUI V0, -24575
9D023410  03E00008   JR RA
9D023414  24429868   ADDIU V0, V0, -26520
66:                  
67:                  void nes_getcontext(nes_t *machine)
68:                  {
9D023418  27BDFFE0   ADDIU SP, SP, -32
9D02341C  AFBF001C   SW RA, 28(SP)
9D023420  AFB20018   SW S2, 24(SP)
9D023424  AFB10014   SW S1, 20(SP)
9D023428  AFB00010   SW S0, 16(SP)
9D02342C  00809021   ADDU S2, A0, ZERO
69:                     apu_getcontext(nes.apu);
9D023430  3C11A001   LUI S1, -24575
9D023434  26309868   ADDIU S0, S1, -26520
9D023438  0F407892   JAL apu_getcontext
9D02343C  8E040308   LW A0, 776(S0)
70:                     ppu_getcontext(nes.ppu);
9D023440  0F4062C8   JAL ppu_getcontext
9D023444  8E040304   LW A0, 772(S0)
71:                     nes6502_getcontext(nes.cpu);
9D023448  0F400099   JAL nes6502_getcontext
9D02344C  8E249868   LW A0, -26520(S1)
72:                     mmc_getcontext(nes.mmc);
9D023450  0F40B416   JAL mmc_getcontext
9D023454  8E04030C   LW A0, 780(S0)
73:                  
74:                     *machine = nes;
9D023458  02001021   ADDU V0, S0, ZERO
9D02345C  02402021   ADDU A0, S2, ZERO
9D023460  26100330   ADDIU S0, S0, 816
9D023464  8C470000   LW A3, 0(V0)
9D023468  8C460004   LW A2, 4(V0)
9D02346C  8C450008   LW A1, 8(V0)
9D023470  8C43000C   LW V1, 12(V0)
9D023474  AC870000   SW A3, 0(A0)
9D023478  AC860004   SW A2, 4(A0)
9D02347C  AC850008   SW A1, 8(A0)
9D023480  AC83000C   SW V1, 12(A0)
9D023484  24420010   ADDIU V0, V0, 16
9D023488  1450FFF6   BNE V0, S0, 0x9D023464
9D02348C  24840010   ADDIU A0, A0, 16
9D023490  8C420000   LW V0, 0(V0)
9D023494  AC820000   SW V0, 0(A0)
75:                  }
9D023498  8FBF001C   LW RA, 28(SP)
9D02349C  8FB20018   LW S2, 24(SP)
9D0234A0  8FB10014   LW S1, 20(SP)
9D0234A4  8FB00010   LW S0, 16(SP)
9D0234A8  03E00008   JR RA
9D0234AC  27BD0020   ADDIU SP, SP, 32
76:                  
77:                  void nes_setcontext(nes_t *machine)
78:                  {
9D0234B0  27BDFFE8   ADDIU SP, SP, -24
9D0234B4  AFBF0014   SW RA, 20(SP)
9D0234B8  AFB00010   SW S0, 16(SP)
9D0234BC  00808021   ADDU S0, A0, ZERO
79:                     ASSERT(machine);
80:                  
81:                     apu_setcontext(machine->apu);
9D0234C0  0F40787C   JAL apu_setcontext
9D0234C4  8C840308   LW A0, 776(A0)
82:                     ppu_setcontext(machine->ppu);
9D0234C8  0F40628D   JAL ppu_setcontext
9D0234CC  8E040304   LW A0, 772(S0)
83:                     nes6502_setcontext(machine->cpu);
9D0234D0  0F400073   JAL nes6502_setcontext
9D0234D4  8E040000   LW A0, 0(S0)
84:                     mmc_setcontext(machine->mmc);
9D0234D8  0F40B411   JAL mmc_setcontext
9D0234DC  8E04030C   LW A0, 780(S0)
85:                  
86:                     nes = *machine;
9D0234E0  02001021   ADDU V0, S0, ZERO
9D0234E4  3C03A001   LUI V1, -24575
9D0234E8  24639868   ADDIU V1, V1, -26520
9D0234EC  26100330   ADDIU S0, S0, 816
9D0234F0  8C470000   LW A3, 0(V0)
9D0234F4  8C460004   LW A2, 4(V0)
9D0234F8  8C450008   LW A1, 8(V0)
9D0234FC  8C44000C   LW A0, 12(V0)
9D023500  AC670000   SW A3, 0(V1)
9D023504  AC660004   SW A2, 4(V1)
9D023508  AC650008   SW A1, 8(V1)
9D02350C  AC64000C   SW A0, 12(V1)
9D023510  24420010   ADDIU V0, V0, 16
9D023514  1450FFF6   BNE V0, S0, 0x9D0234F0
9D023518  24630010   ADDIU V1, V1, 16
9D02351C  8C420000   LW V0, 0(V0)
9D023520  AC620000   SW V0, 0(V1)
87:                  }
9D023524  8FBF0014   LW RA, 20(SP)
9D023528  8FB00010   LW S0, 16(SP)
9D02352C  03E00008   JR RA
9D023530  27BD0018   ADDIU SP, SP, 24
88:                  
89:                  static uint8 ram_read(uint32 address)
90:                  {
91:                     return nes.cpu->mem_page[0][address & (NES_RAMSIZE - 1)];
9D02317C  3C02A001   LUI V0, -24575
9D023180  8C429868   LW V0, -26520(V0)
9D023184  308407FF   ANDI A0, A0, 2047
9D023188  8C420000   LW V0, 0(V0)
9D02318C  00442021   ADDU A0, V0, A0
92:                  }
9D023190  03E00008   JR RA
9D023194  90820000   LBU V0, 0(A0)
93:                  
94:                  static void ram_write(uint32 address, uint8 value)
95:                  {
96:                     nes.cpu->mem_page[0][address & (NES_RAMSIZE - 1)] = value;
9D023198  3C02A001   LUI V0, -24575
9D02319C  8C429868   LW V0, -26520(V0)
9D0231A0  308407FF   ANDI A0, A0, 2047
9D0231A4  8C420000   LW V0, 0(V0)
9D0231A8  00442021   ADDU A0, V0, A0
9D0231AC  03E00008   JR RA
9D0231B0  A0850000   SB A1, 0(A0)
97:                  }
98:                  
99:                  static void write_protect(uint32 address, uint8 value)
100:                 {
9D0231B4  03E00008   JR RA
9D0231B8  00000000   NOP
101:                    /* don't allow write to go through */
102:                    UNUSED(address);
103:                    UNUSED(value);
104:                 }
105:                 
106:                 static uint8 read_protect(uint32 address)
107:                 {
108:                    /* don't allow read to go through */
109:                    UNUSED(address);
110:                 
111:                    return 0xFF;
112:                 }
9D0231BC  03E00008   JR RA
9D0231C0  240200FF   ADDIU V0, ZERO, 255
113:                 
114:                 #define  LAST_MEMORY_HANDLER  { -1, -1, NULL }
115:                 /* read/write handlers for standard NES */
116:                 static nes6502_memread default_readhandler[] =
117:                 {
118:                    { 0x0800, 0x1FFF, ram_read },
119:                    { 0x2000, 0x3FFF, ppu_read },
120:                    { 0x4000, 0x4015, apu_read },
121:                    { 0x4016, 0x4017, ppu_readhigh },
122:                    LAST_MEMORY_HANDLER
123:                 };
124:                 
125:                 static nes6502_memwrite default_writehandler[] =
126:                 {
127:                    { 0x0800, 0x1FFF, ram_write },
128:                    { 0x2000, 0x3FFF, ppu_write },
129:                    { 0x4000, 0x4013, apu_write },
130:                    { 0x4015, 0x4015, apu_write },
131:                    { 0x4014, 0x4017, ppu_writehigh },
132:                    LAST_MEMORY_HANDLER
133:                 };
134:                 
135:                 /* this big nasty boy sets up the address handlers that the CPU uses */
136:                 static void build_address_handlers(nes_t *machine)
137:                 {
138:                    int count, num_handlers = 0;
9D02390C  0B408E58   J 0x9D023960
9D023910  00002021   ADDU A0, ZERO, ZERO
139:                    mapintf_t *intf;
140:                    
141:                    ASSERT(machine);
142:                    intf = machine->mmc->intf;
9D0238D4  8E22030C   LW V0, 780(S1)
9D0238D8  8C500000   LW S0, 0(V0)
143:                 
144:                    memset(machine->readhandler, 0, sizeof(machine->readhandler));
9D0238DC  26240004   ADDIU A0, S1, 4
9D0238E0  00002821   ADDU A1, ZERO, ZERO
9D0238E4  0F40E9FC   JAL .Letext0, .LFE0, memset
9D0238E8  24060180   ADDIU A2, ZERO, 384
145:                    memset(machine->writehandler, 0, sizeof(machine->writehandler));
9D0238EC  26240184   ADDIU A0, S1, 388
9D0238F0  00002821   ADDU A1, ZERO, ZERO
9D0238F4  0F40E9FC   JAL .Letext0, .LFE0, memset
9D0238F8  24060180   ADDIU A2, ZERO, 384
146:                 
147:                    for (count = 0; num_handlers < MAX_MEM_HANDLERS; count++, num_handlers++)
9D023950  24840001   ADDIU A0, A0, 1
9D023954  2442000C   ADDIU V0, V0, 12
9D023958  0B408E45   J 0x9D023914
9D02395C  24A5000C   ADDIU A1, A1, 12
9D023D90  0B408E45   J 0x9D023914
9D023D94  24040001   ADDIU A0, ZERO, 1
148:                    {
149:                       if (NULL == default_readhandler[count].read_func)
9D0238FC  3C02A001   LUI V0, -24575
9D023900  8C42AB0C   LW V0, -21748(V0)
9D023904  14400114   BNE V0, ZERO, 0x9D023D58
9D023908  26220004   ADDIU V0, S1, 4
9D023914  8CA60008   LW A2, 8(A1)
9D023918  50C00012   BEQL A2, ZERO, 0x9D023964
9D02391C  8E020024   LW V0, 36(S0)
150:                          break;
151:                 
152:                       memcpy(&machine->readhandler[num_handlers], &default_readhandler[count],
9D023920  88A70003   LWL A3, 3(A1)
9D023924  98A70000   LWR A3, 0(A1)
9D023928  88A60007   LWL A2, 7(A1)
9D02392C  98A60004   LWR A2, 4(A1)
9D023930  88A8000B   LWL T0, 11(A1)
9D023934  98A80008   LWR T0, 8(A1)
9D023938  A8470003   SWL A3, 3(V0)
9D02393C  B8470000   SWR A3, 0(V0)
9D023940  A8460007   SWL A2, 7(V0)
9D023944  B8460004   SWR A2, 4(V0)
9D023948  A848000B   SWL T0, 11(V0)
9D02394C  B8480008   SWR T0, 8(V0)
9D023D58  3C03A001   LUI V1, -24575
9D023D5C  8C65AB04   LW A1, -21756(V1)
9D023D60  2463AB04   ADDIU V1, V1, -21756
9D023D64  8C640004   LW A0, 4(V1)
9D023D68  8C630008   LW V1, 8(V1)
9D023D6C  AA250007   SWL A1, 7(S1)
9D023D70  B8450000   SWR A1, 0(V0)
9D023D74  A8440007   SWL A0, 7(V0)
9D023D78  B8440004   SWR A0, 4(V0)
9D023D7C  A843000B   SWL V1, 11(V0)
9D023D80  B8430008   SWR V1, 8(V0)
9D023D84  26220010   ADDIU V0, S1, 16
9D023D88  3C05A001   LUI A1, -24575
9D023D8C  24A5AB10   ADDIU A1, A1, -21744
153:                              sizeof(nes6502_memread));
154:                    }
155:                 
156:                    if (intf->sound_ext)
9D023960  8E020024   LW V0, 36(S0)
9D023964  50400028   BEQL V0, ZERO, 0x9D023A08
9D023968  8E03001C   LW V1, 28(S0)
157:                    {
158:                       if (NULL != intf->sound_ext->mem_read)
9D02396C  8C430010   LW V1, 16(V0)
9D023970  10600024   BEQ V1, ZERO, 0x9D023A04
9D023974  28820020   SLTI V0, A0, 32
159:                       {
160:                          for (count = 0; num_handlers < MAX_MEM_HANDLERS; count++, num_handlers++)
9D023978  10400046   BEQ V0, ZERO, 0x9D023A94
9D02397C  00041080   SLL V0, A0, 2
9D0239A0  0B408E70   J 0x9D0239C0
9D0239A4  24090020   ADDIU T1, ZERO, 32
9D0239F0  24840001   ADDIU A0, A0, 1
9D0239F4  1489FFEC   BNE A0, T1, 0x9D0239A8
9D0239F8  B8480008   SWR T0, 8(V0)
9D0239FC  0B408EA5   J 0x9D023A94
9D023A00  00041080   SLL V0, A0, 2
161:                          {
162:                             if (NULL == intf->sound_ext->mem_read[count].read_func)
9D023980  8C620008   LW V0, 8(V1)
9D023984  10400104   BEQ V0, ZERO, 0x9D023D98
9D023988  00045080   SLL T2, A0, 2
9D02398C  00041100   SLL V0, A0, 4
9D023990  004A5023   SUBU T2, V0, T2
9D023994  022A5021   ADDU T2, S1, T2
9D023998  2405000C   ADDIU A1, ZERO, 12
9D02399C  254AFFF8   ADDIU T2, T2, -8
9D0239A8  8E020024   LW V0, 36(S0)
9D0239AC  8C430010   LW V1, 16(V0)
9D0239B0  00651821   ADDU V1, V1, A1
9D0239B4  8C620008   LW V0, 8(V1)
9D0239B8  10400012   BEQ V0, ZERO, 0x9D023A04
9D0239BC  24A5000C   ADDIU A1, A1, 12
9D0239C0  01451021   ADDU V0, T2, A1
163:                                break;
164:                 
165:                             memcpy(&machine->readhandler[num_handlers], &intf->sound_ext->mem_read[count],
9D0239C4  88670003   LWL A3, 3(V1)
9D0239C8  98670000   LWR A3, 0(V1)
9D0239CC  88660007   LWL A2, 7(V1)
9D0239D0  98660004   LWR A2, 4(V1)
9D0239D4  8868000B   LWL T0, 11(V1)
9D0239D8  98680008   LWR T0, 8(V1)
9D0239DC  A8470003   SWL A3, 3(V0)
9D0239E0  B8470000   SWR A3, 0(V0)
9D0239E4  A8460007   SWL A2, 7(V0)
9D0239E8  B8460004   SWR A2, 4(V0)
9D0239EC  A848000B   SWL T0, 11(V0)
166:                                    sizeof(nes6502_memread));
167:                          }
168:                       }
169:                    }
170:                 
171:                    if (NULL != intf->mem_read)
9D023A04  8E03001C   LW V1, 28(S0)
9D023A08  10600021   BEQ V1, ZERO, 0x9D023A90
9D023A0C  28820020   SLTI V0, A0, 32
9D023D98  8E03001C   LW V1, 28(S0)
9D023D9C  5460FF1F   BNEL V1, ZERO, 0x9D023A1C
9D023DA0  8C620008   LW V0, 8(V1)
9D023DA4  0B408EA5   J 0x9D023A94
9D023DA8  00041080   SLL V0, A0, 2
172:                    {
173:                       for (count = 0; num_handlers < MAX_MEM_HANDLERS; count++, num_handlers++)
9D023A10  10400020   BEQ V0, ZERO, 0x9D023A94
9D023A14  00041080   SLL V0, A0, 2
9D023A38  0B408E95   J 0x9D023A54
9D023A3C  24090020   ADDIU T1, ZERO, 32
9D023A84  24840001   ADDIU A0, A0, 1
9D023A88  1489FFED   BNE A0, T1, 0x9D023A40
9D023A8C  B8480008   SWR T0, 8(V0)
9D023A90  00041080   SLL V0, A0, 2
9D023A94  00041900   SLL V1, A0, 4
9D023A98  00621023   SUBU V0, V1, V0
9D023A9C  02221021   ADDU V0, S1, V0
174:                       {
175:                          if (NULL == intf->mem_read[count].read_func)
9D023A18  8C620008   LW V0, 8(V1)
9D023A1C  1040001C   BEQ V0, ZERO, 0x9D023A90
9D023A20  00041100   SLL V0, A0, 4
9D023A24  00045080   SLL T2, A0, 2
9D023A28  004A5023   SUBU T2, V0, T2
9D023A2C  022A5021   ADDU T2, S1, T2
9D023A30  2405000C   ADDIU A1, ZERO, 12
9D023A34  254AFFF8   ADDIU T2, T2, -8
9D023A40  8E03001C   LW V1, 28(S0)
9D023A44  00651821   ADDU V1, V1, A1
9D023A48  8C620008   LW V0, 8(V1)
9D023A4C  10400010   BEQ V0, ZERO, 0x9D023A90
9D023A50  24A5000C   ADDIU A1, A1, 12
9D023A54  01451021   ADDU V0, T2, A1
176:                             break;
177:                 
178:                          memcpy(&machine->readhandler[num_handlers], &intf->mem_read[count],
9D023A58  88670003   LWL A3, 3(V1)
9D023A5C  98670000   LWR A3, 0(V1)
9D023A60  88660007   LWL A2, 7(V1)
9D023A64  98660004   LWR A2, 4(V1)
9D023A68  8868000B   LWL T0, 11(V1)
9D023A6C  98680008   LWR T0, 8(V1)
9D023A70  A8470003   SWL A3, 3(V0)
9D023A74  B8470000   SWR A3, 0(V0)
9D023A78  A8460007   SWL A2, 7(V0)
9D023A7C  B8460004   SWR A2, 4(V0)
9D023A80  A848000B   SWL T0, 11(V0)
179:                                 sizeof(nes6502_memread));
180:                       }
181:                    }
182:                 
183:                    /* TODO: poof! numbers */
184:                    machine->readhandler[num_handlers].min_range = 0x4018;
9D023AA0  24034018   ADDIU V1, ZERO, 16408
9D023AA4  AC430004   SW V1, 4(V0)
185:                    machine->readhandler[num_handlers].max_range = 0x5FFF;
9D023AA8  24035FFF   ADDIU V1, ZERO, 24575
9D023AAC  AC430008   SW V1, 8(V0)
186:                    machine->readhandler[num_handlers].read_func = read_protect;
9D023AB0  3C039D02   LUI V1, -25342
9D023AB4  246331BC   ADDIU V1, V1, 12732
9D023AB8  AC43000C   SW V1, 12(V0)
187:                    num_handlers++;
9D023ABC  24840001   ADDIU A0, A0, 1
9D023AC0  00041080   SLL V0, A0, 2
9D023AC4  00042100   SLL A0, A0, 4
9D023AC8  00821023   SUBU V0, A0, V0
9D023ACC  02221021   ADDU V0, S1, V0
188:                    machine->readhandler[num_handlers].min_range = -1;
9D023AD0  2403FFFF   ADDIU V1, ZERO, -1
9D023AD4  AC430004   SW V1, 4(V0)
189:                    machine->readhandler[num_handlers].max_range = -1;
9D023AD8  AC430008   SW V1, 8(V0)
190:                    machine->readhandler[num_handlers].read_func = NULL;
9D023ADC  AC40000C   SW ZERO, 12(V0)
191:                    num_handlers++;
192:                    ASSERT(num_handlers <= MAX_MEM_HANDLERS);
193:                 
194:                    num_handlers = 0;
9D023AF0  0B408ED1   J 0x9D023B44
9D023AF4  00002021   ADDU A0, ZERO, ZERO
195:                 
196:                    for (count = 0; num_handlers < MAX_MEM_HANDLERS; count++, num_handlers++)
9D023B34  24840001   ADDIU A0, A0, 1
9D023B38  2442000C   ADDIU V0, V0, 12
9D023B3C  0B408EBE   J 0x9D023AF8
9D023B40  24A5000C   ADDIU A1, A1, 12
9D023D50  0B408EBE   J 0x9D023AF8
9D023D54  24040001   ADDIU A0, ZERO, 1
197:                    {
198:                       if (NULL == default_writehandler[count].write_func)
9D023AE0  3C02A001   LUI V0, -24575
9D023AE4  8C42AAC4   LW V0, -21820(V0)
9D023AE8  1440008B   BNE V0, ZERO, 0x9D023D18
9D023AEC  26220184   ADDIU V0, S1, 388
9D023AF8  8CA60008   LW A2, 8(A1)
9D023AFC  50C00012   BEQL A2, ZERO, 0x9D023B48
9D023B00  8E020024   LW V0, 36(S0)
199:                          break;
200:                 
201:                       memcpy(&machine->writehandler[num_handlers], &default_writehandler[count],
9D023B04  88A70003   LWL A3, 3(A1)
9D023B08  98A70000   LWR A3, 0(A1)
9D023B0C  88A60007   LWL A2, 7(A1)
9D023B10  98A60004   LWR A2, 4(A1)
9D023B14  88A8000B   LWL T0, 11(A1)
9D023B18  98A80008   LWR T0, 8(A1)
9D023B1C  A8470003   SWL A3, 3(V0)
9D023B20  B8470000   SWR A3, 0(V0)
9D023B24  A8460007   SWL A2, 7(V0)
9D023B28  B8460004   SWR A2, 4(V0)
9D023B2C  A848000B   SWL T0, 11(V0)
9D023B30  B8480008   SWR T0, 8(V0)
9D023D18  3C03A001   LUI V1, -24575
9D023D1C  8C65AABC   LW A1, -21828(V1)
9D023D20  2463AABC   ADDIU V1, V1, -21828
9D023D24  8C640004   LW A0, 4(V1)
9D023D28  8C630008   LW V1, 8(V1)
9D023D2C  AA250187   SWL A1, 391(S1)
9D023D30  B8450000   SWR A1, 0(V0)
9D023D34  A8440007   SWL A0, 7(V0)
9D023D38  B8440004   SWR A0, 4(V0)
9D023D3C  A843000B   SWL V1, 11(V0)
9D023D40  B8430008   SWR V1, 8(V0)
9D023D44  26220190   ADDIU V0, S1, 400
9D023D48  3C05A001   LUI A1, -24575
9D023D4C  24A5AAC8   ADDIU A1, A1, -21816
202:                              sizeof(nes6502_memwrite));
203:                    }
204:                 
205:                    if (intf->sound_ext)
9D023B44  8E020024   LW V0, 36(S0)
9D023B48  50400028   BEQL V0, ZERO, 0x9D023BEC
9D023B4C  8E030020   LW V1, 32(S0)
206:                    {
207:                       if (NULL != intf->sound_ext->mem_write)
9D023B50  8C430014   LW V1, 20(V0)
9D023B54  10600024   BEQ V1, ZERO, 0x9D023BE8
9D023B58  28820020   SLTI V0, A0, 32
208:                       {
209:                          for (count = 0; num_handlers < MAX_MEM_HANDLERS; count++, num_handlers++)
9D023B5C  10400047   BEQ V0, ZERO, 0x9D023C7C
9D023B60  00041080   SLL V0, A0, 2
9D023B84  0B408EE9   J 0x9D023BA4
9D023B88  24090020   ADDIU T1, ZERO, 32
9D023BD4  24840001   ADDIU A0, A0, 1
9D023BD8  1489FFEC   BNE A0, T1, 0x9D023B8C
9D023BDC  B8480008   SWR T0, 8(V0)
210:                          {
211:                             if (NULL == intf->sound_ext->mem_write[count].write_func)
9D023B64  8C620008   LW V0, 8(V1)
9D023B68  10400090   BEQ V0, ZERO, 0x9D023DAC
9D023B6C  00045080   SLL T2, A0, 2
9D023B70  00041100   SLL V0, A0, 4
9D023B74  004A5023   SUBU T2, V0, T2
9D023B78  022A5021   ADDU T2, S1, T2
9D023B7C  2405000C   ADDIU A1, ZERO, 12
9D023B80  254A0178   ADDIU T2, T2, 376
9D023B8C  8E020024   LW V0, 36(S0)
9D023B90  8C430014   LW V1, 20(V0)
9D023B94  00651821   ADDU V1, V1, A1
9D023B98  8C620008   LW V0, 8(V1)
9D023B9C  10400012   BEQ V0, ZERO, 0x9D023BE8
9D023BA0  24A5000C   ADDIU A1, A1, 12
9D023BA4  01451021   ADDU V0, T2, A1
212:                                break;
213:                 
214:                             memcpy(&machine->writehandler[num_handlers], &intf->sound_ext->mem_write[count],
9D023BA8  88670003   LWL A3, 3(V1)
9D023BAC  98670000   LWR A3, 0(V1)
9D023BB0  88660007   LWL A2, 7(V1)
9D023BB4  98660004   LWR A2, 4(V1)
9D023BB8  8868000B   LWL T0, 11(V1)
9D023BBC  98680008   LWR T0, 8(V1)
9D023BC0  A8470003   SWL A3, 3(V0)
9D023BC4  B8470000   SWR A3, 0(V0)
9D023BC8  A8460007   SWL A2, 7(V0)
9D023BCC  B8460004   SWR A2, 4(V0)
9D023BD0  A848000B   SWL T0, 11(V0)
215:                                    sizeof(nes6502_memwrite));
216:                          }
217:                       }
218:                    }
219:                 
220:                    if (NULL != intf->mem_write)
9D023BE8  8E030020   LW V1, 32(S0)
9D023BEC  10600023   BEQ V1, ZERO, 0x9D023C7C
9D023BF0  00041080   SLL V0, A0, 2
9D023DAC  8E030020   LW V1, 32(S0)
9D023DB0  5460FF94   BNEL V1, ZERO, 0x9D023C04
9D023DB4  8C620008   LW V0, 8(V1)
221:                    {
222:                       for (count = 0; num_handlers < MAX_MEM_HANDLERS; count++, num_handlers++)
9D023BF4  28820020   SLTI V0, A0, 32
9D023BF8  10400020   BEQ V0, ZERO, 0x9D023C7C
9D023BFC  00041080   SLL V0, A0, 2
9D023C20  0B408F0F   J 0x9D023C3C
9D023C24  24090020   ADDIU T1, ZERO, 32
9D023C6C  24840001   ADDIU A0, A0, 1
9D023C70  1489FFED   BNE A0, T1, 0x9D023C28
9D023C74  B8480008   SWR T0, 8(V0)
223:                       {
224:                          if (NULL == intf->mem_write[count].write_func)
9D023C00  8C620008   LW V0, 8(V1)
9D023C04  1040001C   BEQ V0, ZERO, 0x9D023C78
9D023C08  00045080   SLL T2, A0, 2
9D023C0C  00041100   SLL V0, A0, 4
9D023C10  004A5023   SUBU T2, V0, T2
9D023C14  022A5021   ADDU T2, S1, T2
9D023C18  2405000C   ADDIU A1, ZERO, 12
9D023C1C  254A0178   ADDIU T2, T2, 376
9D023C28  8E030020   LW V1, 32(S0)
9D023C2C  00651821   ADDU V1, V1, A1
9D023C30  8C620008   LW V0, 8(V1)
9D023C34  10400010   BEQ V0, ZERO, 0x9D023C78
9D023C38  24A5000C   ADDIU A1, A1, 12
9D023C3C  01451021   ADDU V0, T2, A1
225:                             break;
226:                 
227:                          memcpy(&machine->writehandler[num_handlers], &intf->mem_write[count],
9D023C40  88670003   LWL A3, 3(V1)
9D023C44  98670000   LWR A3, 0(V1)
9D023C48  88660007   LWL A2, 7(V1)
9D023C4C  98660004   LWR A2, 4(V1)
9D023C50  8868000B   LWL T0, 11(V1)
9D023C54  98680008   LWR T0, 8(V1)
9D023C58  A8470003   SWL A3, 3(V0)
9D023C5C  B8470000   SWR A3, 0(V0)
9D023C60  A8460007   SWL A2, 7(V0)
9D023C64  B8460004   SWR A2, 4(V0)
9D023C68  A848000B   SWL T0, 11(V0)
228:                                 sizeof(nes6502_memwrite));
229:                       }
230:                    }
231:                 
232:                    /* catch-all for bad writes */
233:                    /* TODO: poof! numbers */
234:                    machine->writehandler[num_handlers].min_range = 0x4018;
9D023BE0  0B408F1F   J 0x9D023C7C
9D023BE4  00041080   SLL V0, A0, 2
9D023C78  00041080   SLL V0, A0, 2
9D023C7C  00041900   SLL V1, A0, 4
9D023C80  00621023   SUBU V0, V1, V0
9D023C84  02221021   ADDU V0, S1, V0
9D023C88  24034018   ADDIU V1, ZERO, 16408
9D023C8C  AC430184   SW V1, 388(V0)
9D023DB8  0B408F1F   J 0x9D023C7C
9D023DBC  00041080   SLL V0, A0, 2
235:                    machine->writehandler[num_handlers].max_range = 0x5FFF;
9D023C90  24035FFF   ADDIU V1, ZERO, 24575
9D023C94  AC430188   SW V1, 392(V0)
236:                    machine->writehandler[num_handlers].write_func = write_protect;
9D023C98  3C039D02   LUI V1, -25342
9D023C9C  246331B4   ADDIU V1, V1, 12724
9D023CA0  AC43018C   SW V1, 396(V0)
237:                    num_handlers++;
9D023CA4  24850001   ADDIU A1, A0, 1
238:                    machine->writehandler[num_handlers].min_range = 0x8000;
9D023CA8  00051080   SLL V0, A1, 2
9D023CAC  00052900   SLL A1, A1, 4
9D023CB0  00A21023   SUBU V0, A1, V0
9D023CB4  02221021   ADDU V0, S1, V0
9D023CB8  34058000   ORI A1, ZERO, -32768
9D023CBC  AC450184   SW A1, 388(V0)
239:                    machine->writehandler[num_handlers].max_range = 0xFFFF;
9D023CC0  3405FFFF   ORI A1, ZERO, -1
9D023CC4  AC450188   SW A1, 392(V0)
240:                    machine->writehandler[num_handlers].write_func = write_protect;
9D023CC8  AC43018C   SW V1, 396(V0)
241:                    num_handlers++;
9D023CCC  24840002   ADDIU A0, A0, 2
242:                    machine->writehandler[num_handlers].min_range = -1;
9D023CD0  00041080   SLL V0, A0, 2
9D023CD4  00042100   SLL A0, A0, 4
9D023CD8  00822023   SUBU A0, A0, V0
9D023CDC  02248821   ADDU S1, S1, A0
9D023CE0  2402FFFF   ADDIU V0, ZERO, -1
9D023CE4  AE220184   SW V0, 388(S1)
243:                    machine->writehandler[num_handlers].max_range = -1;
9D023CE8  AE220188   SW V0, 392(S1)
244:                    machine->writehandler[num_handlers].write_func = NULL;
9D023CEC  AE20018C   SW ZERO, 396(S1)
245:                    num_handlers++;
246:                    ASSERT(num_handlers <= MAX_MEM_HANDLERS);
247:                 }
248:                 
249:                 /* raise an IRQ */
250:                 void nes_irq(void)
251:                 {
9D0231EC  27BDFFE8   ADDIU SP, SP, -24
9D0231F0  AFBF0014   SW RA, 20(SP)
252:                 #ifdef NOFRENDO_DEBUG
253:                 //   if (nes.scanline <= NES_SCREEN_HEIGHT)
254:                 //      memset(nes.vidbuf->line[nes.scanline - 1], GUI_RED, NES_SCREEN_WIDTH);
255:                 #endif /* NOFRENDO_DEBUG */
256:                 
257:                    nes6502_irq();
9D0231F4  0F40283A   JAL nes6502_irq
9D0231F8  00000000   NOP
258:                 }
9D0231FC  8FBF0014   LW RA, 20(SP)
9D023200  03E00008   JR RA
9D023204  27BD0018   ADDIU SP, SP, 24
259:                 
260:                 static uint8 nes_clearfiq(void)
261:                 {
262:                    if (nes.fiq_occurred)
9D0231C4  3C02A001   LUI V0, -24575
9D0231C8  8C429B7C   LW V0, -25732(V0)
9D0231CC  10400005   BEQ V0, ZERO, 0x9D0231E4
9D0231D0  00000000   NOP
263:                    {
264:                       nes.fiq_occurred = false;
9D0231D4  3C02A001   LUI V0, -24575
9D0231D8  AC409B7C   SW ZERO, -25732(V0)
265:                       return 0x40;
9D0231DC  03E00008   JR RA
9D0231E0  24020040   ADDIU V0, ZERO, 64
266:                    }
267:                 
268:                    return 0;
269:                 }
9D0231E4  03E00008   JR RA
9D0231E8  00001021   ADDU V0, ZERO, ZERO
270:                 
271:                 void nes_setfiq(uint8 value)
272:                 {
273:                    nes.fiq_state = value;
9D023534  3C02A001   LUI V0, -24575
9D023538  24429868   ADDIU V0, V0, -26520
9D02353C  A0440318   SB A0, 792(V0)
274:                    nes.fiq_cycles = (int) NES_FIQ_PERIOD;
9D023540  24037485   ADDIU V1, ZERO, 29829
9D023544  03E00008   JR RA
9D023548  AC43031C   SW V1, 796(V0)
275:                 }
276:                 
277:                 static void nes_checkfiq(int cycles)
278:                 {
9D023244  27BDFFE8   ADDIU SP, SP, -24
9D023248  AFBF0014   SW RA, 20(SP)
279:                    nes.fiq_cycles -= cycles;
9D023208  3C02A001   LUI V0, -24575
9D02320C  8C429B84   LW V0, -25724(V0)
9D023210  00442023   SUBU A0, V0, A0
9D02321C  03E00008   JR RA
9D023220  AC449B84   SW A0, -25724(V0)
280:                    if (nes.fiq_cycles <= 0)
9D023214  18800003   BLEZ A0, 0x9D023224
9D023218  3C02A001   LUI V0, -24575
281:                    {
282:                       nes.fiq_cycles += (int) NES_FIQ_PERIOD;
9D023224  3C02A001   LUI V0, -24575
9D023228  24429868   ADDIU V0, V0, -26520
9D02322C  24847485   ADDIU A0, A0, 29829
9D023230  AC44031C   SW A0, 796(V0)
283:                       if (0 == (nes.fiq_state & 0xC0))
9D023234  90420318   LBU V0, 792(V0)
9D023238  304200C0   ANDI V0, V0, 192
9D02323C  14400008   BNE V0, ZERO, 0x9D023260
9D023240  24030001   ADDIU V1, ZERO, 1
284:                       {
285:                          nes.fiq_occurred = true;
9D02324C  3C02A001   LUI V0, -24575
286:                          nes6502_irq();
9D023250  0F40283A   JAL nes6502_irq
9D023254  AC439B7C   SW V1, -25732(V0)
287:                       }
288:                    }
289:                 }
9D023258  8FBF0014   LW RA, 20(SP)
9D02325C  27BD0018   ADDIU SP, SP, 24
9D023260  03E00008   JR RA
9D023264  00000000   NOP
290:                 
291:                 void nes_nmi(void)
292:                 {
9D02354C  27BDFFE8   ADDIU SP, SP, -24
9D023550  AFBF0014   SW RA, 20(SP)
293:                    nes6502_nmi();
9D023554  0F4027F5   JAL nes6502_nmi
9D023558  00000000   NOP
294:                 }
9D02355C  8FBF0014   LW RA, 20(SP)
9D023560  03E00008   JR RA
9D023564  27BD0018   ADDIU SP, SP, 24
295:                 
296:                 int tsting = 0, tsti = 0;
297:                 static void nes_renderframe(bool draw_flag)
298:                 {
9D023268  27BDFFC8   ADDIU SP, SP, -56
9D02326C  AFBF0034   SW RA, 52(SP)
9D023270  AFBE0030   SW FP, 48(SP)
9D023274  AFB7002C   SW S7, 44(SP)
9D023278  AFB60028   SW S6, 40(SP)
9D02327C  AFB50024   SW S5, 36(SP)
9D023280  AFB40020   SW S4, 32(SP)
9D023284  AFB3001C   SW S3, 28(SP)
9D023288  AFB20018   SW S2, 24(SP)
9D02328C  AFB10014   SW S1, 20(SP)
9D023290  AFB00010   SW S0, 16(SP)
299:                    int elapsed_cycles;
300:                    mapintf_t *mapintf = nes.mmc->intf;
9D023294  3C02A001   LUI V0, -24575
9D023298  24429868   ADDIU V0, V0, -26520
9D02329C  8C43030C   LW V1, 780(V0)
9D0232A0  8C730000   LW S3, 0(V1)
301:                    int in_vblank = 0;
9D0232B4  0000F021   ADDU FP, ZERO, ZERO
302:                 
303:                    while (262 != nes.scanline)
9D0232A4  8C430320   LW V1, 800(V0)
9D0232A8  24020106   ADDIU V0, ZERO, 262
9D0232AC  10620042   BEQ V1, V0, 0x9D0233B8
9D0232B0  0080A021   ADDU S4, A0, ZERO
9D0232C8  24150106   ADDIU S5, ZERO, 262
9D0233B0  1455FFC6   BNE V0, S5, 0x9D0232CC
9D0233B4  AE020320   SW V0, 800(S0)
304:                    {
305:                 //      ppu_scanline(nes.vidbuf, nes.scanline, draw_flag);
306:                 		ppu_scanline(vid_getbuffer(), nes.scanline, draw_flag);
9D0232B8  3C12A001   LUI S2, -24575
9D0232CC  0F40BAD1   JAL vid_getbuffer
9D0232D0  26509868   ADDIU S0, S2, -26520
9D0232D4  00402021   ADDU A0, V0, ZERO
9D0232D8  8E050320   LW A1, 800(S0)
9D0232DC  0F40660A   JAL ppu_scanline
9D0232E0  02803021   ADDU A2, S4, ZERO
307:                 
308:                       if (241 == nes.scanline)
9D0232BC  241700F1   ADDIU S7, ZERO, 241
9D0232E4  8E020320   LW V0, 800(S0)
9D0232E8  54570017   BNEL V0, S7, 0x9D023348
9D0232EC  8E620010   LW V0, 16(S3)
309:                       {
310:                          /* 7-9 cycle delay between when VINT flag goes up and NMI is taken */
311:                          elapsed_cycles = nes6502_execute(7);
9D0232F0  0F4000CB   JAL nes6502_execute
9D0232F4  24040007   ADDIU A0, ZERO, 7
9D0232F8  00408021   ADDU S0, V0, ZERO
312:                          nes.scanline_cycles -= elapsed_cycles;
9D0232FC  26519868   ADDIU S1, S2, -26520
9D023300  0F40EEE7   JAL sitofp
9D023304  00402021   ADDU A0, V0, ZERO
9D023308  8E240324   LW A0, 804(S1)
9D02330C  0F40D22B   JAL __subsf3
9D023310  00402821   ADDU A1, V0, ZERO
9D023314  AE220324   SW V0, 804(S1)
313:                          nes_checkfiq(elapsed_cycles);
9D023318  0F408C82   JAL .LFB20, nes_checkfiq, .LFE17
9D02331C  02002021   ADDU A0, S0, ZERO
314:                 
315:                          ppu_checknmi();
9D023320  0F4065FE   JAL ppu_checknmi
9D023324  00000000   NOP
316:                 
317:                          if (mapintf->vblank)
9D023328  8E62000C   LW V0, 12(S3)
9D02332C  10400005   BEQ V0, ZERO, 0x9D023344
9D023330  241E0001   ADDIU FP, ZERO, 1
318:                             mapintf->vblank();
9D023334  0040F809   JALR V0
9D023338  00000000   NOP
319:                          in_vblank = 1;
320:                       } 
321:                 
322:                       if (mapintf->hblank)
9D02333C  0B408CD2   J 0x9D023348
9D023340  8E620010   LW V0, 16(S3)
9D023344  8E620010   LW V0, 16(S3)
9D023348  10400004   BEQ V0, ZERO, 0x9D02335C
9D02334C  26509868   ADDIU S0, S2, -26520
323:                          mapintf->hblank(in_vblank);
9D023350  0040F809   JALR V0
9D023354  03C02021   ADDU A0, FP, ZERO
324:                 
325:                       nes.scanline_cycles += (float) NES_SCANLINE_CYCLES;
9D0232C0  3C029D04   LUI V0, -25340
9D0232C4  8C56C870   LW S6, -14224(V0)
9D023358  26509868   ADDIU S0, S2, -26520
9D02335C  8E040324   LW A0, 804(S0)
9D023360  0F40D22D   JAL fpadd
9D023364  02C02821   ADDU A1, S6, ZERO
9D023368  AE020324   SW V0, 804(S0)
326:                       elapsed_cycles = nes6502_execute((int) nes.scanline_cycles);
9D02336C  0F40ECBC   JAL __fixsfsi
9D023370  00402021   ADDU A0, V0, ZERO
9D023374  0F4000CB   JAL nes6502_execute
9D023378  00402021   ADDU A0, V0, ZERO
9D02337C  00408821   ADDU S1, V0, ZERO
327:                       nes.scanline_cycles -= (float) elapsed_cycles;
9D023380  0F40EEE7   JAL sitofp
9D023384  00402021   ADDU A0, V0, ZERO
9D023388  8E040324   LW A0, 804(S0)
9D02338C  0F40D22B   JAL __subsf3
9D023390  00402821   ADDU A1, V0, ZERO
9D023394  AE020324   SW V0, 804(S0)
328:                       nes_checkfiq(elapsed_cycles);
9D023398  0F408C82   JAL .LFB20, nes_checkfiq, .LFE17
9D02339C  02202021   ADDU A0, S1, ZERO
329:                 
330:                       ppu_endscanline(nes.scanline);
9D0233A0  0F4065D5   JAL ppu_endscanline
9D0233A4  8E040320   LW A0, 800(S0)
331:                       nes.scanline++; 
9D0233A8  8E020320   LW V0, 800(S0)
9D0233AC  24420001   ADDIU V0, V0, 1
332:                    }
333:                 
334:                    nes.scanline = 0;
9D0233B8  3C02A001   LUI V0, -24575
9D0233BC  AC409B88   SW ZERO, -25720(V0)
335:                 }
9D0233C0  8FBF0034   LW RA, 52(SP)
9D0233C4  8FBE0030   LW FP, 48(SP)
9D0233C8  8FB7002C   LW S7, 44(SP)
9D0233CC  8FB60028   LW S6, 40(SP)
9D0233D0  8FB50024   LW S5, 36(SP)
9D0233D4  8FB40020   LW S4, 32(SP)
9D0233D8  8FB3001C   LW S3, 28(SP)
9D0233DC  8FB20018   LW S2, 24(SP)
9D0233E0  8FB10014   LW S1, 20(SP)
9D0233E4  8FB00010   LW S0, 16(SP)
9D0233E8  03E00008   JR RA
9D0233EC  27BD0038   ADDIU SP, SP, 56
336:                 
337:                 extern bitmap_t *primary_buffer;
338:                 
339:                 static void system_video(bool draw)
340:                 {
341:                    /* TODO: hack */
342:                 //   if (false == draw)
343:                 //   {
344:                 //      //gui_frame(false);
345:                 //      return;
346:                 //   }
347:                 
348:                    /* blit the NES screen to our video surface */
349:                 //   vid_blit(nes.vidbuf, 0, (NES_SCREEN_HEIGHT - NES_VISIBLE_HEIGHT) / 2,
350:                 //            0, 0, NES_SCREEN_WIDTH, NES_VISIBLE_HEIGHT);
351:                 
352:                    /* overlay our GUI on top of it */
353:                    //gui_frame(true);
354:                 
355:                    /* blit to screen */
356:                    //vid_flush();
357:                     //tft_writebuf((const uint8_t **)primary_buffer->line, 256, 240);
358:                    
359:                    //ili9341_write_frame(x, y, DEFAULT_WIDTH, DEFAULT_HEIGHT, (const uint8_t **)bmp->line);
360:                    
361:                 
362:                    /* grab input */
363:                    //osd_getinput();
364:                 }
365:                 
366:                 /* main emulation loop */
367:                 void nes_emulate(void)
368:                 {
9D023568  27BDFFD8   ADDIU SP, SP, -40
9D02356C  AFBF0024   SW RA, 36(SP)
9D023570  AFB30020   SW S3, 32(SP)
9D023574  AFB2001C   SW S2, 28(SP)
9D023578  AFB10018   SW S1, 24(SP)
9D02357C  AFB00014   SW S0, 20(SP)
369:                    int last_ticks, frames_to_render;
370:                 
371:                    //osd_setsound(nes.apu->process);
372:                 
373:                    last_ticks = nofrendo_ticks;
9D023580  8F92816C   LW S2, -32404(GP)
374:                    frames_to_render = 0;
9D02359C  00008021   ADDU S0, ZERO, ZERO
375:                    nes.scanline_cycles = 0;
9D023584  3C02A001   LUI V0, -24575
9D023588  24429868   ADDIU V0, V0, -26520
9D02358C  00001821   ADDU V1, ZERO, ZERO
9D023590  AC430324   SW V1, 804(V0)
376:                    nes.fiq_cycles = (int) NES_FIQ_PERIOD;
9D023594  24037485   ADDIU V1, ZERO, 29829
9D023598  AC43031C   SW V1, 796(V0)
377:                 
378:                    while (false == nes.poweroff)
9D0235A0  3C11A001   LUI S1, -24575
9D0235A4  0B408D8B   J 0x9D02362C
9D0235A8  24130001   ADDIU S3, ZERO, 1
9D02362C  26229868   ADDIU V0, S1, -26520
9D023630  8C42032C   LW V0, 812(V0)
9D023634  1040FFDD   BEQ V0, ZERO, 0x9D0235AC
9D023638  8FBF0024   LW RA, 36(SP)
379:                    {
380:                       if (nofrendo_ticks != last_ticks)
9D0235AC  8F82816C   LW V0, -32404(GP)
9D0235B0  10520007   BEQ V0, S2, 0x9D0235D0
9D0235B4  26229868   ADDIU V0, S1, -26520
381:                       {
382:                          int tick_diff = nofrendo_ticks - last_ticks;
9D0235B8  8F84816C   LW A0, -32404(GP)
9D0235BC  00922023   SUBU A0, A0, S2
383:                 
384:                          frames_to_render += tick_diff;
385:                          gui_tick(tick_diff);
9D0235C0  0F409158   JAL gui_tick
9D0235C4  02048021   ADDU S0, S0, A0
386:                          last_ticks = nofrendo_ticks;
9D0235C8  8F92816C   LW S2, -32404(GP)
387:                       }
388:                 
389:                       if (true == nes.pause)
9D0235CC  26229868   ADDIU V0, S1, -26520
9D0235D0  8C420330   LW V0, 816(V0)
9D0235D4  10530014   BEQ V0, S3, 0x9D023628
9D0235D8  2A020002   SLTI V0, S0, 2
390:                       {
391:                          /* TODO: dim the screen, and pause/silence the apu */
392:                          system_video(true);
393:                          frames_to_render = 0;
9D023628  00008021   ADDU S0, ZERO, ZERO
394:                       }
395:                       else if (frames_to_render > 1)
9D0235DC  14400006   BNE V0, ZERO, 0x9D0235F8
9D0235E0  00000000   NOP
396:                       {
397:                          frames_to_render--;
9D0235E4  2610FFFF   ADDIU S0, S0, -1
398:                          nes_renderframe(false);
9D0235E8  0F408C9A   JAL .LFB22, nes_renderframe, .LFE20
9D0235EC  00002021   ADDU A0, ZERO, ZERO
9D0235F0  0B408D8C   J 0x9D023630
9D0235F4  26229868   ADDIU V0, S1, -26520
399:                          system_video(false);
400:                       }
401:                       else if ((1 == frames_to_render && true == nes.autoframeskip)
9D0235F8  16130004   BNE S0, S3, 0x9D02360C
9D0235FC  26229868   ADDIU V0, S1, -26520
9D023600  8C420328   LW V0, 808(V0)
9D023604  10530004   BEQ V0, S3, 0x9D023618
9D023608  26229868   ADDIU V0, S1, -26520
402:                                || false == nes.autoframeskip)
9D02360C  8C420328   LW V0, 808(V0)
9D023610  14400007   BNE V0, ZERO, 0x9D023630
9D023614  26229868   ADDIU V0, S1, -26520
403:                       {
404:                          frames_to_render = 0;
9D023620  0B408D8B   J 0x9D02362C
9D023624  00008021   ADDU S0, ZERO, ZERO
405:                          nes_renderframe(true);
9D023618  0F408C9A   JAL .LFB22, nes_renderframe, .LFE20
9D02361C  02602021   ADDU A0, S3, ZERO
406:                          system_video(true);
407:                       }
408:                    }
409:                 }
9D02363C  8FB30020   LW S3, 32(SP)
9D023640  8FB2001C   LW S2, 28(SP)
9D023644  8FB10018   LW S1, 24(SP)
9D023648  8FB00014   LW S0, 20(SP)
9D02364C  03E00008   JR RA
9D023650  27BD0028   ADDIU SP, SP, 40
410:                 
411:                 static void mem_trash(uint8 *buffer, int length)
412:                 {
413:                    int i;
414:                 
415:                    for (i = 0; i < length; i++)
9D0236A4  1A20001E   BLEZ S1, 0x9D023720
9D0236C0  1611FFFB   BNE S0, S1, 0x9D0236B0
416:                       buffer[i] = (uint8) rand();
9D0236B0  0F40EF88   JAL .Letext0, .LFE0, rand
9D0236B4  00000000   NOP
9D0236B8  A2020000   SB V0, 0(S0)
9D0236BC  26100001   ADDIU S0, S0, 1
9D0236C0  1611FFFB   BNE S0, S1, 0x9D0236B0
9D0236C4  00000000   NOP
9D0236C8  0B408DC8   J 0x9D023720
9D0236CC  00000000   NOP
417:                 }
418:                 
419:                 /* Reset NES hardware */
420:                 void nes_reset(int reset_type)
421:                 {
9D023654  27BDFFE0   ADDIU SP, SP, -32
9D023658  AFBF001C   SW RA, 28(SP)
9D02365C  AFB10018   SW S1, 24(SP)
9D023660  AFB00014   SW S0, 20(SP)
422:                    if (HARD_RESET == reset_type)
9D023664  24020001   ADDIU V0, ZERO, 1
9D023668  1482001F   BNE A0, V0, 0x9D0236E8
9D02366C  00808021   ADDU S0, A0, ZERO
423:                    {
424:                       memset(nes.cpu->mem_page[0], 0, NES_RAMSIZE);
9D023670  3C10A001   LUI S0, -24575
9D023674  8E029868   LW V0, -26520(S0)
9D023678  8C440000   LW A0, 0(V0)
9D02367C  00002821   ADDU A1, ZERO, ZERO
9D023680  0F40E9FC   JAL .Letext0, .LFE0, memset
9D023684  24060800   ADDIU A2, ZERO, 2048
425:                       if (nes.rominfo->vram)
9D023688  26109868   ADDIU S0, S0, -26520
9D02368C  8E030310   LW V1, 784(S0)
9D023690  8C62000C   LW V0, 12(V1)
9D023694  10400022   BEQ V0, ZERO, 0x9D023720
9D023698  00000000   NOP
426:                          mem_trash(nes.rominfo->vram, 0x2000 * nes.rominfo->vram_banks);
9D02369C  8C71001C   LW S1, 28(V1)
9D0236A0  00118B40   SLL S1, S1, 13
427:                    }
428:                 
429:                    apu_reset();
9D0236E8  0F407A5B   JAL apu_reset
9D0236EC  00000000   NOP
9D023720  0F407A5B   JAL apu_reset
9D023724  00000000   NOP
430:                    ppu_reset(reset_type);
9D0236F0  0F40637F   JAL ppu_reset
9D0236F4  02002021   ADDU A0, S0, ZERO
9D023728  0F40637F   JAL ppu_reset
9D02372C  24040001   ADDIU A0, ZERO, 1
431:                    mmc_reset();
9D0236F8  0F40B50F   JAL mmc_reset
9D0236FC  00000000   NOP
9D023730  0F40B50F   JAL mmc_reset
9D023734  00000000   NOP
432:                    nes6502_reset();
9D023700  0F4027E5   JAL nes6502_reset
9D023704  00000000   NOP
9D023738  0F4027E5   JAL nes6502_reset
9D02373C  00000000   NOP
433:                 
434:                    nes.scanline = 241;
9D023708  240300F1   ADDIU V1, ZERO, 241
9D02370C  3C02A001   LUI V0, -24575
9D023710  AC439B88   SW V1, -25720(V0)
9D023740  240300F1   ADDIU V1, ZERO, 241
9D023744  3C02A001   LUI V0, -24575
9D023748  AC439B88   SW V1, -25720(V0)
435:                 
436:                    gui_sendmsg(GUI_GREEN, "NES %s", 
9D0236D0  240400C6   ADDIU A0, ZERO, 198
9D0236D4  3C059D04   LUI A1, -25340
9D0236D8  0F409253   JAL gui_sendmsg
9D0236DC  24A5C868   ADDIU A1, A1, -14232
9D023714  3C069D04   LUI A2, -25340
9D023718  0B408DB4   J .LBE6, .LBE5
9D02371C  24C6C860   ADDIU A2, A2, -14240
9D02374C  3C069D04   LUI A2, -25340
9D023750  0B408DB4   J .LBE6, .LBE5
9D023754  24C6C854   ADDIU A2, A2, -14252
437:                                (HARD_RESET == reset_type) ? "powered on" : "reset");
438:                 }
9D0236E0  0B408DD6   J 0x9D023758
9D0236E4  8FBF001C   LW RA, 28(SP)
9D023758  8FB10018   LW S1, 24(SP)
9D02375C  8FB00014   LW S0, 20(SP)
9D023760  03E00008   JR RA
9D023764  27BD0020   ADDIU SP, SP, 32
439:                 
440:                 void nes_destroy(nes_t **machine)
441:                 {
9D023768  27BDFFE8   ADDIU SP, SP, -24
9D02376C  AFBF0014   SW RA, 20(SP)
9D023770  AFB00010   SW S0, 16(SP)
9D023774  00808021   ADDU S0, A0, ZERO
442:                    if (*machine)
9D023778  8C840000   LW A0, 0(A0)
9D02377C  1080001B   BEQ A0, ZERO, 0x9D0237EC
9D023780  8FBF0014   LW RA, 20(SP)
443:                    {
444:                       rom_free(&(*machine)->rominfo);
9D023784  0F40AD4C   JAL rom_free
9D023788  24840310   ADDIU A0, A0, 784
445:                       mmc_destroy(&(*machine)->mmc);
9D02378C  8E040000   LW A0, 0(S0)
9D023790  0F40B555   JAL mmc_destroy
9D023794  2484030C   ADDIU A0, A0, 780
446:                       ppu_destroy(&(*machine)->ppu);
9D023798  8E040000   LW A0, 0(S0)
9D02379C  0F406307   JAL ppu_destroy
9D0237A0  24840304   ADDIU A0, A0, 772
447:                       apu_destroy(&(*machine)->apu);
9D0237A4  8E040000   LW A0, 0(S0)
9D0237A8  0F407B16   JAL apu_destroy
9D0237AC  24840308   ADDIU A0, A0, 776
448:                 //      bmp_destroy(&(*machine)->vidbuf);
449:                       if ((*machine)->cpu)
9D0237B0  8E020000   LW V0, 0(S0)
9D0237B4  8C440000   LW A0, 0(V0)
9D0237B8  10800008   BEQ A0, ZERO, .LVL90
9D0237BC  00000000   NOP
450:                       {
451:                          if ((*machine)->cpu->mem_page[0])
9D0237C0  8C820000   LW V0, 0(A0)
9D0237C4  10400003   BEQ V0, ZERO, .LVL89
9D0237C8  00000000   NOP
452:                             free((*machine)->cpu->mem_page[0]);
9D0237CC  0F40DDCA   JAL _my_free
9D0237D0  00000000   NOP
453:                          free((*machine)->cpu);
9D0237D4  0F40DDCA   JAL _my_free
9D0237D8  8E040000   LW A0, 0(S0)
454:                       }
455:                 
456:                       free(*machine);
9D0237DC  0F40DDCA   JAL _my_free
9D0237E0  02002021   ADDU A0, S0, ZERO
457:                       *machine = NULL;
9D0237E4  AE000000   SW ZERO, 0(S0)
458:                    }
459:                 }
9D0237E8  8FBF0014   LW RA, 20(SP)
9D0237EC  8FB00010   LW S0, 16(SP)
9D0237F0  03E00008   JR RA
9D0237F4  27BD0018   ADDIU SP, SP, 24
460:                 
461:                 void nes_poweroff(void)
462:                 {
463:                    nes.poweroff = true;
9D0237F8  24030001   ADDIU V1, ZERO, 1
9D0237FC  3C02A001   LUI V0, -24575
9D023800  03E00008   JR RA
9D023804  AC439B94   SW V1, -25708(V0)
464:                 }
465:                 
466:                 void nes_togglepause(void)
467:                 {
468:                    nes.pause ^= true;
9D023808  3C02A001   LUI V0, -24575
9D02380C  24429868   ADDIU V0, V0, -26520
9D023810  8C430330   LW V1, 816(V0)
9D023814  38630001   XORI V1, V1, 1
9D023818  03E00008   JR RA
9D02381C  AC430330   SW V1, 816(V0)
469:                 }
470:                 
471:                 /* insert a cart into the NES */
472:                 int nes_insertcart(const char *file_ptr, nes_t *machine)
473:                 {
9D023820  27BDFFE0   ADDIU SP, SP, -32
9D023824  AFBF001C   SW RA, 28(SP)
9D023828  AFB10018   SW S1, 24(SP)
9D02382C  AFB00014   SW S0, 20(SP)
9D023830  00808821   ADDU S1, A0, ZERO
9D023834  AFA50024   SW A1, 36(SP)
474:                    nes6502_setcontext(machine->cpu);
9D023838  0F400073   JAL nes6502_setcontext
9D02383C  8CA40000   LW A0, 0(A1)
475:                 
476:                    /* rom file */
477:                    machine->rominfo = rom_load(file_ptr);
9D023840  8FB00024   LW S0, 36(SP)
9D023844  0F40AD88   JAL rom_load
9D023848  02202021   ADDU A0, S1, ZERO
9D02384C  AE020310   SW V0, 784(S0)
478:                    if (NULL == machine->rominfo)
9D023850  8FB00024   LW S0, 36(SP)
9D023854  8E020310   LW V0, 784(S0)
9D023858  1040012B   BEQ V0, ZERO, .L68
9D02385C  00000000   NOP
479:                       goto _fail;
480:                 
481:                    /* map cart's SRAM to CPU $6000-$7FFF */
482:                    if (machine->rominfo->sram)
9D023860  8C420008   LW V0, 8(V0)
9D023864  10400008   BEQ V0, ZERO, 0x9D023888
9D023868  00000000   NOP
483:                    {
484:                       machine->cpu->mem_page[6] = machine->rominfo->sram;
9D02386C  8E030000   LW V1, 0(S0)
9D023870  AC620018   SW V0, 24(V1)
485:                       machine->cpu->mem_page[7] = machine->rominfo->sram + 0x1000;
9D023874  8E020000   LW V0, 0(S0)
9D023878  8E030310   LW V1, 784(S0)
9D02387C  8C630008   LW V1, 8(V1)
9D023880  24631000   ADDIU V1, V1, 4096
9D023884  AC43001C   SW V1, 28(V0)
486:                    }
487:                 
488:                    /* mapper */
489:                    machine->mmc = mmc_create(machine->rominfo);
9D023888  0F40B560   JAL mmc_create
9D02388C  8E040310   LW A0, 784(S0)
9D023890  AE02030C   SW V0, 780(S0)
490:                    if (NULL == machine->mmc)
9D023894  8FA20024   LW V0, 36(SP)
9D023898  8C43030C   LW V1, 780(V0)
9D02389C  1060011A   BEQ V1, ZERO, .L68
9D0238A0  00000000   NOP
491:                       goto _fail;
492:                 
493:                    /* if there's VRAM, let the PPU know */
494:                    if (NULL != machine->rominfo->vram)
9D0238A4  8C430310   LW V1, 784(V0)
9D0238A8  8C63000C   LW V1, 12(V1)
9D0238AC  10600003   BEQ V1, ZERO, 0x9D0238BC
9D0238B0  24040001   ADDIU A0, ZERO, 1
495:                       machine->ppu->vram_present = true;
9D0238B4  8C430304   LW V1, 772(V0)
9D0238B8  AC641DB0   SW A0, 7600(V1)
496:                    
497:                    apu_setext(machine->apu, machine->mmc->intf->sound_ext);
9D0238BC  8C43030C   LW V1, 780(V0)
9D0238C0  8C630000   LW V1, 0(V1)
9D0238C4  8C440308   LW A0, 776(V0)
9D0238C8  0F407B2B   JAL apu_setext
9D0238CC  8C650024   LW A1, 36(V1)
498:                    
499:                    build_address_handlers(machine);
9D0238D0  8FB10024   LW S1, 36(SP)
500:                 
501:                    nes_setcontext(machine);
9D023CF0  0F408D2C   JAL nes_setcontext
9D023CF4  8FA40024   LW A0, 36(SP)
502:                 
503:                    nes_reset(HARD_RESET);
9D023CF8  0F408D95   JAL nes_reset
9D023CFC  24040001   ADDIU A0, ZERO, 1
504:                    return 0;
9D023D00  0B408F70   J 0x9D023DC0
9D023D04  00001021   ADDU V0, ZERO, ZERO
505:                 
506:                 _fail:
507:                    nes_destroy(&machine);
9D023D08  0F408DDA   JAL nes_destroy
9D023D0C  27A40024   ADDIU A0, SP, 36
508:                    return -1;
9D023D10  0B408F70   J 0x9D023DC0
9D023D14  2402FFFF   ADDIU V0, ZERO, -1
509:                 }
9D023DC0  8FBF001C   LW RA, 28(SP)
9D023DC4  8FB10018   LW S1, 24(SP)
9D023DC8  8FB00014   LW S0, 20(SP)
9D023DCC  03E00008   JR RA
9D023DD0  27BD0020   ADDIU SP, SP, 32
510:                 
511:                 
512:                 /* Initialize NES CPU, hardware, etc. */
513:                 nes_t *nes_create(void)
514:                 {
9D023DD4  27BDFFD8   ADDIU SP, SP, -40
9D023DD8  AFBF0024   SW RA, 36(SP)
9D023DDC  AFB00020   SW S0, 32(SP)
515:                    nes_t *machine;
516:                    sndinfo_t osd_sound;
517:                    int i;
518:                 
519:                    int sizee = sizeof(nes_t);
520:                    
521:                    machine = malloc(sizee);
9D023DE0  0F40DDB7   JAL _my_malloc
9D023DE4  24040334   ADDIU A0, ZERO, 820
522:                    if (NULL == machine)
9D023DE8  10400047   BEQ V0, ZERO, 0x9D023F08
9D023DEC  AFA20010   SW V0, 16(SP)
523:                       return NULL;
9D023F08  00001021   ADDU V0, ZERO, ZERO
524:                 
525:                    memset(machine, 0, sizeof(nes_t));
9D023DF0  00402021   ADDU A0, V0, ZERO
9D023DF4  00002821   ADDU A1, ZERO, ZERO
9D023DF8  0F40E9FC   JAL .Letext0, .LFE0, memset
9D023DFC  24060334   ADDIU A2, ZERO, 820
526:                 
527:                    /* bitmap */
528:                    /* 8 pixel overdraw */
529:                 //   machine->vidbuf = bmp_create(NES_SCREEN_WIDTH, NES_SCREEN_HEIGHT, 8);
530:                 //   if (NULL == machine->vidbuf)
531:                 //      goto _fail;
532:                 
533:                    machine->autoframeskip = true;
9D023E00  8FB00010   LW S0, 16(SP)
9D023E04  24020001   ADDIU V0, ZERO, 1
9D023E08  AE020328   SW V0, 808(S0)
534:                 
535:                    /* cpu */
536:                    machine->cpu = malloc(sizeof(nes6502_context));
9D023E0C  0F40DDB7   JAL _my_malloc
9D023E10  2404005C   ADDIU A0, ZERO, 92
9D023E14  AE020000   SW V0, 0(S0)
537:                    if (NULL == machine->cpu)
9D023E18  8FA20010   LW V0, 16(SP)
9D023E1C  8C440000   LW A0, 0(V0)
9D023E20  10800035   BEQ A0, ZERO, .L114
9D023E24  00002821   ADDU A1, ZERO, ZERO
538:                       goto _fail;
539:                 
540:                    memset(machine->cpu, 0, sizeof(nes6502_context));
9D023E28  0F40E9FC   JAL .Letext0, .LFE0, memset
9D023E2C  2406005C   ADDIU A2, ZERO, 92
541:                    
542:                    /* allocate 2kB RAM */
543:                    machine->cpu->mem_page[0] = malloc(NES_RAMSIZE);
9D023E30  8FA20010   LW V0, 16(SP)
9D023E34  8C500000   LW S0, 0(V0)
9D023E38  0F40DDB7   JAL _my_malloc
9D023E3C  24040800   ADDIU A0, ZERO, 2048
9D023E40  AE020000   SW V0, 0(S0)
544:                    if (NULL == machine->cpu->mem_page[0])
9D023E44  8FA20010   LW V0, 16(SP)
9D023E48  8C420000   LW V0, 0(V0)
9D023E4C  8C420000   LW V0, 0(V0)
9D023E50  10400029   BEQ V0, ZERO, .L114
9D023E54  24050010   ADDIU A1, ZERO, 16
9D023E58  24020001   ADDIU V0, ZERO, 1
545:                       goto _fail;
546:                 
547:                    /* point all pages at NULL for now */
548:                    for (i = 1; i < NES6502_NUMBANKS; i++)
9D023E6C  24420001   ADDIU V0, V0, 1
9D023E70  1445FFFA   BNE V0, A1, 0x9D023E5C
9D023E74  AC600000   SW ZERO, 0(V1)
549:                       machine->cpu->mem_page[i] = NULL;
9D023E5C  8FA30010   LW V1, 16(SP)
9D023E60  8C640000   LW A0, 0(V1)
9D023E64  00021880   SLL V1, V0, 2
9D023E68  00831821   ADDU V1, A0, V1
550:                 
551:                    machine->cpu->read_handler = machine->readhandler;
9D023E78  8FB00010   LW S0, 16(SP)
9D023E7C  8E020000   LW V0, 0(S0)
9D023E80  26030004   ADDIU V1, S0, 4
9D023E84  AC430040   SW V1, 64(V0)
552:                    machine->cpu->write_handler = machine->writehandler;
9D023E88  8E020000   LW V0, 0(S0)
9D023E8C  26030184   ADDIU V1, S0, 388
9D023E90  AC430044   SW V1, 68(V0)
553:                 
554:                    /* apu */
555:                    //osd_getsoundinfo(&osd_sound);
556:                    machine->apu = apu_create(0, osd_sound.sample_rate, NES_REFRESH_RATE, osd_sound.bps);
9D023E94  00002021   ADDU A0, ZERO, ZERO
9D023E98  8FA50014   LW A1, 20(SP)
9D023E9C  2406003C   ADDIU A2, ZERO, 60
9D023EA0  0F407AE1   JAL apu_create
9D023EA4  8FA70018   LW A3, 24(SP)
9D023EA8  AE020308   SW V0, 776(S0)
557:                 
558:                    if (NULL == machine->apu)
9D023EAC  8FB00010   LW S0, 16(SP)
9D023EB0  8E020308   LW V0, 776(S0)
9D023EB4  10400010   BEQ V0, ZERO, .L114
9D023EB8  3C039D02   LUI V1, -25342
559:                       goto _fail;
560:                 
561:                    /* set the IRQ routines */
562:                    machine->apu->irq_callback = nes_irq;
9D023EBC  246331EC   ADDIU V1, V1, 12780
9D023EC0  AC430160   SW V1, 352(V0)
563:                    machine->apu->irqclear_callback = nes_clearfiq;
9D023EC4  8E020308   LW V0, 776(S0)
9D023EC8  3C039D02   LUI V1, -25342
9D023ECC  246331C4   ADDIU V1, V1, 12740
564:                 
565:                    /* ppu */
566:                    machine->ppu = ppu_create();
9D023ED0  0F4065A9   JAL ppu_create
9D023ED4  AC430164   SW V1, 356(V0)
9D023ED8  AE020304   SW V0, 772(S0)
567:                    if (NULL == machine->ppu)
9D023EDC  8FA20010   LW V0, 16(SP)
9D023EE0  8C430304   LW V1, 772(V0)
9D023EE4  10600004   BEQ V1, ZERO, .L114
9D023EE8  00000000   NOP
568:                       goto _fail;
569:                 
570:                    machine->poweroff = false;
9D023EEC  AC40032C   SW ZERO, 812(V0)
571:                    machine->pause = false;
572:                 
573:                    return machine;
9D023EF0  0B408FC3   J 0x9D023F0C
9D023EF4  AC400330   SW ZERO, 816(V0)
574:                 
575:                 _fail:
576:                    nes_destroy(&machine);
9D023EF8  0F408DDA   JAL nes_destroy
9D023EFC  27A40010   ADDIU A0, SP, 16
577:                    return NULL;
9D023F00  0B408FC3   J 0x9D023F0C
9D023F04  00001021   ADDU V0, ZERO, ZERO
578:                 }
9D023F0C  8FBF0024   LW RA, 36(SP)
9D023F10  8FB00020   LW S0, 32(SP)
9D023F14  03E00008   JR RA
9D023F18  27BD0028   ADDIU SP, SP, 40
579:                 
580:                 /*
581:                 ** $Log: nes.c,v $
582:                 ** Revision 1.2  2001/04/27 14:37:11  neil
583:                 ** wheeee
584:                 **
585:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
586:                 ** initial
587:                 **
588:                 ** Revision 1.18  2000/11/29 12:58:23  matt
589:                 ** timing/fiq fixes
590:                 **
591:                 ** Revision 1.17  2000/11/27 19:36:15  matt
592:                 ** more timing fixes
593:                 **
594:                 ** Revision 1.16  2000/11/26 16:13:13  matt
595:                 ** slight fix (?) to nes_fiq
596:                 **
597:                 ** Revision 1.15  2000/11/26 15:51:13  matt
598:                 ** frame IRQ emulation
599:                 **
600:                 ** Revision 1.14  2000/11/25 20:30:39  matt
601:                 ** scanline emulation simplifications/timing fixes
602:                 **
603:                 ** Revision 1.13  2000/11/25 01:53:42  matt
604:                 ** bool stinks sometimes
605:                 **
606:                 ** Revision 1.12  2000/11/21 13:28:40  matt
607:                 ** take care to zero allocated mem
608:                 **
609:                 ** Revision 1.11  2000/11/20 13:23:32  matt
610:                 ** nofrendo.c now handles timer
611:                 **
612:                 ** Revision 1.10  2000/11/09 14:07:27  matt
613:                 ** state load fixed, state save mostly fixed
614:                 **
615:                 ** Revision 1.9  2000/11/05 22:19:37  matt
616:                 ** pause buglet fixed
617:                 **
618:                 ** Revision 1.8  2000/11/05 06:27:09  matt
619:                 ** thinlib spawns changes
620:                 **
621:                 ** Revision 1.7  2000/10/29 14:36:45  matt
622:                 ** nes_clearframeirq is static
623:                 **
624:                 ** Revision 1.6  2000/10/28 15:20:41  matt
625:                 ** irq callbacks in nes_apu
626:                 **
627:                 ** Revision 1.5  2000/10/27 12:55:58  matt
628:                 ** nes6502 now uses 4kB banks across the boards
629:                 **
630:                 ** Revision 1.4  2000/10/25 13:44:02  matt
631:                 ** no more silly define names
632:                 **
633:                 ** Revision 1.3  2000/10/25 01:23:08  matt
634:                 ** basic system autodetection
635:                 **
636:                 ** Revision 1.2  2000/10/25 00:23:16  matt
637:                 ** makefiles updated for new directory structure
638:                 **
639:                 ** Revision 1.1  2000/10/24 12:20:28  matt
640:                 ** changed directory structure
641:                 **
642:                 ** Revision 1.50  2000/10/23 17:51:09  matt
643:                 ** adding fds support
644:                 **
645:                 ** Revision 1.49  2000/10/23 15:53:08  matt
646:                 ** better system handling
647:                 **
648:                 ** Revision 1.48  2000/10/22 20:02:29  matt
649:                 ** autoframeskip bugfix
650:                 **
651:                 ** Revision 1.47  2000/10/22 19:16:15  matt
652:                 ** more sane timer ISR / autoframeskip
653:                 **
654:                 ** Revision 1.46  2000/10/21 19:26:59  matt
655:                 ** many more cleanups
656:                 **
657:                 ** Revision 1.45  2000/10/17 12:00:56  matt
658:                 ** selectable apu base frequency
659:                 **
660:                 ** Revision 1.44  2000/10/10 13:58:14  matt
661:                 ** stroustrup squeezing his way in the door
662:                 **
663:                 ** Revision 1.43  2000/10/10 13:05:30  matt
664:                 ** Mr. Clean makes a guest appearance
665:                 **
666:                 ** Revision 1.42  2000/10/08 17:53:37  matt
667:                 ** minor accuracy changes
668:                 **
669:                 ** Revision 1.41  2000/09/18 02:09:12  matt
670:                 ** -pedantic is your friend
671:                 **
672:                 ** Revision 1.40  2000/09/15 13:38:39  matt
673:                 ** changes for optimized apu core
674:                 **
675:                 ** Revision 1.39  2000/09/15 04:58:07  matt
676:                 ** simplifying and optimizing APU core
677:                 **
678:                 ** Revision 1.38  2000/09/08 11:57:29  matt
679:                 ** no more nes_fiq
680:                 **
681:                 ** Revision 1.37  2000/08/31 02:39:01  matt
682:                 ** moved dos stuff in here (temp)
683:                 **
684:                 ** Revision 1.36  2000/08/16 02:51:55  matt
685:                 ** random cleanups
686:                 **
687:                 ** Revision 1.35  2000/08/11 02:43:50  matt
688:                 ** moved frame irq stuff out of APU into here
689:                 **
690:                 ** Revision 1.34  2000/08/11 01:42:43  matt
691:                 ** change to OSD sound info interface
692:                 **
693:                 ** Revision 1.33  2000/07/31 04:27:59  matt
694:                 ** one million cleanups
695:                 **
696:                 ** Revision 1.32  2000/07/30 04:32:32  matt
697:                 ** emulation of the NES frame IRQ
698:                 **
699:                 ** Revision 1.31  2000/07/27 04:07:14  matt
700:                 ** cleaned up the neighborhood lawns
701:                 **
702:                 ** Revision 1.30  2000/07/27 03:59:52  neil
703:                 ** pausing tweaks, during fullscreen toggles
704:                 **
705:                 ** Revision 1.29  2000/07/27 03:19:22  matt
706:                 ** just a little cleaner, that's all
707:                 **
708:                 ** Revision 1.28  2000/07/27 02:55:23  matt
709:                 ** nes_emulate went through detox
710:                 **
711:                 ** Revision 1.27  2000/07/27 02:49:18  matt
712:                 ** cleaner flow in nes_emulate
713:                 **
714:                 ** Revision 1.26  2000/07/27 01:17:09  matt
715:                 ** nes_insertrom -> nes_insertcart
716:                 **
717:                 ** Revision 1.25  2000/07/26 21:36:14  neil
718:                 ** Big honkin' change -- see the mailing list
719:                 **
720:                 ** Revision 1.24  2000/07/25 02:25:53  matt
721:                 ** safer xxx_destroy calls
722:                 **
723:                 ** Revision 1.23  2000/07/24 04:32:40  matt
724:                 ** autoframeskip bugfix
725:                 **
726:                 ** Revision 1.22  2000/07/23 15:13:48  matt
727:                 ** apu API change, autoframeskip part of nes_t struct
728:                 **
729:                 ** Revision 1.21  2000/07/21 02:44:41  matt
730:                 ** merged osd_getinput and osd_gethostinput
731:                 **
732:                 ** Revision 1.20  2000/07/17 05:12:55  matt
733:                 ** nes_ppu.c is no longer a scary place to be-- cleaner & faster
734:                 **
735:                 ** Revision 1.19  2000/07/17 01:52:28  matt
736:                 ** made sure last line of all source files is a newline
737:                 **
738:                 ** Revision 1.18  2000/07/15 23:51:23  matt
739:                 ** hack for certain filthy NES titles
740:                 **
741:                 ** Revision 1.17  2000/07/11 04:31:54  matt
742:                 ** less magic number nastiness for screen dimensions
743:                 **
744:                 ** Revision 1.16  2000/07/11 02:38:25  matt
745:                 ** encapsulated memory address handlers into nes/nsf
746:                 **
747:                 ** Revision 1.15  2000/07/10 13:50:49  matt
748:                 ** added function nes_irq()
749:                 **
750:                 ** Revision 1.14  2000/07/10 05:27:55  matt
751:                 ** cleaned up mapper-specific callbacks
752:                 **
753:                 ** Revision 1.13  2000/07/09 03:43:26  matt
754:                 ** minor changes to gui handling
755:                 **
756:                 ** Revision 1.12  2000/07/06 16:42:23  matt
757:                 ** updated for new video driver
758:                 **
759:                 ** Revision 1.11  2000/07/05 19:57:36  neil
760:                 ** __GNUC -> __DJGPP in nes.c
761:                 **
762:                 ** Revision 1.10  2000/07/05 12:23:03  matt
763:                 ** removed unnecessary references
764:                 **
765:                 ** Revision 1.9  2000/07/04 23:12:34  matt
766:                 ** memory protection handlers
767:                 **
768:                 ** Revision 1.8  2000/07/04 04:58:29  matt
769:                 ** dynamic memory range handlers
770:                 **
771:                 ** Revision 1.7  2000/06/26 04:58:51  matt
772:                 ** minor bugfix
773:                 **
774:                 ** Revision 1.6  2000/06/20 20:42:12  matt
775:                 ** fixed some NULL pointer problems
776:                 **
777:                 ** Revision 1.5  2000/06/09 15:12:26  matt
778:                 ** initial revision
779:                 **
780:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/memguard.c  --------------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** memguard.c
21:                  **
22:                  ** memory allocation wrapper routines
23:                  **
24:                  ** NOTE: based on code (c) 1998 the Retrocade group
25:                  ** $Id: memguard.c,v 1.2 2001/04/27 14:37:11 neil Exp $
26:                  */
27:                  
28:                  #include <noftypes.h>
29:                  #include <memguard.h>
30:                  
31:                  /* undefine macro definitions, so we get real calls */
32:                  #undef malloc
33:                  #undef free
34:                  #undef strdup
35:                  
36:                  #include <string.h>
37:                  #include <stdlib.h>
38:                  #include <log.h>
39:                  
40:                  
41:                  /* Maximum number of allocated blocks at any one time */
42:                  #define  MAX_BLOCKS        4096
43:                  
44:                  /* Memory block structure */
45:                  typedef struct memblock_s
46:                  {
47:                     void  *block_addr;
48:                     int   block_size;
49:                     char  *file_name;
50:                     int   line_num;
51:                  } memblock_t;
52:                  
53:                  /* debugging flag */
54:                  bool mem_debug = true;
55:                  
56:                  
57:                  #ifdef NOFRENDO_DEBUG
58:                  
59:                  static int mem_blockcount = 0;   /* allocated block count */
60:                  static memblock_t *mem_record = NULL;
61:                  
62:                  #define  GUARD_STRING   "GgUuAaRrDdSsTtRrIiNnGgBbLlOoCcKk"
63:                  #define  GUARD_LENGTH   256         /* before and after allocated block */
64:                  
65:                  
66:                  /*
67:                  ** Check the memory guard to make sure out of bounds writes have not
68:                  ** occurred.
69:                  */
70:                  static int mem_checkguardblock(void *data, int guard_size)
71:                  {
72:                     char *check, *block;
73:                     int i, alloc_size;
74:                  
75:                     /* get the original pointer */
76:                     block = ((char *) data) - guard_size;
77:                  
78:                     /* get the size */
79:                     alloc_size = *((uint32 *) block);
80:                     block+=4;
81:                  
82:                     /* check leading guard string */
83:                     check = GUARD_STRING;
84:                     for (i = sizeof(uint32); i < guard_size; i++)
85:                     {
86:                        /* wrap */
87:                        if ('\0' == *check)
88:                           check = GUARD_STRING;
89:                        
90:                        if (*block++ != *check++)
91:                           return -1;
92:                     }
93:                  
94:                     /* check end of block */
95:                     check = GUARD_STRING;
96:                     block = ((char *) data) + alloc_size;
97:                     for (i = 0; i < guard_size; i++)
98:                     {
99:                        /* wrap */
100:                       if ('\0' == *check)
101:                          check = GUARD_STRING;
102:                       if (*block++ != *check++)
103:                          return -1;
104:                    }
105:                 
106:                    /* we're okay! */
107:                    return 0;
108:                 }
109:                 
110:                 /* free a guard block */
111:                 static void mem_freeguardblock(void *data, int guard_size)
112:                 {
113:                    char *orig = ((char *) data) - guard_size;
114:                 
115:                    free(orig);
116:                 }
117:                 
118:                 /* allocate memory, guarding with a guard block in front and behind */
119:                 static void *mem_guardalloc(int alloc_size, int guard_size)
120:                 {
121:                    void *orig;
122:                    char *block, *check;
123:                    uint32 *ptr;
124:                    int i;
125:                 
126:                    /* pad it up to a 32-bit multiple */
127:                    alloc_size = (alloc_size + 3) & ~3;
128:                 
129:                    /* allocate memory */
130:                    orig = malloc(alloc_size + (guard_size * 2));
131:                    if (NULL == orig)
132:                       return NULL;
133:                 
134:                    block = (char *) orig;
135:                    
136:                    /* get it to the pointer we will actually return */
137:                    orig = (void *) ((char *) orig + guard_size);
138:                 
139:                    /* trash it all */
140:                    ptr = (uint32 *) orig;
141:                    for (i = alloc_size / 4; i; i--)
142:                       *ptr++ = 0xDEADBEEF;
143:                    
144:                    /* store the size of the newly allocated block*/
145:                    *((uint32 *) block) = alloc_size;
146:                 	block+=4;
147:                 
148:                    /* put guard string at beginning of block */
149:                    check = GUARD_STRING;
150:                    for (i = sizeof(uint32); i < guard_size; i++)
151:                    {
152:                       /* wrap */
153:                       if ('\0' == *check)
154:                          check = GUARD_STRING;
155:                 
156:                       *block++ = *check++;
157:                    }
158:                 
159:                    /* put at end of block */
160:                    check = GUARD_STRING;
161:                    block = (char *) orig + alloc_size;
162:                    for (i = 0; i < guard_size; i++)
163:                    {
164:                       /* wrap */
165:                       if ('\0' == *check)
166:                          check = GUARD_STRING;
167:                       
168:                       *block++ = *check++;
169:                    }
170:                 
171:                    return orig;
172:                 }
173:                 
174:                 
175:                 /* Free up the space used by the memory block manager */
176:                 void mem_cleanup(void)
177:                 {
178:                    if (mem_record)
179:                    {
180:                       free(mem_record);
181:                       mem_record = NULL;
182:                    }
183:                 }
184:                 
185:                 
186:                 /* Allocate a bunch of memory to keep track of all memory blocks */
187:                 static void mem_init(void)
188:                 {
189:                    mem_cleanup();
190:                 
191:                    mem_blockcount = 0;
192:                 
193:                    mem_record = malloc(MAX_BLOCKS * sizeof(memblock_t));
194:                    ASSERT(mem_record);
195:                    memset(mem_record, 0, MAX_BLOCKS * sizeof(memblock_t));
196:                 }
197:                 
198:                 
199:                 /* add a block of memory to the master record */
200:                 static void mem_addblock(void *data, int block_size, char *file, int line)
201:                 {
202:                    int i;
203:                 
204:                    for (i = 0; i < MAX_BLOCKS; i++)
205:                    {
206:                       if (NULL == mem_record[i].block_addr)
207:                       {
208:                          mem_record[i].block_addr = data;
209:                          mem_record[i].block_size = block_size;
210:                          mem_record[i].file_name = file;
211:                          mem_record[i].line_num = line;
212:                          return;
213:                       }
214:                    }
215:                 
216:                    ASSERT_MSG("out of memory blocks.");
217:                 }
218:                 
219:                 /* find an entry in the block record and delete it */
220:                 static void mem_deleteblock(void *data, char *file, int line)
221:                 {
222:                    int i;
223:                    char fail[256];
224:                 
225:                    for (i = 0; i < MAX_BLOCKS; i++)
226:                    {
227:                       if (data == mem_record[i].block_addr)
228:                       {
229:                          if (mem_checkguardblock(mem_record[i].block_addr, GUARD_LENGTH))
230:                          {
231:                             sprintf(fail, "mem_deleteblock 0x%08X at line %d of %s -- block corrupt",
232:                                     (uint32) data, line, file);
233:                             ASSERT_MSG(fail);
234:                          }
235:                 
236:                          memset(&mem_record[i], 0, sizeof(memblock_t));
237:                          return;
238:                       }
239:                    }
240:                 
241:                    sprintf(fail, "mem_deleteblock 0x%08X at line %d of %s -- block not found",
242:                            (uint32) data, line, file);
243:                    ASSERT_MSG(fail);
244:                 }
245:                 #endif /* NOFRENDO_DEBUG */
246:                 
247:                 /* debugger-friendly versions of calls */
248:                 #ifdef NOFRENDO_DEBUG
249:                 
250:                 /* allocates memory and clears it */
251:                 void *_my_malloc(int size, char *file, int line)
252:                 {
253:                    void *temp;
254:                    char fail[256];
255:                 
256:                    if (NULL == mem_record && false != mem_debug)
257:                       mem_init();
258:                 
259:                    if (false != mem_debug)
260:                       temp = mem_guardalloc(size, GUARD_LENGTH);
261:                    else
262:                       temp = malloc(size);
263:                 
264:                    printf("Malloc: %d at %s:%d\n", size, file, line);
265:                    if (NULL == temp)
266:                    {
267:                       sprintf(fail, "malloc: out of memory at line %d of %s.  block size: %d\n",
268:                               line, file, size);
269:                       ASSERT_MSG(fail);
270:                    }
271:                 
272:                    if (false != mem_debug)
273:                       mem_addblock(temp, size, file, line);
274:                 
275:                    mem_blockcount++;
276:                 
277:                    return temp;
278:                 }
279:                 
280:                 /* free a pointer allocated with my_malloc */
281:                 void _my_free(void **data, char *file, int line)
282:                 {
283:                    char fail[256];
284:                 
285:                    if (NULL == data || NULL == *data)
286:                    {
287:                       sprintf(fail, "free: attempted to free NULL pointer at line %d of %s\n",
288:                               line, file);
289:                       ASSERT_MSG(fail);
290:                    }
291:                 
292:                    /* if this is true, we are in REAL trouble */
293:                    if (0 == mem_blockcount)
294:                    {
295:                       ASSERT_MSG("free: attempted to free memory when no blocks available");
296:                    }
297:                 
298:                    mem_blockcount--; /* dec our block count */
299:                 
300:                    if (false != mem_debug)
301:                    {
302:                       mem_deleteblock(*data, file, line);
303:                       mem_freeguardblock(*data, GUARD_LENGTH);
304:                    }
305:                    else
306:                    {
307:                       free(*data);
308:                    }
309:                 
310:                    *data = NULL; /* NULL our source */
311:                 }
312:                 
313:                 char *_my_strdup(const char *string, char *file, int line)
314:                 {
315:                    char *temp;
316:                 
317:                    if (NULL == string)
318:                       return NULL;
319:                 
320:                    temp = (char *) _my_malloc(strlen(string) + 1, file, line);
321:                    if (NULL == temp)
322:                       return NULL;
323:                 
324:                    strcpy(temp, string);
325:                 
326:                    return temp;
327:                 }
328:                 
329:                 #else /* !NOFRENDO_DEBUG */
330:                 
331:                 /* allocates memory and clears it */
332:                 void *_my_malloc(int size)
333:                 {
9D0376DC  27BDFEE0   ADDIU SP, SP, -288
9D0376E0  AFBF011C   SW RA, 284(SP)
9D0376E4  AFB10118   SW S1, 280(SP)
9D0376E8  AFB00114   SW S0, 276(SP)
334:                    void *temp;
335:                    char fail[256];
336:                 
337:                    temp = malloc(size);
9D0376EC  0F40AE73   JAL .Letext0, .LFE16, malloc
9D0376F0  00808821   ADDU S1, A0, ZERO
338:                 
339:                    if (NULL == temp)
9D0376F4  14400006   BNE V0, ZERO, .LVL2
9D0376F8  00408021   ADDU S0, V0, ZERO
340:                    {
341:                       sprintf(fail, "malloc: out of memory.  block size: %d\n", size);
9D0376FC  27A40010   ADDIU A0, SP, 16
9D037700  3C059D04   LUI A1, -25340
9D037704  24A5BF6C   ADDIU A1, A1, -16532
9D037708  0F40EDE4   JAL _sprintf_cdnopuxX, _sprintf_cdnopsuxX
9D03770C  02203021   ADDU A2, S1, ZERO
342:                       ASSERT_MSG(fail);
343:                    }
344:                 
345:                    return temp;
346:                 }
9D037710  02001021   ADDU V0, S0, ZERO
9D037714  8FBF011C   LW RA, 284(SP)
9D037718  8FB10118   LW S1, 280(SP)
9D03771C  8FB00114   LW S0, 276(SP)
9D037720  03E00008   JR RA
9D037724  27BD0120   ADDIU SP, SP, 288
347:                 
348:                 /* free a pointer allocated with my_malloc */
349:                 void _my_free(void **data)
350:                 {
9D037728  27BDFEE8   ADDIU SP, SP, -280
9D03772C  AFBF0114   SW RA, 276(SP)
9D037730  AFB00110   SW S0, 272(SP)
351:                    char fail[256];
352:                 
353:                    if (NULL == data || NULL == *data)
9D037734  10800004   BEQ A0, ZERO, 0x9D037748
9D037738  00808021   ADDU S0, A0, ZERO
9D03773C  8C820000   LW V0, 0(A0)
9D037740  14400016   BNE V0, ZERO, 0x9D03779C
9D037744  00000000   NOP
354:                    {
355:                       sprintf(fail, "free: attempted to free NULL pointer.\n");
9D037748  3C029D04   LUI V0, -25340
9D03774C  2442BF94   ADDIU V0, V0, -16492
9D037750  27A30010   ADDIU V1, SP, 16
9D037754  24440020   ADDIU A0, V0, 32
9D037758  8C480000   LW T0, 0(V0)
9D03775C  8C470004   LW A3, 4(V0)
9D037760  8C460008   LW A2, 8(V0)
9D037764  8C45000C   LW A1, 12(V0)
9D037768  AC680000   SW T0, 0(V1)
9D03776C  AC670004   SW A3, 4(V1)
9D037770  AC660008   SW A2, 8(V1)
9D037774  AC65000C   SW A1, 12(V1)
9D037778  24420010   ADDIU V0, V0, 16
9D03777C  1444FFF6   BNE V0, A0, 0x9D037758
9D037780  24630010   ADDIU V1, V1, 16
9D037784  8C440000   LW A0, 0(V0)
9D037788  AC640000   SW A0, 0(V1)
9D03778C  94440004   LHU A0, 4(V0)
9D037790  A4640004   SH A0, 4(V1)
9D037794  90420006   LBU V0, 6(V0)
9D037798  A0620006   SB V0, 6(V1)
356:                       ASSERT_MSG(fail);
357:                    }
358:                 
359:                    free(*data);
9D03779C  0F40D0ED   JAL free
9D0377A0  8E040000   LW A0, 0(S0)
360:                    *data = NULL; /* NULL our source */
9D0377A4  AE000000   SW ZERO, 0(S0)
361:                 }
9D0377A8  8FBF0114   LW RA, 276(SP)
9D0377AC  8FB00110   LW S0, 272(SP)
9D0377B0  03E00008   JR RA
9D0377B4  27BD0118   ADDIU SP, SP, 280
362:                 
363:                 char *_my_strdup(const char *string)
364:                 {
9D0377B8  27BDFFE0   ADDIU SP, SP, -32
9D0377BC  AFBF001C   SW RA, 28(SP)
9D0377C0  AFB10018   SW S1, 24(SP)
9D0377C4  AFB00014   SW S0, 20(SP)
365:                    char *temp;
366:                 
367:                    if (NULL == string)
9D0377C8  1080000C   BEQ A0, ZERO, 0x9D0377FC
9D0377CC  00808021   ADDU S0, A0, ZERO
368:                       return NULL;
9D0377FC  0B40DE01   J 0x9D037804
9D037800  00001021   ADDU V0, ZERO, ZERO
369:                 
370:                    /* will ASSERT for us */
371:                    temp = (char *) _my_malloc(strlen(string) + 1);
9D0377D0  0F40DBFE   JAL strlen
9D0377D4  00000000   NOP
9D0377D8  0F40DDB7   JAL _my_malloc
9D0377DC  24440001   ADDIU A0, V0, 1
372:                    if (NULL == temp)
9D0377E0  10400008   BEQ V0, ZERO, 0x9D037804
9D0377E4  00408821   ADDU S1, V0, ZERO
373:                       return NULL;
374:                 
375:                    strcpy(temp, string);
9D0377E8  00402021   ADDU A0, V0, ZERO
9D0377EC  0F40D947   JAL .LFE23, strcpy
9D0377F0  02002821   ADDU A1, S0, ZERO
376:                 
377:                    return temp;
9D0377F4  0B40DE01   J 0x9D037804
9D0377F8  02201021   ADDU V0, S1, ZERO
378:                 }
9D037804  8FBF001C   LW RA, 28(SP)
9D037808  8FB10018   LW S1, 24(SP)
9D03780C  8FB00014   LW S0, 20(SP)
9D037810  03E00008   JR RA
9D037814  27BD0020   ADDIU SP, SP, 32
379:                 
380:                 #endif /* !NOFRENDO_DEBUG */
381:                 
382:                 /* check for orphaned memory handles */
383:                 void mem_checkleaks(void)
384:                 {
9D037818  03E00008   JR RA
9D03781C  00000000   NOP
385:                 #ifdef NOFRENDO_DEBUG
386:                    int i;
387:                 
388:                    if (false == mem_debug || NULL == mem_record)
389:                       return;
390:                 
391:                    if (mem_blockcount)
392:                    {
393:                       log_printf("memory leak - %d unfreed block%s\n\n", mem_blockcount, 
394:                          mem_blockcount == 1 ? "" : "s");
395:                 
396:                       for (i = 0; i < MAX_BLOCKS; i++)
397:                       {
398:                          if (mem_record[i].block_addr)
399:                          {
400:                             log_printf("addr: 0x%08X, size: %d, line %d of %s%s\n",
401:                                     (uint32) mem_record[i].block_addr,
402:                                     mem_record[i].block_size,
403:                                     mem_record[i].line_num,
404:                                     mem_record[i].file_name,
405:                                     (mem_checkguardblock(mem_record[i].block_addr, GUARD_LENGTH))
406:                                     ? " -- block corrupt" : "");
407:                          }
408:                       }
409:                    }
410:                    else
411:                       log_printf("no memory leaks\n");
412:                 #endif /* NOFRENDO_DEBUG */
413:                 }
414:                 
415:                 void mem_checkblocks(void)
416:                 {
9D037820  03E00008   JR RA
417:                 #ifdef NOFRENDO_DEBUG
418:                    int i;
419:                 
420:                    if (false == mem_debug || NULL == mem_record)
421:                       return;
422:                 
423:                    for (i = 0; i < MAX_BLOCKS; i++)
424:                    {
425:                       if (mem_record[i].block_addr)
426:                       {
427:                          if (mem_checkguardblock(mem_record[i].block_addr, GUARD_LENGTH))
428:                          {
429:                             log_printf("addr: 0x%08X, size: %d, line %d of %s -- block corrupt\n",
430:                                     (uint32) mem_record[i].block_addr,
431:                                     mem_record[i].block_size,
432:                                     mem_record[i].line_num,
433:                                     mem_record[i].file_name);
434:                          }
435:                       }
436:                    }
437:                 #endif /* NOFRENDO_DEBUG */
438:                 }
439:                 
440:                 /*
441:                 ** $Log: memguard.c,v $
442:                 ** Revision 1.2  2001/04/27 14:37:11  neil
443:                 ** wheeee
444:                 **
445:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
446:                 ** initial
447:                 **
448:                 ** Revision 1.23  2000/11/24 21:42:48  matt
449:                 ** vc complaints
450:                 **
451:                 ** Revision 1.22  2000/11/21 13:27:30  matt
452:                 ** trash all newly allocated memory
453:                 **
454:                 ** Revision 1.21  2000/11/21 13:22:30  matt
455:                 ** memory guard shouldn't zero memory for us
456:                 **
457:                 ** Revision 1.20  2000/10/28 14:01:53  matt
458:                 ** memguard.h was being included in the wrong place
459:                 **
460:                 ** Revision 1.19  2000/10/26 22:48:33  matt
461:                 ** strdup'ing a NULL ptr returns NULL
462:                 **
463:                 ** Revision 1.18  2000/10/25 13:41:29  matt
464:                 ** added strdup
465:                 **
466:                 ** Revision 1.17  2000/10/10 13:58:13  matt
467:                 ** stroustrup squeezing his way in the door
468:                 **
469:                 ** Revision 1.16  2000/10/10 13:03:54  matt
470:                 ** Mr. Clean makes a guest appearance
471:                 **
472:                 ** Revision 1.15  2000/09/18 02:06:48  matt
473:                 ** -pedantic is your friend
474:                 **
475:                 ** Revision 1.14  2000/08/11 01:45:48  matt
476:                 ** hearing about no corrupt blocks every 10 seconds really was annoying
477:                 **
478:                 ** Revision 1.13  2000/07/31 04:28:46  matt
479:                 ** one million cleanups
480:                 **
481:                 ** Revision 1.12  2000/07/24 04:31:07  matt
482:                 ** mem_checkblocks now gives feedback
483:                 **
484:                 ** Revision 1.11  2000/07/06 17:20:52  matt
485:                 ** block manager space itself wasn't being freed - d'oh!
486:                 **
487:                 ** Revision 1.10  2000/07/06 17:15:43  matt
488:                 ** false isn't NULL, Neil... =)
489:                 **
490:                 ** Revision 1.9  2000/07/05 23:10:01  neil
491:                 ** It's a shame if the memguard segfaults
492:                 **
493:                 ** Revision 1.8  2000/06/26 04:54:48  matt
494:                 ** simplified and made more robust
495:                 **
496:                 ** Revision 1.7  2000/06/12 01:11:41  matt
497:                 ** cleaned up some error output for win32
498:                 **
499:                 ** Revision 1.6  2000/06/09 15:12:25  matt
500:                 ** initial revision
501:                 **
502:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/mapvrc.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map_vrc.c
21:                  **
22:                  ** VRC mapper interface
23:                  ** $Id: mapvrc.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes.h>
29:                  #include <log.h>
30:                  
31:                  #define VRC_VBANK(bank, value, high) \
32:                  { \
33:                     if ((high)) \
34:                        highnybbles[(bank)] = (value) & 0x0F; \
35:                     else \
36:                        lownybbles[(bank)] = (value) & 0x0F; \
37:                     mmc_bankvrom(1, (bank) << 10, (highnybbles[(bank)] << 4)+lownybbles[(bank)]); \
38:                  }
39:                  
40:                  static struct
41:                  {
42:                     int counter, enabled;
43:                     int latch, wait_state;
44:                  } irq;
45:                  
46:                  static int select_c000 = 0;
47:                  static uint8 lownybbles[8];
48:                  static uint8 highnybbles[8];
49:                  
50:                  static void vrc_init(void)
51:                  {
52:                     irq.counter = irq.enabled = 0;
9D02228C  3C03A001   LUI V1, -24575
9D022290  2462B8BC   ADDIU V0, V1, -18244
9D022294  AC400004   SW ZERO, 4(V0)
9D022298  AC60B8BC   SW ZERO, -18244(V1)
53:                     irq.latch = irq.wait_state = 0;
9D02229C  AC40000C   SW ZERO, 12(V0)
9D0222A0  03E00008   JR RA
9D0222A4  AC400008   SW ZERO, 8(V0)
54:                  }
55:                  
56:                  static void map21_write(uint32 address, uint8 value)
57:                  {
9D0222E0  27BDFFE8   ADDIU SP, SP, -24
9D0222E4  AFBF0014   SW RA, 20(SP)
58:                     switch (address)
9D0222E8  3402D002   ORI V0, ZERO, -12286
9D0222EC  10820151   BEQ A0, V0, 0x9D022834
9D0222F0  00A03021   ADDU A2, A1, ZERO
9D0222F4  3402D003   ORI V0, ZERO, -12285
9D0222F8  0082102B   SLTU V0, A0, V0
9D0222FC  10400061   BEQ V0, ZERO, 0x9D022484
9D022300  3402B080   ORI V0, ZERO, -20352
9D022304  10820108   BEQ A0, V0, 0x9D022728
9D022308  3402B081   ORI V0, ZERO, -20351
9D02230C  0082102B   SLTU V0, A0, V0
9D022310  1040002C   BEQ V0, ZERO, 0x9D0223C4
9D022314  3402B001   ORI V0, ZERO, -20479
9D022318  10820103   BEQ A0, V0, 0x9D022728
9D02231C  3402B002   ORI V0, ZERO, -20478
9D022320  0082102B   SLTU V0, A0, V0
9D022324  10400013   BEQ V0, ZERO, 0x9D022374
9D022328  34029002   ORI V0, ZERO, -28670
9D02232C  108200E4   BEQ A0, V0, 0x9D0226C0
9D022330  34029003   ORI V0, ZERO, -28669
9D022334  0082102B   SLTU V0, A0, V0
9D022338  10400008   BEQ V0, ZERO, 0x9D02235C
9D02233C  3402A000   ORI V0, ZERO, -24576
9D022340  34028000   ORI V0, ZERO, -32768
9D022344  108200B0   BEQ A0, V0, 0x9D022608
9D022348  34029000   ORI V0, ZERO, -28672
9D02234C  508200B9   BEQL A0, V0, 0x9D022634
9D022350  30A60003   ANDI A2, A1, 3
9D02235C  108200DB   BEQ A0, V0, 0x9D0226CC
9D022360  3402B000   ORI V0, ZERO, -20480
9D022364  508200DE   BEQL A0, V0, 0x9D0226E0
9D022368  30A6000F   ANDI A2, A1, 15
9D022374  3402B004   ORI V0, ZERO, -20476
9D022378  108200EB   BEQ A0, V0, 0x9D022728
9D02237C  3402B005   ORI V0, ZERO, -20475
9D022380  0082102B   SLTU V0, A0, V0
9D022384  10400009   BEQ V0, ZERO, 0x9D0223AC
9D022388  3402B006   ORI V0, ZERO, -20474
9D02238C  3402B002   ORI V0, ZERO, -20478
9D022390  508200DC   BEQL A0, V0, 0x9D022704
9D022394  30C6000F   ANDI A2, A2, 15
9D022398  3402B003   ORI V0, ZERO, -20477
9D02239C  508200ED   BEQL A0, V0, 0x9D022754
9D0223A0  30C6000F   ANDI A2, A2, 15
9D0223AC  108200E8   BEQ A0, V0, 0x9D022750
9D0223B0  3402B040   ORI V0, ZERO, -20416
9D0223B4  508200D3   BEQL A0, V0, 0x9D022704
9D0223B8  30C6000F   ANDI A2, A2, 15
9D0223C4  3402C004   ORI V0, ZERO, -16380
9D0223C8  108200FD   BEQ A0, V0, 0x9D0227C0
9D0223CC  3402C005   ORI V0, ZERO, -16379
9D0223D0  0082102B   SLTU V0, A0, V0
9D0223D4  10400015   BEQ V0, ZERO, 0x9D02242C
9D0223D8  3402C080   ORI V0, ZERO, -16256
9D0223DC  3402C001   ORI V0, ZERO, -16383
9D0223E0  108200F7   BEQ A0, V0, 0x9D0227C0
9D0223E4  3402C002   ORI V0, ZERO, -16382
9D0223E8  0082102B   SLTU V0, A0, V0
9D0223EC  10400007   BEQ V0, ZERO, 0x9D02240C
9D0223F0  3402B0C0   ORI V0, ZERO, -20288
9D0223F4  108200D6   BEQ A0, V0, 0x9D022750
9D0223F8  3402C000   ORI V0, ZERO, -16384
9D0223FC  508200DE   BEQL A0, V0, 0x9D022778
9D022400  30A6000F   ANDI A2, A1, 15
9D02240C  3402C002   ORI V0, ZERO, -16382
9D022410  508200E2   BEQL A0, V0, 0x9D02279C
9D022414  30C6000F   ANDI A2, A2, 15
9D022418  3402C003   ORI V0, ZERO, -16381
9D02241C  508200F3   BEQL A0, V0, 0x9D0227EC
9D022420  30C6000F   ANDI A2, A2, 15
9D02242C  108200E4   BEQ A0, V0, 0x9D0227C0
9D022430  3402C081   ORI V0, ZERO, -16255
9D022434  0082102B   SLTU V0, A0, V0
9D022438  10400008   BEQ V0, ZERO, 0x9D02245C
9D02243C  3402D000   ORI V0, ZERO, -12288
9D022440  3402C006   ORI V0, ZERO, -16378
9D022444  108200E8   BEQ A0, V0, 0x9D0227E8
9D022448  3402C040   ORI V0, ZERO, -16320
9D02244C  508200D3   BEQL A0, V0, 0x9D02279C
9D022450  30C6000F   ANDI A2, A2, 15
9D02245C  508200EC   BEQL A0, V0, 0x9D022810
9D022460  30A6000F   ANDI A2, A1, 15
9D022464  3402D001   ORI V0, ZERO, -12287
9D022468  0082102B   SLTU V0, A0, V0
9D02246C  104000FB   BEQ V0, ZERO, 0x9D02285C
9D022470  3402C0C0   ORI V0, ZERO, -16192
9D022474  508200DD   BEQL A0, V0, 0x9D0227EC
9D022478  30C6000F   ANDI A2, A2, 15
9D022484  3402E006   ORI V0, ZERO, -8186
9D022488  10820124   BEQ A0, V0, 0x9D02291C
9D02248C  3402E007   ORI V0, ZERO, -8185
9D022490  0082102B   SLTU V0, A0, V0
9D022494  1040002E   BEQ V0, ZERO, 0x9D022550
9D022498  3402F002   ORI V0, ZERO, -4094
9D02249C  3402D0C0   ORI V0, ZERO, -12096
9D0224A0  108200F8   BEQ A0, V0, 0x9D022884
9D0224A4  3402D0C1   ORI V0, ZERO, -12095
9D0224A8  0082102B   SLTU V0, A0, V0
9D0224AC  10400015   BEQ V0, ZERO, 0x9D022504
9D0224B0  3402E002   ORI V0, ZERO, -8190
9D0224B4  3402D006   ORI V0, ZERO, -12282
9D0224B8  108200F2   BEQ A0, V0, 0x9D022884
9D0224BC  3402D007   ORI V0, ZERO, -12281
9D0224C0  0082102B   SLTU V0, A0, V0
9D0224C4  10400008   BEQ V0, ZERO, 0x9D0224E8
9D0224C8  3402D040   ORI V0, ZERO, -12224
9D0224CC  3402D003   ORI V0, ZERO, -12285
9D0224D0  108200EC   BEQ A0, V0, 0x9D022884
9D0224D4  3402D004   ORI V0, ZERO, -12284
9D0224D8  508200E1   BEQL A0, V0, 0x9D022860
9D0224DC  30C6000F   ANDI A2, A2, 15
9D0224E8  508200D3   BEQL A0, V0, 0x9D022838
9D0224EC  30C6000F   ANDI A2, A2, 15
9D0224F0  3402D080   ORI V0, ZERO, -12160
9D0224F4  508200DA   BEQL A0, V0, 0x9D022860
9D0224F8  30C6000F   ANDI A2, A2, 15
9D022504  108200F2   BEQ A0, V0, 0x9D0228D0
9D022508  3402E003   ORI V0, ZERO, -8189
9D02250C  0082102B   SLTU V0, A0, V0
9D022510  10400008   BEQ V0, ZERO, 0x9D022534
9D022514  3402E000   ORI V0, ZERO, -8192
9D022518  508200E4   BEQL A0, V0, 0x9D0228AC
9D02251C  30A6000F   ANDI A2, A1, 15
9D022520  3402E001   ORI V0, ZERO, -8191
9D022524  508200F4   BEQL A0, V0, 0x9D0228F8
9D022528  30C6000F   ANDI A2, A2, 15
9D022534  3402E003   ORI V0, ZERO, -8189
9D022538  108200F8   BEQ A0, V0, 0x9D02291C
9D02253C  3402E004   ORI V0, ZERO, -8188
9D022540  508200ED   BEQL A0, V0, 0x9D0228F8
9D022544  30C6000F   ANDI A2, A2, 15
9D022550  10820103   BEQ A0, V0, 0x9D022960
9D022554  3402F003   ORI V0, ZERO, -4093
9D022558  0082102B   SLTU V0, A0, V0
9D02255C  10400015   BEQ V0, ZERO, 0x9D0225B4
9D022560  3402E0C0   ORI V0, ZERO, -8000
9D022564  108200ED   BEQ A0, V0, 0x9D02291C
9D022568  3402E0C1   ORI V0, ZERO, -7999
9D02256C  0082102B   SLTU V0, A0, V0
9D022570  10400009   BEQ V0, ZERO, 0x9D022598
9D022574  3402F000   ORI V0, ZERO, -4096
9D022578  3402E040   ORI V0, ZERO, -8128
9D02257C  508200D5   BEQL A0, V0, 0x9D0228D4
9D022580  30C6000F   ANDI A2, A2, 15
9D022584  3402E080   ORI V0, ZERO, -8064
9D022588  508200DB   BEQL A0, V0, 0x9D0228F8
9D02258C  30C6000F   ANDI A2, A2, 15
9D022598  108200EA   BEQ A0, V0, 0x9D022944
9D02259C  3C02A001   LUI V0, -24575
9D0225A0  3402F001   ORI V0, ZERO, -4095
9D0225A4  108200F8   BEQ A0, V0, 0x9D022988
9D0225A8  3C03A001   LUI V1, -24575
9D0225B4  3402F006   ORI V0, ZERO, -4090
9D0225B8  108200FB   BEQ A0, V0, 0x9D0229A8
9D0225BC  3402F007   ORI V0, ZERO, -4089
9D0225C0  0082102B   SLTU V0, A0, V0
9D0225C4  10400008   BEQ V0, ZERO, 0x9D0225E8
9D0225C8  3402F080   ORI V0, ZERO, -3968
9D0225CC  3402F003   ORI V0, ZERO, -4093
9D0225D0  108200F5   BEQ A0, V0, 0x9D0229A8
9D0225D4  3402F004   ORI V0, ZERO, -4092
9D0225D8  108200EB   BEQ A0, V0, 0x9D022988
9D0225DC  3C03A001   LUI V1, -24575
9D0225E8  108200E6   BEQ A0, V0, 0x9D022984
9D0225EC  3402F0C0   ORI V0, ZERO, -3904
9D0225F0  108200ED   BEQ A0, V0, 0x9D0229A8
9D0225F4  3402F040   ORI V0, ZERO, -4032
9D0225F8  108200DA   BEQ A0, V0, 0x9D022964
9D0225FC  3C02A001   LUI V0, -24575
59:                     {
60:                     case 0x8000:
61:                        if (select_c000) 
9D022608  8F8280D0   LW V0, -32560(GP)
9D02260C  10400005   BEQ V0, ZERO, 0x9D022624
9D022610  24040008   ADDIU A0, ZERO, 8
62:                           mmc_bankrom(8, 0xC000,value);
9D022614  0F40B479   JAL mmc_bankrom
9D022618  3405C000   ORI A1, ZERO, -16384
9D02261C  0B408A6F   J 0x9D0229BC
9D022620  8FBF0014   LW RA, 20(SP)
63:                        else
64:                           mmc_bankrom(8, 0x8000,value);
9D022624  0F40B479   JAL mmc_bankrom
9D022628  34058000   ORI A1, ZERO, -32768
65:                        break;
66:                  
67:                     case 0x9000:
68:                        switch (value & 3)
9D022634  24020001   ADDIU V0, ZERO, 1
9D022638  10C2000F   BEQ A2, V0, 0x9D022678
9D02263C  00002021   ADDU A0, ZERO, ZERO
9D022640  10C00007   BEQ A2, ZERO, 0x9D022660
9D022644  24020002   ADDIU V0, ZERO, 2
9D022648  10C20011   BEQ A2, V0, 0x9D022690
9D02264C  24020003   ADDIU V0, ZERO, 3
9D022650  10C20015   BEQ A2, V0, 0x9D0226A8
9D022654  24040001   ADDIU A0, ZERO, 1
69:                        {
70:                        case 0:
71:                           ppu_mirror(0, 1, 0, 1); /* vertical */
9D022660  24050001   ADDIU A1, ZERO, 1
9D022664  00003021   ADDU A2, ZERO, ZERO
9D022668  0F40635D   JAL ppu_mirror
9D02266C  24070001   ADDIU A3, ZERO, 1
72:                           break;
9D022670  0B408A6F   J 0x9D0229BC
9D022674  8FBF0014   LW RA, 20(SP)
73:                  
74:                        case 1: 
75:                           ppu_mirror(0, 0, 1, 1); /* horizontal */
9D022678  00002821   ADDU A1, ZERO, ZERO
9D02267C  24060001   ADDIU A2, ZERO, 1
9D022680  0F40635D   JAL ppu_mirror
9D022684  24070001   ADDIU A3, ZERO, 1
76:                           break;
9D022688  0B408A6F   J 0x9D0229BC
9D02268C  8FBF0014   LW RA, 20(SP)
77:                  
78:                        case 2: 
79:                           ppu_mirror(0, 0, 0, 0); 
9D022690  00002821   ADDU A1, ZERO, ZERO
9D022694  00003021   ADDU A2, ZERO, ZERO
9D022698  0F40635D   JAL ppu_mirror
9D02269C  00003821   ADDU A3, ZERO, ZERO
80:                           break;
9D0226A0  0B408A6F   J 0x9D0229BC
9D0226A4  8FBF0014   LW RA, 20(SP)
81:                  
82:                        case 3: 
83:                           ppu_mirror(1, 1, 1, 1); 
9D0226A8  24050001   ADDIU A1, ZERO, 1
9D0226AC  24060001   ADDIU A2, ZERO, 1
9D0226B0  0F40635D   JAL ppu_mirror
9D0226B4  24070001   ADDIU A3, ZERO, 1
84:                           break;
9D0226B8  0B408A6F   J 0x9D0229BC
9D0226BC  8FBF0014   LW RA, 20(SP)
85:                  
86:                        default: 
87:                           break;
88:                        }
89:                        break;
90:                     case 0x9002: select_c000=(value&0x02)>>1; break;
9D0226C0  7CA60040   EXT A2, A1, 1, 1
9D0226C4  0B408A6E   J 0x9D0229B8
9D0226C8  AF8680D0   SW A2, -32560(GP)
91:                     case 0xA000: mmc_bankrom(8, 0xA000,value); break;
9D0226CC  24040008   ADDIU A0, ZERO, 8
9D0226D0  0F40B479   JAL mmc_bankrom
9D0226D4  3405A000   ORI A1, ZERO, -24576
9D0226D8  0B408A6F   J 0x9D0229BC
9D0226DC  8FBF0014   LW RA, 20(SP)
92:                  
93:                     case 0xB000: VRC_VBANK(0,value,0); break;
9D0226E0  A38680C8   SB A2, -32568(GP)
9D0226E4  938280C0   LBU V0, -32576(GP)
9D0226E8  00021100   SLL V0, V0, 4
9D0226EC  24040001   ADDIU A0, ZERO, 1
9D0226F0  00002821   ADDU A1, ZERO, ZERO
9D0226F4  0F40B41B   JAL mmc_bankvrom
9D0226F8  00463021   ADDU A2, V0, A2
9D0226FC  0B408A6F   J 0x9D0229BC
9D022700  8FBF0014   LW RA, 20(SP)
94:                     case 0xB002:
95:                     case 0xB040: VRC_VBANK(0,value,1); break;
9D022704  A38680C0   SB A2, -32576(GP)
9D022708  00063100   SLL A2, A2, 4
9D02270C  938280C8   LBU V0, -32568(GP)
9D022710  24040001   ADDIU A0, ZERO, 1
9D022714  00002821   ADDU A1, ZERO, ZERO
9D022718  0F40B41B   JAL mmc_bankvrom
9D02271C  00C23021   ADDU A2, A2, V0
9D022720  0B408A6F   J 0x9D0229BC
9D022724  8FBF0014   LW RA, 20(SP)
96:                     case 0xB001:
97:                     case 0xB004:
98:                     case 0xB080: VRC_VBANK(1,value,0); break;
9D022728  30C6000F   ANDI A2, A2, 15
9D02272C  A38680C9   SB A2, -32567(GP)
9D022730  938280C1   LBU V0, -32575(GP)
9D022734  00021100   SLL V0, V0, 4
9D022738  24040001   ADDIU A0, ZERO, 1
9D02273C  24050400   ADDIU A1, ZERO, 1024
9D022740  0F40B41B   JAL mmc_bankvrom
9D022744  00463021   ADDU A2, V0, A2
9D022748  0B408A6F   J 0x9D0229BC
9D02274C  8FBF0014   LW RA, 20(SP)
99:                     case 0xB003:
100:                    case 0xB006:
101:                    case 0xB0C0: VRC_VBANK(1,value,1); break;
9D022750  30C6000F   ANDI A2, A2, 15
9D022754  A38680C1   SB A2, -32575(GP)
9D022758  00063100   SLL A2, A2, 4
9D02275C  938280C9   LBU V0, -32567(GP)
9D022760  24040001   ADDIU A0, ZERO, 1
9D022764  24050400   ADDIU A1, ZERO, 1024
9D022768  0F40B41B   JAL mmc_bankvrom
9D02276C  00C23021   ADDU A2, A2, V0
9D022770  0B408A6F   J 0x9D0229BC
9D022774  8FBF0014   LW RA, 20(SP)
102:                    case 0xC000: VRC_VBANK(2,value,0); break;
9D022778  A38680CA   SB A2, -32566(GP)
9D02277C  938280C2   LBU V0, -32574(GP)
9D022780  00021100   SLL V0, V0, 4
9D022784  24040001   ADDIU A0, ZERO, 1
9D022788  24050800   ADDIU A1, ZERO, 2048
9D02278C  0F40B41B   JAL mmc_bankvrom
9D022790  00463021   ADDU A2, V0, A2
9D022794  0B408A6F   J 0x9D0229BC
9D022798  8FBF0014   LW RA, 20(SP)
103:                    case 0xC002:
104:                    case 0xC040: VRC_VBANK(2,value,1); break;
9D02279C  A38680C2   SB A2, -32574(GP)
9D0227A0  00063100   SLL A2, A2, 4
9D0227A4  938280CA   LBU V0, -32566(GP)
9D0227A8  24040001   ADDIU A0, ZERO, 1
9D0227AC  24050800   ADDIU A1, ZERO, 2048
9D0227B0  0F40B41B   JAL mmc_bankvrom
9D0227B4  00C23021   ADDU A2, A2, V0
9D0227B8  0B408A6F   J 0x9D0229BC
9D0227BC  8FBF0014   LW RA, 20(SP)
105:                    case 0xC001:
106:                    case 0xC004:
107:                    case 0xC080: VRC_VBANK(3,value,0); break;
9D0227C0  30C6000F   ANDI A2, A2, 15
9D0227C4  A38680CB   SB A2, -32565(GP)
9D0227C8  938280C3   LBU V0, -32573(GP)
9D0227CC  00021100   SLL V0, V0, 4
9D0227D0  24040001   ADDIU A0, ZERO, 1
9D0227D4  24050C00   ADDIU A1, ZERO, 3072
9D0227D8  0F40B41B   JAL mmc_bankvrom
9D0227DC  00463021   ADDU A2, V0, A2
9D0227E0  0B408A6F   J 0x9D0229BC
9D0227E4  8FBF0014   LW RA, 20(SP)
108:                    case 0xC003:
109:                    case 0xC006:
110:                    case 0xC0C0: VRC_VBANK(3,value,1); break;
9D0227E8  30C6000F   ANDI A2, A2, 15
9D0227EC  A38680C3   SB A2, -32573(GP)
9D0227F0  00063100   SLL A2, A2, 4
9D0227F4  938280CB   LBU V0, -32565(GP)
9D0227F8  24040001   ADDIU A0, ZERO, 1
9D0227FC  24050C00   ADDIU A1, ZERO, 3072
9D022800  0F40B41B   JAL mmc_bankvrom
9D022804  00C23021   ADDU A2, A2, V0
9D022808  0B408A6F   J 0x9D0229BC
9D02280C  8FBF0014   LW RA, 20(SP)
111:                    case 0xD000: VRC_VBANK(4,value,0); break;
9D022810  A38680CC   SB A2, -32564(GP)
9D022814  938280C4   LBU V0, -32572(GP)
9D022818  00021100   SLL V0, V0, 4
9D02281C  24040001   ADDIU A0, ZERO, 1
9D022820  24051000   ADDIU A1, ZERO, 4096
9D022824  0F40B41B   JAL mmc_bankvrom
9D022828  00463021   ADDU A2, V0, A2
9D02282C  0B408A6F   J 0x9D0229BC
9D022830  8FBF0014   LW RA, 20(SP)
112:                    case 0xD002:
113:                    case 0xD040: VRC_VBANK(4,value,1); break;
9D022834  30C6000F   ANDI A2, A2, 15
9D022838  A38680C4   SB A2, -32572(GP)
9D02283C  00063100   SLL A2, A2, 4
9D022840  938280CC   LBU V0, -32564(GP)
9D022844  24040001   ADDIU A0, ZERO, 1
9D022848  24051000   ADDIU A1, ZERO, 4096
9D02284C  0F40B41B   JAL mmc_bankvrom
9D022850  00C23021   ADDU A2, A2, V0
9D022854  0B408A6F   J 0x9D0229BC
9D022858  8FBF0014   LW RA, 20(SP)
114:                    case 0xD001:
115:                    case 0xD004:
116:                    case 0xD080: VRC_VBANK(5,value,0); break;
9D02285C  30C6000F   ANDI A2, A2, 15
9D022860  A38680CD   SB A2, -32563(GP)
9D022864  938280C5   LBU V0, -32571(GP)
9D022868  00021100   SLL V0, V0, 4
9D02286C  24040001   ADDIU A0, ZERO, 1
9D022870  24051400   ADDIU A1, ZERO, 5120
9D022874  0F40B41B   JAL mmc_bankvrom
9D022878  00463021   ADDU A2, V0, A2
9D02287C  0B408A6F   J 0x9D0229BC
9D022880  8FBF0014   LW RA, 20(SP)
117:                    case 0xD003:
118:                    case 0xD006:
119:                    case 0xD0C0: VRC_VBANK(5,value,1); break;
9D022884  30C6000F   ANDI A2, A2, 15
9D022888  A38680C5   SB A2, -32571(GP)
9D02288C  00063100   SLL A2, A2, 4
9D022890  938280CD   LBU V0, -32563(GP)
9D022894  24040001   ADDIU A0, ZERO, 1
9D022898  24051400   ADDIU A1, ZERO, 5120
9D02289C  0F40B41B   JAL mmc_bankvrom
9D0228A0  00C23021   ADDU A2, A2, V0
9D0228A4  0B408A6F   J 0x9D0229BC
9D0228A8  8FBF0014   LW RA, 20(SP)
120:                    case 0xE000: VRC_VBANK(6,value,0); break;
9D0228AC  A38680CE   SB A2, -32562(GP)
9D0228B0  938280C6   LBU V0, -32570(GP)
9D0228B4  00021100   SLL V0, V0, 4
9D0228B8  24040001   ADDIU A0, ZERO, 1
9D0228BC  24051800   ADDIU A1, ZERO, 6144
9D0228C0  0F40B41B   JAL mmc_bankvrom
9D0228C4  00463021   ADDU A2, V0, A2
9D0228C8  0B408A6F   J 0x9D0229BC
9D0228CC  8FBF0014   LW RA, 20(SP)
121:                    case 0xE002:
122:                    case 0xE040: VRC_VBANK(6,value,1); break;
9D0228D0  30C6000F   ANDI A2, A2, 15
9D0228D4  A38680C6   SB A2, -32570(GP)
9D0228D8  00063100   SLL A2, A2, 4
9D0228DC  938280CE   LBU V0, -32562(GP)
9D0228E0  24040001   ADDIU A0, ZERO, 1
9D0228E4  24051800   ADDIU A1, ZERO, 6144
9D0228E8  0F40B41B   JAL mmc_bankvrom
9D0228EC  00C23021   ADDU A2, A2, V0
9D0228F0  0B408A6F   J 0x9D0229BC
9D0228F4  8FBF0014   LW RA, 20(SP)
123:                    case 0xE001:
124:                    case 0xE004:
125:                    case 0xE080: VRC_VBANK(7,value,0); break;
9D0228F8  A38680CF   SB A2, -32561(GP)
9D0228FC  938280C7   LBU V0, -32569(GP)
9D022900  00021100   SLL V0, V0, 4
9D022904  24040001   ADDIU A0, ZERO, 1
9D022908  24051C00   ADDIU A1, ZERO, 7168
9D02290C  0F40B41B   JAL mmc_bankvrom
9D022910  00463021   ADDU A2, V0, A2
9D022914  0B408A6F   J 0x9D0229BC
9D022918  8FBF0014   LW RA, 20(SP)
126:                    case 0xE003:
127:                    case 0xE006:
128:                    case 0xE0C0: VRC_VBANK(7,value,1); break;
9D02291C  30C6000F   ANDI A2, A2, 15
9D022920  A38680C7   SB A2, -32569(GP)
9D022924  00063100   SLL A2, A2, 4
9D022928  938280CF   LBU V0, -32561(GP)
9D02292C  24040001   ADDIU A0, ZERO, 1
9D022930  24051C00   ADDIU A1, ZERO, 7168
9D022934  0F40B41B   JAL mmc_bankvrom
9D022938  00C23021   ADDU A2, A2, V0
9D02293C  0B408A6F   J 0x9D0229BC
9D022940  8FBF0014   LW RA, 20(SP)
129:                 
130:                    case 0xF000:
131:                       irq.latch &= 0xF0;
9D02294C  8C430008   LW V1, 8(V0)
9D022950  306300F0   ANDI V1, V1, 240
132:                       irq.latch |= (value & 0x0F);
9D022944  2442B8BC   ADDIU V0, V0, -18244
9D022948  30A6000F   ANDI A2, A1, 15
9D022954  00C33025   OR A2, A2, V1
133:                       break;
9D022958  0B408A6E   J 0x9D0229B8
9D02295C  AC460008   SW A2, 8(V0)
134:                    case 0xF002:
135:                    case 0xF040:
136:                       irq.latch &= 0x0F;
9D022970  8C430008   LW V1, 8(V0)
9D022974  3063000F   ANDI V1, V1, 15
137:                       irq.latch |= ((value & 0x0F) << 4);
9D022960  3C02A001   LUI V0, -24575
9D022964  2442B8BC   ADDIU V0, V0, -18244
9D022968  00063100   SLL A2, A2, 4
9D02296C  30C600FF   ANDI A2, A2, 255
9D022978  00C31825   OR V1, A2, V1
138:                       break;
9D02297C  0B408A6E   J 0x9D0229B8
9D022980  AC430008   SW V1, 8(V0)
139:                    case 0xF004:
140:                    case 0xF001:
141:                    case 0xF080:
142:                       irq.enabled = (value >> 1) & 0x01;
9D022984  3C03A001   LUI V1, -24575
9D022988  2462B8BC   ADDIU V0, V1, -18244
9D02298C  7CC40040   EXT A0, A2, 1, 1
9D022990  AC440004   SW A0, 4(V0)
143:                       irq.wait_state = value & 0x01;
9D022994  30C60001   ANDI A2, A2, 1
9D022998  AC46000C   SW A2, 12(V0)
144:                       irq.counter = irq.latch;
9D02299C  8C420008   LW V0, 8(V0)
145:                       break;
9D0229A0  0B408A6E   J 0x9D0229B8
9D0229A4  AC62B8BC   SW V0, -18244(V1)
146:                    case 0xF006:
147:                    case 0xF003:
148:                    case 0xF0C0:
149:                       irq.enabled = irq.wait_state;
9D0229A8  3C02A001   LUI V0, -24575
9D0229AC  2442B8BC   ADDIU V0, V0, -18244
9D0229B0  8C43000C   LW V1, 12(V0)
9D0229B4  AC430004   SW V1, 4(V0)
150:                       break;
151:                 
152:                    default:
153:                 #ifdef NOFRENDO_DEBUG
154:                       log_printf("wrote $%02X to $%04X", value, address);
155:                 #endif
156:                       break;
157:                    }
158:                 }
9D022354  0B408A6F   J 0x9D0229BC
9D022358  8FBF0014   LW RA, 20(SP)
9D02236C  0B408A6F   J 0x9D0229BC
9D022370  8FBF0014   LW RA, 20(SP)
9D0223A4  0B408A6F   J 0x9D0229BC
9D0223A8  8FBF0014   LW RA, 20(SP)
9D0223BC  0B408A6F   J 0x9D0229BC
9D0223C0  8FBF0014   LW RA, 20(SP)
9D022404  0B408A6F   J 0x9D0229BC
9D022408  8FBF0014   LW RA, 20(SP)
9D022424  0B408A6F   J 0x9D0229BC
9D022428  8FBF0014   LW RA, 20(SP)
9D022454  0B408A6F   J 0x9D0229BC
9D022458  8FBF0014   LW RA, 20(SP)
9D02247C  0B408A6F   J 0x9D0229BC
9D022480  8FBF0014   LW RA, 20(SP)
9D0224E0  0B408A6F   J 0x9D0229BC
9D0224E4  8FBF0014   LW RA, 20(SP)
9D0224FC  0B408A6F   J 0x9D0229BC
9D022500  8FBF0014   LW RA, 20(SP)
9D02252C  0B408A6F   J 0x9D0229BC
9D022530  8FBF0014   LW RA, 20(SP)
9D022548  0B408A6F   J 0x9D0229BC
9D02254C  8FBF0014   LW RA, 20(SP)
9D022590  0B408A6F   J 0x9D0229BC
9D022594  8FBF0014   LW RA, 20(SP)
9D0225AC  0B408A6F   J 0x9D0229BC
9D0225B0  8FBF0014   LW RA, 20(SP)
9D0225E0  0B408A6F   J 0x9D0229BC
9D0225E4  8FBF0014   LW RA, 20(SP)
9D022600  0B408A6F   J 0x9D0229BC
9D022604  8FBF0014   LW RA, 20(SP)
9D02262C  0B408A6F   J 0x9D0229BC
9D022630  8FBF0014   LW RA, 20(SP)
9D022658  0B408A6F   J 0x9D0229BC
9D02265C  8FBF0014   LW RA, 20(SP)
9D0229B8  8FBF0014   LW RA, 20(SP)
9D0229BC  03E00008   JR RA
9D0229C0  27BD0018   ADDIU SP, SP, 24
159:                 
160:                 static void map22_write(uint32 address, uint8 value)
161:                 {
9D0229C4  27BDFFE8   ADDIU SP, SP, -24
162:                    int reg = address >> 12;
9D0229C8  00041B02   SRL V1, A0, 12
163:                    
164:                    switch (reg)
9D0229CC  2462FFF8   ADDIU V0, V1, -8
9D0229D0  2C470007   SLTIU A3, V0, 7
9D0229D4  10E00046   BEQ A3, ZERO, .LVL112, .LBE2
9D0229D8  AFBF0014   SW RA, 20(SP)
9D0229DC  00A03021   ADDU A2, A1, ZERO
9D0229E0  00021080   SLL V0, V0, 2
9D0229E4  3C059D02   LUI A1, -25342
9D0229E8  24A529FC   ADDIU A1, A1, 10748
9D0229EC  00A21021   ADDU V0, A1, V0
9D0229F0  8C420000   LW V0, 0(V0)
9D0229F4  00400008   JR V0
9D0229F8  00000000   NOP
165:                    {
166:                    case 0x8:
167:                       mmc_bankrom(8, 0x8000, value);
9D022A18  24040008   ADDIU A0, ZERO, 8
9D022A1C  0F40B479   JAL mmc_bankrom
9D022A20  34058000   ORI A1, ZERO, -32768
168:                       break;
9D022A24  0B408ABD   J 0x9D022AF4
9D022A28  8FBF0014   LW RA, 20(SP)
169:                    
170:                    case 0xA:
171:                       mmc_bankrom(8, 0xA000, value);
9D022A2C  24040008   ADDIU A0, ZERO, 8
9D022A30  0F40B479   JAL mmc_bankrom
9D022A34  3405A000   ORI A1, ZERO, -24576
172:                       break;
9D022A38  0B408ABD   J 0x9D022AF4
9D022A3C  8FBF0014   LW RA, 20(SP)
173:                 
174:                    case 0x9:
175:                       switch (value & 3)
9D022A40  30C60003   ANDI A2, A2, 3
9D022A44  24020001   ADDIU V0, ZERO, 1
9D022A48  10C2000F   BEQ A2, V0, 0x9D022A88
9D022A4C  00002021   ADDU A0, ZERO, ZERO
9D022A50  10C00007   BEQ A2, ZERO, 0x9D022A70
9D022A54  24020002   ADDIU V0, ZERO, 2
9D022A58  10C20011   BEQ A2, V0, 0x9D022AA0
9D022A5C  24020003   ADDIU V0, ZERO, 3
9D022A60  10C20016   BEQ A2, V0, 0x9D022ABC
9D022A64  00002821   ADDU A1, ZERO, ZERO
176:                       {
177:                       case 0:
178:                          ppu_mirror(0, 1, 0, 1); /* vertical */
9D022A70  24050001   ADDIU A1, ZERO, 1
9D022A74  00003021   ADDU A2, ZERO, ZERO
9D022A78  0F40635D   JAL ppu_mirror
9D022A7C  24070001   ADDIU A3, ZERO, 1
179:                          break;
9D022A80  0B408ABD   J 0x9D022AF4
9D022A84  8FBF0014   LW RA, 20(SP)
180:                 
181:                       case 1: 
182:                          ppu_mirror(0, 0, 1, 1); /* horizontal */
9D022A88  00002821   ADDU A1, ZERO, ZERO
9D022A8C  24060001   ADDIU A2, ZERO, 1
9D022A90  0F40635D   JAL ppu_mirror
9D022A94  24070001   ADDIU A3, ZERO, 1
183:                          break;
9D022A98  0B408ABD   J 0x9D022AF4
9D022A9C  8FBF0014   LW RA, 20(SP)
184:                 
185:                       case 2:
186:                          ppu_mirror(1, 1, 1, 1);
9D022AA0  24040001   ADDIU A0, ZERO, 1
9D022AA4  24050001   ADDIU A1, ZERO, 1
9D022AA8  24060001   ADDIU A2, ZERO, 1
9D022AAC  0F40635D   JAL ppu_mirror
9D022AB0  24070001   ADDIU A3, ZERO, 1
187:                          break;
9D022AB4  0B408ABD   J 0x9D022AF4
9D022AB8  8FBF0014   LW RA, 20(SP)
188:                 
189:                       case 3:
190:                          ppu_mirror(0, 0, 0, 0);
9D022ABC  00003021   ADDU A2, ZERO, ZERO
9D022AC0  0F40635D   JAL ppu_mirror
9D022AC4  00003821   ADDU A3, ZERO, ZERO
191:                          break;
9D022AC8  0B408ABD   J 0x9D022AF4
9D022ACC  8FBF0014   LW RA, 20(SP)
192:                       }
193:                       break;
194:                 
195:                    case 0xB:
196:                    case 0xC:
197:                    case 0xD:
198:                    case 0xE:
199:                       {
200:                          int loc = (((reg - 0xB) << 1) + (address & 1)) << 10;
9D022AD0  2465FFF5   ADDIU A1, V1, -11
9D022AD4  00052840   SLL A1, A1, 1
9D022AD8  30840001   ANDI A0, A0, 1
9D022ADC  00A42821   ADDU A1, A1, A0
201:                          mmc_bankvrom(1, loc, value >> 1);
9D022AE0  24040001   ADDIU A0, ZERO, 1
9D022AE4  00052A80   SLL A1, A1, 10
9D022AE8  0F40B41B   JAL mmc_bankvrom
9D022AEC  00063042   SRL A2, A2, 1
202:                       }
203:                       break;
204:                 
205:                    default:
206:                       break;
207:                    }
208:                 }
9D022A68  0B408ABD   J 0x9D022AF4
9D022A6C  8FBF0014   LW RA, 20(SP)
9D022AF0  8FBF0014   LW RA, 20(SP)
9D022AF4  03E00008   JR RA
9D022AF8  27BD0018   ADDIU SP, SP, 24
209:                 
210:                 static void map23_write(uint32 address, uint8 value)
211:                 {
9D022AFC  27BDFFE8   ADDIU SP, SP, -24
9D022B00  AFBF0014   SW RA, 20(SP)
212:                    switch (address)
9D022B04  3402C008   ORI V0, ZERO, -16376
9D022B08  10820102   BEQ A0, V0, 0x9D022F14
9D022B0C  00A03021   ADDU A2, A1, ZERO
9D022B10  3402C009   ORI V0, ZERO, -16375
9D022B14  0082102B   SLTU V0, A0, V0
9D022B18  10400049   BEQ V0, ZERO, 0x9D022C40
9D022B1C  3402E001   ORI V0, ZERO, -8191
9D022B20  3402B002   ORI V0, ZERO, -20478
9D022B24  108200D3   BEQ A0, V0, 0x9D022E74
9D022B28  3402B003   ORI V0, ZERO, -20477
9D022B2C  0082102B   SLTU V0, A0, V0
9D022B30  10400029   BEQ V0, ZERO, 0x9D022BD8
9D022B34  3402C000   ORI V0, ZERO, -16384
9D022B38  34029008   ORI V0, ZERO, -28664
9D022B3C  10820096   BEQ A0, V0, 0x9D022D98
9D022B40  34029009   ORI V0, ZERO, -28663
9D022B44  0082102B   SLTU V0, A0, V0
9D022B48  10400012   BEQ V0, ZERO, 0x9D022B94
9D022B4C  3402AFFF   ORI V0, ZERO, -20481
9D022B50  34028FFF   ORI V0, ZERO, -28673
9D022B54  10820086   BEQ A0, V0, 0x9D022D70
9D022B58  34029000   ORI V0, ZERO, -28672
9D022B5C  0082102B   SLTU V0, A0, V0
9D022B60  10400006   BEQ V0, ZERO, 0x9D022B7C
9D022B64  34029000   ORI V0, ZERO, -28672
9D022B68  34028000   ORI V0, ZERO, -32768
9D022B6C  10820081   BEQ A0, V0, 0x9D022D74
9D022B70  24040008   ADDIU A0, ZERO, 8
9D022B7C  10820086   BEQ A0, V0, 0x9D022D98
9D022B80  34029004   ORI V0, ZERO, -28668
9D022B84  50820085   BEQL A0, V0, 0x9D022D9C
9D022B88  30C60003   ANDI A2, A2, 3
9D022B94  1082007B   BEQ A0, V0, 0x9D022D84
9D022B98  3402B000   ORI V0, ZERO, -20480
9D022B9C  0082102B   SLTU V0, A0, V0
9D022BA0  10400006   BEQ V0, ZERO, 0x9D022BBC
9D022BA4  3402B000   ORI V0, ZERO, -20480
9D022BA8  3402A000   ORI V0, ZERO, -24576
9D022BAC  10820076   BEQ A0, V0, 0x9D022D88
9D022BB0  24040008   ADDIU A0, ZERO, 8
9D022BBC  5082009A   BEQL A0, V0, 0x9D022E28
9D022BC0  30A6000F   ANDI A2, A1, 15
9D022BC4  3402B001   ORI V0, ZERO, -20479
9D022BC8  508200A1   BEQL A0, V0, 0x9D022E50
9D022BCC  30C6000F   ANDI A2, A2, 15
9D022BD8  108200BA   BEQ A0, V0, 0x9D022EC4
9D022BDC  3402C001   ORI V0, ZERO, -16383
9D022BE0  0082102B   SLTU V0, A0, V0
9D022BE4  1040000C   BEQ V0, ZERO, 0x9D022C18
9D022BE8  3402C002   ORI V0, ZERO, -16382
9D022BEC  3402B004   ORI V0, ZERO, -20476
9D022BF0  10820096   BEQ A0, V0, 0x9D022E4C
9D022BF4  0082102B   SLTU V0, A0, V0
9D022BF8  144000A8   BNE V0, ZERO, 0x9D022E9C
9D022BFC  3402B008   ORI V0, ZERO, -20472
9D022C00  1082009C   BEQ A0, V0, 0x9D022E74
9D022C04  3402B00C   ORI V0, ZERO, -20468
9D022C08  508200A5   BEQL A0, V0, 0x9D022EA0
9D022C0C  30C6000F   ANDI A2, A2, 15
9D022C18  108200BE   BEQ A0, V0, 0x9D022F14
9D022C1C  0082102B   SLTU V0, A0, V0
9D022C20  144000B2   BNE V0, ZERO, 0x9D022EEC
9D022C24  3402C003   ORI V0, ZERO, -16381
9D022C28  108200C4   BEQ A0, V0, 0x9D022F3C
9D022C2C  3402C004   ORI V0, ZERO, -16380
9D022C30  508200AF   BEQL A0, V0, 0x9D022EF0
9D022C34  30C6000F   ANDI A2, A2, 15
9D022C40  108200F9   BEQ A0, V0, 0x9D023028
9D022C44  3402E002   ORI V0, ZERO, -8190
9D022C48  0082102B   SLTU V0, A0, V0
9D022C4C  10400028   BEQ V0, ZERO, 0x9D022CF0
9D022C50  3402E00C   ORI V0, ZERO, -8180
9D022C54  3402D003   ORI V0, ZERO, -12285
9D022C58  108200E0   BEQ A0, V0, 0x9D022FDC
9D022C5C  3402D004   ORI V0, ZERO, -12284
9D022C60  0082102B   SLTU V0, A0, V0
9D022C64  10400012   BEQ V0, ZERO, 0x9D022CB0
9D022C68  3402D008   ORI V0, ZERO, -12280
9D022C6C  3402D000   ORI V0, ZERO, -12288
9D022C70  108200BC   BEQ A0, V0, 0x9D022F64
9D022C74  3402D001   ORI V0, ZERO, -12287
9D022C78  0082102B   SLTU V0, A0, V0
9D022C7C  10400006   BEQ V0, ZERO, 0x9D022C98
9D022C80  3402D001   ORI V0, ZERO, -12287
9D022C84  3402C00C   ORI V0, ZERO, -16372
9D022C88  508200AD   BEQL A0, V0, 0x9D022F40
9D022C8C  30C6000F   ANDI A2, A2, 15
9D022C98  108200BC   BEQ A0, V0, 0x9D022F8C
9D022C9C  3402D002   ORI V0, ZERO, -12286
9D022CA0  508200C5   BEQL A0, V0, 0x9D022FB8
9D022CA4  30C6000F   ANDI A2, A2, 15
9D022CB0  108200C0   BEQ A0, V0, 0x9D022FB4
9D022CB4  3402D009   ORI V0, ZERO, -12279
9D022CB8  0082102B   SLTU V0, A0, V0
9D022CBC  10400006   BEQ V0, ZERO, 0x9D022CD8
9D022CC0  3402D00C   ORI V0, ZERO, -12276
9D022CC4  3402D004   ORI V0, ZERO, -12284
9D022CC8  508200B1   BEQL A0, V0, 0x9D022F90
9D022CCC  30C6000F   ANDI A2, A2, 15
9D022CD8  108200C0   BEQ A0, V0, 0x9D022FDC
9D022CDC  3402E000   ORI V0, ZERO, -8192
9D022CE0  508200C8   BEQL A0, V0, 0x9D023004
9D022CE4  30A6000F   ANDI A2, A1, 15
9D022CF0  108200E1   BEQ A0, V0, 0x9D023078
9D022CF4  3402E00D   ORI V0, ZERO, -8179
9D022CF8  0082102B   SLTU V0, A0, V0
9D022CFC  1040000C   BEQ V0, ZERO, 0x9D022D30
9D022D00  3402F004   ORI V0, ZERO, -4092
9D022D04  3402E003   ORI V0, ZERO, -8189
9D022D08  108200DB   BEQ A0, V0, 0x9D023078
9D022D0C  0082102B   SLTU V0, A0, V0
9D022D10  144000CF   BNE V0, ZERO, 0x9D023050
9D022D14  3402E004   ORI V0, ZERO, -8188
9D022D18  108200C3   BEQ A0, V0, 0x9D023028
9D022D1C  3402E008   ORI V0, ZERO, -8184
9D022D20  508200CC   BEQL A0, V0, 0x9D023054
9D022D24  30C6000F   ANDI A2, A2, 15
9D022D30  108200E2   BEQ A0, V0, 0x9D0230BC
9D022D34  3402F005   ORI V0, ZERO, -4091
9D022D38  0082102B   SLTU V0, A0, V0
9D022D3C  10400006   BEQ V0, ZERO, 0x9D022D58
9D022D40  3402F008   ORI V0, ZERO, -4088
9D022D44  3402F000   ORI V0, ZERO, -4096
9D022D48  108200D5   BEQ A0, V0, 0x9D0230A0
9D022D4C  3C02A001   LUI V0, -24575
9D022D58  108200E1   BEQ A0, V0, 0x9D0230E0
9D022D5C  3402F00C   ORI V0, ZERO, -4084
9D022D60  108200E8   BEQ A0, V0, 0x9D023104
9D022D64  3C02A001   LUI V0, -24575
213:                    {
214:                    case 0x8000:
215:                    case 0x8FFF:
216:                       mmc_bankrom(8, 0x8000, value);
9D022D70  24040008   ADDIU A0, ZERO, 8
9D022D74  0F40B479   JAL mmc_bankrom
9D022D78  34058000   ORI A1, ZERO, -32768
217:                       break;
9D022D7C  0B408C45   J 0x9D023114
9D022D80  8FBF0014   LW RA, 20(SP)
218:                 
219:                    case 0xA000:
220:                    case 0xAFFF:
221:                       mmc_bankrom(8, 0xA000, value);
9D022D84  24040008   ADDIU A0, ZERO, 8
9D022D88  0F40B479   JAL mmc_bankrom
9D022D8C  3405A000   ORI A1, ZERO, -24576
222:                       break;
9D022D90  0B408C45   J 0x9D023114
9D022D94  8FBF0014   LW RA, 20(SP)
223:                    
224:                    case 0x9000:
225:                    case 0x9004:
226:                    case 0x9008:
227:                       switch(value & 3)
9D022D98  30C60003   ANDI A2, A2, 3
9D022D9C  24020001   ADDIU V0, ZERO, 1
9D022DA0  10C2000F   BEQ A2, V0, 0x9D022DE0
9D022DA4  00002021   ADDU A0, ZERO, ZERO
9D022DA8  10C00007   BEQ A2, ZERO, 0x9D022DC8
9D022DAC  24020002   ADDIU V0, ZERO, 2
9D022DB0  10C20011   BEQ A2, V0, 0x9D022DF8
9D022DB4  24020003   ADDIU V0, ZERO, 3
9D022DB8  10C20015   BEQ A2, V0, 0x9D022E10
9D022DBC  24040001   ADDIU A0, ZERO, 1
228:                       {
229:                       case 0:
230:                          ppu_mirror(0, 1, 0, 1); /* vertical */
9D022DC8  24050001   ADDIU A1, ZERO, 1
9D022DCC  00003021   ADDU A2, ZERO, ZERO
9D022DD0  0F40635D   JAL ppu_mirror
9D022DD4  24070001   ADDIU A3, ZERO, 1
231:                          break;
9D022DD8  0B408C45   J 0x9D023114
9D022DDC  8FBF0014   LW RA, 20(SP)
232:                 
233:                       case 1: 
234:                          ppu_mirror(0, 0, 1, 1); /* horizontal */
9D022DE0  00002821   ADDU A1, ZERO, ZERO
9D022DE4  24060001   ADDIU A2, ZERO, 1
9D022DE8  0F40635D   JAL ppu_mirror
9D022DEC  24070001   ADDIU A3, ZERO, 1
235:                          break;
9D022DF0  0B408C45   J 0x9D023114
9D022DF4  8FBF0014   LW RA, 20(SP)
236:                 
237:                       case 2:
238:                          ppu_mirror(0, 0, 0, 0);
9D022DF8  00002821   ADDU A1, ZERO, ZERO
9D022DFC  00003021   ADDU A2, ZERO, ZERO
9D022E00  0F40635D   JAL ppu_mirror
9D022E04  00003821   ADDU A3, ZERO, ZERO
239:                          break;
9D022E08  0B408C45   J 0x9D023114
9D022E0C  8FBF0014   LW RA, 20(SP)
240:                 
241:                       case 3:
242:                          ppu_mirror(1, 1, 1, 1);
9D022E10  24050001   ADDIU A1, ZERO, 1
9D022E14  24060001   ADDIU A2, ZERO, 1
9D022E18  0F40635D   JAL ppu_mirror
9D022E1C  24070001   ADDIU A3, ZERO, 1
243:                          break;
9D022E20  0B408C45   J 0x9D023114
9D022E24  8FBF0014   LW RA, 20(SP)
244:                       }
245:                       break;
246:                 
247:                    case 0xB000: VRC_VBANK(0,value,0); break;
9D022E28  A38680C8   SB A2, -32568(GP)
9D022E2C  938280C0   LBU V0, -32576(GP)
9D022E30  00021100   SLL V0, V0, 4
9D022E34  24040001   ADDIU A0, ZERO, 1
9D022E38  00002821   ADDU A1, ZERO, ZERO
9D022E3C  0F40B41B   JAL mmc_bankvrom
9D022E40  00463021   ADDU A2, V0, A2
9D022E44  0B408C45   J 0x9D023114
9D022E48  8FBF0014   LW RA, 20(SP)
248:                    case 0xB001:
249:                    case 0xB004: VRC_VBANK(0,value,1); break;
9D022E4C  30C6000F   ANDI A2, A2, 15
9D022E50  A38680C0   SB A2, -32576(GP)
9D022E54  00063100   SLL A2, A2, 4
9D022E58  938280C8   LBU V0, -32568(GP)
9D022E5C  24040001   ADDIU A0, ZERO, 1
9D022E60  00002821   ADDU A1, ZERO, ZERO
9D022E64  0F40B41B   JAL mmc_bankvrom
9D022E68  00C23021   ADDU A2, A2, V0
9D022E6C  0B408C45   J 0x9D023114
9D022E70  8FBF0014   LW RA, 20(SP)
250:                    case 0xB002:
251:                    case 0xB008: VRC_VBANK(1,value,0); break;
9D022E74  30C6000F   ANDI A2, A2, 15
9D022E78  A38680C9   SB A2, -32567(GP)
9D022E7C  938280C1   LBU V0, -32575(GP)
9D022E80  00021100   SLL V0, V0, 4
9D022E84  24040001   ADDIU A0, ZERO, 1
9D022E88  24050400   ADDIU A1, ZERO, 1024
9D022E8C  0F40B41B   JAL mmc_bankvrom
9D022E90  00463021   ADDU A2, V0, A2
9D022E94  0B408C45   J 0x9D023114
9D022E98  8FBF0014   LW RA, 20(SP)
252:                    case 0xB003:
253:                    case 0xB00C: VRC_VBANK(1,value,1); break;
9D022E9C  30C6000F   ANDI A2, A2, 15
9D022EA0  A38680C1   SB A2, -32575(GP)
9D022EA4  00063100   SLL A2, A2, 4
9D022EA8  938280C9   LBU V0, -32567(GP)
9D022EAC  24040001   ADDIU A0, ZERO, 1
9D022EB0  24050400   ADDIU A1, ZERO, 1024
9D022EB4  0F40B41B   JAL mmc_bankvrom
9D022EB8  00C23021   ADDU A2, A2, V0
9D022EBC  0B408C45   J 0x9D023114
9D022EC0  8FBF0014   LW RA, 20(SP)
254:                    case 0xC000: VRC_VBANK(2,value,0); break;
9D022EC4  30A6000F   ANDI A2, A1, 15
9D022EC8  A38680CA   SB A2, -32566(GP)
9D022ECC  938280C2   LBU V0, -32574(GP)
9D022ED0  00021100   SLL V0, V0, 4
9D022ED4  24040001   ADDIU A0, ZERO, 1
9D022ED8  24050800   ADDIU A1, ZERO, 2048
9D022EDC  0F40B41B   JAL mmc_bankvrom
9D022EE0  00463021   ADDU A2, V0, A2
9D022EE4  0B408C45   J 0x9D023114
9D022EE8  8FBF0014   LW RA, 20(SP)
255:                    case 0xC001:
256:                    case 0xC004: VRC_VBANK(2,value,1); break;
9D022EEC  30C6000F   ANDI A2, A2, 15
9D022EF0  A38680C2   SB A2, -32574(GP)
9D022EF4  00063100   SLL A2, A2, 4
9D022EF8  938280CA   LBU V0, -32566(GP)
9D022EFC  24040001   ADDIU A0, ZERO, 1
9D022F00  24050800   ADDIU A1, ZERO, 2048
9D022F04  0F40B41B   JAL mmc_bankvrom
9D022F08  00C23021   ADDU A2, A2, V0
9D022F0C  0B408C45   J 0x9D023114
9D022F10  8FBF0014   LW RA, 20(SP)
257:                    case 0xC002:
258:                    case 0xC008: VRC_VBANK(3,value,0); break;
9D022F14  30C6000F   ANDI A2, A2, 15
9D022F18  A38680CB   SB A2, -32565(GP)
9D022F1C  938280C3   LBU V0, -32573(GP)
9D022F20  00021100   SLL V0, V0, 4
9D022F24  24040001   ADDIU A0, ZERO, 1
9D022F28  24050C00   ADDIU A1, ZERO, 3072
9D022F2C  0F40B41B   JAL mmc_bankvrom
9D022F30  00463021   ADDU A2, V0, A2
9D022F34  0B408C45   J 0x9D023114
9D022F38  8FBF0014   LW RA, 20(SP)
259:                    case 0xC003:
260:                    case 0xC00C: VRC_VBANK(3,value,1); break;
9D022F3C  30C6000F   ANDI A2, A2, 15
9D022F40  A38680C3   SB A2, -32573(GP)
9D022F44  00063100   SLL A2, A2, 4
9D022F48  938280CB   LBU V0, -32565(GP)
9D022F4C  24040001   ADDIU A0, ZERO, 1
9D022F50  24050C00   ADDIU A1, ZERO, 3072
9D022F54  0F40B41B   JAL mmc_bankvrom
9D022F58  00C23021   ADDU A2, A2, V0
9D022F5C  0B408C45   J 0x9D023114
9D022F60  8FBF0014   LW RA, 20(SP)
261:                    case 0xD000: VRC_VBANK(4,value,0); break;
9D022F64  30A6000F   ANDI A2, A1, 15
9D022F68  A38680CC   SB A2, -32564(GP)
9D022F6C  938280C4   LBU V0, -32572(GP)
9D022F70  00021100   SLL V0, V0, 4
9D022F74  24040001   ADDIU A0, ZERO, 1
9D022F78  24051000   ADDIU A1, ZERO, 4096
9D022F7C  0F40B41B   JAL mmc_bankvrom
9D022F80  00463021   ADDU A2, V0, A2
9D022F84  0B408C45   J 0x9D023114
9D022F88  8FBF0014   LW RA, 20(SP)
262:                    case 0xD001:
263:                    case 0xD004: VRC_VBANK(4,value,1); break;
9D022F8C  30C6000F   ANDI A2, A2, 15
9D022F90  A38680C4   SB A2, -32572(GP)
9D022F94  00063100   SLL A2, A2, 4
9D022F98  938280CC   LBU V0, -32564(GP)
9D022F9C  24040001   ADDIU A0, ZERO, 1
9D022FA0  24051000   ADDIU A1, ZERO, 4096
9D022FA4  0F40B41B   JAL mmc_bankvrom
9D022FA8  00C23021   ADDU A2, A2, V0
9D022FAC  0B408C45   J 0x9D023114
9D022FB0  8FBF0014   LW RA, 20(SP)
264:                    case 0xD002:
265:                    case 0xD008: VRC_VBANK(5,value,0); break;
9D022FB4  30C6000F   ANDI A2, A2, 15
9D022FB8  A38680CD   SB A2, -32563(GP)
9D022FBC  938280C5   LBU V0, -32571(GP)
9D022FC0  00021100   SLL V0, V0, 4
9D022FC4  24040001   ADDIU A0, ZERO, 1
9D022FC8  24051400   ADDIU A1, ZERO, 5120
9D022FCC  0F40B41B   JAL mmc_bankvrom
9D022FD0  00463021   ADDU A2, V0, A2
9D022FD4  0B408C45   J 0x9D023114
9D022FD8  8FBF0014   LW RA, 20(SP)
266:                    case 0xD003:
267:                    case 0xD00C: VRC_VBANK(5,value,1); break;
9D022FDC  30C6000F   ANDI A2, A2, 15
9D022FE0  A38680C5   SB A2, -32571(GP)
9D022FE4  00063100   SLL A2, A2, 4
9D022FE8  938280CD   LBU V0, -32563(GP)
9D022FEC  24040001   ADDIU A0, ZERO, 1
9D022FF0  24051400   ADDIU A1, ZERO, 5120
9D022FF4  0F40B41B   JAL mmc_bankvrom
9D022FF8  00C23021   ADDU A2, A2, V0
9D022FFC  0B408C45   J 0x9D023114
9D023000  8FBF0014   LW RA, 20(SP)
268:                    case 0xE000: VRC_VBANK(6,value,0); break;
9D023004  A38680CE   SB A2, -32562(GP)
9D023008  938280C6   LBU V0, -32570(GP)
9D02300C  00021100   SLL V0, V0, 4
9D023010  24040001   ADDIU A0, ZERO, 1
9D023014  24051800   ADDIU A1, ZERO, 6144
9D023018  0F40B41B   JAL mmc_bankvrom
9D02301C  00463021   ADDU A2, V0, A2
9D023020  0B408C45   J 0x9D023114
9D023024  8FBF0014   LW RA, 20(SP)
269:                    case 0xE001:
270:                    case 0xE004: VRC_VBANK(6,value,1); break;
9D023028  30C6000F   ANDI A2, A2, 15
9D02302C  A38680C6   SB A2, -32570(GP)
9D023030  00063100   SLL A2, A2, 4
9D023034  938280CE   LBU V0, -32562(GP)
9D023038  24040001   ADDIU A0, ZERO, 1
9D02303C  24051800   ADDIU A1, ZERO, 6144
9D023040  0F40B41B   JAL mmc_bankvrom
9D023044  00C23021   ADDU A2, A2, V0
9D023048  0B408C45   J 0x9D023114
9D02304C  8FBF0014   LW RA, 20(SP)
271:                    case 0xE002:
272:                    case 0xE008: VRC_VBANK(7,value,0); break;
9D023050  30C6000F   ANDI A2, A2, 15
9D023054  A38680CF   SB A2, -32561(GP)
9D023058  938280C7   LBU V0, -32569(GP)
9D02305C  00021100   SLL V0, V0, 4
9D023060  24040001   ADDIU A0, ZERO, 1
9D023064  24051C00   ADDIU A1, ZERO, 7168
9D023068  0F40B41B   JAL mmc_bankvrom
9D02306C  00463021   ADDU A2, V0, A2
9D023070  0B408C45   J 0x9D023114
9D023074  8FBF0014   LW RA, 20(SP)
273:                    case 0xE003:
274:                    case 0xE00C: VRC_VBANK(7,value,1); break;
9D023078  30C6000F   ANDI A2, A2, 15
9D02307C  A38680C7   SB A2, -32569(GP)
9D023080  00063100   SLL A2, A2, 4
9D023084  938280CF   LBU V0, -32561(GP)
9D023088  24040001   ADDIU A0, ZERO, 1
9D02308C  24051C00   ADDIU A1, ZERO, 7168
9D023090  0F40B41B   JAL mmc_bankvrom
9D023094  00C23021   ADDU A2, A2, V0
9D023098  0B408C45   J 0x9D023114
9D02309C  8FBF0014   LW RA, 20(SP)
275:                 
276:                    case 0xF000: 
277:                       irq.latch &= 0xF0;
9D0230A8  8C430008   LW V1, 8(V0)
9D0230AC  306300F0   ANDI V1, V1, 240
278:                       irq.latch |= (value & 0x0F);
9D0230A0  2442B8BC   ADDIU V0, V0, -18244
9D0230A4  30A6000F   ANDI A2, A1, 15
9D0230B0  00C33025   OR A2, A2, V1
279:                       break;
9D0230B4  0B408C44   J 0x9D023110
9D0230B8  AC460008   SW A2, 8(V0)
280:                 
281:                    case 0xF004: 
282:                       irq.latch &= 0x0F;
9D0230CC  8C430008   LW V1, 8(V0)
9D0230D0  3063000F   ANDI V1, V1, 15
283:                       irq.latch |= ((value & 0x0F) << 4);
9D0230BC  3C02A001   LUI V0, -24575
9D0230C0  2442B8BC   ADDIU V0, V0, -18244
9D0230C4  00053100   SLL A2, A1, 4
9D0230C8  30C600FF   ANDI A2, A2, 255
9D0230D4  00C31825   OR V1, A2, V1
284:                       break;
9D0230D8  0B408C44   J 0x9D023110
9D0230DC  AC430008   SW V1, 8(V0)
285:                 
286:                    case 0xF008:
287:                       irq.enabled = (value >> 1) & 0x01;
9D0230E0  3C03A001   LUI V1, -24575
9D0230E4  2462B8BC   ADDIU V0, V1, -18244
9D0230E8  7CA40040   EXT A0, A1, 1, 1
9D0230EC  AC440004   SW A0, 4(V0)
288:                       irq.wait_state = value & 0x01;
9D0230F0  30A60001   ANDI A2, A1, 1
9D0230F4  AC46000C   SW A2, 12(V0)
289:                       irq.counter = irq.latch;
9D0230F8  8C420008   LW V0, 8(V0)
290:                       break;
9D0230FC  0B408C44   J 0x9D023110
9D023100  AC62B8BC   SW V0, -18244(V1)
291:                 
292:                    case 0xF00C:
293:                       irq.enabled = irq.wait_state;
9D023104  2442B8BC   ADDIU V0, V0, -18244
9D023108  8C43000C   LW V1, 12(V0)
9D02310C  AC430004   SW V1, 4(V0)
294:                       break;
295:                 
296:                    default:
297:                 #ifdef NOFRENDO_DEBUG
298:                       log_printf("wrote $%02X to $%04X",value,address);
299:                 #endif
300:                       break;
301:                    }
302:                 }
9D022B74  0B408C45   J 0x9D023114
9D022B78  8FBF0014   LW RA, 20(SP)
9D022B8C  0B408C45   J 0x9D023114
9D022B90  8FBF0014   LW RA, 20(SP)
9D022BB4  0B408C45   J 0x9D023114
9D022BB8  8FBF0014   LW RA, 20(SP)
9D022BD0  0B408C45   J 0x9D023114
9D022BD4  8FBF0014   LW RA, 20(SP)
9D022C10  0B408C45   J 0x9D023114
9D022C14  8FBF0014   LW RA, 20(SP)
9D022C38  0B408C45   J 0x9D023114
9D022C3C  8FBF0014   LW RA, 20(SP)
9D022C90  0B408C45   J 0x9D023114
9D022C94  8FBF0014   LW RA, 20(SP)
9D022CA8  0B408C45   J 0x9D023114
9D022CAC  8FBF0014   LW RA, 20(SP)
9D022CD0  0B408C45   J 0x9D023114
9D022CD4  8FBF0014   LW RA, 20(SP)
9D022CE8  0B408C45   J 0x9D023114
9D022CEC  8FBF0014   LW RA, 20(SP)
9D022D28  0B408C45   J 0x9D023114
9D022D2C  8FBF0014   LW RA, 20(SP)
9D022D50  0B408C45   J 0x9D023114
9D022D54  8FBF0014   LW RA, 20(SP)
9D022D68  0B408C45   J 0x9D023114
9D022D6C  8FBF0014   LW RA, 20(SP)
9D022DC0  0B408C45   J 0x9D023114
9D022DC4  8FBF0014   LW RA, 20(SP)
9D023110  8FBF0014   LW RA, 20(SP)
9D023114  03E00008   JR RA
9D023118  27BD0018   ADDIU SP, SP, 24
303:                 
304:                 static void vrc_hblank(int vblank) 
305:                 {
9D023144  27BDFFE8   ADDIU SP, SP, -24
9D023148  AFBF0014   SW RA, 20(SP)
9D02314C  AFB00010   SW S0, 16(SP)
306:                    UNUSED(vblank);
307:                 
308:                    if (irq.enabled)
9D02311C  3C02A001   LUI V0, -24575
9D023120  8C42B8C0   LW V0, -18240(V0)
9D023124  10400013   BEQ V0, ZERO, 0x9D023174
9D023128  3C03A001   LUI V1, -24575
309:                    {
310:                       if (256 == ++irq.counter)
9D02312C  8C62B8BC   LW V0, -18244(V1)
9D023130  24420001   ADDIU V0, V0, 1
9D023134  AC62B8BC   SW V0, -18244(V1)
9D023138  24030100   ADDIU V1, ZERO, 256
9D02313C  1443000D   BNE V0, V1, 0x9D023174
9D023140  3C02A001   LUI V0, -24575
311:                       {
312:                          irq.counter = irq.latch;
9D023150  2450B8BC   ADDIU S0, V0, -18244
9D023154  8E030008   LW V1, 8(S0)
313:                          nes_irq();
9D023158  0F408C7B   JAL nes_irq
9D02315C  AC43B8BC   SW V1, -18244(V0)
314:                          //irq.enabled = false;
315:                          irq.enabled = irq.wait_state;
9D023160  8E02000C   LW V0, 12(S0)
9D023164  AE020004   SW V0, 4(S0)
316:                       }
317:                    }
318:                 }
9D023168  8FBF0014   LW RA, 20(SP)
9D02316C  8FB00010   LW S0, 16(SP)
9D023170  27BD0018   ADDIU SP, SP, 24
9D023174  03E00008   JR RA
9D023178  00000000   NOP
319:                 
320:                 
321:                 
322:                 static map_memwrite map21_memwrite[] =
323:                 {
324:                    { 0x8000, 0xFFFF, map21_write },
325:                    {     -1,     -1, NULL }
326:                 };
327:                 
328:                 static map_memwrite map22_memwrite[] =
329:                 {
330:                    { 0x8000, 0xFFFF, map22_write },
331:                    {     -1,     -1, NULL }
332:                 };
333:                 
334:                 static map_memwrite map23_memwrite[] =
335:                 {
336:                    { 0x8000, 0xFFFF, map23_write },
337:                    {     -1,     -1, NULL }
338:                 };
339:                 
340:                 static void map21_getstate(SnssMapperBlock *state)
341:                 {
342:                    state->extraData.mapper21.irqCounter = irq.counter;
9D0222A8  3C02A001   LUI V0, -24575
9D0222AC  8C43B8BC   LW V1, -18244(V0)
9D0222B0  A0830018   SB V1, 24(A0)
343:                    state->extraData.mapper21.irqCounterEnabled = irq.enabled;
9D0222B4  2442B8BC   ADDIU V0, V0, -18244
9D0222B8  8C420004   LW V0, 4(V0)
9D0222BC  03E00008   JR RA
9D0222C0  A0820019   SB V0, 25(A0)
344:                 }
345:                 
346:                 static void map21_setstate(SnssMapperBlock *state)
347:                 {
348:                    irq.counter = state->extraData.mapper21.irqCounter;
9D0222C4  3C02A001   LUI V0, -24575
9D0222C8  90830018   LBU V1, 24(A0)
9D0222CC  AC43B8BC   SW V1, -18244(V0)
349:                    irq.enabled = state->extraData.mapper21.irqCounterEnabled;
9D0222D0  2442B8BC   ADDIU V0, V0, -18244
9D0222D4  90830019   LBU V1, 25(A0)
9D0222D8  03E00008   JR RA
9D0222DC  AC430004   SW V1, 4(V0)
350:                 }
351:                 
352:                 mapintf_t map21_intf =
353:                 {
354:                    21, /* mapper number */
355:                    "Konami VRC4 A", /* mapper name */
356:                    vrc_init, /* init routine */
357:                    NULL, /* vblank callback */
358:                    vrc_hblank, /* hblank callback */
359:                    map21_getstate, /* get state (snss) */
360:                    map21_setstate, /* set state (snss) */
361:                    NULL, /* memory read structure */
362:                    map21_memwrite, /* memory write structure */
363:                    NULL /* external sound device */
364:                 };
365:                 
366:                 mapintf_t map22_intf =
367:                 {
368:                    22, /* mapper number */
369:                    "Konami VRC2 A", /* mapper name */
370:                    vrc_init, /* init routine */
371:                    NULL, /* vblank callback */
372:                    NULL, /* hblank callback */
373:                    NULL, /* get state (snss) */
374:                    NULL, /* set state (snss) */
375:                    NULL, /* memory read structure */
376:                    map22_memwrite, /* memory write structure */
377:                    NULL /* external sound device */
378:                 };
379:                 
380:                 mapintf_t map23_intf =
381:                 {
382:                    23, /* mapper number */
383:                    "Konami VRC2 B", /* mapper name */
384:                    vrc_init, /* init routine */
385:                    NULL, /* vblank callback */
386:                    vrc_hblank, /* hblank callback */
387:                    NULL, /* get state (snss) */
388:                    NULL, /* set state (snss) */
389:                    NULL, /* memory read structure */
390:                    map23_memwrite, /* memory write structure */
391:                    NULL /* external sound device */
392:                 };
393:                 
394:                 mapintf_t map25_intf =
395:                 {
396:                    25, /* mapper number */
397:                    "Konami VRC4 B", /* mapper name */
398:                    NULL, /* init routine */
399:                    NULL, /* vblank callback */
400:                    vrc_hblank, /* hblank callback */
401:                    NULL, /* get state (snss) */
402:                    NULL, /* set state (snss) */
403:                    NULL, /* memory read structure */
404:                    map21_memwrite, /* memory write structure */
405:                    NULL /* external sound device */
406:                 };
407:                 
408:                 /*
409:                 ** $Log: mapvrc.c,v $
410:                 ** Revision 1.2  2001/04/27 14:37:11  neil
411:                 ** wheeee
412:                 **
413:                 ** Revision 1.1  2001/04/27 12:54:40  neil
414:                 ** blah
415:                 **
416:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
417:                 ** initial
418:                 **
419:                 ** Revision 1.1  2000/10/24 12:19:33  matt
420:                 ** changed directory structure
421:                 **
422:                 ** Revision 1.10  2000/10/22 19:17:46  matt
423:                 ** mapper cleanups galore
424:                 **
425:                 ** Revision 1.9  2000/10/22 15:03:14  matt
426:                 ** simplified mirroring
427:                 **
428:                 ** Revision 1.8  2000/10/21 19:33:38  matt
429:                 ** many more cleanups
430:                 **
431:                 ** Revision 1.7  2000/10/10 13:58:17  matt
432:                 ** stroustrup squeezing his way in the door
433:                 **
434:                 ** Revision 1.6  2000/08/16 02:50:11  matt
435:                 ** random mapper cleanups
436:                 **
437:                 ** Revision 1.5  2000/07/15 23:52:20  matt
438:                 ** rounded out a bunch more mapper interfaces
439:                 **
440:                 ** Revision 1.4  2000/07/10 13:51:25  matt
441:                 ** using generic nes_irq() routine now
442:                 **
443:                 ** Revision 1.3  2000/07/10 05:29:03  matt
444:                 ** cleaned up some mirroring issues
445:                 **
446:                 ** Revision 1.2  2000/07/06 02:48:43  matt
447:                 ** clearly labelled structure members
448:                 **
449:                 ** Revision 1.1  2000/07/06 01:01:56  matt
450:                 ** initial revision
451:                 **
452:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map231.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map231.c
21:                  **
22:                  ** mapper 231 interface
23:                  ** $Id: map231.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  
29:                  /* mapper 231: NINA-07, used in Wally Bear and the NO! Gang */
30:                  
31:                  static void map231_init(void)
32:                  {
9D03B6B0  27BDFFE8   ADDIU SP, SP, -24
9D03B6B4  AFBF0014   SW RA, 20(SP)
33:                     mmc_bankrom(32, 0x8000, MMC_LASTBANK);
9D03B6B8  24040020   ADDIU A0, ZERO, 32
9D03B6BC  34058000   ORI A1, ZERO, -32768
9D03B6C0  0F40B479   JAL mmc_bankrom
9D03B6C4  2406FFFF   ADDIU A2, ZERO, -1
34:                  }
9D03B6C8  8FBF0014   LW RA, 20(SP)
9D03B6CC  03E00008   JR RA
9D03B6D0  27BD0018   ADDIU SP, SP, 24
35:                  
36:                  static void map231_write(uint32 address, uint8 value)
37:                  {
9D03B6D4  27BDFFE8   ADDIU SP, SP, -24
9D03B6D8  AFBF0014   SW RA, 20(SP)
9D03B6DC  AFB00010   SW S0, 16(SP)
9D03B6E0  00A08021   ADDU S0, A1, ZERO
38:                     int bank, vbank;
39:                     UNUSED(address);
40:                  
41:                     bank = ((value & 0x80) >> 5) | (value & 0x03);
9D03B6E4  30A60080   ANDI A2, A1, 128
9D03B6E8  00063143   SRA A2, A2, 5
9D03B6EC  30A20003   ANDI V0, A1, 3
42:                     vbank = (value >> 4) & 0x07;
43:                  
44:                     mmc_bankrom(32, 0x8000, bank);
9D03B6F0  24040020   ADDIU A0, ZERO, 32
9D03B6F4  34058000   ORI A1, ZERO, -32768
9D03B6F8  0F40B479   JAL mmc_bankrom
9D03B6FC  00C23025   OR A2, A2, V0
45:                     mmc_bankvrom(8, 0x0000, vbank);
9D03B700  24040008   ADDIU A0, ZERO, 8
9D03B704  00002821   ADDU A1, ZERO, ZERO
9D03B708  0F40B41B   JAL mmc_bankvrom
9D03B70C  7E061100   EXT A2, S0, 4, 3
46:                  }
9D03B710  8FBF0014   LW RA, 20(SP)
9D03B714  8FB00010   LW S0, 16(SP)
9D03B718  03E00008   JR RA
9D03B71C  27BD0018   ADDIU SP, SP, 24
47:                  
48:                  static map_memwrite map231_memwrite[] =
49:                  {
50:                     { 0x8000, 0xFFFF, map231_write },
51:                     {     -1,     -1, NULL }
52:                  };
53:                  
54:                  mapintf_t map231_intf = 
55:                  {
56:                     231, /* mapper number */
57:                     "NINA-07", /* mapper name */
58:                     map231_init, /* init routine */
59:                     NULL, /* vblank callback */
60:                     NULL, /* hblank callback */
61:                     NULL, /* get state (snss) */
62:                     NULL, /* set state (snss) */
63:                     NULL, /* memory read structure */
64:                     map231_memwrite, /* memory write structure */
65:                     NULL /* external sound device */
66:                  };
67:                  
68:                  /*
69:                  ** $Log: map231.c,v $
70:                  ** Revision 1.2  2001/04/27 14:37:11  neil
71:                  ** wheeee
72:                  **
73:                  ** Revision 1.1  2001/04/27 12:54:40  neil
74:                  ** blah
75:                  **
76:                  ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
77:                  ** initial
78:                  **
79:                  ** Revision 1.1  2000/10/24 12:19:33  matt
80:                  ** changed directory structure
81:                  **
82:                  ** Revision 1.4  2000/10/22 19:17:46  matt
83:                  ** mapper cleanups galore
84:                  **
85:                  ** Revision 1.3  2000/10/21 19:33:38  matt
86:                  ** many more cleanups
87:                  **
88:                  ** Revision 1.2  2000/08/16 02:50:11  matt
89:                  ** random mapper cleanups
90:                  **
91:                  ** Revision 1.1  2000/07/11 03:14:18  melanson
92:                  ** Initial commit for mappers 16, 34, and 231
93:                  **
94:                  **
95:                  */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map229.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map229.c
21:                  **
22:                  ** Mapper #229 (31 in 1)
23:                  ** Implementation by Firebug
24:                  ** Mapper information courtesy of Mark Knibbs
25:                  ** $Id: map229.c,v 1.2 2001/04/27 14:37:11 neil Exp $
26:                  **
27:                  */
28:                  
29:                  #include <noftypes.h>
30:                  #include <nes_mmc.h>
31:                  #include <nes.h>
32:                  #include <libsnss.h>
33:                  #include <log.h>
34:                  
35:                  /************************/
36:                  /* Mapper #229: 31 in 1 */
37:                  /************************/
38:                  static void map229_init (void)
39:                  {
9D03962C  27BDFFE8   ADDIU SP, SP, -24
9D039630  AFBF0014   SW RA, 20(SP)
40:                    /* On reset, PRG is set to first 32K and CHR to first 8K */
41:                    mmc_bankrom (32, 0x8000, 0x00);
9D039634  24040020   ADDIU A0, ZERO, 32
9D039638  34058000   ORI A1, ZERO, -32768
9D03963C  0F40B479   JAL mmc_bankrom
9D039640  00003021   ADDU A2, ZERO, ZERO
42:                    mmc_bankvrom (8, 0x0000, 0x00);
9D039644  24040008   ADDIU A0, ZERO, 8
9D039648  00002821   ADDU A1, ZERO, ZERO
9D03964C  0F40B41B   JAL mmc_bankvrom
9D039650  00003021   ADDU A2, ZERO, ZERO
43:                  
44:                    /* Done */
45:                    return;
46:                  }
9D039654  8FBF0014   LW RA, 20(SP)
9D039658  03E00008   JR RA
9D03965C  27BD0018   ADDIU SP, SP, 24
47:                  
48:                  /*******************************************/
49:                  /* Mapper #229 write handler ($8000-$FFFF) */
50:                  /*******************************************/
51:                  static void map229_write (uint32 address, uint8 value)
52:                  {
9D039660  27BDFFE0   ADDIU SP, SP, -32
9D039664  AFBF001C   SW RA, 28(SP)
9D039668  AFB10018   SW S1, 24(SP)
9D03966C  AFB00014   SW S0, 20(SP)
9D039670  00808021   ADDU S0, A0, ZERO
53:                    /* Value written is irrelevant */
54:                    UNUSED (value);
55:                  
56:                    /* A4-A0 sets 8K CHR page */
57:                    mmc_bankvrom (8, 0x0000, (uint8) (address & 0x1F));
9D039674  3091001F   ANDI S1, A0, 31
9D039678  24040008   ADDIU A0, ZERO, 8
9D03967C  00002821   ADDU A1, ZERO, ZERO
9D039680  0F40B41B   JAL mmc_bankvrom
9D039684  02203021   ADDU A2, S1, ZERO
58:                  
59:                    /* If A4-A1 are all low then select the first 32K,     */
60:                    /* otherwise select a 16K bank at both $8000 and $C000 */
61:                    if ((address & 0x1E) == 0x00)
9D039688  3202001E   ANDI V0, S0, 30
9D03968C  14400007   BNE V0, ZERO, 0x9D0396AC
9D039690  24040010   ADDIU A0, ZERO, 16
62:                    {
63:                      mmc_bankrom (32, 0x8000, 0x00);
9D039694  24040020   ADDIU A0, ZERO, 32
9D039698  34058000   ORI A1, ZERO, -32768
9D03969C  0F40B479   JAL mmc_bankrom
9D0396A0  00003021   ADDU A2, ZERO, ZERO
9D0396A4  0B40E5B3   J 0x9D0396CC
9D0396A8  32100020   ANDI S0, S0, 32
64:                    }
65:                    else
66:                    {
67:                      mmc_bankrom (16, 0x8000, (uint8) (address & 0x1F));
9D0396AC  34058000   ORI A1, ZERO, -32768
9D0396B0  0F40B479   JAL mmc_bankrom
9D0396B4  02203021   ADDU A2, S1, ZERO
68:                      mmc_bankrom (16, 0xC000, (uint8) (address & 0x1F));
9D0396B8  24040010   ADDIU A0, ZERO, 16
9D0396BC  3405C000   ORI A1, ZERO, -16384
9D0396C0  0F40B479   JAL mmc_bankrom
9D0396C4  02203021   ADDU A2, S1, ZERO
69:                    }
70:                  
71:                    /* A5: mirroring (low = vertical, high = horizontal) */
72:                    if (address & 0x20) ppu_mirror(0, 0, 1, 1);
9D0396C8  32100020   ANDI S0, S0, 32
9D0396CC  12000007   BEQ S0, ZERO, 0x9D0396EC
9D0396D0  00002021   ADDU A0, ZERO, ZERO
9D0396D4  00002821   ADDU A1, ZERO, ZERO
9D0396D8  24060001   ADDIU A2, ZERO, 1
9D0396DC  0F40635D   JAL ppu_mirror
9D0396E0  24070001   ADDIU A3, ZERO, 1
9D0396E4  0B40E5C0   J 0x9D039700
9D0396E8  8FBF001C   LW RA, 28(SP)
73:                    else                ppu_mirror(0, 1, 0, 1);
9D0396EC  24050001   ADDIU A1, ZERO, 1
9D0396F0  00003021   ADDU A2, ZERO, ZERO
9D0396F4  0F40635D   JAL ppu_mirror
9D0396F8  24070001   ADDIU A3, ZERO, 1
74:                  
75:                    /* Done */
76:                    return;
77:                  }
9D0396FC  8FBF001C   LW RA, 28(SP)
9D039700  8FB10018   LW S1, 24(SP)
9D039704  8FB00014   LW S0, 20(SP)
9D039708  03E00008   JR RA
9D03970C  27BD0020   ADDIU SP, SP, 32
78:                  
79:                  static map_memwrite map229_memwrite [] =
80:                  {
81:                     { 0x8000, 0xFFFF, map229_write },
82:                     {     -1,     -1, NULL }
83:                  };
84:                  
85:                  mapintf_t map229_intf =
86:                  {
87:                     229,                              /* Mapper number */
88:                     "31 in 1 (bootleg)",              /* Mapper name */
89:                     map229_init,                      /* Initialization routine */
90:                     NULL,                             /* VBlank callback */
91:                     NULL,                             /* HBlank callback */
92:                     NULL,                             /* Get state (SNSS) */
93:                     NULL,                             /* Set state (SNSS) */
94:                     NULL,                             /* Memory read structure */
95:                     map229_memwrite,                  /* Memory write structure */
96:                     NULL                              /* External sound device */
97:                  };
98:                  
99:                  /*
100:                 ** $Log: map229.c,v $
101:                 ** Revision 1.2  2001/04/27 14:37:11  neil
102:                 ** wheeee
103:                 **
104:                 ** Revision 1.1  2001/04/27 12:54:40  neil
105:                 ** blah
106:                 **
107:                 ** Revision 1.1  2001/04/27 10:57:41  neil
108:                 ** wheee
109:                 **
110:                 ** Revision 1.1  2000/12/30 06:34:31  firebug
111:                 ** Initial revision
112:                 **
113:                 **
114:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map160.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map160.c
21:                  **
22:                  ** mapper 160 interface
23:                  ** $Id: map160.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes_ppu.h>
29:                  #include <nes.h>
30:                  
31:                  static struct
32:                  {
33:                     bool enabled, expired;
34:                     int counter;
35:                     int latch_c005, latch_c003;
36:                  } irq;
37:                  
38:                  static void map160_write(uint32 address, uint8 value)
39:                  {
9D036D30  27BDFFE8   ADDIU SP, SP, -24
9D036D34  AFBF0014   SW RA, 20(SP)
40:                     if (address >= 0x8000 && address <= 0x8003)
9D036D38  24828000   ADDIU V0, A0, -32768
9D036D3C  2C420004   SLTIU V0, V0, 4
9D036D40  10400008   BEQ V0, ZERO, 0x9D036D64
9D036D44  00A03021   ADDU A2, A1, ZERO
41:                     {
42:                        mmc_bankrom(8, 0x8000 + 0x2000 * (address & 3), value);
9D036D48  30840003   ANDI A0, A0, 3
9D036D4C  24850004   ADDIU A1, A0, 4
9D036D50  24040008   ADDIU A0, ZERO, 8
9D036D54  0F40B479   JAL mmc_bankrom
9D036D58  00052B40   SLL A1, A1, 13
9D036D5C  0B40DB84   J 0x9D036E10
9D036D60  8FBF0014   LW RA, 20(SP)
43:                     }
44:                     else if (address >= 0x9000 && address <= 0x9007)
9D036D64  3C02FFFF   LUI V0, -1
9D036D68  24427000   ADDIU V0, V0, 28672
9D036D6C  00821021   ADDU V0, A0, V0
9D036D70  2C420008   SLTIU V0, V0, 8
9D036D74  10400007   BEQ V0, ZERO, 0x9D036D94
9D036D78  3402C002   ORI V0, ZERO, -16382
45:                     {
46:                        mmc_bankvrom(1, 0x400 * (address & 7), value);
9D036D7C  30850007   ANDI A1, A0, 7
9D036D80  24040001   ADDIU A0, ZERO, 1
9D036D84  0F40B41B   JAL mmc_bankvrom
9D036D88  00052A80   SLL A1, A1, 10
9D036D8C  0B40DB84   J 0x9D036E10
9D036D90  8FBF0014   LW RA, 20(SP)
47:                     }
48:                     else if (0xC002 == address)
9D036D94  14820007   BNE A0, V0, 0x9D036DB4
9D036D98  3402C003   ORI V0, ZERO, -16381
49:                     {
50:                        irq.enabled = false;
9D036D9C  3C02A001   LUI V0, -24575
9D036DA0  AC40B868   SW ZERO, -18328(V0)
51:                        irq.latch_c005 = irq.latch_c003;
9D036DA4  2442B868   ADDIU V0, V0, -18328
9D036DA8  8C430010   LW V1, 16(V0)
9D036DAC  0B40DB83   J 0x9D036E0C
9D036DB0  AC43000C   SW V1, 12(V0)
52:                     }
53:                     else if (0xC003 == address)
9D036DB4  1482000F   BNE A0, V0, 0x9D036DF4
9D036DB8  3402C005   ORI V0, ZERO, -16379
54:                     {
55:                        if (false == irq.expired)
9D036DBC  3C02A001   LUI V0, -24575
9D036DC0  8C42B86C   LW V0, -18324(V0)
9D036DC4  14400004   BNE V0, ZERO, 0x9D036DD8
9D036DC8  3C03A001   LUI V1, -24575
56:                        {
57:                           irq.counter = value;
9D036DCC  3C02A001   LUI V0, -24575
9D036DD0  0B40DB83   J 0x9D036E0C
9D036DD4  AC45B870   SW A1, -18320(V0)
58:                        }
59:                        else
60:                        {
61:                           irq.expired = false;
9D036DD8  2462B868   ADDIU V0, V1, -18328
9D036DDC  AC400004   SW ZERO, 4(V0)
62:                           irq.enabled = true;
9D036DE0  24040001   ADDIU A0, ZERO, 1
9D036DE4  AC64B868   SW A0, -18328(V1)
63:                           irq.counter = irq.latch_c005;
9D036DE8  8C43000C   LW V1, 12(V0)
9D036DEC  0B40DB83   J 0x9D036E0C
9D036DF0  AC430008   SW V1, 8(V0)
64:                        }
65:                     }
66:                     else if (0xC005 == address)
9D036DF4  14820006   BNE A0, V0, 0x9D036E10
9D036DF8  8FBF0014   LW RA, 20(SP)
67:                     {
68:                        irq.latch_c005 = value;
9D036DFC  3C02A001   LUI V0, -24575
9D036E00  2442B868   ADDIU V0, V0, -18328
9D036E04  AC45000C   SW A1, 12(V0)
69:                        irq.counter = value;
9D036E08  AC450008   SW A1, 8(V0)
70:                     }
71:                  #ifdef NOFRENDO_DEBUG
72:                     else
73:                     {
74:                        log_printf("mapper 160: untrapped write $%02X to $%04X\n", value, address);
75:                     }
76:                  #endif /* NOFRENDO_DEBUG */
77:                  }
9D036E0C  8FBF0014   LW RA, 20(SP)
9D036E10  03E00008   JR RA
9D036E14  27BD0018   ADDIU SP, SP, 24
78:                  
79:                  static void map160_hblank(int vblank)
80:                  {
9D036E20  27BDFFE8   ADDIU SP, SP, -24
9D036E24  AFBF0014   SW RA, 20(SP)
81:                     if (!vblank)
9D036E18  1480001B   BNE A0, ZERO, 0x9D036E88
9D036E1C  00000000   NOP
82:                     {
83:                        if (ppu_enabled() && irq.enabled)
9D036E28  0F4065CC   JAL ppu_enabled
9D036E2C  00000000   NOP
9D036E30  10400013   BEQ V0, ZERO, 0x9D036E80
9D036E34  3C02A001   LUI V0, -24575
9D036E38  8C42B868   LW V0, -18328(V0)
9D036E3C  10400010   BEQ V0, ZERO, 0x9D036E80
9D036E40  3C02A001   LUI V0, -24575
84:                        {
85:                           if (0 == irq.counter && false == irq.expired)
9D036E44  8C42B870   LW V0, -18320(V0)
9D036E48  1440000B   BNE V0, ZERO, 0x9D036E78
9D036E4C  2442FFFF   ADDIU V0, V0, -1
9D036E50  3C03A001   LUI V1, -24575
9D036E54  8C63B86C   LW V1, -18324(V1)
9D036E58  14600008   BNE V1, ZERO, 0x9D036E7C
9D036E5C  3C03A001   LUI V1, -24575
86:                           {
87:                              irq.expired = true;
9D036E60  24030001   ADDIU V1, ZERO, 1
9D036E64  3C02A001   LUI V0, -24575
88:                              nes_irq();
9D036E68  0F408C7B   JAL nes_irq
9D036E6C  AC43B86C   SW V1, -18324(V0)
9D036E70  0B40DBA1   J 0x9D036E84
9D036E74  8FBF0014   LW RA, 20(SP)
89:                           }
90:                           else
91:                           {
92:                              irq.counter--;
9D036E78  3C03A001   LUI V1, -24575
9D036E7C  AC62B870   SW V0, -18320(V1)
93:                           }
94:                        }
95:                     }
96:                  }
9D036E80  8FBF0014   LW RA, 20(SP)
9D036E84  27BD0018   ADDIU SP, SP, 24
9D036E88  03E00008   JR RA
9D036E8C  00000000   NOP
97:                  
98:                  static void map160_init(void)
99:                  {
100:                    irq.enabled = false;
9D036D10  3C02A001   LUI V0, -24575
9D036D14  AC40B868   SW ZERO, -18328(V0)
101:                    irq.expired = false;
9D036D18  2442B868   ADDIU V0, V0, -18328
9D036D1C  AC400004   SW ZERO, 4(V0)
102:                    irq.counter = 0;
9D036D20  AC400008   SW ZERO, 8(V0)
103:                    irq.latch_c003 = irq.latch_c005 = 0;
9D036D24  AC40000C   SW ZERO, 12(V0)
9D036D28  03E00008   JR RA
9D036D2C  AC400010   SW ZERO, 16(V0)
104:                 }
105:                 
106:                 static map_memwrite map160_memwrite[] =
107:                 {
108:                    { 0x8000, 0xFFFF, map160_write },
109:                    {     -1,     -1, NULL }
110:                 };
111:                 
112:                 mapintf_t map160_intf =
113:                 {
114:                    160, /* mapper number */
115:                    "Aladdin (pirate)", /* mapper name */
116:                    map160_init, /* init routine */
117:                    NULL, /* vblank callback */
118:                    map160_hblank, /* hblank callback */
119:                    NULL, /* get state (snss) */
120:                    NULL, /* set state (snss) */
121:                    NULL, /* memory read structure */
122:                    map160_memwrite, /* memory write structure */
123:                    NULL /* external sound device */
124:                 };
125:                 
126:                 /*
127:                 ** $Log: map160.c,v $
128:                 ** Revision 1.2  2001/04/27 14:37:11  neil
129:                 ** wheeee
130:                 **
131:                 ** Revision 1.1  2001/04/27 12:54:40  neil
132:                 ** blah
133:                 **
134:                 ** Revision 1.1  2001/04/27 10:57:41  neil
135:                 ** wheee
136:                 **
137:                 ** Revision 1.1  2000/12/27 04:24:46  matt
138:                 ** initial revision
139:                 **
140:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map099.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map99.c
21:                  **
22:                  ** mapper 99 interface
23:                  ** $Id: map099.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes_ppu.h>
29:                  
30:                  /* Switch VROM for VS games */
31:                  static void map99_vromswitch(uint8 value)
32:                  {
9D03BDFC  27BDFFE8   ADDIU SP, SP, -24
9D03BE00  AFBF0014   SW RA, 20(SP)
33:                     int bank = (value & 0x04) >> 2;
9D03BE04  7C860080   EXT A2, A0, 2, 1
34:                     mmc_bankvrom(8, 0x0000, bank);
9D03BE08  24040008   ADDIU A0, ZERO, 8
9D03BE0C  0F40B41B   JAL mmc_bankvrom
9D03BE10  00002821   ADDU A1, ZERO, ZERO
35:                  }
9D03BE14  8FBF0014   LW RA, 20(SP)
9D03BE18  03E00008   JR RA
9D03BE1C  27BD0018   ADDIU SP, SP, 24
36:                  
37:                  /* mapper 99: VS. System */
38:                  static void map99_init(void)
39:                  {
9D03BDC8  27BDFFE8   ADDIU SP, SP, -24
9D03BDCC  AFBF0014   SW RA, 20(SP)
40:                     ppu_mirror(0, 1, 2, 3);
9D03BDD0  00002021   ADDU A0, ZERO, ZERO
9D03BDD4  24050001   ADDIU A1, ZERO, 1
9D03BDD8  24060002   ADDIU A2, ZERO, 2
9D03BDDC  0F40635D   JAL ppu_mirror
9D03BDE0  24070003   ADDIU A3, ZERO, 3
41:                     ppu_setvromswitch(map99_vromswitch);
9D03BDE4  3C049D04   LUI A0, -25340
9D03BDE8  0F4065C9   JAL ppu_setvromswitch
9D03BDEC  2484BDFC   ADDIU A0, A0, -16900
42:                  }
9D03BDF0  8FBF0014   LW RA, 20(SP)
9D03BDF4  03E00008   JR RA
9D03BDF8  27BD0018   ADDIU SP, SP, 24
43:                  
44:                  mapintf_t map99_intf =
45:                  {
46:                     99, /* mapper number */
47:                     "VS. System", /* mapper name */
48:                     map99_init, /* init routine */
49:                     NULL, /* vblank callback */
50:                     NULL, /* hblank callback */
51:                     NULL, /* get state (snss) */
52:                     NULL, /* set state (snss) */
53:                     NULL, /* memory read structure */
54:                     NULL, /* memory write structure */
55:                     NULL /* external sound device */
56:                  };
57:                  
58:                  /*
59:                  ** $Log: map099.c,v $
60:                  ** Revision 1.2  2001/04/27 14:37:11  neil
61:                  ** wheeee
62:                  **
63:                  ** Revision 1.1  2001/04/27 12:54:40  neil
64:                  ** blah
65:                  **
66:                  ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
67:                  ** initial
68:                  **
69:                  ** Revision 1.1  2000/10/24 12:19:33  matt
70:                  ** changed directory structure
71:                  **
72:                  ** Revision 1.6  2000/10/22 19:17:47  matt
73:                  ** mapper cleanups galore
74:                  **
75:                  ** Revision 1.5  2000/10/21 19:33:38  matt
76:                  ** many more cleanups
77:                  **
78:                  ** Revision 1.4  2000/10/10 13:58:17  matt
79:                  ** stroustrup squeezing his way in the door
80:                  **
81:                  ** Revision 1.3  2000/07/10 05:29:03  matt
82:                  ** cleaned up some mirroring issues
83:                  **
84:                  ** Revision 1.2  2000/07/06 02:48:43  matt
85:                  ** clearly labelled structure members
86:                  **
87:                  ** Revision 1.1  2000/07/05 05:05:18  matt
88:                  ** initial revision
89:                  **
90:                  */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map094.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map94.c
21:                  **
22:                  ** mapper 94 interface
23:                  ** $Id: map094.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  
29:                  /* mapper 94: Senjou no Ookami */
30:                  static void map94_write(uint32 address, uint8 value)
31:                  {
9D03C75C  27BDFFE8   ADDIU SP, SP, -24
9D03C760  AFBF0014   SW RA, 20(SP)
32:                     UNUSED(address);
33:                  
34:                     /* ($8000-$FFFF) D7-D2 = switch $8000-$BFFF */
35:                     mmc_bankrom(16, 0x8000, value >> 2);
9D03C764  00053082   SRL A2, A1, 2
9D03C768  24040010   ADDIU A0, ZERO, 16
9D03C76C  0F40B479   JAL mmc_bankrom
9D03C770  34058000   ORI A1, ZERO, -32768
36:                  }
9D03C774  8FBF0014   LW RA, 20(SP)
9D03C778  03E00008   JR RA
9D03C77C  27BD0018   ADDIU SP, SP, 24
37:                  
38:                  static map_memwrite map94_memwrite[] =
39:                  {
40:                     { 0x8000, 0xFFFF, map94_write },
41:                     {     -1,     -1, NULL }
42:                  };
43:                  
44:                  mapintf_t map94_intf =
45:                  {
46:                     94, /* mapper number */
47:                     "Mapper 94", /* mapper name */
48:                     NULL, /* init routine */
49:                     NULL, /* vblank callback */
50:                     NULL, /* hblank callback */
51:                     NULL, /* get state (snss) */
52:                     NULL, /* set state (snss) */
53:                     NULL, /* memory read structure */
54:                     map94_memwrite, /* memory write structure */
55:                     NULL /* external sound device */
56:                  };
57:                  
58:                  /*
59:                  ** $Log: map094.c,v $
60:                  ** Revision 1.2  2001/04/27 14:37:11  neil
61:                  ** wheeee
62:                  **
63:                  ** Revision 1.1  2001/04/27 12:54:40  neil
64:                  ** blah
65:                  **
66:                  ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
67:                  ** initial
68:                  **
69:                  ** Revision 1.1  2000/10/24 12:19:33  matt
70:                  ** changed directory structure
71:                  **
72:                  ** Revision 1.5  2000/10/22 19:17:47  matt
73:                  ** mapper cleanups galore
74:                  **
75:                  ** Revision 1.4  2000/10/21 19:33:38  matt
76:                  ** many more cleanups
77:                  **
78:                  ** Revision 1.3  2000/08/16 02:50:11  matt
79:                  ** random mapper cleanups
80:                  **
81:                  ** Revision 1.2  2000/07/06 02:48:43  matt
82:                  ** clearly labelled structure members
83:                  **
84:                  ** Revision 1.1  2000/07/06 01:01:56  matt
85:                  ** initial revision
86:                  **
87:                  */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map093.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map93.c
21:                  **
22:                  ** mapper 93 interface
23:                  ** $Id: map093.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes_ppu.h>
29:                  
30:                  static void map93_write(uint32 address, uint8 value)
31:                  {
9D03BA70  27BDFFE8   ADDIU SP, SP, -24
9D03BA74  AFBF0014   SW RA, 20(SP)
9D03BA78  AFB00010   SW S0, 16(SP)
9D03BA7C  00A08021   ADDU S0, A1, ZERO
32:                     UNUSED(address);
33:                  
34:                     /* ($8000-$FFFF) D7-D4 = switch $8000-$BFFF D0: mirror */
35:                     mmc_bankrom(16, 0x8000, value >> 4);
9D03BA80  24040010   ADDIU A0, ZERO, 16
9D03BA84  34058000   ORI A1, ZERO, -32768
9D03BA88  0F40B479   JAL mmc_bankrom
9D03BA8C  00103102   SRL A2, S0, 4
36:                  
37:                     if (value & 1)
9D03BA90  32100001   ANDI S0, S0, 1
9D03BA94  12000007   BEQ S0, ZERO, 0x9D03BAB4
9D03BA98  00002021   ADDU A0, ZERO, ZERO
38:                        ppu_mirror(0, 1, 0, 1); /* vert */
9D03BA9C  24050001   ADDIU A1, ZERO, 1
9D03BAA0  00003021   ADDU A2, ZERO, ZERO
9D03BAA4  0F40635D   JAL ppu_mirror
9D03BAA8  24070001   ADDIU A3, ZERO, 1
9D03BAAC  0B40EEB2   J 0x9D03BAC8
9D03BAB0  8FBF0014   LW RA, 20(SP)
39:                     else
40:                        ppu_mirror(0, 0, 1, 1); /* horiz */
9D03BAB4  00002821   ADDU A1, ZERO, ZERO
9D03BAB8  24060001   ADDIU A2, ZERO, 1
9D03BABC  0F40635D   JAL ppu_mirror
9D03BAC0  24070001   ADDIU A3, ZERO, 1
41:                  }
9D03BAC4  8FBF0014   LW RA, 20(SP)
9D03BAC8  8FB00010   LW S0, 16(SP)
9D03BACC  03E00008   JR RA
9D03BAD0  27BD0018   ADDIU SP, SP, 24
42:                  
43:                  static map_memwrite map93_memwrite[] =
44:                  {
45:                     { 0x8000, 0xFFFF, map93_write },
46:                     {     -1,     -1, NULL }
47:                  };
48:                  
49:                  mapintf_t map93_intf =
50:                  {
51:                     93, /* mapper number */
52:                     "Mapper 93", /* mapper name */
53:                     NULL, /* init routine */
54:                     NULL, /* vblank callback */
55:                     NULL, /* hblank callback */
56:                     NULL, /* get state (snss) */
57:                     NULL, /* set state (snss) */
58:                     NULL, /* memory read structure */
59:                     map93_memwrite, /* memory write structure */
60:                     NULL /* external sound device */
61:                  };
62:                  
63:                  /*
64:                  ** $Log: map093.c,v $
65:                  ** Revision 1.2  2001/04/27 14:37:11  neil
66:                  ** wheeee
67:                  **
68:                  ** Revision 1.1  2001/04/27 12:54:40  neil
69:                  ** blah
70:                  **
71:                  ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
72:                  ** initial
73:                  **
74:                  ** Revision 1.1  2000/12/11 12:33:48  matt
75:                  ** initial revision
76:                  **
77:                  */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map087.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map087.c
21:                  **
22:                  ** Mapper #87 (16K VROM switch)
23:                  ** Implementation by Firebug
24:                  ** $Id: map087.c,v 1.2 2001/04/27 14:37:11 neil Exp $
25:                  **
26:                  */
27:                  
28:                  #include <noftypes.h>
29:                  #include <nes_mmc.h>
30:                  #include <nes.h>
31:                  #include <libsnss.h>
32:                  #include <log.h>
33:                  
34:                  /******************************************/
35:                  /* Mapper #87 write handler ($6000-$7FFF) */
36:                  /******************************************/
37:                  static void map87_write (uint32 address, uint8 value)
38:                  {
9D03C058  27BDFFE8   ADDIU SP, SP, -24
39:                    /* Within range, address written to is irrelevant */
40:                    UNUSED (address);
41:                  
42:                    /* Very simple: 8K CHR page is selected by D1 */
43:                    if (value & 0x02) mmc_bankvrom (8, 0x0000, 0x01);
9D03C05C  30A50002   ANDI A1, A1, 2
9D03C060  30A500FF   ANDI A1, A1, 255
9D03C064  10A00007   BEQ A1, ZERO, 0x9D03C084
9D03C068  AFBF0014   SW RA, 20(SP)
9D03C06C  24040008   ADDIU A0, ZERO, 8
9D03C070  00002821   ADDU A1, ZERO, ZERO
9D03C074  0F40B41B   JAL mmc_bankvrom
9D03C078  24060001   ADDIU A2, ZERO, 1
9D03C07C  0B40F026   J 0x9D03C098
9D03C080  8FBF0014   LW RA, 20(SP)
44:                    else              mmc_bankvrom (8, 0x0000, 0x00);
9D03C084  24040008   ADDIU A0, ZERO, 8
9D03C088  00002821   ADDU A1, ZERO, ZERO
9D03C08C  0F40B41B   JAL mmc_bankvrom
9D03C090  00003021   ADDU A2, ZERO, ZERO
45:                  
46:                    /* Done */
47:                    return;
48:                  }
9D03C094  8FBF0014   LW RA, 20(SP)
9D03C098  03E00008   JR RA
9D03C09C  27BD0018   ADDIU SP, SP, 24
49:                  
50:                  static map_memwrite map87_memwrite [] =
51:                  {
52:                     { 0x6000, 0x7FFF, map87_write },
53:                     {     -1,     -1, NULL }
54:                  };
55:                  
56:                  mapintf_t map87_intf =
57:                  {
58:                     87,                               /* Mapper number */
59:                     "16K VROM switch",                /* Mapper name */
60:                     NULL,                             /* Initialization routine */
61:                     NULL,                             /* VBlank callback */
62:                     NULL,                             /* HBlank callback */
63:                     NULL,                             /* Get state (SNSS) */
64:                     NULL,                             /* Set state (SNSS) */
65:                     NULL,                             /* Memory read structure */
66:                     map87_memwrite,                   /* Memory write structure */
67:                     NULL                              /* External sound device */
68:                  };
69:                  
70:                  /*
71:                  ** $Log: map087.c,v $
72:                  ** Revision 1.2  2001/04/27 14:37:11  neil
73:                  ** wheeee
74:                  **
75:                  ** Revision 1.1  2001/04/27 12:54:40  neil
76:                  ** blah
77:                  **
78:                  ** Revision 1.1  2001/04/27 10:57:41  neil
79:                  ** wheee
80:                  **
81:                  ** Revision 1.1  2000/12/30 06:34:44  firebug
82:                  ** Initial revision
83:                  **
84:                  **
85:                  */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map085.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map85.c
21:                  **
22:                  ** mapper 85 interface
23:                  ** $Id: map085.c,v 1.3 2001/05/06 01:42:03 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes.h>
29:                  #include <log.h>
30:                  
31:                  static struct
32:                  {
33:                     int counter, latch;
34:                     int wait_state;
35:                     bool enabled;
36:                  } irq;
37:                  
38:                  /* mapper 85: Konami VRC7 */
39:                  static void map85_write(uint32 address, uint8 value)
40:                  {
9D032F10  27BDFFE8   ADDIU SP, SP, -24
41:                     uint8 bank = address >> 12;
42:                     uint8 reg = (address & 0x10) | ((address & 0x08) << 1);
9D032F14  308200FF   ANDI V0, A0, 255
9D032F18  30430008   ANDI V1, V0, 8
9D032F1C  00031840   SLL V1, V1, 1
9D032F20  30420010   ANDI V0, V0, 16
9D032F24  00621025   OR V0, V1, V0
9D032F28  7C843B00   EXT A0, A0, 12, 8
43:                  
44:                     switch (bank)
9D032F2C  2484FFF8   ADDIU A0, A0, -8
9D032F30  2C830008   SLTIU V1, A0, 8
9D032F34  1060007F   BEQ V1, ZERO, 0x9D033134
9D032F38  AFBF0014   SW RA, 20(SP)
9D032F3C  00042080   SLL A0, A0, 2
9D032F40  3C039D03   LUI V1, -25341
9D032F44  24632F58   ADDIU V1, V1, 12120
9D032F48  00642021   ADDU A0, V1, A0
9D032F4C  8C830000   LW V1, 0(A0)
9D032F50  00600008   JR V1
9D032F54  00A03021   ADDU A2, A1, ZERO
45:                     {
46:                     case 0x08:
47:                        if (0x10 == reg)
9D032F78  10400005   BEQ V0, ZERO, 0x9D032F90
9D032F7C  24040008   ADDIU A0, ZERO, 8
48:                           mmc_bankrom(8, 0xA000, value);
9D032F80  0F40B479   JAL mmc_bankrom
9D032F84  3405A000   ORI A1, ZERO, -24576
9D032F88  0B40CC4E   J 0x9D033138
9D032F8C  8FBF0014   LW RA, 20(SP)
49:                        else
50:                           mmc_bankrom(8, 0x8000, value);
9D032F90  0F40B479   JAL mmc_bankrom
9D032F94  34058000   ORI A1, ZERO, -32768
51:                        break;
52:                  
53:                     case 0x09:
54:                        /* 0x10 & 0x30 should be trapped by sound emulation */
55:                        mmc_bankrom(8, 0xC000, value);
9D032FA0  24040008   ADDIU A0, ZERO, 8
9D032FA4  0F40B479   JAL mmc_bankrom
9D032FA8  3405C000   ORI A1, ZERO, -16384
56:                        break;
9D032FAC  0B40CC4E   J 0x9D033138
9D032FB0  8FBF0014   LW RA, 20(SP)
57:                  
58:                     case 0x0A:
59:                        if (0x10 == reg)
9D032FB4  10400005   BEQ V0, ZERO, 0x9D032FCC
9D032FB8  24040001   ADDIU A0, ZERO, 1
60:                           mmc_bankvrom(1, 0x0400, value);
9D032FBC  0F40B41B   JAL mmc_bankvrom
9D032FC0  24050400   ADDIU A1, ZERO, 1024
9D032FC4  0B40CC4E   J 0x9D033138
9D032FC8  8FBF0014   LW RA, 20(SP)
61:                        else
62:                           mmc_bankvrom(1, 0x0000, value);
9D032FCC  0F40B41B   JAL mmc_bankvrom
9D032FD0  00002821   ADDU A1, ZERO, ZERO
63:                        break;
64:                  
65:                     case 0x0B:
66:                        if (0x10 == reg)
9D032FDC  10400005   BEQ V0, ZERO, 0x9D032FF4
9D032FE0  24040001   ADDIU A0, ZERO, 1
67:                           mmc_bankvrom(1, 0x0C00, value);
9D032FE4  0F40B41B   JAL mmc_bankvrom
9D032FE8  24050C00   ADDIU A1, ZERO, 3072
9D032FEC  0B40CC4E   J 0x9D033138
9D032FF0  8FBF0014   LW RA, 20(SP)
68:                        else
69:                           mmc_bankvrom(1, 0x0800, value);
9D032FF4  0F40B41B   JAL mmc_bankvrom
9D032FF8  24050800   ADDIU A1, ZERO, 2048
70:                        break;
71:                  
72:                     case 0x0C:
73:                        if (0x10 == reg)
9D033004  10400005   BEQ V0, ZERO, 0x9D03301C
9D033008  24040001   ADDIU A0, ZERO, 1
74:                           mmc_bankvrom(1, 0x1400, value);
9D03300C  0F40B41B   JAL mmc_bankvrom
9D033010  24051400   ADDIU A1, ZERO, 5120
9D033014  0B40CC4E   J 0x9D033138
9D033018  8FBF0014   LW RA, 20(SP)
75:                        else
76:                           mmc_bankvrom(1, 0x1000, value);
9D03301C  0F40B41B   JAL mmc_bankvrom
9D033020  24051000   ADDIU A1, ZERO, 4096
77:                        break;
78:                  
79:                     case 0x0D:
80:                        if (0x10 == reg)
9D03302C  10400005   BEQ V0, ZERO, 0x9D033044
9D033030  24040001   ADDIU A0, ZERO, 1
81:                           mmc_bankvrom(1, 0x1C00, value);
9D033034  0F40B41B   JAL mmc_bankvrom
9D033038  24051C00   ADDIU A1, ZERO, 7168
9D03303C  0B40CC4E   J 0x9D033138
9D033040  8FBF0014   LW RA, 20(SP)
82:                        else
83:                           mmc_bankvrom(1, 0x1800, value);
9D033044  0F40B41B   JAL mmc_bankvrom
9D033048  24051800   ADDIU A1, ZERO, 6144
84:                        break;
85:                  
86:                     case 0x0E:
87:                        if (0x10 == reg)
9D033054  10400004   BEQ V0, ZERO, 0x9D033068
9D033058  30A60003   ANDI A2, A1, 3
88:                        {
89:                           irq.latch = value;
9D03305C  3C02A001   LUI V0, -24575
9D033060  0B40CC4D   J 0x9D033134
9D033064  AC45B8A0   SW A1, -18272(V0)
90:                        }
91:                        else
92:                        {
93:                           switch (value & 3)
9D033068  24020001   ADDIU V0, ZERO, 1
9D03306C  10C2000F   BEQ A2, V0, 0x9D0330AC
9D033070  00002021   ADDU A0, ZERO, ZERO
9D033074  10C00007   BEQ A2, ZERO, 0x9D033094
9D033078  24020002   ADDIU V0, ZERO, 2
9D03307C  10C20011   BEQ A2, V0, 0x9D0330C4
9D033080  24020003   ADDIU V0, ZERO, 3
9D033084  10C20015   BEQ A2, V0, 0x9D0330DC
9D033088  24040001   ADDIU A0, ZERO, 1
94:                           {
95:                           case 0:
96:                              ppu_mirror(0, 1, 0, 1); /* vertical */
9D033094  24050001   ADDIU A1, ZERO, 1
9D033098  00003021   ADDU A2, ZERO, ZERO
9D03309C  0F40635D   JAL ppu_mirror
9D0330A0  24070001   ADDIU A3, ZERO, 1
97:                              break;
9D0330A4  0B40CC4E   J 0x9D033138
9D0330A8  8FBF0014   LW RA, 20(SP)
98:                  
99:                           case 1:
100:                             ppu_mirror(0, 0, 1, 1); /* horizontal */
9D0330AC  00002821   ADDU A1, ZERO, ZERO
9D0330B0  24060001   ADDIU A2, ZERO, 1
9D0330B4  0F40635D   JAL ppu_mirror
9D0330B8  24070001   ADDIU A3, ZERO, 1
101:                             break;
9D0330BC  0B40CC4E   J 0x9D033138
9D0330C0  8FBF0014   LW RA, 20(SP)
102:                 
103:                          case 2:
104:                             ppu_mirror(0, 0, 0, 0);
9D0330C4  00002821   ADDU A1, ZERO, ZERO
9D0330C8  00003021   ADDU A2, ZERO, ZERO
9D0330CC  0F40635D   JAL ppu_mirror
9D0330D0  00003821   ADDU A3, ZERO, ZERO
105:                             break;
9D0330D4  0B40CC4E   J 0x9D033138
9D0330D8  8FBF0014   LW RA, 20(SP)
106:                 
107:                          case 3:
108:                             ppu_mirror(1, 1, 1, 1);
9D0330DC  24050001   ADDIU A1, ZERO, 1
9D0330E0  24060001   ADDIU A2, ZERO, 1
9D0330E4  0F40635D   JAL ppu_mirror
9D0330E8  24070001   ADDIU A3, ZERO, 1
109:                             break;
9D0330EC  0B40CC4E   J 0x9D033138
9D0330F0  8FBF0014   LW RA, 20(SP)
110:                          }
111:                       }
112:                       break;
113:                 
114:                    case 0x0F:
115:                       if (0x10 == reg)
9D0330F4  10400005   BEQ V0, ZERO, 0x9D03310C
9D0330F8  3C02A001   LUI V0, -24575
116:                       {
117:                          irq.enabled = irq.wait_state;
9D0330FC  2442B89C   ADDIU V0, V0, -18276
9D033100  8C430008   LW V1, 8(V0)
9D033104  0B40CC4D   J 0x9D033134
9D033108  AC43000C   SW V1, 12(V0)
118:                       }
119:                       else
120:                       {
121:                          irq.wait_state = value & 0x01;
9D03310C  2442B89C   ADDIU V0, V0, -18276
9D033110  30A30001   ANDI V1, A1, 1
9D033114  AC430008   SW V1, 8(V0)
122:                          irq.enabled = (value & 0x02) ? true : false;
9D033118  7CA60040   EXT A2, A1, 1, 1
123:                          if (true == irq.enabled)
9D03311C  10C00005   BEQ A2, ZERO, 0x9D033134
9D033120  AC46000C   SW A2, 12(V0)
124:                             irq.counter = irq.latch;
9D033124  3C02A001   LUI V0, -24575
9D033128  2443B89C   ADDIU V1, V0, -18276
9D03312C  8C630004   LW V1, 4(V1)
9D033130  AC43B89C   SW V1, -18276(V0)
125:                       }
126:                       break;
127:                 
128:                    default:
129:                 #ifdef NOFRENDO_DEBUG
130:                       log_printf("unhandled vrc7 write: $%02X to $%04X\n", value, address);
131:                 #endif /* NOFRENDO_DEBUG */
132:                       break;
133:                    }
134:                 }
9D032F98  0B40CC4E   J 0x9D033138
9D032F9C  8FBF0014   LW RA, 20(SP)
9D032FD4  0B40CC4E   J 0x9D033138
9D032FD8  8FBF0014   LW RA, 20(SP)
9D032FFC  0B40CC4E   J 0x9D033138
9D033000  8FBF0014   LW RA, 20(SP)
9D033024  0B40CC4E   J 0x9D033138
9D033028  8FBF0014   LW RA, 20(SP)
9D03304C  0B40CC4E   J 0x9D033138
9D033050  8FBF0014   LW RA, 20(SP)
9D03308C  0B40CC4E   J 0x9D033138
9D033090  8FBF0014   LW RA, 20(SP)
9D033134  8FBF0014   LW RA, 20(SP)
9D033138  03E00008   JR RA
9D03313C  27BD0018   ADDIU SP, SP, 24
135:                 
136:                 static void map85_hblank(int vblank)
137:                 {
9D033168  27BDFFE8   ADDIU SP, SP, -24
9D03316C  AFBF0014   SW RA, 20(SP)
138:                    UNUSED(vblank);
139:                 
140:                    if (irq.enabled)
9D033140  3C02A001   LUI V0, -24575
9D033144  8C42B8A8   LW V0, -18264(V0)
9D033148  1040000F   BEQ V0, ZERO, 0x9D033188
9D03314C  3C03A001   LUI V1, -24575
141:                    {
142:                       if (++irq.counter > 0xFF)
9D033150  8C62B89C   LW V0, -18276(V1)
9D033154  24420001   ADDIU V0, V0, 1
9D033158  AC62B89C   SW V0, -18276(V1)
9D03315C  28420100   SLTI V0, V0, 256
9D033160  14400009   BNE V0, ZERO, 0x9D033188
9D033164  00601021   ADDU V0, V1, ZERO
143:                       {
144:                          irq.counter = irq.latch;
9D033170  2463B89C   ADDIU V1, V1, -18276
9D033174  8C630004   LW V1, 4(V1)
145:                          nes_irq();
9D033178  0F408C7B   JAL nes_irq
9D03317C  AC43B89C   SW V1, -18276(V0)
146:                 
147:                          //return;
148:                       }
149:                       //irq.counter++;
150:                    }
151:                 }
9D033180  8FBF0014   LW RA, 20(SP)
9D033184  27BD0018   ADDIU SP, SP, 24
9D033188  03E00008   JR RA
9D03318C  00000000   NOP
152:                 
153:                 static map_memwrite map85_memwrite[] =
154:                 {
155:                    { 0x8000, 0xFFFF, map85_write },
156:                    {     -1,     -1, NULL }
157:                 };
158:                 
159:                 static void map85_init(void)
160:                 {
9D032EB4  27BDFFE8   ADDIU SP, SP, -24
9D032EB8  AFBF0014   SW RA, 20(SP)
161:                    mmc_bankrom(16, 0x8000, 0);
9D032EBC  24040010   ADDIU A0, ZERO, 16
9D032EC0  34058000   ORI A1, ZERO, -32768
9D032EC4  0F40B479   JAL mmc_bankrom
9D032EC8  00003021   ADDU A2, ZERO, ZERO
162:                    mmc_bankrom(16, 0xC000, MMC_LASTBANK);
9D032ECC  24040010   ADDIU A0, ZERO, 16
9D032ED0  3405C000   ORI A1, ZERO, -16384
9D032ED4  0F40B479   JAL mmc_bankrom
9D032ED8  2406FFFF   ADDIU A2, ZERO, -1
163:                    
164:                    mmc_bankvrom(8, 0x0000, 0);
9D032EDC  24040008   ADDIU A0, ZERO, 8
9D032EE0  00002821   ADDU A1, ZERO, ZERO
9D032EE4  0F40B41B   JAL mmc_bankvrom
9D032EE8  00003021   ADDU A2, ZERO, ZERO
165:                 
166:                    irq.counter = irq.latch = 0;
9D032EEC  3C03A001   LUI V1, -24575
9D032EF0  2462B89C   ADDIU V0, V1, -18276
9D032EF4  AC400004   SW ZERO, 4(V0)
9D032EF8  AC60B89C   SW ZERO, -18276(V1)
167:                    irq.wait_state = 0;
9D032EFC  AC400008   SW ZERO, 8(V0)
168:                    irq.enabled = false;
9D032F00  AC40000C   SW ZERO, 12(V0)
169:                 }
9D032F04  8FBF0014   LW RA, 20(SP)
9D032F08  03E00008   JR RA
9D032F0C  27BD0018   ADDIU SP, SP, 24
170:                 
171:                 mapintf_t map85_intf = 
172:                 {
173:                    85, /* mapper number */
174:                    "Konami VRC7", /* mapper name */
175:                    map85_init, /* init routine */
176:                    NULL, /* vblank callback */
177:                    map85_hblank, /* hblank callback */
178:                    NULL, /* get state (snss) */
179:                    NULL, /* set state (snss) */
180:                    NULL, /* memory read structure */
181:                    map85_memwrite, /* memory write structure */
182:                    NULL
183:                 };
184:                 
185:                 /*
186:                 ** $Log: map085.c,v $
187:                 ** Revision 1.3  2001/05/06 01:42:03  neil
188:                 ** boooo
189:                 **
190:                 ** Revision 1.2  2001/04/27 14:37:11  neil
191:                 ** wheeee
192:                 **
193:                 ** Revision 1.1  2001/04/27 12:54:40  neil
194:                 ** blah
195:                 **
196:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
197:                 ** initial
198:                 **
199:                 ** Revision 1.1  2000/10/24 12:19:33  matt
200:                 ** changed directory structure
201:                 **
202:                 ** Revision 1.10  2000/10/22 19:17:46  matt
203:                 ** mapper cleanups galore
204:                 **
205:                 ** Revision 1.9  2000/10/22 15:03:14  matt
206:                 ** simplified mirroring
207:                 **
208:                 ** Revision 1.8  2000/10/21 19:33:38  matt
209:                 ** many more cleanups
210:                 **
211:                 ** Revision 1.7  2000/10/10 13:58:17  matt
212:                 ** stroustrup squeezing his way in the door
213:                 **
214:                 ** Revision 1.6  2000/08/16 02:50:11  matt
215:                 ** random mapper cleanups
216:                 **
217:                 ** Revision 1.5  2000/07/23 14:37:21  matt
218:                 ** added a break statement
219:                 **
220:                 ** Revision 1.4  2000/07/15 23:52:19  matt
221:                 ** rounded out a bunch more mapper interfaces
222:                 **
223:                 ** Revision 1.3  2000/07/10 13:51:25  matt
224:                 ** using generic nes_irq() routine now
225:                 **
226:                 ** Revision 1.2  2000/07/10 05:29:03  matt
227:                 ** cleaned up some mirroring issues
228:                 **
229:                 ** Revision 1.1  2000/07/06 02:47:47  matt
230:                 ** initial revision
231:                 **
232:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map079.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map78.c
21:                  **
22:                  ** mapper 78 interface
23:                  ** $Id: map079.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  
29:                  /* mapper 79: NINA-03/06 */
30:                  static void map79_write(uint32 address, uint8 value)
31:                  {
9D03B074  27BDFFE8   ADDIU SP, SP, -24
9D03B078  AFBF0014   SW RA, 20(SP)
9D03B07C  AFB00010   SW S0, 16(SP)
9D03B080  00A08021   ADDU S0, A1, ZERO
32:                     if ((address & 0x5100) == 0x4100)
9D03B064  30845100   ANDI A0, A0, 20736
9D03B068  24024100   ADDIU V0, ZERO, 16640
9D03B06C  1482000F   BNE A0, V0, 0x9D03B0AC
9D03B070  24040020   ADDIU A0, ZERO, 32
33:                     {
34:                        mmc_bankrom(32, 0x8000, (value >> 3) & 1);
9D03B084  34058000   ORI A1, ZERO, -32768
9D03B088  0F40B479   JAL mmc_bankrom
9D03B08C  7E0600C0   EXT A2, S0, 3, 1
35:                        mmc_bankvrom(8, 0x0000, value & 7);
9D03B090  24040008   ADDIU A0, ZERO, 8
9D03B094  00002821   ADDU A1, ZERO, ZERO
9D03B098  0F40B41B   JAL mmc_bankvrom
9D03B09C  32060007   ANDI A2, S0, 7
36:                     }
37:                  }
9D03B0A0  8FBF0014   LW RA, 20(SP)
9D03B0A4  8FB00010   LW S0, 16(SP)
9D03B0A8  27BD0018   ADDIU SP, SP, 24
9D03B0AC  03E00008   JR RA
9D03B0B0  00000000   NOP
38:                  
39:                  static void map79_init(void)
40:                  {
9D03B0B4  27BDFFE8   ADDIU SP, SP, -24
9D03B0B8  AFBF0014   SW RA, 20(SP)
41:                     mmc_bankrom(32, 0x8000, 0);
9D03B0BC  24040020   ADDIU A0, ZERO, 32
9D03B0C0  34058000   ORI A1, ZERO, -32768
9D03B0C4  0F40B479   JAL mmc_bankrom
9D03B0C8  00003021   ADDU A2, ZERO, ZERO
42:                     mmc_bankvrom(8, 0x0000, 0);
9D03B0CC  24040008   ADDIU A0, ZERO, 8
9D03B0D0  00002821   ADDU A1, ZERO, ZERO
9D03B0D4  0F40B41B   JAL mmc_bankvrom
9D03B0D8  00003021   ADDU A2, ZERO, ZERO
43:                  }
9D03B0DC  8FBF0014   LW RA, 20(SP)
9D03B0E0  03E00008   JR RA
9D03B0E4  27BD0018   ADDIU SP, SP, 24
44:                  
45:                  static map_memwrite map79_memwrite[] =
46:                  {
47:                     { 0x4100, 0x5FFF, map79_write }, /* ????? incorrect range ??? */
48:                     {     -1,     -1, NULL }
49:                  };
50:                  
51:                  mapintf_t map79_intf =
52:                  {
53:                     79, /* mapper number */
54:                     "NINA-03/06", /* mapper name */
55:                     map79_init, /* init routine */
56:                     NULL, /* vblank callback */
57:                     NULL, /* hblank callback */
58:                     NULL, /* get state (snss) */
59:                     NULL, /* set state (snss) */
60:                     NULL, /* memory read structure */
61:                     map79_memwrite, /* memory write structure */
62:                     NULL /* external sound device */
63:                  };
64:                  
65:                  /*
66:                  ** $Log: map079.c,v $
67:                  ** Revision 1.2  2001/04/27 14:37:11  neil
68:                  ** wheeee
69:                  **
70:                  ** Revision 1.1  2001/04/27 12:54:40  neil
71:                  ** blah
72:                  **
73:                  ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
74:                  ** initial
75:                  **
76:                  ** Revision 1.1  2000/10/24 12:19:33  matt
77:                  ** changed directory structure
78:                  **
79:                  ** Revision 1.4  2000/10/22 19:17:47  matt
80:                  ** mapper cleanups galore
81:                  **
82:                  ** Revision 1.3  2000/10/21 19:33:38  matt
83:                  ** many more cleanups
84:                  **
85:                  ** Revision 1.2  2000/07/06 02:48:43  matt
86:                  ** clearly labelled structure members
87:                  **
88:                  ** Revision 1.1  2000/07/06 01:01:56  matt
89:                  ** initial revision
90:                  **
91:                  */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map078.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map78.c
21:                  **
22:                  ** mapper 78 interface
23:                  ** $Id: map078.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes_ppu.h>
29:                  
30:                  /* mapper 78: Holy Diver, Cosmo Carrier */
31:                  /* ($8000-$FFFF) D2-D0 = switch $8000-$BFFF */
32:                  /* ($8000-$FFFF) D7-D4 = switch PPU $0000-$1FFF */
33:                  /* ($8000-$FFFF) D3 = switch mirroring */
34:                  static void map78_write(uint32 address, uint8 value)
35:                  {
9D03A498  27BDFFE8   ADDIU SP, SP, -24
9D03A49C  AFBF0014   SW RA, 20(SP)
9D03A4A0  AFB00010   SW S0, 16(SP)
9D03A4A4  00A08021   ADDU S0, A1, ZERO
36:                     UNUSED(address);
37:                  
38:                     mmc_bankrom(16, 0x8000, value & 7);
9D03A4A8  24040010   ADDIU A0, ZERO, 16
9D03A4AC  34058000   ORI A1, ZERO, -32768
9D03A4B0  0F40B479   JAL mmc_bankrom
9D03A4B4  32060007   ANDI A2, S0, 7
39:                     mmc_bankvrom(8, 0x0000, (value >> 4) & 0x0F);
9D03A4B8  24040008   ADDIU A0, ZERO, 8
9D03A4BC  00002821   ADDU A1, ZERO, ZERO
9D03A4C0  0F40B41B   JAL mmc_bankvrom
9D03A4C4  00103102   SRL A2, S0, 4
40:                  
41:                     /* Ugh! Same abuse of the 4-screen bit as with Mapper #70 */
42:                     if (mmc_getinfo()->flags & ROM_FLAG_FOURSCREEN)
9D03A4C8  0F40B40F   JAL mmc_getinfo
9D03A4CC  00000000   NOP
9D03A4D0  90420028   LBU V0, 40(V0)
9D03A4D4  30420004   ANDI V0, V0, 4
9D03A4D8  304200FF   ANDI V0, V0, 255
9D03A4DC  10400011   BEQ V0, ZERO, .LBB2
9D03A4E0  7E0700C0   EXT A3, S0, 3, 1
43:                     {
44:                        if (value & 0x08)
9D03A4E4  32100008   ANDI S0, S0, 8
9D03A4E8  321000FF   ANDI S0, S0, 255
9D03A4EC  12000007   BEQ S0, ZERO, 0x9D03A50C
9D03A4F0  00002021   ADDU A0, ZERO, ZERO
45:                           ppu_mirror(0, 1, 0, 1); /* vert */
9D03A4F4  24050001   ADDIU A1, ZERO, 1
9D03A4F8  00003021   ADDU A2, ZERO, ZERO
9D03A4FC  0F40635D   JAL ppu_mirror
9D03A500  24070001   ADDIU A3, ZERO, 1
9D03A504  0B40E94E   J 0x9D03A538
9D03A508  8FBF0014   LW RA, 20(SP)
46:                        else
47:                           ppu_mirror(0, 0, 1, 1); /* horiz */
9D03A50C  00002821   ADDU A1, ZERO, ZERO
9D03A510  24060001   ADDIU A2, ZERO, 1
9D03A514  0F40635D   JAL ppu_mirror
9D03A518  24070001   ADDIU A3, ZERO, 1
48:                     }
49:                     else
50:                     {
51:                        int mirror = (value >> 3) & 1;
52:                        ppu_mirror(mirror, mirror, mirror, mirror);
9D03A524  00E02021   ADDU A0, A3, ZERO
9D03A528  00E02821   ADDU A1, A3, ZERO
9D03A52C  0F40635D   JAL ppu_mirror
9D03A530  00E03021   ADDU A2, A3, ZERO
53:                     }
54:                  }
9D03A51C  0B40E94E   J 0x9D03A538
9D03A520  8FBF0014   LW RA, 20(SP)
9D03A534  8FBF0014   LW RA, 20(SP)
9D03A538  8FB00010   LW S0, 16(SP)
9D03A53C  03E00008   JR RA
9D03A540  27BD0018   ADDIU SP, SP, 24
55:                  
56:                  static map_memwrite map78_memwrite[] =
57:                  {
58:                     { 0x8000, 0xFFFF, map78_write },
59:                     {     -1,     -1, NULL }
60:                  };
61:                  
62:                  mapintf_t map78_intf =
63:                  {
64:                     78, /* mapper number */
65:                     "Mapper 78", /* mapper name */
66:                     NULL, /* init routine */
67:                     NULL, /* vblank callback */
68:                     NULL, /* hblank callback */
69:                     NULL, /* get state (snss) */
70:                     NULL, /* set state (snss) */
71:                     NULL, /* memory read structure */
72:                     map78_memwrite, /* memory write structure */
73:                     NULL /* external sound device */
74:                  };
75:                  
76:                  /*
77:                  ** $Log: map078.c,v $
78:                  ** Revision 1.2  2001/04/27 14:37:11  neil
79:                  ** wheeee
80:                  **
81:                  ** Revision 1.1  2001/04/27 12:54:40  neil
82:                  ** blah
83:                  **
84:                  ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
85:                  ** initial
86:                  **
87:                  ** Revision 1.1  2000/10/24 12:19:33  matt
88:                  ** changed directory structure
89:                  **
90:                  ** Revision 1.7  2000/10/22 19:17:46  matt
91:                  ** mapper cleanups galore
92:                  **
93:                  ** Revision 1.6  2000/10/22 15:03:14  matt
94:                  ** simplified mirroring
95:                  **
96:                  ** Revision 1.5  2000/10/21 19:33:38  matt
97:                  ** many more cleanups
98:                  **
99:                  ** Revision 1.4  2000/08/16 02:50:11  matt
100:                 ** random mapper cleanups
101:                 **
102:                 ** Revision 1.3  2000/07/10 05:29:03  matt
103:                 ** cleaned up some mirroring issues
104:                 **
105:                 ** Revision 1.2  2000/07/06 02:48:43  matt
106:                 ** clearly labelled structure members
107:                 **
108:                 ** Revision 1.1  2000/07/06 01:01:56  matt
109:                 ** initial revision
110:                 **
111:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map075.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map75.c
21:                  **
22:                  ** mapper 75 interface
23:                  ** $Id: map075.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes_ppu.h>
29:                  
30:                  
31:                  static uint8 latch[2];
32:                  static uint8 hibits;
33:                  
34:                  /* mapper 75: Konami VRC1 */
35:                  static void map75_write(uint32 address, uint8 value)
36:                  {
9D03686C  27BDFFE8   ADDIU SP, SP, -24
9D036870  AFBF0014   SW RA, 20(SP)
9D036874  AFB00010   SW S0, 16(SP)
37:                     switch ((address & 0xF000) >> 12)
9D036858  7C841B00   EXT A0, A0, 12, 4
9D03685C  2484FFF8   ADDIU A0, A0, -8
9D036860  2C820008   SLTIU V0, A0, 8
9D036864  1040005F   BEQ V0, ZERO, 0x9D0369E4
9D036868  00042080   SLL A0, A0, 2
9D036878  3C029D03   LUI V0, -25341
9D03687C  24426890   ADDIU V0, V0, 26768
9D036880  00442021   ADDU A0, V0, A0
9D036884  8C820000   LW V0, 0(A0)
9D036888  00400008   JR V0
9D03688C  00A08021   ADDU S0, A1, ZERO
38:                     {
39:                     case 0x8:
40:                        mmc_bankrom(8, 0x8000, value);
9D0368B0  24040008   ADDIU A0, ZERO, 8
9D0368B4  34058000   ORI A1, ZERO, -32768
9D0368B8  0F40B479   JAL mmc_bankrom
9D0368BC  02003021   ADDU A2, S0, ZERO
41:                        break;
9D0368C0  0B40DA77   J 0x9D0369DC
9D0368C4  8FBF0014   LW RA, 20(SP)
42:                  
43:                     case 0x9:
44:                        hibits = (value & 0x06);
9D0368C8  30A20006   ANDI V0, A1, 6
9D0368CC  A382805C   SB V0, -32676(GP)
45:                        
46:                        mmc_bankvrom(4, 0x0000, ((hibits & 0x02) << 3) | latch[0]);
9D0368D0  30A60002   ANDI A2, A1, 2
9D0368D4  30C600FF   ANDI A2, A2, 255
9D0368D8  000630C0   SLL A2, A2, 3
9D0368DC  93828060   LBU V0, -32672(GP)
9D0368E0  24040004   ADDIU A0, ZERO, 4
9D0368E4  00002821   ADDU A1, ZERO, ZERO
9D0368E8  0F40B41B   JAL mmc_bankvrom
9D0368EC  00C23025   OR A2, A2, V0
47:                        mmc_bankvrom(4, 0x1000, ((hibits & 0x04) << 2) | latch[1]);
9D0368F0  9386805C   LBU A2, -32676(GP)
9D0368F4  30C60004   ANDI A2, A2, 4
9D0368F8  30C600FF   ANDI A2, A2, 255
9D0368FC  00063080   SLL A2, A2, 2
9D036900  93828061   LBU V0, -32671(GP)
9D036904  24040004   ADDIU A0, ZERO, 4
9D036908  24051000   ADDIU A1, ZERO, 4096
9D03690C  0F40B41B   JAL mmc_bankvrom
9D036910  00C23025   OR A2, A2, V0
48:                  
49:                        if (value & 1)
9D036914  32100001   ANDI S0, S0, 1
9D036918  12000007   BEQ S0, ZERO, 0x9D036938
9D03691C  00002021   ADDU A0, ZERO, ZERO
50:                           ppu_mirror(0, 1, 0, 1); /* vert */
9D036920  24050001   ADDIU A1, ZERO, 1
9D036924  00003021   ADDU A2, ZERO, ZERO
9D036928  0F40635D   JAL ppu_mirror
9D03692C  24070001   ADDIU A3, ZERO, 1
9D036930  0B40DA77   J 0x9D0369DC
9D036934  8FBF0014   LW RA, 20(SP)
51:                        else
52:                           ppu_mirror(0, 0, 1, 1); /* horiz */
9D036938  00002821   ADDU A1, ZERO, ZERO
9D03693C  24060001   ADDIU A2, ZERO, 1
9D036940  0F40635D   JAL ppu_mirror
9D036944  24070001   ADDIU A3, ZERO, 1
53:                  
54:                        break;
55:                  
56:                     case 0xA:
57:                        mmc_bankrom(8, 0xA000, value);
9D036950  24040008   ADDIU A0, ZERO, 8
9D036954  3405A000   ORI A1, ZERO, -24576
9D036958  0F40B479   JAL mmc_bankrom
9D03695C  02003021   ADDU A2, S0, ZERO
58:                        break;
9D036960  0B40DA77   J 0x9D0369DC
9D036964  8FBF0014   LW RA, 20(SP)
59:                  
60:                     case 0xC:
61:                        mmc_bankrom(8, 0xC000, value);
9D036968  24040008   ADDIU A0, ZERO, 8
9D03696C  3405C000   ORI A1, ZERO, -16384
9D036970  0F40B479   JAL mmc_bankrom
9D036974  02003021   ADDU A2, S0, ZERO
62:                        break;
9D036978  0B40DA77   J 0x9D0369DC
9D03697C  8FBF0014   LW RA, 20(SP)
63:                  
64:                     case 0xE:
65:                        latch[0] = (value & 0x0F);
9D036980  30B0000F   ANDI S0, A1, 15
9D036984  A3908060   SB S0, -32672(GP)
66:                        mmc_bankvrom(4, 0x0000, ((hibits & 0x02) << 3) | latch[0]);
9D036988  9386805C   LBU A2, -32676(GP)
9D03698C  30C60002   ANDI A2, A2, 2
9D036990  30C600FF   ANDI A2, A2, 255
9D036994  000630C0   SLL A2, A2, 3
9D036998  24040004   ADDIU A0, ZERO, 4
9D03699C  00002821   ADDU A1, ZERO, ZERO
9D0369A0  0F40B41B   JAL mmc_bankvrom
9D0369A4  02063025   OR A2, S0, A2
67:                        break;
9D0369A8  0B40DA77   J 0x9D0369DC
9D0369AC  8FBF0014   LW RA, 20(SP)
68:                  
69:                     case 0xF:
70:                        latch[1] = (value & 0x0F);
9D0369B0  30B0000F   ANDI S0, A1, 15
9D0369B4  A3908061   SB S0, -32671(GP)
71:                        mmc_bankvrom(4, 0x1000, ((hibits & 0x04) << 2) | latch[1]);
9D0369B8  9386805C   LBU A2, -32676(GP)
9D0369BC  30C60004   ANDI A2, A2, 4
9D0369C0  30C600FF   ANDI A2, A2, 255
9D0369C4  00063080   SLL A2, A2, 2
9D0369C8  24040004   ADDIU A0, ZERO, 4
9D0369CC  24051000   ADDIU A1, ZERO, 4096
9D0369D0  0F40B41B   JAL mmc_bankvrom
9D0369D4  02063025   OR A2, S0, A2
72:                        break;
73:                  
74:                     default:
75:                        break;
76:                     }
77:                  }
9D036948  0B40DA77   J 0x9D0369DC
9D03694C  8FBF0014   LW RA, 20(SP)
9D0369D8  8FBF0014   LW RA, 20(SP)
9D0369DC  8FB00010   LW S0, 16(SP)
9D0369E0  27BD0018   ADDIU SP, SP, 24
9D0369E4  03E00008   JR RA
9D0369E8  00000000   NOP
78:                  
79:                  static map_memwrite map75_memwrite[] =
80:                  {
81:                     { 0x8000, 0xFFFF, map75_write },
82:                     {     -1,     -1, NULL }
83:                  };
84:                  
85:                  mapintf_t map75_intf =
86:                  {
87:                     75, /* mapper number */
88:                     "Konami VRC1", /* mapper name */
89:                     NULL, /* init routine */
90:                     NULL, /* vblank callback */
91:                     NULL, /* hblank callback */
92:                     NULL, /* get state (snss) */
93:                     NULL, /* set state (snss) */
94:                     NULL, /* memory read structure */
95:                     map75_memwrite, /* memory write structure */
96:                     NULL /* external sound device */
97:                  };
98:                  
99:                  /*
100:                 ** $Log: map075.c,v $
101:                 ** Revision 1.2  2001/04/27 14:37:11  neil
102:                 ** wheeee
103:                 **
104:                 ** Revision 1.1  2001/04/27 12:54:40  neil
105:                 ** blah
106:                 **
107:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
108:                 ** initial
109:                 **
110:                 ** Revision 1.1  2000/10/24 12:19:33  matt
111:                 ** changed directory structure
112:                 **
113:                 ** Revision 1.6  2000/10/22 19:17:46  matt
114:                 ** mapper cleanups galore
115:                 **
116:                 ** Revision 1.5  2000/10/22 15:03:14  matt
117:                 ** simplified mirroring
118:                 **
119:                 ** Revision 1.4  2000/10/21 19:33:38  matt
120:                 ** many more cleanups
121:                 **
122:                 ** Revision 1.3  2000/07/10 05:29:03  matt
123:                 ** cleaned up some mirroring issues
124:                 **
125:                 ** Revision 1.2  2000/07/06 02:48:43  matt
126:                 ** clearly labelled structure members
127:                 **
128:                 ** Revision 1.1  2000/07/06 01:01:56  matt
129:                 ** initial revision
130:                 **
131:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map073.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map073.c
21:                  **
22:                  ** Mapper #73 (Konami VRC3)
23:                  ** Implementation by Firebug
24:                  ** $Id: map073.c,v 1.2 2001/04/27 14:37:11 neil Exp $
25:                  **
26:                  */
27:                  
28:                  #include <noftypes.h>
29:                  #include <nes_mmc.h>
30:                  #include <nes.h>
31:                  #include <libsnss.h>
32:                  #include <log.h>
33:                  
34:                  static struct
35:                  {
36:                    bool enabled;
37:                    uint32 counter;
38:                  } irq;
39:                  
40:                  /**************************/
41:                  /* Mapper #73: Salamander */
42:                  /**************************/
43:                  static void map73_init (void)
44:                  {
45:                    /* Turn off IRQs */
46:                    irq.enabled = false;
9D037428  AF80808C   SW ZERO, -32628(GP)
47:                    irq.counter = 0x0000;
9D03742C  03E00008   JR RA
9D037430  AF808090   SW ZERO, -32624(GP)
48:                  
49:                    /* Done */
50:                    return;
51:                  }
52:                  
53:                  /****************************************/
54:                  /* Mapper #73 callback for IRQ handling */
55:                  /****************************************/
56:                  static void map73_hblank (int vblank)
57:                  {
9D037540  27BDFFE8   ADDIU SP, SP, -24
9D037544  AFBF0014   SW RA, 20(SP)
58:                     /* Counter is M2 based so it doesn't matter whether */
59:                     /* the PPU is in its VBlank period or not           */
60:                     UNUSED (vblank);
61:                  
62:                     /* Increment the counter if it is enabled and check for strike */
63:                     if (irq.enabled)
9D037548  8F82808C   LW V0, -32628(GP)
9D03754C  1040000A   BEQ V0, ZERO, 0x9D037578
9D037550  8F828090   LW V0, -32624(GP)
64:                     {
65:                       /* Is there a constant for cycles per scanline? */
66:                       /* If so, someone ought to substitute it here   */
67:                       irq.counter = irq.counter + 114;
9D037554  24420072   ADDIU V0, V0, 114
9D037564  0B40DD5E   J 0x9D037578
9D037568  AF828090   SW V0, -32624(GP)
68:                  
69:                       /* Counter triggered on overflow into Q16 */
70:                       if (irq.counter & 0x10000)
9D037558  7C430400   EXT V1, V0, 16, 1
9D03755C  54600003   BNEL V1, ZERO, 0x9D03756C
9D037560  3042FFFF   ANDI V0, V0, -1
71:                       {
72:                         /* Clip to sixteen-bit word */
73:                         irq.counter &= 0xFFFF;
74:                  
75:                         /* Trigger the IRQ */
76:                         nes_irq ();
9D03756C  0F408C7B   JAL nes_irq
9D037570  AF828090   SW V0, -32624(GP)
77:                  
78:                         /* Shut off IRQ counter */
79:                         irq.enabled = false;
9D037574  AF80808C   SW ZERO, -32628(GP)
80:                       }
81:                     }
82:                  }
9D037578  8FBF0014   LW RA, 20(SP)
9D03757C  03E00008   JR RA
9D037580  27BD0018   ADDIU SP, SP, 24
83:                  
84:                  /******************************************/
85:                  /* Mapper #73 write handler ($8000-$FFFF) */
86:                  /******************************************/
87:                  static void map73_write (uint32 address, uint8 value)
88:                  {
9D037444  27BDFFE8   ADDIU SP, SP, -24
9D037448  AFBF0014   SW RA, 20(SP)
89:                    switch (address & 0xF000)
9D03744C  3084F000   ANDI A0, A0, -4096
9D037450  3402A000   ORI V0, ZERO, -24576
9D037454  10820020   BEQ A0, V0, 0x9D0374D8
9D037458  00A03021   ADDU A2, A1, ZERO
9D03745C  3402A001   ORI V0, ZERO, -24575
9D037460  0082102B   SLTU V0, A0, V0
9D037464  10400008   BEQ V0, ZERO, 0x9D037488
9D037468  3402C000   ORI V0, ZERO, -16384
9D03746C  34028000   ORI V0, ZERO, -32768
9D037470  1082000D   BEQ A0, V0, 0x9D0374A8
9D037474  34029000   ORI V0, ZERO, -28672
9D037478  10820011   BEQ A0, V0, 0x9D0374C0
9D03747C  27828090   ADDIU V0, GP, -32624
9D037488  10820020   BEQ A0, V0, 0x9D03750C
9D03748C  3402F000   ORI V0, ZERO, -4096
9D037490  10820025   BEQ A0, V0, 0x9D037528
9D037494  3402B000   ORI V0, ZERO, -20480
9D037498  14820027   BNE A0, V0, 0x9D037538
9D03749C  8FBF0014   LW RA, 20(SP)
90:                    {
91:                      case 0x8000: irq.counter &= 0xFFF0;
9D0374AC  8C430000   LW V1, 0(V0)
9D0374B0  3063FFF0   ANDI V1, V1, -16
92:                                   irq.counter |= (uint32) (value);
9D0374A8  27828090   ADDIU V0, GP, -32624
9D0374B4  00A33025   OR A2, A1, V1
93:                                   break;
9D0374B8  0B40DD4D   J .LVL5
9D0374BC  AC460000   SW A2, 0(V0)
94:                      case 0x9000: irq.counter &= 0xFF0F;
9D0374C4  8C430000   LW V1, 0(V0)
9D0374C8  3063FF0F   ANDI V1, V1, -241
95:                                   irq.counter |= (uint32) (value << 4);
9D0374C0  00053100   SLL A2, A1, 4
9D0374CC  00C33025   OR A2, A2, V1
96:                                   break;
9D0374D0  0B40DD4D   J .LVL5
9D0374D4  AC460000   SW A2, 0(V0)
97:                      case 0xA000: irq.counter &= 0xF0FF;
9D0374E0  8C430000   LW V1, 0(V0)
9D0374E4  3063F0FF   ANDI V1, V1, -3841
98:                                   irq.counter |= (uint32) (value << 8);
9D0374D8  27828090   ADDIU V0, GP, -32624
9D0374DC  00053200   SLL A2, A1, 8
9D0374E8  00C33025   OR A2, A2, V1
99:                                   break;
9D0374EC  0B40DD4D   J .LVL5
9D0374F0  AC460000   SW A2, 0(V0)
100:                     case 0xB000: irq.counter &= 0x0FFF;
9D0374F8  8C430000   LW V1, 0(V0)
9D0374FC  30630FFF   ANDI V1, V1, 4095
101:                                  irq.counter |= (uint32) (value << 12);
9D0374A0  0B40DD3D   J 0x9D0374F4
9D0374A4  27828090   ADDIU V0, GP, -32624
9D0374F4  00053300   SLL A2, A1, 12
9D037500  00C33025   OR A2, A2, V1
102:                                  break;
9D037504  0B40DD4D   J .LVL5
9D037508  AC460000   SW A2, 0(V0)
103:                     case 0xC000: if (value & 0x02) irq.enabled = true;
9D03750C  30A60002   ANDI A2, A1, 2
9D037510  30C600FF   ANDI A2, A2, 255
9D037514  50C00007   BEQL A2, ZERO, .LVL5
9D037518  AF80808C   SW ZERO, -32628(GP)
9D03751C  24020001   ADDIU V0, ZERO, 1
9D037520  0B40DD4D   J .LVL5
9D037524  AF82808C   SW V0, -32628(GP)
104:                                  else              irq.enabled = false;
105:                                  break;
106:                     case 0xF000: mmc_bankrom (16, 0x8000, value);
9D037528  24040010   ADDIU A0, ZERO, 16
9D03752C  0F40B479   JAL mmc_bankrom
9D037530  34058000   ORI A1, ZERO, -32768
107:                     default:     break;
108:                   }
109:                 
110:                   /* Done */
111:                   return;
112:                 }
9D037480  0B40DD4E   J 0x9D037538
9D037484  8FBF0014   LW RA, 20(SP)
9D037534  8FBF0014   LW RA, 20(SP)
9D037538  03E00008   JR RA
9D03753C  27BD0018   ADDIU SP, SP, 24
113:                 
114:                 /****************************************************/
115:                 /* Shove extra mapper information into a SNSS block */
116:                 /****************************************************/
117:                 static void map73_setstate (SnssMapperBlock *state)
118:                 {
9D037434  03E00008   JR RA
9D037438  00000000   NOP
119:                   /* TODO: Store SNSS information */
120:                   UNUSED (state);
121:                 
122:                   /* Done */
123:                   return;
124:                 }
125:                 
126:                 /*****************************************************/
127:                 /* Pull extra mapper information out of a SNSS block */
128:                 /*****************************************************/
129:                 static void map73_getstate (SnssMapperBlock *state)
130:                 {
9D03743C  03E00008   JR RA
9D037440  00000000   NOP
131:                   /* TODO: Retrieve SNSS information */
132:                   UNUSED (state);
133:                 
134:                   /* Done */
135:                   return;
136:                 }
137:                 
138:                 static map_memwrite map73_memwrite [] =
139:                 {
140:                    { 0x8000, 0xFFFF, map73_write },
141:                    {     -1,     -1, NULL }
142:                 };
143:                 
144:                 mapintf_t map73_intf =
145:                 {
146:                    73,                               /* Mapper number */
147:                    "Konami VRC3",                    /* Mapper name */
148:                    map73_init,                       /* Initialization routine */
149:                    NULL,                             /* VBlank callback */
150:                    map73_hblank,                     /* HBlank callback */
151:                    map73_getstate,                   /* Get state (SNSS) */
152:                    map73_setstate,                   /* Set state (SNSS) */
153:                    NULL,                             /* Memory read structure */
154:                    map73_memwrite,                   /* Memory write structure */
155:                    NULL                              /* External sound device */
156:                 };
157:                 
158:                 /*
159:                 ** $Log: map073.c,v $
160:                 ** Revision 1.2  2001/04/27 14:37:11  neil
161:                 ** wheeee
162:                 **
163:                 ** Revision 1.1  2001/04/27 12:54:40  neil
164:                 ** blah
165:                 **
166:                 ** Revision 1.1  2001/04/27 10:57:41  neil
167:                 ** wheee
168:                 **
169:                 ** Revision 1.1  2000/12/30 06:35:05  firebug
170:                 ** Initial revision
171:                 **
172:                 **
173:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map070.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map70.c
21:                  **
22:                  ** mapper 70 interface
23:                  ** $Id: map070.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes_ppu.h>
29:                  
30:                  /* mapper 70: Arkanoid II, Kamen Rider Club, etc. */
31:                  /* ($8000-$FFFF) D6-D4 = switch $8000-$BFFF */
32:                  /* ($8000-$FFFF) D3-D0 = switch PPU $0000-$1FFF */
33:                  /* ($8000-$FFFF) D7 = switch mirroring */
34:                  static void map70_write(uint32 address, uint8 value)
35:                  {
9D03A748  27BDFFE8   ADDIU SP, SP, -24
9D03A74C  AFBF0014   SW RA, 20(SP)
9D03A750  AFB00010   SW S0, 16(SP)
9D03A754  00A08021   ADDU S0, A1, ZERO
36:                     UNUSED(address);
37:                  
38:                     mmc_bankrom(16, 0x8000, (value >> 4) & 0x07);
9D03A758  24040010   ADDIU A0, ZERO, 16
9D03A75C  34058000   ORI A1, ZERO, -32768
9D03A760  0F40B479   JAL mmc_bankrom
9D03A764  7E061100   EXT A2, S0, 4, 3
39:                     mmc_bankvrom(8, 0x0000, value & 0x0F);
9D03A768  24040008   ADDIU A0, ZERO, 8
9D03A76C  00002821   ADDU A1, ZERO, ZERO
9D03A770  0F40B41B   JAL mmc_bankvrom
9D03A774  3206000F   ANDI A2, S0, 15
40:                  
41:                     /* Argh! FanWen used the 4-screen bit to determine
42:                     ** whether the game uses D7 to switch between
43:                     ** horizontal and vertical mirroring, or between
44:                     ** one-screen mirroring from $2000 or $2400.
45:                     */
46:                     if (mmc_getinfo()->flags & ROM_FLAG_FOURSCREEN)
9D03A778  0F40B40F   JAL mmc_getinfo
9D03A77C  00000000   NOP
9D03A780  90420028   LBU V0, 40(V0)
9D03A784  30420004   ANDI V0, V0, 4
9D03A788  304200FF   ANDI V0, V0, 255
9D03A78C  10400010   BEQ V0, ZERO, .LBB2
9D03A790  001039C2   SRL A3, S0, 7
47:                     {
48:                        if (value & 0x80)
9D03A794  7C108420   SEB S0, S0
9D03A798  06010007   BGEZ S0, 0x9D03A7B8
9D03A79C  00002021   ADDU A0, ZERO, ZERO
49:                           ppu_mirror(0, 0, 1, 1); /* horiz */
9D03A7A0  00002821   ADDU A1, ZERO, ZERO
9D03A7A4  24060001   ADDIU A2, ZERO, 1
9D03A7A8  0F40635D   JAL ppu_mirror
9D03A7AC  24070001   ADDIU A3, ZERO, 1
9D03A7B0  0B40E9F9   J 0x9D03A7E4
9D03A7B4  8FBF0014   LW RA, 20(SP)
50:                        else
51:                           ppu_mirror(0, 1, 0, 1); /* vert */
9D03A7B8  24050001   ADDIU A1, ZERO, 1
9D03A7BC  00003021   ADDU A2, ZERO, ZERO
9D03A7C0  0F40635D   JAL ppu_mirror
9D03A7C4  24070001   ADDIU A3, ZERO, 1
52:                     }
53:                     else
54:                     {
55:                        int mirror = (value & 0x80) >> 7;
56:                        ppu_mirror(mirror, mirror, mirror, mirror);
9D03A7D0  00E02021   ADDU A0, A3, ZERO
9D03A7D4  00E02821   ADDU A1, A3, ZERO
9D03A7D8  0F40635D   JAL ppu_mirror
9D03A7DC  00E03021   ADDU A2, A3, ZERO
57:                     }
58:                  }
9D03A7C8  0B40E9F9   J 0x9D03A7E4
9D03A7CC  8FBF0014   LW RA, 20(SP)
9D03A7E0  8FBF0014   LW RA, 20(SP)
9D03A7E4  8FB00010   LW S0, 16(SP)
9D03A7E8  03E00008   JR RA
9D03A7EC  27BD0018   ADDIU SP, SP, 24
59:                  
60:                  static map_memwrite map70_memwrite[] =
61:                  {
62:                     { 0x8000, 0xFFFF, map70_write },
63:                     {     -1,     -1, NULL }
64:                  };
65:                  
66:                  mapintf_t map70_intf =
67:                  {
68:                     70, /* mapper number */
69:                     "Mapper 70", /* mapper name */
70:                     NULL, /* init routine */
71:                     NULL, /* vblank callback */
72:                     NULL, /* hblank callback */
73:                     NULL, /* get state (snss) */
74:                     NULL, /* set state (snss) */
75:                     NULL, /* memory read structure */
76:                     map70_memwrite, /* memory write structure */
77:                     NULL /* external sound device */
78:                  };
79:                  
80:                  /*
81:                  ** $Log: map070.c,v $
82:                  ** Revision 1.2  2001/04/27 14:37:11  neil
83:                  ** wheeee
84:                  **
85:                  ** Revision 1.1  2001/04/27 12:54:40  neil
86:                  ** blah
87:                  **
88:                  ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
89:                  ** initial
90:                  **
91:                  ** Revision 1.1  2000/10/24 12:19:33  matt
92:                  ** changed directory structure
93:                  **
94:                  ** Revision 1.7  2000/10/22 19:17:46  matt
95:                  ** mapper cleanups galore
96:                  **
97:                  ** Revision 1.6  2000/10/22 15:03:13  matt
98:                  ** simplified mirroring
99:                  **
100:                 ** Revision 1.5  2000/10/21 19:33:38  matt
101:                 ** many more cleanups
102:                 **
103:                 ** Revision 1.4  2000/08/16 02:50:11  matt
104:                 ** random mapper cleanups
105:                 **
106:                 ** Revision 1.3  2000/07/10 05:29:03  matt
107:                 ** cleaned up some mirroring issues
108:                 **
109:                 ** Revision 1.2  2000/07/06 02:48:43  matt
110:                 ** clearly labelled structure members
111:                 **
112:                 ** Revision 1.1  2000/07/06 01:01:56  matt
113:                 ** initial revision
114:                 **
115:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map066.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map66.c
21:                  **
22:                  ** mapper 66 interface
23:                  ** $Id: map066.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  
29:                  /* mapper 66: GNROM */
30:                  static void map66_write(uint32 address, uint8 value)
31:                  {
9D03B554  27BDFFE8   ADDIU SP, SP, -24
9D03B558  AFBF0014   SW RA, 20(SP)
9D03B55C  AFB00010   SW S0, 16(SP)
9D03B560  00A08021   ADDU S0, A1, ZERO
32:                     UNUSED(address);
33:                  
34:                     mmc_bankrom(32, 0x8000, (value >> 4) & 3);
9D03B564  24040020   ADDIU A0, ZERO, 32
9D03B568  34058000   ORI A1, ZERO, -32768
9D03B56C  0F40B479   JAL mmc_bankrom
9D03B570  7E060900   EXT A2, S0, 4, 2
35:                     mmc_bankvrom(8, 0x0000, value & 3);
9D03B574  24040008   ADDIU A0, ZERO, 8
9D03B578  00002821   ADDU A1, ZERO, ZERO
9D03B57C  0F40B41B   JAL mmc_bankvrom
9D03B580  32060003   ANDI A2, S0, 3
36:                  }
9D03B584  8FBF0014   LW RA, 20(SP)
9D03B588  8FB00010   LW S0, 16(SP)
9D03B58C  03E00008   JR RA
9D03B590  27BD0018   ADDIU SP, SP, 24
37:                  
38:                  static void map66_init(void)
39:                  {
9D03B594  27BDFFE8   ADDIU SP, SP, -24
9D03B598  AFBF0014   SW RA, 20(SP)
40:                     mmc_bankrom(32, 0x8000, 0);
9D03B59C  24040020   ADDIU A0, ZERO, 32
9D03B5A0  34058000   ORI A1, ZERO, -32768
9D03B5A4  0F40B479   JAL mmc_bankrom
9D03B5A8  00003021   ADDU A2, ZERO, ZERO
41:                     mmc_bankvrom(8, 0x0000, 0);
9D03B5AC  24040008   ADDIU A0, ZERO, 8
9D03B5B0  00002821   ADDU A1, ZERO, ZERO
9D03B5B4  0F40B41B   JAL mmc_bankvrom
9D03B5B8  00003021   ADDU A2, ZERO, ZERO
42:                  }
9D03B5BC  8FBF0014   LW RA, 20(SP)
9D03B5C0  03E00008   JR RA
9D03B5C4  27BD0018   ADDIU SP, SP, 24
43:                  
44:                  
45:                  static map_memwrite map66_memwrite[] =
46:                  {
47:                     { 0x8000, 0xFFFF, map66_write },
48:                     {     -1,     -1, NULL }
49:                  };
50:                  
51:                  mapintf_t map66_intf =
52:                  {
53:                     66, /* mapper number */
54:                     "GNROM", /* mapper name */
55:                     map66_init, /* init routine */
56:                     NULL, /* vblank callback */
57:                     NULL, /* hblank callback */
58:                     NULL, /* get state (snss) */
59:                     NULL, /* set state (snss) */
60:                     NULL, /* memory read structure */
61:                     map66_memwrite, /* memory write structure */
62:                     NULL /* external sound device */
63:                  };
64:                  
65:                  /*
66:                  ** $Log: map066.c,v $
67:                  ** Revision 1.2  2001/04/27 14:37:11  neil
68:                  ** wheeee
69:                  **
70:                  ** Revision 1.1  2001/04/27 12:54:40  neil
71:                  ** blah
72:                  **
73:                  ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
74:                  ** initial
75:                  **
76:                  ** Revision 1.1  2000/10/24 12:19:33  matt
77:                  ** changed directory structure
78:                  **
79:                  ** Revision 1.5  2000/10/22 19:17:46  matt
80:                  ** mapper cleanups galore
81:                  **
82:                  ** Revision 1.4  2000/10/21 19:33:38  matt
83:                  ** many more cleanups
84:                  **
85:                  ** Revision 1.3  2000/08/16 02:50:11  matt
86:                  ** random mapper cleanups
87:                  **
88:                  ** Revision 1.2  2000/07/06 02:48:43  matt
89:                  ** clearly labelled structure members
90:                  **
91:                  ** Revision 1.1  2000/07/05 05:05:18  matt
92:                  ** initial revision
93:                  **
94:                  */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map065.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map65.c
21:                  **
22:                  ** mapper 65 interface
23:                  ** $Id: map065.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes_ppu.h>
29:                  
30:                  static struct
31:                  {
32:                     int counter;
33:                     bool enabled;
34:                     int cycles;
35:                     uint8 low, high;
36:                  } irq;
37:                  
38:                  static void map65_init(void)
39:                  {
40:                     irq.counter = 0;
9D037E44  3C02A001   LUI V0, -24575
9D037E48  AC40B88C   SW ZERO, -18292(V0)
41:                     irq.enabled = false;
9D037E4C  2442B88C   ADDIU V0, V0, -18292
9D037E50  AC400004   SW ZERO, 4(V0)
42:                     irq.low = irq.high = 0;
9D037E54  A040000D   SB ZERO, 13(V0)
9D037E58  A040000C   SB ZERO, 12(V0)
43:                     irq.cycles = 0;
9D037E5C  03E00008   JR RA
9D037E60  AC400008   SW ZERO, 8(V0)
44:                  }
45:                  
46:                  /* TODO: shouldn't there be some kind of HBlank callback??? */
47:                  
48:                  /* mapper 65: Irem H-3001*/
49:                  static void map65_write(uint32 address, uint8 value)
50:                  {
9D037E64  27BDFFE8   ADDIU SP, SP, -24
9D037E68  AFBF0014   SW RA, 20(SP)
9D037E6C  00A03021   ADDU A2, A1, ZERO
51:                     int range = address & 0xF000;
9D037E70  3082F000   ANDI V0, A0, -4096
52:                     int reg = address & 7;
53:                  
54:                     switch (range)
9D037E74  3403A000   ORI V1, ZERO, -24576
9D037E78  10430011   BEQ V0, V1, 0x9D037EC0
9D037E7C  30850007   ANDI A1, A0, 7
9D037E80  3403A001   ORI V1, ZERO, -24575
9D037E84  0043182A   SLT V1, V0, V1
9D037E88  10600008   BEQ V1, ZERO, 0x9D037EAC
9D037E8C  3403B000   ORI V1, ZERO, -20480
9D037E90  34038000   ORI V1, ZERO, -32768
9D037E94  1043000A   BEQ V0, V1, 0x9D037EC0
9D037E98  34039000   ORI V1, ZERO, -28672
9D037E9C  10430011   BEQ V0, V1, 0x9D037EE4
9D037EA0  24020005   ADDIU V0, ZERO, 5
9D037EAC  10430009   BEQ V0, V1, 0x9D037ED4
9D037EB0  24040001   ADDIU A0, ZERO, 1
9D037EB4  3403C000   ORI V1, ZERO, -16384
9D037EB8  54430029   BNEL V0, V1, 0x9D037F60
9D037EBC  8FBF0014   LW RA, 20(SP)
55:                     {
56:                     case 0x8000:
57:                     case 0xA000:
58:                     case 0xC000:
59:                        mmc_bankrom(8, range, value);
9D037EC0  24040008   ADDIU A0, ZERO, 8
9D037EC4  0F40B479   JAL mmc_bankrom
9D037EC8  00402821   ADDU A1, V0, ZERO
60:                        break;
9D037ECC  0B40DFD8   J 0x9D037F60
9D037ED0  8FBF0014   LW RA, 20(SP)
61:                  
62:                     case 0xB000:
63:                        mmc_bankvrom(1, reg << 10, value);
9D037ED4  0F40B41B   JAL mmc_bankvrom
9D037ED8  00052A80   SLL A1, A1, 10
64:                        break;
9D037EDC  0B40DFD8   J 0x9D037F60
9D037EE0  8FBF0014   LW RA, 20(SP)
65:                  
66:                     case 0x9000:
67:                        switch (reg)
9D037EE4  10A2000A   BEQ A1, V0, 0x9D037F10
9D037EE8  24020006   ADDIU V0, ZERO, 6
9D037EEC  10A20012   BEQ A1, V0, 0x9D037F38
9D037EF0  24020004   ADDIU V0, ZERO, 4
9D037EF4  14A2001A   BNE A1, V0, 0x9D037F60
9D037EF8  8FBF0014   LW RA, 20(SP)
68:                        {
69:                        case 4:
70:                           irq.enabled = (value & 0x01) ? false : true;
9D037EFC  38C60001   XORI A2, A2, 1
9D037F00  30C60001   ANDI A2, A2, 1
9D037F04  3C02A001   LUI V0, -24575
71:                           break;
9D037F08  0B40DFD7   J 0x9D037F5C
9D037F0C  AC46B890   SW A2, -18288(V0)
72:                  
73:                        case 5:
74:                           irq.high = value;
9D037F10  3C03A001   LUI V1, -24575
9D037F14  2462B88C   ADDIU V0, V1, -18292
9D037F18  A046000D   SB A2, 13(V0)
75:                           irq.cycles = (irq.high << 8) | irq.low;
9D037F1C  00063200   SLL A2, A2, 8
9D037F20  9044000C   LBU A0, 12(V0)
9D037F24  00C43025   OR A2, A2, A0
9D037F28  AC460008   SW A2, 8(V0)
76:                           irq.counter = (uint8)(irq.cycles / 128);
9D037F2C  7CC639C0   EXT A2, A2, 7, 8
77:                           break;
9D037F30  0B40DFD7   J 0x9D037F5C
9D037F34  AC66B88C   SW A2, -18292(V1)
78:                  
79:                        case 6:
80:                           irq.low = value;
9D037F38  3C03A001   LUI V1, -24575
9D037F3C  2462B88C   ADDIU V0, V1, -18292
9D037F40  A046000C   SB A2, 12(V0)
81:                           irq.cycles = (irq.high << 8) | irq.low;
9D037F44  9044000D   LBU A0, 13(V0)
9D037F48  00042200   SLL A0, A0, 8
9D037F4C  00C43025   OR A2, A2, A0
9D037F50  AC460008   SW A2, 8(V0)
82:                           irq.counter = (uint8)(irq.cycles / 128);
9D037F54  7CC639C0   EXT A2, A2, 7, 8
9D037F58  AC66B88C   SW A2, -18292(V1)
83:                           break;
84:                  
85:                        default:
86:                           break;
87:                        }
88:                        break;
89:                  
90:                     default:
91:                        break;
92:                     }
93:                  }
9D037EA4  0B40DFD8   J 0x9D037F60
9D037EA8  8FBF0014   LW RA, 20(SP)
9D037F5C  8FBF0014   LW RA, 20(SP)
9D037F60  03E00008   JR RA
9D037F64  27BD0018   ADDIU SP, SP, 24
94:                  
95:                  static map_memwrite map65_memwrite[] =
96:                  {
97:                     { 0x8000, 0xFFFF, map65_write },
98:                     {     -1,     -1, NULL }
99:                  };
100:                 
101:                 mapintf_t map65_intf =
102:                 {
103:                    65, /* mapper number */
104:                    "Irem H-3001", /* mapper name */
105:                    map65_init, /* init routine */
106:                    NULL, /* vblank callback */
107:                    NULL, /* hblank callback */
108:                    NULL, /* get state (snss) */
109:                    NULL, /* set state (snss) */
110:                    NULL, /* memory read structure */
111:                    map65_memwrite, /* memory write structure */
112:                    NULL /* external sound device */
113:                 };
114:                 
115:                 /*
116:                 ** $Log: map065.c,v $
117:                 ** Revision 1.2  2001/04/27 14:37:11  neil
118:                 ** wheeee
119:                 **
120:                 ** Revision 1.1  2001/04/27 12:54:40  neil
121:                 ** blah
122:                 **
123:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
124:                 ** initial
125:                 **
126:                 ** Revision 1.1  2000/10/24 12:19:33  matt
127:                 ** changed directory structure
128:                 **
129:                 ** Revision 1.5  2000/10/22 19:17:46  matt
130:                 ** mapper cleanups galore
131:                 **
132:                 ** Revision 1.4  2000/10/21 19:33:38  matt
133:                 ** many more cleanups
134:                 **
135:                 ** Revision 1.3  2000/10/10 13:58:17  matt
136:                 ** stroustrup squeezing his way in the door
137:                 **
138:                 ** Revision 1.2  2000/07/06 02:48:43  matt
139:                 ** clearly labelled structure members
140:                 **
141:                 ** Revision 1.1  2000/07/06 01:01:56  matt
142:                 ** initial revision
143:                 **
144:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map064.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map64.c
21:                  **
22:                  ** mapper 64 interface
23:                  ** $Id: map064.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes.h>
29:                  #include <log.h>
30:                  
31:                  static struct
32:                  {
33:                     int counter, latch;
34:                     bool enabled, reset;
35:                  } irq;
36:                  
37:                  static uint8 command = 0;
38:                  static uint16 vrombase = 0x0000;
39:                  
40:                  static void map64_hblank(int vblank)
41:                  {
9D030C40  27BDFFE8   ADDIU SP, SP, -24
9D030C44  AFBF0014   SW RA, 20(SP)
42:                     if (vblank)
9D030C38  14800019   BNE A0, ZERO, 0x9D030CA0
9D030C3C  3C02A001   LUI V0, -24575
43:                        return;
44:                  
45:                     irq.reset = false;
46:                  
47:                     if (ppu_enabled())
9D030C48  0F4065CC   JAL ppu_enabled
9D030C4C  AC40B8D8   SW ZERO, -18216(V0)
9D030C50  10400011   BEQ V0, ZERO, 0x9D030C98
9D030C54  3C03A001   LUI V1, -24575
48:                     {
49:                        if (0 == irq.counter--)
9D030C58  8C62B8CC   LW V0, -18228(V1)
9D030C5C  2444FFFF   ADDIU A0, V0, -1
9D030C60  1440000D   BNE V0, ZERO, 0x9D030C98
9D030C64  AC64B8CC   SW A0, -18228(V1)
50:                        {
51:                           irq.counter = irq.latch;
9D030C68  2462B8CC   ADDIU V0, V1, -18228
9D030C6C  8C440004   LW A0, 4(V0)
9D030C70  AC64B8CC   SW A0, -18228(V1)
52:                         
53:                           if (true == irq.enabled)
9D030C74  8C430008   LW V1, 8(V0)
9D030C78  24020001   ADDIU V0, ZERO, 1
9D030C7C  14620004   BNE V1, V0, 0x9D030C90
9D030C80  24030001   ADDIU V1, ZERO, 1
54:                              nes_irq();
9D030C84  0F408C7B   JAL nes_irq
9D030C88  00000000   NOP
55:                  
56:                           irq.reset = true;
9D030C8C  24030001   ADDIU V1, ZERO, 1
9D030C90  3C02A001   LUI V0, -24575
9D030C94  AC43B8D8   SW V1, -18216(V0)
57:                        }
58:                     }
59:                  }
9D030C98  8FBF0014   LW RA, 20(SP)
9D030C9C  27BD0018   ADDIU SP, SP, 24
9D030CA0  03E00008   JR RA
9D030CA4  00000000   NOP
60:                  
61:                  /* mapper 64: Tengen RAMBO-1 */
62:                  static void map64_write(uint32 address, uint8 value)
63:                  {
9D030930  27BDFFE8   ADDIU SP, SP, -24
9D030934  AFBF0014   SW RA, 20(SP)
9D030938  AFB00010   SW S0, 16(SP)
64:                     switch (address & 0xE001)
9D03093C  3084E001   ANDI A0, A0, -8191
9D030940  3402C000   ORI V0, ZERO, -16384
9D030944  108200A3   BEQ A0, V0, 0x9D030BD4
9D030948  00A08021   ADDU S0, A1, ZERO
9D03094C  3402C001   ORI V0, ZERO, -16383
9D030950  0082102B   SLTU V0, A0, V0
9D030954  1040000A   BEQ V0, ZERO, 0x9D030980
9D030958  3402E000   ORI V0, ZERO, -8192
9D03095C  34028001   ORI V0, ZERO, -32767
9D030960  10820014   BEQ A0, V0, 0x9D0309B4
9D030964  3402A000   ORI V0, ZERO, -24576
9D030968  1082008B   BEQ A0, V0, 0x9D030B98
9D03096C  34028000   ORI V0, ZERO, -32768
9D030970  148200A5   BNE A0, V0, 0x9D030C08
9D030974  3C02A001   LUI V0, -24575
9D030980  1082009A   BEQ A0, V0, 0x9D030BEC
9D030984  3402E001   ORI V0, ZERO, -8191
9D030988  1082009B   BEQ A0, V0, 0x9D030BF8
9D03098C  3402C001   ORI V0, ZERO, -16383
9D030990  1482009D   BNE A0, V0, 0x9D030C08
9D030994  3C02A001   LUI V0, -24575
65:                     {
66:                     case 0x8000:
67:                        command = value;
9D030978  0B40C268   J 0x9D0309A0
9D03097C  A38580D6   SB A1, -32554(GP)
68:                        vrombase = (value & 0x80) ? 0x1000 : 0x0000;
9D0309A0  000581C2   SRL S0, A1, 7
9D0309A4  24021000   ADDIU V0, ZERO, 4096
9D0309A8  0010100A   MOVZ V0, ZERO, S0
69:                        break;
9D0309AC  0B40C301   J 0x9D030C04
9D0309B0  A78280D4   SH V0, -32556(GP)
70:                  
71:                     case 0x8001:
72:                        switch (command & 0xF)
9D0309B4  938280D6   LBU V0, -32554(GP)
9D0309B8  3044000F   ANDI A0, V0, 15
9D0309BC  00042080   SLL A0, A0, 2
9D0309C0  3C039D03   LUI V1, -25341
9D0309C4  246309D8   ADDIU V1, V1, 2520
9D0309C8  00641821   ADDU V1, V1, A0
9D0309CC  8C630000   LW V1, 0(V1)
9D0309D0  00600008   JR V1
9D0309D4  00000000   NOP
73:                        {
74:                        case 0:
75:                           mmc_bankvrom(1, 0x0000 ^ vrombase, value);
9D030A18  24040001   ADDIU A0, ZERO, 1
9D030A1C  978580D4   LHU A1, -32556(GP)
9D030A20  0F40B41B   JAL mmc_bankvrom
9D030A24  02003021   ADDU A2, S0, ZERO
76:                           mmc_bankvrom(1, 0x0400 ^ vrombase, value);
9D030A28  978580D4   LHU A1, -32556(GP)
9D030A2C  24040001   ADDIU A0, ZERO, 1
9D030A30  38A50400   XORI A1, A1, 1024
9D030A34  0F40B41B   JAL mmc_bankvrom
9D030A38  02003021   ADDU A2, S0, ZERO
77:                           break;
9D030A3C  0B40C302   J 0x9D030C08
9D030A40  3C02A001   LUI V0, -24575
78:                  
79:                        case 1:
80:                           mmc_bankvrom(1, 0x0800 ^ vrombase, value);
9D030A44  978580D4   LHU A1, -32556(GP)
9D030A48  24040001   ADDIU A0, ZERO, 1
9D030A4C  38A50800   XORI A1, A1, 2048
9D030A50  0F40B41B   JAL mmc_bankvrom
9D030A54  02003021   ADDU A2, S0, ZERO
81:                           mmc_bankvrom(1, 0x0C00 ^ vrombase, value);
9D030A58  978580D4   LHU A1, -32556(GP)
9D030A5C  24040001   ADDIU A0, ZERO, 1
9D030A60  38A50C00   XORI A1, A1, 3072
9D030A64  0F40B41B   JAL mmc_bankvrom
9D030A68  02003021   ADDU A2, S0, ZERO
82:                           break;
9D030A6C  0B40C302   J 0x9D030C08
9D030A70  3C02A001   LUI V0, -24575
83:                  
84:                        case 2:
85:                           mmc_bankvrom(1, 0x1000 ^ vrombase, value);
9D030A74  978580D4   LHU A1, -32556(GP)
9D030A78  24040001   ADDIU A0, ZERO, 1
9D030A7C  38A51000   XORI A1, A1, 4096
9D030A80  0F40B41B   JAL mmc_bankvrom
9D030A84  02003021   ADDU A2, S0, ZERO
86:                           break;
9D030A88  0B40C302   J 0x9D030C08
9D030A8C  3C02A001   LUI V0, -24575
87:                  
88:                        case 3:
89:                           mmc_bankvrom(1, 0x1400 ^ vrombase, value);
9D030A90  978580D4   LHU A1, -32556(GP)
9D030A94  24040001   ADDIU A0, ZERO, 1
9D030A98  38A51400   XORI A1, A1, 5120
9D030A9C  0F40B41B   JAL mmc_bankvrom
9D030AA0  02003021   ADDU A2, S0, ZERO
90:                           break;
9D030AA4  0B40C302   J 0x9D030C08
9D030AA8  3C02A001   LUI V0, -24575
91:                  
92:                        case 4:
93:                           mmc_bankvrom(1, 0x1800 ^ vrombase, value);
9D030AAC  978580D4   LHU A1, -32556(GP)
9D030AB0  24040001   ADDIU A0, ZERO, 1
9D030AB4  38A51800   XORI A1, A1, 6144
9D030AB8  0F40B41B   JAL mmc_bankvrom
9D030ABC  02003021   ADDU A2, S0, ZERO
94:                           break;
9D030AC0  0B40C302   J 0x9D030C08
9D030AC4  3C02A001   LUI V0, -24575
95:                  
96:                        case 5:
97:                           mmc_bankvrom(1, 0x1C00 ^ vrombase, value);
9D030AC8  978580D4   LHU A1, -32556(GP)
9D030ACC  24040001   ADDIU A0, ZERO, 1
9D030AD0  38A51C00   XORI A1, A1, 7168
9D030AD4  0F40B41B   JAL mmc_bankvrom
9D030AD8  02003021   ADDU A2, S0, ZERO
98:                           break;
9D030ADC  0B40C302   J 0x9D030C08
9D030AE0  3C02A001   LUI V0, -24575
99:                  
100:                       case 6:
101:                          mmc_bankrom(8, (command & 0x40) ? 0xA000 : 0x8000, value);
9D030AE4  30420040   ANDI V0, V0, 64
9D030AE8  304500FF   ANDI A1, V0, 255
9D030AEC  24040008   ADDIU A0, ZERO, 8
9D030AF0  3402A000   ORI V0, ZERO, -24576
9D030AF4  34038000   ORI V1, ZERO, -32768
9D030AF8  0065100A   MOVZ V0, V1, A1
9D030AFC  00402821   ADDU A1, V0, ZERO
9D030B00  0F40B479   JAL mmc_bankrom
9D030B04  02003021   ADDU A2, S0, ZERO
102:                          break;
9D030B08  0B40C302   J 0x9D030C08
9D030B0C  3C02A001   LUI V0, -24575
103:                 
104:                       case 7:
105:                          mmc_bankrom(8, (command & 0x40) ? 0xC000 : 0xA000, value);
9D030B10  30420040   ANDI V0, V0, 64
9D030B14  304500FF   ANDI A1, V0, 255
9D030B18  24040008   ADDIU A0, ZERO, 8
9D030B1C  3402C000   ORI V0, ZERO, -16384
9D030B20  3403A000   ORI V1, ZERO, -24576
9D030B24  0065100A   MOVZ V0, V1, A1
9D030B28  00402821   ADDU A1, V0, ZERO
9D030B2C  0F40B479   JAL mmc_bankrom
9D030B30  02003021   ADDU A2, S0, ZERO
106:                          break;
9D030B34  0B40C302   J 0x9D030C08
9D030B38  3C02A001   LUI V0, -24575
107:                 
108:                       case 8:
109:                          mmc_bankvrom(1, 0x0400, value);
9D030B3C  24040001   ADDIU A0, ZERO, 1
9D030B40  24050400   ADDIU A1, ZERO, 1024
9D030B44  0F40B41B   JAL mmc_bankvrom
9D030B48  02003021   ADDU A2, S0, ZERO
110:                          break;
9D030B4C  0B40C302   J 0x9D030C08
9D030B50  3C02A001   LUI V0, -24575
111:                 
112:                       case 9:
113:                          mmc_bankvrom(1, 0x0C00, value);
9D030B54  24040001   ADDIU A0, ZERO, 1
9D030B58  24050C00   ADDIU A1, ZERO, 3072
9D030B5C  0F40B41B   JAL mmc_bankvrom
9D030B60  02003021   ADDU A2, S0, ZERO
114:                          break;
9D030B64  0B40C302   J 0x9D030C08
9D030B68  3C02A001   LUI V0, -24575
115:                 
116:                       case 15:
117:                          mmc_bankrom(8, (command & 0x40) ? 0x8000 : 0xC000, value);
9D030B6C  30420040   ANDI V0, V0, 64
9D030B70  304500FF   ANDI A1, V0, 255
9D030B74  24040008   ADDIU A0, ZERO, 8
9D030B78  34028000   ORI V0, ZERO, -32768
9D030B7C  3403C000   ORI V1, ZERO, -16384
9D030B80  0065100A   MOVZ V0, V1, A1
9D030B84  00402821   ADDU A1, V0, ZERO
9D030B88  0F40B479   JAL mmc_bankrom
9D030B8C  02003021   ADDU A2, S0, ZERO
118:                          break;
9D030B90  0B40C302   J 0x9D030C08
9D030B94  3C02A001   LUI V0, -24575
119:                 
120:                       default:
121:                 #ifdef NOFRENDO_DEBUG
122:                          log_printf("mapper 64: unknown command #%d", command & 0xF);
123:                 #endif
124:                          break;
125:                       }
126:                       break;
127:                    
128:                    case 0xA000:
129:                       if (value & 1)
9D030B98  30B00001   ANDI S0, A1, 1
9D030B9C  12000007   BEQ S0, ZERO, 0x9D030BBC
9D030BA0  00002021   ADDU A0, ZERO, ZERO
130:                          ppu_mirror(0, 0, 1, 1);
9D030BA4  00002821   ADDU A1, ZERO, ZERO
9D030BA8  24060001   ADDIU A2, ZERO, 1
9D030BAC  0F40635D   JAL ppu_mirror
9D030BB0  24070001   ADDIU A3, ZERO, 1
9D030BB4  0B40C302   J 0x9D030C08
9D030BB8  3C02A001   LUI V0, -24575
131:                       else
132:                          ppu_mirror(0, 1, 0, 1);
9D030BBC  24050001   ADDIU A1, ZERO, 1
9D030BC0  00003021   ADDU A2, ZERO, ZERO
9D030BC4  0F40635D   JAL ppu_mirror
9D030BC8  24070001   ADDIU A3, ZERO, 1
133:                       break;
134:                    
135:                    case 0xC000:
136:                       //irq.counter = value;
137:                       irq.latch = value;
9D030BD4  3C02A001   LUI V0, -24575
138:                       break;
9D030BD8  0B40C301   J 0x9D030C04
9D030BDC  AC45B8D0   SW A1, -18224(V0)
139:                    
140:                    case 0xC001:
141:                       //irq.latch = value;
142:                       irq.reset = true;
9D030998  0B40C2F8   J 0x9D030BE0
9D03099C  24030001   ADDIU V1, ZERO, 1
9D030BE0  3C02A001   LUI V0, -24575
9D030BE4  0B40C306   J 0x9D030C18
9D030BE8  AC43B8D8   SW V1, -18216(V0)
143:                       break;
144:                    
145:                    case 0xE000:
146:                       //irq.counter = irq.latch;
147:                       irq.enabled = false;
9D030BEC  3C02A001   LUI V0, -24575
148:                       break;
9D030BF0  0B40C301   J 0x9D030C04
9D030BF4  AC40B8D4   SW ZERO, -18220(V0)
149:                    
150:                    case 0xE001:
151:                       irq.enabled = true;
9D030BF8  24030001   ADDIU V1, ZERO, 1
9D030BFC  3C02A001   LUI V0, -24575
9D030C00  AC43B8D4   SW V1, -18220(V0)
152:                       break;
153:                    
154:                    default:
155:                 #ifdef NOFRENDO_DEBUG
156:                       log_printf("mapper 64: Wrote $%02X to $%04X", value, address);
157:                 #endif
158:                       break;
159:                    }
160:                 
161:                    if (true == irq.reset)
9D030BCC  0B40C302   J 0x9D030C08
9D030BD0  3C02A001   LUI V0, -24575
9D030C04  3C02A001   LUI V0, -24575
9D030C08  8C43B8D8   LW V1, -18216(V0)
9D030C0C  24020001   ADDIU V0, ZERO, 1
9D030C10  14620006   BNE V1, V0, 0x9D030C2C
9D030C14  8FBF0014   LW RA, 20(SP)
162:                       irq.counter = irq.latch;
9D030C18  3C02A001   LUI V0, -24575
9D030C1C  2443B8CC   ADDIU V1, V0, -18228
9D030C20  8C630004   LW V1, 4(V1)
9D030C24  AC43B8CC   SW V1, -18228(V0)
163:                 }
9D030C28  8FBF0014   LW RA, 20(SP)
9D030C2C  8FB00010   LW S0, 16(SP)
9D030C30  03E00008   JR RA
9D030C34  27BD0018   ADDIU SP, SP, 24
164:                 
165:                 static void map64_init(void)
166:                 {
9D0308C4  27BDFFE8   ADDIU SP, SP, -24
9D0308C8  AFBF0014   SW RA, 20(SP)
167:                    mmc_bankrom(8, 0x8000, MMC_LASTBANK);
9D0308CC  24040008   ADDIU A0, ZERO, 8
9D0308D0  34058000   ORI A1, ZERO, -32768
9D0308D4  0F40B479   JAL mmc_bankrom
9D0308D8  2406FFFF   ADDIU A2, ZERO, -1
168:                    mmc_bankrom(8, 0xA000, MMC_LASTBANK);
9D0308DC  24040008   ADDIU A0, ZERO, 8
9D0308E0  3405A000   ORI A1, ZERO, -24576
9D0308E4  0F40B479   JAL mmc_bankrom
9D0308E8  2406FFFF   ADDIU A2, ZERO, -1
169:                    mmc_bankrom(8, 0xC000, MMC_LASTBANK);
9D0308EC  24040008   ADDIU A0, ZERO, 8
9D0308F0  3405C000   ORI A1, ZERO, -16384
9D0308F4  0F40B479   JAL mmc_bankrom
9D0308F8  2406FFFF   ADDIU A2, ZERO, -1
170:                    mmc_bankrom(8, 0xE000, MMC_LASTBANK);
9D0308FC  24040008   ADDIU A0, ZERO, 8
9D030900  3405E000   ORI A1, ZERO, -8192
9D030904  0F40B479   JAL mmc_bankrom
9D030908  2406FFFF   ADDIU A2, ZERO, -1
171:                 
172:                    irq.counter = irq.latch = 0;
9D03090C  3C03A001   LUI V1, -24575
9D030910  2462B8CC   ADDIU V0, V1, -18228
9D030914  AC400004   SW ZERO, 4(V0)
9D030918  AC60B8CC   SW ZERO, -18228(V1)
173:                    irq.reset = irq.enabled = false;
9D03091C  AC400008   SW ZERO, 8(V0)
9D030920  AC40000C   SW ZERO, 12(V0)
174:                 }
9D030924  8FBF0014   LW RA, 20(SP)
9D030928  03E00008   JR RA
9D03092C  27BD0018   ADDIU SP, SP, 24
175:                 
176:                 static map_memwrite map64_memwrite[] =
177:                 {
178:                    { 0x8000, 0xFFFF, map64_write },
179:                    {     -1,     -1, NULL }
180:                 };
181:                 
182:                 mapintf_t map64_intf =
183:                 {
184:                    64, /* mapper number */
185:                    "Tengen RAMBO-1", /* mapper name */
186:                    map64_init, /* init routine */
187:                    NULL, /* vblank callback */
188:                    map64_hblank, /* hblank callback */
189:                    NULL, /* get state (snss) */
190:                    NULL, /* set state (snss) */
191:                    NULL, /* memory read structure */
192:                    map64_memwrite, /* memory write structure */
193:                    NULL /* external sound device */
194:                 };
195:                 
196:                 /*
197:                 ** $Log: map064.c,v $
198:                 ** Revision 1.2  2001/04/27 14:37:11  neil
199:                 ** wheeee
200:                 **
201:                 ** Revision 1.1  2001/04/27 12:54:40  neil
202:                 ** blah
203:                 **
204:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
205:                 ** initial
206:                 **
207:                 ** Revision 1.1  2000/10/24 12:19:33  matt
208:                 ** changed directory structure
209:                 **
210:                 ** Revision 1.8  2000/10/22 19:17:46  matt
211:                 ** mapper cleanups galore
212:                 **
213:                 ** Revision 1.7  2000/10/22 15:03:13  matt
214:                 ** simplified mirroring
215:                 **
216:                 ** Revision 1.6  2000/10/21 19:33:38  matt
217:                 ** many more cleanups
218:                 **
219:                 ** Revision 1.5  2000/10/10 13:58:17  matt
220:                 ** stroustrup squeezing his way in the door
221:                 **
222:                 ** Revision 1.4  2000/07/10 13:51:25  matt
223:                 ** using generic nes_irq() routine now
224:                 **
225:                 ** Revision 1.3  2000/07/10 05:29:03  matt
226:                 ** cleaned up some mirroring issues
227:                 **
228:                 ** Revision 1.2  2000/07/06 02:48:43  matt
229:                 ** clearly labelled structure members
230:                 **
231:                 ** Revision 1.1  2000/07/05 05:05:18  matt
232:                 ** initial revision
233:                 **
234:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map050.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map050.c
21:                  **
22:                  ** Mapper #50 (SMB2j - 3rd discovered variation)
23:                  ** Implementation by Firebug
24:                  ** Mapper information courtesy of Kevin Horton
25:                  ** $Id: map050.c,v 1.2 2001/04/27 14:37:11 neil Exp $
26:                  **
27:                  */
28:                  
29:                  #include <noftypes.h>
30:                  #include <nes_mmc.h>
31:                  #include <nes.h>
32:                  #include <libsnss.h>
33:                  #include <log.h>
34:                  
35:                  static struct
36:                  {
37:                    bool enabled;
38:                    uint32 counter;
39:                  } irq;
40:                  
41:                  /********************************/
42:                  /* Mapper #50 IRQ reset routine */
43:                  /********************************/
44:                  static void map50_irq_reset (void)
45:                  {
46:                    /* Turn off IRQs */
47:                    irq.enabled = false;
9D037868  AF808064   SW ZERO, -32668(GP)
9D0378F8  AF808064   SW ZERO, -32668(GP)
9D037954  AF808064   SW ZERO, -32668(GP)
48:                    irq.counter = 0x0000;
9D03786C  0B40DE2D   J .LVL11
9D037870  AF808068   SW ZERO, -32664(GP)
9D0378FC  AF808068   SW ZERO, -32664(GP)
9D037958  AF808068   SW ZERO, -32664(GP)
49:                  
50:                    /* Done */
51:                    return;
52:                  }
53:                  
54:                  /**************************************************************/
55:                  /* Mapper #50: 3rd discovered variation of SMB2j cart bootleg */
56:                  /**************************************************************/
57:                  static void map50_init (void)
58:                  {
9D03790C  27BDFFE8   ADDIU SP, SP, -24
9D037910  AFBF0014   SW RA, 20(SP)
59:                    /* Set the hardwired pages */
60:                    mmc_bankrom (8, 0x6000, 0x0F);
9D037914  24040008   ADDIU A0, ZERO, 8
9D037918  24056000   ADDIU A1, ZERO, 24576
9D03791C  0F40B479   JAL mmc_bankrom
9D037920  2406000F   ADDIU A2, ZERO, 15
61:                    mmc_bankrom (8, 0x8000, 0x08);
9D037924  24040008   ADDIU A0, ZERO, 8
9D037928  34058000   ORI A1, ZERO, -32768
9D03792C  0F40B479   JAL mmc_bankrom
9D037930  24060008   ADDIU A2, ZERO, 8
62:                    mmc_bankrom (8, 0xA000, 0x09);
9D037934  24040008   ADDIU A0, ZERO, 8
9D037938  3405A000   ORI A1, ZERO, -24576
9D03793C  0F40B479   JAL mmc_bankrom
9D037940  24060009   ADDIU A2, ZERO, 9
63:                    mmc_bankrom (8, 0xE000, 0x0B);
9D037944  24040008   ADDIU A0, ZERO, 8
9D037948  3405E000   ORI A1, ZERO, -8192
9D03794C  0F40B479   JAL mmc_bankrom
9D037950  2406000B   ADDIU A2, ZERO, 11
64:                  
65:                    /* Reset the IRQ counter */
66:                    map50_irq_reset ();
67:                  
68:                    /* Done */
69:                    return;
70:                  }
9D03795C  8FBF0014   LW RA, 20(SP)
9D037960  03E00008   JR RA
9D037964  27BD0018   ADDIU SP, SP, 24
71:                  
72:                  /****************************************/
73:                  /* Mapper #50 callback for IRQ handling */
74:                  /****************************************/
75:                  static void map50_hblank (int vblank)
76:                  {
9D0378C4  27BDFFE8   ADDIU SP, SP, -24
9D0378C8  AFBF0014   SW RA, 20(SP)
77:                     /* Counter is M2 based so it doesn't matter whether */
78:                     /* the PPU is in its VBlank period or not           */
79:                     UNUSED(vblank);
80:                  
81:                     /* Increment the counter if it is enabled and check for strike */
82:                     if (irq.enabled)
9D0378CC  8F828064   LW V0, -32668(GP)
9D0378D0  1040000B   BEQ V0, ZERO, .LBE8
9D0378D4  27838068   ADDIU V1, GP, -32664
83:                     {
84:                       /* Is there a constant for cycles per scanline? */
85:                       /* If so, someone ought to substitute it here   */
86:                       irq.counter = irq.counter + 114;
9D0378D8  8C620000   LW V0, 0(V1)
9D0378DC  24420072   ADDIU V0, V0, 114
9D0378E0  AC620000   SW V0, 0(V1)
87:                  
88:                       /* IRQ line is hooked to Q12 of the counter */
89:                       if (irq.counter & 0x1000)
9D0378E4  30421000   ANDI V0, V0, 4096
9D0378E8  10400006   BEQ V0, ZERO, 0x9D037904
9D0378EC  8FBF0014   LW RA, 20(SP)
90:                       {
91:                         /* Trigger the IRQ */
92:                         nes_irq ();
9D0378F0  0F408C7B   JAL nes_irq
9D0378F4  00000000   NOP
93:                  
94:                         /* Reset the counter */
95:                         map50_irq_reset ();
96:                       }
97:                     }
98:                  }
9D037900  8FBF0014   LW RA, 20(SP)
9D037904  03E00008   JR RA
9D037908  27BD0018   ADDIU SP, SP, 24
99:                  
100:                 /******************************************/
101:                 /* Mapper #50 write handler ($4000-$5FFF) */
102:                 /******************************************/
103:                 static void map50_write (uint32 address, uint8 value)
104:                 {
9D037848  27BDFFE8   ADDIU SP, SP, -24
105:                   uint8 selectable_bank;
106:                 
107:                   /* For address to be decoded, A5 must be high and A6 low */
108:                   if ((address & 0x60) != 0x20) return;
9D037838  30830060   ANDI V1, A0, 96
9D03783C  24020020   ADDIU V0, ZERO, 32
9D037840  1462001E   BNE V1, V0, 0x9D0378BC
9D037844  30840100   ANDI A0, A0, 256
109:                 
110:                   /* A8 low  = $C000-$DFFF page selection */
111:                   /* A8 high = IRQ timer toggle */
112:                   if (address & 0x100)
9D03784C  10800009   BEQ A0, ZERO, 0x9D037874
9D037850  AFBF0014   SW RA, 20(SP)
113:                   {
114:                     /* IRQ settings */
115:                     if (value & 0x01) irq.enabled = true;
9D037854  30A50001   ANDI A1, A1, 1
9D037858  10A00003   BEQ A1, ZERO, .LBB4
9D03785C  24020001   ADDIU V0, ZERO, 1
9D037860  0B40DE2D   J .LVL11
9D037864  AF828064   SW V0, -32668(GP)
116:                     else              map50_irq_reset ();
117:                   }
118:                   else
119:                   {
120:                     /* Stupid data line swapping */
121:                     selectable_bank = 0x00;
122:                     if (value & 0x08) selectable_bank |= 0x08;
123:                     if (value & 0x04) selectable_bank |= 0x02;
9D037874  30A20004   ANDI V0, A1, 4
9D037878  304200FF   ANDI V0, V0, 255
9D03787C  10400003   BEQ V0, ZERO, 0x9D03788C
9D037880  30A60008   ANDI A2, A1, 8
9D037884  34C60002   ORI A2, A2, 2
9D037888  30C600FF   ANDI A2, A2, 255
124:                     if (value & 0x02) selectable_bank |= 0x01;
9D03788C  30A30002   ANDI V1, A1, 2
9D037890  306300FF   ANDI V1, V1, 255
9D037894  34C20001   ORI V0, A2, 1
9D037898  0043300B   MOVN A2, V0, V1
125:                     if (value & 0x01) selectable_bank |= 0x04;
9D03789C  30A50001   ANDI A1, A1, 1
9D0378A0  34C20004   ORI V0, A2, 4
9D0378A4  0045300B   MOVN A2, V0, A1
126:                     mmc_bankrom (8, 0xC000, selectable_bank);
9D0378A8  24040008   ADDIU A0, ZERO, 8
9D0378AC  0F40B479   JAL mmc_bankrom
9D0378B0  3405C000   ORI A1, ZERO, -16384
127:                   }
128:                 
129:                   /* Done */
130:                   return;
131:                 }
9D0378B4  8FBF0014   LW RA, 20(SP)
9D0378B8  27BD0018   ADDIU SP, SP, 24
9D0378BC  03E00008   JR RA
9D0378C0  00000000   NOP
132:                 
133:                 /****************************************************/
134:                 /* Shove extra mapper information into a SNSS block */
135:                 /****************************************************/
136:                 static void map50_setstate (SnssMapperBlock *state)
137:                 {
9D037828  03E00008   JR RA
9D03782C  00000000   NOP
138:                   /* TODO: Store SNSS information */
139:                   UNUSED (state);
140:                 
141:                   /* Done */
142:                   return;
143:                 }
144:                 
145:                 /*****************************************************/
146:                 /* Pull extra mapper information out of a SNSS block */
147:                 /*****************************************************/
148:                 static void map50_getstate (SnssMapperBlock *state)
149:                 {
9D037830  03E00008   JR RA
9D037834  00000000   NOP
150:                   /* TODO: Retrieve SNSS information */
151:                   UNUSED (state);
152:                 
153:                   /* Done */
154:                   return;
155:                 }
156:                 
157:                 static map_memwrite map50_memwrite [] =
158:                 {
159:                    { 0x4000, 0x5FFF, map50_write },
160:                    {     -1,     -1, NULL }
161:                 };
162:                 
163:                 mapintf_t map50_intf =
164:                 {
165:                    50,                               /* Mapper number */
166:                    "SMB2j (3rd discovered variant)", /* Mapper name */
167:                    map50_init,                       /* Initialization routine */
168:                    NULL,                             /* VBlank callback */
169:                    map50_hblank,                     /* HBlank callback */
170:                    map50_getstate,                   /* Get state (SNSS) */
171:                    map50_setstate,                   /* Set state (SNSS) */
172:                    NULL,                             /* Memory read structure */
173:                    map50_memwrite,                   /* Memory write structure */
174:                    NULL                              /* External sound device */
175:                 };
176:                 
177:                 /*
178:                 ** $Log: map050.c,v $
179:                 ** Revision 1.2  2001/04/27 14:37:11  neil
180:                 ** wheeee
181:                 **
182:                 ** Revision 1.1  2001/04/27 12:54:40  neil
183:                 ** blah
184:                 **
185:                 ** Revision 1.1  2001/04/27 10:57:41  neil
186:                 ** wheee
187:                 **
188:                 ** Revision 1.1  2000/12/27 19:22:13  firebug
189:                 ** initial revision
190:                 **
191:                 **
192:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map046.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map046.c
21:                  **
22:                  ** Mapper #46 (Pelican Game Station)
23:                  ** Implementation by Firebug
24:                  ** Mapper information courtesy of Kevin Horton
25:                  ** $Id: map046.c,v 1.2 2001/04/27 14:37:11 neil Exp $
26:                  **
27:                  */
28:                  
29:                  #include <noftypes.h>
30:                  #include <nes_mmc.h>
31:                  #include <nes.h>
32:                  #include <libsnss.h>
33:                  #include <log.h>
34:                  
35:                  static uint8 prg_low_bank;
36:                  static uint8 chr_low_bank;
37:                  static uint8 prg_high_bank;
38:                  static uint8 chr_high_bank;
39:                  
40:                  /*************************************************/
41:                  /* Set banks from the combined register values   */
42:                  /*************************************************/
43:                  static void map46_set_banks (void)
44:                  {
9D039F88  27BDFFE8   ADDIU SP, SP, -24
9D039F8C  AFBF0014   SW RA, 20(SP)
45:                    /* Set the PRG and CHR pages */
46:                    mmc_bankrom (32, 0x8000, (prg_high_bank << 1) | (prg_low_bank));
9D039F90  938680BD   LBU A2, -32579(GP)
9D039F94  00063040   SLL A2, A2, 1
9D039F98  938280BF   LBU V0, -32577(GP)
9D039F9C  24040020   ADDIU A0, ZERO, 32
9D039FA0  34058000   ORI A1, ZERO, -32768
9D039FA4  0F40B479   JAL mmc_bankrom
9D039FA8  00C23025   OR A2, A2, V0
47:                    mmc_bankvrom (8, 0x0000, (chr_high_bank << 3) | (chr_low_bank));
9D039FAC  938680BC   LBU A2, -32580(GP)
9D039FB0  000630C0   SLL A2, A2, 3
9D039FB4  938280BE   LBU V0, -32578(GP)
9D039FB8  24040008   ADDIU A0, ZERO, 8
9D039FBC  00002821   ADDU A1, ZERO, ZERO
9D039FC0  0F40B41B   JAL mmc_bankvrom
9D039FC4  00C23025   OR A2, A2, V0
48:                  
49:                    /* Done */
50:                    return;
51:                  }
9D039FC8  8FBF0014   LW RA, 20(SP)
9D039FCC  03E00008   JR RA
9D039FD0  27BD0018   ADDIU SP, SP, 24
52:                  
53:                  /*********************************************************/
54:                  /* Mapper #46: Pelican Game Station (aka Rumble Station) */
55:                  /*********************************************************/
56:                  static void map46_init (void)
57:                  {
9D03A020  27BDFFE8   ADDIU SP, SP, -24
9D03A024  AFBF0014   SW RA, 20(SP)
58:                    /* High bank switch register is set to zero on reset */
59:                    prg_high_bank = 0x00;
9D03A028  A38080BD   SB ZERO, -32579(GP)
60:                    chr_high_bank = 0x00;
61:                    map46_set_banks ();
9D03A02C  0F40E7E2   JAL .LFB0, map46_set_banks, .LFE4
9D03A030  A38080BC   SB ZERO, -32580(GP)
62:                  
63:                    /* Done */
64:                    return;
65:                  }
9D03A034  8FBF0014   LW RA, 20(SP)
9D03A038  03E00008   JR RA
9D03A03C  27BD0018   ADDIU SP, SP, 24
66:                  
67:                  /******************************************/
68:                  /* Mapper #46 write handler ($6000-$FFFF) */
69:                  /******************************************/
70:                  static void map46_write (uint32 address, uint8 value)
71:                  {
9D039FD4  27BDFFE8   ADDIU SP, SP, -24
72:                    /* $8000-$FFFF: D6-D4 = lower three bits of CHR bank */
73:                    /*              D0    = low bit of PRG bank          */
74:                    /* $6000-$7FFF: D7-D4 = high four bits of CHR bank   */
75:                    /*              D3-D0 = high four bits of PRG bank   */
76:                    if (address & 0x8000)
9D039FD8  30848000   ANDI A0, A0, -32768
9D039FDC  10800008   BEQ A0, ZERO, 0x9D03A000
9D039FE0  AFBF0014   SW RA, 20(SP)
77:                    {
78:                      prg_low_bank = value & 0x01;
9D039FE4  30A20001   ANDI V0, A1, 1
9D039FE8  A38280BF   SB V0, -32577(GP)
79:                      chr_low_bank = (value >> 4) & 0x07;
9D039FEC  7CA51100   EXT A1, A1, 4, 3
80:                      map46_set_banks ();
9D039FF0  0F40E7E2   JAL .LFB0, map46_set_banks, .LFE4
9D039FF4  A38580BE   SB A1, -32578(GP)
9D039FF8  0B40E806   J 0x9D03A018
9D039FFC  8FBF0014   LW RA, 20(SP)
81:                    }
82:                    else
83:                    {
84:                      prg_high_bank = value & 0x0F;
9D03A000  30A2000F   ANDI V0, A1, 15
9D03A004  A38280BD   SB V0, -32579(GP)
85:                      chr_high_bank = (value >> 4) & 0x0F;
9D03A008  00052902   SRL A1, A1, 4
86:                      map46_set_banks ();
9D03A00C  0F40E7E2   JAL .LFB0, map46_set_banks, .LFE4
9D03A010  A38580BC   SB A1, -32580(GP)
87:                    }
88:                  
89:                    /* Done */
90:                    return;
91:                  }
9D03A014  8FBF0014   LW RA, 20(SP)
9D03A018  03E00008   JR RA
9D03A01C  27BD0018   ADDIU SP, SP, 24
92:                  
93:                  /****************************************************/
94:                  /* Shove extra mapper information into a SNSS block */
95:                  /****************************************************/
96:                  static void map46_setstate (SnssMapperBlock *state)
97:                  {
9D039F78  03E00008   JR RA
9D039F7C  00000000   NOP
98:                    /* TODO: Store SNSS information */
99:                    UNUSED (state);
100:                 
101:                   /* Done */
102:                   return;
103:                 }
104:                 
105:                 /*****************************************************/
106:                 /* Pull extra mapper information out of a SNSS block */
107:                 /*****************************************************/
108:                 static void map46_getstate (SnssMapperBlock *state)
109:                 {
9D039F80  03E00008   JR RA
9D039F84  00000000   NOP
110:                   /* TODO: Retrieve SNSS information */
111:                   UNUSED (state);
112:                 
113:                   /* Done */
114:                   return;
115:                 }
116:                 
117:                 static map_memwrite map46_memwrite [] =
118:                 {
119:                    { 0x6000, 0xFFFF, map46_write },
120:                    {     -1,     -1, NULL }
121:                 };
122:                 
123:                 mapintf_t map46_intf =
124:                 {
125:                    46,                               /* Mapper number */
126:                    "Pelican Game Station",           /* Mapper name */
127:                    map46_init,                       /* Initialization routine */
128:                    NULL,                             /* VBlank callback */
129:                    NULL,                             /* HBlank callback */
130:                    map46_getstate,                   /* Get state (SNSS) */
131:                    map46_setstate,                   /* Set state (SNSS) */
132:                    NULL,                             /* Memory read structure */
133:                    map46_memwrite,                   /* Memory write structure */
134:                    NULL                              /* External sound device */
135:                 };
136:                 
137:                 /*
138:                 ** $Log: map046.c,v $
139:                 ** Revision 1.2  2001/04/27 14:37:11  neil
140:                 ** wheeee
141:                 **
142:                 ** Revision 1.1  2001/04/27 12:54:40  neil
143:                 ** blah
144:                 **
145:                 ** Revision 1.1  2001/04/27 10:57:41  neil
146:                 ** wheee
147:                 **
148:                 ** Revision 1.1  2000/12/27 19:23:05  firebug
149:                 ** initial revision
150:                 **
151:                 **
152:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map042.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map042.c
21:                  **
22:                  ** Mapper #42 (Baby Mario bootleg)
23:                  ** Implementation by Firebug
24:                  ** Mapper information courtesy of Kevin Horton
25:                  ** $Id: map042.c,v 1.2 2001/04/27 14:37:11 neil Exp $
26:                  **
27:                  */
28:                  
29:                  #include <noftypes.h>
30:                  #include <nes_mmc.h>
31:                  #include <nes.h>
32:                  #include <libsnss.h>
33:                  #include <log.h>
34:                  
35:                  static struct
36:                  {
37:                    bool enabled;
38:                    uint32 counter;
39:                  } irq;
40:                  
41:                  /********************************/
42:                  /* Mapper #42 IRQ reset routine */
43:                  /********************************/
44:                  static void map42_irq_reset (void)
45:                  {
46:                    /* Turn off IRQs */
47:                    irq.enabled = false;
9D0371B8  AF8080B4   SW ZERO, -32588(GP)
9D037200  AF8080B4   SW ZERO, -32588(GP)
9D0372B0  AF8080B4   SW ZERO, -32588(GP)
48:                    irq.counter = 0x0000;
9D0371BC  AF8080B8   SW ZERO, -32584(GP)
9D037204  AF8080B8   SW ZERO, -32584(GP)
9D0372B4  AF8080B8   SW ZERO, -32584(GP)
49:                  
50:                    /* Done */
51:                    return;
52:                  }
53:                  
54:                  /********************************************/
55:                  /* Mapper #42: Baby Mario bootleg cartridge */
56:                  /********************************************/
57:                  static void map42_init (void)
58:                  {
9D037170  27BDFFE8   ADDIU SP, SP, -24
9D037174  AFBF0014   SW RA, 20(SP)
59:                    /* Set the hardwired pages */
60:                    mmc_bankrom (8, 0x8000, 0x0C);
9D037178  24040008   ADDIU A0, ZERO, 8
9D03717C  34058000   ORI A1, ZERO, -32768
9D037180  0F40B479   JAL mmc_bankrom
9D037184  2406000C   ADDIU A2, ZERO, 12
61:                    mmc_bankrom (8, 0xA000, 0x0D);
9D037188  24040008   ADDIU A0, ZERO, 8
9D03718C  3405A000   ORI A1, ZERO, -24576
9D037190  0F40B479   JAL mmc_bankrom
9D037194  2406000D   ADDIU A2, ZERO, 13
62:                    mmc_bankrom (8, 0xC000, 0x0E);
9D037198  24040008   ADDIU A0, ZERO, 8
9D03719C  3405C000   ORI A1, ZERO, -16384
9D0371A0  0F40B479   JAL mmc_bankrom
9D0371A4  2406000E   ADDIU A2, ZERO, 14
63:                    mmc_bankrom (8, 0xE000, 0x0F);
9D0371A8  24040008   ADDIU A0, ZERO, 8
9D0371AC  3405E000   ORI A1, ZERO, -8192
9D0371B0  0F40B479   JAL mmc_bankrom
9D0371B4  2406000F   ADDIU A2, ZERO, 15
64:                  
65:                    /* Reset the IRQ counter */
66:                    map42_irq_reset ();
67:                  
68:                    /* Done */
69:                    return;
70:                  }
9D0371C0  8FBF0014   LW RA, 20(SP)
9D0371C4  03E00008   JR RA
9D0371C8  27BD0018   ADDIU SP, SP, 24
71:                  
72:                  /****************************************/
73:                  /* Mapper #42 callback for IRQ handling */
74:                  /****************************************/
75:                  static void map42_hblank (int vblank)
76:                  {
9D0371CC  27BDFFE8   ADDIU SP, SP, -24
9D0371D0  AFBF0014   SW RA, 20(SP)
77:                     /* Counter is M2 based so it doesn't matter whether */
78:                     /* the PPU is in its VBlank period or not           */
79:                     UNUSED(vblank);
80:                  
81:                     /* Increment the counter if it is enabled and check for strike */
82:                     if (irq.enabled)
9D0371D4  8F8280B4   LW V0, -32588(GP)
9D0371D8  1040000B   BEQ V0, ZERO, .LBE8
9D0371DC  278380B8   ADDIU V1, GP, -32584
83:                     {
84:                       /* Is there a constant for cycles per scanline? */
85:                       /* If so, someone ought to substitute it here   */
86:                       irq.counter = irq.counter + 114;
9D0371E0  8C620000   LW V0, 0(V1)
9D0371E4  24420072   ADDIU V0, V0, 114
9D0371E8  AC620000   SW V0, 0(V1)
87:                  
88:                       /* IRQ is triggered after 24576 M2 cycles */
89:                       if (irq.counter >= 0x6000)
9D0371EC  2C426000   SLTIU V0, V0, 24576
9D0371F0  14400006   BNE V0, ZERO, 0x9D03720C
9D0371F4  8FBF0014   LW RA, 20(SP)
90:                       {
91:                         /* Trigger the IRQ */
92:                         nes_irq ();
9D0371F8  0F408C7B   JAL nes_irq
9D0371FC  00000000   NOP
93:                  
94:                         /* Reset the counter */
95:                         map42_irq_reset ();
96:                       }
97:                     }
98:                  }
9D037208  8FBF0014   LW RA, 20(SP)
9D03720C  03E00008   JR RA
9D037210  27BD0018   ADDIU SP, SP, 24
99:                  
100:                 /******************************************/
101:                 /* Mapper #42 write handler ($E000-$FFFF) */
102:                 /******************************************/
103:                 static void map42_write (uint32 address, uint8 value)
104:                 {
9D037214  27BDFFE8   ADDIU SP, SP, -24
9D037218  AFBF0014   SW RA, 20(SP)
105:                   switch (address & 0x03)
9D03721C  30840003   ANDI A0, A0, 3
9D037220  24020001   ADDIU V0, ZERO, 1
9D037224  1082000D   BEQ A0, V0, 0x9D03725C
9D037228  00A03021   ADDU A2, A1, ZERO
9D03722C  10800005   BEQ A0, ZERO, 0x9D037244
9D037230  24020002   ADDIU V0, ZERO, 2
9D037234  50820019   BEQL A0, V0, 0x9D03729C
9D037238  30A60002   ANDI A2, A1, 2
106:                   {
107:                     /* Register 0: Select ROM page at $6000-$7FFF */
108:                     case 0x00: mmc_bankrom (8, 0x6000, value & 0x0F);
9D037244  24040008   ADDIU A0, ZERO, 8
9D037248  24056000   ADDIU A1, ZERO, 24576
9D03724C  0F40B479   JAL mmc_bankrom
9D037250  30C6000F   ANDI A2, A2, 15
109:                                break;
9D037254  0B40DCAF   J 0x9D0372BC
9D037258  8FBF0014   LW RA, 20(SP)
110:                 
111:                     /* Register 1: mirroring */
112:                     case 0x01: if (value & 0x08) ppu_mirror(0, 0, 1, 1); /* horizontal */
9D03725C  30A60008   ANDI A2, A1, 8
9D037260  30C600FF   ANDI A2, A2, 255
9D037264  10C00007   BEQ A2, ZERO, 0x9D037284
9D037268  00002021   ADDU A0, ZERO, ZERO
9D03726C  00002821   ADDU A1, ZERO, ZERO
9D037270  24060001   ADDIU A2, ZERO, 1
9D037274  0F40635D   JAL ppu_mirror
9D037278  24070001   ADDIU A3, ZERO, 1
9D03727C  0B40DCAF   J 0x9D0372BC
9D037280  8FBF0014   LW RA, 20(SP)
113:                                else              ppu_mirror(0, 1, 0, 1); /* vertical   */
9D037284  24050001   ADDIU A1, ZERO, 1
9D037288  00003021   ADDU A2, ZERO, ZERO
9D03728C  0F40635D   JAL ppu_mirror
9D037290  24070001   ADDIU A3, ZERO, 1
114:                                break;
115:                 
116:                     /* Register 2: IRQ */
117:                     case 0x02: if (value & 0x02) irq.enabled = true;
9D03729C  30C600FF   ANDI A2, A2, 255
9D0372A0  10C00003   BEQ A2, ZERO, .LBB12
9D0372A4  24020001   ADDIU V0, ZERO, 1
9D0372A8  0B40DCAE   J .LBE12
9D0372AC  AF8280B4   SW V0, -32588(GP)
118:                                else              map42_irq_reset ();
119:                                break;
120:                 
121:                     /* Register 3: unused */
122:                     default:   break;
123:                   }
124:                 
125:                   /* Done */
126:                   return;
127:                 }
9D03723C  0B40DCAF   J 0x9D0372BC
9D037240  8FBF0014   LW RA, 20(SP)
9D037294  0B40DCAF   J 0x9D0372BC
9D037298  8FBF0014   LW RA, 20(SP)
9D0372B8  8FBF0014   LW RA, 20(SP)
9D0372BC  03E00008   JR RA
9D0372C0  27BD0018   ADDIU SP, SP, 24
128:                 
129:                 /****************************************************/
130:                 /* Shove extra mapper information into a SNSS block */
131:                 /****************************************************/
132:                 static void map42_setstate (SnssMapperBlock *state)
133:                 {
9D037160  03E00008   JR RA
9D037164  00000000   NOP
134:                   /* TODO: Store SNSS information */
135:                   UNUSED (state);
136:                 
137:                   /* Done */
138:                   return;
139:                 }
140:                 
141:                 /*****************************************************/
142:                 /* Pull extra mapper information out of a SNSS block */
143:                 /*****************************************************/
144:                 static void map42_getstate (SnssMapperBlock *state)
145:                 {
9D037168  03E00008   JR RA
9D03716C  00000000   NOP
146:                   /* TODO: Retrieve SNSS information */
147:                   UNUSED (state);
148:                 
149:                   /* Done */
150:                   return;
151:                 }
152:                 
153:                 static map_memwrite map42_memwrite [] =
154:                 {
155:                    { 0xE000, 0xFFFF, map42_write },
156:                    {     -1,     -1, NULL }
157:                 };
158:                 
159:                 mapintf_t map42_intf =
160:                 {
161:                    42,                               /* Mapper number */
162:                    "Baby Mario (bootleg)",           /* Mapper name */
163:                    map42_init,                       /* Initialization routine */
164:                    NULL,                             /* VBlank callback */
165:                    map42_hblank,                     /* HBlank callback */
166:                    map42_getstate,                   /* Get state (SNSS) */
167:                    map42_setstate,                   /* Set state (SNSS) */
168:                    NULL,                             /* Memory read structure */
169:                    map42_memwrite,                   /* Memory write structure */
170:                    NULL                              /* External sound device */
171:                 };
172:                 
173:                 /*
174:                 ** $Log: map042.c,v $
175:                 ** Revision 1.2  2001/04/27 14:37:11  neil
176:                 ** wheeee
177:                 **
178:                 ** Revision 1.1  2001/04/27 12:54:40  neil
179:                 ** blah
180:                 **
181:                 ** Revision 1.1  2001/04/27 10:57:41  neil
182:                 ** wheee
183:                 **
184:                 ** Revision 1.1  2000/12/27 19:23:30  firebug
185:                 ** initial revision
186:                 **
187:                 **
188:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map041.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map041.c
21:                  **
22:                  ** Mapper #41 (Caltron 6 in 1)
23:                  ** Implementation by Firebug
24:                  ** Mapper information courtesy of Kevin Horton
25:                  ** $Id: map041.c,v 1.2 2001/04/27 14:37:11 neil Exp $
26:                  **
27:                  */
28:                  
29:                  #include <noftypes.h>
30:                  #include <nes_mmc.h>
31:                  #include <nes.h>
32:                  #include <libsnss.h>
33:                  #include <log.h>
34:                  
35:                  static uint8 register_low;
36:                  static uint8 register_high;
37:                  
38:                  /*****************************************************/
39:                  /* Set 8K CHR bank from the combined register values */
40:                  /*****************************************************/
41:                  static void map41_set_chr (void)
42:                  {
9D03809C  27BDFFE8   ADDIU SP, SP, -24
9D0380A0  AFBF0014   SW RA, 20(SP)
43:                    /* Set the CHR bank from the appropriate register bits */
44:                    mmc_bankvrom (8, 0x0000, ((register_low >> 1) & 0x0C) | (register_high));
9D0380A4  938680D9   LBU A2, -32551(GP)
9D0380A8  00063042   SRL A2, A2, 1
9D0380AC  30C6000C   ANDI A2, A2, 12
9D0380B0  938280D8   LBU V0, -32552(GP)
9D0380B4  24040008   ADDIU A0, ZERO, 8
9D0380B8  00002821   ADDU A1, ZERO, ZERO
9D0380BC  0F40B41B   JAL mmc_bankvrom
9D0380C0  00C23025   OR A2, A2, V0
45:                  
46:                    /* Done */
47:                    return;
48:                  }
9D0380C4  8FBF0014   LW RA, 20(SP)
9D0380C8  03E00008   JR RA
9D0380CC  27BD0018   ADDIU SP, SP, 24
49:                  
50:                  /******************************/
51:                  /* Mapper #41: Caltron 6 in 1 */
52:                  /******************************/
53:                  static void map41_init (void)
54:                  {
9D038104  27BDFFE8   ADDIU SP, SP, -24
9D038108  AFBF0014   SW RA, 20(SP)
55:                    /* Both registers set to zero at power on */
56:                    /* TODO: Registers should also be cleared on a soft reset */
57:                    register_low = 0x00;
9D03810C  A38080D9   SB ZERO, -32551(GP)
58:                    register_high = 0x00;
9D038110  A38080D8   SB ZERO, -32552(GP)
59:                    mmc_bankrom (32, 0x8000, 0x00);
9D038114  24040020   ADDIU A0, ZERO, 32
9D038118  34058000   ORI A1, ZERO, -32768
9D03811C  0F40B479   JAL mmc_bankrom
9D038120  00003021   ADDU A2, ZERO, ZERO
60:                    map41_set_chr ();
9D038124  0F40E027   JAL .LFB0, map41_set_chr, .LFE5
9D038128  00000000   NOP
61:                  
62:                    /* Done */
63:                    return;
64:                  }
9D03812C  8FBF0014   LW RA, 20(SP)
9D038130  03E00008   JR RA
9D038134  27BD0018   ADDIU SP, SP, 24
65:                  
66:                  /******************************************/
67:                  /* Mapper #41 write handler ($6000-$67FF) */
68:                  /******************************************/
69:                  static void map41_low_write (uint32 address, uint8 value)
70:                  {
9D038138  27BDFFE8   ADDIU SP, SP, -24
9D03813C  AFBF0014   SW RA, 20(SP)
71:                    /* Within this range the value written is irrelevant */
72:                    UNUSED (value);
73:                  
74:                    /* $6000-$67FF: A5    = mirroring (1=horizontal, 0=vertical)      */
75:                    /*              A4-A3 = high two bits of 8K CHR bank              */
76:                    /*              A2    = register 1 enable (0=disabled, 1=enabled) */
77:                    /*              A2-A0 = 32K PRG bank                              */
78:                    register_low = (uint8) (address & 0x3F);
9D038140  308600FF   ANDI A2, A0, 255
9D038144  30C2003F   ANDI V0, A2, 63
9D038148  A38280D9   SB V0, -32551(GP)
79:                    mmc_bankrom (32, 0x8000, register_low & 0x07);
9D03814C  24040020   ADDIU A0, ZERO, 32
9D038150  34058000   ORI A1, ZERO, -32768
9D038154  0F40B479   JAL mmc_bankrom
9D038158  30C60007   ANDI A2, A2, 7
80:                    map41_set_chr ();
9D03815C  0F40E027   JAL .LFB0, map41_set_chr, .LFE5
9D038160  00000000   NOP
81:                    if (register_low & 0x20) ppu_mirror(0, 0, 1, 1); /* horizontal */
9D038164  938280D9   LBU V0, -32551(GP)
9D038168  30420020   ANDI V0, V0, 32
9D03816C  304200FF   ANDI V0, V0, 255
9D038170  10400007   BEQ V0, ZERO, 0x9D038190
9D038174  00002021   ADDU A0, ZERO, ZERO
9D038178  00002821   ADDU A1, ZERO, ZERO
9D03817C  24060001   ADDIU A2, ZERO, 1
9D038180  0F40635D   JAL ppu_mirror
9D038184  24070001   ADDIU A3, ZERO, 1
9D038188  0B40E069   J 0x9D0381A4
9D03818C  8FBF0014   LW RA, 20(SP)
82:                    else                     ppu_mirror(0, 1, 0, 1); /* vertical */
9D038190  24050001   ADDIU A1, ZERO, 1
9D038194  00003021   ADDU A2, ZERO, ZERO
9D038198  0F40635D   JAL ppu_mirror
9D03819C  24070001   ADDIU A3, ZERO, 1
83:                  
84:                    /* Done */
85:                    return;
86:                  }
9D0381A0  8FBF0014   LW RA, 20(SP)
9D0381A4  03E00008   JR RA
9D0381A8  27BD0018   ADDIU SP, SP, 24
87:                  
88:                  /******************************************/
89:                  /* Mapper #41 write handler ($8000-$FFFF) */
90:                  /******************************************/
91:                  static void map41_high_write (uint32 address, uint8 value)
92:                  {
9D0380D0  27BDFFE8   ADDIU SP, SP, -24
9D0380D4  AFBF0014   SW RA, 20(SP)
93:                    /* Address doesn't matter within this range */
94:                    UNUSED (address);
95:                  
96:                    /* $8000-$FFFF: D1-D0 = low two bits of 8K CHR bank */
97:                    if (register_low & 0x04)
9D0380D8  938280D9   LBU V0, -32551(GP)
9D0380DC  30420004   ANDI V0, V0, 4
9D0380E0  304200FF   ANDI V0, V0, 255
9D0380E4  10400005   BEQ V0, ZERO, 0x9D0380FC
9D0380E8  8FBF0014   LW RA, 20(SP)
98:                    {
99:                      register_high = value & 0x03;
9D0380EC  30A50003   ANDI A1, A1, 3
100:                     map41_set_chr ();
9D0380F0  0F40E027   JAL .LFB0, map41_set_chr, .LFE5
9D0380F4  A38580D8   SB A1, -32552(GP)
101:                   }
102:                 
103:                   /* Done */
104:                   return;
105:                 }
9D0380F8  8FBF0014   LW RA, 20(SP)
9D0380FC  03E00008   JR RA
9D038100  27BD0018   ADDIU SP, SP, 24
106:                 
107:                 /****************************************************/
108:                 /* Shove extra mapper information into a SNSS block */
109:                 /****************************************************/
110:                 static void map41_setstate (SnssMapperBlock *state)
111:                 {
9D03808C  03E00008   JR RA
9D038090  00000000   NOP
112:                   /* TODO: Store SNSS information */
113:                   UNUSED (state);
114:                 
115:                   /* Done */
116:                   return;
117:                 }
118:                 
119:                 /*****************************************************/
120:                 /* Pull extra mapper information out of a SNSS block */
121:                 /*****************************************************/
122:                 static void map41_getstate (SnssMapperBlock *state)
123:                 {
9D038094  03E00008   JR RA
9D038098  00000000   NOP
124:                   /* TODO: Retrieve SNSS information */
125:                   UNUSED (state);
126:                 
127:                   /* Done */
128:                   return;
129:                 }
130:                 
131:                 static map_memwrite map41_memwrite [] =
132:                 {
133:                    { 0x6000, 0x67FF, map41_low_write },
134:                    { 0x8000, 0xFFFF, map41_high_write },
135:                    {     -1,     -1, NULL }
136:                 };
137:                 
138:                 mapintf_t map41_intf =
139:                 {
140:                    41,                               /* Mapper number */
141:                    "Caltron 6 in 1",                 /* Mapper name */
142:                    map41_init,                       /* Initialization routine */
143:                    NULL,                             /* VBlank callback */
144:                    NULL,                             /* HBlank callback */
145:                    map41_getstate,                   /* Get state (SNSS) */
146:                    map41_setstate,                   /* Set state (SNSS) */
147:                    NULL,                             /* Memory read structure */
148:                    map41_memwrite,                   /* Memory write structure */
149:                    NULL                              /* External sound device */
150:                 };
151:                 
152:                 /*
153:                 ** $Log: map041.c,v $
154:                 ** Revision 1.2  2001/04/27 14:37:11  neil
155:                 ** wheeee
156:                 **
157:                 ** Revision 1.1  2001/04/27 12:54:40  neil
158:                 ** blah
159:                 **
160:                 ** Revision 1.1  2001/04/27 10:57:41  neil
161:                 ** wheee
162:                 **
163:                 ** Revision 1.1  2000/12/30 00:33:15  firebug
164:                 ** initial revision
165:                 **
166:                 **
167:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map040.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map40.c
21:                  **
22:                  ** mapper 40 interface
23:                  ** $Id: map040.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes.h>
29:                  #include <libsnss.h>
30:                  #include <log.h>
31:                  
32:                  #define  MAP40_IRQ_PERIOD  (4096 / 113.666666)
33:                  
34:                  static struct
35:                  {
36:                     int enabled, counter;
37:                  } irq;
38:                  
39:                  /* mapper 40: SMB 2j (hack) */
40:                  static void map40_init(void)
41:                  {
9D037FF0  27BDFFE8   ADDIU SP, SP, -24
9D037FF4  AFBF0014   SW RA, 20(SP)
42:                     mmc_bankrom(8, 0x6000, 6);
9D037FF8  24040008   ADDIU A0, ZERO, 8
9D037FFC  24056000   ADDIU A1, ZERO, 24576
9D038000  0F40B479   JAL mmc_bankrom
9D038004  24060006   ADDIU A2, ZERO, 6
43:                     mmc_bankrom(8, 0x8000, 4);
9D038008  24040008   ADDIU A0, ZERO, 8
9D03800C  34058000   ORI A1, ZERO, -32768
9D038010  0F40B479   JAL mmc_bankrom
9D038014  24060004   ADDIU A2, ZERO, 4
44:                     mmc_bankrom(8, 0xA000, 5);
9D038018  24040008   ADDIU A0, ZERO, 8
9D03801C  3405A000   ORI A1, ZERO, -24576
9D038020  0F40B479   JAL mmc_bankrom
9D038024  24060005   ADDIU A2, ZERO, 5
45:                     mmc_bankrom(8, 0xE000, 7);
9D038028  24040008   ADDIU A0, ZERO, 8
9D03802C  3405E000   ORI A1, ZERO, -8192
9D038030  0F40B479   JAL mmc_bankrom
9D038034  24060007   ADDIU A2, ZERO, 7
46:                  
47:                     irq.enabled = false;
9D038038  AF808070   SW ZERO, -32656(GP)
48:                     irq.counter = (int) MAP40_IRQ_PERIOD;
9D03803C  24020024   ADDIU V0, ZERO, 36
9D038040  AF828074   SW V0, -32652(GP)
49:                  }
9D038044  8FBF0014   LW RA, 20(SP)
9D038048  03E00008   JR RA
9D03804C  27BD0018   ADDIU SP, SP, 24
50:                  
51:                  static void map40_hblank(int vblank)
52:                  {
9D038050  27BDFFE8   ADDIU SP, SP, -24
9D038054  AFBF0014   SW RA, 20(SP)
53:                     UNUSED(vblank);
54:                  
55:                     if (irq.enabled && irq.counter)
9D038058  8F828070   LW V0, -32656(GP)
9D03805C  10400008   BEQ V0, ZERO, 0x9D038080
9D038060  8F828074   LW V0, -32652(GP)
9D038064  10400006   BEQ V0, ZERO, 0x9D038080
9D038068  2442FFFF   ADDIU V0, V0, -1
56:                     {
57:                        irq.counter--;
58:                        if (0 == irq.counter)
9D03806C  14400004   BNE V0, ZERO, 0x9D038080
9D038070  AF828074   SW V0, -32652(GP)
59:                        {
60:                           nes_irq();
9D038074  0F408C7B   JAL nes_irq
9D038078  00000000   NOP
61:                           irq.enabled = false;
9D03807C  AF808070   SW ZERO, -32656(GP)
62:                        }
63:                     }
64:                  }
9D038080  8FBF0014   LW RA, 20(SP)
9D038084  03E00008   JR RA
9D038088  27BD0018   ADDIU SP, SP, 24
65:                  
66:                  static void map40_write(uint32 address, uint8 value)
67:                  {
9D037F90  27BDFFE8   ADDIU SP, SP, -24
68:                     int range = (address >> 13) - 4;
9D037F94  00042342   SRL A0, A0, 13
9D037F98  2484FFFC   ADDIU A0, A0, -4
69:                  
70:                     switch (range)
9D037F9C  24020001   ADDIU V0, ZERO, 1
9D037FA0  1082000A   BEQ A0, V0, 0x9D037FCC
9D037FA4  AFBF0014   SW RA, 20(SP)
9D037FA8  24020003   ADDIU V0, ZERO, 3
9D037FAC  10820009   BEQ A0, V0, 0x9D037FD4
9D037FB0  00A03021   ADDU A2, A1, ZERO
9D037FB4  1480000C   BNE A0, ZERO, 0x9D037FE8
9D037FB8  8FBF0014   LW RA, 20(SP)
71:                     {
72:                     case 0: /* 0x8000-0x9FFF */
73:                        irq.enabled = false;
9D037FBC  AF808070   SW ZERO, -32656(GP)
74:                        irq.counter = (int) MAP40_IRQ_PERIOD;
9D037FC0  24020024   ADDIU V0, ZERO, 36
75:                        break;
9D037FC4  0B40DFF9   J .LVL8
9D037FC8  AF828074   SW V0, -32652(GP)
76:                  
77:                     case 1: /* 0xA000-0xBFFF */
78:                        irq.enabled = true;
79:                        break;
9D037FCC  0B40DFF9   J .LVL8
9D037FD0  AF828070   SW V0, -32656(GP)
80:                  
81:                     case 3: /* 0xE000-0xFFFF */
82:                        mmc_bankrom(8, 0xC000, value & 7);
9D037FD4  24040008   ADDIU A0, ZERO, 8
9D037FD8  3405C000   ORI A1, ZERO, -16384
9D037FDC  0F40B479   JAL mmc_bankrom
9D037FE0  30C60007   ANDI A2, A2, 7
83:                        break;
84:                  
85:                     default:
86:                        break;
87:                     }
88:                  }
9D037FE4  8FBF0014   LW RA, 20(SP)
9D037FE8  03E00008   JR RA
9D037FEC  27BD0018   ADDIU SP, SP, 24
89:                  
90:                  static void map40_getstate(SnssMapperBlock *state)
91:                  {
92:                     state->extraData.mapper40.irqCounter = irq.counter;
9D037F68  8F828074   LW V0, -32652(GP)
9D037F6C  A0820018   SB V0, 24(A0)
93:                     state->extraData.mapper40.irqCounterEnabled = irq.enabled;
9D037F70  8F828070   LW V0, -32656(GP)
9D037F74  03E00008   JR RA
9D037F78  A0820019   SB V0, 25(A0)
94:                  }
95:                  
96:                  static void map40_setstate(SnssMapperBlock *state)
97:                  {
98:                     irq.counter = state->extraData.mapper40.irqCounter;
9D037F7C  90820018   LBU V0, 24(A0)
9D037F80  AF828074   SW V0, -32652(GP)
99:                     irq.enabled = state->extraData.mapper40.irqCounterEnabled;
9D037F84  90820019   LBU V0, 25(A0)
9D037F88  03E00008   JR RA
9D037F8C  AF828070   SW V0, -32656(GP)
100:                 }
101:                 
102:                 static map_memwrite map40_memwrite[] =
103:                 {
104:                    { 0x8000, 0xFFFF, map40_write },
105:                    {     -1,     -1, NULL }
106:                 };
107:                 
108:                 mapintf_t map40_intf =
109:                 {
110:                    40, /* mapper number */
111:                    "SMB 2j (pirate)", /* mapper name */
112:                    map40_init, /* init routine */
113:                    NULL, /* vblank callback */
114:                    map40_hblank, /* hblank callback */
115:                    map40_getstate, /* get state (snss) */
116:                    map40_setstate, /* set state (snss) */
117:                    NULL, /* memory read structure */
118:                    map40_memwrite, /* memory write structure */
119:                    NULL /* external sound device */
120:                 };
121:                 
122:                 /*
123:                 ** $Log: map040.c,v $
124:                 ** Revision 1.2  2001/04/27 14:37:11  neil
125:                 ** wheeee
126:                 **
127:                 ** Revision 1.1  2001/04/27 12:54:40  neil
128:                 ** blah
129:                 **
130:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
131:                 ** initial
132:                 **
133:                 ** Revision 1.1  2000/10/24 12:19:33  matt
134:                 ** changed directory structure
135:                 **
136:                 ** Revision 1.9  2000/10/23 15:53:27  matt
137:                 ** suppressed warnings
138:                 **
139:                 ** Revision 1.8  2000/10/22 19:17:46  matt
140:                 ** mapper cleanups galore
141:                 **
142:                 ** Revision 1.7  2000/10/21 19:33:38  matt
143:                 ** many more cleanups
144:                 **
145:                 ** Revision 1.6  2000/10/10 13:58:17  matt
146:                 ** stroustrup squeezing his way in the door
147:                 **
148:                 ** Revision 1.5  2000/08/16 02:50:11  matt
149:                 ** random mapper cleanups
150:                 **
151:                 ** Revision 1.4  2000/07/15 23:52:19  matt
152:                 ** rounded out a bunch more mapper interfaces
153:                 **
154:                 ** Revision 1.3  2000/07/10 13:51:25  matt
155:                 ** using generic nes_irq() routine now
156:                 **
157:                 ** Revision 1.2  2000/07/06 02:48:43  matt
158:                 ** clearly labelled structure members
159:                 **
160:                 ** Revision 1.1  2000/07/05 05:05:18  matt
161:                 ** initial revision
162:                 **
163:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map034.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map34.c
21:                  **
22:                  ** mapper 34 interface
23:                  ** $Id: map034.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  
29:                  static void map34_init(void)
30:                  {
9D03AEC0  27BDFFE8   ADDIU SP, SP, -24
9D03AEC4  AFBF0014   SW RA, 20(SP)
31:                     mmc_bankrom(32, 0x8000, MMC_LASTBANK);
9D03AEC8  24040020   ADDIU A0, ZERO, 32
9D03AECC  34058000   ORI A1, ZERO, -32768
9D03AED0  0F40B479   JAL mmc_bankrom
9D03AED4  2406FFFF   ADDIU A2, ZERO, -1
32:                  }
9D03AED8  8FBF0014   LW RA, 20(SP)
9D03AEDC  03E00008   JR RA
9D03AEE0  27BD0018   ADDIU SP, SP, 24
33:                  
34:                  static void map34_write(uint32 address, uint8 value)
35:                  {
9D03AEE4  27BDFFE8   ADDIU SP, SP, -24
9D03AEE8  AFBF0014   SW RA, 20(SP)
36:                     if ((address & 0x8000) || (0x7FFD == address))
9D03AEEC  30828000   ANDI V0, A0, -32768
9D03AEF0  14400004   BNE V0, ZERO, 0x9D03AF04
9D03AEF4  00A03021   ADDU A2, A1, ZERO
9D03AEF8  24027FFD   ADDIU V0, ZERO, 32765
9D03AEFC  14820006   BNE A0, V0, 0x9D03AF18
9D03AF00  24027FFE   ADDIU V0, ZERO, 32766
37:                     {
38:                        mmc_bankrom(32, 0x8000, value);
9D03AF04  24040020   ADDIU A0, ZERO, 32
9D03AF08  0F40B479   JAL mmc_bankrom
9D03AF0C  34058000   ORI A1, ZERO, -32768
9D03AF10  0B40EBD3   J 0x9D03AF4C
9D03AF14  8FBF0014   LW RA, 20(SP)
39:                     }
40:                     else if (0x7FFE == address)
9D03AF18  14820006   BNE A0, V0, 0x9D03AF34
9D03AF1C  24027FFF   ADDIU V0, ZERO, 32767
41:                     {
42:                        mmc_bankvrom(4, 0x0000, value);
9D03AF20  24040004   ADDIU A0, ZERO, 4
9D03AF24  0F40B41B   JAL mmc_bankvrom
9D03AF28  00002821   ADDU A1, ZERO, ZERO
9D03AF2C  0B40EBD3   J 0x9D03AF4C
9D03AF30  8FBF0014   LW RA, 20(SP)
43:                     }
44:                     else if (0x7FFF == address)
9D03AF34  14820005   BNE A0, V0, 0x9D03AF4C
9D03AF38  8FBF0014   LW RA, 20(SP)
45:                     {
46:                        mmc_bankvrom(4, 0x1000, value);
9D03AF3C  24040004   ADDIU A0, ZERO, 4
9D03AF40  0F40B41B   JAL mmc_bankvrom
9D03AF44  24051000   ADDIU A1, ZERO, 4096
47:                     }
48:                  }
9D03AF48  8FBF0014   LW RA, 20(SP)
9D03AF4C  03E00008   JR RA
9D03AF50  27BD0018   ADDIU SP, SP, 24
49:                  
50:                  static map_memwrite map34_memwrite[] = 
51:                  {
52:                     { 0x7FFD, 0xFFFF, map34_write },
53:                     { -1, -1, NULL }
54:                  };
55:                  
56:                  mapintf_t map34_intf = 
57:                  {
58:                     34, /* mapper number */
59:                     "Nina-1", /* mapper name */
60:                     map34_init, /* init routine */
61:                     NULL, /* vblank callback */
62:                     NULL, /* hblank callback */
63:                     NULL, /* get state (snss) */
64:                     NULL, /* set state (snss) */
65:                     NULL, /* memory read structure */
66:                     map34_memwrite, /* memory write structure */
67:                     NULL /* external sound device */
68:                  };
69:                  
70:                  /*
71:                  ** $Log: map034.c,v $
72:                  ** Revision 1.2  2001/04/27 14:37:11  neil
73:                  ** wheeee
74:                  **
75:                  ** Revision 1.1  2001/04/27 12:54:40  neil
76:                  ** blah
77:                  **
78:                  ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
79:                  ** initial
80:                  **
81:                  ** Revision 1.1  2000/10/24 12:19:33  matt
82:                  ** changed directory structure
83:                  **
84:                  ** Revision 1.5  2000/10/22 19:17:46  matt
85:                  ** mapper cleanups galore
86:                  **
87:                  ** Revision 1.4  2000/10/21 19:33:38  matt
88:                  ** many more cleanups
89:                  **
90:                  ** Revision 1.3  2000/07/11 05:03:49  matt
91:                  ** value masking isn't necessary for the banking routines
92:                  **
93:                  ** Revision 1.2  2000/07/11 03:35:08  bsittler
94:                  ** Fixes to make mikes new mappers compile.
95:                  **
96:                  ** Revision 1.1  2000/07/11 03:14:18  melanson
97:                  ** Initial commit for mappers 16, 34, and 231
98:                  **
99:                  **
100:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map033.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map33.c
21:                  **
22:                  ** mapper 33 interface
23:                  ** $Id: map033.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes_ppu.h>
29:                  
30:                  /* mapper 33: Taito TC0190*/
31:                  static void map33_write(uint32 address, uint8 value)
32:                  {
9D038728  27BDFFE8   ADDIU SP, SP, -24
9D03872C  AFBF0014   SW RA, 20(SP)
33:                     int page = (address >> 13) & 3;
9D038734  7C840B40   EXT A0, A0, 13, 2
34:                     int reg = address & 3;
9D038730  30820003   ANDI V0, A0, 3
35:                  
36:                     switch (page)
9D038738  24030001   ADDIU V1, ZERO, 1
9D03873C  10830026   BEQ A0, V1, .LBB2
9D038740  00A03021   ADDU A2, A1, ZERO
9D038744  28830002   SLTI V1, A0, 2
9D038748  50600029   BEQL V1, ZERO, 0x9D0387F0
9D03874C  2C420002   SLTIU V0, V0, 2
9D038750  14800035   BNE A0, ZERO, .LVL23
9D038754  24030001   ADDIU V1, ZERO, 1
37:                     {
38:                     case 0: /* $800X */
39:                        switch (reg)
9D038758  10430011   BEQ V0, V1, 0x9D0387A0
9D03875C  28430002   SLTI V1, V0, 2
9D038760  50600005   BEQL V1, ZERO, 0x9D038778
9D038764  24030002   ADDIU V1, ZERO, 2
9D038768  10400009   BEQ V0, ZERO, 0x9D038790
9D03876C  24040008   ADDIU A0, ZERO, 8
9D038778  1043000E   BEQ V0, V1, 0x9D0387B4
9D03877C  24030003   ADDIU V1, ZERO, 3
9D038780  10430011   BEQ V0, V1, 0x9D0387C8
9D038784  24040002   ADDIU A0, ZERO, 2
40:                        {
41:                        case 0:
42:                           mmc_bankrom(8, 0x8000, value);
9D038790  0F40B479   JAL mmc_bankrom
9D038794  34058000   ORI A1, ZERO, -32768
43:                           break;
9D038798  0B40E20B   J 0x9D03882C
9D03879C  8FBF0014   LW RA, 20(SP)
44:                  
45:                        case 1:
46:                           mmc_bankrom(8, 0xA000, value);
9D0387A0  24040008   ADDIU A0, ZERO, 8
9D0387A4  0F40B479   JAL mmc_bankrom
9D0387A8  3405A000   ORI A1, ZERO, -24576
47:                           break;
9D0387AC  0B40E20B   J 0x9D03882C
9D0387B0  8FBF0014   LW RA, 20(SP)
48:                  
49:                        case 2:
50:                           mmc_bankvrom(2, 0x0000, value);
9D0387B4  24040002   ADDIU A0, ZERO, 2
9D0387B8  0F40B41B   JAL mmc_bankvrom
9D0387BC  00002821   ADDU A1, ZERO, ZERO
51:                           break;
9D0387C0  0B40E20B   J 0x9D03882C
9D0387C4  8FBF0014   LW RA, 20(SP)
52:                  
53:                        case 3:
54:                           mmc_bankvrom(2, 0x0800, value);
9D0387C8  0F40B41B   JAL mmc_bankvrom
9D0387CC  24050800   ADDIU A1, ZERO, 2048
55:                           break;
9D0387D0  0B40E20B   J 0x9D03882C
9D0387D4  8FBF0014   LW RA, 20(SP)
56:                        }
57:                        break;
58:                  
59:                     case 1: /* $A00X */
60:                        {
61:                           int loc = 0x1000 + (reg << 10);
9D0387D8  00022A80   SLL A1, V0, 10
62:                           mmc_bankvrom(1, loc, value);
9D0387DC  24040001   ADDIU A0, ZERO, 1
9D0387E0  0F40B41B   JAL mmc_bankvrom
9D0387E4  24A51000   ADDIU A1, A1, 4096
63:                        }
64:                        break;
9D0387E8  0B40E20B   J 0x9D03882C
9D0387EC  8FBF0014   LW RA, 20(SP)
65:                  
66:                     case 2: /* $C00X */
67:                     case 3: /* $E00X */
68:                        switch (reg)
9D0387F0  1040000D   BEQ V0, ZERO, .LVL23
9D0387F4  30A60001   ANDI A2, A1, 1
69:                        {
70:                        case 0:
71:                           /* irqs maybe ? */
72:                           //break;
73:                        
74:                        case 1:
75:                           /* this doesn't seem to work just right */
76:                           if (value & 1)
9D0387F8  10C00007   BEQ A2, ZERO, 0x9D038818
9D0387FC  00002021   ADDU A0, ZERO, ZERO
77:                              ppu_mirror(0, 0, 1, 1); /* horizontal */
9D038800  00002821   ADDU A1, ZERO, ZERO
9D038804  24060001   ADDIU A2, ZERO, 1
9D038808  0F40635D   JAL ppu_mirror
9D03880C  24070001   ADDIU A3, ZERO, 1
9D038810  0B40E20B   J 0x9D03882C
9D038814  8FBF0014   LW RA, 20(SP)
78:                           else
79:                              ppu_mirror(0, 1, 0, 1);
9D038818  24050001   ADDIU A1, ZERO, 1
9D03881C  00003021   ADDU A2, ZERO, ZERO
9D038820  0F40635D   JAL ppu_mirror
9D038824  24070001   ADDIU A3, ZERO, 1
80:                           break;
81:                  
82:                        default:
83:                           break;
84:                        }
85:                        break;
86:                     }
87:                  }
9D038770  0B40E20B   J 0x9D03882C
9D038774  8FBF0014   LW RA, 20(SP)
9D038788  0B40E20B   J 0x9D03882C
9D03878C  8FBF0014   LW RA, 20(SP)
9D038828  8FBF0014   LW RA, 20(SP)
9D03882C  03E00008   JR RA
9D038830  27BD0018   ADDIU SP, SP, 24
88:                  
89:                  
90:                  static map_memwrite map33_memwrite[] =
91:                  {
92:                     { 0x8000, 0xFFFF, map33_write },
93:                     {     -1,     -1, NULL }
94:                  };
95:                  
96:                  mapintf_t map33_intf =
97:                  {
98:                     33, /* mapper number */
99:                     "Taito TC0190", /* mapper name */
100:                    NULL, /* init routine */
101:                    NULL, /* vblank callback */
102:                    NULL, /* hblank callback */
103:                    NULL, /* get state (snss) */
104:                    NULL, /* set state (snss) */
105:                    NULL, /* memory read structure */
106:                    map33_memwrite, /* memory write structure */
107:                    NULL /* external sound device */
108:                 };
109:                 
110:                 /*
111:                 ** $Log: map033.c,v $
112:                 ** Revision 1.2  2001/04/27 14:37:11  neil
113:                 ** wheeee
114:                 **
115:                 ** Revision 1.1  2001/04/27 12:54:40  neil
116:                 ** blah
117:                 **
118:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
119:                 ** initial
120:                 **
121:                 ** Revision 1.1  2000/10/24 12:19:33  matt
122:                 ** changed directory structure
123:                 **
124:                 ** Revision 1.7  2000/10/22 19:17:46  matt
125:                 ** mapper cleanups galore
126:                 **
127:                 ** Revision 1.6  2000/10/22 15:03:13  matt
128:                 ** simplified mirroring
129:                 **
130:                 ** Revision 1.5  2000/10/21 19:33:38  matt
131:                 ** many more cleanups
132:                 **
133:                 ** Revision 1.4  2000/07/15 23:52:19  matt
134:                 ** rounded out a bunch more mapper interfaces
135:                 **
136:                 ** Revision 1.3  2000/07/10 05:29:03  matt
137:                 ** cleaned up some mirroring issues
138:                 **
139:                 ** Revision 1.2  2000/07/06 02:48:43  matt
140:                 ** clearly labelled structure members
141:                 **
142:                 ** Revision 1.1  2000/07/06 01:01:56  matt
143:                 ** initial revision
144:                 **
145:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map032.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map32.c
21:                  **
22:                  ** mapper 32 interface
23:                  ** $Id: map032.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes_ppu.h>
29:                  
30:                  static int select_c000 = 0;
31:                  
32:                  /* mapper 32: Irem G-101 */
33:                  static void map32_write(uint32 address, uint8 value)
34:                  {
9D03915C  27BDFFE8   ADDIU SP, SP, -24
9D039160  AFBF0014   SW RA, 20(SP)
9D039164  AFB00010   SW S0, 16(SP)
35:                     switch (address >> 12)
9D039168  00041302   SRL V0, A0, 12
9D03916C  24030009   ADDIU V1, ZERO, 9
9D039170  1043001B   BEQ V0, V1, 0x9D0391E0
9D039174  00A08021   ADDU S0, A1, ZERO
9D039178  2C43000A   SLTIU V1, V0, 10
9D03917C  10600006   BEQ V1, ZERO, 0x9D039198
9D039180  2403000A   ADDIU V1, ZERO, 10
9D039184  24030008   ADDIU V1, ZERO, 8
9D039188  10430009   BEQ V0, V1, 0x9D0391B0
9D03918C  8F828080   LW V0, -32640(GP)
9D039198  10430021   BEQ V0, V1, 0x9D039220
9D03919C  2403000B   ADDIU V1, ZERO, 11
9D0391A0  10430025   BEQ V0, V1, .LBB2
9D0391A4  30850007   ANDI A1, A0, 7
36:                     {
37:                     case 0x08: 
38:                        if (select_c000)
9D0391B0  10400006   BEQ V0, ZERO, 0x9D0391CC
9D0391B4  24040008   ADDIU A0, ZERO, 8
39:                           mmc_bankrom(8, 0xC000, value);
9D0391B8  3405C000   ORI A1, ZERO, -16384
9D0391BC  0F40B479   JAL mmc_bankrom
9D0391C0  02003021   ADDU A2, S0, ZERO
9D0391C4  0B40E493   J 0x9D03924C
9D0391C8  8FBF0014   LW RA, 20(SP)
40:                        else
41:                           mmc_bankrom(8, 0x8000, value);
9D0391CC  34058000   ORI A1, ZERO, -32768
9D0391D0  0F40B479   JAL mmc_bankrom
9D0391D4  02003021   ADDU A2, S0, ZERO
42:                        break;
43:                  
44:                     case 0x09: 
45:                        if (value & 1)
9D0391E0  30A20001   ANDI V0, A1, 1
9D0391E4  10400007   BEQ V0, ZERO, 0x9D039204
9D0391E8  00002021   ADDU A0, ZERO, ZERO
46:                           ppu_mirror(0, 0, 1, 1); /* horizontal */
9D0391EC  00002821   ADDU A1, ZERO, ZERO
9D0391F0  24060001   ADDIU A2, ZERO, 1
9D0391F4  0F40635D   JAL ppu_mirror
9D0391F8  24070001   ADDIU A3, ZERO, 1
9D0391FC  0B40E486   J 0x9D039218
9D039200  32100002   ANDI S0, S0, 2
47:                        else
48:                           ppu_mirror(0, 1, 0, 1); /* vertical */
9D039204  24050001   ADDIU A1, ZERO, 1
9D039208  00003021   ADDU A2, ZERO, ZERO
9D03920C  0F40635D   JAL ppu_mirror
9D039210  24070001   ADDIU A3, ZERO, 1
49:                     
50:                        select_c000 = (value & 0x02);
9D039214  32100002   ANDI S0, S0, 2
51:                        break;
9D039218  0B40E492   J .LVL21, .LBE2
9D03921C  AF908080   SW S0, -32640(GP)
52:                  
53:                     case 0x0A: 
54:                        mmc_bankrom(8, 0xA000, value); 
9D039220  24040008   ADDIU A0, ZERO, 8
9D039224  3405A000   ORI A1, ZERO, -24576
9D039228  0F40B479   JAL mmc_bankrom
9D03922C  02003021   ADDU A2, S0, ZERO
55:                        break;
9D039230  0B40E493   J 0x9D03924C
9D039234  8FBF0014   LW RA, 20(SP)
56:                  
57:                     case 0x0B: 
58:                        {
59:                           int loc = (address & 0x07) << 10;
60:                           mmc_bankvrom(1, loc, value);
9D039238  24040001   ADDIU A0, ZERO, 1
9D03923C  00052A80   SLL A1, A1, 10
9D039240  0F40B41B   JAL mmc_bankvrom
9D039244  02003021   ADDU A2, S0, ZERO
61:                        }
62:                        break;
63:                  
64:                     default:
65:                        break;
66:                     }
67:                  }
9D039190  0B40E493   J 0x9D03924C
9D039194  8FBF0014   LW RA, 20(SP)
9D0391A8  0B40E493   J 0x9D03924C
9D0391AC  8FBF0014   LW RA, 20(SP)
9D0391D8  0B40E493   J 0x9D03924C
9D0391DC  8FBF0014   LW RA, 20(SP)
9D039248  8FBF0014   LW RA, 20(SP)
9D03924C  8FB00010   LW S0, 16(SP)
9D039250  03E00008   JR RA
9D039254  27BD0018   ADDIU SP, SP, 24
68:                  
69:                  static map_memwrite map32_memwrite[] =
70:                  {
71:                     { 0x8000, 0xFFFF, map32_write },
72:                     {     -1,     -1, NULL }
73:                  };
74:                  
75:                  mapintf_t map32_intf =
76:                  {
77:                     32, /* mapper number */
78:                     "Irem G-101", /* mapper name */
79:                     NULL, /* init routine */
80:                     NULL, /* vblank callback */
81:                     NULL, /* hblank callback */
82:                     NULL, /* get state (snss) */
83:                     NULL, /* set state (snss) */
84:                     NULL, /* memory read structure */
85:                     map32_memwrite, /* memory write structure */
86:                     NULL /* external sound device */
87:                  };
88:                  
89:                  /*
90:                  ** $Log: map032.c,v $
91:                  ** Revision 1.2  2001/04/27 14:37:11  neil
92:                  ** wheeee
93:                  **
94:                  ** Revision 1.1  2001/04/27 12:54:40  neil
95:                  ** blah
96:                  **
97:                  ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
98:                  ** initial
99:                  **
100:                 ** Revision 1.1  2000/10/24 12:19:33  matt
101:                 ** changed directory structure
102:                 **
103:                 ** Revision 1.6  2000/10/22 19:17:46  matt
104:                 ** mapper cleanups galore
105:                 **
106:                 ** Revision 1.5  2000/10/22 15:03:13  matt
107:                 ** simplified mirroring
108:                 **
109:                 ** Revision 1.4  2000/10/21 19:33:38  matt
110:                 ** many more cleanups
111:                 **
112:                 ** Revision 1.3  2000/07/10 05:29:03  matt
113:                 ** cleaned up some mirroring issues
114:                 **
115:                 ** Revision 1.2  2000/07/06 02:48:43  matt
116:                 ** clearly labelled structure members
117:                 **
118:                 ** Revision 1.1  2000/07/06 01:01:56  matt
119:                 ** initial revision
120:                 **
121:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map024.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map24.c
21:                  **
22:                  ** mapper 24 interface
23:                  ** $Id: map024.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes.h>
29:                  #include <log.h>
30:                  #include <vrcvisnd.h>
31:                  
32:                  static struct
33:                  {
34:                     int counter, enabled;
35:                     int latch, wait_state;
36:                  } irq;
37:                  
38:                  static void map24_init(void)
39:                  {
40:                     irq.counter = irq.enabled = 0;
9D032200  3C03A001   LUI V1, -24575
9D032204  2462B8EC   ADDIU V0, V1, -18196
9D032208  AC400004   SW ZERO, 4(V0)
9D03220C  AC60B8EC   SW ZERO, -18196(V1)
41:                     irq.latch = irq.wait_state = 0;
9D032210  AC40000C   SW ZERO, 12(V0)
9D032214  03E00008   JR RA
9D032218  AC400008   SW ZERO, 8(V0)
42:                  }
43:                  
44:                  static void map24_hblank(int vblank) 
45:                  {
9D03250C  27BDFFE8   ADDIU SP, SP, -24
9D032510  AFBF0014   SW RA, 20(SP)
9D032514  AFB00010   SW S0, 16(SP)
46:                     UNUSED(vblank);
47:                  
48:                     if (irq.enabled)
9D0324E4  3C02A001   LUI V0, -24575
9D0324E8  8C42B8F0   LW V0, -18192(V0)
9D0324EC  10400013   BEQ V0, ZERO, 0x9D03253C
9D0324F0  3C03A001   LUI V1, -24575
49:                     {
50:                        if (256 == ++irq.counter)
9D0324F4  8C62B8EC   LW V0, -18196(V1)
9D0324F8  24420001   ADDIU V0, V0, 1
9D0324FC  AC62B8EC   SW V0, -18196(V1)
9D032500  24030100   ADDIU V1, ZERO, 256
9D032504  1443000D   BNE V0, V1, 0x9D03253C
9D032508  3C02A001   LUI V0, -24575
51:                        {
52:                           irq.counter = irq.latch;
9D032518  2450B8EC   ADDIU S0, V0, -18196
9D03251C  8E030008   LW V1, 8(S0)
53:                           nes_irq();
9D032520  0F408C7B   JAL nes_irq
9D032524  AC43B8EC   SW V1, -18196(V0)
54:                           //irq.enabled = false;
55:                           irq.enabled = irq.wait_state;
9D032528  8E02000C   LW V0, 12(S0)
9D03252C  AE020004   SW V0, 4(S0)
56:                        }
57:                     }
58:                  }
9D032530  8FBF0014   LW RA, 20(SP)
9D032534  8FB00010   LW S0, 16(SP)
9D032538  27BD0018   ADDIU SP, SP, 24
9D03253C  03E00008   JR RA
9D032540  00000000   NOP
59:                  
60:                  static void map24_write(uint32 address, uint8 value)
61:                  {
9D032254  27BDFFE8   ADDIU SP, SP, -24
9D032258  AFBF0014   SW RA, 20(SP)
62:                     switch (address & 0xF003)
9D03225C  3084F003   ANDI A0, A0, -4093
9D032260  3402D003   ORI V0, ZERO, -12285
9D032264  10820073   BEQ A0, V0, 0x9D032434
9D032268  00A03021   ADDU A2, A1, ZERO
9D03226C  3402D004   ORI V0, ZERO, -12284
9D032270  0082102B   SLTU V0, A0, V0
9D032274  10400017   BEQ V0, ZERO, 0x9D0322D4
9D032278  3402E003   ORI V0, ZERO, -8189
9D03227C  3402C000   ORI V0, ZERO, -16384
9D032280  10820059   BEQ A0, V0, 0x9D0323E8
9D032284  3402C001   ORI V0, ZERO, -16383
9D032288  0082102B   SLTU V0, A0, V0
9D03228C  10400008   BEQ V0, ZERO, 0x9D0322B0
9D032290  3402D001   ORI V0, ZERO, -12287
9D032294  34028000   ORI V0, ZERO, -32768
9D032298  10820025   BEQ A0, V0, 0x9D032330
9D03229C  3402B003   ORI V0, ZERO, -20477
9D0322A0  50820028   BEQL A0, V0, 0x9D032344
9D0322A4  30A6000C   ANDI A2, A1, 12
9D0322B0  10820056   BEQ A0, V0, 0x9D03240C
9D0322B4  3402D002   ORI V0, ZERO, -12286
9D0322B8  0082102B   SLTU V0, A0, V0
9D0322BC  10400058   BEQ V0, ZERO, 0x9D032420
9D0322C0  3402D000   ORI V0, ZERO, -12288
9D0322C4  1082004D   BEQ A0, V0, 0x9D0323FC
9D0322C8  24040001   ADDIU A0, ZERO, 1
9D0322D4  1082006A   BEQ A0, V0, 0x9D032480
9D0322D8  3402E004   ORI V0, ZERO, -8188
9D0322DC  0082102B   SLTU V0, A0, V0
9D0322E0  1040000A   BEQ V0, ZERO, 0x9D03230C
9D0322E4  3402E001   ORI V0, ZERO, -8191
9D0322E8  1082005B   BEQ A0, V0, 0x9D032458
9D0322EC  3402E002   ORI V0, ZERO, -8190
9D0322F0  0082102B   SLTU V0, A0, V0
9D0322F4  1040005D   BEQ V0, ZERO, 0x9D03246C
9D0322F8  3402E000   ORI V0, ZERO, -8192
9D0322FC  10820052   BEQ A0, V0, 0x9D032448
9D032300  24040001   ADDIU A0, ZERO, 1
9D03230C  3402F001   ORI V0, ZERO, -4095
9D032310  10820062   BEQ A0, V0, 0x9D03249C
9D032314  3402F002   ORI V0, ZERO, -4094
9D032318  1082006B   BEQ A0, V0, 0x9D0324C8
9D03231C  3402F000   ORI V0, ZERO, -4096
9D032320  1482006E   BNE A0, V0, 0x9D0324DC
9D032324  8FBF0014   LW RA, 20(SP)
63:                     {
64:                     case 0x8000:
65:                        mmc_bankrom(16, 0x8000, value);
9D032330  24040010   ADDIU A0, ZERO, 16
9D032334  0F40B479   JAL mmc_bankrom
9D032338  34058000   ORI A1, ZERO, -32768
66:                        break;
9D03233C  0B40C937   J 0x9D0324DC
9D032340  8FBF0014   LW RA, 20(SP)
67:                  
68:                     case 0x9003:
69:                        /* ??? */
70:                        break;
71:                     
72:                     case 0xB003:
73:                        switch (value & 0x0C)
9D032344  24020004   ADDIU V0, ZERO, 4
9D032348  10C20013   BEQ A2, V0, 0x9D032398
9D03234C  2CC20005   SLTIU V0, A2, 5
9D032350  50400005   BEQL V0, ZERO, 0x9D032368
9D032354  24020008   ADDIU V0, ZERO, 8
9D032358  10C00009   BEQ A2, ZERO, 0x9D032380
9D03235C  00002021   ADDU A0, ZERO, ZERO
9D032368  10C20012   BEQ A2, V0, 0x9D0323B4
9D03236C  2402000C   ADDIU V0, ZERO, 12
9D032370  10C20017   BEQ A2, V0, 0x9D0323D0
9D032374  24040001   ADDIU A0, ZERO, 1
74:                        {
75:                        case 0x00:
76:                           ppu_mirror(0, 1, 0, 1); /* vertical */
9D032380  24050001   ADDIU A1, ZERO, 1
9D032384  00003021   ADDU A2, ZERO, ZERO
9D032388  0F40635D   JAL ppu_mirror
9D03238C  24070001   ADDIU A3, ZERO, 1
77:                           break;
9D032390  0B40C937   J 0x9D0324DC
9D032394  8FBF0014   LW RA, 20(SP)
78:                        
79:                        case 0x04:
80:                           ppu_mirror(0, 0, 1, 1); /* horizontal */
9D032398  00002021   ADDU A0, ZERO, ZERO
9D03239C  00002821   ADDU A1, ZERO, ZERO
9D0323A0  24060001   ADDIU A2, ZERO, 1
9D0323A4  0F40635D   JAL ppu_mirror
9D0323A8  24070001   ADDIU A3, ZERO, 1
81:                           break;
9D0323AC  0B40C937   J 0x9D0324DC
9D0323B0  8FBF0014   LW RA, 20(SP)
82:                        
83:                        case 0x08:
84:                           ppu_mirror(0, 0, 0, 0);
9D0323B4  00002021   ADDU A0, ZERO, ZERO
9D0323B8  00002821   ADDU A1, ZERO, ZERO
9D0323BC  00003021   ADDU A2, ZERO, ZERO
9D0323C0  0F40635D   JAL ppu_mirror
9D0323C4  00003821   ADDU A3, ZERO, ZERO
85:                           break;
9D0323C8  0B40C937   J 0x9D0324DC
9D0323CC  8FBF0014   LW RA, 20(SP)
86:                        
87:                        case 0x0C:
88:                           ppu_mirror(1, 1, 1, 1);
9D0323D0  24050001   ADDIU A1, ZERO, 1
9D0323D4  24060001   ADDIU A2, ZERO, 1
9D0323D8  0F40635D   JAL ppu_mirror
9D0323DC  24070001   ADDIU A3, ZERO, 1
89:                           break;
9D0323E0  0B40C937   J 0x9D0324DC
9D0323E4  8FBF0014   LW RA, 20(SP)
90:                        
91:                        default:
92:                           break;
93:                        }
94:                        break;
95:                     
96:                  
97:                     case 0xC000:
98:                        mmc_bankrom(8, 0xC000, value);
9D0323E8  24040008   ADDIU A0, ZERO, 8
9D0323EC  0F40B479   JAL mmc_bankrom
9D0323F0  3405C000   ORI A1, ZERO, -16384
99:                        break;
9D0323F4  0B40C937   J 0x9D0324DC
9D0323F8  8FBF0014   LW RA, 20(SP)
100:                    
101:                    case 0xD000:
102:                       mmc_bankvrom(1, 0x0000, value);
9D0323FC  0F40B41B   JAL mmc_bankvrom
9D032400  00002821   ADDU A1, ZERO, ZERO
103:                       break;
9D032404  0B40C937   J 0x9D0324DC
9D032408  8FBF0014   LW RA, 20(SP)
104:                    
105:                    case 0xD001:
106:                       mmc_bankvrom(1, 0x0400, value);
9D03240C  24040001   ADDIU A0, ZERO, 1
9D032410  0F40B41B   JAL mmc_bankvrom
9D032414  24050400   ADDIU A1, ZERO, 1024
107:                       break;
9D032418  0B40C937   J 0x9D0324DC
9D03241C  8FBF0014   LW RA, 20(SP)
108:                    
109:                    case 0xD002:
110:                       mmc_bankvrom(1, 0x0800, value);
9D032420  24040001   ADDIU A0, ZERO, 1
9D032424  0F40B41B   JAL mmc_bankvrom
9D032428  24050800   ADDIU A1, ZERO, 2048
111:                       break;
9D03242C  0B40C937   J 0x9D0324DC
9D032430  8FBF0014   LW RA, 20(SP)
112:                    
113:                    case 0xD003:
114:                       mmc_bankvrom(1, 0x0C00, value);
9D032434  24040001   ADDIU A0, ZERO, 1
9D032438  0F40B41B   JAL mmc_bankvrom
9D03243C  24050C00   ADDIU A1, ZERO, 3072
115:                       break;
9D032440  0B40C937   J 0x9D0324DC
9D032444  8FBF0014   LW RA, 20(SP)
116:                    
117:                    case 0xE000:
118:                       mmc_bankvrom(1, 0x1000, value);
9D032448  0F40B41B   JAL mmc_bankvrom
9D03244C  24051000   ADDIU A1, ZERO, 4096
119:                       break;
9D032450  0B40C937   J 0x9D0324DC
9D032454  8FBF0014   LW RA, 20(SP)
120:                    
121:                    case 0xE001:
122:                       mmc_bankvrom(1, 0x1400, value);
9D032458  24040001   ADDIU A0, ZERO, 1
9D03245C  0F40B41B   JAL mmc_bankvrom
9D032460  24051400   ADDIU A1, ZERO, 5120
123:                       break;
9D032464  0B40C937   J 0x9D0324DC
9D032468  8FBF0014   LW RA, 20(SP)
124:                    
125:                    case 0xE002:
126:                       mmc_bankvrom(1, 0x1800, value);
9D03246C  24040001   ADDIU A0, ZERO, 1
9D032470  0F40B41B   JAL mmc_bankvrom
9D032474  24051800   ADDIU A1, ZERO, 6144
127:                       break;
9D032478  0B40C937   J 0x9D0324DC
9D03247C  8FBF0014   LW RA, 20(SP)
128:                    
129:                    case 0xE003:
130:                       mmc_bankvrom(1, 0x1C00, value);
9D032480  24040001   ADDIU A0, ZERO, 1
9D032484  0F40B41B   JAL mmc_bankvrom
9D032488  24051C00   ADDIU A1, ZERO, 7168
131:                       break;
9D03248C  0B40C937   J 0x9D0324DC
9D032490  8FBF0014   LW RA, 20(SP)
132:                    
133:                    case 0xF000:
134:                       irq.latch = value;
9D032328  0B40C925   J 0x9D032494
9D03232C  3C02A001   LUI V0, -24575
135:                       break;
9D032494  0B40C936   J 0x9D0324D8
9D032498  AC45B8F4   SW A1, -18188(V0)
136:                    
137:                    case 0xF001:
138:                       irq.enabled = (value >> 1) & 0x01;
9D03249C  7CA20040   EXT V0, A1, 1, 1
9D0324A0  3C03A001   LUI V1, -24575
9D0324A4  2463B8EC   ADDIU V1, V1, -18196
9D0324A8  AC620004   SW V0, 4(V1)
139:                       irq.wait_state = value & 0x01;
9D0324AC  30A60001   ANDI A2, A1, 1
140:                       if (irq.enabled)
9D0324B0  10400009   BEQ V0, ZERO, 0x9D0324D8
9D0324B4  AC66000C   SW A2, 12(V1)
141:                          irq.counter = irq.latch;
9D0324B8  3C02A001   LUI V0, -24575
9D0324BC  8C630008   LW V1, 8(V1)
9D0324C0  0B40C936   J 0x9D0324D8
9D0324C4  AC43B8EC   SW V1, -18196(V0)
142:                       break;
143:                    
144:                    case 0xF002:
145:                       irq.enabled = irq.wait_state;
9D0324C8  3C02A001   LUI V0, -24575
9D0324CC  2442B8EC   ADDIU V0, V0, -18196
9D0324D0  8C43000C   LW V1, 12(V0)
9D0324D4  AC430004   SW V1, 4(V0)
146:                       break;
147:                    
148:                    default:
149:                 #ifdef NOFRENDO_DEBUG
150:                       log_printf("invalid VRC6 write: $%02X to $%04X", value, address);
151:                 #endif
152:                       break;      
153:                    }
154:                 }
9D0322A8  0B40C937   J 0x9D0324DC
9D0322AC  8FBF0014   LW RA, 20(SP)
9D0322CC  0B40C937   J 0x9D0324DC
9D0322D0  8FBF0014   LW RA, 20(SP)
9D032304  0B40C937   J 0x9D0324DC
9D032308  8FBF0014   LW RA, 20(SP)
9D032360  0B40C937   J 0x9D0324DC
9D032364  8FBF0014   LW RA, 20(SP)
9D032378  0B40C937   J 0x9D0324DC
9D03237C  8FBF0014   LW RA, 20(SP)
9D0324D8  8FBF0014   LW RA, 20(SP)
9D0324DC  03E00008   JR RA
9D0324E0  27BD0018   ADDIU SP, SP, 24
155:                 
156:                 static void map24_getstate(SnssMapperBlock *state)
157:                 {
158:                    state->extraData.mapper24.irqCounter = irq.counter;
9D03221C  3C02A001   LUI V0, -24575
9D032220  8C43B8EC   LW V1, -18196(V0)
9D032224  A0830018   SB V1, 24(A0)
159:                    state->extraData.mapper24.irqCounterEnabled = irq.enabled;
9D032228  2442B8EC   ADDIU V0, V0, -18196
9D03222C  8C420004   LW V0, 4(V0)
9D032230  03E00008   JR RA
9D032234  A0820019   SB V0, 25(A0)
160:                 }
161:                 
162:                 static void map24_setstate(SnssMapperBlock *state)
163:                 {
164:                    irq.counter = state->extraData.mapper24.irqCounter;
9D032238  3C02A001   LUI V0, -24575
9D03223C  90830018   LBU V1, 24(A0)
9D032240  AC43B8EC   SW V1, -18196(V0)
165:                    irq.enabled = state->extraData.mapper24.irqCounterEnabled;
9D032244  2442B8EC   ADDIU V0, V0, -18196
9D032248  90830019   LBU V1, 25(A0)
9D03224C  03E00008   JR RA
9D032250  AC430004   SW V1, 4(V0)
166:                 }
167:                 
168:                 static map_memwrite map24_memwrite[] =
169:                 {
170:                    { 0x8000, 0xF002, map24_write },
171:                    {     -1,     -1, NULL }
172:                 };
173:                 
174:                 mapintf_t map24_intf =
175:                 {
176:                    24, /* mapper number */
177:                    "Konami VRC6", /* mapper name */
178:                    map24_init, /* init routine */
179:                    NULL, /* vblank callback */
180:                    map24_hblank, /* hblank callback */
181:                    map24_getstate, /* get state (snss) */
182:                    map24_setstate, /* set state (snss) */
183:                    NULL, /* memory read structure */
184:                    map24_memwrite, /* memory write structure */
185:                    &vrcvi_ext /* external sound device */
186:                 };
187:                 
188:                 /*
189:                 ** $Log: map024.c,v $
190:                 ** Revision 1.2  2001/04/27 14:37:11  neil
191:                 ** wheeee
192:                 **
193:                 ** Revision 1.1  2001/04/27 12:54:40  neil
194:                 ** blah
195:                 **
196:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
197:                 ** initial
198:                 **
199:                 ** Revision 1.1  2000/10/24 12:19:33  matt
200:                 ** changed directory structure
201:                 **
202:                 ** Revision 1.11  2000/10/22 19:17:46  matt
203:                 ** mapper cleanups galore
204:                 **
205:                 ** Revision 1.10  2000/10/22 15:03:13  matt
206:                 ** simplified mirroring
207:                 **
208:                 ** Revision 1.9  2000/10/21 19:33:38  matt
209:                 ** many more cleanups
210:                 **
211:                 ** Revision 1.8  2000/10/10 13:58:17  matt
212:                 ** stroustrup squeezing his way in the door
213:                 **
214:                 ** Revision 1.7  2000/10/09 12:00:53  matt
215:                 ** removed old code
216:                 **
217:                 ** Revision 1.6  2000/08/16 02:50:11  matt
218:                 ** random mapper cleanups
219:                 **
220:                 ** Revision 1.5  2000/07/15 23:52:19  matt
221:                 ** rounded out a bunch more mapper interfaces
222:                 **
223:                 ** Revision 1.4  2000/07/10 13:51:25  matt
224:                 ** using generic nes_irq() routine now
225:                 **
226:                 ** Revision 1.3  2000/07/10 05:29:03  matt
227:                 ** cleaned up some mirroring issues
228:                 **
229:                 ** Revision 1.2  2000/07/06 02:48:43  matt
230:                 ** clearly labelled structure members
231:                 **
232:                 ** Revision 1.1  2000/07/04 23:11:45  matt
233:                 ** initial revision
234:                 **
235:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map019.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map19.c
21:                  **
22:                  ** mapper 19 interface
23:                  ** $Id: map019.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes_ppu.h>
29:                  
30:                  /* TODO: shouldn't there be an h-blank IRQ handler??? */
31:                  
32:                  /* Special mirroring macro for mapper 19 */
33:                  #define N_BANK1(table, value) \
34:                  { \
35:                     if ((value) < 0xE0) \
36:                        ppu_setpage(1, (table) + 8, &mmc_getinfo()->vrom[((value) % (mmc_getinfo()->vrom_banks * 8)) << 10] - (0x2000 + ((table) << 10))); \
37:                     else \
38:                        ppu_setpage(1, (table) + 8, &mmc_getinfo()->vram[((value) & 7) << 10] - (0x2000 + ((table) << 10))); \
39:                     ppu_mirrorhipages(); \
40:                  }
41:                  
42:                  static struct
43:                  {
44:                     int counter, enabled;
45:                  } irq;
46:                  
47:                  static void map19_init(void)
48:                  {
49:                     irq.counter = irq.enabled = 0;
9D035404  AF80807C   SW ZERO, -32644(GP)
9D035408  03E00008   JR RA
9D03540C  AF808078   SW ZERO, -32648(GP)
50:                  }
51:                  
52:                  /* mapper 19: Namcot 106 */
53:                  static void map19_write(uint32 address, uint8 value)
54:                  {
9D035460  27BDFFE0   ADDIU SP, SP, -32
9D035464  AFBF001C   SW RA, 28(SP)
9D035468  AFB20018   SW S2, 24(SP)
9D03546C  AFB10014   SW S1, 20(SP)
9D035470  AFB00010   SW S0, 16(SP)
55:                     int reg = address >> 11;
9D03544C  000422C2   SRL A0, A0, 11
56:                     switch (reg)
9D035450  2482FFF6   ADDIU V0, A0, -10
9D035454  2C430015   SLTIU V1, V0, 21
9D035458  10600072   BEQ V1, ZERO, 0x9D035624
9D03545C  00021080   SLL V0, V0, 2
9D035474  3C039D03   LUI V1, -25341
9D035478  2463548C   ADDIU V1, V1, 21644
9D03547C  00621021   ADDU V0, V1, V0
9D035480  8C420000   LW V0, 0(V0)
9D035484  00400008   JR V0
9D035488  00A08021   ADDU S0, A1, ZERO
57:                     {
58:                     case 0xA:
59:                        irq.counter &= ~0xFF;
9D0354E4  8C430000   LW V1, 0(V0)
9D0354E8  7C033804   INS V1, ZERO, 0, 8
60:                        irq.counter |= value;
9D0354E0  27828078   ADDIU V0, GP, -32648
9D0354EC  00A38025   OR S0, A1, V1
61:                        break;
9D0354F0  0B40D584   J .LVL28
9D0354F4  AC500000   SW S0, 0(V0)
62:                     
63:                     case 0xB:
64:                        irq.counter = ((value & 0x7F) << 8) | (irq.counter & 0xFF);
9D0354F8  27828078   ADDIU V0, GP, -32648
9D0354FC  30A3007F   ANDI V1, A1, 127
9D035500  00031A00   SLL V1, V1, 8
9D035504  90440000   LBU A0, 0(V0)
9D035508  00641825   OR V1, V1, A0
9D03550C  AC430000   SW V1, 0(V0)
65:                        irq.enabled = (value & 0x80) ? true : false;
9D035510  000581C2   SRL S0, A1, 7
66:                        break;
9D035514  0B40D584   J .LVL28
9D035518  AF90807C   SW S0, -32644(GP)
67:                  
68:                     case 0x10:
69:                     case 0x11:
70:                     case 0x12:
71:                     case 0x13:
72:                     case 0x14:
73:                     case 0x15:
74:                     case 0x16:
75:                     case 0x17:
76:                        mmc_bankvrom(1, (reg & 7) << 10, value);
9D03551C  30850007   ANDI A1, A0, 7
9D035520  24040001   ADDIU A0, ZERO, 1
9D035524  00052A80   SLL A1, A1, 10
9D035528  0F40B41B   JAL mmc_bankvrom
9D03552C  02003021   ADDU A2, S0, ZERO
77:                        break;
9D035530  0B40D585   J 0x9D035614
9D035534  8FBF001C   LW RA, 28(SP)
78:                  
79:                     case 0x18:
80:                     case 0x19:
81:                     case 0x1A:
82:                     case 0x1B:
83:                        N_BANK1(reg & 3, value);
9D035538  2CA200E0   SLTIU V0, A1, 224
9D03553C  10400014   BEQ V0, ZERO, 0x9D035590
9D035540  00000000   NOP
9D035544  0F40B40F   JAL mmc_getinfo
9D035548  30910003   ANDI S1, A0, 3
9D03554C  0F40B40F   JAL mmc_getinfo
9D035550  8C520004   LW S2, 4(V0)
9D035554  8C420014   LW V0, 20(V0)
9D035558  000210C0   SLL V0, V0, 3
9D03555C  0202001A   DIV S0, V0
9D035560  004001F4   TEQ V0, ZERO
9D035564  00003010   MFHI A2
9D035568  00063280   SLL A2, A2, 10
9D03556C  24C6E000   ADDIU A2, A2, -8192
9D035570  00111280   SLL V0, S1, 10
9D035574  00C23023   SUBU A2, A2, V0
9D035578  24040001   ADDIU A0, ZERO, 1
9D03557C  26250008   ADDIU A1, S1, 8
9D035580  0F406314   JAL ppu_setpage
9D035584  02463021   ADDU A2, S2, A2
9D035588  0B40D570   J .LVL15
9D03558C  00000000   NOP
9D035590  0F40B40F   JAL mmc_getinfo
9D035594  30910003   ANDI S1, A0, 3
9D035598  32040007   ANDI A0, S0, 7
9D03559C  00042280   SLL A0, A0, 10
9D0355A0  2484E000   ADDIU A0, A0, -8192
9D0355A4  00111A80   SLL V1, S1, 10
9D0355A8  00831823   SUBU V1, A0, V1
9D0355AC  8C46000C   LW A2, 12(V0)
9D0355B0  24040001   ADDIU A0, ZERO, 1
9D0355B4  26250008   ADDIU A1, S1, 8
9D0355B8  0F406314   JAL ppu_setpage
9D0355BC  00C33021   ADDU A2, A2, V1
9D0355C0  0F40634E   JAL ppu_mirrorhipages
9D0355C4  00000000   NOP
84:                        break;
9D0355C8  0B40D585   J 0x9D035614
9D0355CC  8FBF001C   LW RA, 28(SP)
85:                  
86:                     case 0x1C:
87:                        mmc_bankrom(8, 0x8000, value);
9D0355D0  24040008   ADDIU A0, ZERO, 8
9D0355D4  34058000   ORI A1, ZERO, -32768
9D0355D8  0F40B479   JAL mmc_bankrom
9D0355DC  02003021   ADDU A2, S0, ZERO
88:                        break;
9D0355E0  0B40D585   J 0x9D035614
9D0355E4  8FBF001C   LW RA, 28(SP)
89:                  
90:                     case 0x1D:
91:                        mmc_bankrom(8, 0xA000, value);
9D0355E8  24040008   ADDIU A0, ZERO, 8
9D0355EC  3405A000   ORI A1, ZERO, -24576
9D0355F0  0F40B479   JAL mmc_bankrom
9D0355F4  02003021   ADDU A2, S0, ZERO
92:                        break;
9D0355F8  0B40D585   J 0x9D035614
9D0355FC  8FBF001C   LW RA, 28(SP)
93:                     
94:                     case 0x1E:
95:                        mmc_bankrom(8, 0xC000, value);
9D035600  24040008   ADDIU A0, ZERO, 8
9D035604  3405C000   ORI A1, ZERO, -16384
9D035608  0F40B479   JAL mmc_bankrom
9D03560C  02003021   ADDU A2, S0, ZERO
96:                        break;
97:                     
98:                     default:
99:                        break;
100:                    }
101:                 }
9D035610  8FBF001C   LW RA, 28(SP)
9D035614  8FB20018   LW S2, 24(SP)
9D035618  8FB10014   LW S1, 20(SP)
9D03561C  8FB00010   LW S0, 16(SP)
9D035620  27BD0020   ADDIU SP, SP, 32
9D035624  03E00008   JR RA
9D035628  00000000   NOP
102:                 
103:                 static void map19_getstate(SnssMapperBlock *state)
104:                 {
105:                    state->extraData.mapper19.irqCounterLowByte = irq.counter & 0xFF;
9D035410  8F828078   LW V0, -32648(GP)
9D035414  A0820018   SB V0, 24(A0)
106:                    state->extraData.mapper19.irqCounterHighByte = irq.counter >> 8;
9D035418  00021203   SRA V0, V0, 8
9D03541C  A0820019   SB V0, 25(A0)
107:                    state->extraData.mapper19.irqCounterEnabled = irq.enabled;
9D035420  8F82807C   LW V0, -32644(GP)
9D035424  03E00008   JR RA
9D035428  A082001A   SB V0, 26(A0)
108:                 }
109:                 
110:                 static void map19_setstate(SnssMapperBlock *state)
111:                 {
112:                    irq.counter = (state->extraData.mapper19.irqCounterHighByte << 8)
9D03542C  90820019   LBU V0, 25(A0)
9D035430  00021200   SLL V0, V0, 8
9D03543C  AF828078   SW V0, -32648(GP)
113:                                        | state->extraData.mapper19.irqCounterLowByte;
9D035434  90830018   LBU V1, 24(A0)
9D035438  00431025   OR V0, V0, V1
114:                    irq.enabled = state->extraData.mapper19.irqCounterEnabled;
9D035440  9082001A   LBU V0, 26(A0)
9D035444  03E00008   JR RA
9D035448  AF82807C   SW V0, -32644(GP)
115:                 }
116:                 
117:                 static map_memwrite map19_memwrite[] =
118:                 {
119:                    { 0x5000, 0x5FFF, map19_write },
120:                    { 0x8000, 0xFFFF, map19_write },
121:                    {     -1,     -1, NULL }
122:                 };
123:                 
124:                 mapintf_t map19_intf =
125:                 {
126:                    19, /* mapper number */
127:                    "Namcot 106", /* mapper name */
128:                    map19_init, /* init routine */
129:                    NULL, /* vblank callback */
130:                    NULL, /* hblank callback */
131:                    map19_getstate, /* get state (snss) */
132:                    map19_setstate, /* set state (snss) */
133:                    NULL, /* memory read structure */
134:                    map19_memwrite, /* memory write structure */
135:                    NULL /* external sound device */
136:                 };
137:                 
138:                 /*
139:                 ** $Log: map019.c,v $
140:                 ** Revision 1.2  2001/04/27 14:37:11  neil
141:                 ** wheeee
142:                 **
143:                 ** Revision 1.1  2001/04/27 12:54:40  neil
144:                 ** blah
145:                 **
146:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
147:                 ** initial
148:                 **
149:                 ** Revision 1.1  2000/10/24 12:19:33  matt
150:                 ** changed directory structure
151:                 **
152:                 ** Revision 1.6  2000/10/22 19:17:46  matt
153:                 ** mapper cleanups galore
154:                 **
155:                 ** Revision 1.5  2000/10/21 19:33:38  matt
156:                 ** many more cleanups
157:                 **
158:                 ** Revision 1.4  2000/10/10 13:58:17  matt
159:                 ** stroustrup squeezing his way in the door
160:                 **
161:                 ** Revision 1.3  2000/07/15 23:52:20  matt
162:                 ** rounded out a bunch more mapper interfaces
163:                 **
164:                 ** Revision 1.2  2000/07/06 02:48:43  matt
165:                 ** clearly labelled structure members
166:                 **
167:                 ** Revision 1.1  2000/07/06 01:01:56  matt
168:                 ** initial revision
169:                 **
170:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map018.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map18.c
21:                  **
22:                  ** mapper 18 interface
23:                  ** $Id: map018.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes_ppu.h>
29:                  
30:                  /* mapper 18: Jaleco SS8806 */
31:                  #define  VRC_PBANK(bank, value, high) \
32:                  do { \
33:                     if ((high)) \
34:                        highprgnybbles[(bank)] = (value) & 0x0F; \
35:                     else \
36:                        lowprgnybbles[(bank)] = (value) & 0x0F; \
37:                     mmc_bankrom(8, 0x8000 + ((bank) << 13), (highprgnybbles[(bank)] << 4)+lowprgnybbles[(bank)]); \
38:                  } while (0)
39:                  
40:                  #define VRC_VBANK(bank, value, high) \
41:                  { \
42:                     if ((high)) \
43:                        highnybbles[(bank)] = (value) & 0x0F; \
44:                     else \
45:                        lownybbles[(bank)] = (value) & 0x0F; \
46:                     mmc_bankvrom(1, (bank) << 10, (highnybbles[(bank)] << 4)+lownybbles[(bank)]); \
47:                  }
48:                  
49:                  static struct
50:                  {
51:                     int counter, enabled;
52:                     uint8 nybbles[4];
53:                     int clockticks;
54:                  } irq;
55:                  
56:                  static void map18_init(void)
57:                  {
58:                     irq.counter = irq.enabled = 0;
9D02C1CC  3C02A001   LUI V0, -24575
9D02C1D0  2443B8AC   ADDIU V1, V0, -18260
9D02C1D4  AC600004   SW ZERO, 4(V1)
9D02C1D8  03E00008   JR RA
9D02C1DC  AC40B8AC   SW ZERO, -18260(V0)
59:                  }
60:                  
61:                  static uint8 lownybbles[8];
62:                  static uint8 highnybbles[8];
63:                  static uint8 lowprgnybbles[3];
64:                  static uint8 highprgnybbles[3];
65:                  
66:                  
67:                  static void map18_write(uint32 address, uint8 value)
68:                  {
9D02C22C  27BDFFE8   ADDIU SP, SP, -24
69:                     switch (address)
9D02C230  3402C000   ORI V0, ZERO, -16384
9D02C234  108200F0   BEQ A0, V0, 0x9D02C5F8
9D02C238  AFBF0014   SW RA, 20(SP)
9D02C23C  3402C001   ORI V0, ZERO, -16383
9D02C240  0082102B   SLTU V0, A0, V0
9D02C244  10400031   BEQ V0, ZERO, 0x9D02C30C
9D02C248  3402A000   ORI V0, ZERO, -24576
9D02C24C  1082009C   BEQ A0, V0, 0x9D02C4C0
9D02C250  3402A001   ORI V0, ZERO, -24575
9D02C254  0082102B   SLTU V0, A0, V0
9D02C258  10400016   BEQ V0, ZERO, 0x9D02C2B4
9D02C25C  3402B000   ORI V0, ZERO, -20480
9D02C260  34028002   ORI V0, ZERO, -32766
9D02C264  1082006F   BEQ A0, V0, 0x9D02C424
9D02C268  34028003   ORI V0, ZERO, -32765
9D02C26C  0082102B   SLTU V0, A0, V0
9D02C270  10400008   BEQ V0, ZERO, 0x9D02C294
9D02C274  34029000   ORI V0, ZERO, -28672
9D02C278  34028000   ORI V0, ZERO, -32768
9D02C27C  10820056   BEQ A0, V0, 0x9D02C3D8
9D02C280  34028001   ORI V0, ZERO, -32767
9D02C284  5082005E   BEQL A0, V0, 0x9D02C400
9D02C288  30A5000F   ANDI A1, A1, 15
9D02C294  10820076   BEQ A0, V0, 0x9D02C470
9D02C298  34029001   ORI V0, ZERO, -28671
9D02C29C  1082007E   BEQ A0, V0, 0x9D02C498
9D02C2A0  34028003   ORI V0, ZERO, -32765
9D02C2A4  548201C3   BNEL A0, V0, 0x9D02C9B4
9D02C2A8  8FBF0014   LW RA, 20(SP)
9D02C2B4  108200A9   BEQ A0, V0, 0x9D02C55C
9D02C2B8  3402B001   ORI V0, ZERO, -20479
9D02C2BC  0082102B   SLTU V0, A0, V0
9D02C2C0  10400009   BEQ V0, ZERO, 0x9D02C2E8
9D02C2C4  3402A002   ORI V0, ZERO, -24574
9D02C2C8  10820091   BEQ A0, V0, 0x9D02C510
9D02C2CC  0082102B   SLTU V0, A0, V0
9D02C2D0  14400085   BNE V0, ZERO, 0x9D02C4E8
9D02C2D4  3402A003   ORI V0, ZERO, -24573
9D02C2D8  50820097   BEQL A0, V0, 0x9D02C538
9D02C2DC  30A5000F   ANDI A1, A1, 15
9D02C2E8  3402B002   ORI V0, ZERO, -20478
9D02C2EC  108200AF   BEQ A0, V0, 0x9D02C5AC
9D02C2F0  0082102B   SLTU V0, A0, V0
9D02C2F4  144000A3   BNE V0, ZERO, 0x9D02C584
9D02C2F8  3402B003   ORI V0, ZERO, -20477
9D02C2FC  508200B5   BEQL A0, V0, 0x9D02C5D4
9D02C300  30A5000F   ANDI A1, A1, 15
9D02C30C  3402D003   ORI V0, ZERO, -12285
9D02C310  108200FD   BEQ A0, V0, 0x9D02C708
9D02C314  3402D004   ORI V0, ZERO, -12284
9D02C318  0082102B   SLTU V0, A0, V0
9D02C31C  10400017   BEQ V0, ZERO, 0x9D02C37C
9D02C320  3402E003   ORI V0, ZERO, -8189
9D02C324  3402C003   ORI V0, ZERO, -16381
9D02C328  108200D0   BEQ A0, V0, 0x9D02C66C
9D02C32C  3402C004   ORI V0, ZERO, -16380
9D02C330  0082102B   SLTU V0, A0, V0
9D02C334  10400008   BEQ V0, ZERO, 0x9D02C358
9D02C338  3402D001   ORI V0, ZERO, -12287
9D02C33C  3402C001   ORI V0, ZERO, -16383
9D02C340  108200B7   BEQ A0, V0, 0x9D02C620
9D02C344  3402C002   ORI V0, ZERO, -16382
9D02C348  108200BF   BEQ A0, V0, 0x9D02C648
9D02C34C  30A2000F   ANDI V0, A1, 15
9D02C358  108200D7   BEQ A0, V0, 0x9D02C6B8
9D02C35C  3402D002   ORI V0, ZERO, -12286
9D02C360  0082102B   SLTU V0, A0, V0
9D02C364  104000DE   BEQ V0, ZERO, 0x9D02C6E0
9D02C368  3402D000   ORI V0, ZERO, -12288
9D02C36C  108200C9   BEQ A0, V0, 0x9D02C694
9D02C370  30A2000F   ANDI V0, A1, 15
9D02C37C  10820142   BEQ A0, V0, 0x9D02C888
9D02C380  3402E004   ORI V0, ZERO, -8188
9D02C384  0082102B   SLTU V0, A0, V0
9D02C388  1040000A   BEQ V0, ZERO, 0x9D02C3B4
9D02C38C  3402E001   ORI V0, ZERO, -8191
9D02C390  10820103   BEQ A0, V0, 0x9D02C7A0
9D02C394  3402E002   ORI V0, ZERO, -8190
9D02C398  0082102B   SLTU V0, A0, V0
9D02C39C  1040011D   BEQ V0, ZERO, 0x9D02C814
9D02C3A0  3402E000   ORI V0, ZERO, -8192
9D02C3A4  508200E2   BEQL A0, V0, 0x9D02C730
9D02C3A8  30A5000F   ANDI A1, A1, 15
9D02C3B4  3402F001   ORI V0, ZERO, -4095
9D02C3B8  10820156   BEQ A0, V0, 0x9D02C914
9D02C3BC  3402F002   ORI V0, ZERO, -4094
9D02C3C0  10820158   BEQ A0, V0, 0x9D02C924
9D02C3C4  3402F000   ORI V0, ZERO, -4096
9D02C3C8  1482017A   BNE A0, V0, 0x9D02C9B4
9D02C3CC  8FBF0014   LW RA, 20(SP)
70:                     {
71:                     case 0x8000: VRC_PBANK(0, value, 0); break;
9D02C3D8  30A2000F   ANDI V0, A1, 15
9D02C3DC  A3828098   SB V0, -32616(GP)
9D02C3E0  93868094   LBU A2, -32620(GP)
9D02C3E4  00063100   SLL A2, A2, 4
9D02C3E8  24040008   ADDIU A0, ZERO, 8
9D02C3EC  34058000   ORI A1, ZERO, -32768
9D02C3F0  0F40B479   JAL mmc_bankrom
9D02C3F4  00C23021   ADDU A2, A2, V0
9D02C3F8  0B40B26D   J 0x9D02C9B4
9D02C3FC  8FBF0014   LW RA, 20(SP)
72:                     case 0x8001: VRC_PBANK(0, value, 1); break;
9D02C400  A3858094   SB A1, -32620(GP)
9D02C404  00053100   SLL A2, A1, 4
9D02C408  93828098   LBU V0, -32616(GP)
9D02C40C  24040008   ADDIU A0, ZERO, 8
9D02C410  34058000   ORI A1, ZERO, -32768
9D02C414  0F40B479   JAL mmc_bankrom
9D02C418  00C23021   ADDU A2, A2, V0
9D02C41C  0B40B26D   J 0x9D02C9B4
9D02C420  8FBF0014   LW RA, 20(SP)
73:                     case 0x8002: VRC_PBANK(1, value, 0); break;
9D02C424  30A2000F   ANDI V0, A1, 15
9D02C428  A3828099   SB V0, -32615(GP)
9D02C42C  93868095   LBU A2, -32619(GP)
9D02C430  00063100   SLL A2, A2, 4
9D02C434  24040008   ADDIU A0, ZERO, 8
9D02C438  3405A000   ORI A1, ZERO, -24576
9D02C43C  0F40B479   JAL mmc_bankrom
9D02C440  00C23021   ADDU A2, A2, V0
9D02C444  0B40B26D   J 0x9D02C9B4
9D02C448  8FBF0014   LW RA, 20(SP)
74:                     case 0x8003: VRC_PBANK(1, value, 1); break;
9D02C2AC  0B40B113   J 0x9D02C44C
9D02C2B0  30A5000F   ANDI A1, A1, 15
9D02C44C  A3858095   SB A1, -32619(GP)
9D02C450  00053100   SLL A2, A1, 4
9D02C454  93828099   LBU V0, -32615(GP)
9D02C458  24040008   ADDIU A0, ZERO, 8
9D02C45C  3405A000   ORI A1, ZERO, -24576
9D02C460  0F40B479   JAL mmc_bankrom
9D02C464  00C23021   ADDU A2, A2, V0
9D02C468  0B40B26D   J 0x9D02C9B4
9D02C46C  8FBF0014   LW RA, 20(SP)
75:                     case 0x9000: VRC_PBANK(2, value, 0); break;
9D02C470  30A2000F   ANDI V0, A1, 15
9D02C474  A382809A   SB V0, -32614(GP)
9D02C478  93868096   LBU A2, -32618(GP)
9D02C47C  00063100   SLL A2, A2, 4
9D02C480  24040008   ADDIU A0, ZERO, 8
9D02C484  3405C000   ORI A1, ZERO, -16384
9D02C488  0F40B479   JAL mmc_bankrom
9D02C48C  00C23021   ADDU A2, A2, V0
9D02C490  0B40B26D   J 0x9D02C9B4
9D02C494  8FBF0014   LW RA, 20(SP)
76:                     case 0x9001: VRC_PBANK(2, value, 1); break;
9D02C498  30A5000F   ANDI A1, A1, 15
9D02C49C  A3858096   SB A1, -32618(GP)
9D02C4A0  00053100   SLL A2, A1, 4
9D02C4A4  9382809A   LBU V0, -32614(GP)
9D02C4A8  24040008   ADDIU A0, ZERO, 8
9D02C4AC  3405C000   ORI A1, ZERO, -16384
9D02C4B0  0F40B479   JAL mmc_bankrom
9D02C4B4  00C23021   ADDU A2, A2, V0
9D02C4B8  0B40B26D   J 0x9D02C9B4
9D02C4BC  8FBF0014   LW RA, 20(SP)
77:                     case 0xA000: VRC_VBANK(0, value, 0); break;
9D02C4C0  30A2000F   ANDI V0, A1, 15
9D02C4C4  A38280A4   SB V0, -32604(GP)
9D02C4C8  9386809C   LBU A2, -32612(GP)
9D02C4CC  00063100   SLL A2, A2, 4
9D02C4D0  24040001   ADDIU A0, ZERO, 1
9D02C4D4  00002821   ADDU A1, ZERO, ZERO
9D02C4D8  0F40B41B   JAL mmc_bankvrom
9D02C4DC  00C23021   ADDU A2, A2, V0
9D02C4E0  0B40B26D   J 0x9D02C9B4
9D02C4E4  8FBF0014   LW RA, 20(SP)
78:                     case 0xA001: VRC_VBANK(0, value, 1); break;
9D02C4E8  30A5000F   ANDI A1, A1, 15
9D02C4EC  A385809C   SB A1, -32612(GP)
9D02C4F0  00053100   SLL A2, A1, 4
9D02C4F4  938280A4   LBU V0, -32604(GP)
9D02C4F8  24040001   ADDIU A0, ZERO, 1
9D02C4FC  00002821   ADDU A1, ZERO, ZERO
9D02C500  0F40B41B   JAL mmc_bankvrom
9D02C504  00C23021   ADDU A2, A2, V0
9D02C508  0B40B26D   J 0x9D02C9B4
9D02C50C  8FBF0014   LW RA, 20(SP)
79:                     case 0xA002: VRC_VBANK(1, value, 0); break;
9D02C510  30A2000F   ANDI V0, A1, 15
9D02C514  A38280A5   SB V0, -32603(GP)
9D02C518  9386809D   LBU A2, -32611(GP)
9D02C51C  00063100   SLL A2, A2, 4
9D02C520  24040001   ADDIU A0, ZERO, 1
9D02C524  24050400   ADDIU A1, ZERO, 1024
9D02C528  0F40B41B   JAL mmc_bankvrom
9D02C52C  00C23021   ADDU A2, A2, V0
9D02C530  0B40B26D   J 0x9D02C9B4
9D02C534  8FBF0014   LW RA, 20(SP)
80:                     case 0xA003: VRC_VBANK(1, value, 1); break;
9D02C538  A385809D   SB A1, -32611(GP)
9D02C53C  00053100   SLL A2, A1, 4
9D02C540  938280A5   LBU V0, -32603(GP)
9D02C544  24040001   ADDIU A0, ZERO, 1
9D02C548  24050400   ADDIU A1, ZERO, 1024
9D02C54C  0F40B41B   JAL mmc_bankvrom
9D02C550  00C23021   ADDU A2, A2, V0
9D02C554  0B40B26D   J 0x9D02C9B4
9D02C558  8FBF0014   LW RA, 20(SP)
81:                     case 0xB000: VRC_VBANK(2, value, 0); break;
9D02C55C  30A2000F   ANDI V0, A1, 15
9D02C560  A38280A6   SB V0, -32602(GP)
9D02C564  9386809E   LBU A2, -32610(GP)
9D02C568  00063100   SLL A2, A2, 4
9D02C56C  24040001   ADDIU A0, ZERO, 1
9D02C570  24050800   ADDIU A1, ZERO, 2048
9D02C574  0F40B41B   JAL mmc_bankvrom
9D02C578  00C23021   ADDU A2, A2, V0
9D02C57C  0B40B26D   J 0x9D02C9B4
9D02C580  8FBF0014   LW RA, 20(SP)
82:                     case 0xB001: VRC_VBANK(2, value, 1); break;
9D02C584  30A5000F   ANDI A1, A1, 15
9D02C588  A385809E   SB A1, -32610(GP)
9D02C58C  00053100   SLL A2, A1, 4
9D02C590  938280A6   LBU V0, -32602(GP)
9D02C594  24040001   ADDIU A0, ZERO, 1
9D02C598  24050800   ADDIU A1, ZERO, 2048
9D02C59C  0F40B41B   JAL mmc_bankvrom
9D02C5A0  00C23021   ADDU A2, A2, V0
9D02C5A4  0B40B26D   J 0x9D02C9B4
9D02C5A8  8FBF0014   LW RA, 20(SP)
83:                     case 0xB002: VRC_VBANK(3, value, 0); break;
9D02C5AC  30A2000F   ANDI V0, A1, 15
9D02C5B0  A38280A7   SB V0, -32601(GP)
9D02C5B4  9386809F   LBU A2, -32609(GP)
9D02C5B8  00063100   SLL A2, A2, 4
9D02C5BC  24040001   ADDIU A0, ZERO, 1
9D02C5C0  24050C00   ADDIU A1, ZERO, 3072
9D02C5C4  0F40B41B   JAL mmc_bankvrom
9D02C5C8  00C23021   ADDU A2, A2, V0
9D02C5CC  0B40B26D   J 0x9D02C9B4
9D02C5D0  8FBF0014   LW RA, 20(SP)
84:                     case 0xB003: VRC_VBANK(3, value, 1); break;
9D02C5D4  A385809F   SB A1, -32609(GP)
9D02C5D8  00053100   SLL A2, A1, 4
9D02C5DC  938280A7   LBU V0, -32601(GP)
9D02C5E0  24040001   ADDIU A0, ZERO, 1
9D02C5E4  24050C00   ADDIU A1, ZERO, 3072
9D02C5E8  0F40B41B   JAL mmc_bankvrom
9D02C5EC  00C23021   ADDU A2, A2, V0
9D02C5F0  0B40B26D   J 0x9D02C9B4
9D02C5F4  8FBF0014   LW RA, 20(SP)
85:                     case 0xC000: VRC_VBANK(4, value, 0); break;
9D02C5F8  30A2000F   ANDI V0, A1, 15
9D02C5FC  A38280A8   SB V0, -32600(GP)
9D02C600  938680A0   LBU A2, -32608(GP)
9D02C604  00063100   SLL A2, A2, 4
9D02C608  24040001   ADDIU A0, ZERO, 1
9D02C60C  24051000   ADDIU A1, ZERO, 4096
9D02C610  0F40B41B   JAL mmc_bankvrom
9D02C614  00C23021   ADDU A2, A2, V0
9D02C618  0B40B26D   J 0x9D02C9B4
9D02C61C  8FBF0014   LW RA, 20(SP)
86:                     case 0xC001: VRC_VBANK(4, value, 1); break;
9D02C620  30A5000F   ANDI A1, A1, 15
9D02C624  A38580A0   SB A1, -32608(GP)
9D02C628  00053100   SLL A2, A1, 4
9D02C62C  938280A8   LBU V0, -32600(GP)
9D02C630  24040001   ADDIU A0, ZERO, 1
9D02C634  24051000   ADDIU A1, ZERO, 4096
9D02C638  0F40B41B   JAL mmc_bankvrom
9D02C63C  00C23021   ADDU A2, A2, V0
9D02C640  0B40B26D   J 0x9D02C9B4
9D02C644  8FBF0014   LW RA, 20(SP)
87:                     case 0xC002: VRC_VBANK(5, value, 0); break;
9D02C648  A38280A9   SB V0, -32599(GP)
9D02C64C  938680A1   LBU A2, -32607(GP)
9D02C650  00063100   SLL A2, A2, 4
9D02C654  24040001   ADDIU A0, ZERO, 1
9D02C658  24051400   ADDIU A1, ZERO, 5120
9D02C65C  0F40B41B   JAL mmc_bankvrom
9D02C660  00C23021   ADDU A2, A2, V0
9D02C664  0B40B26D   J 0x9D02C9B4
9D02C668  8FBF0014   LW RA, 20(SP)
88:                     case 0xC003: VRC_VBANK(5, value, 1); break;
9D02C66C  30A5000F   ANDI A1, A1, 15
9D02C670  A38580A1   SB A1, -32607(GP)
9D02C674  00053100   SLL A2, A1, 4
9D02C678  938280A9   LBU V0, -32599(GP)
9D02C67C  24040001   ADDIU A0, ZERO, 1
9D02C680  24051400   ADDIU A1, ZERO, 5120
9D02C684  0F40B41B   JAL mmc_bankvrom
9D02C688  00C23021   ADDU A2, A2, V0
9D02C68C  0B40B26D   J 0x9D02C9B4
9D02C690  8FBF0014   LW RA, 20(SP)
89:                     case 0xD000: VRC_VBANK(6, value, 0); break;
9D02C694  A38280AA   SB V0, -32598(GP)
9D02C698  938680A2   LBU A2, -32606(GP)
9D02C69C  00063100   SLL A2, A2, 4
9D02C6A0  24040001   ADDIU A0, ZERO, 1
9D02C6A4  24051800   ADDIU A1, ZERO, 6144
9D02C6A8  0F40B41B   JAL mmc_bankvrom
9D02C6AC  00C23021   ADDU A2, A2, V0
9D02C6B0  0B40B26D   J 0x9D02C9B4
9D02C6B4  8FBF0014   LW RA, 20(SP)
90:                     case 0xD001: VRC_VBANK(6, value, 1); break;
9D02C6B8  30A5000F   ANDI A1, A1, 15
9D02C6BC  A38580A2   SB A1, -32606(GP)
9D02C6C0  00053100   SLL A2, A1, 4
9D02C6C4  938280AA   LBU V0, -32598(GP)
9D02C6C8  24040001   ADDIU A0, ZERO, 1
9D02C6CC  24051800   ADDIU A1, ZERO, 6144
9D02C6D0  0F40B41B   JAL mmc_bankvrom
9D02C6D4  00C23021   ADDU A2, A2, V0
9D02C6D8  0B40B26D   J 0x9D02C9B4
9D02C6DC  8FBF0014   LW RA, 20(SP)
91:                     case 0xD002: VRC_VBANK(7, value, 0); break;
9D02C6E0  30A2000F   ANDI V0, A1, 15
9D02C6E4  A38280AB   SB V0, -32597(GP)
9D02C6E8  938680A3   LBU A2, -32605(GP)
9D02C6EC  00063100   SLL A2, A2, 4
9D02C6F0  24040001   ADDIU A0, ZERO, 1
9D02C6F4  24051C00   ADDIU A1, ZERO, 7168
9D02C6F8  0F40B41B   JAL mmc_bankvrom
9D02C6FC  00C23021   ADDU A2, A2, V0
9D02C700  0B40B26D   J 0x9D02C9B4
9D02C704  8FBF0014   LW RA, 20(SP)
92:                     case 0xD003: VRC_VBANK(7, value, 1); break;
9D02C708  30A5000F   ANDI A1, A1, 15
9D02C70C  A38580A3   SB A1, -32605(GP)
9D02C710  00053100   SLL A2, A1, 4
9D02C714  938280AB   LBU V0, -32597(GP)
9D02C718  24040001   ADDIU A0, ZERO, 1
9D02C71C  24051C00   ADDIU A1, ZERO, 7168
9D02C720  0F40B41B   JAL mmc_bankvrom
9D02C724  00C23021   ADDU A2, A2, V0
9D02C728  0B40B26D   J 0x9D02C9B4
9D02C72C  8FBF0014   LW RA, 20(SP)
93:                     case 0xE000:
94:                        irq.nybbles[0]=value&0x0F;
9D02C730  3C02A001   LUI V0, -24575
9D02C734  2442B8AC   ADDIU V0, V0, -18260
9D02C738  A0450008   SB A1, 8(V0)
95:                        irq.clockticks= (irq.nybbles[0]) | (irq.nybbles[1]<<4) |
9D02C744  90430009   LBU V1, 9(V0)
9D02C748  00031900   SLL V1, V1, 4
9D02C74C  00832025   OR A0, A0, V1
9D02C758  00831825   OR V1, A0, V1
9D02C760  AC45000C   SW A1, 12(V0)
96:                                       (irq.nybbles[2]<<8) | (irq.nybbles[3]<<12);
9D02C73C  9044000A   LBU A0, 10(V0)
9D02C740  00042200   SLL A0, A0, 8
9D02C750  9043000B   LBU V1, 11(V0)
9D02C754  00031B00   SLL V1, V1, 12
9D02C75C  00652825   OR A1, V1, A1
97:                        irq.counter=(uint8)(irq.clockticks/114);
9D02C764  3C028FB8   LUI V0, -28744
9D02C768  244223EF   ADDIU V0, V0, 9199
9D02C76C  00A20018   MULT 0, A1, V0
9D02C770  00001010   MFHI V0
9D02C774  00452821   ADDU A1, V0, A1
9D02C778  7CA53980   EXT A1, A1, 6, 8
9D02C788  3C02A001   LUI V0, -24575
9D02C78C  0B40B26C   J .LVL110
9D02C790  AC45B8AC   SW A1, -18260(V0)
98:                        if(irq.counter>15) irq.counter-=16;
9D02C77C  28A20010   SLTI V0, A1, 16
9D02C780  50400004   BEQL V0, ZERO, 0x9D02C794
9D02C784  24A5FFF0   ADDIU A1, A1, -16
9D02C794  3C02A001   LUI V0, -24575
9D02C798  0B40B26C   J .LVL110
9D02C79C  AC45B8AC   SW A1, -18260(V0)
99:                        break;
100:                    case 0xE001:
101:                       irq.nybbles[1]=value&0x0F;
9D02C7A0  30A5000F   ANDI A1, A1, 15
9D02C7A4  3C02A001   LUI V0, -24575
9D02C7A8  2442B8AC   ADDIU V0, V0, -18260
9D02C7AC  A0450009   SB A1, 9(V0)
102:                       irq.clockticks= (irq.nybbles[0]) | (irq.nybbles[1]<<4) |
9D02C7C0  00832025   OR A0, A0, V1
9D02C7C4  90430008   LBU V1, 8(V0)
9D02C7C8  00831825   OR V1, A0, V1
9D02C7CC  00052900   SLL A1, A1, 4
9D02C7D4  AC43000C   SW V1, 12(V0)
103:                                      (irq.nybbles[2]<<8) | (irq.nybbles[3]<<12);
9D02C7B0  9044000A   LBU A0, 10(V0)
9D02C7B4  00042200   SLL A0, A0, 8
9D02C7B8  9043000B   LBU V1, 11(V0)
9D02C7BC  00031B00   SLL V1, V1, 12
9D02C7D0  00651825   OR V1, V1, A1
104:                       irq.counter=(uint8)(irq.clockticks/114);
9D02C7D8  3C028FB8   LUI V0, -28744
9D02C7DC  244223EF   ADDIU V0, V0, 9199
9D02C7E0  00620018   MULT 0, V1, V0
9D02C7E4  00001010   MFHI V0
9D02C7E8  00431821   ADDU V1, V0, V1
9D02C7EC  7C633980   EXT V1, V1, 6, 8
9D02C7FC  3C02A001   LUI V0, -24575
9D02C800  0B40B26C   J .LVL110
9D02C804  AC43B8AC   SW V1, -18260(V0)
105:                       if(irq.counter>15) irq.counter-=16;
9D02C7F0  28620010   SLTI V0, V1, 16
9D02C7F4  50400004   BEQL V0, ZERO, 0x9D02C808
9D02C7F8  2463FFF0   ADDIU V1, V1, -16
9D02C808  3C02A001   LUI V0, -24575
9D02C80C  0B40B26C   J .LVL110
9D02C810  AC43B8AC   SW V1, -18260(V0)
106:                       break;
107:                    case 0xE002:
108:                       irq.nybbles[2]=value&0x0F;
9D02C814  30A5000F   ANDI A1, A1, 15
9D02C818  3C02A001   LUI V0, -24575
9D02C81C  2442B8AC   ADDIU V0, V0, -18260
9D02C820  A045000A   SB A1, 10(V0)
109:                       irq.clockticks= (irq.nybbles[0]) | (irq.nybbles[1]<<4) |
9D02C824  90440009   LBU A0, 9(V0)
9D02C828  00042100   SLL A0, A0, 4
9D02C834  00832025   OR A0, A0, V1
9D02C838  90430008   LBU V1, 8(V0)
9D02C83C  00831825   OR V1, A0, V1
9D02C848  AC43000C   SW V1, 12(V0)
110:                                      (irq.nybbles[2]<<8) | (irq.nybbles[3]<<12);
9D02C82C  9043000B   LBU V1, 11(V0)
9D02C830  00031B00   SLL V1, V1, 12
9D02C840  00052A00   SLL A1, A1, 8
9D02C844  00651825   OR V1, V1, A1
111:                       irq.counter=(uint8)(irq.clockticks/114);
9D02C84C  3C028FB8   LUI V0, -28744
9D02C850  244223EF   ADDIU V0, V0, 9199
9D02C854  00620018   MULT 0, V1, V0
9D02C858  00001010   MFHI V0
9D02C85C  00431821   ADDU V1, V0, V1
9D02C860  7C633980   EXT V1, V1, 6, 8
9D02C870  3C02A001   LUI V0, -24575
9D02C874  0B40B26C   J .LVL110
9D02C878  AC43B8AC   SW V1, -18260(V0)
112:                       if(irq.counter>15) irq.counter-=16;
9D02C864  28620010   SLTI V0, V1, 16
9D02C868  50400004   BEQL V0, ZERO, 0x9D02C87C
9D02C86C  2463FFF0   ADDIU V1, V1, -16
9D02C87C  3C02A001   LUI V0, -24575
9D02C880  0B40B26C   J .LVL110
9D02C884  AC43B8AC   SW V1, -18260(V0)
113:                       break;
114:                    case 0xE003:
115:                       irq.nybbles[3]=value&0x0F;
9D02C888  30A5000F   ANDI A1, A1, 15
9D02C88C  3C02A001   LUI V0, -24575
9D02C890  2442B8AC   ADDIU V0, V0, -18260
9D02C894  A045000B   SB A1, 11(V0)
116:                       irq.clockticks= (irq.nybbles[0]) | (irq.nybbles[1]<<4) |
9D02C898  90440009   LBU A0, 9(V0)
9D02C89C  00042100   SLL A0, A0, 4
9D02C8A8  00832025   OR A0, A0, V1
9D02C8AC  90430008   LBU V1, 8(V0)
9D02C8B0  00831825   OR V1, A0, V1
9D02C8BC  AC43000C   SW V1, 12(V0)
117:                                      (irq.nybbles[2]<<8) | (irq.nybbles[3]<<12);
9D02C8A0  9043000A   LBU V1, 10(V0)
9D02C8A4  00031A00   SLL V1, V1, 8
9D02C8B4  00052B00   SLL A1, A1, 12
9D02C8B8  00651825   OR V1, V1, A1
118:                       irq.counter=(uint8)(irq.clockticks/114);
9D02C8C0  3C028FB8   LUI V0, -28744
9D02C8C4  244223EF   ADDIU V0, V0, 9199
9D02C8C8  00620018   MULT 0, V1, V0
9D02C8CC  00001010   MFHI V0
9D02C8D0  00431821   ADDU V1, V0, V1
9D02C8D4  7C633980   EXT V1, V1, 6, 8
9D02C8E4  3C02A001   LUI V0, -24575
9D02C8E8  0B40B26C   J .LVL110
9D02C8EC  AC43B8AC   SW V1, -18260(V0)
119:                       if(irq.counter>15) irq.counter-=16;
9D02C8D8  28620010   SLTI V0, V1, 16
9D02C8DC  50400004   BEQL V0, ZERO, 0x9D02C8F0
9D02C8E0  2463FFF0   ADDIU V1, V1, -16
9D02C8F0  3C02A001   LUI V0, -24575
9D02C8F4  0B40B26C   J .LVL110
9D02C8F8  AC43B8AC   SW V1, -18260(V0)
120:                       break;
121:                    case 0xF000:
122:                       if(value&0x01) irq.enabled=true;
9D02C3D0  0B40B23F   J 0x9D02C8FC
9D02C3D4  30A50001   ANDI A1, A1, 1
9D02C8FC  10A0002D   BEQ A1, ZERO, 0x9D02C9B4
9D02C900  8FBF0014   LW RA, 20(SP)
9D02C904  24030001   ADDIU V1, ZERO, 1
9D02C908  3C02A001   LUI V0, -24575
9D02C90C  0B40B26C   J .LVL110
9D02C910  AC43B8B0   SW V1, -18256(V0)
123:                       break;
124:                    case 0xF001: 
125:                       irq.enabled=value&0x01;
9D02C914  30A50001   ANDI A1, A1, 1
9D02C918  3C02A001   LUI V0, -24575
126:                       break;
9D02C91C  0B40B26C   J .LVL110
9D02C920  AC45B8B0   SW A1, -18256(V0)
127:                    case 0xF002: 
128:                       switch(value&0x03)
9D02C924  30A50003   ANDI A1, A1, 3
9D02C928  24020001   ADDIU V0, ZERO, 1
9D02C92C  10A2000F   BEQ A1, V0, 0x9D02C96C
9D02C930  00002021   ADDU A0, ZERO, ZERO
9D02C934  10A00007   BEQ A1, ZERO, 0x9D02C954
9D02C938  24020002   ADDIU V0, ZERO, 2
9D02C93C  10A20011   BEQ A1, V0, 0x9D02C984
9D02C940  24020003   ADDIU V0, ZERO, 3
9D02C944  10A20016   BEQ A1, V0, 0x9D02C9A0
9D02C948  24040001   ADDIU A0, ZERO, 1
129:                       {
130:                       case 0:  ppu_mirror(0, 0, 1, 1); break;
9D02C954  00002821   ADDU A1, ZERO, ZERO
9D02C958  24060001   ADDIU A2, ZERO, 1
9D02C95C  0F40635D   JAL ppu_mirror
9D02C960  24070001   ADDIU A3, ZERO, 1
9D02C964  0B40B26D   J 0x9D02C9B4
9D02C968  8FBF0014   LW RA, 20(SP)
131:                       case 1:  ppu_mirror(0, 1, 0, 1); break;
9D02C96C  24050001   ADDIU A1, ZERO, 1
9D02C970  00003021   ADDU A2, ZERO, ZERO
9D02C974  0F40635D   JAL ppu_mirror
9D02C978  24070001   ADDIU A3, ZERO, 1
9D02C97C  0B40B26D   J 0x9D02C9B4
9D02C980  8FBF0014   LW RA, 20(SP)
132:                       case 2:  ppu_mirror(1,1,1,1);break;
9D02C984  24040001   ADDIU A0, ZERO, 1
9D02C988  24050001   ADDIU A1, ZERO, 1
9D02C98C  24060001   ADDIU A2, ZERO, 1
9D02C990  0F40635D   JAL ppu_mirror
9D02C994  24070001   ADDIU A3, ZERO, 1
9D02C998  0B40B26D   J 0x9D02C9B4
9D02C99C  8FBF0014   LW RA, 20(SP)
133:                       case 3:  ppu_mirror(1,1,1,1);break; // should this be zero?
9D02C9A0  24050001   ADDIU A1, ZERO, 1
9D02C9A4  24060001   ADDIU A2, ZERO, 1
9D02C9A8  0F40635D   JAL ppu_mirror
9D02C9AC  24070001   ADDIU A3, ZERO, 1
134:                       default: break;
135:                       }
136:                       break;
137:                    default:
138:                       break;
139:                    }
140:                 }
9D02C28C  0B40B26D   J 0x9D02C9B4
9D02C290  8FBF0014   LW RA, 20(SP)
9D02C2E0  0B40B26D   J 0x9D02C9B4
9D02C2E4  8FBF0014   LW RA, 20(SP)
9D02C304  0B40B26D   J 0x9D02C9B4
9D02C308  8FBF0014   LW RA, 20(SP)
9D02C350  0B40B26D   J 0x9D02C9B4
9D02C354  8FBF0014   LW RA, 20(SP)
9D02C374  0B40B26D   J 0x9D02C9B4
9D02C378  8FBF0014   LW RA, 20(SP)
9D02C3AC  0B40B26D   J 0x9D02C9B4
9D02C3B0  8FBF0014   LW RA, 20(SP)
9D02C94C  0B40B26D   J 0x9D02C9B4
9D02C950  8FBF0014   LW RA, 20(SP)
9D02C9B0  8FBF0014   LW RA, 20(SP)
9D02C9B4  03E00008   JR RA
9D02C9B8  27BD0018   ADDIU SP, SP, 24
141:                 
142:                 
143:                 static map_memwrite map18_memwrite[] =
144:                 {
145:                    { 0x8000, 0xFFFF, map18_write },
146:                    {     -1,     -1, NULL }
147:                 };
148:                 
149:                 static void map18_getstate(SnssMapperBlock *state)
150:                 {
151:                    state->extraData.mapper18.irqCounterLowByte = irq.counter & 0xFF;
9D02C1E0  3C02A001   LUI V0, -24575
9D02C1E4  8C43B8AC   LW V1, -18260(V0)
9D02C1E8  A0830018   SB V1, 24(A0)
152:                    state->extraData.mapper18.irqCounterHighByte = irq.counter >> 8;
9D02C1EC  00031A03   SRA V1, V1, 8
9D02C1F0  A0830019   SB V1, 25(A0)
153:                    state->extraData.mapper18.irqCounterEnabled = irq.enabled;
9D02C1F4  2442B8AC   ADDIU V0, V0, -18260
9D02C1F8  8C420004   LW V0, 4(V0)
9D02C1FC  03E00008   JR RA
9D02C200  A082001A   SB V0, 26(A0)
154:                 }
155:                 
156:                 static void map18_setstate(SnssMapperBlock *state)
157:                 {
158:                    irq.counter = (state->extraData.mapper18.irqCounterHighByte << 8)
9D02C204  3C02A001   LUI V0, -24575
9D02C208  90830019   LBU V1, 25(A0)
9D02C20C  00031A00   SLL V1, V1, 8
9D02C218  AC43B8AC   SW V1, -18260(V0)
159:                                        | state->extraData.mapper18.irqCounterLowByte;
9D02C210  90850018   LBU A1, 24(A0)
9D02C214  00651825   OR V1, V1, A1
160:                    irq.enabled = state->extraData.mapper18.irqCounterEnabled;
9D02C21C  2442B8AC   ADDIU V0, V0, -18260
9D02C220  9083001A   LBU V1, 26(A0)
9D02C224  03E00008   JR RA
9D02C228  AC430004   SW V1, 4(V0)
161:                 }
162:                 
163:                 mapintf_t map18_intf =
164:                 {
165:                    18, /* mapper number */
166:                    "Jaleco SS8806", /* mapper name */
167:                    map18_init, /* init routine */
168:                    NULL, /* vblank callback */
169:                    NULL, /* hblank callback */
170:                    map18_getstate, /* get state (snss) */
171:                    map18_setstate, /* set state (snss) */
172:                    NULL, /* memory read structure */
173:                    map18_memwrite, /* memory write structure */
174:                    NULL /* external sound device */
175:                 };
176:                 
177:                 /*
178:                 ** $Log: map018.c,v $
179:                 ** Revision 1.2  2001/04/27 14:37:11  neil
180:                 ** wheeee
181:                 **
182:                 ** Revision 1.1  2001/04/27 12:54:40  neil
183:                 ** blah
184:                 **
185:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
186:                 ** initial
187:                 **
188:                 ** Revision 1.1  2000/10/24 12:19:33  matt
189:                 ** changed directory structure
190:                 **
191:                 ** Revision 1.8  2000/10/22 19:17:46  matt
192:                 ** mapper cleanups galore
193:                 **
194:                 ** Revision 1.7  2000/10/22 15:03:13  matt
195:                 ** simplified mirroring
196:                 **
197:                 ** Revision 1.6  2000/10/21 19:33:38  matt
198:                 ** many more cleanups
199:                 **
200:                 ** Revision 1.5  2000/10/10 13:58:17  matt
201:                 ** stroustrup squeezing his way in the door
202:                 **
203:                 ** Revision 1.4  2000/07/15 23:52:19  matt
204:                 ** rounded out a bunch more mapper interfaces
205:                 **
206:                 ** Revision 1.3  2000/07/10 05:29:03  matt
207:                 ** cleaned up some mirroring issues
208:                 **
209:                 ** Revision 1.2  2000/07/06 02:48:42  matt
210:                 ** clearly labelled structure members
211:                 **
212:                 ** Revision 1.1  2000/07/06 01:01:56  matt
213:                 ** initial revision
214:                 **
215:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map016.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map16.c
21:                  **
22:                  ** mapper 16 interface
23:                  ** $Id: map016.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes_ppu.h>
29:                  #include <nes.h>
30:                  
31:                  static struct
32:                  {
33:                     int counter;
34:                     bool enabled;
35:                  } irq;
36:                  
37:                  /* mapper 16: Bandai */
38:                  
39:                  static void map16_init(void)
40:                  {
9D035A9C  27BDFFE8   ADDIU SP, SP, -24
9D035AA0  AFBF0014   SW RA, 20(SP)
41:                     mmc_bankrom(16, 0x8000, 0);
9D035AA4  24040010   ADDIU A0, ZERO, 16
9D035AA8  34058000   ORI A1, ZERO, -32768
9D035AAC  0F40B479   JAL mmc_bankrom
9D035AB0  00003021   ADDU A2, ZERO, ZERO
42:                     mmc_bankrom(16, 0xC000, MMC_LASTBANK);
9D035AB4  24040010   ADDIU A0, ZERO, 16
9D035AB8  3405C000   ORI A1, ZERO, -16384
9D035ABC  0F40B479   JAL mmc_bankrom
9D035AC0  2406FFFF   ADDIU A2, ZERO, -1
43:                     irq.counter = 0;
9D035AC4  AF8080AC   SW ZERO, -32596(GP)
44:                     irq.enabled = false;
9D035AC8  AF8080B0   SW ZERO, -32592(GP)
45:                  }
9D035ACC  8FBF0014   LW RA, 20(SP)
9D035AD0  03E00008   JR RA
9D035AD4  27BD0018   ADDIU SP, SP, 24
46:                  
47:                  static void map16_write(uint32 address, uint8 value)
48:                  {
9D035AD8  27BDFFE8   ADDIU SP, SP, -24
9D035ADC  00A03021   ADDU A2, A1, ZERO
49:                     int reg = address & 0xF;
9D035AE0  3085000F   ANDI A1, A0, 15
50:                  
51:                     if (reg < 8)
9D035AE4  28A30008   SLTI V1, A1, 8
9D035AE8  10600006   BEQ V1, ZERO, 0x9D035B04
9D035AEC  AFBF0014   SW RA, 20(SP)
52:                     {
53:                        mmc_bankvrom(1, reg << 10, value);
9D035AF0  24040001   ADDIU A0, ZERO, 1
9D035AF4  0F40B41B   JAL mmc_bankvrom
9D035AF8  00052A80   SLL A1, A1, 10
9D035AFC  0B40D709   J 0x9D035C24
9D035B00  8FBF0014   LW RA, 20(SP)
54:                     }
55:                     else
56:                     {
57:                        switch (address & 0x000F)
9D035B04  3084000F   ANDI A0, A0, 15
9D035B08  2484FFF8   ADDIU A0, A0, -8
9D035B0C  2C820005   SLTIU V0, A0, 5
9D035B10  10400043   BEQ V0, ZERO, 0x9D035C20
9D035B14  00042080   SLL A0, A0, 2
9D035B18  3C029D03   LUI V0, -25341
9D035B1C  24425B30   ADDIU V0, V0, 23344
9D035B20  00442021   ADDU A0, V0, A0
9D035B24  8C820000   LW V0, 0(A0)
9D035B28  00400008   JR V0
9D035B2C  00000000   NOP
58:                        {
59:                        case 0x8:
60:                           mmc_bankrom(16, 0x8000, value);
9D035B44  24040010   ADDIU A0, ZERO, 16
9D035B48  0F40B479   JAL mmc_bankrom
9D035B4C  34058000   ORI A1, ZERO, -32768
61:                           break;
9D035B50  0B40D709   J 0x9D035C24
9D035B54  8FBF0014   LW RA, 20(SP)
62:                  
63:                        case 0x9:
64:                           switch (value & 3)
9D035B58  30C60003   ANDI A2, A2, 3
9D035B5C  24020001   ADDIU V0, ZERO, 1
9D035B60  10C2000F   BEQ A2, V0, 0x9D035BA0
9D035B64  00002021   ADDU A0, ZERO, ZERO
9D035B68  10C00007   BEQ A2, ZERO, 0x9D035B88
9D035B6C  24020002   ADDIU V0, ZERO, 2
9D035B70  10C20011   BEQ A2, V0, 0x9D035BB8
9D035B74  24020003   ADDIU V0, ZERO, 3
9D035B78  10C20015   BEQ A2, V0, 0x9D035BD0
9D035B7C  24040001   ADDIU A0, ZERO, 1
65:                           {
66:                           case 0:
67:                              ppu_mirror(0, 0, 1, 1); /* horizontal */
9D035B88  00002821   ADDU A1, ZERO, ZERO
9D035B8C  24060001   ADDIU A2, ZERO, 1
9D035B90  0F40635D   JAL ppu_mirror
9D035B94  24070001   ADDIU A3, ZERO, 1
68:                              break;
9D035B98  0B40D709   J 0x9D035C24
9D035B9C  8FBF0014   LW RA, 20(SP)
69:                        
70:                           case 1:
71:                              ppu_mirror(0, 1, 0, 1); /* vertical */
9D035BA0  24050001   ADDIU A1, ZERO, 1
9D035BA4  00003021   ADDU A2, ZERO, ZERO
9D035BA8  0F40635D   JAL ppu_mirror
9D035BAC  24070001   ADDIU A3, ZERO, 1
72:                              break;
9D035BB0  0B40D709   J 0x9D035C24
9D035BB4  8FBF0014   LW RA, 20(SP)
73:                        
74:                           case 2:
75:                              ppu_mirror(0, 0, 0, 0);
9D035BB8  00002821   ADDU A1, ZERO, ZERO
9D035BBC  00003021   ADDU A2, ZERO, ZERO
9D035BC0  0F40635D   JAL ppu_mirror
9D035BC4  00003821   ADDU A3, ZERO, ZERO
76:                              break;
9D035BC8  0B40D709   J 0x9D035C24
9D035BCC  8FBF0014   LW RA, 20(SP)
77:                        
78:                           case 3:
79:                              ppu_mirror(1, 1, 1, 1);
9D035BD0  24050001   ADDIU A1, ZERO, 1
9D035BD4  24060001   ADDIU A2, ZERO, 1
9D035BD8  0F40635D   JAL ppu_mirror
9D035BDC  24070001   ADDIU A3, ZERO, 1
80:                              break;
9D035BE0  0B40D709   J 0x9D035C24
9D035BE4  8FBF0014   LW RA, 20(SP)
81:                           }
82:                           break;
83:                     
84:                        case 0xA:
85:                           irq.enabled = (value & 1) ? true : false;
9D035BE8  30C60001   ANDI A2, A2, 1
86:                           break;
9D035BEC  0B40D708   J 0x9D035C20
9D035BF0  AF8680B0   SW A2, -32592(GP)
87:                   
88:                        case 0xB:
89:                           irq.counter = (irq.counter & 0xFF00) | value;
9D035BF4  278280AC   ADDIU V0, GP, -32596
9D035BF8  8C430000   LW V1, 0(V0)
9D035BFC  3063FF00   ANDI V1, V1, -256
9D035C00  00C33025   OR A2, A2, V1
90:                           break;
9D035C04  0B40D708   J 0x9D035C20
9D035C08  AC460000   SW A2, 0(V0)
91:                     
92:                        case 0xC:
93:                           irq.counter = (value << 8) | (irq.counter & 0xFF);
9D035C0C  278280AC   ADDIU V0, GP, -32596
9D035C10  00063200   SLL A2, A2, 8
9D035C14  90430000   LBU V1, 0(V0)
9D035C18  00C33025   OR A2, A2, V1
9D035C1C  AC460000   SW A2, 0(V0)
94:                           break;
95:                     
96:                        case 0xD:
97:                           /* eeprom I/O port? */
98:                           break;
99:                        }
100:                    }
101:                 }
9D035B80  0B40D709   J 0x9D035C24
9D035B84  8FBF0014   LW RA, 20(SP)
9D035C20  8FBF0014   LW RA, 20(SP)
9D035C24  03E00008   JR RA
9D035C28  27BD0018   ADDIU SP, SP, 24
102:                 
103:                 static void map16_hblank(int vblank)
104:                 {
9D035C2C  27BDFFE8   ADDIU SP, SP, -24
9D035C30  AFBF0014   SW RA, 20(SP)
105:                    UNUSED(vblank);
106:                 
107:                    if (irq.enabled)
9D035C34  8F8280B0   LW V0, -32592(GP)
9D035C38  10400007   BEQ V0, ZERO, .LVL27
9D035C3C  8F8280AC   LW V0, -32596(GP)
108:                    {
109:                       if (irq.counter)
9D035C40  10400005   BEQ V0, ZERO, .LVL27
9D035C44  2442FFFF   ADDIU V0, V0, -1
110:                       {
111:                          if (0 == --irq.counter)
9D035C48  14400003   BNE V0, ZERO, .LVL27
9D035C4C  AF8280AC   SW V0, -32596(GP)
112:                             nes_irq();
9D035C50  0F408C7B   JAL nes_irq
9D035C54  00000000   NOP
113:                       }
114:                    }
115:                 }
9D035C58  8FBF0014   LW RA, 20(SP)
9D035C5C  03E00008   JR RA
9D035C60  27BD0018   ADDIU SP, SP, 24
116:                 
117:                 static void map16_getstate(SnssMapperBlock *state)
118:                 {
119:                    state->extraData.mapper16.irqCounterLowByte = irq.counter & 0xFF;
9D035A60  8F8280AC   LW V0, -32596(GP)
9D035A64  A0820018   SB V0, 24(A0)
120:                    state->extraData.mapper16.irqCounterHighByte = irq.counter >> 8;
9D035A68  00021203   SRA V0, V0, 8
9D035A6C  A0820019   SB V0, 25(A0)
121:                    state->extraData.mapper16.irqCounterEnabled = irq.enabled;
9D035A70  8F8280B0   LW V0, -32592(GP)
9D035A74  03E00008   JR RA
9D035A78  A082001A   SB V0, 26(A0)
122:                 }
123:                 
124:                 static void map16_setstate(SnssMapperBlock *state)
125:                 {
126:                    irq.counter = (state->extraData.mapper16.irqCounterHighByte << 8)
9D035A7C  90820019   LBU V0, 25(A0)
9D035A80  00021200   SLL V0, V0, 8
9D035A8C  AF8280AC   SW V0, -32596(GP)
127:                                        | state->extraData.mapper16.irqCounterLowByte;
9D035A84  90830018   LBU V1, 24(A0)
9D035A88  00431025   OR V0, V0, V1
128:                    irq.enabled = state->extraData.mapper16.irqCounterEnabled;
9D035A90  9082001A   LBU V0, 26(A0)
9D035A94  03E00008   JR RA
9D035A98  AF8280B0   SW V0, -32592(GP)
129:                 }
130:                 
131:                 static map_memwrite map16_memwrite[] =
132:                 {
133:                    { 0x6000, 0x600D, map16_write },
134:                    { 0x7FF0, 0x7FFD, map16_write },
135:                    { 0x8000, 0x800D, map16_write },
136:                    {     -1,     -1, NULL }
137:                 };
138:                 
139:                 mapintf_t map16_intf = 
140:                 {
141:                    16, /* mapper number */
142:                    "Bandai", /* mapper name */
143:                    map16_init, /* init routine */
144:                    NULL, /* vblank callback */
145:                    map16_hblank, /* hblank callback */
146:                    map16_getstate, /* get state (snss) */
147:                    map16_setstate, /* set state (snss) */
148:                    NULL, /* memory read structure */
149:                    map16_memwrite, /* memory write structure */
150:                    NULL /* external sound device */
151:                 };
152:                 
153:                 /*
154:                 ** $Log: map016.c,v $
155:                 ** Revision 1.2  2001/04/27 14:37:11  neil
156:                 ** wheeee
157:                 **
158:                 ** Revision 1.1  2001/04/27 12:54:40  neil
159:                 ** blah
160:                 **
161:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
162:                 ** initial
163:                 **
164:                 ** Revision 1.1  2000/10/24 12:19:33  matt
165:                 ** changed directory structure
166:                 **
167:                 ** Revision 1.8  2000/10/22 19:17:46  matt
168:                 ** mapper cleanups galore
169:                 **
170:                 ** Revision 1.7  2000/10/22 15:03:13  matt
171:                 ** simplified mirroring
172:                 **
173:                 ** Revision 1.6  2000/10/21 19:33:38  matt
174:                 ** many more cleanups
175:                 **
176:                 ** Revision 1.5  2000/10/10 13:58:16  matt
177:                 ** stroustrup squeezing his way in the door
178:                 **
179:                 ** Revision 1.4  2000/08/16 02:50:11  matt
180:                 ** random mapper cleanups
181:                 **
182:                 ** Revision 1.3  2000/07/15 23:52:20  matt
183:                 ** rounded out a bunch more mapper interfaces
184:                 **
185:                 ** Revision 1.2  2000/07/11 05:03:49  matt
186:                 ** value masking isn't necessary for the banking routines
187:                 **
188:                 ** Revision 1.1  2000/07/11 03:14:18  melanson
189:                 ** Initial commit for mappers 16, 34, and 231
190:                 **
191:                 **
192:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map015.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map15.c
21:                  **
22:                  ** mapper 15 interface
23:                  ** $Id: map015.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes_ppu.h>
29:                  
30:                  /* mapper 15: Contra 100-in-1 */
31:                  static void map15_write(uint32 address, uint8 value)
32:                  {
9D034B48  27BDFFD8   ADDIU SP, SP, -40
9D034B4C  AFBF0024   SW RA, 36(SP)
9D034B50  AFB40020   SW S4, 32(SP)
9D034B54  AFB3001C   SW S3, 28(SP)
9D034B58  AFB20018   SW S2, 24(SP)
9D034B5C  AFB10014   SW S1, 20(SP)
9D034B60  AFB00010   SW S0, 16(SP)
9D034B64  00A08021   ADDU S0, A1, ZERO
33:                     int bank = value & 0x3F;
9D034B68  30B2003F   ANDI S2, A1, 63
34:                     uint8 swap = (value & 0x80) >> 7;
35:                  
36:                     switch (address & 0x3)
9D034B6C  30840003   ANDI A0, A0, 3
9D034B70  24020001   ADDIU V0, ZERO, 1
9D034B74  1082002D   BEQ A0, V0, 0x9D034C2C
9D034B78  000589C2   SRL S1, A1, 7
9D034B7C  10800007   BEQ A0, ZERO, 0x9D034B9C
9D034B80  24020002   ADDIU V0, ZERO, 2
9D034B84  10820035   BEQ A0, V0, 0x9D034C5C
9D034B88  24020003   ADDIU V0, ZERO, 3
9D034B8C  1082005A   BEQ A0, V0, 0x9D034CF8
9D034B90  00129040   SLL S2, S2, 1
37:                     {
38:                     case 0:
39:                        mmc_bankrom(8, 0x8000, (bank << 1) + swap);
9D034B9C  0012A040   SLL S4, S2, 1
9D034BA0  24040008   ADDIU A0, ZERO, 8
9D034BA4  34058000   ORI A1, ZERO, -32768
9D034BA8  0F40B479   JAL mmc_bankrom
9D034BAC  02913021   ADDU A2, S4, S1
40:                        mmc_bankrom(8, 0xA000, (bank << 1) + (swap ^ 1));
9D034BB0  3A330001   XORI S3, S1, 1
9D034BB4  24040008   ADDIU A0, ZERO, 8
9D034BB8  3405A000   ORI A1, ZERO, -24576
9D034BBC  0F40B479   JAL mmc_bankrom
9D034BC0  02933021   ADDU A2, S4, S3
41:                        mmc_bankrom(8, 0xC000, ((bank + 1) << 1) + swap);
9D034BC4  26520001   ADDIU S2, S2, 1
9D034BC8  00129040   SLL S2, S2, 1
9D034BCC  24040008   ADDIU A0, ZERO, 8
9D034BD0  3405C000   ORI A1, ZERO, -16384
9D034BD4  0F40B479   JAL mmc_bankrom
9D034BD8  02323021   ADDU A2, S1, S2
42:                        mmc_bankrom(8, 0xE000, ((bank + 1) << 1) + (swap ^ 1));
9D034BDC  24040008   ADDIU A0, ZERO, 8
9D034BE0  3405E000   ORI A1, ZERO, -8192
9D034BE4  0F40B479   JAL mmc_bankrom
9D034BE8  02723021   ADDU A2, S3, S2
43:                  
44:                        if (value & 0x40)
9D034BEC  32100040   ANDI S0, S0, 64
9D034BF0  321000FF   ANDI S0, S0, 255
9D034BF4  12000007   BEQ S0, ZERO, 0x9D034C14
9D034BF8  00002021   ADDU A0, ZERO, ZERO
45:                           ppu_mirror(0, 0, 1, 1); /* horizontal */
9D034BFC  00002821   ADDU A1, ZERO, ZERO
9D034C00  24060001   ADDIU A2, ZERO, 1
9D034C04  0F40635D   JAL ppu_mirror
9D034C08  24070001   ADDIU A3, ZERO, 1
9D034C0C  0B40D356   J 0x9D034D58
9D034C10  8FBF0024   LW RA, 36(SP)
46:                        else
47:                           ppu_mirror(0, 1, 0, 1); /* vertical */
9D034C14  24050001   ADDIU A1, ZERO, 1
9D034C18  00003021   ADDU A2, ZERO, ZERO
9D034C1C  0F40635D   JAL ppu_mirror
9D034C20  24070001   ADDIU A3, ZERO, 1
48:                        break;
49:                  
50:                     case 1:
51:                        mmc_bankrom(8, 0xC000, (bank << 1) + swap);
9D034C2C  00129040   SLL S2, S2, 1
9D034C30  24040008   ADDIU A0, ZERO, 8
9D034C34  3405C000   ORI A1, ZERO, -16384
9D034C38  0F40B479   JAL mmc_bankrom
9D034C3C  02513021   ADDU A2, S2, S1
52:                        mmc_bankrom(8, 0xE000, (bank << 1) + (swap ^ 1));
9D034C40  3A260001   XORI A2, S1, 1
9D034C44  24040008   ADDIU A0, ZERO, 8
9D034C48  3405E000   ORI A1, ZERO, -8192
9D034C4C  0F40B479   JAL mmc_bankrom
9D034C50  02463021   ADDU A2, S2, A2
53:                        break;
9D034C54  0B40D356   J 0x9D034D58
9D034C58  8FBF0024   LW RA, 36(SP)
54:                  
55:                     case 2:
56:                        if (swap)
9D034C5C  12200014   BEQ S1, ZERO, 0x9D034CB0
9D034C60  00129040   SLL S2, S2, 1
57:                        {
58:                           mmc_bankrom(8, 0x8000, (bank << 1) + 1);
9D034C64  26520001   ADDIU S2, S2, 1
9D034C68  24040008   ADDIU A0, ZERO, 8
9D034C6C  34058000   ORI A1, ZERO, -32768
9D034C70  0F40B479   JAL mmc_bankrom
9D034C74  02403021   ADDU A2, S2, ZERO
59:                           mmc_bankrom(8, 0xA000, (bank << 1) + 1);
9D034C78  24040008   ADDIU A0, ZERO, 8
9D034C7C  3405A000   ORI A1, ZERO, -24576
9D034C80  0F40B479   JAL mmc_bankrom
9D034C84  02403021   ADDU A2, S2, ZERO
60:                           mmc_bankrom(8, 0xC000, (bank << 1) + 1);
9D034C88  24040008   ADDIU A0, ZERO, 8
9D034C8C  3405C000   ORI A1, ZERO, -16384
9D034C90  0F40B479   JAL mmc_bankrom
9D034C94  02403021   ADDU A2, S2, ZERO
61:                           mmc_bankrom(8, 0xE000, (bank << 1) + 1);
9D034C98  24040008   ADDIU A0, ZERO, 8
9D034C9C  3405E000   ORI A1, ZERO, -8192
9D034CA0  0F40B479   JAL mmc_bankrom
9D034CA4  02403021   ADDU A2, S2, ZERO
9D034CA8  0B40D356   J 0x9D034D58
9D034CAC  8FBF0024   LW RA, 36(SP)
62:                        }
63:                        else
64:                        {
65:                           mmc_bankrom(8, 0x8000, (bank << 1));
9D034CB0  24040008   ADDIU A0, ZERO, 8
9D034CB4  34058000   ORI A1, ZERO, -32768
9D034CB8  0F40B479   JAL mmc_bankrom
9D034CBC  02403021   ADDU A2, S2, ZERO
66:                           mmc_bankrom(8, 0xA000, (bank << 1));
9D034CC0  24040008   ADDIU A0, ZERO, 8
9D034CC4  3405A000   ORI A1, ZERO, -24576
9D034CC8  0F40B479   JAL mmc_bankrom
9D034CCC  02403021   ADDU A2, S2, ZERO
67:                           mmc_bankrom(8, 0xC000, (bank << 1));
9D034CD0  24040008   ADDIU A0, ZERO, 8
9D034CD4  3405C000   ORI A1, ZERO, -16384
9D034CD8  0F40B479   JAL mmc_bankrom
9D034CDC  02403021   ADDU A2, S2, ZERO
68:                           mmc_bankrom(8, 0xE000, (bank << 1));
9D034CE0  24040008   ADDIU A0, ZERO, 8
9D034CE4  3405E000   ORI A1, ZERO, -8192
9D034CE8  0F40B479   JAL mmc_bankrom
9D034CEC  02403021   ADDU A2, S2, ZERO
69:                        }
70:                        break;
71:                  
72:                     case 3:
73:                        mmc_bankrom(8, 0xC000, (bank << 1) + swap);
9D034CF8  24040008   ADDIU A0, ZERO, 8
9D034CFC  3405C000   ORI A1, ZERO, -16384
9D034D00  0F40B479   JAL mmc_bankrom
9D034D04  02513021   ADDU A2, S2, S1
74:                        mmc_bankrom(8, 0xE000, (bank << 1) + (swap ^ 1));
9D034D08  3A260001   XORI A2, S1, 1
9D034D0C  24040008   ADDIU A0, ZERO, 8
9D034D10  3405E000   ORI A1, ZERO, -8192
9D034D14  0F40B479   JAL mmc_bankrom
9D034D18  02463021   ADDU A2, S2, A2
75:                  
76:                        if (value & 0x40)
9D034D1C  32100040   ANDI S0, S0, 64
9D034D20  321000FF   ANDI S0, S0, 255
9D034D24  12000007   BEQ S0, ZERO, 0x9D034D44
9D034D28  00002021   ADDU A0, ZERO, ZERO
77:                           ppu_mirror(0, 0, 1, 1); /* horizontal */
9D034D2C  00002821   ADDU A1, ZERO, ZERO
9D034D30  24060001   ADDIU A2, ZERO, 1
9D034D34  0F40635D   JAL ppu_mirror
9D034D38  24070001   ADDIU A3, ZERO, 1
9D034D3C  0B40D356   J 0x9D034D58
9D034D40  8FBF0024   LW RA, 36(SP)
78:                        else
79:                           ppu_mirror(0, 1, 0, 1); /* vertical */
9D034D44  24050001   ADDIU A1, ZERO, 1
9D034D48  00003021   ADDU A2, ZERO, ZERO
9D034D4C  0F40635D   JAL ppu_mirror
9D034D50  24070001   ADDIU A3, ZERO, 1
80:                        break;
81:                  
82:                     default:
83:                        break;
84:                     }
85:                  }
9D034B94  0B40D356   J 0x9D034D58
9D034B98  8FBF0024   LW RA, 36(SP)
9D034C24  0B40D356   J 0x9D034D58
9D034C28  8FBF0024   LW RA, 36(SP)
9D034CF0  0B40D356   J 0x9D034D58
9D034CF4  8FBF0024   LW RA, 36(SP)
9D034D54  8FBF0024   LW RA, 36(SP)
9D034D58  8FB40020   LW S4, 32(SP)
9D034D5C  8FB3001C   LW S3, 28(SP)
9D034D60  8FB20018   LW S2, 24(SP)
9D034D64  8FB10014   LW S1, 20(SP)
9D034D68  8FB00010   LW S0, 16(SP)
9D034D6C  03E00008   JR RA
9D034D70  27BD0028   ADDIU SP, SP, 40
86:                  
87:                  static void map15_init(void)
88:                  {
9D034B24  27BDFFE8   ADDIU SP, SP, -24
9D034B28  AFBF0014   SW RA, 20(SP)
89:                     mmc_bankrom(32, 0x8000, 0);
9D034B2C  24040020   ADDIU A0, ZERO, 32
9D034B30  34058000   ORI A1, ZERO, -32768
9D034B34  0F40B479   JAL mmc_bankrom
9D034B38  00003021   ADDU A2, ZERO, ZERO
90:                  }
9D034B3C  8FBF0014   LW RA, 20(SP)
9D034B40  03E00008   JR RA
9D034B44  27BD0018   ADDIU SP, SP, 24
91:                  
92:                  static map_memwrite map15_memwrite[] =
93:                  {
94:                     { 0x8000, 0xFFFF, map15_write },
95:                     {     -1,     -1, NULL }
96:                  };
97:                  
98:                  mapintf_t map15_intf =
99:                  {
100:                    15, /* mapper number */
101:                    "Contra 100-in-1", /* mapper name */
102:                    map15_init, /* init routine */
103:                    NULL, /* vblank callback */
104:                    NULL, /* hblank callback */
105:                    NULL, /* get state (snss) */
106:                    NULL, /* set state (snss) */
107:                    NULL, /* memory read structure */
108:                    map15_memwrite, /* memory write structure */
109:                    NULL /* external sound device */
110:                 };
111:                 
112:                 /*
113:                 ** $Log: map015.c,v $
114:                 ** Revision 1.2  2001/04/27 14:37:11  neil
115:                 ** wheeee
116:                 **
117:                 ** Revision 1.1  2001/04/27 12:54:40  neil
118:                 ** blah
119:                 **
120:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
121:                 ** initial
122:                 **
123:                 ** Revision 1.1  2000/10/24 12:19:33  matt
124:                 ** changed directory structure
125:                 **
126:                 ** Revision 1.6  2000/10/22 19:17:46  matt
127:                 ** mapper cleanups galore
128:                 **
129:                 ** Revision 1.5  2000/10/22 15:03:13  matt
130:                 ** simplified mirroring
131:                 **
132:                 ** Revision 1.4  2000/10/21 19:33:38  matt
133:                 ** many more cleanups
134:                 **
135:                 ** Revision 1.3  2000/07/10 05:29:03  matt
136:                 ** cleaned up some mirroring issues
137:                 **
138:                 ** Revision 1.2  2000/07/06 02:48:43  matt
139:                 ** clearly labelled structure members
140:                 **
141:                 ** Revision 1.1  2000/07/05 05:05:18  matt
142:                 ** initial revision
143:                 **
144:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map011.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map11.c
21:                  **
22:                  ** mapper 11 interface
23:                  ** $Id: map011.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  
29:                  /* mapper 11: Color Dreams, Wisdom Tree */
30:                  static void map11_write(uint32 address, uint8 value)
31:                  {
9D03B5C8  27BDFFE8   ADDIU SP, SP, -24
9D03B5CC  AFBF0014   SW RA, 20(SP)
9D03B5D0  AFB00010   SW S0, 16(SP)
9D03B5D4  00A08021   ADDU S0, A1, ZERO
32:                     UNUSED(address);
33:                  
34:                     mmc_bankrom(32, 0x8000, value & 0x0F);
9D03B5D8  24040020   ADDIU A0, ZERO, 32
9D03B5DC  34058000   ORI A1, ZERO, -32768
9D03B5E0  0F40B479   JAL mmc_bankrom
9D03B5E4  3206000F   ANDI A2, S0, 15
35:                     mmc_bankvrom(8, 0x0000, value >> 4);
9D03B5E8  24040008   ADDIU A0, ZERO, 8
9D03B5EC  00002821   ADDU A1, ZERO, ZERO
9D03B5F0  0F40B41B   JAL mmc_bankvrom
9D03B5F4  00103102   SRL A2, S0, 4
36:                  }
9D03B5F8  8FBF0014   LW RA, 20(SP)
9D03B5FC  8FB00010   LW S0, 16(SP)
9D03B600  03E00008   JR RA
9D03B604  27BD0018   ADDIU SP, SP, 24
37:                  
38:                  static void map11_init(void)
39:                  {
9D03B608  27BDFFE8   ADDIU SP, SP, -24
9D03B60C  AFBF0014   SW RA, 20(SP)
40:                     mmc_bankrom(32, 0x8000, 0);
9D03B610  24040020   ADDIU A0, ZERO, 32
9D03B614  34058000   ORI A1, ZERO, -32768
9D03B618  0F40B479   JAL mmc_bankrom
9D03B61C  00003021   ADDU A2, ZERO, ZERO
41:                     mmc_bankvrom(8, 0x0000, 0);
9D03B620  24040008   ADDIU A0, ZERO, 8
9D03B624  00002821   ADDU A1, ZERO, ZERO
9D03B628  0F40B41B   JAL mmc_bankvrom
9D03B62C  00003021   ADDU A2, ZERO, ZERO
42:                  }
9D03B630  8FBF0014   LW RA, 20(SP)
9D03B634  03E00008   JR RA
9D03B638  27BD0018   ADDIU SP, SP, 24
43:                  
44:                  static map_memwrite map11_memwrite[] =
45:                  {
46:                     { 0x8000, 0xFFFF, map11_write },
47:                     {     -1,     -1, NULL }
48:                  };
49:                  
50:                  mapintf_t map11_intf =
51:                  {
52:                     11, /* mapper number */
53:                     "Color Dreams", /* mapper name */
54:                     map11_init, /* init routine */
55:                     NULL, /* vblank callback */
56:                     NULL, /* hblank callback */
57:                     NULL, /* get state (snss) */
58:                     NULL, /* set state (snss) */
59:                     NULL, /* memory read structure */
60:                     map11_memwrite, /* memory write structure */
61:                     NULL /* external sound device */
62:                  };
63:                  
64:                  /*
65:                  ** $Log: map011.c,v $
66:                  ** Revision 1.2  2001/04/27 14:37:11  neil
67:                  ** wheeee
68:                  **
69:                  ** Revision 1.1  2001/04/27 12:54:40  neil
70:                  ** blah
71:                  **
72:                  ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
73:                  ** initial
74:                  **
75:                  ** Revision 1.1  2000/10/24 12:19:33  matt
76:                  ** changed directory structure
77:                  **
78:                  ** Revision 1.5  2000/10/22 19:17:46  matt
79:                  ** mapper cleanups galore
80:                  **
81:                  ** Revision 1.4  2000/10/21 19:33:38  matt
82:                  ** many more cleanups
83:                  **
84:                  ** Revision 1.3  2000/08/16 02:50:11  matt
85:                  ** random mapper cleanups
86:                  **
87:                  ** Revision 1.2  2000/07/06 02:48:43  matt
88:                  ** clearly labelled structure members
89:                  **
90:                  ** Revision 1.1  2000/07/04 23:11:45  matt
91:                  ** initial revision
92:                  **
93:                  */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map009.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map9.c
21:                  **
22:                  ** mapper 9 interface
23:                  ** $Id: map009.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <string.h>
27:                  #include <noftypes.h>
28:                  #include <nes_mmc.h>
29:                  #include <nes_ppu.h>
30:                  #include <libsnss.h>
31:                  
32:                  static uint8 latch[2];
33:                  static uint8 regs[4];
34:                  
35:                  /* Used when tile $FD/$FE is accessed */
36:                  static void mmc9_latchfunc(uint32 address, uint8 value)
37:                  {
9D0334CC  27BDFFE8   ADDIU SP, SP, -24
9D0334D0  AFBF0014   SW RA, 20(SP)
38:                     if (0xFD == value || 0xFE == value)
9D0334B8  24A20003   ADDIU V0, A1, 3
9D0334BC  304200FF   ANDI V0, V0, 255
9D0334C0  2C420002   SLTIU V0, V0, 2
9D0334C4  10400012   BEQ V0, ZERO, 0x9D033510
9D0334C8  00000000   NOP
39:                     {
40:                        int reg;
41:                  
42:                        if (address)
9D0334D4  10800004   BEQ A0, ZERO, 0x9D0334E8
9D0334D8  00801821   ADDU V1, A0, ZERO
43:                        {
44:                           latch[1] = value;
9D0334DC  A3858089   SB A1, -32631(GP)
9D0334E0  0B40CD3C   J 0x9D0334F0
9D0334E4  24A5FF05   ADDIU A1, A1, -251
45:                           reg = 2 + (value - 0xFD);
46:                        }
47:                        else
48:                        {
49:                           latch[0] = value;
9D0334E8  A3858088   SB A1, -32632(GP)
50:                           reg = value - 0xFD;
9D0334EC  24A5FF03   ADDIU A1, A1, -253
51:                        }
52:                  
53:                        mmc_bankvrom(4, address, regs[reg]);
9D0334F0  27828084   ADDIU V0, GP, -32636
9D0334F4  00451021   ADDU V0, V0, A1
9D0334F8  24040004   ADDIU A0, ZERO, 4
9D0334FC  00602821   ADDU A1, V1, ZERO
9D033500  0F40B41B   JAL mmc_bankvrom
9D033504  90460000   LBU A2, 0(V0)
54:                     }
55:                  }
9D033508  8FBF0014   LW RA, 20(SP)
9D03350C  27BD0018   ADDIU SP, SP, 24
9D033510  03E00008   JR RA
9D033514  00000000   NOP
56:                  
57:                  /* mapper 9: MMC2 */
58:                  /* MMC2: Punch-Out! */
59:                  static void map9_write(uint32 address, uint8 value)
60:                  {
9D03352C  27BDFFE8   ADDIU SP, SP, -24
9D033530  AFBF0014   SW RA, 20(SP)
61:                     switch ((address & 0xF000) >> 12)
9D033518  7C841B00   EXT A0, A0, 12, 4
9D03351C  2484FFF6   ADDIU A0, A0, -10
9D033520  2C820006   SLTIU V0, A0, 6
9D033524  1040004B   BEQ V0, ZERO, 0x9D033654
9D033528  00042080   SLL A0, A0, 2
9D033534  3C029D03   LUI V0, -25341
9D033538  2442354C   ADDIU V0, V0, 13644
9D03353C  00442021   ADDU A0, V0, A0
9D033540  8C820000   LW V0, 0(A0)
9D033544  00400008   JR V0
9D033548  00A03021   ADDU A2, A1, ZERO
62:                     {
63:                     case 0xA:
64:                        mmc_bankrom(8, 0x8000, value);
9D033564  24040008   ADDIU A0, ZERO, 8
9D033568  0F40B479   JAL mmc_bankrom
9D03356C  34058000   ORI A1, ZERO, -32768
65:                        break;
9D033570  0B40CD94   J 0x9D033650
9D033574  8FBF0014   LW RA, 20(SP)
66:                  
67:                     case 0xB:
68:                        regs[0] = value;
9D033578  A3858084   SB A1, -32636(GP)
69:                        if (0xFD == latch[0])
9D03357C  93838088   LBU V1, -32632(GP)
9D033580  240200FD   ADDIU V0, ZERO, 253
9D033584  54620032   BNEL V1, V0, 0x9D033650
9D033588  8FBF0014   LW RA, 20(SP)
70:                           mmc_bankvrom(4, 0x0000, value);
9D03358C  24040004   ADDIU A0, ZERO, 4
9D033590  0F40B41B   JAL mmc_bankvrom
9D033594  00002821   ADDU A1, ZERO, ZERO
71:                        break;
72:                  
73:                     case 0xC:
74:                        regs[1] = value;
9D0335A0  A3858085   SB A1, -32635(GP)
75:                        if (0xFE == latch[0])
9D0335A4  93838088   LBU V1, -32632(GP)
9D0335A8  240200FE   ADDIU V0, ZERO, 254
9D0335AC  54620028   BNEL V1, V0, 0x9D033650
9D0335B0  8FBF0014   LW RA, 20(SP)
76:                           mmc_bankvrom(4, 0x0000, value);
9D0335B4  24040004   ADDIU A0, ZERO, 4
9D0335B8  0F40B41B   JAL mmc_bankvrom
9D0335BC  00002821   ADDU A1, ZERO, ZERO
77:                        break;
78:                  
79:                     case 0xD:
80:                        regs[2] = value;
9D0335C8  A3858086   SB A1, -32634(GP)
81:                        if (0xFD == latch[1])
9D0335CC  93838089   LBU V1, -32631(GP)
9D0335D0  240200FD   ADDIU V0, ZERO, 253
9D0335D4  5462001E   BNEL V1, V0, 0x9D033650
9D0335D8  8FBF0014   LW RA, 20(SP)
82:                           mmc_bankvrom(4, 0x1000, value);
9D0335DC  24040004   ADDIU A0, ZERO, 4
9D0335E0  0F40B41B   JAL mmc_bankvrom
9D0335E4  24051000   ADDIU A1, ZERO, 4096
83:                        break;
84:                  
85:                     case 0xE:
86:                        regs[3] = value;
9D0335F0  A3858087   SB A1, -32633(GP)
87:                        if (0xFE == latch[1])
9D0335F4  93838089   LBU V1, -32631(GP)
9D0335F8  240200FE   ADDIU V0, ZERO, 254
9D0335FC  54620014   BNEL V1, V0, 0x9D033650
9D033600  8FBF0014   LW RA, 20(SP)
88:                           mmc_bankvrom(4, 0x1000, value);
9D033604  24040004   ADDIU A0, ZERO, 4
9D033608  0F40B41B   JAL mmc_bankvrom
9D03360C  24051000   ADDIU A1, ZERO, 4096
89:                        break;
90:                  
91:                     case 0xF:
92:                        if (value & 1)
9D033618  30A60001   ANDI A2, A1, 1
9D03361C  10C00007   BEQ A2, ZERO, 0x9D03363C
9D033620  00002021   ADDU A0, ZERO, ZERO
93:                           ppu_mirror(0, 0, 1, 1); /* horizontal */
9D033624  00002821   ADDU A1, ZERO, ZERO
9D033628  24060001   ADDIU A2, ZERO, 1
9D03362C  0F40635D   JAL ppu_mirror
9D033630  24070001   ADDIU A3, ZERO, 1
9D033634  0B40CD94   J 0x9D033650
9D033638  8FBF0014   LW RA, 20(SP)
94:                        else
95:                           ppu_mirror(0, 1, 0, 1); /* vertical */
9D03363C  24050001   ADDIU A1, ZERO, 1
9D033640  00003021   ADDU A2, ZERO, ZERO
9D033644  0F40635D   JAL ppu_mirror
9D033648  24070001   ADDIU A3, ZERO, 1
96:                        break;
97:                  
98:                     default:
99:                        break;
100:                    }
101:                 }
9D033598  0B40CD94   J 0x9D033650
9D03359C  8FBF0014   LW RA, 20(SP)
9D0335C0  0B40CD94   J 0x9D033650
9D0335C4  8FBF0014   LW RA, 20(SP)
9D0335E8  0B40CD94   J 0x9D033650
9D0335EC  8FBF0014   LW RA, 20(SP)
9D033610  0B40CD94   J 0x9D033650
9D033614  8FBF0014   LW RA, 20(SP)
9D03364C  8FBF0014   LW RA, 20(SP)
9D033650  27BD0018   ADDIU SP, SP, 24
9D033654  03E00008   JR RA
9D033658  00000000   NOP
102:                 
103:                 static void map9_init(void)
104:                 {
9D03365C  27BDFFE8   ADDIU SP, SP, -24
9D033660  AFBF0014   SW RA, 20(SP)
105:                    memset(regs, 0, sizeof(regs));
9D033664  AF808084   SW ZERO, -32636(GP)
106:                 
107:                    mmc_bankrom(8, 0x8000, 0);
9D033668  24040008   ADDIU A0, ZERO, 8
9D03366C  34058000   ORI A1, ZERO, -32768
9D033670  0F40B479   JAL mmc_bankrom
9D033674  00003021   ADDU A2, ZERO, ZERO
108:                    mmc_bankrom(8, 0xA000, (mmc_getinfo()->rom_banks * 2) - 3);
9D033678  0F40B40F   JAL mmc_getinfo
9D03367C  00000000   NOP
9D033680  8C460010   LW A2, 16(V0)
9D033684  00063040   SLL A2, A2, 1
9D033688  24040008   ADDIU A0, ZERO, 8
9D03368C  3405A000   ORI A1, ZERO, -24576
9D033690  0F40B479   JAL mmc_bankrom
9D033694  24C6FFFD   ADDIU A2, A2, -3
109:                    mmc_bankrom(8, 0xC000, (mmc_getinfo()->rom_banks * 2) - 2);
9D033698  0F40B40F   JAL mmc_getinfo
9D03369C  00000000   NOP
9D0336A0  8C460010   LW A2, 16(V0)
9D0336A4  24C6FFFF   ADDIU A2, A2, -1
9D0336A8  24040008   ADDIU A0, ZERO, 8
9D0336AC  3405C000   ORI A1, ZERO, -16384
9D0336B0  0F40B479   JAL mmc_bankrom
9D0336B4  00063040   SLL A2, A2, 1
110:                    mmc_bankrom(8, 0xE000, (mmc_getinfo()->rom_banks * 2) - 1);
9D0336B8  0F40B40F   JAL mmc_getinfo
9D0336BC  00000000   NOP
9D0336C0  8C460010   LW A2, 16(V0)
9D0336C4  00063040   SLL A2, A2, 1
9D0336C8  24040008   ADDIU A0, ZERO, 8
9D0336CC  3405E000   ORI A1, ZERO, -8192
9D0336D0  0F40B479   JAL mmc_bankrom
9D0336D4  24C6FFFF   ADDIU A2, A2, -1
111:                 
112:                    latch[0] = 0xFE;
9D0336D8  2402FFFE   ADDIU V0, ZERO, -2
9D0336DC  A3828088   SB V0, -32632(GP)
113:                    latch[1] = 0xFE;
9D0336E0  A3828089   SB V0, -32631(GP)
114:                 
115:                    ppu_setlatchfunc(mmc9_latchfunc);
9D0336E4  3C049D03   LUI A0, -25341
9D0336E8  0F4065C6   JAL ppu_setlatchfunc
9D0336EC  248434B8   ADDIU A0, A0, 13496
116:                 }
9D0336F0  8FBF0014   LW RA, 20(SP)
9D0336F4  03E00008   JR RA
9D0336F8  27BD0018   ADDIU SP, SP, 24
117:                 
118:                 static void map9_getstate(SnssMapperBlock *state)
119:                 {
120:                    state->extraData.mapper9.latch[0] = latch[0];
9D033450  93828088   LBU V0, -32632(GP)
9D033454  A0820018   SB V0, 24(A0)
121:                    state->extraData.mapper9.latch[1] = latch[1];
9D033458  93828089   LBU V0, -32631(GP)
9D03345C  A0820019   SB V0, 25(A0)
122:                    state->extraData.mapper9.lastB000Write = regs[0];
9D033460  93828084   LBU V0, -32636(GP)
9D033464  A082001A   SB V0, 26(A0)
123:                    state->extraData.mapper9.lastC000Write = regs[1];
9D033468  93828085   LBU V0, -32635(GP)
9D03346C  A082001B   SB V0, 27(A0)
124:                    state->extraData.mapper9.lastD000Write = regs[2];
9D033470  93828086   LBU V0, -32634(GP)
9D033474  A082001C   SB V0, 28(A0)
125:                    state->extraData.mapper9.lastE000Write = regs[3];
9D033478  93828087   LBU V0, -32633(GP)
9D03347C  03E00008   JR RA
9D033480  A082001D   SB V0, 29(A0)
126:                 }
127:                 
128:                 static void map9_setstate(SnssMapperBlock *state)
129:                 {
130:                    latch[0] = state->extraData.mapper9.latch[0];
9D033484  90820018   LBU V0, 24(A0)
9D033488  A3828088   SB V0, -32632(GP)
131:                    latch[1] = state->extraData.mapper9.latch[1];
9D03348C  90820019   LBU V0, 25(A0)
9D033490  A3828089   SB V0, -32631(GP)
132:                    regs[0] = state->extraData.mapper9.lastB000Write;
9D033494  9082001A   LBU V0, 26(A0)
9D033498  A3828084   SB V0, -32636(GP)
133:                    regs[1] = state->extraData.mapper9.lastC000Write;
9D03349C  9082001B   LBU V0, 27(A0)
9D0334A0  A3828085   SB V0, -32635(GP)
134:                    regs[2] = state->extraData.mapper9.lastD000Write;
9D0334A4  9082001C   LBU V0, 28(A0)
9D0334A8  A3828086   SB V0, -32634(GP)
135:                    regs[3] = state->extraData.mapper9.lastE000Write;
9D0334AC  9082001D   LBU V0, 29(A0)
9D0334B0  03E00008   JR RA
9D0334B4  A3828087   SB V0, -32633(GP)
136:                 }
137:                 
138:                 static map_memwrite map9_memwrite[] =
139:                 {
140:                    { 0x8000, 0xFFFF, map9_write },
141:                    {     -1,     -1, NULL }
142:                 };
143:                 
144:                 mapintf_t map9_intf =
145:                 {
146:                    9, /* mapper number */
147:                    "MMC2", /* mapper name */
148:                    map9_init, /* init routine */
149:                    NULL, /* vblank callback */
150:                    NULL, /* hblank callback */
151:                    map9_getstate, /* get state (snss) */
152:                    map9_setstate, /* set state (snss) */
153:                    NULL, /* memory read structure */
154:                    map9_memwrite, /* memory write structure */
155:                    NULL /* external sound device */
156:                 };
157:                 
158:                 /*
159:                 ** $Log: map009.c,v $
160:                 ** Revision 1.2  2001/04/27 14:37:11  neil
161:                 ** wheeee
162:                 **
163:                 ** Revision 1.1  2001/04/27 12:54:40  neil
164:                 ** blah
165:                 **
166:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
167:                 ** initial
168:                 **
169:                 ** Revision 1.1  2000/10/24 12:19:33  matt
170:                 ** changed directory structure
171:                 **
172:                 ** Revision 1.9  2000/10/22 19:17:46  matt
173:                 ** mapper cleanups galore
174:                 **
175:                 ** Revision 1.8  2000/10/22 15:03:14  matt
176:                 ** simplified mirroring
177:                 **
178:                 ** Revision 1.7  2000/10/21 19:33:38  matt
179:                 ** many more cleanups
180:                 **
181:                 ** Revision 1.6  2000/07/17 05:11:35  matt
182:                 ** minor update from making PPU code less filthy
183:                 **
184:                 ** Revision 1.5  2000/07/15 23:52:19  matt
185:                 ** rounded out a bunch more mapper interfaces
186:                 **
187:                 ** Revision 1.4  2000/07/10 05:29:03  matt
188:                 ** cleaned up some mirroring issues
189:                 **
190:                 ** Revision 1.3  2000/07/06 02:48:43  matt
191:                 ** clearly labelled structure members
192:                 **
193:                 ** Revision 1.2  2000/07/05 22:50:33  matt
194:                 ** fixed punchout -- works 100% now
195:                 **
196:                 ** Revision 1.1  2000/07/05 05:05:18  matt
197:                 ** initial revision
198:                 **
199:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map008.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map8.c
21:                  **
22:                  ** mapper 8 interface
23:                  ** $Id: map008.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  
29:                  /* mapper 8: FFE F3xxx -- what the hell uses this? */
30:                  static void map8_write(uint32 address, uint8 value)
31:                  {
9D03B0E8  27BDFFE8   ADDIU SP, SP, -24
9D03B0EC  AFBF0014   SW RA, 20(SP)
9D03B0F0  AFB00010   SW S0, 16(SP)
9D03B0F4  00A08021   ADDU S0, A1, ZERO
32:                     UNUSED(address);
33:                  
34:                     mmc_bankrom(16, 0x8000, value >> 3);
9D03B0F8  24040010   ADDIU A0, ZERO, 16
9D03B0FC  34058000   ORI A1, ZERO, -32768
9D03B100  0F40B479   JAL mmc_bankrom
9D03B104  001030C2   SRL A2, S0, 3
35:                     mmc_bankvrom(8, 0x0000, value & 7);
9D03B108  24040008   ADDIU A0, ZERO, 8
9D03B10C  00002821   ADDU A1, ZERO, ZERO
9D03B110  0F40B41B   JAL mmc_bankvrom
9D03B114  32060007   ANDI A2, S0, 7
36:                  }
9D03B118  8FBF0014   LW RA, 20(SP)
9D03B11C  8FB00010   LW S0, 16(SP)
9D03B120  03E00008   JR RA
9D03B124  27BD0018   ADDIU SP, SP, 24
37:                  
38:                  static void map8_init(void)
39:                  {
9D03B128  27BDFFE8   ADDIU SP, SP, -24
9D03B12C  AFBF0014   SW RA, 20(SP)
40:                     mmc_bankrom(16, 0x8000, 0);
9D03B130  24040010   ADDIU A0, ZERO, 16
9D03B134  34058000   ORI A1, ZERO, -32768
9D03B138  0F40B479   JAL mmc_bankrom
9D03B13C  00003021   ADDU A2, ZERO, ZERO
41:                     mmc_bankrom(16, 0xC000, 1);
9D03B140  24040010   ADDIU A0, ZERO, 16
9D03B144  3405C000   ORI A1, ZERO, -16384
9D03B148  0F40B479   JAL mmc_bankrom
9D03B14C  24060001   ADDIU A2, ZERO, 1
42:                     mmc_bankvrom(8, 0x0000, 0);
9D03B150  24040008   ADDIU A0, ZERO, 8
9D03B154  00002821   ADDU A1, ZERO, ZERO
9D03B158  0F40B41B   JAL mmc_bankvrom
9D03B15C  00003021   ADDU A2, ZERO, ZERO
43:                  }
9D03B160  8FBF0014   LW RA, 20(SP)
9D03B164  03E00008   JR RA
9D03B168  27BD0018   ADDIU SP, SP, 24
44:                  
45:                  static map_memwrite map8_memwrite[] =
46:                  {
47:                     { 0x8000, 0xFFFF, map8_write },
48:                     {     -1,     -1, NULL }
49:                  };
50:                  
51:                  mapintf_t map8_intf =
52:                  {
53:                     8, /* mapper number */
54:                     "FFE F3xxx", /* mapper name */
55:                     map8_init, /* init routine */
56:                     NULL, /* vblank callback */
57:                     NULL, /* hblank callback */
58:                     NULL, /* get state (snss) */
59:                     NULL, /* set state (snss) */
60:                     NULL, /* memory read structure */
61:                     map8_memwrite, /* memory write structure */
62:                     NULL /* external sound device */
63:                  };
64:                  
65:                  /*
66:                  ** $Log: map008.c,v $
67:                  ** Revision 1.2  2001/04/27 14:37:11  neil
68:                  ** wheeee
69:                  **
70:                  ** Revision 1.1  2001/04/27 12:54:40  neil
71:                  ** blah
72:                  **
73:                  ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
74:                  ** initial
75:                  **
76:                  ** Revision 1.1  2000/10/24 12:19:32  matt
77:                  ** changed directory structure
78:                  **
79:                  ** Revision 1.5  2000/10/22 19:17:47  matt
80:                  ** mapper cleanups galore
81:                  **
82:                  ** Revision 1.4  2000/10/21 19:33:38  matt
83:                  ** many more cleanups
84:                  **
85:                  ** Revision 1.3  2000/08/16 02:50:11  matt
86:                  ** random mapper cleanups
87:                  **
88:                  ** Revision 1.2  2000/07/06 02:48:43  matt
89:                  ** clearly labelled structure members
90:                  **
91:                  ** Revision 1.1  2000/07/04 23:11:45  matt
92:                  ** initial revision
93:                  **
94:                  */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map007.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map7.c
21:                  **
22:                  ** mapper 7 interface
23:                  ** $Id: map007.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes_ppu.h>
29:                  #include <log.h>
30:                  
31:                  /* mapper 7: AOROM */
32:                  static void map7_write(uint32 address, uint8 value)
33:                  {
9D03B88C  27BDFFE8   ADDIU SP, SP, -24
9D03B890  AFBF0014   SW RA, 20(SP)
9D03B894  AFB00010   SW S0, 16(SP)
9D03B898  00A08021   ADDU S0, A1, ZERO
34:                     int mirror;
35:                     UNUSED(address);
36:                  
37:                     mmc_bankrom(32, 0x8000, value);
9D03B89C  24040020   ADDIU A0, ZERO, 32
9D03B8A0  34058000   ORI A1, ZERO, -32768
9D03B8A4  0F40B479   JAL mmc_bankrom
9D03B8A8  02003021   ADDU A2, S0, ZERO
38:                     mirror = (value & 0x10) >> 4;
9D03B8AC  7E070100   EXT A3, S0, 4, 1
39:                     ppu_mirror(mirror, mirror, mirror, mirror);
9D03B8B0  00E02021   ADDU A0, A3, ZERO
9D03B8B4  00E02821   ADDU A1, A3, ZERO
9D03B8B8  0F40635D   JAL ppu_mirror
9D03B8BC  00E03021   ADDU A2, A3, ZERO
40:                  }
9D03B8C0  8FBF0014   LW RA, 20(SP)
9D03B8C4  8FB00010   LW S0, 16(SP)
9D03B8C8  03E00008   JR RA
9D03B8CC  27BD0018   ADDIU SP, SP, 24
41:                  
42:                  static void map7_init(void)
43:                  {
9D03B868  27BDFFE8   ADDIU SP, SP, -24
9D03B86C  AFBF0014   SW RA, 20(SP)
44:                     mmc_bankrom(32, 0x8000, 0);
9D03B870  24040020   ADDIU A0, ZERO, 32
9D03B874  34058000   ORI A1, ZERO, -32768
9D03B878  0F40B479   JAL mmc_bankrom
9D03B87C  00003021   ADDU A2, ZERO, ZERO
45:                  }
9D03B880  8FBF0014   LW RA, 20(SP)
9D03B884  03E00008   JR RA
9D03B888  27BD0018   ADDIU SP, SP, 24
46:                  
47:                  static map_memwrite map7_memwrite[] =
48:                  {
49:                     { 0x8000, 0xFFFF, map7_write },
50:                     {     -1,     -1, NULL }
51:                  };
52:                  
53:                  mapintf_t map7_intf =
54:                  {
55:                     7, /* mapper number */
56:                     "AOROM", /* mapper name */
57:                     map7_init, /* init routine */
58:                     NULL, /* vblank callback */
59:                     NULL, /* hblank callback */
60:                     NULL, /* get state (snss) */
61:                     NULL, /* set state (snss) */
62:                     NULL, /* memory read structure */
63:                     map7_memwrite, /* memory write structure */
64:                     NULL /* external sound device */
65:                  };
66:                  
67:                  /*
68:                  ** $Log: map007.c,v $
69:                  ** Revision 1.2  2001/04/27 14:37:11  neil
70:                  ** wheeee
71:                  **
72:                  ** Revision 1.1  2001/04/27 12:54:40  neil
73:                  ** blah
74:                  **
75:                  ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
76:                  ** initial
77:                  **
78:                  ** Revision 1.1  2000/10/24 12:19:32  matt
79:                  ** changed directory structure
80:                  **
81:                  ** Revision 1.6  2000/10/22 19:17:46  matt
82:                  ** mapper cleanups galore
83:                  **
84:                  ** Revision 1.5  2000/10/22 15:03:13  matt
85:                  ** simplified mirroring
86:                  **
87:                  ** Revision 1.4  2000/10/21 19:33:38  matt
88:                  ** many more cleanups
89:                  **
90:                  ** Revision 1.3  2000/08/16 02:50:11  matt
91:                  ** random mapper cleanups
92:                  **
93:                  ** Revision 1.2  2000/07/06 02:48:43  matt
94:                  ** clearly labelled structure members
95:                  **
96:                  ** Revision 1.1  2000/07/04 23:11:45  matt
97:                  ** initial revision
98:                  **
99:                  */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map005.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map5.c
21:                  **
22:                  ** mapper 5 interface
23:                  ** $Id: map005.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes.h>
29:                  #include <log.h>
30:                  #include "mmc5_snd.h"
31:                  
32:                  /* TODO: there's lots of info about this mapper now;
33:                  ** let's implement it correctly/completely
34:                  */
35:                  
36:                  static struct
37:                  {
38:                     int counter, enabled;
39:                     int reset, latch;
40:                  } irq;
41:                  
42:                  /* MMC5 - Castlevania III, etc */
43:                  static void map5_hblank(int vblank)
44:                  {
9D032810  27BDFFE8   ADDIU SP, SP, -24
9D032814  AFBF0014   SW RA, 20(SP)
9D032818  AFB00010   SW S0, 16(SP)
45:                     UNUSED(vblank);
46:                  
47:                     if (irq.counter == nes_getcontextptr()->scanline)
9D03281C  3C02A001   LUI V0, -24575
9D032820  0F408D03   JAL nes_getcontextptr
9D032824  8C50B8DC   LW S0, -18212(V0)
9D032828  8C420320   LW V0, 800(V0)
9D03282C  16020010   BNE S0, V0, 0x9D032870
9D032830  8FBF0014   LW RA, 20(SP)
48:                     {
49:                        if (true == irq.enabled)
9D032834  3C02A001   LUI V0, -24575
9D032838  8C43B8E0   LW V1, -18208(V0)
9D03283C  24020001   ADDIU V0, ZERO, 1
9D032840  14620007   BNE V1, V0, 0x9D032860
9D032844  3C02A001   LUI V0, -24575
50:                        {
51:                           nes_irq();
9D032848  0F408C7B   JAL nes_irq
9D03284C  00000000   NOP
52:                           irq.reset = true;
9D032850  24030001   ADDIU V1, ZERO, 1
9D032854  3C02A001   LUI V0, -24575
9D032858  AC43B8E4   SW V1, -18204(V0)
53:                        }
54:                        //else 
55:                        //   irq.reset = false;
56:                        irq.counter = irq.latch;
9D03285C  3C02A001   LUI V0, -24575
9D032860  2443B8DC   ADDIU V1, V0, -18212
9D032864  8C63000C   LW V1, 12(V1)
9D032868  AC43B8DC   SW V1, -18212(V0)
57:                     }
58:                  }
9D03286C  8FBF0014   LW RA, 20(SP)
9D032870  8FB00010   LW S0, 16(SP)
9D032874  03E00008   JR RA
9D032878  27BD0018   ADDIU SP, SP, 24
59:                  
60:                  static void map5_write(uint32 address, uint8 value)
61:                  {
9D0325F4  27BDFFE8   ADDIU SP, SP, -24
9D0325F8  AFBF0014   SW RA, 20(SP)
9D0325FC  AFB00010   SW S0, 16(SP)
62:                     static int page_size = 8;
63:                  
64:                     /* ex-ram memory-- bleh! */
65:                     if (address >= 0x5C00 && address <= 0x5FFF)
9D0325E4  2482A400   ADDIU V0, A0, -23552
9D0325E8  2C420400   SLTIU V0, V0, 1024
9D0325EC  14400086   BNE V0, ZERO, 0x9D032808
9D0325F0  24025122   ADDIU V0, ZERO, 20770
66:                        return;
67:                  
68:                     switch (address)
9D032600  10820054   BEQ A0, V0, 0x9D032754
9D032604  00A08021   ADDU S0, A1, ZERO
9D032608  2C825123   SLTIU V0, A0, 20771
9D03260C  10400015   BEQ V0, ZERO, 0x9D032664
9D032610  2402512A   ADDIU V0, ZERO, 20778
9D032614  24025115   ADDIU V0, ZERO, 20757
9D032618  10820033   BEQ A0, V0, 0x9D0326E8
9D03261C  2C825116   SLTIU V0, A0, 20758
9D032620  10400008   BEQ V0, ZERO, 0x9D032644
9D032624  24025120   ADDIU V0, ZERO, 20768
9D032628  24025105   ADDIU V0, ZERO, 20741
9D03262C  10820022   BEQ A0, V0, 0x9D0326B8
9D032630  24025114   ADDIU V0, ZERO, 20756
9D032634  10820027   BEQ A0, V0, 0x9D0326D4
9D032638  24040008   ADDIU A0, ZERO, 8
9D032644  10820037   BEQ A0, V0, 0x9D032724
9D032648  2C825121   SLTIU V0, A0, 20769
9D03264C  1040003B   BEQ V0, ZERO, 0x9D03273C
9D032650  24025116   ADDIU V0, ZERO, 20758
9D032654  1082002E   BEQ A0, V0, 0x9D032710
9D032658  24040008   ADDIU A0, ZERO, 8
9D032664  10820052   BEQ A0, V0, 0x9D0327B0
9D032668  2C82512B   SLTIU V0, A0, 20779
9D03266C  1040000A   BEQ V0, ZERO, 0x9D032698
9D032670  24025203   ADDIU V0, ZERO, 20995
9D032674  24025128   ADDIU V0, ZERO, 20776
9D032678  10820041   BEQ A0, V0, 0x9D032780
9D03267C  2C825129   SLTIU V0, A0, 20777
9D032680  10400045   BEQ V0, ZERO, 0x9D032798
9D032684  24025123   ADDIU V0, ZERO, 20771
9D032688  10820038   BEQ A0, V0, 0x9D03276C
9D03268C  24040001   ADDIU A0, ZERO, 1
9D032698  10820050   BEQ A0, V0, 0x9D0327DC
9D03269C  24025204   ADDIU V0, ZERO, 20996
9D0326A0  10820053   BEQ A0, V0, 0x9D0327F0
9D0326A4  2402512B   ADDIU V0, ZERO, 20779
9D0326A8  54820055   BNEL A0, V0, 0x9D032800
9D0326AC  8FBF0014   LW RA, 20(SP)
69:                     {
70:                     case 0x5100:
71:                        /* PRG page size setting */
72:                        /* 0:32k 1:16k 2,3:8k */
73:                        switch (value & 3)
74:                        {
75:                        case 0:
76:                           page_size = 32;
77:                           break;
78:                  
79:                        case 1:
80:                           page_size = 16;
81:                           break;
82:                        
83:                        case 2:
84:                        case 3:
85:                           page_size = 8;
86:                           break;
87:                        }
88:                        break;
89:                  
90:                     case 0x5101:
91:                        /* CHR page size setting */
92:                        /* 0:8k 1:4k 2:2k 3:1k */
93:                        break;
94:                  
95:                     case 0x5104:
96:                        /* GFX mode setting */
97:                        /*
98:                        00:split mode
99:                        01:split & exgraffix
100:                       10:ex-ram
101:                       11:exram + write protect
102:                       */
103:                       break;
104:                    
105:                    case 0x5105:
106:                       /* TODO: exram needs to fill in nametables 2-3 */
107:                       ppu_mirror(value & 3, (value >> 2) & 3, (value >> 4) & 3, value >> 6);
9D0326B8  30A40003   ANDI A0, A1, 3
9D0326BC  7CA50880   EXT A1, A1, 2, 2
9D0326C0  7E060900   EXT A2, S0, 4, 2
9D0326C4  0F40635D   JAL ppu_mirror
9D0326C8  00103982   SRL A3, S0, 6
108:                       break;
9D0326CC  0B40CA00   J 0x9D032800
9D0326D0  8FBF0014   LW RA, 20(SP)
109:                 
110:                    case 0x5106:
111:                    case 0x5107:
112:                       /* ex-ram fill mode stuff */
113:                       break;
114:                    
115:                    case 0x5113:
116:                       /* ram page for $6000-7FFF? bit 2*/
117:                       break;
118:                    
119:                    case 0x5114:
120:                       mmc_bankrom(8, 0x8000, value);
9D0326D4  34058000   ORI A1, ZERO, -32768
9D0326D8  0F40B479   JAL mmc_bankrom
9D0326DC  02003021   ADDU A2, S0, ZERO
121:                       //if (page_size == 8)
122:                       //   mmc_bankrom(8, 0x8000, value);
123:                       break;
9D0326E0  0B40CA00   J 0x9D032800
9D0326E4  8FBF0014   LW RA, 20(SP)
124:                 
125:                    case 0x5115:
126:                       mmc_bankrom(8, 0x8000, value);
9D0326E8  24040008   ADDIU A0, ZERO, 8
9D0326EC  34058000   ORI A1, ZERO, -32768
9D0326F0  0F40B479   JAL mmc_bankrom
9D0326F4  02003021   ADDU A2, S0, ZERO
127:                       mmc_bankrom(8, 0xA000, value + 1);
9D0326F8  24040008   ADDIU A0, ZERO, 8
9D0326FC  3405A000   ORI A1, ZERO, -24576
9D032700  0F40B479   JAL mmc_bankrom
9D032704  26060001   ADDIU A2, S0, 1
128:                       //if (page_size == 8)
129:                       //   mmc_bankrom(8, 0xA000, value);
130:                       //else if (page_size == 16)
131:                       //   mmc_bankrom(16, 0x8000, value >> 1);
132:                          //mmc_bankrom(16, 0x8000, value & 0xFE);
133:                       break;
9D032708  0B40CA00   J 0x9D032800
9D03270C  8FBF0014   LW RA, 20(SP)
134:                 
135:                    case 0x5116:
136:                       mmc_bankrom(8, 0xC000, value);
9D032710  3405C000   ORI A1, ZERO, -16384
9D032714  0F40B479   JAL mmc_bankrom
9D032718  02003021   ADDU A2, S0, ZERO
137:                       //if (page_size == 8)
138:                       //   mmc_bankrom(8, 0xC000, value);
139:                       break;
9D03271C  0B40CA00   J 0x9D032800
9D032720  8FBF0014   LW RA, 20(SP)
140:                 
141:                    case 0x5117:
142:                       //if (page_size == 8)
143:                       //   mmc_bankrom(8, 0xE000, value);
144:                       //else if (page_size == 16)
145:                       //   mmc_bankrom(16, 0xC000, value >> 1);
146:                          //mmc_bankrom(16, 0xC000, value & 0xFE);
147:                       //else if (page_size == 32)
148:                       //   mmc_bankrom(32, 0x8000, value >> 2);
149:                          //mmc_bankrom(32, 0x8000, value & 0xFC);
150:                       break;
151:                 
152:                    case 0x5120:
153:                       mmc_bankvrom(1, 0x0000, value);
9D032724  24040001   ADDIU A0, ZERO, 1
9D032728  00002821   ADDU A1, ZERO, ZERO
9D03272C  0F40B41B   JAL mmc_bankvrom
9D032730  02003021   ADDU A2, S0, ZERO
154:                       break;
9D032734  0B40CA00   J 0x9D032800
9D032738  8FBF0014   LW RA, 20(SP)
155:                 
156:                    case 0x5121:
157:                       mmc_bankvrom(1, 0x0400, value);
9D03273C  24040001   ADDIU A0, ZERO, 1
9D032740  24050400   ADDIU A1, ZERO, 1024
9D032744  0F40B41B   JAL mmc_bankvrom
9D032748  02003021   ADDU A2, S0, ZERO
158:                       break;
9D03274C  0B40CA00   J 0x9D032800
9D032750  8FBF0014   LW RA, 20(SP)
159:                 
160:                    case 0x5122:
161:                       mmc_bankvrom(1, 0x0800, value);
9D032754  24040001   ADDIU A0, ZERO, 1
9D032758  24050800   ADDIU A1, ZERO, 2048
9D03275C  0F40B41B   JAL mmc_bankvrom
9D032760  02003021   ADDU A2, S0, ZERO
162:                       break;
9D032764  0B40CA00   J 0x9D032800
9D032768  8FBF0014   LW RA, 20(SP)
163:                 
164:                    case 0x5123:
165:                       mmc_bankvrom(1, 0x0C00, value);
9D03276C  24050C00   ADDIU A1, ZERO, 3072
9D032770  0F40B41B   JAL mmc_bankvrom
9D032774  02003021   ADDU A2, S0, ZERO
166:                       break;
9D032778  0B40CA00   J 0x9D032800
9D03277C  8FBF0014   LW RA, 20(SP)
167:                 
168:                    case 0x5124:
169:                    case 0x5125:
170:                    case 0x5126:
171:                    case 0x5127:
172:                       /* more VROM shit? */
173:                       break;
174:                 
175:                    case 0x5128:
176:                       mmc_bankvrom(1, 0x1000, value);
9D032780  24040001   ADDIU A0, ZERO, 1
9D032784  24051000   ADDIU A1, ZERO, 4096
9D032788  0F40B41B   JAL mmc_bankvrom
9D03278C  02003021   ADDU A2, S0, ZERO
177:                       break;
9D032790  0B40CA00   J 0x9D032800
9D032794  8FBF0014   LW RA, 20(SP)
178:                 
179:                    case 0x5129:
180:                       mmc_bankvrom(1, 0x1400, value);
9D032798  24040001   ADDIU A0, ZERO, 1
9D03279C  24051400   ADDIU A1, ZERO, 5120
9D0327A0  0F40B41B   JAL mmc_bankvrom
9D0327A4  02003021   ADDU A2, S0, ZERO
181:                       break;
9D0327A8  0B40CA00   J 0x9D032800
9D0327AC  8FBF0014   LW RA, 20(SP)
182:                 
183:                    case 0x512A:
184:                       mmc_bankvrom(1, 0x1800, value);
9D0327B0  24040001   ADDIU A0, ZERO, 1
9D0327B4  24051800   ADDIU A1, ZERO, 6144
9D0327B8  0F40B41B   JAL mmc_bankvrom
9D0327BC  02003021   ADDU A2, S0, ZERO
185:                       break;
9D0327C0  0B40CA00   J 0x9D032800
9D0327C4  8FBF0014   LW RA, 20(SP)
186:                 
187:                    case 0x512B:
188:                       mmc_bankvrom(1, 0x1C00, value);
9D0326B0  0B40C9F2   J 0x9D0327C8
9D0326B4  24040001   ADDIU A0, ZERO, 1
9D0327C8  24051C00   ADDIU A1, ZERO, 7168
9D0327CC  0F40B41B   JAL mmc_bankvrom
9D0327D0  02003021   ADDU A2, S0, ZERO
189:                       break;
9D0327D4  0B40CA00   J 0x9D032800
9D0327D8  8FBF0014   LW RA, 20(SP)
190:                 
191:                    case 0x5203:
192:                       irq.counter = value;
9D0327DC  3C02A001   LUI V0, -24575
9D0327E0  AC45B8DC   SW A1, -18212(V0)
193:                       irq.latch = value;
9D0327E4  2442B8DC   ADDIU V0, V0, -18212
194:                 //      irq.reset = false;
195:                       break;
9D0327E8  0B40C9FF   J 0x9D0327FC
9D0327EC  AC45000C   SW A1, 12(V0)
196:                 
197:                    case 0x5204:
198:                       irq.enabled = (value & 0x80) ? true : false;
9D0327F0  000581C2   SRL S0, A1, 7
9D0327F4  3C02A001   LUI V0, -24575
9D0327F8  AC50B8E0   SW S0, -18208(V0)
199:                 //      irq.reset = false;
200:                       break;
201:                 
202:                    default:
203:                 #ifdef NOFRENDO_DEBUG
204:                       log_printf("unknown mmc5 write: $%02X to $%04X\n", value, address);
205:                 #endif /* NOFRENDO_DEBUG */
206:                       break;
207:                    }
208:                 }
9D03263C  0B40CA00   J 0x9D032800
9D032640  8FBF0014   LW RA, 20(SP)
9D03265C  0B40CA00   J 0x9D032800
9D032660  8FBF0014   LW RA, 20(SP)
9D032690  0B40CA00   J 0x9D032800
9D032694  8FBF0014   LW RA, 20(SP)
9D0327FC  8FBF0014   LW RA, 20(SP)
9D032800  8FB00010   LW S0, 16(SP)
9D032804  27BD0018   ADDIU SP, SP, 24
9D032808  03E00008   JR RA
9D03280C  00000000   NOP
209:                 
210:                 static uint8 map5_read(uint32 address)
211:                 {
212:                    /* Castlevania 3 IRQ counter */
213:                    if (address == 0x5204)
9D032544  24035204   ADDIU V1, ZERO, 20996
9D032548  14830005   BNE A0, V1, 0x9D032560
9D03254C  240200FF   ADDIU V0, ZERO, 255
214:                    {
215:                       /* if reset == 1, we've hit scanline */
216:                       return (irq.reset ? 0x40 : 0x00);
9D032550  3C02A001   LUI V0, -24575
9D032554  8C43B8E4   LW V1, -18204(V0)
9D032558  24020040   ADDIU V0, ZERO, 64
9D03255C  0003100A   MOVZ V0, ZERO, V1
217:                    }
218:                    else
219:                    {
220:                 #ifdef NOFRENDO_DEBUG
221:                       log_printf("invalid MMC5 read: $%04X", address);
222:                 #endif
223:                       return 0xFF;
224:                    }
225:                 }
9D032560  03E00008   JR RA
9D032564  00000000   NOP
226:                 
227:                 static void map5_init(void)
228:                 {
9D032578  27BDFFE8   ADDIU SP, SP, -24
9D03257C  AFBF0014   SW RA, 20(SP)
229:                    mmc_bankrom(8, 0x8000, MMC_LASTBANK);
9D032580  24040008   ADDIU A0, ZERO, 8
9D032584  34058000   ORI A1, ZERO, -32768
9D032588  0F40B479   JAL mmc_bankrom
9D03258C  2406FFFF   ADDIU A2, ZERO, -1
230:                    mmc_bankrom(8, 0xA000, MMC_LASTBANK);
9D032590  24040008   ADDIU A0, ZERO, 8
9D032594  3405A000   ORI A1, ZERO, -24576
9D032598  0F40B479   JAL mmc_bankrom
9D03259C  2406FFFF   ADDIU A2, ZERO, -1
231:                    mmc_bankrom(8, 0xC000, MMC_LASTBANK);
9D0325A0  24040008   ADDIU A0, ZERO, 8
9D0325A4  3405C000   ORI A1, ZERO, -16384
9D0325A8  0F40B479   JAL mmc_bankrom
9D0325AC  2406FFFF   ADDIU A2, ZERO, -1
232:                    mmc_bankrom(8, 0xE000, MMC_LASTBANK);
9D0325B0  24040008   ADDIU A0, ZERO, 8
9D0325B4  3405E000   ORI A1, ZERO, -8192
9D0325B8  0F40B479   JAL mmc_bankrom
9D0325BC  2406FFFF   ADDIU A2, ZERO, -1
233:                 
234:                    irq.counter = irq.enabled = 0;
9D0325C0  3C03A001   LUI V1, -24575
9D0325C4  2462B8DC   ADDIU V0, V1, -18212
9D0325C8  AC400004   SW ZERO, 4(V0)
9D0325CC  AC60B8DC   SW ZERO, -18212(V1)
235:                    irq.reset = irq.latch = 0;
9D0325D0  AC40000C   SW ZERO, 12(V0)
9D0325D4  AC400008   SW ZERO, 8(V0)
236:                 }
9D0325D8  8FBF0014   LW RA, 20(SP)
9D0325DC  03E00008   JR RA
9D0325E0  27BD0018   ADDIU SP, SP, 24
237:                 
238:                 /* incomplete SNSS definition */
239:                 static void map5_getstate(SnssMapperBlock *state)
240:                 {
241:                    state->extraData.mapper5.dummy = 0;
9D032568  03E00008   JR RA
9D03256C  A0800018   SB ZERO, 24(A0)
242:                 }
243:                 
244:                 static void map5_setstate(SnssMapperBlock *state)
245:                 {
9D032570  03E00008   JR RA
9D032574  00000000   NOP
246:                    UNUSED(state);
247:                 }
248:                 
249:                 static map_memwrite map5_memwrite[] =
250:                 {
251:                    /* $5000 - $5015 handled by sound */
252:                    { 0x5016, 0x5FFF, map5_write },
253:                    { 0x8000, 0xFFFF, map5_write },
254:                    {     -1,     -1, NULL }
255:                 };
256:                 
257:                 static map_memread map5_memread[] = 
258:                 {
259:                    { 0x5204, 0x5204, map5_read },
260:                    {     -1,     -1, NULL }
261:                 };
262:                 
263:                 mapintf_t map5_intf =
264:                 {
265:                    5, /* mapper number */
266:                    "MMC5", /* mapper name */
267:                    map5_init, /* init routine */
268:                    NULL, /* vblank callback */
269:                    map5_hblank, /* hblank callback */
270:                    map5_getstate, /* get state (snss) */
271:                    map5_setstate, /* set state (snss) */
272:                    map5_memread, /* memory read structure */
273:                    map5_memwrite, /* memory write structure */
274:                    &mmc5_ext /* external sound device */
275:                 };
276:                 /*
277:                 ** $Log: map005.c,v $
278:                 ** Revision 1.2  2001/04/27 14:37:11  neil
279:                 ** wheeee
280:                 **
281:                 ** Revision 1.1  2001/04/27 12:54:40  neil
282:                 ** blah
283:                 **
284:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
285:                 ** initial
286:                 **
287:                 ** Revision 1.2  2000/11/25 20:32:33  matt
288:                 ** scanline interface change
289:                 **
290:                 ** Revision 1.1  2000/10/24 12:19:32  matt
291:                 ** changed directory structure
292:                 **
293:                 ** Revision 1.11  2000/10/22 19:17:46  matt
294:                 ** mapper cleanups galore
295:                 **
296:                 ** Revision 1.10  2000/10/21 19:33:37  matt
297:                 ** many more cleanups
298:                 **
299:                 ** Revision 1.9  2000/10/17 03:23:16  matt
300:                 ** added mmc5 sound interface
301:                 **
302:                 ** Revision 1.8  2000/10/10 13:58:17  matt
303:                 ** stroustrup squeezing his way in the door
304:                 **
305:                 ** Revision 1.7  2000/08/16 02:50:11  matt
306:                 ** random mapper cleanups
307:                 **
308:                 ** Revision 1.6  2000/07/15 23:52:19  matt
309:                 ** rounded out a bunch more mapper interfaces
310:                 **
311:                 ** Revision 1.5  2000/07/10 13:51:25  matt
312:                 ** using generic nes_irq() routine now
313:                 **
314:                 ** Revision 1.4  2000/07/10 05:29:03  matt
315:                 ** cleaned up some mirroring issues
316:                 **
317:                 ** Revision 1.3  2000/07/06 02:48:43  matt
318:                 ** clearly labelled structure members
319:                 **
320:                 ** Revision 1.2  2000/07/05 05:04:51  matt
321:                 ** fixed h-blank callback
322:                 **
323:                 ** Revision 1.1  2000/07/04 23:11:45  matt
324:                 ** initial revision
325:                 **
326:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map004.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map4.c
21:                  **
22:                  ** mapper 4 interface
23:                  ** $Id: map004.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes.h>
29:                  #include <libsnss.h>
30:                  
31:                  static struct
32:                  {
33:                     int counter, latch;
34:                     bool enabled, reset;
35:                  } irq;
36:                  
37:                  static uint8 reg;
38:                  static uint8 command;
39:                  static uint16 vrombase;
40:                  
41:                  /* mapper 4: MMC3 */
42:                  static void map4_write(uint32 address, uint8 value)
43:                  {
9D030544  27BDFFE8   ADDIU SP, SP, -24
9D030548  AFBF0014   SW RA, 20(SP)
9D03054C  AFB00010   SW S0, 16(SP)
44:                     switch (address & 0xE001)
9D030550  3084E001   ANDI A0, A0, -8191
9D030554  3402C000   ORI V0, ZERO, -16384
9D030558  108200A2   BEQ A0, V0, 0x9D0307E4
9D03055C  00A08021   ADDU S0, A1, ZERO
9D030560  3402C001   ORI V0, ZERO, -16383
9D030564  0082102B   SLTU V0, A0, V0
9D030568  1040000A   BEQ V0, ZERO, 0x9D030594
9D03056C  3402E000   ORI V0, ZERO, -8192
9D030570  34028001   ORI V0, ZERO, -32767
9D030574  1082002E   BEQ A0, V0, 0x9D030630
9D030578  3402A000   ORI V0, ZERO, -24576
9D03057C  10820083   BEQ A0, V0, 0x9D03078C
9D030580  34028000   ORI V0, ZERO, -32768
9D030584  148200A7   BNE A0, V0, 0x9D030824
9D030588  3C02A001   LUI V0, -24575
9D030594  1082009C   BEQ A0, V0, 0x9D030808
9D030598  3402E001   ORI V0, ZERO, -8191
9D03059C  1082009D   BEQ A0, V0, 0x9D030814
9D0305A0  3402C001   ORI V0, ZERO, -16383
9D0305A4  5482009F   BNEL A0, V0, 0x9D030824
9D0305A8  3C02A001   LUI V0, -24575
45:                     {
46:                     case 0x8000:
47:                        command = value;
9D03058C  0B40C16D   J 0x9D0305B4
9D030590  A385806E   SB A1, -32658(GP)
48:                        vrombase = (command & 0x80) ? 0x1000 : 0x0000;
9D0305B4  000519C2   SRL V1, A1, 7
9D0305B8  24021000   ADDIU V0, ZERO, 4096
9D0305BC  0003100A   MOVZ V0, ZERO, V1
9D0305C0  A782806C   SH V0, -32660(GP)
49:                        
50:                        if (reg != (value & 0x40))
9D0305C4  30B00040   ANDI S0, A1, 64
9D0305C8  321000FF   ANDI S0, S0, 255
9D0305CC  9382806F   LBU V0, -32657(GP)
9D0305D0  50500093   BEQL V0, S0, 0x9D030820
9D0305D4  A390806F   SB S0, -32657(GP)
51:                        {
52:                           if (value & 0x40)
9D0305D8  1200000B   BEQ S0, ZERO, 0x9D030608
9D0305DC  00000000   NOP
53:                              mmc_bankrom(8, 0x8000, (mmc_getinfo()->rom_banks * 2) - 2);
9D0305E0  0F40B40F   JAL mmc_getinfo
9D0305E4  00000000   NOP
9D0305E8  8C460010   LW A2, 16(V0)
9D0305EC  24C6FFFF   ADDIU A2, A2, -1
9D0305F0  24040008   ADDIU A0, ZERO, 8
9D0305F4  34058000   ORI A1, ZERO, -32768
9D0305F8  0F40B479   JAL mmc_bankrom
9D0305FC  00063040   SLL A2, A2, 1
9D030600  0B40C208   J 0x9D030820
9D030604  A390806F   SB S0, -32657(GP)
54:                           else
55:                              mmc_bankrom(8, 0xC000, (mmc_getinfo()->rom_banks * 2) - 2);
9D030608  0F40B40F   JAL mmc_getinfo
9D03060C  00000000   NOP
9D030610  8C460010   LW A2, 16(V0)
9D030614  24C6FFFF   ADDIU A2, A2, -1
9D030618  24040008   ADDIU A0, ZERO, 8
9D03061C  3405C000   ORI A1, ZERO, -16384
9D030620  0F40B479   JAL mmc_bankrom
9D030624  00063040   SLL A2, A2, 1
56:                        }
57:                        reg = value & 0x40;
58:                        break;
9D030628  0B40C208   J 0x9D030820
9D03062C  A390806F   SB S0, -32657(GP)
59:                  
60:                     case 0x8001:
61:                        switch (command & 0x07)
9D030630  9382806E   LBU V0, -32658(GP)
9D030634  30440007   ANDI A0, V0, 7
9D030638  00042080   SLL A0, A0, 2
9D03063C  3C039D03   LUI V1, -25341
9D030640  24630654   ADDIU V1, V1, 1620
9D030644  00641821   ADDU V1, V1, A0
9D030648  8C630000   LW V1, 0(V1)
9D03064C  00600008   JR V1
9D030650  00000000   NOP
62:                        {
63:                        case 0:
64:                           value &= 0xFE;
65:                           mmc_bankvrom(1, vrombase ^ 0x0000, value);
9D030674  30B000FE   ANDI S0, A1, 254
9D030678  24040001   ADDIU A0, ZERO, 1
9D03067C  9785806C   LHU A1, -32660(GP)
9D030680  0F40B41B   JAL mmc_bankvrom
9D030684  02003021   ADDU A2, S0, ZERO
66:                           mmc_bankvrom(1, vrombase ^ 0x0400, value + 1);
9D030688  9785806C   LHU A1, -32660(GP)
9D03068C  24040001   ADDIU A0, ZERO, 1
9D030690  38A50400   XORI A1, A1, 1024
9D030694  0F40B41B   JAL mmc_bankvrom
9D030698  26060001   ADDIU A2, S0, 1
67:                           break;
9D03069C  0B40C209   J 0x9D030824
9D0306A0  3C02A001   LUI V0, -24575
68:                  
69:                        case 1:
70:                           value &= 0xFE;
71:                           mmc_bankvrom(1, vrombase ^ 0x0800, value);
9D0306A4  30B000FE   ANDI S0, A1, 254
9D0306A8  9785806C   LHU A1, -32660(GP)
9D0306AC  24040001   ADDIU A0, ZERO, 1
9D0306B0  38A50800   XORI A1, A1, 2048
9D0306B4  0F40B41B   JAL mmc_bankvrom
9D0306B8  02003021   ADDU A2, S0, ZERO
72:                           mmc_bankvrom(1, vrombase ^ 0x0C00, value + 1);
9D0306BC  9785806C   LHU A1, -32660(GP)
9D0306C0  24040001   ADDIU A0, ZERO, 1
9D0306C4  38A50C00   XORI A1, A1, 3072
9D0306C8  0F40B41B   JAL mmc_bankvrom
9D0306CC  26060001   ADDIU A2, S0, 1
73:                           break;
9D0306D0  0B40C209   J 0x9D030824
9D0306D4  3C02A001   LUI V0, -24575
74:                  
75:                        case 2:
76:                           mmc_bankvrom(1, vrombase ^ 0x1000, value);
9D0306D8  9785806C   LHU A1, -32660(GP)
9D0306DC  24040001   ADDIU A0, ZERO, 1
9D0306E0  38A51000   XORI A1, A1, 4096
9D0306E4  0F40B41B   JAL mmc_bankvrom
9D0306E8  02003021   ADDU A2, S0, ZERO
77:                           break;
9D0306EC  0B40C209   J 0x9D030824
9D0306F0  3C02A001   LUI V0, -24575
78:                  
79:                        case 3:
80:                           mmc_bankvrom(1, vrombase ^ 0x1400, value);
9D0306F4  9785806C   LHU A1, -32660(GP)
9D0306F8  24040001   ADDIU A0, ZERO, 1
9D0306FC  38A51400   XORI A1, A1, 5120
9D030700  0F40B41B   JAL mmc_bankvrom
9D030704  02003021   ADDU A2, S0, ZERO
81:                           break;
9D030708  0B40C209   J 0x9D030824
9D03070C  3C02A001   LUI V0, -24575
82:                  
83:                        case 4:
84:                           mmc_bankvrom(1, vrombase ^ 0x1800, value);
9D030710  9785806C   LHU A1, -32660(GP)
9D030714  24040001   ADDIU A0, ZERO, 1
9D030718  38A51800   XORI A1, A1, 6144
9D03071C  0F40B41B   JAL mmc_bankvrom
9D030720  02003021   ADDU A2, S0, ZERO
85:                           break;
9D030724  0B40C209   J 0x9D030824
9D030728  3C02A001   LUI V0, -24575
86:                  
87:                        case 5:
88:                           mmc_bankvrom(1, vrombase ^ 0x1C00, value);
9D03072C  9785806C   LHU A1, -32660(GP)
9D030730  24040001   ADDIU A0, ZERO, 1
9D030734  38A51C00   XORI A1, A1, 7168
9D030738  0F40B41B   JAL mmc_bankvrom
9D03073C  02003021   ADDU A2, S0, ZERO
89:                           break;
9D030740  0B40C209   J 0x9D030824
9D030744  3C02A001   LUI V0, -24575
90:                  
91:                        case 6:
92:                           mmc_bankrom(8, (command & 0x40) ? 0xC000 : 0x8000, value);
9D030748  30420040   ANDI V0, V0, 64
9D03074C  304500FF   ANDI A1, V0, 255
9D030750  24040008   ADDIU A0, ZERO, 8
9D030754  3402C000   ORI V0, ZERO, -16384
9D030758  34038000   ORI V1, ZERO, -32768
9D03075C  0065100A   MOVZ V0, V1, A1
9D030760  00402821   ADDU A1, V0, ZERO
9D030764  0F40B479   JAL mmc_bankrom
9D030768  02003021   ADDU A2, S0, ZERO
93:                           break;
9D03076C  0B40C209   J 0x9D030824
9D030770  3C02A001   LUI V0, -24575
94:                  
95:                        case 7:
96:                           mmc_bankrom(8, 0xA000, value);
9D030774  24040008   ADDIU A0, ZERO, 8
9D030778  3405A000   ORI A1, ZERO, -24576
9D03077C  0F40B479   JAL mmc_bankrom
9D030780  02003021   ADDU A2, S0, ZERO
97:                           break;
9D030784  0B40C209   J 0x9D030824
9D030788  3C02A001   LUI V0, -24575
98:                        }
99:                        break;
100:                 
101:                    case 0xA000:
102:                       /* four screen mirroring crap */
103:                       if (0 == (mmc_getinfo()->flags & ROM_FLAG_FOURSCREEN))
9D03078C  0F40B40F   JAL mmc_getinfo
9D030790  00000000   NOP
9D030794  90420028   LBU V0, 40(V0)
9D030798  30420004   ANDI V0, V0, 4
9D03079C  304200FF   ANDI V0, V0, 255
9D0307A0  14400020   BNE V0, ZERO, 0x9D030824
9D0307A4  3C02A001   LUI V0, -24575
104:                       {
105:                          if (value & 1)
9D0307A8  32100001   ANDI S0, S0, 1
9D0307AC  12000007   BEQ S0, ZERO, 0x9D0307CC
9D0307B0  00002021   ADDU A0, ZERO, ZERO
106:                             ppu_mirror(0, 0, 1, 1); /* horizontal */
9D0307B4  00002821   ADDU A1, ZERO, ZERO
9D0307B8  24060001   ADDIU A2, ZERO, 1
9D0307BC  0F40635D   JAL ppu_mirror
9D0307C0  24070001   ADDIU A3, ZERO, 1
9D0307C4  0B40C209   J 0x9D030824
9D0307C8  3C02A001   LUI V0, -24575
107:                          else
108:                             ppu_mirror(0, 1, 0, 1); /* vertical */
9D0307CC  24050001   ADDIU A1, ZERO, 1
9D0307D0  00003021   ADDU A2, ZERO, ZERO
9D0307D4  0F40635D   JAL ppu_mirror
9D0307D8  24070001   ADDIU A3, ZERO, 1
109:                       }
110:                       break;
111:                 
112:                    case 0xA001:
113:                       /* Save RAM enable / disable */
114:                       /* Messes up Startropics I/II if implemented -- bah */
115:                       break;
116:                 
117:                    case 0xC000:
118:                       irq.latch = value;
9D0307E4  3C02A001   LUI V0, -24575
119:                 //      if (irq.reset)
120:                 //         irq.counter = irq.latch;
121:                       break;
9D0307E8  0B40C208   J 0x9D030820
9D0307EC  AC45B880   SW A1, -18304(V0)
122:                 
123:                    case 0xC001:
124:                       irq.reset = true;
9D0305AC  0B40C1FC   J 0x9D0307F0
9D0305B0  3C02A001   LUI V0, -24575
9D0307F0  2443B87C   ADDIU V1, V0, -18308
9D0307F4  24040001   ADDIU A0, ZERO, 1
9D0307F8  AC64000C   SW A0, 12(V1)
125:                       irq.counter = irq.latch;
9D0307FC  8C630004   LW V1, 4(V1)
126:                       break;
9D030800  0B40C208   J 0x9D030820
9D030804  AC43B87C   SW V1, -18308(V0)
127:                 
128:                    case 0xE000:
129:                       irq.enabled = false;
9D030808  3C02A001   LUI V0, -24575
130:                 //      if (irq.reset)
131:                 //         irq.counter = irq.latch;
132:                       break;
9D03080C  0B40C208   J 0x9D030820
9D030810  AC40B884   SW ZERO, -18300(V0)
133:                 
134:                    case 0xE001:
135:                       irq.enabled = true;
9D030814  24030001   ADDIU V1, ZERO, 1
9D030818  3C02A001   LUI V0, -24575
9D03081C  AC43B884   SW V1, -18300(V0)
136:                 //      if (irq.reset)
137:                 //         irq.counter = irq.latch;
138:                       break;
139:                 
140:                    default:
141:                       break;
142:                    }
143:                 
144:                    if (true == irq.reset)
9D0307DC  0B40C209   J 0x9D030824
9D0307E0  3C02A001   LUI V0, -24575
9D030820  3C02A001   LUI V0, -24575
9D030824  8C43B888   LW V1, -18296(V0)
9D030828  24020001   ADDIU V0, ZERO, 1
9D03082C  14620006   BNE V1, V0, 0x9D030848
9D030830  8FBF0014   LW RA, 20(SP)
145:                       irq.counter = irq.latch;
9D030834  3C02A001   LUI V0, -24575
9D030838  2443B87C   ADDIU V1, V0, -18308
9D03083C  8C630004   LW V1, 4(V1)
9D030840  AC43B87C   SW V1, -18308(V0)
146:                 }
9D030844  8FBF0014   LW RA, 20(SP)
9D030848  8FB00010   LW S0, 16(SP)
9D03084C  03E00008   JR RA
9D030850  27BD0018   ADDIU SP, SP, 24
147:                 
148:                 static void map4_hblank(int vblank)
149:                 {
9D03085C  27BDFFE8   ADDIU SP, SP, -24
9D030860  AFBF0014   SW RA, 20(SP)
150:                    if (vblank)
9D030854  14800019   BNE A0, ZERO, 0x9D0308BC
9D030858  00000000   NOP
151:                       return;
152:                 
153:                    if (ppu_enabled())
9D030864  0F4065CC   JAL ppu_enabled
9D030868  00000000   NOP
9D03086C  10400011   BEQ V0, ZERO, .LVL44
9D030870  3C02A001   LUI V0, -24575
154:                    {
155:                       if (irq.counter >= 0)
9D030874  8C42B87C   LW V0, -18308(V0)
9D030878  0440000E   BLTZ V0, .LVL44
9D03087C  3C03A001   LUI V1, -24575
156:                       {
157:                          irq.reset = false;
9D030880  2464B87C   ADDIU A0, V1, -18308
9D030884  AC80000C   SW ZERO, 12(A0)
158:                          irq.counter--;
9D030888  2442FFFF   ADDIU V0, V0, -1
159:                 
160:                          if (irq.counter < 0)
9D03088C  04410009   BGEZ V0, .LVL44
9D030890  AC62B87C   SW V0, -18308(V1)
161:                          {
162:                             if (irq.enabled)
9D030894  3C02A001   LUI V0, -24575
9D030898  8C42B884   LW V0, -18300(V0)
9D03089C  10400006   BEQ V0, ZERO, 0x9D0308B8
9D0308A0  8FBF0014   LW RA, 20(SP)
163:                             {
164:                                irq.reset = true;
9D0308A4  24030001   ADDIU V1, ZERO, 1
9D0308A8  3C02A001   LUI V0, -24575
165:                                nes_irq();
9D0308AC  0F408C7B   JAL nes_irq
9D0308B0  AC43B888   SW V1, -18296(V0)
166:                             }
167:                          }
168:                       }
169:                    }
170:                 }
9D0308B4  8FBF0014   LW RA, 20(SP)
9D0308B8  27BD0018   ADDIU SP, SP, 24
9D0308BC  03E00008   JR RA
9D0308C0  00000000   NOP
171:                 
172:                 static void map4_getstate(SnssMapperBlock *state)
173:                 {
174:                    state->extraData.mapper4.irqCounter = irq.counter;
9D0304C4  3C02A001   LUI V0, -24575
9D0304C8  8C43B87C   LW V1, -18308(V0)
9D0304CC  A0830018   SB V1, 24(A0)
175:                    state->extraData.mapper4.irqLatchCounter = irq.latch;
9D0304D0  2442B87C   ADDIU V0, V0, -18308
9D0304D4  8C430004   LW V1, 4(V0)
9D0304D8  A0830019   SB V1, 25(A0)
176:                    state->extraData.mapper4.irqCounterEnabled = irq.enabled;
9D0304DC  8C420008   LW V0, 8(V0)
9D0304E0  A082001A   SB V0, 26(A0)
177:                    state->extraData.mapper4.last8000Write = command;
9D0304E4  9382806E   LBU V0, -32658(GP)
9D0304E8  03E00008   JR RA
9D0304EC  A082001B   SB V0, 27(A0)
178:                 }
179:                 
180:                 static void map4_setstate(SnssMapperBlock *state)
181:                 {
182:                    irq.counter = state->extraData.mapper4.irqCounter;
9D0304F0  3C02A001   LUI V0, -24575
9D0304F4  90830018   LBU V1, 24(A0)
9D0304F8  AC43B87C   SW V1, -18308(V0)
183:                    irq.latch = state->extraData.mapper4.irqLatchCounter;
9D0304FC  2442B87C   ADDIU V0, V0, -18308
9D030500  90830019   LBU V1, 25(A0)
9D030504  AC430004   SW V1, 4(V0)
184:                    irq.enabled = state->extraData.mapper4.irqCounterEnabled;
9D030508  9083001A   LBU V1, 26(A0)
9D03050C  AC430008   SW V1, 8(V0)
185:                    command = state->extraData.mapper4.last8000Write;
9D030510  9082001B   LBU V0, 27(A0)
9D030514  03E00008   JR RA
9D030518  A382806E   SB V0, -32658(GP)
186:                 }
187:                 
188:                 static void map4_init(void)
189:                 {
190:                    irq.counter = irq.latch = 0;
9D03051C  3C03A001   LUI V1, -24575
9D030520  2462B87C   ADDIU V0, V1, -18308
9D030524  AC400004   SW ZERO, 4(V0)
9D030528  AC60B87C   SW ZERO, -18308(V1)
191:                    irq.enabled = irq.reset = false;
9D03052C  AC40000C   SW ZERO, 12(V0)
9D030530  AC400008   SW ZERO, 8(V0)
192:                    reg = command = 0;
9D030534  A380806E   SB ZERO, -32658(GP)
9D030538  A380806F   SB ZERO, -32657(GP)
193:                    vrombase = 0x0000;
9D03053C  03E00008   JR RA
9D030540  A780806C   SH ZERO, -32660(GP)
194:                 }
195:                 
196:                 static map_memwrite map4_memwrite[] =
197:                 {
198:                    { 0x8000, 0xFFFF, map4_write },
199:                    {     -1,     -1, NULL }
200:                 };
201:                 
202:                 mapintf_t map4_intf =
203:                 {
204:                    4, /* mapper number */
205:                    "MMC3", /* mapper name */
206:                    map4_init, /* init routine */
207:                    NULL, /* vblank callback */
208:                    map4_hblank, /* hblank callback */
209:                    map4_getstate, /* get state (snss) */
210:                    map4_setstate, /* set state (snss) */
211:                    NULL, /* memory read structure */
212:                    map4_memwrite, /* memory write structure */
213:                    NULL /* external sound device */
214:                 };
215:                 
216:                 /*
217:                 ** $Log: map004.c,v $
218:                 ** Revision 1.2  2001/04/27 14:37:11  neil
219:                 ** wheeee
220:                 **
221:                 ** Revision 1.1  2001/04/27 12:54:40  neil
222:                 ** blah
223:                 **
224:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
225:                 ** initial
226:                 **
227:                 ** Revision 1.2  2000/11/26 15:40:49  matt
228:                 ** hey, it actually works now
229:                 **
230:                 ** Revision 1.1  2000/10/24 12:19:32  matt
231:                 ** changed directory structure
232:                 **
233:                 ** Revision 1.12  2000/10/23 15:53:27  matt
234:                 ** suppressed warnings
235:                 **
236:                 ** Revision 1.11  2000/10/22 19:17:46  matt
237:                 ** mapper cleanups galore
238:                 **
239:                 ** Revision 1.10  2000/10/22 15:03:13  matt
240:                 ** simplified mirroring
241:                 **
242:                 ** Revision 1.9  2000/10/21 19:33:38  matt
243:                 ** many more cleanups
244:                 **
245:                 ** Revision 1.8  2000/10/10 13:58:17  matt
246:                 ** stroustrup squeezing his way in the door
247:                 **
248:                 ** Revision 1.7  2000/10/08 18:05:44  matt
249:                 ** kept old version around, just in case....
250:                 **
251:                 ** Revision 1.6  2000/07/15 23:52:19  matt
252:                 ** rounded out a bunch more mapper interfaces
253:                 **
254:                 ** Revision 1.5  2000/07/10 13:51:25  matt
255:                 ** using generic nes_irq() routine now
256:                 **
257:                 ** Revision 1.4  2000/07/10 05:29:03  matt
258:                 ** cleaned up some mirroring issues
259:                 **
260:                 ** Revision 1.3  2000/07/06 02:48:43  matt
261:                 ** clearly labelled structure members
262:                 **
263:                 ** Revision 1.2  2000/07/05 05:04:39  matt
264:                 ** minor modifications
265:                 **
266:                 ** Revision 1.1  2000/07/04 23:11:45  matt
267:                 ** initial revision
268:                 **
269:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map003.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map3.c
21:                  **
22:                  ** mapper 3 interface
23:                  ** $Id: map003.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  
29:                  /* mapper 3: CNROM */
30:                  static void map3_write(uint32 address, uint8 value)
31:                  {
9D03C738  27BDFFE8   ADDIU SP, SP, -24
9D03C73C  AFBF0014   SW RA, 20(SP)
9D03C740  00A03021   ADDU A2, A1, ZERO
32:                     UNUSED(address);
33:                  
34:                     mmc_bankvrom(8, 0x0000, value);
9D03C744  24040008   ADDIU A0, ZERO, 8
9D03C748  0F40B41B   JAL mmc_bankvrom
9D03C74C  00002821   ADDU A1, ZERO, ZERO
35:                  }
9D03C750  8FBF0014   LW RA, 20(SP)
9D03C754  03E00008   JR RA
9D03C758  27BD0018   ADDIU SP, SP, 24
36:                  
37:                  static map_memwrite map3_memwrite[] =
38:                  {
39:                     { 0x8000, 0xFFFF, map3_write },
40:                     {     -1,     -1, NULL }
41:                  };
42:                  
43:                  mapintf_t map3_intf =
44:                  {
45:                     3, /* mapper number */
46:                     "CNROM", /* mapper name */
47:                     NULL, /* init routine */
48:                     NULL, /* vblank callback */
49:                     NULL, /* hblank callback */
50:                     NULL, /* get state (snss) */
51:                     NULL, /* set state (snss) */
52:                     NULL, /* memory read structure */
53:                     map3_memwrite, /* memory write structure */
54:                     NULL /* external sound device */
55:                  };
56:                  
57:                  /*
58:                  ** $Log: map003.c,v $
59:                  ** Revision 1.2  2001/04/27 14:37:11  neil
60:                  ** wheeee
61:                  **
62:                  ** Revision 1.1  2001/04/27 12:54:40  neil
63:                  ** blah
64:                  **
65:                  ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
66:                  ** initial
67:                  **
68:                  ** Revision 1.1  2000/10/24 12:19:32  matt
69:                  ** changed directory structure
70:                  **
71:                  ** Revision 1.5  2000/10/22 19:17:46  matt
72:                  ** mapper cleanups galore
73:                  **
74:                  ** Revision 1.4  2000/10/21 19:33:38  matt
75:                  ** many more cleanups
76:                  **
77:                  ** Revision 1.3  2000/08/16 02:50:11  matt
78:                  ** random mapper cleanups
79:                  **
80:                  ** Revision 1.2  2000/07/06 02:48:43  matt
81:                  ** clearly labelled structure members
82:                  **
83:                  ** Revision 1.1  2000/07/04 23:11:45  matt
84:                  ** initial revision
85:                  **
86:                  */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map002.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map2.c
21:                  **
22:                  ** mapper 2 interface
23:                  ** $Id: map002.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  
29:                  /* mapper 2: UNROM */
30:                  static void map2_write(uint32 address, uint8 value)
31:                  {
9D03C780  27BDFFE8   ADDIU SP, SP, -24
9D03C784  AFBF0014   SW RA, 20(SP)
9D03C788  00A03021   ADDU A2, A1, ZERO
32:                     UNUSED(address);
33:                  
34:                     mmc_bankrom(16, 0x8000, value);
9D03C78C  24040010   ADDIU A0, ZERO, 16
9D03C790  0F40B479   JAL mmc_bankrom
9D03C794  34058000   ORI A1, ZERO, -32768
35:                  }
9D03C798  8FBF0014   LW RA, 20(SP)
9D03C79C  03E00008   JR RA
9D03C7A0  27BD0018   ADDIU SP, SP, 24
36:                  
37:                  static map_memwrite map2_memwrite[] =
38:                  {
39:                     { 0x8000, 0xFFFF, map2_write },
40:                     {     -1,     -1, NULL }
41:                  };
42:                  
43:                  mapintf_t map2_intf =
44:                  {
45:                     2, /* mapper number */
46:                     "UNROM", /* mapper name */
47:                     NULL, /* init routine */
48:                     NULL, /* vblank callback */
49:                     NULL, /* hblank callback */
50:                     NULL, /* get state (snss) */
51:                     NULL, /* set state (snss) */
52:                     NULL, /* memory read structure */
53:                     map2_memwrite, /* memory write structure */
54:                     NULL /* external sound device */
55:                  };
56:                  
57:                  /*
58:                  ** $Log: map002.c,v $
59:                  ** Revision 1.2  2001/04/27 14:37:11  neil
60:                  ** wheeee
61:                  **
62:                  ** Revision 1.1  2001/04/27 12:54:40  neil
63:                  ** blah
64:                  **
65:                  ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
66:                  ** initial
67:                  **
68:                  ** Revision 1.1  2000/10/24 12:19:32  matt
69:                  ** changed directory structure
70:                  **
71:                  ** Revision 1.5  2000/10/22 19:17:46  matt
72:                  ** mapper cleanups galore
73:                  **
74:                  ** Revision 1.4  2000/10/21 19:33:38  matt
75:                  ** many more cleanups
76:                  **
77:                  ** Revision 1.3  2000/08/16 02:50:11  matt
78:                  ** random mapper cleanups
79:                  **
80:                  ** Revision 1.2  2000/07/06 02:48:43  matt
81:                  ** clearly labelled structure members
82:                  **
83:                  ** Revision 1.1  2000/07/04 23:11:45  matt
84:                  ** initial revision
85:                  **
86:                  */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map001.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map1.c
21:                  **
22:                  ** mapper 1 interface
23:                  ** $Id: map001.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <string.h>
27:                  #include <noftypes.h>
28:                  #include <nes_mmc.h>
29:                  #include <nes_ppu.h>
30:                  
31:                  /* TODO: WRAM enable ala Mark Knibbs:
32:                     ==================================
33:                  The SNROM board uses 8K CHR-RAM. The CHR-RAM is paged (i.e. it can be split
34:                  into two 4Kbyte pages).
35:                  
36:                  The CRA16 line of the MMC1 is connected to the /CS1 pin of the WRAM. THIS MEANS
37:                  THAT THE WRAM CAN BE ENABLED OR DISABLED ACCORDING TO THE STATE OF THE CRA16
38:                  LINE. The CRA16 line corresponds to bit 4 of MMC1 registers 1 & 2.
39:                  
40:                  The WRAM is enabled when the CRA16 line is low, and disabled when CRA16 is
41:                  high. This has implications when CHR page size is 4K, if the two page numbers
42:                  set have different CRA16 states (e.g. reg 1 bit 4 = 0, reg 2 bit 4 = 1). Then
43:                  the WRAM will be enabled and disabled depending on what CHR address is being
44:                  accessed.
45:                  
46:                  When CHR page size is 8K, bit 4 of MMC1 register 1 (and not register 2, because
47:                  page size is 8K) controls whether the WRAM is enabled or not. It must be low
48:                  to be enabled. When the WRAM is disabled, reading from and writing to it will
49:                  not be possible.
50:                  */
51:                  
52:                  /* TODO: roll this into something... */
53:                  static int bitcount = 0;
54:                  static uint8 latch = 0;
55:                  static uint8 regs[4];
56:                  static int bank_select;
57:                  static uint8 lastreg;
58:                  
59:                  static void map1_write(uint32 address, uint8 value)
60:                  {
9D031BB0  27BDFFE8   ADDIU SP, SP, -24
9D031BB4  AFBF0014   SW RA, 20(SP)
61:                     int regnum = (address >> 13) - 4;
9D031BB8  00042342   SRL A0, A0, 13
62:                  
63:                     if (value & 0x80)
9D031BBC  7C051C20   SEB V1, A1
9D031BC0  04610008   BGEZ V1, 0x9D031BE4
9D031BC4  2484FFFC   ADDIU A0, A0, -4
64:                     {
65:                        regs[0] |= 0x0C;
9D031BC8  278280E4   ADDIU V0, GP, -32540
9D031BCC  90430000   LBU V1, 0(V0)
9D031BD0  3463000C   ORI V1, V1, 12
9D031BD4  A0430000   SB V1, 0(V0)
66:                        bitcount = 0;
9D031BD8  AF8080EC   SW ZERO, -32532(GP)
67:                        latch = 0;
68:                        return;
9D031BDC  0B40C793   J .LVL29
9D031BE0  A38080E8   SB ZERO, -32536(GP)
69:                     }
70:                  
71:                     if (lastreg != regnum)
9D031BE4  938380DC   LBU V1, -32548(GP)
9D031BE8  10640004   BEQ V1, A0, 0x9D031BFC
9D031BEC  00801021   ADDU V0, A0, ZERO
72:                     {
73:                        bitcount = 0;
9D031BF0  AF8080EC   SW ZERO, -32532(GP)
74:                        latch = 0;
9D031BF4  A38080E8   SB ZERO, -32536(GP)
75:                        lastreg = regnum;
9D031BF8  A38480DC   SB A0, -32548(GP)
76:                     }
77:                     //lastreg = regnum;
78:                  
79:                     latch |= ((value & 1) << bitcount++);
9D031BFC  8F8680EC   LW A2, -32532(GP)
9D031C00  24C30001   ADDIU V1, A2, 1
9D031C04  AF8380EC   SW V1, -32532(GP)
9D031C08  30A50001   ANDI A1, A1, 1
9D031C0C  00C53004   SLLV A2, A1, A2
9D031C10  938780E8   LBU A3, -32536(GP)
9D031C14  00C73025   OR A2, A2, A3
9D031C18  30C600FF   ANDI A2, A2, 255
80:                  
81:                     /* 5 bit registers */
82:                     if (5 != bitcount)
9D031C1C  24050005   ADDIU A1, ZERO, 5
9D031C20  1465008A   BNE V1, A1, .LVL29
9D031C24  A38680E8   SB A2, -32536(GP)
83:                        return;
84:                  
85:                     regs[regnum] = latch;
9D031C28  278380E4   ADDIU V1, GP, -32540
9D031C2C  00641821   ADDU V1, V1, A0
9D031C30  A0660000   SB A2, 0(V1)
86:                     value = latch;
87:                     bitcount = 0;
9D031C34  AF8080EC   SW ZERO, -32532(GP)
88:                     latch = 0;
89:                  
90:                     switch (regnum)
9D031C38  24030001   ADDIU V1, ZERO, 1
9D031C3C  10430026   BEQ V0, V1, 0x9D031CD8
9D031C40  A38080E8   SB ZERO, -32536(GP)
9D031C44  28840002   SLTI A0, A0, 2
9D031C48  50800005   BEQL A0, ZERO, 0x9D031C60
9D031C4C  24030002   ADDIU V1, ZERO, 2
9D031C50  10400009   BEQ V0, ZERO, 0x9D031C78
9D031C54  30C20002   ANDI V0, A2, 2
9D031C60  1043002C   BEQ V0, V1, 0x9D031D14
9D031C64  24030003   ADDIU V1, ZERO, 3
9D031C68  10430034   BEQ V0, V1, 0x9D031D3C
9D031C6C  8FBF0014   LW RA, 20(SP)
9D031C70  0B40C794   J 0x9D031E50
9D031C74  00000000   NOP
91:                     {
92:                     case 0:
93:                        {
94:                           if (0 == (value & 2))
9D031C78  304200FF   ANDI V0, V0, 255
9D031C7C  54400008   BNEL V0, ZERO, 0x9D031CA0
9D031C80  30C60001   ANDI A2, A2, 1
95:                           {
96:                              int mirror = value & 1;
9D031C84  30C70001   ANDI A3, A2, 1
97:                              ppu_mirror(mirror, mirror, mirror, mirror);
9D031C88  00E02021   ADDU A0, A3, ZERO
9D031C8C  00E02821   ADDU A1, A3, ZERO
9D031C90  0F40635D   JAL ppu_mirror
9D031C94  00E03021   ADDU A2, A3, ZERO
9D031C98  0B40C794   J 0x9D031E50
9D031C9C  8FBF0014   LW RA, 20(SP)
98:                           }
99:                           else
100:                          {
101:                             if (value & 1)
9D031CA0  10C00007   BEQ A2, ZERO, 0x9D031CC0
9D031CA4  00002021   ADDU A0, ZERO, ZERO
102:                                ppu_mirror(0, 0, 1, 1);
9D031CA8  00002821   ADDU A1, ZERO, ZERO
9D031CAC  24060001   ADDIU A2, ZERO, 1
9D031CB0  0F40635D   JAL ppu_mirror
9D031CB4  24070001   ADDIU A3, ZERO, 1
9D031CB8  0B40C794   J 0x9D031E50
9D031CBC  8FBF0014   LW RA, 20(SP)
103:                             else
104:                                ppu_mirror(0, 1, 0, 1);
9D031CC0  24050001   ADDIU A1, ZERO, 1
9D031CC4  00003021   ADDU A2, ZERO, ZERO
9D031CC8  0F40635D   JAL ppu_mirror
9D031CCC  24070001   ADDIU A3, ZERO, 1
105:                          }
106:                       }
107:                       break;
108:                 
109:                    case 1:
110:                       if (regs[0] & 0x10)
9D031CD8  938280E4   LBU V0, -32540(GP)
9D031CDC  30420010   ANDI V0, V0, 16
9D031CE0  304200FF   ANDI V0, V0, 255
9D031CE4  10400006   BEQ V0, ZERO, 0x9D031D00
9D031CE8  24040008   ADDIU A0, ZERO, 8
111:                          mmc_bankvrom(4, 0x0000, value);
9D031CEC  24040004   ADDIU A0, ZERO, 4
9D031CF0  0F40B41B   JAL mmc_bankvrom
9D031CF4  00002821   ADDU A1, ZERO, ZERO
9D031CF8  0B40C794   J 0x9D031E50
9D031CFC  8FBF0014   LW RA, 20(SP)
112:                       else
113:                          mmc_bankvrom(8, 0x0000, value >> 1);
9D031D00  00002821   ADDU A1, ZERO, ZERO
9D031D04  0F40B41B   JAL mmc_bankvrom
9D031D08  00063042   SRL A2, A2, 1
114:                       break;
115:                 
116:                    case 2:
117:                       if (regs[0] & 0x10)
9D031D14  938280E4   LBU V0, -32540(GP)
9D031D18  30420010   ANDI V0, V0, 16
9D031D1C  304200FF   ANDI V0, V0, 255
9D031D20  5040004B   BEQL V0, ZERO, 0x9D031E50
9D031D24  8FBF0014   LW RA, 20(SP)
118:                          mmc_bankvrom(4, 0x1000, value);
9D031D28  24040004   ADDIU A0, ZERO, 4
9D031D2C  0F40B41B   JAL mmc_bankvrom
9D031D30  24051000   ADDIU A1, ZERO, 4096
119:                       break;
120:                 
121:                    case 3:
122:                       if (mmc_getinfo()->rom_banks == 0x20)
9D031D3C  0F40B40F   JAL mmc_getinfo
9D031D40  00000000   NOP
9D031D44  8C430010   LW V1, 16(V0)
9D031D48  24020020   ADDIU V0, ZERO, 32
9D031D4C  14620007   BNE V1, V0, 0x9D031D6C
9D031D50  938380E5   LBU V1, -32539(GP)
123:                       {
124:                          bank_select = (regs[1] & 0x10) ? 0 : 0x10;
9D031D54  30630010   ANDI V1, V1, 16
9D031D58  306300FF   ANDI V1, V1, 255
9D031D5C  24020010   ADDIU V0, ZERO, 16
9D031D60  0003100B   MOVN V0, ZERO, V1
9D031D64  0B40C773   J 0x9D031DCC
9D031D68  AF8280E0   SW V0, -32544(GP)
125:                       }
126:                       else if (mmc_getinfo()->rom_banks == 0x40)
9D031D6C  0F40B40F   JAL mmc_getinfo
9D031D70  00000000   NOP
9D031D74  8C430010   LW V1, 16(V0)
9D031D78  24020040   ADDIU V0, ZERO, 64
9D031D7C  54620013   BNEL V1, V0, 0x9D031DCC
9D031D80  AF8080E0   SW ZERO, -32544(GP)
127:                       {
128:                          if (regs[0] & 0x10)
9D031D84  938280E4   LBU V0, -32540(GP)
9D031D88  30420010   ANDI V0, V0, 16
9D031D8C  304200FF   ANDI V0, V0, 255
9D031D90  1040000A   BEQ V0, ZERO, 0x9D031DBC
9D031D94  938280E5   LBU V0, -32539(GP)
129:                             bank_select = (regs[1] & 0x10) | ((regs[2] & 0x10) << 1);
9D031D98  938280E6   LBU V0, -32538(GP)
9D031D9C  30420010   ANDI V0, V0, 16
9D031DA0  304200FF   ANDI V0, V0, 255
9D031DA4  00021040   SLL V0, V0, 1
9D031DA8  938380E5   LBU V1, -32539(GP)
9D031DAC  30630010   ANDI V1, V1, 16
9D031DB0  00621025   OR V0, V1, V0
9D031DB4  0B40C773   J 0x9D031DCC
9D031DB8  AF8280E0   SW V0, -32544(GP)
130:                          else
131:                             bank_select = (regs[1] & 0x10) << 1;
9D031DBC  30420010   ANDI V0, V0, 16
9D031DC0  304200FF   ANDI V0, V0, 255
9D031DC4  00021040   SLL V0, V0, 1
9D031DC8  AF8280E0   SW V0, -32544(GP)
132:                       }
133:                       else
134:                       {
135:                          bank_select = 0;
136:                       }
137:                    
138:                       if (0 == (regs[0] & 0x08))
9D031DCC  938280E4   LBU V0, -32540(GP)
9D031DD0  30430008   ANDI V1, V0, 8
9D031DD4  306300FF   ANDI V1, V1, 255
9D031DD8  1460000B   BNE V1, ZERO, 0x9D031E08
9D031DDC  30420004   ANDI V0, V0, 4
139:                          mmc_bankrom(32, 0x8000, ((regs[3] >> 1) + (bank_select >> 1)));
9D031DE0  938680E7   LBU A2, -32537(GP)
9D031DE4  00063042   SRL A2, A2, 1
9D031DE8  8F8280E0   LW V0, -32544(GP)
9D031DEC  00021043   SRA V0, V0, 1
9D031DF0  24040020   ADDIU A0, ZERO, 32
9D031DF4  34058000   ORI A1, ZERO, -32768
9D031DF8  0F40B479   JAL mmc_bankrom
9D031DFC  00C23021   ADDU A2, A2, V0
9D031E00  0B40C794   J 0x9D031E50
9D031E04  8FBF0014   LW RA, 20(SP)
140:                       else if (regs[0] & 0x04)
9D031E08  304200FF   ANDI V0, V0, 255
9D031E0C  10400009   BEQ V0, ZERO, 0x9D031E34
9D031E10  938680E7   LBU A2, -32537(GP)
141:                          mmc_bankrom(16, 0x8000, ((regs[3] & 0xF) + bank_select));
9D031E14  30C6000F   ANDI A2, A2, 15
9D031E18  24040010   ADDIU A0, ZERO, 16
9D031E1C  34058000   ORI A1, ZERO, -32768
9D031E20  8F8280E0   LW V0, -32544(GP)
9D031E24  0F40B479   JAL mmc_bankrom
9D031E28  00C23021   ADDU A2, A2, V0
9D031E2C  0B40C794   J 0x9D031E50
9D031E30  8FBF0014   LW RA, 20(SP)
142:                       else
143:                          mmc_bankrom(16, 0xC000, ((regs[3] & 0xF) + bank_select));
9D031E34  30C6000F   ANDI A2, A2, 15
9D031E38  24040010   ADDIU A0, ZERO, 16
9D031E3C  3405C000   ORI A1, ZERO, -16384
9D031E40  8F8280E0   LW V0, -32544(GP)
9D031E44  0F40B479   JAL mmc_bankrom
9D031E48  00C23021   ADDU A2, A2, V0
144:                 
145:                    default:
146:                       break;
147:                    }
148:                 }
9D031C58  0B40C794   J 0x9D031E50
9D031C5C  8FBF0014   LW RA, 20(SP)
9D031CD0  0B40C794   J 0x9D031E50
9D031CD4  8FBF0014   LW RA, 20(SP)
9D031D0C  0B40C794   J 0x9D031E50
9D031D10  8FBF0014   LW RA, 20(SP)
9D031D34  0B40C794   J 0x9D031E50
9D031D38  8FBF0014   LW RA, 20(SP)
9D031E4C  8FBF0014   LW RA, 20(SP)
9D031E50  03E00008   JR RA
9D031E54  27BD0018   ADDIU SP, SP, 24
149:                 
150:                 static void map1_init(void)
151:                 {
9D031E58  27BDFFE8   ADDIU SP, SP, -24
9D031E5C  AFBF0014   SW RA, 20(SP)
152:                    bitcount = 0;
9D031E60  AF8080EC   SW ZERO, -32532(GP)
153:                    latch = 0;
9D031E64  A38080E8   SB ZERO, -32536(GP)
154:                 
155:                    memset(regs, 0, sizeof(regs));
156:                 
157:                    if (mmc_getinfo()->rom_banks == 0x20)
9D031E68  0F40B40F   JAL mmc_getinfo
9D031E6C  AF8080E4   SW ZERO, -32540(GP)
9D031E70  8C430010   LW V1, 16(V0)
9D031E74  24020020   ADDIU V0, ZERO, 32
9D031E78  14620006   BNE V1, V0, 0x9D031E94
9D031E7C  34048000   ORI A0, ZERO, -32768
158:                       mmc_bankrom(16, 0xC000, 0x0F);
9D031E80  24040010   ADDIU A0, ZERO, 16
9D031E84  3405C000   ORI A1, ZERO, -16384
9D031E88  0F40B479   JAL mmc_bankrom
9D031E8C  2406000F   ADDIU A2, ZERO, 15
159:                 
160:                    map1_write(0x8000, 0x80);
9D031E90  34048000   ORI A0, ZERO, -32768
9D031E94  0F40C6EC   JAL .LFB5, map1_write, .LFE8
9D031E98  24050080   ADDIU A1, ZERO, 128
161:                 }
9D031E9C  8FBF0014   LW RA, 20(SP)
9D031EA0  03E00008   JR RA
9D031EA4  27BD0018   ADDIU SP, SP, 24
162:                 
163:                 static void map1_getstate(SnssMapperBlock *state)
164:                 {
165:                    state->extraData.mapper1.registers[0] = regs[0];
9D031B50  938280E4   LBU V0, -32540(GP)
9D031B54  A0820018   SB V0, 24(A0)
166:                    state->extraData.mapper1.registers[1] = regs[1];
9D031B58  938280E5   LBU V0, -32539(GP)
9D031B5C  A0820019   SB V0, 25(A0)
167:                    state->extraData.mapper1.registers[2] = regs[2];
9D031B60  938280E6   LBU V0, -32538(GP)
9D031B64  A082001A   SB V0, 26(A0)
168:                    state->extraData.mapper1.registers[3] = regs[3];
9D031B68  938280E7   LBU V0, -32537(GP)
9D031B6C  A082001B   SB V0, 27(A0)
169:                    state->extraData.mapper1.latch = latch;
9D031B70  938280E8   LBU V0, -32536(GP)
9D031B74  A082001C   SB V0, 28(A0)
170:                    state->extraData.mapper1.numberOfBits = bitcount;
9D031B78  8F8280EC   LW V0, -32532(GP)
9D031B7C  03E00008   JR RA
9D031B80  A082001D   SB V0, 29(A0)
171:                 }
172:                 
173:                 
174:                 static void map1_setstate(SnssMapperBlock *state)
175:                 {
176:                    regs[1] = state->extraData.mapper1.registers[0];
177:                    regs[1] = state->extraData.mapper1.registers[1];
9D031B84  90820019   LBU V0, 25(A0)
9D031B88  A38280E5   SB V0, -32539(GP)
178:                    regs[2] = state->extraData.mapper1.registers[2];
9D031B8C  9082001A   LBU V0, 26(A0)
9D031B90  A38280E6   SB V0, -32538(GP)
179:                    regs[3] = state->extraData.mapper1.registers[3];
9D031B94  9082001B   LBU V0, 27(A0)
9D031B98  A38280E7   SB V0, -32537(GP)
180:                    latch = state->extraData.mapper1.latch;
9D031B9C  9082001C   LBU V0, 28(A0)
9D031BA0  A38280E8   SB V0, -32536(GP)
181:                    bitcount = state->extraData.mapper1.numberOfBits;
9D031BA4  9082001D   LBU V0, 29(A0)
9D031BA8  03E00008   JR RA
9D031BAC  AF8280EC   SW V0, -32532(GP)
182:                 }
183:                 
184:                 static map_memwrite map1_memwrite[] =
185:                 {
186:                    { 0x8000, 0xFFFF, map1_write },
187:                    {     -1,     -1, NULL }
188:                 };
189:                 
190:                 mapintf_t map1_intf =
191:                 {
192:                    1, /* mapper number */
193:                    "MMC1", /* mapper name */
194:                    map1_init, /* init routine */
195:                    NULL, /* vblank callback */
196:                    NULL, /* hblank callback */
197:                    map1_getstate, /* get state (snss) */
198:                    map1_setstate, /* set state (snss) */
199:                    NULL, /* memory read structure */
200:                    map1_memwrite, /* memory write structure */
201:                    NULL /* external sound device */
202:                 };
203:                 
204:                 /*
205:                 ** $Log: map001.c,v $
206:                 ** Revision 1.2  2001/04/27 14:37:11  neil
207:                 ** wheeee
208:                 **
209:                 ** Revision 1.1  2001/04/27 12:54:40  neil
210:                 ** blah
211:                 **
212:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
213:                 ** initial
214:                 **
215:                 ** Revision 1.1  2000/10/24 12:19:32  matt
216:                 ** changed directory structure
217:                 **
218:                 ** Revision 1.8  2000/10/22 19:46:50  matt
219:                 ** mirroring bugfix
220:                 **
221:                 ** Revision 1.7  2000/10/22 19:17:46  matt
222:                 ** mapper cleanups galore
223:                 **
224:                 ** Revision 1.6  2000/10/22 15:03:13  matt
225:                 ** simplified mirroring
226:                 **
227:                 ** Revision 1.5  2000/10/21 19:33:38  matt
228:                 ** many more cleanups
229:                 **
230:                 ** Revision 1.4  2000/07/15 23:52:19  matt
231:                 ** rounded out a bunch more mapper interfaces
232:                 **
233:                 ** Revision 1.3  2000/07/10 05:29:03  matt
234:                 ** cleaned up some mirroring issues
235:                 **
236:                 ** Revision 1.2  2000/07/06 02:48:43  matt
237:                 ** clearly labelled structure members
238:                 **
239:                 ** Revision 1.1  2000/07/04 23:11:45  matt
240:                 ** initial revision
241:                 **
242:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/log.c  -------------------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** log.c
21:                  **
22:                  ** Error logging functions
23:                  ** $Id: log.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <stdlib.h>
27:                  #include <stdio.h>
28:                  #include <stdarg.h>
29:                  #include <noftypes.h>
30:                  #include <log.h>
31:                  
32:                  
33:                  //static FILE *errorlog = NULL;
34:                  static int (*log_func)(const char *string) = NULL;
35:                  
36:                  /* first up: debug versions of calls */
37:                  #ifdef NOFRENDO_DEBUG
38:                  int log_init(void)
39:                  {
40:                  //   errorlog = fopen("errorlog.txt", "wt");
41:                  //   if (NULL == errorlog)
42:                  //      return (-1);
43:                  
44:                     return 0;
45:                  }
46:                  
47:                  void log_shutdown(void)
48:                  {
49:                     /* Snoop around for unallocated blocks */
50:                     mem_checkblocks();
51:                     mem_checkleaks();
52:                     mem_cleanup();
53:                  
54:                  //   if (NULL != errorlog)
55:                  //      fclose(errorlog);
56:                  }
57:                  
58:                  int log_print(const char *string)
59:                  {
60:                     /* if we have a custom logging function, use that */
61:                     if (NULL != log_func)
62:                        log_func(string);
63:                     
64:                     /* Log it to disk, as well */
65:                  //   fputs(string, errorlog);
66:                  //	printf("%s\n", string);
67:                  
68:                     return 0;
69:                  }
70:                  
71:                  int log_printf(const char *format, ... )
72:                  {
73:                     /* don't allocate on stack every call */
74:                     static char buffer[1024 + 1];
75:                     va_list arg;
76:                  
77:                     va_start(arg, format);
78:                  
79:                     if (NULL != log_func)
80:                     {
81:                        vsprintf(buffer, format, arg);
82:                        log_func(buffer);
83:                     }
84:                  
85:                  //   vfprintf(errorlog, format, arg);
86:                     va_end(arg);
87:                  
88:                     return 0; /* should be number of chars written */
89:                  }
90:                  
91:                  #else /* !NOFRENDO_DEBUG */
92:                  
93:                  int log_init(void)
94:                  {
95:                     return 0;
96:                  }
9D03C454  03E00008   JR RA
9D03C458  00001021   ADDU V0, ZERO, ZERO
97:                  
98:                  void log_shutdown(void)
99:                  {
9D03C45C  03E00008   JR RA
9D03C460  00000000   NOP
100:                 }
101:                 
102:                 int log_print(const char *string)
103:                 {
104:                    UNUSED(string);
105:                 
106:                    return 0;
107:                 }
9D03C464  03E00008   JR RA
9D03C468  00001021   ADDU V0, ZERO, ZERO
108:                 
109:                 int log_printf(const char *format, ... )
110:                 {
9D03C46C  AFA50004   SW A1, 4(SP)
9D03C470  AFA60008   SW A2, 8(SP)
9D03C474  AFA7000C   SW A3, 12(SP)
111:                    UNUSED(format);
112:                 
113:                    return 0; /* should be number of chars written */
114:                 }
9D03C478  03E00008   JR RA
9D03C47C  00001021   ADDU V0, ZERO, ZERO
115:                 #endif /* !NOFRENDO_DEBUG */
116:                 
117:                 void log_chain_logfunc(int (*func)(const char *string))
118:                 {
119:                    log_func = func;
9D03C480  03E00008   JR RA
9D03C484  AF848124   SW A0, -32476(GP)
120:                 }
121:                 
122:                 void log_assert(int expr, int line, const char *file, char *msg)
123:                 {
9D03C488  03E00008   JR RA
124:                    if (expr)
125:                       return;
126:                 
127:                    if (NULL != msg)
128:                       log_printf("ASSERT: line %d of %s, %s\n", line, file, msg);
129:                    else
130:                       log_printf("ASSERT: line %d of %s\n", line, file);
131:                 
132:                    //asm("break.n 1");
133:                 //   exit(-1);
134:                 }
135:                 
136:                 
137:                 /*
138:                 ** $Log: log.c,v $
139:                 ** Revision 1.2  2001/04/27 14:37:11  neil
140:                 ** wheeee
141:                 **
142:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
143:                 ** initial
144:                 **
145:                 ** Revision 1.14  2000/11/13 00:56:17  matt
146:                 ** doesn't look as nasty now
147:                 **
148:                 ** Revision 1.13  2000/11/06 02:15:07  matt
149:                 ** more robust logging routines
150:                 **
151:                 ** Revision 1.12  2000/10/15 13:28:12  matt
152:                 ** need stdlib.h for exit()
153:                 **
154:                 ** Revision 1.11  2000/10/10 13:13:13  matt
155:                 ** dumb bug in log_chain_logfunc
156:                 **
157:                 ** Revision 1.10  2000/10/10 13:03:54  matt
158:                 ** Mr. Clean makes a guest appearance
159:                 **
160:                 ** Revision 1.9  2000/08/28 01:47:10  matt
161:                 ** quelled fricking compiler complaints
162:                 **
163:                 ** Revision 1.8  2000/07/31 04:28:46  matt
164:                 ** one million cleanups
165:                 **
166:                 ** Revision 1.7  2000/07/17 01:52:27  matt
167:                 ** made sure last line of all source files is a newline
168:                 **
169:                 ** Revision 1.6  2000/07/06 17:20:52  matt
170:                 ** block manager space itself wasn't being freed - d'oh!
171:                 **
172:                 ** Revision 1.5  2000/06/26 04:55:33  matt
173:                 ** minor change
174:                 **
175:                 ** Revision 1.4  2000/06/09 15:12:25  matt
176:                 ** initial revision
177:                 **
178:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/libsnss/libsnss.c  -------------------------
1:                   /**************************************************************************/
2:                   /*
3:                         libsnss.c
4:                   
5:                         (C) 2000 The SNSS Group
6:                         See README.TXT file for license and terms of use.
7:                   
8:                         $Id: libsnss.c,v 1.2 2001/04/27 14:37:11 neil Exp $
9:                   */
10:                  /**************************************************************************/
11:                  
12:                  #include <stdio.h>
13:                  #include <stdlib.h>
14:                  #include <string.h>
15:                  #include <libsnss.h>
16:                  
17:                  /**************************************************************************/
18:                  /* This section deals with endian-specific code. */
19:                  /**************************************************************************/
20:                  
21:                  static unsigned int
22:                  swaap32 (unsigned int source)
23:                  {
24:                  #ifdef USE_LITTLE_ENDIAN
25:                     char buffer[4];
26:                     
27:                     buffer[0] = ((char *) &source)[3];
28:                     buffer[1] = ((char *) &source)[2];
29:                     buffer[2] = ((char *) &source)[1];
30:                     buffer[3] = ((char *) &source)[0];
31:                  
32:                     return *((unsigned int *) buffer);
33:                  #else /* !USE_LITTLE_ENDIAN */
34:                     return source;
35:                  #endif /* !USE_LITTLE_ENDIAN */
36:                  }
37:                  
38:                  static unsigned short
39:                  swaap16 (unsigned short source)
40:                  {
41:                  #ifdef USE_LITTLE_ENDIAN
42:                     char buffer[2];
43:                     
44:                     buffer[0] = ((char *) &source)[1];
45:                     buffer[1] = ((char *) &source)[0];
46:                  
47:                     return *((unsigned short *) buffer);
48:                  #else /* !USE_LITTLE_ENDIAN */
49:                     return source;
50:                  #endif /* !USE_LITTLE_ENDIAN */
51:                  }
52:                  
53:                  /**************************************************************************/
54:                  /* support functions */
55:                  /**************************************************************************/
56:                  
57:                  #define MIN(a,b) (((a) < (b)) ? (a) : (b))
58:                  
59:                  /**************************************************************************/
60:                  
61:                  static SNSS_RETURN_CODE
62:                  SNSS_ReadBlockHeader (SnssBlockHeader *header, SNSS_FILE *snssFile)
63:                  {
9D021220  27BDFFD8   ADDIU SP, SP, -40
9D021224  AFBF0024   SW RA, 36(SP)
9D021228  AFB00020   SW S0, 32(SP)
9D02122C  00808021   ADDU S0, A0, ZERO
64:                     char headerBytes[12];
65:                  
66:                     if (fread (headerBytes, 12, 1, snssFile->fp) != 1)
9D021230  8CA70000   LW A3, 0(A1)
9D021234  27A40010   ADDIU A0, SP, 16
9D021238  2405000C   ADDIU A1, ZERO, 12
9D02123C  0F40CC64   JAL .Letext0, .LFE1, fread
9D021240  24060001   ADDIU A2, ZERO, 1
9D021244  24050001   ADDIU A1, ZERO, 1
9D021248  1445000F   BNE V0, A1, 0x9D021288
9D02124C  24030004   ADDIU V1, ZERO, 4
67:                     {
68:                        return SNSS_READ_FAILED;
69:                     }
70:                  
71:                     strncpy (header->tag, &headerBytes[0], TAG_LENGTH);
9D021250  02002021   ADDU A0, S0, ZERO
9D021254  27A50010   ADDIU A1, SP, 16
9D021258  0F40E397   JAL .LFE23, strncpy
9D02125C  24060004   ADDIU A2, ZERO, 4
72:                     header->tag[4] = '\0';
9D021260  A2000004   SB ZERO, 4(S0)
73:                     header->blockVersion = *((unsigned int *) &headerBytes[4]);
74:                     header->blockVersion = swap32 (header->blockVersion);
9D021264  8FA20014   LW V0, 20(SP)
9D021268  7C0210A0   WSBH V0, V0
9D02126C  00221402   ROTR V0, V0, 16
9D021270  AE020008   SW V0, 8(S0)
75:                     header->blockLength = *((unsigned int *) &headerBytes[8]);
76:                     header->blockLength = swap32 (header->blockLength);
9D021274  8FA20018   LW V0, 24(SP)
9D021278  7C0210A0   WSBH V0, V0
9D02127C  00221402   ROTR V0, V0, 16
9D021280  AE02000C   SW V0, 12(S0)
77:                  
78:                     return SNSS_OK;
9D021284  00001821   ADDU V1, ZERO, ZERO
79:                  }
9D021288  00601021   ADDU V0, V1, ZERO
9D02128C  8FBF0024   LW RA, 36(SP)
9D021290  8FB00020   LW S0, 32(SP)
9D021294  03E00008   JR RA
9D021298  27BD0028   ADDIU SP, SP, 40
80:                  
81:                  /**************************************************************************/
82:                  
83:                  static SNSS_RETURN_CODE
84:                  SNSS_WriteBlockHeader (SnssBlockHeader *header, SNSS_FILE *snssFile)
85:                  {
9D021520  27BDFFD0   ADDIU SP, SP, -48
9D021524  AFBF002C   SW RA, 44(SP)
9D021528  AFB10028   SW S1, 40(SP)
9D02152C  AFB00024   SW S0, 36(SP)
9D021530  00808021   ADDU S0, A0, ZERO
9D021534  00A08821   ADDU S1, A1, ZERO
86:                     char headerBytes[12];
87:                     unsigned int tempInt;
88:                  
89:                     strncpy (&headerBytes[0], header->tag, TAG_LENGTH);
9D021538  27A40010   ADDIU A0, SP, 16
9D02153C  02002821   ADDU A1, S0, ZERO
9D021540  0F40E397   JAL .LFE23, strncpy
9D021544  24060004   ADDIU A2, ZERO, 4
90:                  
91:                     tempInt = swap32 (header->blockVersion);
9D021548  8E020008   LW V0, 8(S0)
9D02154C  7C0210A0   WSBH V0, V0
9D021550  00221402   ROTR V0, V0, 16
92:                     headerBytes[4] = ((char *) &tempInt)[0];
9D021554  A3A20014   SB V0, 20(SP)
93:                     headerBytes[5] = ((char *) &tempInt)[1];
9D021558  00021A02   SRL V1, V0, 8
9D02155C  A3A30015   SB V1, 21(SP)
94:                     headerBytes[6] = ((char *) &tempInt)[2];
9D021560  00021C02   SRL V1, V0, 16
9D021564  A3A30016   SB V1, 22(SP)
95:                     headerBytes[7] = ((char *) &tempInt)[3];
9D021568  00021602   SRL V0, V0, 24
9D02156C  A3A20017   SB V0, 23(SP)
96:                  
97:                     tempInt = swap32 (header->blockLength);
9D021570  8E02000C   LW V0, 12(S0)
9D021574  7C0210A0   WSBH V0, V0
9D021578  00221402   ROTR V0, V0, 16
9D02157C  AFA2001C   SW V0, 28(SP)
98:                     headerBytes[8] = ((char *) &tempInt)[0];
9D021580  A3A20018   SB V0, 24(SP)
99:                     headerBytes[9] = ((char *) &tempInt)[1];
9D021584  00021A02   SRL V1, V0, 8
9D021588  A3A30019   SB V1, 25(SP)
100:                    headerBytes[10] = ((char *) &tempInt)[2];
9D02158C  00021C02   SRL V1, V0, 16
9D021590  A3A3001A   SB V1, 26(SP)
101:                    headerBytes[11] = ((char *) &tempInt)[3];
9D021594  00021602   SRL V0, V0, 24
9D021598  A3A2001B   SB V0, 27(SP)
102:                 
103:                    if (fwrite (headerBytes, 12, 1, snssFile->fp) != 1)
9D02159C  27A40010   ADDIU A0, SP, 16
9D0215A0  2405000C   ADDIU A1, ZERO, 12
9D0215A4  24060001   ADDIU A2, ZERO, 1
9D0215A8  0F40F1FB   JAL fwrite
9D0215AC  8E270000   LW A3, 0(S1)
104:                    {
105:                       return SNSS_WRITE_FAILED;
9D0215B0  38420001   XORI V0, V0, 1
106:                    }
107:                 
108:                    return SNSS_OK;
109:                 }
9D0215B4  24030005   ADDIU V1, ZERO, 5
9D0215B8  0002180A   MOVZ V1, ZERO, V0
9D0215BC  00601021   ADDU V0, V1, ZERO
9D0215C0  8FBF002C   LW RA, 44(SP)
9D0215C4  8FB10028   LW S1, 40(SP)
9D0215C8  8FB00024   LW S0, 36(SP)
9D0215CC  03E00008   JR RA
9D0215D0  27BD0030   ADDIU SP, SP, 48
110:                 
111:                 /**************************************************************************/
112:                 
113:                 const char *
114:                 SNSS_GetErrorString (SNSS_RETURN_CODE code)
115:                 {
116:                    switch (code)
9D021874  2C820008   SLTIU V0, A0, 8
9D021878  10400024   BEQ V0, ZERO, 0x9D02190C
9D02187C  00042080   SLL A0, A0, 2
9D021880  3C029D02   LUI V0, -25342
9D021884  24421898   ADDIU V0, V0, 6296
9D021888  00442021   ADDU A0, V0, A0
9D02188C  8C820000   LW V0, 0(A0)
9D021890  00400008   JR V0
9D021894  00000000   NOP
117:                    {
118:                    case SNSS_OK:
119:                       return "no error";
9D0218B8  3C029D04   LUI V0, -25340
9D0218BC  03E00008   JR RA
9D0218C0  24428618   ADDIU V0, V0, -31208
120:                 
121:                    case SNSS_BAD_FILE_TAG:
122:                       return "not an SNSS file";
9D021918  3C029D04   LUI V0, -25340
123:                 
124:                    case SNSS_OPEN_FAILED:
125:                       return "could not open SNSS file";
9D0218C4  3C029D04   LUI V0, -25340
9D0218C8  03E00008   JR RA
9D0218CC  24428638   ADDIU V0, V0, -31176
126:                 
127:                    case SNSS_CLOSE_FAILED:
128:                       return "could not close SNSS file";
9D0218D0  3C029D04   LUI V0, -25340
9D0218D4  03E00008   JR RA
9D0218D8  24428654   ADDIU V0, V0, -31148
129:                 
130:                    case SNSS_READ_FAILED:
131:                       return "could not read from SNSS file";
9D0218DC  3C029D04   LUI V0, -25340
9D0218E0  03E00008   JR RA
9D0218E4  24428670   ADDIU V0, V0, -31120
132:                 
133:                    case SNSS_WRITE_FAILED:
134:                       return "could not write to SNSS file";
9D0218E8  3C029D04   LUI V0, -25340
9D0218EC  03E00008   JR RA
9D0218F0  24428690   ADDIU V0, V0, -31088
135:                 
136:                    case SNSS_OUT_OF_MEMORY:
137:                       return "out of memory";
9D0218F4  3C029D04   LUI V0, -25340
9D0218F8  03E00008   JR RA
9D0218FC  244286B0   ADDIU V0, V0, -31056
138:                 
139:                    case SNSS_UNSUPPORTED_BLOCK:
140:                       return "unsupported block type";
9D021900  3C029D04   LUI V0, -25340
9D021904  03E00008   JR RA
9D021908  244286C0   ADDIU V0, V0, -31040
141:                 
142:                    default:
143:                       return "unknown error";
9D02190C  3C029D04   LUI V0, -25340
9D021910  03E00008   JR RA
9D021914  244286D8   ADDIU V0, V0, -31016
144:                    }
145:                 }
9D02191C  03E00008   JR RA
9D021920  24428624   ADDIU V0, V0, -31196
146:                 
147:                 /**************************************************************************/
148:                 /* functions for reading and writing SNSS file headers */
149:                 /**************************************************************************/
150:                 
151:                 static SNSS_RETURN_CODE 
152:                 SNSS_ReadFileHeader (SNSS_FILE *snssFile)
153:                 {
154:                    if (fread (snssFile->headerBlock.tag, 4, 1, snssFile->fp) != 1)
9D0219E8  02002021   ADDU A0, S0, ZERO
155:                    {
156:                       return SNSS_READ_FAILED;
157:                    }
158:                  
159:                    if (0 != strncmp(snssFile->headerBlock.tag, "SNSS", 4))
9D021A04  02002021   ADDU A0, S0, ZERO
160:                    {
161:                       return SNSS_BAD_FILE_TAG;
162:                    }
163:                    
164:                    snssFile->headerBlock.tag[4] = '\0';
9D021A20  A220000C   SB ZERO, 12(S1)
165:                 
166:                    if (fread (&snssFile->headerBlock.numberOfBlocks, sizeof (unsigned int), 1, snssFile->fp) != 1)
9D021A24  26240010   ADDIU A0, S1, 16
167:                    {
168:                       return SNSS_READ_FAILED;
169:                    }
170:                 
171:                    snssFile->headerBlock.numberOfBlocks = swap32 (snssFile->headerBlock.numberOfBlocks);
9D021A44  8E220010   LW V0, 16(S1)
9D021A48  7C0210A0   WSBH V0, V0
9D021A4C  00221402   ROTR V0, V0, 16
9D021A50  AE220010   SW V0, 16(S1)
172:                 
173:                    return SNSS_OK;
9D021A54  0B40869A   J 0x9D021A68
9D021A58  00003821   ADDU A3, ZERO, ZERO
174:                 }
175:                 
176:                 /**************************************************************************/
177:                 
178:                 static SNSS_RETURN_CODE 
179:                 SNSS_WriteFileHeader (SNSS_FILE *snssFile)
180:                 {
9D0211AC  27BDFFD8   ADDIU SP, SP, -40
9D0211B0  AFBF0024   SW RA, 36(SP)
9D0211B4  00801821   ADDU V1, A0, ZERO
181:                    unsigned int tempInt;
182:                    char writeBuffer[8];
183:                 
184:                    /* always place the SNSS tag in this field */
185:                    strncpy (&writeBuffer[0], "SNSS", 4);
9D0211B8  3C025353   LUI V0, 21331
9D0211BC  24424E53   ADDIU V0, V0, 20051
9D0211C0  AFA20014   SW V0, 20(SP)
186:                    tempInt = swap32 (snssFile->headerBlock.numberOfBlocks);
9D0211C4  8C820010   LW V0, 16(A0)
9D0211C8  7C0210A0   WSBH V0, V0
9D0211CC  00221402   ROTR V0, V0, 16
9D0211D0  AFA20010   SW V0, 16(SP)
187:                    writeBuffer[4] = ((char *) &tempInt)[0];
9D0211D4  A3A20018   SB V0, 24(SP)
188:                    writeBuffer[5] = ((char *) &tempInt)[1];
9D0211D8  00022202   SRL A0, V0, 8
9D0211DC  A3A40019   SB A0, 25(SP)
189:                    writeBuffer[6] = ((char *) &tempInt)[2];
9D0211E0  00022402   SRL A0, V0, 16
9D0211E4  A3A4001A   SB A0, 26(SP)
190:                    writeBuffer[7] = ((char *) &tempInt)[3];
9D0211E8  00021602   SRL V0, V0, 24
9D0211EC  A3A2001B   SB V0, 27(SP)
191:                 
192:                    if (fwrite (writeBuffer, 8, 1, snssFile->fp) != 1)
9D0211F0  27A40014   ADDIU A0, SP, 20
9D0211F4  24050008   ADDIU A1, ZERO, 8
9D0211F8  24060001   ADDIU A2, ZERO, 1
9D0211FC  0F40F1FB   JAL fwrite
9D021200  8C670000   LW A3, 0(V1)
193:                    {
194:                       return SNSS_WRITE_FAILED;
9D021204  38420001   XORI V0, V0, 1
195:                    }
196:                 
197:                    return SNSS_OK;
198:                 }
9D021208  24030005   ADDIU V1, ZERO, 5
9D02120C  0002180A   MOVZ V1, ZERO, V0
9D021210  00601021   ADDU V0, V1, ZERO
9D021214  8FBF0024   LW RA, 36(SP)
9D021218  03E00008   JR RA
9D02121C  27BD0028   ADDIU SP, SP, 40
199:                 
200:                 /**************************************************************************/
201:                 /* general file manipulation functions */
202:                 /**************************************************************************/
203:                 SNSS_RETURN_CODE
204:                 SNSS_OpenFile (SNSS_FILE **snssFile, const char *filename, SNSS_OPEN_MODE mode)
205:                 {
9D021924  27BDFFE0   ADDIU SP, SP, -32
9D021928  AFBF001C   SW RA, 28(SP)
9D02192C  AFB20018   SW S2, 24(SP)
9D021930  AFB10014   SW S1, 20(SP)
9D021934  AFB00010   SW S0, 16(SP)
9D021938  00808021   ADDU S0, A0, ZERO
9D02193C  00A09021   ADDU S2, A1, ZERO
9D021940  00C08821   ADDU S1, A2, ZERO
206:                    *snssFile = malloc(sizeof(SNSS_FILE));
9D021944  0F40AE73   JAL .Letext0, .LFE16, malloc
9D021948  240479FC   ADDIU A0, ZERO, 31228
9D02194C  AE020000   SW V0, 0(S0)
207:                    if (NULL == *snssFile)
9D021950  10400045   BEQ V0, ZERO, 0x9D021A68
9D021954  24070006   ADDIU A3, ZERO, 6
208:                    {
209:                       return SNSS_OUT_OF_MEMORY;
210:                    }
211:                  
212:                    /* zero the memory */
213:                    memset (*snssFile, 0, sizeof(SNSS_FILE));
9D021958  00402021   ADDU A0, V0, ZERO
9D02195C  00002821   ADDU A1, ZERO, ZERO
9D021960  0F40E9FC   JAL .Letext0, .LFE0, memset
9D021964  240679FC   ADDIU A2, ZERO, 31228
214:                 
215:                    (*snssFile)->mode = mode;
9D021968  8E020000   LW V0, 0(S0)
216:                 
217:                    if (SNSS_OPEN_READ == mode)
9D02196C  1620000D   BNE S1, ZERO, 0x9D0219A4
9D021970  AC510004   SW S1, 4(V0)
218:                    {
219:                       (*snssFile)->fp = fopen (filename, "rb");
9D021974  8E110000   LW S1, 0(S0)
9D021978  02402021   ADDU A0, S2, ZERO
9D02197C  3C059D04   LUI A1, -25340
9D021980  0F40DCB1   JAL .Letext0, .LFE3, fopen
9D021984  24A586E8   ADDIU A1, A1, -31000
9D021988  AE220000   SW V0, 0(S1)
220:                    }
221:                    else
222:                    {
223:                       (*snssFile)->fp = fopen (filename, "wb");
9D0219A4  8E110000   LW S1, 0(S0)
9D0219A8  02402021   ADDU A0, S2, ZERO
9D0219AC  3C059D04   LUI A1, -25340
9D0219B0  0F40DCB1   JAL .Letext0, .LFE3, fopen
9D0219B4  24A586EC   ADDIU A1, A1, -30996
9D0219B8  AE220000   SW V0, 0(S1)
224:                       (*snssFile)->headerBlock.numberOfBlocks = 0;
9D0219BC  8E020000   LW V0, 0(S0)
9D0219C0  AC400010   SW ZERO, 16(V0)
225:                    }
226:                 
227:                    if (NULL == (*snssFile)->fp)
9D02198C  8E110000   LW S1, 0(S0)
9D021990  8E270000   LW A3, 0(S1)
9D021994  54E00014   BNEL A3, ZERO, .LBB25
9D021998  26300008   ADDIU S0, S1, 8
9D02199C  0B408675   J 0x9D0219D4
9D0219A0  00000000   NOP
9D0219C4  8E110000   LW S1, 0(S0)
9D0219C8  8E220000   LW V0, 0(S1)
9D0219CC  14400023   BNE V0, ZERO, 0x9D021A5C
9D0219D0  00000000   NOP
228:                    {
229:                       free(*snssFile);
9D0219D4  0F40D0ED   JAL free
9D0219D8  02202021   ADDU A0, S1, ZERO
230:                       *snssFile = NULL;
9D0219DC  AE000000   SW ZERO, 0(S0)
231:                       return SNSS_OPEN_FAILED;
9D0219E0  0B40869A   J 0x9D021A68
9D0219E4  24070002   ADDIU A3, ZERO, 2
232:                    }
233:                 
234:                    if (SNSS_OPEN_READ == mode)
235:                    {
236:                       return SNSS_ReadFileHeader(*snssFile);
237:                    }
238:                    else
239:                    {
240:                       return SNSS_WriteFileHeader(*snssFile);
9D021A5C  0F40846B   JAL .LFB14, SNSS_WriteFileHeader, .Ltext0
9D021A60  02202021   ADDU A0, S1, ZERO
9D021A64  00403821   ADDU A3, V0, ZERO
241:                    }
242:                 }
9D021A68  00E01021   ADDU V0, A3, ZERO
9D021A6C  8FBF001C   LW RA, 28(SP)
9D021A70  8FB20018   LW S2, 24(SP)
9D021A74  8FB10014   LW S1, 20(SP)
9D021A78  8FB00010   LW S0, 16(SP)
9D021A7C  03E00008   JR RA
9D021A80  27BD0020   ADDIU SP, SP, 32
243:                 
244:                 /**************************************************************************/
245:                 
246:                 SNSS_RETURN_CODE
247:                 SNSS_CloseFile (SNSS_FILE **snssFile)
248:                 {
9D021A84  27BDFFE0   ADDIU SP, SP, -32
9D021A88  AFBF001C   SW RA, 28(SP)
9D021A8C  AFB10018   SW S1, 24(SP)
9D021A90  AFB00014   SW S0, 20(SP)
249:                    int prevLoc;
250:                    SNSS_RETURN_CODE code;
251:                 
252:                    /* file was never open, so this should indicate success- kinda. */
253:                    if (NULL == *snssFile)
9D021A94  8C820000   LW V0, 0(A0)
9D021A98  10400020   BEQ V0, ZERO, 0x9D021B1C
9D021A9C  00808021   ADDU S0, A0, ZERO
254:                    {
255:                       return SNSS_OK;
9D021B1C  00001821   ADDU V1, ZERO, ZERO
256:                    }
257:                 
258:                    if (SNSS_OPEN_WRITE == (*snssFile)->mode)
9D021AA0  8C440004   LW A0, 4(V0)
9D021AA4  24030001   ADDIU V1, ZERO, 1
9D021AA8  54830013   BNEL A0, V1, 0x9D021AF8
9D021AAC  8E020000   LW V0, 0(S0)
259:                    {
260:                       prevLoc = ftell((*snssFile)->fp);
9D021AB0  0F40EF44   JAL ftell
9D021AB4  8C440000   LW A0, 0(V0)
9D021AB8  00408821   ADDU S1, V0, ZERO
261:                       fseek((*snssFile)->fp, 0, SEEK_SET);
9D021ABC  8E030000   LW V1, 0(S0)
9D021AC0  8C640000   LW A0, 0(V1)
9D021AC4  00002821   ADDU A1, ZERO, ZERO
9D021AC8  0F40EBF7   JAL fseek
9D021ACC  00003021   ADDU A2, ZERO, ZERO
262:                 
263:                       /* write the header again to update block count */
264:                       if (SNSS_OK != (code = SNSS_WriteFileHeader(*snssFile)))
9D021AD0  0F40846B   JAL .LFB14, SNSS_WriteFileHeader, .Ltext0
9D021AD4  8E040000   LW A0, 0(S0)
9D021AD8  14400011   BNE V0, ZERO, 0x9D021B20
9D021ADC  24030003   ADDIU V1, ZERO, 3
265:                       {
266:                          return SNSS_CLOSE_FAILED;
267:                       }
268:                 
269:                       fseek((*snssFile)->fp, prevLoc, SEEK_SET);
9D021AE0  8E020000   LW V0, 0(S0)
9D021AE4  8C440000   LW A0, 0(V0)
9D021AE8  02202821   ADDU A1, S1, ZERO
9D021AEC  0F40EBF7   JAL fseek
9D021AF0  00003021   ADDU A2, ZERO, ZERO
270:                    }
271:                 
272:                    if (fclose ((*snssFile)->fp) != 0)
9D021AF4  8E020000   LW V0, 0(S0)
9D021AF8  0F40EBD5   JAL .Letext0, .LFE1, fclose
9D021AFC  8C440000   LW A0, 0(V0)
9D021B00  14400007   BNE V0, ZERO, 0x9D021B20
9D021B04  24030003   ADDIU V1, ZERO, 3
273:                    {
274:                       return SNSS_CLOSE_FAILED;
275:                    }
276:                 
277:                    free(*snssFile);
9D021B08  0F40D0ED   JAL free
9D021B0C  8E040000   LW A0, 0(S0)
278:                    *snssFile = NULL;
9D021B10  AE000000   SW ZERO, 0(S0)
279:                 
280:                    return SNSS_OK;
9D021B14  0B4086C8   J 0x9D021B20
9D021B18  00001821   ADDU V1, ZERO, ZERO
281:                 }
9D021B20  00601021   ADDU V0, V1, ZERO
9D021B24  8FBF001C   LW RA, 28(SP)
9D021B28  8FB10018   LW S1, 24(SP)
9D021B2C  8FB00014   LW S0, 20(SP)
9D021B30  03E00008   JR RA
9D021B34  27BD0020   ADDIU SP, SP, 32
282:                 
283:                 /**************************************************************************/
284:                 
285:                 SNSS_RETURN_CODE 
286:                 SNSS_GetNextBlockType (SNSS_BLOCK_TYPE *blockType, SNSS_FILE *snssFile)
287:                 {
9D021B38  27BDFFD8   ADDIU SP, SP, -40
9D021B3C  AFBF0024   SW RA, 36(SP)
9D021B40  AFB10020   SW S1, 32(SP)
9D021B44  AFB0001C   SW S0, 28(SP)
9D021B48  00808821   ADDU S1, A0, ZERO
9D021B4C  00A08021   ADDU S0, A1, ZERO
288:                    char tagBuffer[TAG_LENGTH + 1];
289:                 
290:                    if (fread (tagBuffer, TAG_LENGTH, 1, snssFile->fp) != 1)
9D021B50  27A40010   ADDIU A0, SP, 16
9D021B54  24050004   ADDIU A1, ZERO, 4
9D021B58  24060001   ADDIU A2, ZERO, 1
9D021B5C  0F40CC64   JAL .Letext0, .LFE1, fread
9D021B60  8E070000   LW A3, 0(S0)
9D021B64  24050001   ADDIU A1, ZERO, 1
9D021B68  14450040   BNE V0, A1, 0x9D021C6C
9D021B6C  24030004   ADDIU V1, ZERO, 4
291:                    {
292:                       return SNSS_READ_FAILED;
293:                    }
294:                    tagBuffer[TAG_LENGTH] = '\0';
9D021B70  A3A00014   SB ZERO, 20(SP)
295:                 
296:                    /* reset the file pointer to the start of the block */
297:                    if (fseek (snssFile->fp, -TAG_LENGTH, SEEK_CUR) != 0)
9D021B74  8E040000   LW A0, 0(S0)
9D021B78  2405FFFC   ADDIU A1, ZERO, -4
9D021B7C  0F40EBF7   JAL fseek
9D021B80  24060001   ADDIU A2, ZERO, 1
9D021B84  14400039   BNE V0, ZERO, 0x9D021C6C
9D021B88  24030004   ADDIU V1, ZERO, 4
298:                    {
299:                       return SNSS_READ_FAILED;
300:                    }
301:                 
302:                    /* figure out which type of block it is */
303:                    if (strcmp (tagBuffer, "BASR") == 0)
9D021B8C  27A40010   ADDIU A0, SP, 16
9D021B90  3C059D04   LUI A1, -25340
9D021B94  0F40E06B   JAL .Letext0, .LFE2, strcmp
9D021B98  24A586F8   ADDIU A1, A1, -30984
9D021B9C  14400004   BNE V0, ZERO, 0x9D021BB0
9D021BA0  27A40010   ADDIU A0, SP, 16
304:                    {
305:                       *blockType = SNSS_BASR;
9D021BA4  AE200000   SW ZERO, 0(S1)
9D021BA8  0B40871B   J 0x9D021C6C
9D021BAC  00001821   ADDU V1, ZERO, ZERO
306:                    }
307:                    else if (strcmp (tagBuffer, "VRAM") == 0)
9D021BB0  3C059D04   LUI A1, -25340
9D021BB4  0F40E06B   JAL .Letext0, .LFE2, strcmp
9D021BB8  24A58700   ADDIU A1, A1, -30976
9D021BBC  14400005   BNE V0, ZERO, 0x9D021BD4
9D021BC0  27A40010   ADDIU A0, SP, 16
308:                    {
309:                       *blockType = SNSS_VRAM;
9D021BC4  24020001   ADDIU V0, ZERO, 1
9D021BC8  AE220000   SW V0, 0(S1)
9D021BCC  0B40871B   J 0x9D021C6C
9D021BD0  00001821   ADDU V1, ZERO, ZERO
310:                    }
311:                    else if (strcmp (tagBuffer, "SRAM") == 0)
9D021BD4  3C059D04   LUI A1, -25340
9D021BD8  0F40E06B   JAL .Letext0, .LFE2, strcmp
9D021BDC  24A58708   ADDIU A1, A1, -30968
9D021BE0  14400005   BNE V0, ZERO, 0x9D021BF8
9D021BE4  27A40010   ADDIU A0, SP, 16
312:                    {
313:                       *blockType = SNSS_SRAM;
9D021BE8  24020002   ADDIU V0, ZERO, 2
9D021BEC  AE220000   SW V0, 0(S1)
9D021BF0  0B40871B   J 0x9D021C6C
9D021BF4  00001821   ADDU V1, ZERO, ZERO
314:                    }
315:                    else if (strcmp (tagBuffer, "MPRD") == 0)
9D021BF8  3C059D04   LUI A1, -25340
9D021BFC  0F40E06B   JAL .Letext0, .LFE2, strcmp
9D021C00  24A58710   ADDIU A1, A1, -30960
9D021C04  14400005   BNE V0, ZERO, 0x9D021C1C
9D021C08  27A40010   ADDIU A0, SP, 16
316:                    {
317:                       *blockType = SNSS_MPRD;
9D021C0C  24020003   ADDIU V0, ZERO, 3
9D021C10  AE220000   SW V0, 0(S1)
9D021C14  0B40871B   J 0x9D021C6C
9D021C18  00001821   ADDU V1, ZERO, ZERO
318:                    }
319:                    else if (strcmp (tagBuffer, "CNTR") == 0)
9D021C1C  3C059D04   LUI A1, -25340
9D021C20  0F40E06B   JAL .Letext0, .LFE2, strcmp
9D021C24  24A58718   ADDIU A1, A1, -30952
9D021C28  14400005   BNE V0, ZERO, 0x9D021C40
9D021C2C  27A40010   ADDIU A0, SP, 16
320:                    {
321:                       *blockType = SNSS_CNTR;
9D021C30  24020004   ADDIU V0, ZERO, 4
9D021C34  AE220000   SW V0, 0(S1)
9D021C38  0B40871B   J 0x9D021C6C
9D021C3C  00001821   ADDU V1, ZERO, ZERO
322:                    }
323:                    else if (strcmp (tagBuffer, "SOUN") == 0)
9D021C40  3C059D04   LUI A1, -25340
9D021C44  0F40E06B   JAL .Letext0, .LFE2, strcmp
9D021C48  24A58720   ADDIU A1, A1, -30944
9D021C4C  14400005   BNE V0, ZERO, 0x9D021C64
9D021C50  24020006   ADDIU V0, ZERO, 6
324:                    {
325:                       *blockType = SNSS_SOUN;
9D021C54  24020005   ADDIU V0, ZERO, 5
9D021C58  AE220000   SW V0, 0(S1)
9D021C5C  0B40871B   J 0x9D021C6C
9D021C60  00001821   ADDU V1, ZERO, ZERO
326:                    }
327:                    else
328:                    {
329:                       *blockType = SNSS_UNKNOWN_BLOCK;
9D021C64  AE220000   SW V0, 0(S1)
330:                    }
331:                 
332:                    return SNSS_OK;
9D021C68  00001821   ADDU V1, ZERO, ZERO
333:                 }
9D021C6C  00601021   ADDU V0, V1, ZERO
9D021C70  8FBF0024   LW RA, 36(SP)
9D021C74  8FB10020   LW S1, 32(SP)
9D021C78  8FB0001C   LW S0, 28(SP)
9D021C7C  03E00008   JR RA
9D021C80  27BD0028   ADDIU SP, SP, 40
334:                 
335:                 /**************************************************************************/
336:                 
337:                 SNSS_RETURN_CODE 
338:                 SNSS_SkipNextBlock (SNSS_FILE *snssFile)
339:                 {
9D021C84  27BDFFE0   ADDIU SP, SP, -32
9D021C88  AFBF001C   SW RA, 28(SP)
9D021C8C  AFB00018   SW S0, 24(SP)
9D021C90  00808021   ADDU S0, A0, ZERO
340:                    unsigned int blockLength;
341:                 
342:                    /* skip the block's tag and version */
343:                    if (fseek (snssFile->fp, TAG_LENGTH + sizeof (unsigned int), SEEK_CUR) != 0)
9D021C94  8C840000   LW A0, 0(A0)
9D021C98  24050008   ADDIU A1, ZERO, 8
9D021C9C  0F40EBF7   JAL fseek
9D021CA0  24060001   ADDIU A2, ZERO, 1
9D021CA4  14400012   BNE V0, ZERO, 0x9D021CF0
9D021CA8  24030004   ADDIU V1, ZERO, 4
344:                    {
345:                       return SNSS_READ_FAILED;
346:                    }
347:                 
348:                    /* get the block data length */
349:                    if (fread (&blockLength, sizeof (unsigned int), 1, snssFile->fp) != 1)
9D021CAC  27A40010   ADDIU A0, SP, 16
9D021CB0  24050004   ADDIU A1, ZERO, 4
9D021CB4  24060001   ADDIU A2, ZERO, 1
9D021CB8  0F40CC64   JAL .Letext0, .LFE1, fread
9D021CBC  8E070000   LW A3, 0(S0)
9D021CC0  24040001   ADDIU A0, ZERO, 1
9D021CC4  1444000A   BNE V0, A0, 0x9D021CF0
9D021CC8  24030004   ADDIU V1, ZERO, 4
350:                    {
351:                       return SNSS_READ_FAILED;
352:                    }
353:                    blockLength = swap32 (blockLength);
9D021CCC  8FA50010   LW A1, 16(SP)
9D021CD0  7C0528A0   WSBH A1, A1
9D021CD4  00252C02   ROTR A1, A1, 16
9D021CD8  AFA50010   SW A1, 16(SP)
354:                 
355:                    /* skip over the block data */
356:                    if (fseek (snssFile->fp, blockLength, SEEK_CUR) != 0)
9D021CDC  8E040000   LW A0, 0(S0)
9D021CE0  0F40EBF7   JAL fseek
9D021CE4  24060001   ADDIU A2, ZERO, 1
357:                    {
358:                       return SNSS_READ_FAILED;
9D021CE8  24030004   ADDIU V1, ZERO, 4
9D021CEC  0002180A   MOVZ V1, ZERO, V0
359:                    }
360:                 
361:                    return SNSS_OK;
362:                 }
9D021CF0  00601021   ADDU V0, V1, ZERO
9D021CF4  8FBF001C   LW RA, 28(SP)
9D021CF8  8FB00018   LW S0, 24(SP)
9D021CFC  03E00008   JR RA
9D021D00  27BD0020   ADDIU SP, SP, 32
363:                 
364:                 /**************************************************************************/
365:                 /* functions for reading and writing base register blocks */
366:                 /**************************************************************************/
367:                 
368:                 static SNSS_RETURN_CODE 
369:                 SNSS_ReadBaseBlock (SNSS_FILE *snssFile)
370:                 {
9D02129C  27BDE6A0   ADDIU SP, SP, -6496
9D0212A0  AFBF195C   SW RA, 6492(SP)
9D0212A4  AFB01958   SW S0, 6488(SP)
9D0212A8  00808021   ADDU S0, A0, ZERO
371:                    char blockBytes[BASE_BLOCK_LENGTH];
372:                    SnssBlockHeader header;
373:                 
374:                    if (SNSS_ReadBlockHeader (&header, snssFile) != SNSS_OK)
9D0212AC  27A41944   ADDIU A0, SP, 6468
9D0212B0  0F408488   JAL .LFB10, SNSS_ReadBlockHeader, .LFE14
9D0212B4  02002821   ADDU A1, S0, ZERO
9D0212B8  14400094   BNE V0, ZERO, 0x9D02150C
9D0212BC  24030004   ADDIU V1, ZERO, 4
375:                    {
376:                       return SNSS_READ_FAILED;
377:                    }
378:                 
379:                    if (fread (blockBytes, MIN (header.blockLength, BASE_BLOCK_LENGTH), 1, snssFile->fp) != 1)
9D0212C0  8FA21950   LW V0, 6480(SP)
9D0212C4  2C451932   SLTIU A1, V0, 6450
9D0212C8  27A40010   ADDIU A0, SP, 16
9D0212CC  24031931   ADDIU V1, ZERO, 6449
9D0212D0  0045180B   MOVN V1, V0, A1
9D0212D4  00602821   ADDU A1, V1, ZERO
9D0212D8  24060001   ADDIU A2, ZERO, 1
9D0212DC  0F40CC64   JAL .Letext0, .LFE1, fread
9D0212E0  8E070000   LW A3, 0(S0)
9D0212E4  24040001   ADDIU A0, ZERO, 1
9D0212E8  14440088   BNE V0, A0, 0x9D02150C
9D0212EC  24030004   ADDIU V1, ZERO, 4
380:                    {
381:                       return SNSS_READ_FAILED;
382:                    }
383:                 
384:                    snssFile->baseBlock.regA = blockBytes[0x0];
9D0212F0  93A20010   LBU V0, 16(SP)
9D0212F4  A2020014   SB V0, 20(S0)
385:                    snssFile->baseBlock.regX = blockBytes[0x1];
9D0212F8  93A20011   LBU V0, 17(SP)
9D0212FC  A2020015   SB V0, 21(S0)
386:                    snssFile->baseBlock.regY = blockBytes[0x2];
9D021300  93A20012   LBU V0, 18(SP)
9D021304  A2020016   SB V0, 22(S0)
387:                    snssFile->baseBlock.regFlags = blockBytes[0x3];
9D021308  93A20013   LBU V0, 19(SP)
9D02130C  A2020017   SB V0, 23(S0)
388:                    snssFile->baseBlock.regStack = blockBytes[0x4];
9D021310  93A20014   LBU V0, 20(SP)
9D021314  A2020018   SB V0, 24(S0)
389:                    snssFile->baseBlock.regPc = *((unsigned short *) &blockBytes[0x5]);
9D021318  93A30015   LBU V1, 21(SP)
9D02131C  93A20016   LBU V0, 22(SP)
9D021320  00021200   SLL V0, V0, 8
9D021324  00431025   OR V0, V0, V1
390:                    snssFile->baseBlock.regPc = swap16 (snssFile->baseBlock.regPc);
9D021328  7C0210A0   WSBH V0, V0
9D02132C  A602001A   SH V0, 26(S0)
391:                    snssFile->baseBlock.reg2000 = blockBytes[0x7];
9D021330  93A20017   LBU V0, 23(SP)
9D021334  A202001C   SB V0, 28(S0)
392:                    snssFile->baseBlock.reg2001 = blockBytes[0x8];
9D021338  93A20018   LBU V0, 24(SP)
9D02133C  A202001D   SB V0, 29(S0)
393:                    memcpy (&snssFile->baseBlock.cpuRam, &blockBytes[0x9], 0x800);
9D021340  27A30019   ADDIU V1, SP, 25
9D021344  2602001E   ADDIU V0, S0, 30
9D021348  27A80819   ADDIU T0, SP, 2073
9D02134C  88670003   LWL A3, 3(V1)
9D021350  98670000   LWR A3, 0(V1)
9D021354  88660007   LWL A2, 7(V1)
9D021358  98660004   LWR A2, 4(V1)
9D02135C  8865000B   LWL A1, 11(V1)
9D021360  98650008   LWR A1, 8(V1)
9D021364  8864000F   LWL A0, 15(V1)
9D021368  9864000C   LWR A0, 12(V1)
9D02136C  A8470003   SWL A3, 3(V0)
9D021370  B8470000   SWR A3, 0(V0)
9D021374  A8460007   SWL A2, 7(V0)
9D021378  B8460004   SWR A2, 4(V0)
9D02137C  A845000B   SWL A1, 11(V0)
9D021380  B8450008   SWR A1, 8(V0)
9D021384  A844000F   SWL A0, 15(V0)
9D021388  B844000C   SWR A0, 12(V0)
9D02138C  24630010   ADDIU V1, V1, 16
9D021390  1468FFEE   BNE V1, T0, 0x9D02134C
9D021394  24420010   ADDIU V0, V0, 16
394:                    memcpy (&snssFile->baseBlock.spriteRam, &blockBytes[0x809], 0x100);
9D021398  27A30819   ADDIU V1, SP, 2073
9D02139C  2602081E   ADDIU V0, S0, 2078
9D0213A0  27A80919   ADDIU T0, SP, 2329
9D0213A4  88670003   LWL A3, 3(V1)
9D0213A8  98670000   LWR A3, 0(V1)
9D0213AC  88660007   LWL A2, 7(V1)
9D0213B0  98660004   LWR A2, 4(V1)
9D0213B4  8865000B   LWL A1, 11(V1)
9D0213B8  98650008   LWR A1, 8(V1)
9D0213BC  8864000F   LWL A0, 15(V1)
9D0213C0  9864000C   LWR A0, 12(V1)
9D0213C4  A8470003   SWL A3, 3(V0)
9D0213C8  B8470000   SWR A3, 0(V0)
9D0213CC  A8460007   SWL A2, 7(V0)
9D0213D0  B8460004   SWR A2, 4(V0)
9D0213D4  A845000B   SWL A1, 11(V0)
9D0213D8  B8450008   SWR A1, 8(V0)
9D0213DC  A844000F   SWL A0, 15(V0)
9D0213E0  B844000C   SWR A0, 12(V0)
9D0213E4  24630010   ADDIU V1, V1, 16
9D0213E8  1468FFEE   BNE V1, T0, 0x9D0213A4
9D0213EC  24420010   ADDIU V0, V0, 16
395:                    memcpy (&snssFile->baseBlock.ppuRam, &blockBytes[0x909], 0x1000);
9D0213F0  27A30919   ADDIU V1, SP, 2329
9D0213F4  2602091E   ADDIU V0, S0, 2334
9D0213F8  27A81919   ADDIU T0, SP, 6425
9D0213FC  88670003   LWL A3, 3(V1)
9D021400  98670000   LWR A3, 0(V1)
9D021404  88660007   LWL A2, 7(V1)
9D021408  98660004   LWR A2, 4(V1)
9D02140C  8865000B   LWL A1, 11(V1)
9D021410  98650008   LWR A1, 8(V1)
9D021414  8864000F   LWL A0, 15(V1)
9D021418  9864000C   LWR A0, 12(V1)
9D02141C  A8470003   SWL A3, 3(V0)
9D021420  B8470000   SWR A3, 0(V0)
9D021424  A8460007   SWL A2, 7(V0)
9D021428  B8460004   SWR A2, 4(V0)
9D02142C  A845000B   SWL A1, 11(V0)
9D021430  B8450008   SWR A1, 8(V0)
9D021434  A844000F   SWL A0, 15(V0)
9D021438  B844000C   SWR A0, 12(V0)
9D02143C  24630010   ADDIU V1, V1, 16
9D021440  1468FFEE   BNE V1, T0, 0x9D0213FC
9D021444  24420010   ADDIU V0, V0, 16
396:                    memcpy (&snssFile->baseBlock.palette, &blockBytes[0x1909], 0x20);
9D021448  2602191E   ADDIU V0, S0, 6430
9D02144C  8BAA191C   LWL T2, 6428(SP)
9D021450  9BAA1919   LWR T2, 6425(SP)
9D021454  8BA91920   LWL T1, 6432(SP)
9D021458  9BA9191D   LWR T1, 6429(SP)
9D02145C  8BA81924   LWL T0, 6436(SP)
9D021460  9BA81921   LWR T0, 6433(SP)
9D021464  8BA71928   LWL A3, 6440(SP)
9D021468  9BA71925   LWR A3, 6437(SP)
9D02146C  8BA6192C   LWL A2, 6444(SP)
9D021470  9BA61929   LWR A2, 6441(SP)
9D021474  8BA51930   LWL A1, 6448(SP)
9D021478  9BA5192D   LWR A1, 6445(SP)
9D02147C  8BA41934   LWL A0, 6452(SP)
9D021480  9BA41931   LWR A0, 6449(SP)
9D021484  8BA31938   LWL V1, 6456(SP)
9D021488  9BA31935   LWR V1, 6453(SP)
9D02148C  A84A0003   SWL T2, 3(V0)
9D021490  B84A0000   SWR T2, 0(V0)
9D021494  A8490007   SWL T1, 7(V0)
9D021498  B8490004   SWR T1, 4(V0)
9D02149C  A848000B   SWL T0, 11(V0)
9D0214A0  B8480008   SWR T0, 8(V0)
9D0214A4  A847000F   SWL A3, 15(V0)
9D0214A8  B847000C   SWR A3, 12(V0)
9D0214AC  A8460013   SWL A2, 19(V0)
9D0214B0  B8460010   SWR A2, 16(V0)
9D0214B4  A8450017   SWL A1, 23(V0)
9D0214B8  B8450014   SWR A1, 20(V0)
9D0214BC  A844001B   SWL A0, 27(V0)
9D0214C0  B8440018   SWR A0, 24(V0)
9D0214C4  A843001F   SWL V1, 31(V0)
9D0214C8  B843001C   SWR V1, 28(V0)
397:                    memcpy (&snssFile->baseBlock.mirrorState, &blockBytes[0x1929], 0x4);
9D0214CC  2602193E   ADDIU V0, S0, 6462
9D0214D0  8BA3193C   LWL V1, 6460(SP)
9D0214D4  9BA31939   LWR V1, 6457(SP)
9D0214D8  AA031941   SWL V1, 6465(S0)
9D0214DC  B8430000   SWR V1, 0(V0)
398:                    snssFile->baseBlock.vramAddress = *((unsigned short *) &blockBytes[0x192D]);
9D0214E0  93A2193D   LBU V0, 6461(SP)
9D0214E4  93A3193E   LBU V1, 6462(SP)
9D0214E8  00031A00   SLL V1, V1, 8
9D0214EC  00621025   OR V0, V1, V0
399:                    snssFile->baseBlock.vramAddress = swap16 (snssFile->baseBlock.vramAddress);
9D0214F0  7C0210A0   WSBH V0, V0
9D0214F4  A6021942   SH V0, 6466(S0)
400:                    snssFile->baseBlock.spriteRamAddress = blockBytes[0x192F];
9D0214F8  93A2193F   LBU V0, 6463(SP)
9D0214FC  A2021944   SB V0, 6468(S0)
401:                    snssFile->baseBlock.tileXOffset = blockBytes[0x1930];
9D021500  93A21940   LBU V0, 6464(SP)
9D021504  A2021945   SB V0, 6469(S0)
402:                 
403:                    return SNSS_OK;
9D021508  00001821   ADDU V1, ZERO, ZERO
404:                 }
9D02150C  00601021   ADDU V0, V1, ZERO
9D021510  8FBF195C   LW RA, 6492(SP)
9D021514  8FB01958   LW S0, 6488(SP)
9D021518  03E00008   JR RA
9D02151C  27BD1960   ADDIU SP, SP, 6496
405:                 
406:                 /**************************************************************************/
407:                 
408:                 static SNSS_RETURN_CODE 
409:                 SNSS_WriteBaseBlock (SNSS_FILE *snssFile)
410:                 {
9D0215D4  27BDE6A0   ADDIU SP, SP, -6496
9D0215D8  AFBF195C   SW RA, 6492(SP)
9D0215DC  AFB01958   SW S0, 6488(SP)
9D0215E0  00808021   ADDU S0, A0, ZERO
411:                    SnssBlockHeader header;
412:                    SNSS_RETURN_CODE returnCode;
413:                    char blockBytes[BASE_BLOCK_LENGTH];
414:                    unsigned short tempShort;
415:                 
416:                    strcpy (header.tag, "BASR");
9D0215E4  3C025253   LUI V0, 21075
9D0215E8  24424142   ADDIU V0, V0, 16706
9D0215EC  AFA20010   SW V0, 16(SP)
9D0215F0  A3A00014   SB ZERO, 20(SP)
417:                    header.blockVersion = SNSS_BLOCK_VERSION;
9D0215F4  24020001   ADDIU V0, ZERO, 1
9D0215F8  AFA20018   SW V0, 24(SP)
418:                    header.blockLength = BASE_BLOCK_LENGTH;
9D0215FC  24021931   ADDIU V0, ZERO, 6449
9D021600  AFA2001C   SW V0, 28(SP)
419:                 
420:                    if ((returnCode = SNSS_WriteBlockHeader (&header, snssFile)) != SNSS_OK)
9D021604  27A40010   ADDIU A0, SP, 16
9D021608  0F408548   JAL .LFB11, SNSS_WriteBlockHeader, .LFE19
9D02160C  02002821   ADDU A1, S0, ZERO
9D021610  14400093   BNE V0, ZERO, 0x9D021860
9D021614  00401821   ADDU V1, V0, ZERO
421:                    {
422:                       return returnCode;
423:                    }
424:                 
425:                    blockBytes[0x0] = snssFile->baseBlock.regA;
9D021618  92020014   LBU V0, 20(S0)
9D02161C  A3A20020   SB V0, 32(SP)
426:                    blockBytes[0x1] = snssFile->baseBlock.regX;
9D021620  92020015   LBU V0, 21(S0)
9D021624  A3A20021   SB V0, 33(SP)
427:                    blockBytes[0x2] = snssFile->baseBlock.regY;
9D021628  92020016   LBU V0, 22(S0)
9D02162C  A3A20022   SB V0, 34(SP)
428:                    blockBytes[0x3] = snssFile->baseBlock.regFlags;
9D021630  92020017   LBU V0, 23(S0)
9D021634  A3A20023   SB V0, 35(SP)
429:                    blockBytes[0x4] = snssFile->baseBlock.regStack;
9D021638  92020018   LBU V0, 24(S0)
9D02163C  A3A20024   SB V0, 36(SP)
430:                    tempShort = swap16 (snssFile->baseBlock.regPc);
9D021640  9602001A   LHU V0, 26(S0)
9D021644  7C0210A0   WSBH V0, V0
9D021648  A7A21952   SH V0, 6482(SP)
431:                    blockBytes[0x5] = ((char *) &tempShort)[0];
9D02164C  A3A20025   SB V0, 37(SP)
432:                    blockBytes[0x6] = ((char *) &tempShort)[1];
9D021650  00021202   SRL V0, V0, 8
9D021654  A3A20026   SB V0, 38(SP)
433:                    blockBytes[0x7] = snssFile->baseBlock.reg2000;
9D021658  9202001C   LBU V0, 28(S0)
9D02165C  A3A20027   SB V0, 39(SP)
434:                    blockBytes[0x8] = snssFile->baseBlock.reg2001;
9D021660  9202001D   LBU V0, 29(S0)
9D021664  A3A20028   SB V0, 40(SP)
435:                    memcpy (&blockBytes[0x9], &snssFile->baseBlock.cpuRam, 0x800);
9D021668  2603001E   ADDIU V1, S0, 30
9D02166C  27A20029   ADDIU V0, SP, 41
9D021670  2608081E   ADDIU T0, S0, 2078
9D021674  88670003   LWL A3, 3(V1)
9D021678  98670000   LWR A3, 0(V1)
9D02167C  88660007   LWL A2, 7(V1)
9D021680  98660004   LWR A2, 4(V1)
9D021684  8865000B   LWL A1, 11(V1)
9D021688  98650008   LWR A1, 8(V1)
9D02168C  8864000F   LWL A0, 15(V1)
9D021690  9864000C   LWR A0, 12(V1)
9D021694  A8470003   SWL A3, 3(V0)
9D021698  B8470000   SWR A3, 0(V0)
9D02169C  A8460007   SWL A2, 7(V0)
9D0216A0  B8460004   SWR A2, 4(V0)
9D0216A4  A845000B   SWL A1, 11(V0)
9D0216A8  B8450008   SWR A1, 8(V0)
9D0216AC  A844000F   SWL A0, 15(V0)
9D0216B0  B844000C   SWR A0, 12(V0)
9D0216B4  24630010   ADDIU V1, V1, 16
9D0216B8  1468FFEE   BNE V1, T0, 0x9D021674
9D0216BC  24420010   ADDIU V0, V0, 16
436:                    memcpy (&blockBytes[0x809], &snssFile->baseBlock.spriteRam, 0x100);
9D0216C0  2603081E   ADDIU V1, S0, 2078
9D0216C4  27A20829   ADDIU V0, SP, 2089
9D0216C8  2608091E   ADDIU T0, S0, 2334
9D0216CC  88670003   LWL A3, 3(V1)
9D0216D0  98670000   LWR A3, 0(V1)
9D0216D4  88660007   LWL A2, 7(V1)
9D0216D8  98660004   LWR A2, 4(V1)
9D0216DC  8865000B   LWL A1, 11(V1)
9D0216E0  98650008   LWR A1, 8(V1)
9D0216E4  8864000F   LWL A0, 15(V1)
9D0216E8  9864000C   LWR A0, 12(V1)
9D0216EC  A8470003   SWL A3, 3(V0)
9D0216F0  B8470000   SWR A3, 0(V0)
9D0216F4  A8460007   SWL A2, 7(V0)
9D0216F8  B8460004   SWR A2, 4(V0)
9D0216FC  A845000B   SWL A1, 11(V0)
9D021700  B8450008   SWR A1, 8(V0)
9D021704  A844000F   SWL A0, 15(V0)
9D021708  B844000C   SWR A0, 12(V0)
9D02170C  24630010   ADDIU V1, V1, 16
9D021710  1468FFEE   BNE V1, T0, 0x9D0216CC
9D021714  24420010   ADDIU V0, V0, 16
437:                    memcpy (&blockBytes[0x909], &snssFile->baseBlock.ppuRam, 0x1000);
9D021718  2603091E   ADDIU V1, S0, 2334
9D02171C  27A20929   ADDIU V0, SP, 2345
9D021720  2608191E   ADDIU T0, S0, 6430
9D021724  88670003   LWL A3, 3(V1)
9D021728  98670000   LWR A3, 0(V1)
9D02172C  88660007   LWL A2, 7(V1)
9D021730  98660004   LWR A2, 4(V1)
9D021734  8865000B   LWL A1, 11(V1)
9D021738  98650008   LWR A1, 8(V1)
9D02173C  8864000F   LWL A0, 15(V1)
9D021740  9864000C   LWR A0, 12(V1)
9D021744  A8470003   SWL A3, 3(V0)
9D021748  B8470000   SWR A3, 0(V0)
9D02174C  A8460007   SWL A2, 7(V0)
9D021750  B8460004   SWR A2, 4(V0)
9D021754  A845000B   SWL A1, 11(V0)
9D021758  B8450008   SWR A1, 8(V0)
9D02175C  A844000F   SWL A0, 15(V0)
9D021760  B844000C   SWR A0, 12(V0)
9D021764  24630010   ADDIU V1, V1, 16
9D021768  1468FFEE   BNE V1, T0, 0x9D021724
9D02176C  24420010   ADDIU V0, V0, 16
438:                    memcpy (&blockBytes[0x1909], &snssFile->baseBlock.palette, 0x20);
9D021770  2602191E   ADDIU V0, S0, 6430
9D021774  88490003   LWL T1, 3(V0)
9D021778  98490000   LWR T1, 0(V0)
9D02177C  88480007   LWL T0, 7(V0)
9D021780  98480004   LWR T0, 4(V0)
9D021784  8847000B   LWL A3, 11(V0)
9D021788  98470008   LWR A3, 8(V0)
9D02178C  8846000F   LWL A2, 15(V0)
9D021790  9846000C   LWR A2, 12(V0)
9D021794  88450013   LWL A1, 19(V0)
9D021798  98450010   LWR A1, 16(V0)
9D02179C  88440017   LWL A0, 23(V0)
9D0217A0  98440014   LWR A0, 20(V0)
9D0217A4  8843001B   LWL V1, 27(V0)
9D0217A8  98430018   LWR V1, 24(V0)
9D0217AC  884A001F   LWL T2, 31(V0)
9D0217B0  984A001C   LWR T2, 28(V0)
9D0217B4  ABA9192C   SWL T1, 6444(SP)
9D0217B8  BBA91929   SWR T1, 6441(SP)
9D0217BC  ABA81930   SWL T0, 6448(SP)
9D0217C0  BBA8192D   SWR T0, 6445(SP)
9D0217C4  ABA71934   SWL A3, 6452(SP)
9D0217C8  BBA71931   SWR A3, 6449(SP)
9D0217CC  ABA61938   SWL A2, 6456(SP)
9D0217D0  BBA61935   SWR A2, 6453(SP)
9D0217D4  ABA5193C   SWL A1, 6460(SP)
9D0217D8  BBA51939   SWR A1, 6457(SP)
9D0217DC  ABA41940   SWL A0, 6464(SP)
9D0217E0  BBA4193D   SWR A0, 6461(SP)
9D0217E4  ABA31944   SWL V1, 6468(SP)
9D0217E8  BBA31941   SWR V1, 6465(SP)
9D0217EC  ABAA1948   SWL T2, 6472(SP)
9D0217F0  BBAA1945   SWR T2, 6469(SP)
439:                    memcpy (&blockBytes[0x1929], &snssFile->baseBlock.mirrorState, 0x4);
9D0217F4  2602193E   ADDIU V0, S0, 6462
9D0217F8  88430003   LWL V1, 3(V0)
9D0217FC  98430000   LWR V1, 0(V0)
9D021800  ABA3194C   SWL V1, 6476(SP)
9D021804  BBA31949   SWR V1, 6473(SP)
440:                    tempShort = swap16 (snssFile->baseBlock.vramAddress);
9D021808  96021942   LHU V0, 6466(S0)
9D02180C  7C0210A0   WSBH V0, V0
9D021810  A7A21952   SH V0, 6482(SP)
441:                    blockBytes[0x192D] = ((char *) &tempShort)[0];
9D021814  A3A2194D   SB V0, 6477(SP)
442:                    blockBytes[0x192E] = ((char *) &tempShort)[1];
9D021818  00021202   SRL V0, V0, 8
9D02181C  A3A2194E   SB V0, 6478(SP)
443:                    blockBytes[0x192F] = snssFile->baseBlock.spriteRamAddress;
9D021820  92021944   LBU V0, 6468(S0)
9D021824  A3A2194F   SB V0, 6479(SP)
444:                    blockBytes[0x1930] = snssFile->baseBlock.tileXOffset;
9D021828  92021945   LBU V0, 6469(S0)
9D02182C  A3A21950   SB V0, 6480(SP)
445:                 
446:                    if (fwrite (blockBytes, BASE_BLOCK_LENGTH, 1, snssFile->fp) != 1)
9D021830  27A40020   ADDIU A0, SP, 32
9D021834  24051931   ADDIU A1, ZERO, 6449
9D021838  24060001   ADDIU A2, ZERO, 1
9D02183C  0F40F1FB   JAL fwrite
9D021840  8E070000   LW A3, 0(S0)
9D021844  24040001   ADDIU A0, ZERO, 1
9D021848  14440005   BNE V0, A0, 0x9D021860
9D02184C  24030005   ADDIU V1, ZERO, 5
447:                    {
448:                       return SNSS_WRITE_FAILED;
449:                    }
450:                 
451:                    snssFile->headerBlock.numberOfBlocks++;
9D021850  8E020010   LW V0, 16(S0)
9D021854  24420001   ADDIU V0, V0, 1
9D021858  AE020010   SW V0, 16(S0)
452:                 
453:                    return SNSS_OK;
9D02185C  00001821   ADDU V1, ZERO, ZERO
454:                 }
9D021860  00601021   ADDU V0, V1, ZERO
9D021864  8FBF195C   LW RA, 6492(SP)
9D021868  8FB01958   LW S0, 6488(SP)
9D02186C  03E00008   JR RA
9D021870  27BD1960   ADDIU SP, SP, 6496
455:                 
456:                 /**************************************************************************/
457:                 /* functions for reading and writing VRAM blocks */
458:                 /**************************************************************************/
459:                 
460:                 static SNSS_RETURN_CODE 
461:                 SNSS_ReadVramBlock (SNSS_FILE *snssFile)
462:                 {
463:                    SnssBlockHeader header;
464:                 
465:                    if (SNSS_ReadBlockHeader (&header, snssFile) != SNSS_OK)
9D021D6C  27A40010   ADDIU A0, SP, 16
466:                    {
467:                       return SNSS_READ_FAILED;
468:                    }
469:                 
470:                    if (fread (snssFile->vramBlock.vram, MIN (header.blockLength, VRAM_16K), 1, snssFile->fp) != 1)
9D021D80  8FA2001C   LW V0, 28(SP)
471:                    {
472:                       return SNSS_READ_FAILED;
473:                    }
474:                 
475:                    snssFile->vramBlock.vramSize = header.blockLength;
9D021DB0  8FA2001C   LW V0, 28(SP)
9D021DB4  A6021946   SH V0, 6470(S0)
476:                 
477:                    return SNSS_OK;
9D021DB8  0B4087E3   J 0x9D021F8C
9D021DBC  00001821   ADDU V1, ZERO, ZERO
478:                 }
479:                 
480:                 /**************************************************************************/
481:                 
482:                 static SNSS_RETURN_CODE 
483:                 SNSS_WriteVramBlock (SNSS_FILE *snssFile)
484:                 {
485:                    SnssBlockHeader header;
486:                    SNSS_RETURN_CODE returnCode;
487:                 
488:                    strcpy (header.tag, "VRAM");
9D022008  3C024D41   LUI V0, 19777
489:                    header.blockVersion = SNSS_BLOCK_VERSION;
9D022018  24020001   ADDIU V0, ZERO, 1
490:                    header.blockLength = snssFile->vramBlock.vramSize;
9D022020  94821946   LHU V0, 6470(A0)
491:                 
492:                    if ((returnCode = SNSS_WriteBlockHeader (&header, snssFile)) != SNSS_OK)
9D022028  27A40010   ADDIU A0, SP, 16
493:                    {
494:                       return returnCode;
495:                    }
496:                 
497:                    if (fwrite (snssFile->vramBlock.vram, snssFile->vramBlock.vramSize, 1, snssFile->fp) != 1)
9D02203C  26041948   ADDIU A0, S0, 6472
498:                    {
499:                       return SNSS_WRITE_FAILED;
500:                    }
501:                 
502:                    snssFile->headerBlock.numberOfBlocks++;
9D02205C  8E020010   LW V0, 16(S0)
9D022060  24420001   ADDIU V0, V0, 1
9D022064  AE020010   SW V0, 16(S0)
503:                 
504:                    return SNSS_OK;
9D022068  0B40889E   J 0x9D022278
9D02206C  00001821   ADDU V1, ZERO, ZERO
505:                 }
506:                 
507:                 /**************************************************************************/
508:                 /* functions for reading and writing SRAM blocks */
509:                 /**************************************************************************/
510:                 
511:                 static SNSS_RETURN_CODE 
512:                 SNSS_ReadSramBlock (SNSS_FILE *snssFile)
513:                 {
514:                    SnssBlockHeader header;
515:                 
516:                    if (SNSS_ReadBlockHeader (&header, snssFile) != SNSS_OK)
9D021DC0  27A40010   ADDIU A0, SP, 16
517:                    {
518:                       return SNSS_READ_FAILED;
519:                    }
520:                 
521:                    if (fread (&snssFile->sramBlock.sramEnabled, 1, 1, snssFile->fp) != 1)
9D021DD4  2604594A   ADDIU A0, S0, 22858
522:                    {
523:                       return SNSS_READ_FAILED;
524:                    }
525:                 
526:                    /* read blockLength - 1 bytes to get all of the SRAM */
527:                    if (fread (&snssFile->sramBlock.sram, MIN (header.blockLength - 1, SRAM_8K), 1, snssFile->fp) != 1)
9D021DF4  8FA2001C   LW V0, 28(SP)
528:                    {
529:                       return SNSS_READ_FAILED;
530:                    }
531:                 
532:                    /* SRAM size is the size of the block - 1 (SRAM enabled byte) */
533:                    snssFile->sramBlock.sramSize = header.blockLength - 1;
9D021E28  8FA2001C   LW V0, 28(SP)
9D021E2C  2442FFFF   ADDIU V0, V0, -1
9D021E30  A6025948   SH V0, 22856(S0)
534:                 
535:                    return SNSS_OK;
9D021E34  0B4087E3   J 0x9D021F8C
9D021E38  00001821   ADDU V1, ZERO, ZERO
536:                 }
537:                 
538:                 /**************************************************************************/
539:                 
540:                 static SNSS_RETURN_CODE 
541:                 SNSS_WriteSramBlock (SNSS_FILE *snssFile)
542:                 {
543:                    SnssBlockHeader header;
544:                    SNSS_RETURN_CODE returnCode;
545:                 
546:                    strcpy (header.tag, "SRAM");
9D022070  3C024D41   LUI V0, 19777
547:                    header.blockVersion = SNSS_BLOCK_VERSION;
9D022080  24020001   ADDIU V0, ZERO, 1
548:                    /* length of block is size of SRAM plus SRAM enabled byte */
549:                    header.blockLength = snssFile->sramBlock.sramSize + 1;
9D022088  94825948   LHU V0, 22856(A0)
550:                    if ((returnCode = SNSS_WriteBlockHeader (&header, snssFile)) != SNSS_OK)
9D022094  27A40010   ADDIU A0, SP, 16
551:                    {
552:                       return returnCode;
553:                    }
554:                 
555:                    if (fwrite (&snssFile->sramBlock.sramEnabled, 1, 1, snssFile->fp) != 1)
9D0220A8  2604594A   ADDIU A0, S0, 22858
556:                    {
557:                       return SNSS_WRITE_FAILED;
558:                    }
559:                 
560:                    if (fwrite (snssFile->sramBlock.sram, snssFile->sramBlock.sramSize, 1, snssFile->fp) != 1)
9D0220C8  2604594B   ADDIU A0, S0, 22859
561:                    {
562:                       return SNSS_WRITE_FAILED;
563:                    }
564:                 
565:                    snssFile->headerBlock.numberOfBlocks++;
9D0220E8  8E020010   LW V0, 16(S0)
9D0220EC  24420001   ADDIU V0, V0, 1
9D0220F0  AE020010   SW V0, 16(S0)
566:                 
567:                    return SNSS_OK;
9D0220F4  0B40889E   J 0x9D022278
9D0220F8  00001821   ADDU V1, ZERO, ZERO
568:                 }
569:                 
570:                 /**************************************************************************/
571:                 /* functions for reading and writing mapper data blocks */
572:                 /**************************************************************************/
573:                 
574:                 static SNSS_RETURN_CODE 
575:                 SNSS_ReadMapperBlock (SNSS_FILE *snssFile)
576:                 {
577:                    char *blockBytes;
578:                    int i;
579:                    SnssBlockHeader header;
580:                 
581:                    if (SNSS_ReadBlockHeader (&header, snssFile) != SNSS_OK)
9D021E3C  27A40010   ADDIU A0, SP, 16
9D021E40  0F408488   JAL .LFB10, SNSS_ReadBlockHeader, .LFE14
9D021E44  02002821   ADDU A1, S0, ZERO
9D021E48  14400050   BNE V0, ZERO, 0x9D021F8C
9D021E4C  24030004   ADDIU V1, ZERO, 4
582:                    {
583:                       return SNSS_READ_FAILED;
584:                    }
585:                 
586:                    if ((blockBytes = (char *) malloc (0x8 + 0x10 + 0x80)) == NULL)
9D021E50  0F40AE73   JAL .Letext0, .LFE16, malloc
9D021E54  24040098   ADDIU A0, ZERO, 152
9D021E58  00408821   ADDU S1, V0, ZERO
9D021E5C  1040004B   BEQ V0, ZERO, 0x9D021F8C
9D021E60  24030006   ADDIU V1, ZERO, 6
587:                    {
588:                       return SNSS_OUT_OF_MEMORY;
589:                    }
590:                 
591:                    if (fread (blockBytes, MIN (0x8 + 0x10 + 0x80, header.blockLength), 1, snssFile->fp) != 1)
9D021E64  8FA2001C   LW V0, 28(SP)
9D021E68  2C450099   SLTIU A1, V0, 153
9D021E6C  02202021   ADDU A0, S1, ZERO
9D021E70  24030098   ADDIU V1, ZERO, 152
9D021E74  0045180B   MOVN V1, V0, A1
9D021E78  00602821   ADDU A1, V1, ZERO
9D021E7C  24060001   ADDIU A2, ZERO, 1
9D021E80  0F40CC64   JAL .Letext0, .LFE1, fread
9D021E84  8E070000   LW A3, 0(S0)
9D021E88  24030001   ADDIU V1, ZERO, 1
9D021E8C  10430005   BEQ V0, V1, 0x9D021EA4
9D021E90  00001021   ADDU V0, ZERO, ZERO
592:                    {
593:                       free(blockBytes);
9D021E94  0F40D0ED   JAL free
9D021E98  02202021   ADDU A0, S1, ZERO
594:                       return SNSS_READ_FAILED;
9D021E9C  0B4087E3   J 0x9D021F8C
9D021EA0  24030004   ADDIU V1, ZERO, 4
595:                    }
596:                 
597:                    for (i = 0; i < 4; i++)
9D021EA4  24050008   ADDIU A1, ZERO, 8
9D021EA8  02221821   ADDU V1, S1, V0
9D021EBC  1445FFFA   BNE V0, A1, 0x9D021EA8
9D021EC0  A464794C   SH A0, 31052(V1)
9D021EC4  00001821   ADDU V1, ZERO, ZERO
598:                    {
599:                       snssFile->mapperBlock.prgPages[i] = *((unsigned short *) &blockBytes[i * 2]);
600:                       snssFile->mapperBlock.prgPages[i] = swap16 (snssFile->mapperBlock.prgPages[i]);
9D021EAC  94640000   LHU A0, 0(V1)
9D021EB0  7C0420A0   WSBH A0, A0
9D021EB4  02021821   ADDU V1, S0, V0
9D021EB8  24420002   ADDIU V0, V0, 2
601:                    }
602:                 
603:                    for (i = 0; i < 8; i++)
9D021EC8  24050010   ADDIU A1, ZERO, 16
9D021ECC  02231021   ADDU V0, S1, V1
9D021EE0  1465FFFA   BNE V1, A1, 0x9D021ECC
9D021EE4  A4447954   SH A0, 31060(V0)
604:                    {
605:                       snssFile->mapperBlock.chrPages[i] = *((unsigned short *) &blockBytes[0x8 + (i * 2)]);
606:                       snssFile->mapperBlock.chrPages[i] = swap16 (snssFile->mapperBlock.chrPages[i]);
9D021ED0  94440008   LHU A0, 8(V0)
9D021ED4  7C0420A0   WSBH A0, A0
9D021ED8  02031021   ADDU V0, S0, V1
9D021EDC  24630002   ADDIU V1, V1, 2
607:                    }
608:                 
609:                    memcpy (&snssFile->mapperBlock.extraData.mapperData, &blockBytes[0x18], 0x80);
9D021EE8  26220018   ADDIU V0, S1, 24
9D021EEC  26107964   ADDIU S0, S0, 31076
9D021EF0  26270098   ADDIU A3, S1, 152
9D021EF4  8C460000   LW A2, 0(V0)
9D021EF8  8C450004   LW A1, 4(V0)
9D021EFC  8C440008   LW A0, 8(V0)
9D021F00  8C43000C   LW V1, 12(V0)
9D021F04  AA060003   SWL A2, 3(S0)
9D021F08  BA060000   SWR A2, 0(S0)
9D021F0C  AA050007   SWL A1, 7(S0)
9D021F10  BA050004   SWR A1, 4(S0)
9D021F14  AA04000B   SWL A0, 11(S0)
9D021F18  BA040008   SWR A0, 8(S0)
9D021F1C  AA03000F   SWL V1, 15(S0)
9D021F20  BA03000C   SWR V1, 12(S0)
9D021F24  24420010   ADDIU V0, V0, 16
9D021F28  1447FFF2   BNE V0, A3, 0x9D021EF4
9D021F2C  26100010   ADDIU S0, S0, 16
610:                 
611:                    free (blockBytes);
9D021F30  0F40D0ED   JAL free
9D021F34  02202021   ADDU A0, S1, ZERO
612:                 
613:                    return SNSS_OK;
9D021F38  0B4087E3   J 0x9D021F8C
9D021F3C  00001821   ADDU V1, ZERO, ZERO
614:                 }
615:                 
616:                 /**************************************************************************/
617:                 
618:                 static SNSS_RETURN_CODE 
619:                 SNSS_WriteMapperBlock (SNSS_FILE *snssFile)
620:                 {
621:                    SnssBlockHeader header;
622:                    char blockBytes[MAPPER_BLOCK_LENGTH];
623:                    unsigned short tempShort;
624:                    int i;
625:                    SNSS_RETURN_CODE returnCode;
626:                 
627:                    strcpy (header.tag, "MPRD");
9D0220FC  3C024452   LUI V0, 17490
628:                    header.blockVersion = SNSS_BLOCK_VERSION;
9D02210C  24020001   ADDIU V0, ZERO, 1
629:                    header.blockLength = MAPPER_BLOCK_LENGTH;
9D022114  24020098   ADDIU V0, ZERO, 152
630:                 
631:                    if ((returnCode = SNSS_WriteBlockHeader (&header, snssFile)) != SNSS_OK)
9D02211C  27A400A8   ADDIU A0, SP, 168
632:                    {
633:                       return returnCode;
634:                    }
635:                 
636:                    for (i = 0; i < 4; i++)
9D022158  1445FFF8   BNE V0, A1, .LBB83, .LBB84
637:                    {
638:                       tempShort = swap16 (snssFile->mapperBlock.prgPages[i]);
9D02213C  9483794C   LHU V1, 31052(A0)
639:                       blockBytes[(i * 2) + 0] = ((char *) &tempShort)[0];
9D022148  A0430000   SB V1, 0(V0)
640:                       blockBytes[(i * 2) + 1] = ((char *) &tempShort)[1];
9D02214C  00031A02   SRL V1, V1, 8
641:                    }
642:                 
643:                    for (i = 0; i < 8; i++)
9D022188  1445FFF8   BNE V0, A1, .LBB85, .LBB86
644:                    {
645:                       tempShort = swap16 (snssFile->mapperBlock.chrPages[i]);
9D02216C  94837954   LHU V1, 31060(A0)
646:                       blockBytes[0x8 + (i * 2) + 0] = ((char *) &tempShort)[0];
9D022178  A0430000   SB V1, 0(V0)
647:                       blockBytes[0x8 + (i * 2) + 1] = ((char *) &tempShort)[1];
9D02217C  00031A02   SRL V1, V1, 8
648:                    }
649:                 
650:                    memcpy (&blockBytes[0x18], &snssFile->mapperBlock.extraData.mapperData, 0x80);
9D022190  26027964   ADDIU V0, S0, 31076
651:                 
652:                    if (fwrite (blockBytes, MAPPER_BLOCK_LENGTH, 1, snssFile->fp) != 1)
9D0221D8  27A40010   ADDIU A0, SP, 16
653:                    {
654:                       return SNSS_WRITE_FAILED;
655:                    }
656:                 
657:                    snssFile->headerBlock.numberOfBlocks++;
9D0221F8  8E020010   LW V0, 16(S0)
9D0221FC  24420001   ADDIU V0, V0, 1
9D022200  AE020010   SW V0, 16(S0)
658:                 
659:                    return SNSS_OK;
9D022204  0B40889E   J 0x9D022278
9D022208  00001821   ADDU V1, ZERO, ZERO
660:                 }
661:                 
662:                 /**************************************************************************/
663:                 /* functions for reading and writing controller data blocks */
664:                 /**************************************************************************/
665:                 
666:                 static SNSS_RETURN_CODE 
667:                 SNSS_ReadControllersBlock (SNSS_FILE *snssFile)
668:                 {
669:                    /* quell warnings */
670:                    snssFile = snssFile;
671:                 
672:                    return SNSS_OK;
673:                 }
674:                 
675:                 /**************************************************************************/
676:                 
677:                 static SNSS_RETURN_CODE 
678:                 SNSS_WriteControllersBlock (SNSS_FILE *snssFile)
679:                 {
680:                    /* quell warnings */
681:                    snssFile = snssFile;
682:                 
683:                    return SNSS_OK;
684:                 }
685:                 
686:                 /**************************************************************************/
687:                 /* functions for reading and writing sound blocks */
688:                 /**************************************************************************/
689:                 
690:                 static SNSS_RETURN_CODE 
691:                 SNSS_ReadSoundBlock (SNSS_FILE *snssFile)
692:                 {
693:                    SnssBlockHeader header;
694:                 
695:                    if (SNSS_ReadBlockHeader (&header, snssFile) != SNSS_OK)
9D021F40  27A40010   ADDIU A0, SP, 16
696:                    {
697:                       return SNSS_READ_FAILED;
698:                    }
699:                 
700:                    if (fread (snssFile->soundBlock.soundRegisters, MIN (header.blockLength, 0x16), 1, snssFile->fp) != 1)
9D021F54  8FA2001C   LW V0, 28(SP)
701:                    {
702:                       return SNSS_READ_FAILED;
9D021F78  38420001   XORI V0, V0, 1
9D021F7C  24030004   ADDIU V1, ZERO, 4
703:                    }
704:                 
705:                    return SNSS_OK;
706:                 }
707:                 
708:                 /**************************************************************************/
709:                 
710:                 static SNSS_RETURN_CODE 
711:                 SNSS_WriteSoundBlock (SNSS_FILE *snssFile)
712:                 {
713:                    SnssBlockHeader header;
714:                    SNSS_RETURN_CODE returnCode;
715:                 
716:                    strcpy (header.tag, "SOUN");
9D02220C  3C024E55   LUI V0, 20053
717:                    header.blockVersion = SNSS_BLOCK_VERSION;
9D02221C  24020001   ADDIU V0, ZERO, 1
718:                    header.blockLength = SOUND_BLOCK_LENGTH;
9D022224  24020016   ADDIU V0, ZERO, 22
719:                 
720:                    if ((returnCode = SNSS_WriteBlockHeader (&header, snssFile)) != SNSS_OK)
9D02222C  27A40010   ADDIU A0, SP, 16
721:                    {
722:                       return returnCode;
723:                    }
724:                 
725:                    if (fwrite (snssFile->soundBlock.soundRegisters, SOUND_BLOCK_LENGTH, 1, snssFile->fp) != 1)
9D022240  260479E5   ADDIU A0, S0, 31205
726:                    {
727:                       return SNSS_WRITE_FAILED;
728:                    }
729:                 
730:                    snssFile->headerBlock.numberOfBlocks++;
9D022260  8E020010   LW V0, 16(S0)
9D022264  24420001   ADDIU V0, V0, 1
9D022268  AE020010   SW V0, 16(S0)
731:                 
732:                    return SNSS_OK;
9D02226C  0B40889E   J 0x9D022278
9D022270  00001821   ADDU V1, ZERO, ZERO
733:                 }
734:                 
735:                 /**************************************************************************/
736:                 /* general functions for reading and writing SNSS data blocks */
737:                 /**************************************************************************/
738:                 
739:                 SNSS_RETURN_CODE
740:                 SNSS_ReadBlock (SNSS_FILE *snssFile, SNSS_BLOCK_TYPE blockType)
741:                 {
9D021D10  27BDFFD0   ADDIU SP, SP, -48
9D021D14  AFBF002C   SW RA, 44(SP)
9D021D18  AFB10028   SW S1, 40(SP)
9D021D1C  AFB00024   SW S0, 36(SP)
742:                    switch (blockType)
9D021D04  2CA20006   SLTIU V0, A1, 6
9D021D08  10400011   BEQ V0, ZERO, 0x9D021D50
9D021D0C  00052880   SLL A1, A1, 2
9D021D20  3C029D02   LUI V0, -25342
9D021D24  24421D38   ADDIU V0, V0, 7480
9D021D28  00452821   ADDU A1, V0, A1
9D021D2C  8CA20000   LW V0, 0(A1)
9D021D30  00400008   JR V0
9D021D34  00808021   ADDU S0, A0, ZERO
743:                    {
744:                    case SNSS_BASR:
745:                       return SNSS_ReadBaseBlock (snssFile);
9D021D5C  0F4084A7   JAL .LFB19, SNSS_ReadBaseBlock, .LFE10
9D021D60  00000000   NOP
9D021D64  0B4087E3   J 0x9D021F8C
9D021D68  00401821   ADDU V1, V0, ZERO
746:                 
747:                    case SNSS_VRAM:
748:                       return SNSS_ReadVramBlock (snssFile);
749:                 
750:                    case SNSS_SRAM:
751:                       return SNSS_ReadSramBlock (snssFile);
752:                 
753:                    case SNSS_MPRD:
754:                       return SNSS_ReadMapperBlock (snssFile);
755:                 
756:                    case SNSS_CNTR:
757:                       return SNSS_ReadControllersBlock (snssFile);
9D021F88  00001821   ADDU V1, ZERO, ZERO
758:                 
759:                    case SNSS_SOUN:
760:                       return SNSS_ReadSoundBlock (snssFile);
761:                 
762:                    case SNSS_UNKNOWN_BLOCK:
763:                    default:
764:                        return SNSS_UNSUPPORTED_BLOCK;
9D021D50  24030007   ADDIU V1, ZERO, 7
765:                    }
766:                 }
9D021D54  03E00008   JR RA
9D021D58  00601021   ADDU V0, V1, ZERO
9D021F8C  00601021   ADDU V0, V1, ZERO
9D021F90  8FBF002C   LW RA, 44(SP)
9D021F94  8FB10028   LW S1, 40(SP)
9D021F98  8FB00024   LW S0, 36(SP)
9D021F9C  03E00008   JR RA
9D021FA0  27BD0030   ADDIU SP, SP, 48
767:                 
768:                 /**************************************************************************/
769:                 
770:                 SNSS_RETURN_CODE
771:                 SNSS_WriteBlock (SNSS_FILE *snssFile, SNSS_BLOCK_TYPE blockType)
772:                 {
9D021FB0  27BDFF38   ADDIU SP, SP, -200
9D021FB4  AFBF00C4   SW RA, 196(SP)
9D021FB8  AFB000C0   SW S0, 192(SP)
773:                    switch (blockType)
9D021FA4  2CA20006   SLTIU V0, A1, 6
9D021FA8  10400010   BEQ V0, ZERO, 0x9D021FEC
9D021FAC  00052880   SLL A1, A1, 2
9D021FBC  3C029D02   LUI V0, -25342
9D021FC0  24421FD4   ADDIU V0, V0, 8148
9D021FC4  00452821   ADDU A1, V0, A1
9D021FC8  8CA20000   LW V0, 0(A1)
9D021FCC  00400008   JR V0
9D021FD0  00808021   ADDU S0, A0, ZERO
774:                    {
775:                    case SNSS_BASR:
776:                       return SNSS_WriteBaseBlock (snssFile);
9D021FF8  0F408575   JAL .LFB20, SNSS_WriteBaseBlock, .LFE11
9D021FFC  00000000   NOP
9D022000  0B40889E   J 0x9D022278
9D022004  00401821   ADDU V1, V0, ZERO
777:                 
778:                    case SNSS_VRAM:
779:                       return SNSS_WriteVramBlock (snssFile);
780:                 
781:                    case SNSS_SRAM:
782:                       return SNSS_WriteSramBlock (snssFile);
783:                 
784:                    case SNSS_MPRD:
785:                       return SNSS_WriteMapperBlock (snssFile);
786:                 
787:                    case SNSS_CNTR:
788:                       return SNSS_WriteControllersBlock (snssFile);
9D022274  00001821   ADDU V1, ZERO, ZERO
789:                 
790:                    case SNSS_SOUN:
791:                       return SNSS_WriteSoundBlock (snssFile);
792:                 
793:                    case SNSS_UNKNOWN_BLOCK:
794:                    default:
795:                        return SNSS_UNSUPPORTED_BLOCK;
9D021FEC  24030007   ADDIU V1, ZERO, 7
796:                    }
797:                 }
9D021FF0  03E00008   JR RA
9D021FF4  00601021   ADDU V0, V1, ZERO
9D022278  00601021   ADDU V0, V1, ZERO
9D02227C  8FBF00C4   LW RA, 196(SP)
9D022280  8FB000C0   LW S0, 192(SP)
9D022284  03E00008   JR RA
9D022288  27BD00C8   ADDIU SP, SP, 200
798:                 
799:                 /*
800:                 ** $Log: libsnss.c,v $
801:                 ** Revision 1.2  2001/04/27 14:37:11  neil
802:                 ** wheeee
803:                 **
804:                 ** Revision 1.1  2001/04/27 12:54:40  neil
805:                 ** blah
806:                 **
807:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
808:                 ** initial
809:                 **
810:                 ** Revision 1.1  2000/10/24 12:19:01  matt
811:                 ** changed directory structure
812:                 **
813:                 ** Revision 1.9  2000/10/10 13:03:54  matt
814:                 ** Mr. Clean makes a guest appearance
815:                 **
816:                 ** Revision 1.8  2000/08/16 02:58:34  matt
817:                 ** random cleanups
818:                 **
819:                 ** Revision 1.7  2000/07/17 01:52:27  matt
820:                 ** made sure last line of all source files is a newline
821:                 **
822:                 ** Revision 1.6  2000/07/10 01:54:16  matt
823:                 ** state is now zeroed when it is allocated
824:                 **
825:                 ** Revision 1.5  2000/07/09 15:37:21  matt
826:                 ** all block read/write calls now pass through a common handler
827:                 **
828:                 ** Revision 1.4  2000/07/09 03:39:06  matt
829:                 ** minor modifications
830:                 **
831:                 ** Revision 1.3  2000/07/08 16:01:39  matt
832:                 ** added bald's changes, made error checking more robust
833:                 **
834:                 ** Revision 1.2  2000/07/04 04:46:06  matt
835:                 ** simplified handling of SNSS states
836:                 **
837:                 ** Revision 1.1  2000/06/29 14:13:28  matt
838:                 ** initial revision
839:                 **
840:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/intro.c  -----------------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** intro.c
21:                  **
22:                  ** Nofrendo intro -- 6502 code
23:                  ** $Id: intro.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <string.h>
27:                  #include <stdlib.h>
28:                  #include <noftypes.h>
29:                  #include <intro.h>
30:                  
31:                  #define  CODE_SIZE   0x4000
32:                  #define  VROM_SIZE   0x2000
33:                  
34:                  /* 6502 code for the intro */
35:                  static uint8 intro_code[301] =
36:                  {
37:                     0x78, 0xD8, 0xA2, 0x00, 0x8E, 0x00, 0x20, 0x8E, 0x01, 0x20, 0xAD, 0x02, 0x20, 0xAD, 0x02, 0x20, 
38:                     0x10, 0xFB, 0xAD, 0x02, 0x20, 0x10, 0xFB, 0x8E, 0x03, 0x20, 0xCA, 0x9A, 0xA9, 0x3F, 0x8D, 0x06, 
39:                     0x20, 0xA9, 0x00, 0x8D, 0x06, 0x20, 0xA2, 0x20, 0xA9, 0x0F, 0x8D, 0x07, 0x20, 0xCA, 0xD0, 0xFA, 
40:                     0xA9, 0x20, 0x8D, 0x06, 0x20, 0xA9, 0x00, 0x8D, 0x06, 0x20, 0xAA, 0xA0, 0x10, 0x8D, 0x07, 0x20, 
41:                     0xE8, 0xD0, 0xFA, 0x88, 0xD0, 0xF7, 0xA9, 0xF8, 0xA2, 0x00, 0x9D, 0x00, 0x02, 0xE8, 0xD0, 0xFA, 
42:                     0xA9, 0x02, 0x8D, 0x14, 0x40, 0xA9, 0x21, 0x8D, 0x06, 0x20, 0xA9, 0x89, 0x8D, 0x06, 0x20, 0xA0, 
43:                     0x10, 0xA2, 0xF0, 0x8C, 0x07, 0x20, 0xC8, 0xCA, 0xD0, 0xF9, 0xA9, 0x00, 0x8D, 0x05, 0x20, 0x8D, 
44:                     0x05, 0x20, 0xA9, 0x1E, 0x8D, 0x01, 0x20, 0xA9, 0x80, 0x8D, 0x00, 0x20, 0x20, 0x8B, 0x80, 0x20, 
45:                     0xFE, 0x80, 0x20, 0xF3, 0x80, 0x20, 0xC0, 0x80, 0x4C, 0x88, 0x80, 0xA2, 0x00, 0xA0, 0x06, 0xAD, 
46:                     0x02, 0x20, 0x10, 0xFB, 0x88, 0xD0, 0xF8, 0xA9, 0x00, 0x8D, 0x00, 0x20, 0x8D, 0x01, 0x20, 0xA9, 
47:                     0x3F, 0x8D, 0x06, 0x20, 0xA9, 0x01, 0x8D, 0x06, 0x20, 0xBD, 0x28, 0x81, 0x8D, 0x07, 0x20, 0xA9, 
48:                     0x1E, 0x8D, 0x01, 0x20, 0xA9, 0x80, 0x8D, 0x00, 0x20, 0xE8, 0x8A, 0xC9, 0x05, 0xD0, 0xCE, 0x60, 
49:                     0xA2, 0x05, 0xCA, 0xA0, 0x06, 0xAD, 0x02, 0x20, 0x10, 0xFB, 0x88, 0xD0, 0xF8, 0xA9, 0x00, 0x8D, 
50:                     0x00, 0x20, 0x8D, 0x01, 0x20, 0xA9, 0x3F, 0x8D, 0x06, 0x20, 0xA9, 0x01, 0x8D, 0x06, 0x20, 0xBD, 
51:                     0x28, 0x81, 0x8D, 0x07, 0x20, 0xA9, 0x1E, 0x8D, 0x01, 0x20, 0xA9, 0x80, 0x8D, 0x00, 0x20, 0x8A, 
52:                     0xD0, 0xD0, 0x60, 0xA2, 0x60, 0xAD, 0x02, 0x20, 0x10, 0xFB, 0xCA, 0xD0, 0xF8, 0x60, 0xA9, 0x0F, 
53:                     0x8D, 0x15, 0x40, 0xA9, 0x8D, 0x8D, 0x00, 0x40, 0xA9, 0x7F, 0x8D, 0x01, 0x40, 0xA9, 0x70, 0x8D, 
54:                     0x02, 0x40, 0xA9, 0x08, 0x8D, 0x03, 0x40, 0xA0, 0x05, 0xAD, 0x02, 0x20, 0x10, 0xFB, 0x88, 0xD0, 
55:                     0xF8, 0xA9, 0x54, 0x8D, 0x02, 0x40, 0x60, 0x40, 0x0F, 0x2D, 0x10, 0x3D, 0x20, 
56:                  } ;
57:                  
58:                  /* interrupt vectors (FFFAh - FFFFh) */
59:                  static uint8 intro_vec[6] =
60:                  {
61:                     0x27, 0x81, 0x00, 0x80, 0x27, 0x81
62:                  };
63:                  
64:                  /* graphics */
65:                  static uint8 intro_vrom[4096] = 
66:                  {
67:                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
68:                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
69:                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
70:                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
71:                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
72:                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
73:                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
74:                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
75:                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
76:                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
77:                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
78:                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
79:                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
80:                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
81:                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
82:                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
83:                     0x7F, 0x80, 0xBE, 0xBF, 0xBF, 0xBF, 0xBF, 0xBE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
84:                     0xFF, 0x00, 0x01, 0x01, 0x01, 0x81, 0xC1, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
85:                     0xFF, 0x00, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
86:                     0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
87:                     0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
88:                     0xFF, 0x00, 0x7F, 0xFF, 0xF3, 0xF1, 0xF8, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
89:                     0xFF, 0x00, 0x00, 0x80, 0xC0, 0x80, 0x00, 0x7D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
90:                     0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
91:                     0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
92:                     0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
93:                     0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
94:                     0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
95:                     0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
96:                     0xFF, 0x00, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
97:                     0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
98:                     0xFE, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
99:                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
100:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
101:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
102:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
103:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
104:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
105:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
106:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
107:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
108:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
109:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
110:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
111:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
112:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
113:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
114:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
115:                    0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
116:                    0xE1, 0x71, 0x31, 0x39, 0x1D, 0x0D, 0x0F, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
117:                    0xF0, 0xF1, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
118:                    0xF3, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
119:                    0xC7, 0xE0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
120:                    0xFF, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
121:                    0x7F, 0x7E, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
122:                    0xFC, 0x3C, 0x19, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
123:                    0x79, 0xF0, 0xF0, 0xF0, 0xFF, 0xF0, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
124:                    0xE1, 0xF1, 0xF9, 0xF9, 0xF9, 0x01, 0xF9, 0xF1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
125:                    0xFF, 0xF8, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
126:                    0xF8, 0xF8, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
127:                    0x3C, 0x78, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
128:                    0xFC, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
129:                    0x3C, 0x78, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
130:                    0xF1, 0x79, 0x7D, 0x7D, 0x7D, 0x7D, 0x7D, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
131:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
132:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
133:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
134:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
135:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
136:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
137:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
138:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
139:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
140:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
141:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
142:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
143:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
144:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
145:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
146:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
147:                    0xBE, 0xBE, 0x80, 0x80, 0xBD, 0xA1, 0xBD, 0xA1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
148:                    0x03, 0x03, 0x00, 0x00, 0xE7, 0x11, 0x11, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
149:                    0xF0, 0xF0, 0x00, 0x00, 0xDE, 0x10, 0x1E, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
150:                    0xF3, 0x3F, 0x00, 0x00, 0xF3, 0x88, 0xF0, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
151:                    0xC0, 0x00, 0x00, 0x00, 0xE7, 0x88, 0x8F, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
152:                    0xF8, 0xF8, 0x00, 0x00, 0x2F, 0xA8, 0xA8, 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
153:                    0x7C, 0x7C, 0x00, 0x00, 0x3F, 0xA4, 0xA4, 0xA4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
154:                    0x00, 0x00, 0x00, 0x00, 0x3D, 0xA1, 0xBD, 0xA1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
155:                    0x79, 0x1F, 0x00, 0x00, 0xE7, 0x11, 0x11, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
156:                    0xE1, 0x81, 0x00, 0x00, 0xC3, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
157:                    0xF0, 0xF0, 0x00, 0x00, 0xD1, 0x11, 0x8E, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
158:                    0x7C, 0x7C, 0x00, 0x00, 0x3D, 0x40, 0x38, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
159:                    0x3C, 0x1F, 0x00, 0x00, 0xF7, 0x44, 0x47, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
160:                    0xFC, 0x7C, 0x00, 0x00, 0xBF, 0x24, 0xA4, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
161:                    0x3C, 0x0F, 0x00, 0x00, 0x02, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
162:                    0xF1, 0xC1, 0x01, 0x01, 0x19, 0x25, 0x25, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
163:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
164:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
165:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
166:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
167:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
168:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
169:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
170:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
171:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
172:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
173:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
174:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
175:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
176:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
177:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
178:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
179:                    0x9D, 0x80, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
180:                    0x11, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
181:                    0x0E, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
182:                    0x88, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
183:                    0x88, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
184:                    0xA8, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
185:                    0xA4, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
186:                    0x9D, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
187:                    0x11, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
188:                    0x07, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
189:                    0x84, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
190:                    0x78, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
191:                    0x43, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
192:                    0xA4, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
193:                    0x82, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
194:                    0x99, 0x01, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
195:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
196:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
197:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
198:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
199:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
200:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
201:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
202:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
203:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
204:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
205:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
206:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
207:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
208:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
209:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
210:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
211:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
212:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
213:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
214:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
215:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
216:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
217:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
218:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
219:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
220:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
221:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
222:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
223:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
224:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
225:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
226:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
227:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
228:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
229:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
230:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
231:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
232:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
233:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
234:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
235:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
236:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
237:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
238:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
239:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
240:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
241:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
242:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
243:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
244:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
245:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
246:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
247:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
248:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
249:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
250:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
251:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
252:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
253:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
254:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
255:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
256:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
257:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
258:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
259:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
260:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
261:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
262:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
263:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
264:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
265:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
266:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
267:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
268:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
269:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
270:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
271:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
272:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
273:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
274:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
275:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
276:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
277:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
278:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
279:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
280:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
281:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
282:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
283:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
284:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
285:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
286:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
287:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
288:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
289:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
290:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
291:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
292:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
293:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
294:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
295:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
296:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
297:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
298:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
299:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
300:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
301:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
302:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
303:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
304:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
305:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
306:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
307:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
308:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
309:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
310:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
311:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
312:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
313:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
314:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
315:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
316:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
317:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
318:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
319:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
320:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
321:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
322:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
323:                 };
324:                 
325:                 static uint8 *intro_getrom(void)
326:                 {
327:                    uint8 *rom;
328:                    
329:                    rom = malloc(CODE_SIZE);   
9D03622C  0F40DDB7   JAL _my_malloc
330:                    if (NULL != rom)
9D036234  1040002C   BEQ V0, ZERO, .LBE7, .LBE6
331:                    {
332:                       /* good measure */
333:                       memset(rom, 0, CODE_SIZE);
9D03623C  00402021   ADDU A0, V0, ZERO
334:                 
335:                       /* copy in the code */
336:                       memcpy(rom, intro_code, sizeof(intro_code));
9D03624C  3C059D02   LUI A1, -25342
337:                 
338:                       /* copy in the interrupt vectors */
339:                       memcpy(rom + (CODE_SIZE - sizeof(intro_vec)), intro_vec, sizeof(intro_vec));
9D0362C4  3C029D02   LUI V0, -25342
9D0362C8  8C431074   LW V1, 4212(V0)
9D0362CC  AA033FFD   SWL V1, 16381(S0)
9D0362D0  BA033FFA   SWR V1, 16378(S0)
9D0362D4  24421074   ADDIU V0, V0, 4212
9D0362D8  90430004   LBU V1, 4(V0)
9D0362DC  A2033FFE   SB V1, 16382(S0)
9D0362E0  90420005   LBU V0, 5(V0)
9D0362E4  A2023FFF   SB V0, 16383(S0)
340:                    }
341:                 
342:                    return rom;
343:                 }
344:                 
345:                 static uint8 *intro_getvrom(void)
346:                 {
347:                    uint8 *vrom;
348:                 
349:                    vrom = malloc(VROM_SIZE);
9D0362EC  0F40DDB7   JAL _my_malloc
350:                    if (NULL != vrom)
9D0362F4  10400013   BEQ V0, ZERO, .LBE9, .LBE8
351:                    {
352:                       memcpy(vrom, intro_vrom, sizeof(intro_vrom));
9D0362FC  3C059D02   LUI A1, -25342
9D036300  24A50074   ADDIU A1, A1, 116
9D036304  24A91000   ADDIU T1, A1, 4096
9D036308  8CA80000   LW T0, 0(A1)
9D03630C  8CA70004   LW A3, 4(A1)
9D036310  8CA60008   LW A2, 8(A1)
9D036314  8CA4000C   LW A0, 12(A1)
9D036318  A8680003   SWL T0, 3(V1)
9D03631C  B8680000   SWR T0, 0(V1)
9D036320  A8670007   SWL A3, 7(V1)
9D036324  B8670004   SWR A3, 4(V1)
9D036328  A866000B   SWL A2, 11(V1)
9D03632C  B8660008   SWR A2, 8(V1)
9D036330  A864000F   SWL A0, 15(V1)
9D036334  B864000C   SWR A0, 12(V1)
9D036338  24A50010   ADDIU A1, A1, 16
9D03633C  14A9FFF2   BNE A1, T1, 0x9D036308
9D036340  24630010   ADDIU V1, V1, 16
353:                    }
354:                 
355:                    return vrom;
356:                 }
357:                 
358:                 void intro_get_header(rominfo_t *rominfo)
359:                 {
9D0361C8  27BDFFE8   ADDIU SP, SP, -24
9D0361CC  AFBF0014   SW RA, 20(SP)
360:                    ASSERT(rominfo);
361:                 
362:                    rominfo->rom_banks = CODE_SIZE / 0x4000;
9D0361D0  24020001   ADDIU V0, ZERO, 1
9D0361D4  AC820010   SW V0, 16(A0)
363:                    rominfo->vrom_banks = VROM_SIZE / 0x2000;
9D0361D8  AC820014   SW V0, 20(A0)
364:                    rominfo->mirror = MIRROR_VERT;
9D0361DC  AC820024   SW V0, 36(A0)
365:                    rominfo->flags = 0;
9D0361E0  A0800028   SB ZERO, 40(A0)
366:                    rominfo->mapper_number = 0;
9D0361E4  AC800020   SW ZERO, 32(A0)
367:                    
368:                    rominfo->sram_banks = 0;
9D0361E8  AC800018   SW ZERO, 24(A0)
369:                    rominfo->vram_banks = 0;
9D0361EC  AC80001C   SW ZERO, 28(A0)
370:                    rominfo->sram = NULL;
9D0361F0  AC800008   SW ZERO, 8(A0)
371:                    rominfo->vram = NULL;
9D0361F4  AC80000C   SW ZERO, 12(A0)
372:                 
373:                    strncpy(rominfo->filename, "Nofrendo intro", PATH_MAX);
9D0361F8  24840029   ADDIU A0, A0, 41
9D0361FC  3C059D02   LUI A1, -25342
9D036200  24A50064   ADDIU A1, A1, 100
9D036204  0F40E397   JAL .LFE23, strncpy
9D036208  24060200   ADDIU A2, ZERO, 512
374:                 }
9D03620C  8FBF0014   LW RA, 20(SP)
9D036210  03E00008   JR RA
9D036214  27BD0018   ADDIU SP, SP, 24
375:                 
376:                 int intro_get_rom(rominfo_t *rominfo)
377:                 {
9D036218  27BDFFE0   ADDIU SP, SP, -32
9D03621C  AFBF001C   SW RA, 28(SP)
9D036220  AFB10018   SW S1, 24(SP)
9D036224  AFB00014   SW S0, 20(SP)
9D036228  00808821   ADDU S1, A0, ZERO
378:                    ASSERT(rominfo);
379:                 
380:                    rominfo->rom = intro_getrom();
9D0362E8  AE300000   SW S0, 0(S1)
381:                    rominfo->vrom = intro_getvrom();
9D036344  AE220004   SW V0, 4(S1)
382:                    if (NULL == rominfo->rom || NULL == rominfo->vrom)
9D036348  8E230000   LW V1, 0(S1)
9D03634C  10600003   BEQ V1, ZERO, 0x9D03635C
9D036350  2C420001   SLTIU V0, V0, 1
9D036354  0B40D8D8   J 0x9D036360
9D036358  00021023   SUBU V0, ZERO, V0
383:                       return -1; 
9D03635C  2402FFFF   ADDIU V0, ZERO, -1
384:                 
385:                    return 0;
386:                 }
9D036360  8FBF001C   LW RA, 28(SP)
9D036364  8FB10018   LW S1, 24(SP)
9D036368  8FB00014   LW S0, 20(SP)
9D03636C  03E00008   JR RA
9D036370  27BD0020   ADDIU SP, SP, 32
387:                 
388:                 /*
389:                 ** $Log: intro.c,v $
390:                 ** Revision 1.2  2001/04/27 14:37:11  neil
391:                 ** wheeee
392:                 **
393:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
394:                 ** initial
395:                 **
396:                 ** Revision 1.5  2000/10/17 03:22:37  matt
397:                 ** cleaning up rom module
398:                 **
399:                 ** Revision 1.4  2000/10/10 13:58:13  matt
400:                 ** stroustrup squeezing his way in the door
401:                 **
402:                 ** Revision 1.3  2000/10/10 13:03:54  matt
403:                 ** Mr. Clean makes a guest appearance
404:                 **
405:                 ** Revision 1.2  2000/07/31 04:28:46  matt
406:                 ** one million cleanups
407:                 **
408:                 ** Revision 1.1  2000/07/30 04:29:11  matt
409:                 ** initial revision
410:                 **
411:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/gui.c  -------------------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** gui.c
21:                  **
22:                  ** GUI routines
23:                  ** $Id: gui.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <stdio.h>
27:                  #include <string.h>
28:                  #include <stdarg.h>
29:                  #include <noftypes.h>
30:                  #include <nes_ppu.h>
31:                  #include <nes_apu.h>
32:                  #include <nesinput.h>
33:                  #include <nes.h>
34:                  #include <log.h>
35:                  #include <osd.h>
36:                  
37:                  #include <bitmap.h>
38:                  
39:                  #include <gui.h>
40:                  #include <gui_elem.h>
41:                  #include <vid_drv.h>
42:                  
43:                  /* TODO: oh god */
44:                  /* 8-bit GUI color table */
45:                  rgb_t gui_pal[GUI_TOTALCOLORS] =
46:                  {
47:                     { 0x00, 0x00, 0x00 }, /* black      */
48:                     { 0x3F, 0x3F, 0x3F }, /* dark gray  */
49:                     { 0x7F, 0x7F, 0x7F }, /* gray       */
50:                     { 0xBF, 0xBF, 0xBF }, /* light gray */
51:                     { 0xFF, 0xFF, 0xFF }, /* white      */
52:                     { 0xFF, 0x00, 0x00 }, /* red        */
53:                     { 0x00, 0xFF, 0x00 }, /* green      */
54:                     { 0x00, 0x00, 0xFF }, /* blue       */
55:                     { 0xFF, 0xFF, 0x00 }, /* yellow     */
56:                     { 0xFF, 0xAF, 0x00 }, /* orange     */
57:                     { 0xFF, 0x00, 0xFF }, /* purple     */
58:                     { 0x3F, 0x7F, 0x7F }, /* teal       */
59:                     { 0x00, 0x2A, 0x00 }, /* dk. green  */
60:                     { 0x00, 0x00, 0x3F }  /* dark blue  */
61:                  };
62:                  
63:                  /**************************************************************/
64:                  #include <pcx.h>
65:                  #include <nesstate.h>
66:                  static bool option_drawsprites = true;
67:                  
68:                  /* save a PCX snapshot */
69:                  void gui_savesnap(void)
70:                  {
9D0249A0  27BDFDE8   ADDIU SP, SP, -536
9D0249A4  AFBF0214   SW RA, 532(SP)
71:                     char filename[PATH_MAX];
72:                     nes_t *nes = nes_getcontextptr();
9D0249A8  0F408D03   JAL nes_getcontextptr
9D0249AC  AFB00210   SW S0, 528(SP)
73:                  
74:                     //if (osd_makesnapname(filename, PATH_MAX) < 0)
75:                     //   return;
76:                  
77:                     if (pcx_write(filename, vid_getbuffer(), nes->ppu->curpal)) 
9D0249B0  0F40BAD1   JAL vid_getbuffer
9D0249B4  00408021   ADDU S0, V0, ZERO
9D0249B8  8E060304   LW A2, 772(S0)
9D0249BC  27A40010   ADDIU A0, SP, 16
9D0249C0  00402821   ADDU A1, V0, ZERO
9D0249C4  0F40D612   JAL pcx_write
9D0249C8  24C611AC   ADDIU A2, A2, 4524
9D0249CC  14400007   BNE V0, ZERO, 0x9D0249EC
9D0249D0  8FBF0214   LW RA, 532(SP)
78:                        return;
79:                  
80:                     gui_sendmsg(GUI_GREEN, "Screen saved to %s", filename);
9D0249D4  240400C6   ADDIU A0, ZERO, 198
9D0249D8  3C059D04   LUI A1, -25340
9D0249DC  24A59588   ADDIU A1, A1, -27256
9D0249E0  0F409253   JAL gui_sendmsg
9D0249E4  27A60010   ADDIU A2, SP, 16
81:                  }
9D0249E8  8FBF0214   LW RA, 532(SP)
9D0249EC  8FB00210   LW S0, 528(SP)
9D0249F0  03E00008   JR RA
9D0249F4  27BD0218   ADDIU SP, SP, 536
82:                  
83:                  /* Show/hide sprites (hiding sprites useful for making maps) */
84:                  void gui_togglesprites(void)
85:                  {
9D0249F8  27BDFFE8   ADDIU SP, SP, -24
9D0249FC  AFBF0014   SW RA, 20(SP)
86:                     option_drawsprites ^= true;
9D024A00  8F848024   LW A0, -32732(GP)
9D024A04  38840001   XORI A0, A0, 1
87:                     ppu_displaysprites(option_drawsprites);
9D024A08  0F40628A   JAL ppu_displaysprites
9D024A0C  AF848024   SW A0, -32732(GP)
88:                     gui_sendmsg(GUI_GREEN, "Sprites %s", option_drawsprites ? "displayed" : "hidden");
9D024A10  8F828024   LW V0, -32732(GP)
9D024A14  50400004   BEQL V0, ZERO, 0x9D024A28
9D024A18  3C069D04   LUI A2, -25340
9D024A1C  3C069D04   LUI A2, -25340
9D024A20  0B40928B   J 0x9D024A2C
9D024A24  24C6959C   ADDIU A2, A2, -27236
9D024A28  24C695A8   ADDIU A2, A2, -27224
9D024A2C  240400C6   ADDIU A0, ZERO, 198
9D024A30  3C059D04   LUI A1, -25340
9D024A34  0F409253   JAL gui_sendmsg
9D024A38  24A595B0   ADDIU A1, A1, -27216
89:                  }
9D024A3C  8FBF0014   LW RA, 20(SP)
9D024A40  03E00008   JR RA
9D024A44  27BD0018   ADDIU SP, SP, 24
90:                  
91:                  /* Set the frameskip policy */
92:                  void gui_togglefs(void)
93:                  {
9D024A48  27BDFFE8   ADDIU SP, SP, -24
9D024A4C  AFBF0014   SW RA, 20(SP)
94:                     nes_t *machine = nes_getcontextptr();
9D024A50  0F408D03   JAL nes_getcontextptr
9D024A54  00000000   NOP
95:                  
96:                     machine->autoframeskip ^= true;
9D024A58  8C430328   LW V1, 808(V0)
9D024A5C  38630001   XORI V1, V1, 1
97:                     if (machine->autoframeskip)
9D024A60  10600007   BEQ V1, ZERO, .LVL173
9D024A64  AC430328   SW V1, 808(V0)
98:                        gui_sendmsg(GUI_YELLOW, "automatic frameskip");
9D024A68  240400C8   ADDIU A0, ZERO, 200
9D024A6C  3C059D04   LUI A1, -25340
9D024A70  0F409253   JAL gui_sendmsg
9D024A74  24A595BC   ADDIU A1, A1, -27204
9D024A78  0B4092A5   J 0x9D024A94
9D024A7C  8FBF0014   LW RA, 20(SP)
99:                     else
100:                       gui_sendmsg(GUI_YELLOW, "unthrottled emulation");
9D024A80  240400C8   ADDIU A0, ZERO, 200
9D024A84  3C059D04   LUI A1, -25340
9D024A88  0F409253   JAL gui_sendmsg
9D024A8C  24A595D0   ADDIU A1, A1, -27184
101:                 }
9D024A90  8FBF0014   LW RA, 20(SP)
9D024A94  03E00008   JR RA
9D024A98  27BD0018   ADDIU SP, SP, 24
102:                 
103:                 /* display rom information */
104:                 void gui_displayinfo()
105:                 {
9D024A9C  27BDFFE8   ADDIU SP, SP, -24
9D024AA0  AFBF0014   SW RA, 20(SP)
106:                    gui_sendmsg(GUI_ORANGE, (char *) rom_getinfo(nes_getcontextptr()->rominfo));
9D024AA4  0F408D03   JAL nes_getcontextptr
9D024AA8  00000000   NOP
9D024AAC  0F40ACDE   JAL rom_getinfo
9D024AB0  8C440310   LW A0, 784(V0)
9D024AB4  240400C9   ADDIU A0, ZERO, 201
9D024AB8  0F409253   JAL gui_sendmsg
9D024ABC  00402821   ADDU A1, V0, ZERO
107:                 }
9D024AC0  8FBF0014   LW RA, 20(SP)
9D024AC4  03E00008   JR RA
9D024AC8  27BD0018   ADDIU SP, SP, 24
108:                 
109:                 void gui_toggle_chan(int chan)
110:                 {
9D024ACC  27BDFFD8   ADDIU SP, SP, -40
9D024AD0  AFBF0024   SW RA, 36(SP)
9D024AD4  AFB00020   SW S0, 32(SP)
111:                 #define  FILL_CHAR   0x7C           /* ASCII 124 '|' */
112:                 #define  BLANK_CHAR  0x7F           /* ASCII 127   [delta] */
113:                    static bool chan_enabled[6] = { true, true, true, true, true, true };
114:                 
115:                    chan_enabled[chan] ^= true;
9D024AD8  3C10A001   LUI S0, -24575
9D024ADC  00041880   SLL V1, A0, 2
9D024AE0  2602A8E8   ADDIU V0, S0, -22296
9D024AE4  00621021   ADDU V0, V1, V0
9D024AE8  8C450000   LW A1, 0(V0)
9D024AEC  38A50001   XORI A1, A1, 1
116:                    apu_setchan(chan, chan_enabled[chan]);
9D024AF0  0F4078A7   JAL apu_setchan
9D024AF4  AC450000   SW A1, 0(V0)
117:                 
118:                    gui_sendmsg(GUI_ORANGE, "%ca %cb %cc %cd %ce %cext",
9D024AF8  8E06A8E8   LW A2, -22296(S0)
9D024B00  8C47A8EC   LW A3, -22292(V0)
9D024B08  8C45A8F0   LW A1, -22288(V0)
9D024B0C  2402007C   ADDIU V0, ZERO, 124
9D024B10  2403007F   ADDIU V1, ZERO, 127
9D024B14  0065100A   MOVZ V0, V1, A1
9D024B18  00402821   ADDU A1, V0, ZERO
9D024B20  8C44A8F4   LW A0, -22284(V0)
9D024B24  2402007C   ADDIU V0, ZERO, 124
9D024B28  0064100A   MOVZ V0, V1, A0
9D024B2C  00402021   ADDU A0, V0, ZERO
9D024B34  8C48A8F8   LW T0, -22280(V0)
9D024B38  2402007C   ADDIU V0, ZERO, 124
9D024B3C  0048180B   MOVN V1, V0, T0
9D024B44  8C49A8FC   LW T1, -22276(V0)
9D024B48  2408007C   ADDIU T0, ZERO, 124
9D024B4C  2402007F   ADDIU V0, ZERO, 127
9D024B50  0109100B   MOVN V0, T0, T1
9D024B54  AFA50010   SW A1, 16(SP)
9D024B58  AFA40014   SW A0, 20(SP)
9D024B5C  AFA30018   SW V1, 24(SP)
9D024B60  AFA2001C   SW V0, 28(SP)
9D024B64  240400C9   ADDIU A0, ZERO, 201
9D024B68  3C059D04   LUI A1, -25340
9D024B6C  24A595E8   ADDIU A1, A1, -27160
9D024B70  2402007C   ADDIU V0, ZERO, 124
9D024B74  2403007F   ADDIU V1, ZERO, 127
9D024B78  0066100A   MOVZ V0, V1, A2
9D024B7C  00403021   ADDU A2, V0, ZERO
9D024B80  2402007C   ADDIU V0, ZERO, 124
9D024B84  0067100A   MOVZ V0, V1, A3
9D024B88  0F409253   JAL gui_sendmsg
9D024B8C  00403821   ADDU A3, V0, ZERO
119:                                chan_enabled[0] ? FILL_CHAR : BLANK_CHAR,
120:                                chan_enabled[1] ? FILL_CHAR : BLANK_CHAR,
9D024AFC  3C02A001   LUI V0, -24575
121:                                chan_enabled[2] ? FILL_CHAR : BLANK_CHAR,
9D024B04  3C02A001   LUI V0, -24575
122:                                chan_enabled[3] ? FILL_CHAR : BLANK_CHAR,
9D024B1C  3C02A001   LUI V0, -24575
123:                                chan_enabled[4] ? FILL_CHAR : BLANK_CHAR,
9D024B30  3C02A001   LUI V0, -24575
124:                                chan_enabled[5] ? FILL_CHAR : BLANK_CHAR);
9D024B40  3C02A001   LUI V0, -24575
125:                 }
9D024B90  8FBF0024   LW RA, 36(SP)
9D024B94  8FB00020   LW S0, 32(SP)
9D024B98  03E00008   JR RA
9D024B9C  27BD0028   ADDIU SP, SP, 40
126:                                         
127:                 void gui_setfilter(int filter_type)
128:                 {
9D024BA0  27BDFFD8   ADDIU SP, SP, -40
9D024BA4  AFBF0024   SW RA, 36(SP)
9D024BA8  AFB00020   SW S0, 32(SP)
129:                    char *types[3] = { "no", "lowpass", "weighted" };
9D024BAC  3C029D04   LUI V0, -25340
9D024BB0  24429604   ADDIU V0, V0, -27132
9D024BB4  AFA20010   SW V0, 16(SP)
9D024BB8  3C029D04   LUI V0, -25340
9D024BBC  24429608   ADDIU V0, V0, -27128
9D024BC0  AFA20014   SW V0, 20(SP)
9D024BC4  3C029D04   LUI V0, -25340
9D024BC8  24429610   ADDIU V0, V0, -27120
9D024BCC  AFA20018   SW V0, 24(SP)
130:                    static int last_filter = 2;
131:                 
132:                    if (last_filter == filter_type || filter_type < 0 || filter_type > 2)
9D024BD0  8F82801C   LW V0, -32740(GP)
9D024BD4  1044000E   BEQ V0, A0, 0x9D024C10
9D024BD8  00808021   ADDU S0, A0, ZERO
9D024BDC  2C820003   SLTIU V0, A0, 3
9D024BE0  1040000C   BEQ V0, ZERO, 0x9D024C14
9D024BE4  8FBF0024   LW RA, 36(SP)
133:                       return;
134:                 
135:                    apu_setfilter(filter_type);
9D024BE8  0F407A58   JAL .LFB18, .LFE16, apu_setfilter
9D024BEC  00000000   NOP
136:                    gui_sendmsg(GUI_ORANGE, "%s filter", types[filter_type]);
9D024BF0  00101080   SLL V0, S0, 2
9D024BF4  03A21021   ADDU V0, SP, V0
9D024BF8  240400C9   ADDIU A0, ZERO, 201
9D024BFC  3C059D04   LUI A1, -25340
9D024C00  24A5961C   ADDIU A1, A1, -27108
9D024C04  0F409253   JAL gui_sendmsg
9D024C08  8C460010   LW A2, 16(V0)
137:                    last_filter = filter_type;
9D024C0C  AF90801C   SW S0, -32740(GP)
138:                 }
9D024C10  8FBF0024   LW RA, 36(SP)
9D024C14  8FB00020   LW S0, 32(SP)
9D024C18  03E00008   JR RA
9D024C1C  27BD0028   ADDIU SP, SP, 40
139:                 /**************************************************************/
140:                 
141:                 
142:                 enum
143:                 {
144:                    GUI_WAVENONE,
145:                    GUI_WAVELINE,
146:                    GUI_WAVESOLID,
147:                    GUI_NUMWAVESTYLES
148:                 };
149:                 
150:                 enum
151:                 {
152:                    BUTTON_UP,
153:                    BUTTON_DOWN
154:                 };
155:                 
156:                 
157:                 /* TODO: roll options into a structure */
158:                 static message_t msg;
159:                 static bool option_showfps = false;
160:                 static bool option_showgui = false;
161:                 static int option_wavetype = GUI_WAVENONE;
162:                 static bool option_showpattern = false;
163:                 static bool option_showoam = false;
164:                 static int pattern_col = 0;
165:                 
166:                 /* timimg variables */
167:                 static bool gui_fpsupdate = false;
168:                 static int gui_ticks = 0;
169:                 static int gui_fps = 0;
170:                 static int gui_refresh = 60; /* default to 60Hz */
171:                 
172:                 static int mouse_x, mouse_y, mouse_button;
173:                 
174:                 static bitmap_t *gui_surface;
175:                 
176:                 
177:                 /* Put a pixel on our bitmap- just for GUI use */
178:                 INLINE void gui_putpixel(int x_pos, int y_pos, uint8 color)
179:                 {
180:                    gui_surface->line[y_pos][x_pos] = color;
9D023F28  24A50004   ADDIU A1, A1, 4
9D023F74  8C650000   LW A1, 0(V1)
9D024030  8CE50000   LW A1, 0(A3)
9D024404  241EFFC6   ADDIU FP, ZERO, -58
9D024478  8F828138   LW V0, -32456(GP)
9D02447C  8C420098   LW V0, 152(V0)
9D024480  00501021   ADDU V0, V0, S0
9D024484  0B40912F   J .LVL117
9D024488  A05E0000   SB FP, 0(V0)
9D024908  8D070014   LW A3, 20(T0)
9D024914  90840000   LBU A0, 0(A0)
181:                 }
182:                 
183:                 /* Line drawing */
184:                 static void gui_hline(int x_pos, int y_pos, int length, uint8 color)
185:                 {
186:                    while (length--)
9D023F1C  10C0000B   BEQ A2, ZERO, .LVL7
9D023F20  00801021   ADDU V0, A0, ZERO
9D023F24  00C42021   ADDU A0, A2, A0
9D023F44  1444FFFC   BNE V0, A0, .LVL4
9D023F48  A0670000   SB A3, 0(V1)
9D023F4C  03E00008   JR RA
9D023F50  00000000   NOP
187:                       gui_putpixel(x_pos++, y_pos, color);
188:                 }
189:                 
190:                 static void gui_vline(int x_pos, int y_pos, int height, uint8 color)
191:                 {
192:                    while (height--)
9D023F54  10C0000D   BEQ A2, ZERO, .LVL13
9D023F58  24C2FFFF   ADDIU V0, A2, -1
9D023F5C  24A50004   ADDIU A1, A1, 4
9D023F60  00052880   SLL A1, A1, 2
9D023F64  8F838138   LW V1, -32456(GP)
9D023F68  00651821   ADDU V1, V1, A1
9D023F6C  24630004   ADDIU V1, V1, 4
9D023F70  2406FFFF   ADDIU A2, ZERO, -1
9D023F80  2442FFFF   ADDIU V0, V0, -1
9D023F84  1446FFFB   BNE V0, A2, .LVL11, .LBB18
9D023F88  24630004   ADDIU V1, V1, 4
9D023F8C  03E00008   JR RA
9D023F90  00000000   NOP
193:                       gui_putpixel(x_pos, y_pos++, color);
194:                 }
195:                 
196:                 /* Rectangles */
197:                 static void gui_rect(int x_pos, int y_pos, int width, int height, uint8 color)
198:                 {
199:                    gui_hline(x_pos, y_pos, width, color);
9D0244C8  24040080   ADDIU A0, ZERO, 128
200:                    gui_hline(x_pos, y_pos + height - 1, width, color);
9D0244DC  24040080   ADDIU A0, ZERO, 128
201:                    gui_vline(x_pos, y_pos + 1, height - 2, color);
9D0244F0  24040080   ADDIU A0, ZERO, 128
202:                    gui_vline(x_pos + width - 1, y_pos + 1, height - 2, color);
9D024504  240400FF   ADDIU A0, ZERO, 255
9D024508  24050001   ADDIU A1, ZERO, 1
9D02450C  24060040   ADDIU A2, ZERO, 64
9D024510  0F408FD5   JAL .LFB13, gui_vline, .LVL8, .LFE12
9D024514  240700C1   ADDIU A3, ZERO, 193
203:                 }
204:                 
205:                 static void gui_rectfill(int x_pos, int y_pos, int width, int height, uint8 color)
206:                 {
207:                    while (height--)
9D0241B8  2413FFFF   ADDIU S3, ZERO, -1
9D0241D4  2631FFFF   ADDIU S1, S1, -1
208:                       gui_hline(x_pos, y_pos++, width, color);
9D0241BC  26120001   ADDIU S2, S0, 1
9D0241C0  02A02021   ADDU A0, S5, ZERO
9D0241C4  02002821   ADDU A1, S0, ZERO
9D0241C8  02803021   ADDU A2, S4, ZERO
9D0241CC  0F408FC7   JAL .LFB12, gui_hline, .LVL0, .Ltext0, .Letext0, .LFE31
9D0241D0  02C03821   ADDU A3, S6, ZERO
9D0241D4  2631FFFF   ADDIU S1, S1, -1
9D0241D8  1633FFF8   BNE S1, S3, .LVL54
9D0241DC  02408021   ADDU S0, S2, ZERO
209:                 }
210:                 
211:                 /* Draw the outline of a button */
212:                 static void gui_buttonrect(int x_pos, int y_pos, int width, int height, bool down)
213:                 {
214:                    uint8 color1, color2;
215:                 
216:                    if (down)
217:                    {
218:                       color1 = GUI_GRAY;
219:                       color2 = GUI_WHITE;
9D024130  240200C4   ADDIU V0, ZERO, 196
220:                    }
221:                    else
222:                    {
223:                       color1 = GUI_WHITE;
224:                       color2 = GUI_GRAY;
225:                    }
226:                 
227:                    gui_hline(x_pos, y_pos, width - 1, color1);
9D024148  02E02021   ADDU A0, S7, ZERO
228:                    gui_vline(x_pos, y_pos + 1, height - 2, color1);
9D02415C  27D00001   ADDIU S0, FP, 1
229:                    gui_hline(x_pos, y_pos + height - 1, width, color2);
9D024174  8FA20018   LW V0, 24(SP)
230:                    gui_vline(x_pos + width - 1, y_pos, height - 1, color2);
9D024190  02B72021   ADDU A0, S5, S7
9D024194  2484FFFF   ADDIU A0, A0, -1
9D024198  03C02821   ADDU A1, FP, ZERO
9D02419C  26660002   ADDIU A2, S3, 2
9D0241A0  0F408FD5   JAL .LFB13, gui_vline, .LVL8, .LFE12
9D0241A4  02203821   ADDU A3, S1, ZERO
231:                 }
232:                 
233:                 /* Text blitting */
234:                 INLINE void gui_charline(char ch, int x_pos, int y_pos, uint8 color)
235:                 {
236:                    int count = 8;
237:                    while (count--)
9D023FE4  2404FFFF   ADDIU A0, ZERO, -1
9D02401C  24030007   ADDIU V1, ZERO, 7
9D02403C  1464FFF8   BNE V1, A0, .LVL24
9D024040  24C60001   ADDIU A2, A2, 1
9D024044  24E70004   ADDIU A3, A3, 4
238:                    {
239:                       if (ch & (1 << count))
9D024020  00694007   SRAV T0, T1, V1
9D024024  31080001   ANDI T0, T0, 1
9D024028  11000004   BEQ T0, ZERO, .LVL26, .LBE30
9D02402C  2463FFFF   ADDIU V1, V1, -1
240:                          gui_putpixel(x_pos, y_pos, color);
241:                       x_pos++;
242:                    }
243:                 }
244:                 
245:                 static void gui_putchar(const uint8 *dat, int height, int x_pos, int y_pos, uint8 color)
246:                 {
247:                    while (height--)
9D024048  554BFFF2   BNEL T2, T3, .LVL22, .LBB35
9D02404C  254A0001   ADDIU T2, T2, 1
248:                       gui_charline(*dat++, x_pos, y_pos++, color);
9D024014  8149FFFF   LB T1, -1(T2)
9D024018  00403021   ADDU A2, V0, ZERO
249:                 }
250:                 
251:                 /* Return length of text in pixels */
252:                 static int gui_textlen(char *str, font_t *font)
253:                 {
254:                    int pixels = 0;
9D0240EC  0000A021   ADDU S4, ZERO, ZERO
9D024118  0000A021   ADDU S4, ZERO, ZERO
255:                    int num_chars = strlen(str);
9D0240D4  0F40DBFE   JAL strlen
9D0240D8  8FB00060   LW S0, 96(SP)
256:                 
257:                    while (num_chars--)
9D0240DC  1040000E   BEQ V0, ZERO, .LVL43, .LBB45
9D0240E0  8F868028   LW A2, -32728(GP)
9D0240E4  8FA30048   LW V1, 72(SP)
9D0240E8  00621021   ADDU V0, V1, V0
9D024108  1462FFF9   BNE V1, V0, .LVL40
9D02410C  0284A021   ADDU S4, S4, A0
258:                       pixels += font->character[(*str++ - 32)].spacing;
9D0240F0  24630001   ADDIU V1, V1, 1
9D0240F4  8064FFFF   LB A0, -1(V1)
9D0240F8  000428C0   SLL A1, A0, 3
9D0240FC  00A42023   SUBU A0, A1, A0
9D024100  00C42021   ADDU A0, A2, A0
9D024104  9084FF26   LBU A0, -218(A0)
259:                 
260:                    return pixels;
261:                 }
262:                 
263:                 /* Simple textout() type function */
264:                 static int gui_textout(char *str, int x_pos, int y_pos, font_t *font, uint8 color)
265:                 {
9D023F94  27BDFFD8   ADDIU SP, SP, -40
9D023F98  AFBF0024   SW RA, 36(SP)
9D023F9C  AFB40020   SW S4, 32(SP)
9D023FA0  AFB3001C   SW S3, 28(SP)
9D023FA4  AFB20018   SW S2, 24(SP)
9D023FA8  AFB10014   SW S1, 20(SP)
9D023FAC  AFB00010   SW S0, 16(SP)
9D023FB0  00808821   ADDU S1, A0, ZERO
9D023FB4  00A09821   ADDU S3, A1, ZERO
9D023FB8  00C0A021   ADDU S4, A2, ZERO
9D023FBC  00E09021   ADDU S2, A3, ZERO
266:                    int x_new;
267:                    int num_chars = strlen(str);
9D023FC0  0F40DBFE   JAL strlen
9D023FC4  93B00038   LBU S0, 56(SP)
268:                    int code;
269:                 
270:                    x_new = x_pos;
9D023FD0  02601021   ADDU V0, S3, ZERO
9D023FD4  26830004   ADDIU V1, S4, 4
9D023FD8  00031880   SLL V1, V1, 2
9D023FDC  8F8D8138   LW T5, -32456(GP)
9D023FE0  01A36821   ADDU T5, T5, V1
9D02406C  02601021   ADDU V0, S3, ZERO
271:                 
272:                    while (num_chars--)
9D023FC8  10400028   BEQ V0, ZERO, .LVL29
9D023FCC  02227021   ADDU T6, S1, V0
9D02405C  162EFFE2   BNE S1, T6, .LVL16, .LBE28, .LBE26
9D024060  00431021   ADDU V0, V0, V1
9D024064  0B40901D   J .LVL31
9D024068  00531023   SUBU V0, V0, S3
273:                    {
274:                       /* Turn ASCII code into letter */
275:                       code = *str++;
9D023FE8  26310001   ADDIU S1, S1, 1
9D023FEC  8223FFFF   LB V1, -1(S1)
276:                       if (code > 0x7F)
277:                          code = 0x7F;
278:                       code -= 32; /* normalize */
9D023FF0  2463FFE0   ADDIU V1, V1, -32
279:                       gui_putchar(font->character[code].lines, font->height, x_new, y_pos, color);
9D023FF4  000360C0   SLL T4, V1, 3
9D023FF8  01836023   SUBU T4, T4, V1
9D023FFC  8E4A0000   LW T2, 0(S2)
9D024000  014C5021   ADDU T2, T2, T4
9D024004  25A70004   ADDIU A3, T5, 4
9D024008  924B0004   LBU T3, 4(S2)
9D02400C  0B409012   J .LVL27, .LBE33
9D024010  014B5821   ADDU T3, T2, T3
280:                       x_new += font->character[code].spacing;
9D024050  8E430000   LW V1, 0(S2)
9D024054  006C6021   ADDU T4, V1, T4
9D024058  91830006   LBU V1, 6(T4)
281:                    }
282:                 
283:                    /* Return the length in pixels */
284:                    return (x_new - x_pos);
285:                 }
9D024070  00531023   SUBU V0, V0, S3
9D024074  8FBF0024   LW RA, 36(SP)
9D024078  8FB40020   LW S4, 32(SP)
9D02407C  8FB3001C   LW S3, 28(SP)
9D024080  8FB20018   LW S2, 24(SP)
9D024084  8FB10014   LW S1, 20(SP)
9D024088  8FB00010   LW S0, 16(SP)
9D02408C  03E00008   JR RA
9D024090  27BD0028   ADDIU SP, SP, 40
286:                 
287:                 /* Draw bar-/button-type text */
288:                 static int gui_textbar(char *str, int x_pos, int y_pos, font_t *font,
289:                                        uint8 color, uint8 bgcolor, bool buttonstate)
290:                 {
9D024094  27BDFFB8   ADDIU SP, SP, -72
9D024098  AFBF0044   SW RA, 68(SP)
9D02409C  AFBE0040   SW FP, 64(SP)
9D0240A0  AFB7003C   SW S7, 60(SP)
9D0240A4  AFB60038   SW S6, 56(SP)
9D0240A8  AFB50034   SW S5, 52(SP)
9D0240AC  AFB40030   SW S4, 48(SP)
9D0240B0  AFB3002C   SW S3, 44(SP)
9D0240B4  AFB20028   SW S2, 40(SP)
9D0240B8  AFB10024   SW S1, 36(SP)
9D0240BC  AFB00020   SW S0, 32(SP)
9D0240C0  AFA40048   SW A0, 72(SP)
9D0240C4  00A0B821   ADDU S7, A1, ZERO
9D0240C8  00C0F021   ADDU FP, A2, ZERO
9D0240CC  AFA70054   SW A3, 84(SP)
9D0240D0  93B6005C   LBU S6, 92(SP)
291:                    int width = gui_textlen(str, &small);
292:                 
293:                    /* Fill the 'button' */
294:                    gui_buttonrect(x_pos, y_pos, width + 3, font->height + 3, buttonstate);
9D024110  0B409048   J 0x9D024120
9D024114  26950003   ADDIU S5, S4, 3
9D02411C  26950003   ADDIU S5, S4, 3
9D024120  8FA20054   LW V0, 84(SP)
9D024124  90530004   LBU S3, 4(V0)
9D024128  26630003   ADDIU V1, S3, 3
9D02412C  AFA30018   SW V1, 24(SP)
295:                    gui_rectfill(x_pos + 1, y_pos + 1, width + 1, font->height + 1, bgcolor);
9D0241A8  26F50001   ADDIU S5, S7, 1
9D0241AC  26940001   ADDIU S4, S4, 1
9D0241B0  8FA30054   LW V1, 84(SP)
9D0241B4  90710004   LBU S1, 4(V1)
296:                 
297:                    /* Print the text */
298:                    return gui_textout(str, x_pos + 2, y_pos + 2, font, color);
9D0241E0  93A20058   LBU V0, 88(SP)
9D0241E4  AFA20010   SW V0, 16(SP)
9D0241E8  8FA40048   LW A0, 72(SP)
9D0241EC  26E50002   ADDIU A1, S7, 2
9D0241F0  27C60002   ADDIU A2, FP, 2
9D0241F4  0F408FE5   JAL .LFB20, gui_textout, .LVL14, .LFE13
9D0241F8  8FA70054   LW A3, 84(SP)
299:                 }
9D0241FC  8FBF0044   LW RA, 68(SP)
9D024200  8FBE0040   LW FP, 64(SP)
9D024204  8FB7003C   LW S7, 60(SP)
9D024208  8FB60038   LW S6, 56(SP)
9D02420C  8FB50034   LW S5, 52(SP)
9D024210  8FB40030   LW S4, 48(SP)
9D024214  8FB3002C   LW S3, 44(SP)
9D024218  8FB20028   LW S2, 40(SP)
9D02421C  8FB10024   LW S1, 36(SP)
9D024220  8FB00020   LW S0, 32(SP)
9D024224  03E00008   JR RA
9D024228  27BD0048   ADDIU SP, SP, 72
300:                 
301:                 /* Draw the mouse pointer */
302:                 static void gui_drawmouse(void)
303:                 {
304:                    int ythresh, xthresh;
305:                    int i, j, color;
306:                 
307:                    ythresh = gui_surface->height - mouse_y - 1;
9D0248B8  8F8C8138   LW T4, -32456(GP)
308:                    for (j = 0; j < CURSOR_HEIGHT; j++)
9D024930  14ABFFEB   BNE A1, T3, .LVL150
309:                    {
310:                       if (ythresh < 0)
9D0248E0  05420013   BLTZL T2, 0x9D024930
311:                          continue;
312:                 
313:                       xthresh = gui_surface->width - mouse_x - 1;
9D0248E8  8D830000   LW V1, 0(T4)
314:                       for (i = 0; i < CURSOR_WIDTH; i++)
9D0248DC  2406000B   ADDIU A2, ZERO, 11
9D0248F0  00001021   ADDU V0, ZERO, ZERO
9D02491C  24420001   ADDIU V0, V0, 1
315:                       {
316:                          if (xthresh < 0)
9D0248F4  04600009   BLTZ V1, .LVL156, .LBE91
317:                             continue;
318:                 
319:                          color = cursor[(j * CURSOR_WIDTH) + i];
9D0248FC  90840000   LBU A0, 0(A0)
320:                 
321:                          if (color)
9D024900  10800006   BEQ A0, ZERO, .LVL156, .LBE91
322:                             gui_putpixel(mouse_x + i, mouse_y + j, cursor_color[color]);
9D0248D4  3C099D03   LUI T1, -25341
9D024910  00892021   ADDU A0, A0, T1
323:                          xthresh--;
324:                       }
325:                       ythresh--;
9D024928  254AFFFF   ADDIU T2, T2, -1
9D02492C  24A5000B   ADDIU A1, A1, 11
9D024930  14ABFFEB   BNE A1, T3, .LVL150
9D024934  25080004   ADDIU T0, T0, 4
326:                    }
327:                 }
328:                 
329:                 void gui_tick(int ticks)
330:                 {
331:                 
332:                    static int fps_counter = 0;
333:                 
334:                    gui_ticks += ticks;
9D024560  8F828140   LW V0, -32448(GP)
9D024564  00441021   ADDU V0, V0, A0
9D024568  AF828140   SW V0, -32448(GP)
335:                    fps_counter += ticks;
9D02456C  8F828134   LW V0, -32460(GP)
9D024570  00822021   ADDU A0, A0, V0
9D024574  AF848134   SW A0, -32460(GP)
336:                    
337:                    if (fps_counter >= gui_refresh)
9D024578  8F828020   LW V0, -32736(GP)
9D02457C  0082182A   SLT V1, A0, V0
9D024580  14600004   BNE V1, ZERO, 0x9D024594
9D024584  00822023   SUBU A0, A0, V0
338:                    {
339:                       fps_counter -= gui_refresh;
9D024588  AF848134   SW A0, -32460(GP)
340:                       gui_fpsupdate = true;
9D02458C  24020001   ADDIU V0, ZERO, 1
9D024590  AF828144   SW V0, -32444(GP)
9D024594  03E00008   JR RA
9D024598  00000000   NOP
341:                    }
342:                 }
343:                 
344:                 /* updated in sync with the timer interrupt */
345:                 static void gui_tickdec(void)
346:                 {
347:                 #ifdef NOFRENDO_DEBUG
348:                    static int hertz_ticks = 0;
349:                 #endif
350:                    int ticks = gui_ticks;
9D024680  8F828140   LW V0, -32448(GP)
351:                 
352:                    if (0 == ticks)
9D024684  1040000B   BEQ V0, ZERO, .LBE77
9D024688  3C03A001   LUI V1, -24575
353:                       return;
354:                 
355:                    gui_ticks = 0;
9D02468C  AF808140   SW ZERO, -32448(GP)
356:                 
357:                 #ifdef NOFRENDO_DEBUG
358:                    /* Check for corrupt memory block every 10 seconds */
359:                    hertz_ticks += ticks;
360:                    if (hertz_ticks >= (10 * gui_refresh))
361:                    {
362:                       hertz_ticks -= (10 * gui_refresh);
363:                       mem_checkblocks(); 
364:                    }
365:                 #endif
366:                 
367:                    /* TODO: bleh */
368:                    if (msg.ttl > 0)
9D024690  8C63A624   LW V1, -23004(V1)
9D024694  18600007   BLEZ V1, .LBE77
9D024698  00621023   SUBU V0, V1, V0
369:                    {
370:                       msg.ttl -= ticks;
9D0246A4  0B4091AD   J .LBE77
9D0246A8  AC62A624   SW V0, -23004(V1)
371:                       if (msg.ttl < 0)
9D02469C  04400003   BLTZ V0, .LBB77
9D0246A0  3C03A001   LUI V1, -24575
372:                          msg.ttl = 0;
9D0246AC  3C02A001   LUI V0, -24575
9D0246B0  AC40A624   SW ZERO, -23004(V0)
373:                    }
374:                 }
375:                 
376:                 /* Update the FPS display */
377:                 static void gui_updatefps(void)
378:                 {
379:                    static char fpsbuf[20];
380:                 
381:                    /* Check to see if we need to do an sprintf or not */
382:                    if (true == gui_fpsupdate)
9D0246C0  24020001   ADDIU V0, ZERO, 1
383:                    {
384:                       sprintf(fpsbuf, "%4d FPS /%4d%%", gui_fps, (gui_fps * 100) / gui_refresh);
9D0246D0  8F86813C   LW A2, -32452(GP)
385:                       gui_fps = 0;
9D02470C  AF80813C   SW ZERO, -32452(GP)
386:                       gui_fpsupdate = false;
9D024710  AF808144   SW ZERO, -32444(GP)
387:                    }
388:                 
389:                    gui_textout(fpsbuf, gui_surface->width - 1 - 90, 1, &small, GUI_GREEN);
9D024714  8F828138   LW V0, -32456(GP)
390:                 }
391:                 
392:                 /* Turn FPS on/off */
393:                 void gui_togglefps(void)
394:                 {
395:                    option_showfps ^= true;
9D02459C  8F82815C   LW V0, -32420(GP)
9D0245A0  38420001   XORI V0, V0, 1
9D0245A4  03E00008   JR RA
9D0245A8  AF82815C   SW V0, -32420(GP)
396:                 }
397:                 
398:                 /* Turn GUI on/off */
399:                 void gui_togglegui(void)
400:                 {
401:                    option_showgui ^= true;
9D0245AC  8F828158   LW V0, -32424(GP)
9D0245B0  38420001   XORI V0, V0, 1
9D0245B4  03E00008   JR RA
9D0245B8  AF828158   SW V0, -32424(GP)
402:                 }
403:                 
404:                 void gui_togglewave(void)
405:                 {
406:                    option_wavetype = (option_wavetype + 1) % GUI_NUMWAVESTYLES;
9D0245BC  8F828154   LW V0, -32428(GP)
9D0245C0  24420001   ADDIU V0, V0, 1
9D0245C4  3C035555   LUI V1, 21845
9D0245C8  24635556   ADDIU V1, V1, 21846
9D0245CC  00430018   MULT 0, V0, V1
9D0245D0  00001810   MFHI V1
9D0245D4  000227C3   SRA A0, V0, 31
9D0245D8  00641823   SUBU V1, V1, A0
9D0245DC  00032040   SLL A0, V1, 1
9D0245E0  00831821   ADDU V1, A0, V1
9D0245E4  00431023   SUBU V0, V0, V1
9D0245E8  03E00008   JR RA
9D0245EC  AF828154   SW V0, -32428(GP)
407:                 }
408:                 
409:                 void gui_toggleoam(void)
410:                 {
411:                    option_showoam ^= true;
9D0245F0  8F82814C   LW V0, -32436(GP)
9D0245F4  38420001   XORI V0, V0, 1
9D0245F8  03E00008   JR RA
9D0245FC  AF82814C   SW V0, -32436(GP)
412:                 }
413:                 
414:                 /* TODO: hack! */
415:                 void gui_togglepattern(void)
416:                 {
417:                    option_showpattern ^= true;
9D024600  8F828150   LW V0, -32432(GP)
9D024604  38420001   XORI V0, V0, 1
9D024608  03E00008   JR RA
9D02460C  AF828150   SW V0, -32432(GP)
418:                 }
419:                 
420:                 /* TODO: hack! */
421:                 void gui_decpatterncol(void)
422:                 {
423:                    if (pattern_col && option_showpattern)
9D024610  8F828148   LW V0, -32440(GP)
9D024614  10400004   BEQ V0, ZERO, 0x9D024628
9D024618  8F838150   LW V1, -32432(GP)
9D02461C  10600002   BEQ V1, ZERO, 0x9D024628
9D024620  2442FFFF   ADDIU V0, V0, -1
424:                       pattern_col--;
9D024624  AF828148   SW V0, -32440(GP)
9D024628  03E00008   JR RA
9D02462C  00000000   NOP
425:                 }
426:                 
427:                 /* TODO: hack! */
428:                 void gui_incpatterncol(void)
429:                 {
430:                    if ((pattern_col < 7) && option_showpattern)
9D024630  8F828148   LW V0, -32440(GP)
9D024634  28430007   SLTI V1, V0, 7
9D024638  10600004   BEQ V1, ZERO, 0x9D02464C
9D02463C  8F838150   LW V1, -32432(GP)
9D024640  10600002   BEQ V1, ZERO, 0x9D02464C
9D024644  24420001   ADDIU V0, V0, 1
431:                       pattern_col++;
9D024648  AF828148   SW V0, -32440(GP)
9D02464C  03E00008   JR RA
9D024650  00000000   NOP
432:                 }
433:                 
434:                 /* Downward-scrolling message display */
435:                 static void gui_updatemsg(void)
436:                 {
437:                    if (msg.ttl)
9D024868  8C42A624   LW V0, -23004(V0)
438:                       gui_textbar(msg.text, 2, gui_surface->height - 10, &small, msg.color, GUI_DKGRAY, BUTTON_UP);
9D024874  8F828138   LW V0, -32456(GP)
9D024878  8C460004   LW A2, 4(V0)
9D02487C  3C02A001   LUI V0, -24575
9D024880  9042A728   LBU V0, -22744(V0)
9D024884  AFA20010   SW V0, 16(SP)
9D024888  240200C1   ADDIU V0, ZERO, 193
9D02488C  AFA20014   SW V0, 20(SP)
9D024890  AFA00018   SW ZERO, 24(SP)
9D024894  3C04A001   LUI A0, -24575
9D024898  2484A628   ADDIU A0, A0, -23000
9D02489C  24050002   ADDIU A1, ZERO, 2
9D0248A0  24C6FFF6   ADDIU A2, A2, -10
9D0248A4  0F409025   JAL .LFB21, gui_textbar, .LVL37, .LFE20
9D0248A8  27878028   ADDIU A3, GP, -32728
439:                 }
440:                 
441:                 /* Little thing to display the waveform */
442:                 static void gui_updatewave(int wave_type)
443:                 {
9D02422C  27BDFE48   ADDIU SP, SP, -440
9D024230  AFBF01B4   SW RA, 436(SP)
9D024234  AFBE01B0   SW FP, 432(SP)
9D024238  AFB701AC   SW S7, 428(SP)
9D02423C  AFB601A8   SW S6, 424(SP)
9D024240  AFB501A4   SW S5, 420(SP)
9D024244  AFB401A0   SW S4, 416(SP)
9D024248  AFB3019C   SW S3, 412(SP)
9D02424C  AFB20198   SW S2, 408(SP)
9D024250  AFB10194   SW S1, 404(SP)
9D024254  AFB00190   SW S0, 400(SP)
9D024258  00808021   ADDU S0, A0, ZERO
444:                 #define  WAVEDISP_WIDTH   128
445:                    int loop, xofs, yofs;
446:                    int difference, offset;
447:                    float scale;
448:                    uint8 val, oldval;
449:                    int vis_length = 0;
450:                    void *vis_buffer = NULL;
451:                    int vis_bps;
452:                    apu_t apu;
453:                 
454:                    apu_getcontext(&apu);
9D02425C  0F407892   JAL apu_getcontext
9D024260  27A40020   ADDIU A0, SP, 32
455:                    vis_buffer = apu.buffer;
9D024264  8FB10158   LW S1, 344(SP)
456:                    vis_length = apu.num_samples;
457:                    vis_bps = apu.sample_bits;
9D024268  8FB20174   LW S2, 372(SP)
458:                 
459:                    xofs = (NES_SCREEN_WIDTH - WAVEDISP_WIDTH);
460:                    yofs = 1;
461:                    scale = (float) (vis_length / (float) WAVEDISP_WIDTH);
9D02426C  0F40EEE7   JAL sitofp
9D024270  8FA4015C   LW A0, 348(SP)
9D024274  00402021   ADDU A0, V0, ZERO
9D024278  3C029D04   LUI V0, -25340
9D02427C  0F40D795   JAL __mulsf3
9D024280  8C459628   LW A1, -27096(V0)
462:                 
463:                    if (NULL == vis_buffer)
9D024284  16200013   BNE S1, ZERO, .LVL76
9D024288  00409821   ADDU S3, V0, ZERO
464:                    {
465:                       /* draw centerline */
466:                       gui_hline(xofs, yofs + 0x20, WAVEDISP_WIDTH, GUI_GRAY);
9D02428C  24040080   ADDIU A0, ZERO, 128
9D024290  24050021   ADDIU A1, ZERO, 33
9D024294  24060080   ADDIU A2, ZERO, 128
9D024298  0F408FC7   JAL .LFB12, gui_hline, .LVL0, .Ltext0, .Letext0, .LFE31
9D02429C  240700C2   ADDIU A3, ZERO, 194
467:                       gui_textbar("no sound", xofs + 40, yofs + 0x20 - 4, &small, GUI_RED, GUI_DKGRAY, BUTTON_UP);
9D0242A0  240200C5   ADDIU V0, ZERO, 197
9D0242A4  AFA20010   SW V0, 16(SP)
9D0242A8  240200C1   ADDIU V0, ZERO, 193
9D0242AC  AFA20014   SW V0, 20(SP)
9D0242B0  AFA00018   SW ZERO, 24(SP)
9D0242B4  3C049D04   LUI A0, -25340
9D0242B8  24849540   ADDIU A0, A0, -27328
9D0242BC  240500A8   ADDIU A1, ZERO, 168
9D0242C0  2406001D   ADDIU A2, ZERO, 29
9D0242C4  0F409025   JAL .LFB21, gui_textbar, .LVL37, .LFE20
9D0242C8  27878028   ADDIU A3, GP, -32728
9D0242CC  0B409133   J 0x9D0244CC
9D0242D0  24040080   ADDIU A0, ZERO, 128
468:                 
469:                    }
470:                    else if (GUI_WAVELINE == wave_type)
9D0242D4  24020001   ADDIU V0, ZERO, 1
9D0242D8  16020044   BNE S0, V0, .LVL99
9D0242DC  24020002   ADDIU V0, ZERO, 2
471:                    {
472:                       /* draw centerline */
473:                       gui_hline(xofs, yofs + 0x20, WAVEDISP_WIDTH, GUI_GRAY);
9D0242E0  24040080   ADDIU A0, ZERO, 128
9D0242E4  24050021   ADDIU A1, ZERO, 33
9D0242E8  24060080   ADDIU A2, ZERO, 128
9D0242EC  0F408FC7   JAL .LFB12, gui_hline, .LVL0, .Ltext0, .Letext0, .LFE31
9D0242F0  240700C2   ADDIU A3, ZERO, 194
474:                 
475:                       /* initial old value */
476:                       if (16 == vis_bps)
9D0242F4  24020010   ADDIU V0, ZERO, 16
9D0242F8  56420008   BNEL S2, V0, .LVL79
9D0242FC  92220000   LBU V0, 0(S1)
477:                          oldval = 0x40 - (((((uint16 *) vis_buffer)[0] >> 8) ^ 0x80) >> 2);
9D024300  96220000   LHU V0, 0(S1)
9D024304  38428000   XORI V0, V0, -32768
9D024308  00021282   SRL V0, V0, 10
9D02430C  24150040   ADDIU S5, ZERO, 64
9D024310  02A2A823   SUBU S5, S5, V0
9D024314  0B409148   J .LVL124
9D024318  32B500FF   ANDI S5, S5, 255
478:                       else
479:                          oldval = 0x40 - (((uint8 *) vis_buffer)[0] >> 2);
9D02431C  00021082   SRL V0, V0, 2
9D024320  24150040   ADDIU S5, ZERO, 64
9D024324  02A2A823   SUBU S5, S5, V0
9D024328  0B409148   J .LVL124
9D02432C  32B500FF   ANDI S5, S5, 255
480:                 
481:                       for (loop = 1; loop < WAVEDISP_WIDTH; loop++)
9D0243D8  26100001   ADDIU S0, S0, 1
9D0243DC  1616FFD4   BNE S0, S6, .LVL81
9D0243E0  0280A821   ADDU S5, S4, ZERO
9D0243E4  0B409133   J 0x9D0244CC
9D0243E8  24040080   ADDIU A0, ZERO, 128
9D02452C  0B4090CC   J .LVL81
9D024530  24160080   ADDIU S6, ZERO, 128
482:                       {
483:                          //val = 0x40 - (vis_buffer[(uint32) (loop * scale)] >> 2);
484:                          if (16 == vis_bps)
9D024330  165E0010   BNE S2, FP, .LVL86
9D024334  00000000   NOP
9D024524  241E0010   ADDIU FP, ZERO, 16
485:                             val = 0x40 - (((((uint16 *) vis_buffer)[(uint32) (loop * scale)] >> 8) ^ 0x80) >> 2);
9D024338  0F40EEE7   JAL sitofp
9D02433C  02002021   ADDU A0, S0, ZERO
9D024340  00402021   ADDU A0, V0, ZERO
9D024344  0F40D795   JAL __mulsf3
9D024348  02602821   ADDU A1, S3, ZERO
9D02434C  0F40ECDC   JAL fptoui
9D024350  00402021   ADDU A0, V0, ZERO
9D024354  00021040   SLL V0, V0, 1
9D024358  02221021   ADDU V0, S1, V0
9D02435C  94540000   LHU S4, 0(V0)
9D024360  3A948000   XORI S4, S4, -32768
9D024364  0014A282   SRL S4, S4, 10
9D024368  02F4A023   SUBU S4, S7, S4
9D02436C  0B4090E9   J .LVL90
9D024370  329400FF   ANDI S4, S4, 255
486:                          else
487:                             val = 0x40 - (((uint8 *) vis_buffer)[(uint32) (loop * scale)] >> 2);
9D024374  0F40EEE7   JAL sitofp
9D024378  02002021   ADDU A0, S0, ZERO
9D02437C  00402021   ADDU A0, V0, ZERO
9D024380  0F40D795   JAL __mulsf3
9D024384  02602821   ADDU A1, S3, ZERO
9D024388  0F40ECDC   JAL fptoui
9D02438C  00402021   ADDU A0, V0, ZERO
9D024390  02221021   ADDU V0, S1, V0
9D024394  90540000   LBU S4, 0(V0)
9D024398  0014A082   SRL S4, S4, 2
9D02439C  02F4A023   SUBU S4, S7, S4
9D0243A0  329400FF   ANDI S4, S4, 255
9D024528  24170040   ADDIU S7, ZERO, 64
488:                          if (oldval < val)
9D0243A4  02B4102B   SLTU V0, S5, S4
9D0243A8  50400005   BEQL V0, ZERO, .LVL93
9D0243AC  02802821   ADDU A1, S4, ZERO
489:                          {
490:                             offset = oldval;
9D0243B0  02A02821   ADDU A1, S5, ZERO
491:                             difference = (val - oldval) + 1;
9D0243B4  0295A823   SUBU S5, S4, S5
9D0243B8  0B4090F2   J .LVL95
9D0243BC  26A60001   ADDIU A2, S5, 1
492:                          }
493:                          else
494:                          {
495:                             offset = val;
496:                             difference = (oldval - val) + 1;
9D0243C0  02B4A823   SUBU S5, S5, S4
9D0243C4  26A60001   ADDIU A2, S5, 1
497:                          }
498:                 
499:                          gui_vline(xofs + loop, yofs + offset, difference, GUI_GREEN);
9D0243C8  26040080   ADDIU A0, S0, 128
9D0243CC  24A50001   ADDIU A1, A1, 1
9D0243D0  0F408FD5   JAL .LFB13, gui_vline, .LVL8, .LFE12
9D0243D4  240700C6   ADDIU A3, ZERO, 198
500:                          oldval = val;
9D024520  24100001   ADDIU S0, ZERO, 1
501:                       }
502:                    }
503:                    /* solid wave */
504:                    else if (GUI_WAVESOLID == wave_type)
9D0243EC  56020037   BNEL S0, V0, 0x9D0244CC
9D0243F0  24040080   ADDIU A0, ZERO, 128
9D0243F4  24100080   ADDIU S0, ZERO, 128
505:                    {
506:                       for (loop = 0; loop < WAVEDISP_WIDTH; loop++)
9D024408  24150100   ADDIU S5, ZERO, 256
9D0244C0  1615FFD2   BNE S0, S5, .LVL101
9D0244C4  00000000   NOP
507:                       {
508:                          //val = vis_buffer[(uint32) (loop * scale)] >> 2;
509:                          if (16 == vis_bps)
9D0243F8  24160010   ADDIU S6, ZERO, 16
9D02440C  1656000E   BNE S2, S6, .LVL106
9D024410  2604FF80   ADDIU A0, S0, -128
510:                             val = ((((uint16 *) vis_buffer)[(uint32) (loop * scale)] >> 8) ^ 0x80) >> 2;
9D024414  0F40EEE7   JAL sitofp
9D024418  00000000   NOP
9D02441C  00402021   ADDU A0, V0, ZERO
9D024420  0F40D795   JAL __mulsf3
9D024424  02602821   ADDU A1, S3, ZERO
9D024428  0F40ECDC   JAL fptoui
9D02442C  00402021   ADDU A0, V0, ZERO
9D024430  00021040   SLL V0, V0, 1
9D024434  02221021   ADDU V0, S1, V0
9D024438  94460000   LHU A2, 0(V0)
9D02443C  38C68000   XORI A2, A2, -32768
9D024440  0B40911C   J .LVL110
9D024444  00063282   SRL A2, A2, 10
511:                          else
512:                             val = ((uint8 *) vis_buffer)[(uint32) (loop * scale)] >> 2;
9D024448  0F40EEE7   JAL sitofp
9D02444C  00000000   NOP
9D024450  00402021   ADDU A0, V0, ZERO
9D024454  0F40D795   JAL __mulsf3
9D024458  02602821   ADDU A1, S3, ZERO
9D02445C  0F40ECDC   JAL fptoui
9D024460  00402021   ADDU A0, V0, ZERO
9D024464  02221021   ADDU V0, S1, V0
9D024468  90460000   LBU A2, 0(V0)
9D02446C  00063082   SRL A2, A2, 2
513:                          if (val == 0x20)
9D0243FC  24140020   ADDIU S4, ZERO, 32
9D024470  14D40006   BNE A2, S4, .LVL112
9D024474  2CC20020   SLTIU V0, A2, 32
514:                             gui_putpixel(xofs + loop, yofs + 0x20, GUI_GREEN);
515:                          else if (val < 0x20)
9D02448C  10400007   BEQ V0, ZERO, .LVL115
9D024490  02002021   ADDU A0, S0, ZERO
516:                             gui_vline(xofs + loop, yofs + 0x20, 0x20 - val, GUI_GREEN);
9D024494  24050021   ADDIU A1, ZERO, 33
9D024498  02863023   SUBU A2, S4, A2
9D02449C  0F408FD5   JAL .LFB13, gui_vline, .LVL8, .LFE12
9D0244A0  240700C6   ADDIU A3, ZERO, 198
9D0244A4  0B409130   J .LVL118
9D0244A8  26100001   ADDIU S0, S0, 1
517:                          else
518:                             gui_vline(xofs + loop, yofs + 0x20 - (val - 0x20), val - 0x20,
9D024400  24170041   ADDIU S7, ZERO, 65
9D0244AC  02E62823   SUBU A1, S7, A2
9D0244B0  24C6FFE0   ADDIU A2, A2, -32
9D0244B4  0F408FD5   JAL .LFB13, gui_vline, .LVL8, .LFE12
9D0244B8  240700C6   ADDIU A3, ZERO, 198
9D0244BC  26100001   ADDIU S0, S0, 1
519:                                       GUI_GREEN);
520:                       }
521:                    }
522:                 
523:                    gui_rect(xofs, yofs - 1, WAVEDISP_WIDTH, 66, GUI_DKGRAY);
524:                 }
9D024518  0B40914D   J .LVL126
9D02451C  8FBF01B4   LW RA, 436(SP)
9D024534  8FBE01B0   LW FP, 432(SP)
9D024538  8FB701AC   LW S7, 428(SP)
9D02453C  8FB601A8   LW S6, 424(SP)
9D024540  8FB501A4   LW S5, 420(SP)
9D024544  8FB401A0   LW S4, 416(SP)
9D024548  8FB3019C   LW S3, 412(SP)
9D02454C  8FB20198   LW S2, 408(SP)
9D024550  8FB10194   LW S1, 404(SP)
9D024554  8FB00190   LW S0, 400(SP)
9D024558  03E00008   JR RA
9D02455C  27BD01B8   ADDIU SP, SP, 440
525:                 
526:                 
527:                 static void gui_updatepattern(void)
528:                 {
529:                    /* Pretty it up a bit */
530:                    gui_textbar("Pattern Table 0", 0, 0, &small, GUI_GREEN, GUI_DKGRAY, BUTTON_UP);
9D02475C  241100C6   ADDIU S1, ZERO, 198
531:                    gui_textbar("Pattern Table 1", 128, 0, &small, GUI_GREEN, GUI_DKGRAY, BUTTON_UP);
9D024788  AFB10010   SW S1, 16(SP)
532:                    gui_hline(0, 9, 256, GUI_DKGRAY);
9D0247AC  00002021   ADDU A0, ZERO, ZERO
533:                    gui_hline(0, 138, 256, GUI_DKGRAY);
9D0247C0  00002021   ADDU A0, ZERO, ZERO
534:                 
535:                    /* Dump the actual tables */
536:                    ppu_dumppattern(gui_surface, 0, 0, 10, pattern_col);
9D0247D4  8F828148   LW V0, -32440(GP)
537:                    ppu_dumppattern(gui_surface, 1, 128, 10, pattern_col);
9D0247F0  8F828148   LW V0, -32440(GP)
9D0247F4  AFA20010   SW V0, 16(SP)
9D0247F8  8F848138   LW A0, -32456(GP)
9D0247FC  24050001   ADDIU A1, ZERO, 1
9D024800  24060080   ADDIU A2, ZERO, 128
9D024804  0F406A03   JAL ppu_dumppattern
9D024808  2407000A   ADDIU A3, ZERO, 10
538:                 }
539:                 
540:                 static void gui_updateoam(void)
541:                 {
542:                    int y;
543:                 
544:                    y = option_showpattern ? 140 : 0;
9D024818  2402008C   ADDIU V0, ZERO, 140
545:                    gui_textbar("Current OAM", 0, y, &small, GUI_GREEN, GUI_DKGRAY, BUTTON_UP);
9D024828  240200C6   ADDIU V0, ZERO, 198
546:                    ppu_dumpoam(gui_surface, 0, y + 9);
9D024854  8F848138   LW A0, -32456(GP)
9D024858  00002821   ADDU A1, ZERO, ZERO
9D02485C  0F40692C   JAL ppu_dumpoam
9D024860  26060009   ADDIU A2, S0, 9
547:                 }
548:                 
549:                 
550:                 /* The GUI overlay */
551:                 void gui_frame(bool draw)
552:                 {
9D024654  27BDFFD0   ADDIU SP, SP, -48
9D024658  AFBF002C   SW RA, 44(SP)
9D02465C  AFB10028   SW S1, 40(SP)
9D024660  AFB00024   SW S0, 36(SP)
553:                    gui_fps++;
9D024664  8F82813C   LW V0, -32452(GP)
9D024668  24420001   ADDIU V0, V0, 1
554:                    if (false == draw)
9D02466C  108000B2   BEQ A0, ZERO, .LVL159, .LBE87, .LBE86
9D024670  AF82813C   SW V0, -32452(GP)
555:                       return;
556:                 
557:                    gui_surface = vid_getbuffer();
9D024674  0F40BAD1   JAL vid_getbuffer
9D024678  00000000   NOP
9D02467C  AF828138   SW V0, -32456(GP)
558:                 
559:                    ASSERT(gui_surface);
560:                 
561:                    gui_tickdec();
562:                 
563:                    if (option_showfps)
9D0246B4  8F82815C   LW V0, -32420(GP)
9D0246B8  10400021   BEQ V0, ZERO, 0x9D024740
9D0246BC  8F848154   LW A0, -32428(GP)
564:                       gui_updatefps();
565:                 
566:                    if (option_wavetype != GUI_WAVENONE)
9D02473C  8F848154   LW A0, -32428(GP)
9D024740  10800004   BEQ A0, ZERO, 0x9D024754
9D024744  8F828150   LW V0, -32432(GP)
567:                       gui_updatewave(option_wavetype);
9D024748  0F40908B   JAL .LFB34, gui_updatewave, .LVL67, .LFE21
9D02474C  00000000   NOP
568:                 
569:                    if (option_showpattern)
9D024750  8F828150   LW V0, -32432(GP)
9D024754  1040002E   BEQ V0, ZERO, 0x9D024810
9D024758  8F82814C   LW V0, -32436(GP)
570:                       gui_updatepattern();
571:                 
572:                    if (option_showoam)
9D02480C  8F82814C   LW V0, -32436(GP)
9D024810  10400015   BEQ V0, ZERO, .LBB84
9D024814  3C02A001   LUI V0, -24575
573:                       gui_updateoam();
574:                 
575:                    if (msg.ttl)
9D024864  3C02A001   LUI V0, -24575
576:                       gui_updatemsg();
577:                 
578:                    if (option_showgui)
9D0248AC  8F828158   LW V0, -32424(GP)
9D0248B0  10400022   BEQ V0, ZERO, 0x9D02493C
9D0248B4  8FBF002C   LW RA, 44(SP)
579:                    {
580:                       //osd_getmouse(&mouse_x, &mouse_y, &mouse_button);
581:                       gui_drawmouse();
582:                    }
583:                 }
9D024938  8FBF002C   LW RA, 44(SP)
9D02493C  8FB10028   LW S1, 40(SP)
9D024940  8FB00024   LW S0, 36(SP)
9D024944  03E00008   JR RA
9D024948  27BD0030   ADDIU SP, SP, 48
584:                 
585:                 void gui_sendmsg(int color, char *format, ...)
586:                 {
9D02494C  27BDFFE0   ADDIU SP, SP, -32
9D024950  AFBF001C   SW RA, 28(SP)
9D024954  AFB00018   SW S0, 24(SP)
9D024958  00808021   ADDU S0, A0, ZERO
9D02495C  AFA60028   SW A2, 40(SP)
9D024960  AFA7002C   SW A3, 44(SP)
587:                    va_list arg;
588:                    va_start(arg, format);
9D024964  27A60028   ADDIU A2, SP, 40
9D024968  AFA60010   SW A2, 16(SP)
589:                    vsprintf(msg.text, format, arg);
9D02496C  3C04A001   LUI A0, -24575
9D024970  0F40EF5B   JAL vsprintf
9D024974  2484A628   ADDIU A0, A0, -23000
590:                 
591:                 #ifdef NOFRENDO_DEBUG
592:                    log_print("GUI: ");
593:                    log_print(msg.text);
594:                    log_print("\n");
595:                 #endif
596:                 
597:                    va_end(arg);
598:                 
599:                    msg.ttl = gui_refresh * 2; /* 2 second delay */
9D024978  3C02A001   LUI V0, -24575
9D02497C  8F838020   LW V1, -32736(GP)
9D024980  00031840   SLL V1, V1, 1
9D024984  AC43A624   SW V1, -23004(V0)
600:                    msg.color = color;
9D024988  2442A624   ADDIU V0, V0, -23004
9D02498C  A0500104   SB S0, 260(V0)
601:                 }
9D024990  8FBF001C   LW RA, 28(SP)
9D024994  8FB00018   LW S0, 24(SP)
9D024998  03E00008   JR RA
9D02499C  27BD0020   ADDIU SP, SP, 32
602:                 
603:                 void gui_setrefresh(int frequency)
604:                 {
605:                    gui_refresh = frequency;
9D024C20  03E00008   JR RA
9D024C24  AF848020   SW A0, -32736(GP)
606:                 }
607:                 
608:                 int gui_init(void)
609:                 {
9D024C28  27BDFFE8   ADDIU SP, SP, -24
9D024C2C  AFBF0014   SW RA, 20(SP)
610:                    gui_refresh = 60;
9D024C30  2402003C   ADDIU V0, ZERO, 60
9D024C34  AF828020   SW V0, -32736(GP)
611:                    memset(&msg, 0, sizeof(message_t));
9D024C38  3C04A001   LUI A0, -24575
9D024C3C  2484A624   ADDIU A0, A0, -23004
9D024C40  00002821   ADDU A1, ZERO, ZERO
9D024C44  0F40E9FC   JAL .Letext0, .LFE0, memset
9D024C48  24060108   ADDIU A2, ZERO, 264
612:                 
613:                    return 0; /* can't fail */
614:                 }
9D024C4C  00001021   ADDU V0, ZERO, ZERO
9D024C50  8FBF0014   LW RA, 20(SP)
9D024C54  03E00008   JR RA
9D024C58  27BD0018   ADDIU SP, SP, 24
615:                 
616:                 void gui_shutdown(void)
617:                 {
9D024C5C  03E00008   JR RA
618:                 }
619:                 
620:                 /*
621:                 ** $Log: gui.c,v $
622:                 ** Revision 1.2  2001/04/27 14:37:11  neil
623:                 ** wheeee
624:                 **
625:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
626:                 ** initial
627:                 **
628:                 ** Revision 1.26  2000/11/25 20:26:05  matt
629:                 ** removed fds "system"
630:                 **
631:                 ** Revision 1.25  2000/11/09 14:05:43  matt
632:                 ** state load fixed, state save mostly fixed
633:                 **
634:                 ** Revision 1.24  2000/11/05 16:37:18  matt
635:                 ** rolled rgb.h into bitmap.h
636:                 **
637:                 ** Revision 1.23  2000/10/27 12:57:49  matt
638:                 ** fixed pcx snapshots
639:                 **
640:                 ** Revision 1.22  2000/10/25 00:23:16  matt
641:                 ** makefiles updated for new directory structure
642:                 **
643:                 ** Revision 1.21  2000/10/23 17:50:47  matt
644:                 ** adding fds support
645:                 **
646:                 ** Revision 1.20  2000/10/23 15:52:04  matt
647:                 ** better system handling
648:                 **
649:                 ** Revision 1.19  2000/10/22 19:15:39  matt
650:                 ** more sane timer ISR / autoframeskip
651:                 **
652:                 ** Revision 1.18  2000/10/17 03:22:37  matt
653:                 ** cleaning up rom module
654:                 **
655:                 ** Revision 1.17  2000/10/10 13:58:13  matt
656:                 ** stroustrup squeezing his way in the door
657:                 **
658:                 ** Revision 1.16  2000/10/10 13:03:53  matt
659:                 ** Mr. Clean makes a guest appearance
660:                 **
661:                 ** Revision 1.15  2000/10/08 17:59:12  matt
662:                 ** gui_ticks is volatile
663:                 **
664:                 ** Revision 1.14  2000/09/15 04:58:06  matt
665:                 ** simplifying and optimizing APU core
666:                 **
667:                 ** Revision 1.13  2000/07/31 04:28:46  matt
668:                 ** one million cleanups
669:                 **
670:                 ** Revision 1.12  2000/07/30 04:29:59  matt
671:                 ** no more apu_getpcmdata hack
672:                 **
673:                 ** Revision 1.11  2000/07/25 02:20:47  matt
674:                 ** moved gui palette filth here, for the time being
675:                 **
676:                 ** Revision 1.10  2000/07/24 04:32:05  matt
677:                 ** bugfix on message delay
678:                 **
679:                 ** Revision 1.9  2000/07/23 15:16:25  matt
680:                 ** moved non-osd code here
681:                 **
682:                 ** Revision 1.8  2000/07/17 01:52:27  matt
683:                 ** made sure last line of all source files is a newline
684:                 **
685:                 ** Revision 1.7  2000/07/11 04:40:23  matt
686:                 ** updated for new screen dimension defines
687:                 **
688:                 ** Revision 1.6  2000/07/09 03:39:33  matt
689:                 ** small gui_frame cleanup
690:                 **
691:                 ** Revision 1.5  2000/07/06 16:47:18  matt
692:                 ** new video driver interface
693:                 **
694:                 ** Revision 1.4  2000/06/09 15:12:25  matt
695:                 ** initial revision
696:                 **
697:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/event.c  -----------------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** event.c
21:                  **
22:                  ** OS-independent event handling
23:                  ** $Id: event.c,v 1.3 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <stdlib.h>
27:                  #include <noftypes.h>
28:                  #include <event.h>
29:                  #include <nofrendo.h>
30:                  #include <gui.h>
31:                  #include <osd.h>
32:                  
33:                  /* TODO: put system specific stuff in their own files... */
34:                  #include <nes.h>
35:                  #include <nesinput.h>
36:                  #include <nes_pal.h>
37:                  #include <nesstate.h>
38:                  
39:                  /* pointer to our current system's event handler table */
40:                  static event_t *system_events = NULL;
41:                  
42:                  /* standard keyboard input */
43:                  static nesinput_t kb_input = { INP_JOYPAD0, 0 };
44:                  static nesinput_t kb_alt_input = { INP_JOYPAD1, 0 };
45:                  
46:                  static void func_event_quit(int code)
47:                  {
9D027CB4  27BDFFE8   ADDIU SP, SP, -24
9D027CB8  AFBF0014   SW RA, 20(SP)
48:                     UNUSED(code);
49:                     main_quit();
9D027CBC  0F40CE1D   JAL main_quit
9D027CC0  00000000   NOP
50:                  }
9D027CC4  8FBF0014   LW RA, 20(SP)
9D027CC8  03E00008   JR RA
9D027CCC  27BD0018   ADDIU SP, SP, 24
51:                  
52:                  static void func_event_insert(int code)
53:                  {
9D02721C  03E00008   JR RA
9D027220  00000000   NOP
54:                     UNUSED(code);
55:                     /* TODO: after the GUI */
56:                  }
57:                  
58:                  static void func_event_eject(int code)
59:                  {
9D027C94  27BDFFE8   ADDIU SP, SP, -24
9D027C98  AFBF0014   SW RA, 20(SP)
60:                     if (INP_STATE_MAKE == code)
9D027C88  24020001   ADDIU V0, ZERO, 1
9D027C8C  14820007   BNE A0, V0, 0x9D027CAC
9D027C90  00000000   NOP
61:                        main_eject();
9D027C9C  0F40CE03   JAL main_eject
9D027CA0  00000000   NOP
62:                  }
9D027CA4  8FBF0014   LW RA, 20(SP)
9D027CA8  27BD0018   ADDIU SP, SP, 24
9D027CAC  03E00008   JR RA
9D027CB0  00000000   NOP
63:                  
64:                  static void func_event_togglepause(int code)
65:                  {
9D027C68  27BDFFE8   ADDIU SP, SP, -24
9D027C6C  AFBF0014   SW RA, 20(SP)
66:                     if (INP_STATE_MAKE == code)
9D027C5C  24020001   ADDIU V0, ZERO, 1
9D027C60  14820007   BNE A0, V0, 0x9D027C80
9D027C64  00000000   NOP
67:                        nes_togglepause();
9D027C70  0F408E02   JAL nes_togglepause
9D027C74  00000000   NOP
68:                  }
9D027C78  8FBF0014   LW RA, 20(SP)
9D027C7C  27BD0018   ADDIU SP, SP, 24
9D027C80  03E00008   JR RA
9D027C84  00000000   NOP
69:                  
70:                  static void func_event_soft_reset(int code)
71:                  {
9D027C3C  27BDFFE8   ADDIU SP, SP, -24
9D027C40  AFBF0014   SW RA, 20(SP)
72:                     if (INP_STATE_MAKE == code) 
9D027C30  24020001   ADDIU V0, ZERO, 1
9D027C34  14820007   BNE A0, V0, 0x9D027C54
9D027C38  00000000   NOP
73:                        nes_reset(SOFT_RESET);
9D027C44  0F408D95   JAL nes_reset
9D027C48  00002021   ADDU A0, ZERO, ZERO
74:                  }
9D027C4C  8FBF0014   LW RA, 20(SP)
9D027C50  27BD0018   ADDIU SP, SP, 24
9D027C54  03E00008   JR RA
9D027C58  00000000   NOP
75:                  
76:                  static void func_event_hard_reset(int code)
77:                  {
9D027C10  27BDFFE8   ADDIU SP, SP, -24
9D027C14  AFBF0014   SW RA, 20(SP)
78:                     if (INP_STATE_MAKE == code)
9D027C04  24020001   ADDIU V0, ZERO, 1
9D027C08  14820007   BNE A0, V0, 0x9D027C28
9D027C0C  00000000   NOP
79:                        nes_reset(HARD_RESET);
9D027C18  0F408D95   JAL nes_reset
9D027C1C  24040001   ADDIU A0, ZERO, 1
80:                  }
9D027C20  8FBF0014   LW RA, 20(SP)
9D027C24  27BD0018   ADDIU SP, SP, 24
9D027C28  03E00008   JR RA
9D027C2C  00000000   NOP
81:                  
82:                  static void func_event_snapshot(int code)
83:                  {
9D027BE4  27BDFFE8   ADDIU SP, SP, -24
9D027BE8  AFBF0014   SW RA, 20(SP)
84:                     if (INP_STATE_MAKE == code)
9D027BD8  24020001   ADDIU V0, ZERO, 1
9D027BDC  14820007   BNE A0, V0, 0x9D027BFC
9D027BE0  00000000   NOP
85:                        gui_savesnap();
9D027BEC  0F409268   JAL gui_savesnap
9D027BF0  00000000   NOP
86:                  }
9D027BF4  8FBF0014   LW RA, 20(SP)
9D027BF8  27BD0018   ADDIU SP, SP, 24
9D027BFC  03E00008   JR RA
9D027C00  00000000   NOP
87:                  
88:                  static void func_event_toggle_frameskip(int code)
89:                  {
9D027BB8  27BDFFE8   ADDIU SP, SP, -24
9D027BBC  AFBF0014   SW RA, 20(SP)
90:                     if (INP_STATE_MAKE == code)
9D027BAC  24020001   ADDIU V0, ZERO, 1
9D027BB0  14820007   BNE A0, V0, 0x9D027BD0
9D027BB4  00000000   NOP
91:                        gui_togglefs();
9D027BC0  0F409292   JAL gui_togglefs
9D027BC4  00000000   NOP
92:                  }
9D027BC8  8FBF0014   LW RA, 20(SP)
9D027BCC  27BD0018   ADDIU SP, SP, 24
9D027BD0  03E00008   JR RA
9D027BD4  00000000   NOP
93:                  
94:                  static void func_event_state_save(int code)
95:                  {
9D027B8C  27BDFFE8   ADDIU SP, SP, -24
9D027B90  AFBF0014   SW RA, 20(SP)
96:                     if (INP_STATE_MAKE == code)
9D027B80  24020001   ADDIU V0, ZERO, 1
9D027B84  14820007   BNE A0, V0, 0x9D027BA4
9D027B88  00000000   NOP
97:                        state_save();
9D027B94  0F409676   JAL state_save
9D027B98  00000000   NOP
98:                  }
9D027B9C  8FBF0014   LW RA, 20(SP)
9D027BA0  27BD0018   ADDIU SP, SP, 24
9D027BA4  03E00008   JR RA
9D027BA8  00000000   NOP
99:                  
100:                 static void func_event_state_load(int code)
101:                 {
9D027B60  27BDFFE8   ADDIU SP, SP, -24
9D027B64  AFBF0014   SW RA, 20(SP)
102:                    if (INP_STATE_MAKE == code)
9D027B54  24020001   ADDIU V0, ZERO, 1
9D027B58  14820007   BNE A0, V0, 0x9D027B78
9D027B5C  00000000   NOP
103:                       state_load();
9D027B68  0F40980A   JAL state_load
9D027B6C  00000000   NOP
104:                 }
9D027B70  8FBF0014   LW RA, 20(SP)
9D027B74  27BD0018   ADDIU SP, SP, 24
9D027B78  03E00008   JR RA
9D027B7C  00000000   NOP
105:                 
106:                 static void func_event_state_slot_0(int code)
107:                 {
9D027B34  27BDFFE8   ADDIU SP, SP, -24
9D027B38  AFBF0014   SW RA, 20(SP)
108:                    if (INP_STATE_MAKE == code)
9D027B28  24020001   ADDIU V0, ZERO, 1
9D027B2C  14820007   BNE A0, V0, 0x9D027B4C
9D027B30  00000000   NOP
109:                       state_setslot(0);
9D027B3C  0F409666   JAL state_setslot
9D027B40  00002021   ADDU A0, ZERO, ZERO
110:                 }
9D027B44  8FBF0014   LW RA, 20(SP)
9D027B48  27BD0018   ADDIU SP, SP, 24
9D027B4C  03E00008   JR RA
9D027B50  00000000   NOP
111:                 
112:                 static void func_event_state_slot_1(int code)
113:                 {
9D027B08  27BDFFE8   ADDIU SP, SP, -24
9D027B0C  AFBF0014   SW RA, 20(SP)
114:                    if (INP_STATE_MAKE == code) 
9D027AFC  24020001   ADDIU V0, ZERO, 1
9D027B00  14820007   BNE A0, V0, 0x9D027B20
9D027B04  00000000   NOP
115:                       state_setslot(1);
9D027B10  0F409666   JAL state_setslot
9D027B14  24040001   ADDIU A0, ZERO, 1
116:                 }
9D027B18  8FBF0014   LW RA, 20(SP)
9D027B1C  27BD0018   ADDIU SP, SP, 24
9D027B20  03E00008   JR RA
9D027B24  00000000   NOP
117:                 
118:                 static void func_event_state_slot_2(int code)
119:                 {
9D027ADC  27BDFFE8   ADDIU SP, SP, -24
9D027AE0  AFBF0014   SW RA, 20(SP)
120:                    if (INP_STATE_MAKE == code) 
9D027AD0  24020001   ADDIU V0, ZERO, 1
9D027AD4  14820007   BNE A0, V0, 0x9D027AF4
9D027AD8  00000000   NOP
121:                       state_setslot(2);
9D027AE4  0F409666   JAL state_setslot
9D027AE8  24040002   ADDIU A0, ZERO, 2
122:                 }
9D027AEC  8FBF0014   LW RA, 20(SP)
9D027AF0  27BD0018   ADDIU SP, SP, 24
9D027AF4  03E00008   JR RA
9D027AF8  00000000   NOP
123:                 
124:                 static void func_event_state_slot_3(int code)
125:                 {
9D027AB0  27BDFFE8   ADDIU SP, SP, -24
9D027AB4  AFBF0014   SW RA, 20(SP)
126:                    if (INP_STATE_MAKE == code)
9D027AA4  24020001   ADDIU V0, ZERO, 1
9D027AA8  14820007   BNE A0, V0, 0x9D027AC8
9D027AAC  00000000   NOP
127:                       state_setslot(3);
9D027AB8  0F409666   JAL state_setslot
9D027ABC  24040003   ADDIU A0, ZERO, 3
128:                 }
9D027AC0  8FBF0014   LW RA, 20(SP)
9D027AC4  27BD0018   ADDIU SP, SP, 24
9D027AC8  03E00008   JR RA
9D027ACC  00000000   NOP
129:                 
130:                 static void func_event_state_slot_4(int code)
131:                 {
9D027A84  27BDFFE8   ADDIU SP, SP, -24
9D027A88  AFBF0014   SW RA, 20(SP)
132:                    if (INP_STATE_MAKE == code)
9D027A78  24020001   ADDIU V0, ZERO, 1
9D027A7C  14820007   BNE A0, V0, 0x9D027A9C
9D027A80  00000000   NOP
133:                       state_setslot(4);
9D027A8C  0F409666   JAL state_setslot
9D027A90  24040004   ADDIU A0, ZERO, 4
134:                 }
9D027A94  8FBF0014   LW RA, 20(SP)
9D027A98  27BD0018   ADDIU SP, SP, 24
9D027A9C  03E00008   JR RA
9D027AA0  00000000   NOP
135:                 
136:                 static void func_event_state_slot_5(int code)
137:                 {
9D027A58  27BDFFE8   ADDIU SP, SP, -24
9D027A5C  AFBF0014   SW RA, 20(SP)
138:                    if (INP_STATE_MAKE == code) 
9D027A4C  24020001   ADDIU V0, ZERO, 1
9D027A50  14820007   BNE A0, V0, 0x9D027A70
9D027A54  00000000   NOP
139:                       state_setslot(5);
9D027A60  0F409666   JAL state_setslot
9D027A64  24040005   ADDIU A0, ZERO, 5
140:                 }
9D027A68  8FBF0014   LW RA, 20(SP)
9D027A6C  27BD0018   ADDIU SP, SP, 24
9D027A70  03E00008   JR RA
9D027A74  00000000   NOP
141:                 
142:                 static void func_event_state_slot_6(int code)
143:                 {
9D027A2C  27BDFFE8   ADDIU SP, SP, -24
9D027A30  AFBF0014   SW RA, 20(SP)
144:                    if (INP_STATE_MAKE == code) 
9D027A20  24020001   ADDIU V0, ZERO, 1
9D027A24  14820007   BNE A0, V0, 0x9D027A44
9D027A28  00000000   NOP
145:                       state_setslot(6);
9D027A34  0F409666   JAL state_setslot
9D027A38  24040006   ADDIU A0, ZERO, 6
146:                 }
9D027A3C  8FBF0014   LW RA, 20(SP)
9D027A40  27BD0018   ADDIU SP, SP, 24
9D027A44  03E00008   JR RA
9D027A48  00000000   NOP
147:                 
148:                 static void func_event_state_slot_7(int code)
149:                 {
9D027A00  27BDFFE8   ADDIU SP, SP, -24
9D027A04  AFBF0014   SW RA, 20(SP)
150:                    if (INP_STATE_MAKE == code) 
9D0279F4  24020001   ADDIU V0, ZERO, 1
9D0279F8  14820007   BNE A0, V0, 0x9D027A18
9D0279FC  00000000   NOP
151:                       state_setslot(7);
9D027A08  0F409666   JAL state_setslot
9D027A0C  24040007   ADDIU A0, ZERO, 7
152:                 }
9D027A10  8FBF0014   LW RA, 20(SP)
9D027A14  27BD0018   ADDIU SP, SP, 24
9D027A18  03E00008   JR RA
9D027A1C  00000000   NOP
153:                 
154:                 static void func_event_state_slot_8(int code)
155:                 {
9D0279D4  27BDFFE8   ADDIU SP, SP, -24
9D0279D8  AFBF0014   SW RA, 20(SP)
156:                    if (INP_STATE_MAKE == code)
9D0279C8  24020001   ADDIU V0, ZERO, 1
9D0279CC  14820007   BNE A0, V0, 0x9D0279EC
9D0279D0  00000000   NOP
157:                       state_setslot(8);
9D0279DC  0F409666   JAL state_setslot
9D0279E0  24040008   ADDIU A0, ZERO, 8
158:                 }
9D0279E4  8FBF0014   LW RA, 20(SP)
9D0279E8  27BD0018   ADDIU SP, SP, 24
9D0279EC  03E00008   JR RA
9D0279F0  00000000   NOP
159:                 
160:                 static void func_event_state_slot_9(int code)
161:                 {
9D0279A8  27BDFFE8   ADDIU SP, SP, -24
9D0279AC  AFBF0014   SW RA, 20(SP)
162:                    if (INP_STATE_MAKE == code)
9D02799C  24020001   ADDIU V0, ZERO, 1
9D0279A0  14820007   BNE A0, V0, 0x9D0279C0
9D0279A4  00000000   NOP
163:                       state_setslot(9);
9D0279B0  0F409666   JAL state_setslot
9D0279B4  24040009   ADDIU A0, ZERO, 9
164:                 }
9D0279B8  8FBF0014   LW RA, 20(SP)
9D0279BC  27BD0018   ADDIU SP, SP, 24
9D0279C0  03E00008   JR RA
9D0279C4  00000000   NOP
165:                 
166:                 static void func_event_gui_toggle_oam(int code)
167:                 {
9D02797C  27BDFFE8   ADDIU SP, SP, -24
9D027980  AFBF0014   SW RA, 20(SP)
168:                    if (INP_STATE_MAKE == code)
9D027970  24020001   ADDIU V0, ZERO, 1
9D027974  14820007   BNE A0, V0, 0x9D027994
9D027978  00000000   NOP
169:                       gui_toggleoam();
9D027984  0F40917C   JAL gui_toggleoam
9D027988  00000000   NOP
170:                 }
9D02798C  8FBF0014   LW RA, 20(SP)
9D027990  27BD0018   ADDIU SP, SP, 24
9D027994  03E00008   JR RA
9D027998  00000000   NOP
171:                 
172:                 static void func_event_gui_toggle_wave(int code)
173:                 {
9D027950  27BDFFE8   ADDIU SP, SP, -24
9D027954  AFBF0014   SW RA, 20(SP)
174:                    if (INP_STATE_MAKE == code)
9D027944  24020001   ADDIU V0, ZERO, 1
9D027948  14820007   BNE A0, V0, 0x9D027968
9D02794C  00000000   NOP
175:                       gui_togglewave();
9D027958  0F40916F   JAL gui_togglewave
9D02795C  00000000   NOP
176:                 }
9D027960  8FBF0014   LW RA, 20(SP)
9D027964  27BD0018   ADDIU SP, SP, 24
9D027968  03E00008   JR RA
9D02796C  00000000   NOP
177:                 
178:                 static void func_event_gui_toggle_pattern(int code)
179:                 {
9D027924  27BDFFE8   ADDIU SP, SP, -24
9D027928  AFBF0014   SW RA, 20(SP)
180:                    if (INP_STATE_MAKE == code)
9D027918  24020001   ADDIU V0, ZERO, 1
9D02791C  14820007   BNE A0, V0, 0x9D02793C
9D027920  00000000   NOP
181:                       gui_togglepattern();
9D02792C  0F409180   JAL gui_togglepattern
9D027930  00000000   NOP
182:                 }
9D027934  8FBF0014   LW RA, 20(SP)
9D027938  27BD0018   ADDIU SP, SP, 24
9D02793C  03E00008   JR RA
9D027940  00000000   NOP
183:                 
184:                 static void func_event_gui_pattern_color_up(int code)
185:                 {
9D0278F8  27BDFFE8   ADDIU SP, SP, -24
9D0278FC  AFBF0014   SW RA, 20(SP)
186:                    if (INP_STATE_MAKE == code)
9D0278EC  24020001   ADDIU V0, ZERO, 1
9D0278F0  14820007   BNE A0, V0, 0x9D027910
9D0278F4  00000000   NOP
187:                       gui_incpatterncol();
9D027900  0F40918C   JAL gui_incpatterncol
9D027904  00000000   NOP
188:                 }
9D027908  8FBF0014   LW RA, 20(SP)
9D02790C  27BD0018   ADDIU SP, SP, 24
9D027910  03E00008   JR RA
9D027914  00000000   NOP
189:                 
190:                 static void func_event_gui_pattern_color_down(int code)
191:                 {
9D0278CC  27BDFFE8   ADDIU SP, SP, -24
9D0278D0  AFBF0014   SW RA, 20(SP)
192:                    if (INP_STATE_MAKE == code)
9D0278C0  24020001   ADDIU V0, ZERO, 1
9D0278C4  14820007   BNE A0, V0, 0x9D0278E4
9D0278C8  00000000   NOP
193:                       gui_decpatterncol();
9D0278D4  0F409184   JAL gui_decpatterncol
9D0278D8  00000000   NOP
194:                 }
9D0278DC  8FBF0014   LW RA, 20(SP)
9D0278E0  27BD0018   ADDIU SP, SP, 24
9D0278E4  03E00008   JR RA
9D0278E8  00000000   NOP
195:                 
196:                 static void func_event_gui_toggle_fps(int code)
197:                 {
9D0278A0  27BDFFE8   ADDIU SP, SP, -24
9D0278A4  AFBF0014   SW RA, 20(SP)
198:                    if (INP_STATE_MAKE == code)
9D027894  24020001   ADDIU V0, ZERO, 1
9D027898  14820007   BNE A0, V0, 0x9D0278B8
9D02789C  00000000   NOP
199:                       gui_togglefps();
9D0278A8  0F409167   JAL gui_togglefps
9D0278AC  00000000   NOP
200:                 }
9D0278B0  8FBF0014   LW RA, 20(SP)
9D0278B4  27BD0018   ADDIU SP, SP, 24
9D0278B8  03E00008   JR RA
9D0278BC  00000000   NOP
201:                 
202:                 static void func_event_gui_display_info(int code)
203:                 {
9D027874  27BDFFE8   ADDIU SP, SP, -24
9D027878  AFBF0014   SW RA, 20(SP)
204:                    if (INP_STATE_MAKE == code)
9D027868  24020001   ADDIU V0, ZERO, 1
9D02786C  14820007   BNE A0, V0, 0x9D02788C
9D027870  00000000   NOP
205:                       gui_displayinfo();
9D02787C  0F4092A7   JAL gui_displayinfo
9D027880  00000000   NOP
206:                 }
9D027884  8FBF0014   LW RA, 20(SP)
9D027888  27BD0018   ADDIU SP, SP, 24
9D02788C  03E00008   JR RA
9D027890  00000000   NOP
207:                 
208:                 static void func_event_gui_toggle(int code)
209:                 {
9D027848  27BDFFE8   ADDIU SP, SP, -24
9D02784C  AFBF0014   SW RA, 20(SP)
210:                    if (INP_STATE_MAKE == code)
9D02783C  24020001   ADDIU V0, ZERO, 1
9D027840  14820007   BNE A0, V0, 0x9D027860
9D027844  00000000   NOP
211:                       gui_togglegui();
9D027850  0F40916B   JAL gui_togglegui
9D027854  00000000   NOP
212:                 }
9D027858  8FBF0014   LW RA, 20(SP)
9D02785C  27BD0018   ADDIU SP, SP, 24
9D027860  03E00008   JR RA
9D027864  00000000   NOP
213:                 
214:                 static void func_event_toggle_channel_0(int code)
215:                 {
9D02781C  27BDFFE8   ADDIU SP, SP, -24
9D027820  AFBF0014   SW RA, 20(SP)
216:                    if (INP_STATE_MAKE == code)
9D027810  24020001   ADDIU V0, ZERO, 1
9D027814  14820007   BNE A0, V0, 0x9D027834
9D027818  00000000   NOP
217:                       gui_toggle_chan(0);
9D027824  0F4092B3   JAL gui_toggle_chan
9D027828  00002021   ADDU A0, ZERO, ZERO
218:                 }
9D02782C  8FBF0014   LW RA, 20(SP)
9D027830  27BD0018   ADDIU SP, SP, 24
9D027834  03E00008   JR RA
9D027838  00000000   NOP
219:                 
220:                 static void func_event_toggle_channel_1(int code)
221:                 {
9D0277F0  27BDFFE8   ADDIU SP, SP, -24
9D0277F4  AFBF0014   SW RA, 20(SP)
222:                    if (INP_STATE_MAKE == code)
9D0277E4  24020001   ADDIU V0, ZERO, 1
9D0277E8  14820007   BNE A0, V0, 0x9D027808
9D0277EC  00000000   NOP
223:                       gui_toggle_chan(1);
9D0277F8  0F4092B3   JAL gui_toggle_chan
9D0277FC  24040001   ADDIU A0, ZERO, 1
224:                 }
9D027800  8FBF0014   LW RA, 20(SP)
9D027804  27BD0018   ADDIU SP, SP, 24
9D027808  03E00008   JR RA
9D02780C  00000000   NOP
225:                 
226:                 static void func_event_toggle_channel_2(int code)
227:                 {
9D0277C4  27BDFFE8   ADDIU SP, SP, -24
9D0277C8  AFBF0014   SW RA, 20(SP)
228:                    if (INP_STATE_MAKE == code)
9D0277B8  24020001   ADDIU V0, ZERO, 1
9D0277BC  14820007   BNE A0, V0, 0x9D0277DC
9D0277C0  00000000   NOP
229:                       gui_toggle_chan(2);
9D0277CC  0F4092B3   JAL gui_toggle_chan
9D0277D0  24040002   ADDIU A0, ZERO, 2
230:                 }
9D0277D4  8FBF0014   LW RA, 20(SP)
9D0277D8  27BD0018   ADDIU SP, SP, 24
9D0277DC  03E00008   JR RA
9D0277E0  00000000   NOP
231:                 
232:                 static void func_event_toggle_channel_3(int code)
233:                 {
9D027798  27BDFFE8   ADDIU SP, SP, -24
9D02779C  AFBF0014   SW RA, 20(SP)
234:                    if (INP_STATE_MAKE == code)
9D02778C  24020001   ADDIU V0, ZERO, 1
9D027790  14820007   BNE A0, V0, 0x9D0277B0
9D027794  00000000   NOP
235:                       gui_toggle_chan(3);
9D0277A0  0F4092B3   JAL gui_toggle_chan
9D0277A4  24040003   ADDIU A0, ZERO, 3
236:                 }
9D0277A8  8FBF0014   LW RA, 20(SP)
9D0277AC  27BD0018   ADDIU SP, SP, 24
9D0277B0  03E00008   JR RA
9D0277B4  00000000   NOP
237:                 
238:                 static void func_event_toggle_channel_4(int code)
239:                 {
9D02776C  27BDFFE8   ADDIU SP, SP, -24
9D027770  AFBF0014   SW RA, 20(SP)
240:                    if (INP_STATE_MAKE == code)
9D027760  24020001   ADDIU V0, ZERO, 1
9D027764  14820007   BNE A0, V0, 0x9D027784
9D027768  00000000   NOP
241:                       gui_toggle_chan(4);
9D027774  0F4092B3   JAL gui_toggle_chan
9D027778  24040004   ADDIU A0, ZERO, 4
242:                 }
9D02777C  8FBF0014   LW RA, 20(SP)
9D027780  27BD0018   ADDIU SP, SP, 24
9D027784  03E00008   JR RA
9D027788  00000000   NOP
243:                 
244:                 static void func_event_toggle_channel_5(int code)
245:                 {
9D027740  27BDFFE8   ADDIU SP, SP, -24
9D027744  AFBF0014   SW RA, 20(SP)
246:                    if (INP_STATE_MAKE == code)
9D027734  24020001   ADDIU V0, ZERO, 1
9D027738  14820007   BNE A0, V0, 0x9D027758
9D02773C  00000000   NOP
247:                       gui_toggle_chan(5);
9D027748  0F4092B3   JAL gui_toggle_chan
9D02774C  24040005   ADDIU A0, ZERO, 5
248:                 }
9D027750  8FBF0014   LW RA, 20(SP)
9D027754  27BD0018   ADDIU SP, SP, 24
9D027758  03E00008   JR RA
9D02775C  00000000   NOP
249:                 
250:                 static void func_event_set_filter_0(int code)
251:                 {
9D027714  27BDFFE8   ADDIU SP, SP, -24
9D027718  AFBF0014   SW RA, 20(SP)
252:                    if (INP_STATE_MAKE == code)
9D027708  24020001   ADDIU V0, ZERO, 1
9D02770C  14820007   BNE A0, V0, 0x9D02772C
9D027710  00000000   NOP
253:                       gui_setfilter(0);
9D02771C  0F4092E8   JAL gui_setfilter
9D027720  00002021   ADDU A0, ZERO, ZERO
254:                 }
9D027724  8FBF0014   LW RA, 20(SP)
9D027728  27BD0018   ADDIU SP, SP, 24
9D02772C  03E00008   JR RA
9D027730  00000000   NOP
255:                 
256:                 static void func_event_set_filter_1(int code)
257:                 {
9D0276E8  27BDFFE8   ADDIU SP, SP, -24
9D0276EC  AFBF0014   SW RA, 20(SP)
258:                    if (INP_STATE_MAKE == code)
9D0276DC  24020001   ADDIU V0, ZERO, 1
9D0276E0  14820007   BNE A0, V0, 0x9D027700
9D0276E4  00000000   NOP
259:                       gui_setfilter(1);
9D0276F0  0F4092E8   JAL gui_setfilter
9D0276F4  24040001   ADDIU A0, ZERO, 1
260:                 }
9D0276F8  8FBF0014   LW RA, 20(SP)
9D0276FC  27BD0018   ADDIU SP, SP, 24
9D027700  03E00008   JR RA
9D027704  00000000   NOP
261:                 
262:                 static void func_event_set_filter_2(int code)
263:                 {
9D0276BC  27BDFFE8   ADDIU SP, SP, -24
9D0276C0  AFBF0014   SW RA, 20(SP)
264:                    if (INP_STATE_MAKE == code)
9D0276B0  24020001   ADDIU V0, ZERO, 1
9D0276B4  14820007   BNE A0, V0, 0x9D0276D4
9D0276B8  00000000   NOP
265:                       gui_setfilter(2);
9D0276C4  0F4092E8   JAL gui_setfilter
9D0276C8  24040002   ADDIU A0, ZERO, 2
266:                 }
9D0276CC  8FBF0014   LW RA, 20(SP)
9D0276D0  27BD0018   ADDIU SP, SP, 24
9D0276D4  03E00008   JR RA
9D0276D8  00000000   NOP
267:                 
268:                 static void func_event_toggle_sprites(int code)
269:                 {
9D027690  27BDFFE8   ADDIU SP, SP, -24
9D027694  AFBF0014   SW RA, 20(SP)
270:                    if (INP_STATE_MAKE == code)
9D027684  24020001   ADDIU V0, ZERO, 1
9D027688  14820007   BNE A0, V0, 0x9D0276A8
9D02768C  00000000   NOP
271:                       gui_togglesprites();
9D027698  0F40927E   JAL gui_togglesprites
9D02769C  00000000   NOP
272:                 }
9D0276A0  8FBF0014   LW RA, 20(SP)
9D0276A4  27BD0018   ADDIU SP, SP, 24
9D0276A8  03E00008   JR RA
9D0276AC  00000000   NOP
273:                 
274:                 static void func_event_palette_hue_up(int code)
275:                 {
9D027628  27BDFFE8   ADDIU SP, SP, -24
9D02762C  AFBF0014   SW RA, 20(SP)
9D027630  AFB00010   SW S0, 16(SP)
276:                    /* make sure we don't have a VS game */
277:                    if (nes_getcontextptr()->rominfo->flags & ROM_FLAG_VERSUS)
9D027634  0F408D03   JAL nes_getcontextptr
9D027638  00808021   ADDU S0, A0, ZERO
9D02763C  8C420310   LW V0, 784(V0)
9D027640  90420028   LBU V0, 40(V0)
9D027644  30420008   ANDI V0, V0, 8
9D027648  304200FF   ANDI V0, V0, 255
9D02764C  14400009   BNE V0, ZERO, .LVL81
9D027650  24020001   ADDIU V0, ZERO, 1
278:                       return;
279:                 
280:                    if (INP_STATE_MAKE == code)
9D027654  16020008   BNE S0, V0, 0x9D027678
9D027658  8FBF0014   LW RA, 20(SP)
281:                    {
282:                       pal_inchue();
9D02765C  0F40C3EC   JAL pal_inchue
9D027660  00000000   NOP
283:                       ppu_setdefaultpal(nes_getcontextptr()->ppu);
9D027664  0F408D03   JAL nes_getcontextptr
9D027668  00000000   NOP
9D02766C  0F4065A1   JAL ppu_setdefaultpal
9D027670  8C440304   LW A0, 772(V0)
284:                    }
285:                 }
9D027674  8FBF0014   LW RA, 20(SP)
9D027678  8FB00010   LW S0, 16(SP)
9D02767C  03E00008   JR RA
9D027680  27BD0018   ADDIU SP, SP, 24
286:                 
287:                 static void func_event_palette_hue_down(int code)
288:                 {
9D0275CC  27BDFFE8   ADDIU SP, SP, -24
9D0275D0  AFBF0014   SW RA, 20(SP)
9D0275D4  AFB00010   SW S0, 16(SP)
289:                    /* make sure we don't have a VS game */
290:                    if (nes_getcontextptr()->rominfo->flags & ROM_FLAG_VERSUS)
9D0275D8  0F408D03   JAL nes_getcontextptr
9D0275DC  00808021   ADDU S0, A0, ZERO
9D0275E0  8C420310   LW V0, 784(V0)
9D0275E4  90420028   LBU V0, 40(V0)
9D0275E8  30420008   ANDI V0, V0, 8
9D0275EC  304200FF   ANDI V0, V0, 255
9D0275F0  14400009   BNE V0, ZERO, .LVL75
9D0275F4  24020001   ADDIU V0, ZERO, 1
291:                       return;
292:                 
293:                    if (INP_STATE_MAKE == code)
9D0275F8  16020008   BNE S0, V0, 0x9D02761C
9D0275FC  8FBF0014   LW RA, 20(SP)
294:                    {
295:                       pal_dechue();
9D027600  0F40C3DB   JAL pal_dechue
9D027604  00000000   NOP
296:                       ppu_setdefaultpal(nes_getcontextptr()->ppu);
9D027608  0F408D03   JAL nes_getcontextptr
9D02760C  00000000   NOP
9D027610  0F4065A1   JAL ppu_setdefaultpal
9D027614  8C440304   LW A0, 772(V0)
297:                    }
298:                 }
9D027618  8FBF0014   LW RA, 20(SP)
9D02761C  8FB00010   LW S0, 16(SP)
9D027620  03E00008   JR RA
9D027624  27BD0018   ADDIU SP, SP, 24
299:                 
300:                 static void func_event_palette_tint_up(int code)
301:                 {
9D027570  27BDFFE8   ADDIU SP, SP, -24
9D027574  AFBF0014   SW RA, 20(SP)
9D027578  AFB00010   SW S0, 16(SP)
302:                    /* make sure we don't have a VS game */
303:                    if (nes_getcontextptr()->rominfo->flags & ROM_FLAG_VERSUS)
9D02757C  0F408D03   JAL nes_getcontextptr
9D027580  00808021   ADDU S0, A0, ZERO
9D027584  8C420310   LW V0, 784(V0)
9D027588  90420028   LBU V0, 40(V0)
9D02758C  30420008   ANDI V0, V0, 8
9D027590  304200FF   ANDI V0, V0, 255
9D027594  14400009   BNE V0, ZERO, .LVL69
9D027598  24020001   ADDIU V0, ZERO, 1
304:                       return;
305:                 
306:                    if (INP_STATE_MAKE == code)
9D02759C  16020008   BNE S0, V0, 0x9D0275C0
9D0275A0  8FBF0014   LW RA, 20(SP)
307:                    {
308:                       pal_inctint();
9D0275A4  0F40C40E   JAL pal_inctint
9D0275A8  00000000   NOP
309:                       ppu_setdefaultpal(nes_getcontextptr()->ppu);
9D0275AC  0F408D03   JAL nes_getcontextptr
9D0275B0  00000000   NOP
9D0275B4  0F4065A1   JAL ppu_setdefaultpal
9D0275B8  8C440304   LW A0, 772(V0)
310:                    }
311:                 }
9D0275BC  8FBF0014   LW RA, 20(SP)
9D0275C0  8FB00010   LW S0, 16(SP)
9D0275C4  03E00008   JR RA
9D0275C8  27BD0018   ADDIU SP, SP, 24
312:                 
313:                 static void func_event_palette_tint_down(int code)
314:                 {
9D027514  27BDFFE8   ADDIU SP, SP, -24
9D027518  AFBF0014   SW RA, 20(SP)
9D02751C  AFB00010   SW S0, 16(SP)
315:                    /* make sure we don't have a VS game */
316:                    if (nes_getcontextptr()->rominfo->flags & ROM_FLAG_VERSUS)
9D027520  0F408D03   JAL nes_getcontextptr
9D027524  00808021   ADDU S0, A0, ZERO
9D027528  8C420310   LW V0, 784(V0)
9D02752C  90420028   LBU V0, 40(V0)
9D027530  30420008   ANDI V0, V0, 8
9D027534  304200FF   ANDI V0, V0, 255
9D027538  14400009   BNE V0, ZERO, .LVL63
9D02753C  24020001   ADDIU V0, ZERO, 1
317:                       return;
318:                 
319:                    if (INP_STATE_MAKE == code)
9D027540  16020008   BNE S0, V0, 0x9D027564
9D027544  8FBF0014   LW RA, 20(SP)
320:                    {
321:                       pal_dectint();
9D027548  0F40C3FD   JAL pal_dectint
9D02754C  00000000   NOP
322:                       ppu_setdefaultpal(nes_getcontextptr()->ppu);
9D027550  0F408D03   JAL nes_getcontextptr
9D027554  00000000   NOP
9D027558  0F4065A1   JAL ppu_setdefaultpal
9D02755C  8C440304   LW A0, 772(V0)
323:                    }
324:                 }
9D027560  8FBF0014   LW RA, 20(SP)
9D027564  8FB00010   LW S0, 16(SP)
9D027568  03E00008   JR RA
9D02756C  27BD0018   ADDIU SP, SP, 24
325:                 
326:                 static void func_event_palette_set_default(int code)
327:                 {
9D0274C0  27BDFFE8   ADDIU SP, SP, -24
9D0274C4  AFBF0014   SW RA, 20(SP)
9D0274C8  AFB00010   SW S0, 16(SP)
328:                    /* make sure we don't have a VS game */
329:                    if (nes_getcontextptr()->rominfo->flags & ROM_FLAG_VERSUS)
9D0274CC  0F408D03   JAL nes_getcontextptr
9D0274D0  00808021   ADDU S0, A0, ZERO
9D0274D4  8C420310   LW V0, 784(V0)
9D0274D8  90420028   LBU V0, 40(V0)
9D0274DC  30420008   ANDI V0, V0, 8
9D0274E0  304200FF   ANDI V0, V0, 255
9D0274E4  14400007   BNE V0, ZERO, .LVL57
9D0274E8  24020001   ADDIU V0, ZERO, 1
330:                       return;
331:                 
332:                    if (INP_STATE_MAKE == code)
9D0274EC  16020006   BNE S0, V0, 0x9D027508
9D0274F0  8FBF0014   LW RA, 20(SP)
333:                       ppu_setdefaultpal(nes_getcontextptr()->ppu);
9D0274F4  0F408D03   JAL nes_getcontextptr
9D0274F8  00000000   NOP
9D0274FC  0F4065A1   JAL ppu_setdefaultpal
9D027500  8C440304   LW A0, 772(V0)
334:                 }
9D027504  8FBF0014   LW RA, 20(SP)
9D027508  8FB00010   LW S0, 16(SP)
9D02750C  03E00008   JR RA
9D027510  27BD0018   ADDIU SP, SP, 24
335:                 
336:                 static void func_event_palette_set_shady(int code)
337:                 {
9D027464  27BDFFE8   ADDIU SP, SP, -24
9D027468  AFBF0014   SW RA, 20(SP)
9D02746C  AFB00010   SW S0, 16(SP)
338:                    /* make sure we don't have a VS game */
339:                    if (nes_getcontextptr()->rominfo->flags & ROM_FLAG_VERSUS)
9D027470  0F408D03   JAL nes_getcontextptr
9D027474  00808021   ADDU S0, A0, ZERO
9D027478  8C420310   LW V0, 784(V0)
9D02747C  90420028   LBU V0, 40(V0)
9D027480  30420008   ANDI V0, V0, 8
9D027484  304200FF   ANDI V0, V0, 255
9D027488  14400009   BNE V0, ZERO, .LVL52
9D02748C  24020001   ADDIU V0, ZERO, 1
340:                       return;
341:                 
342:                    if (INP_STATE_MAKE == code)
9D027490  16020008   BNE S0, V0, 0x9D0274B4
9D027494  8FBF0014   LW RA, 20(SP)
343:                       ppu_setpal(nes_getcontextptr()->ppu, shady_palette);
9D027498  0F408D03   JAL nes_getcontextptr
9D02749C  00000000   NOP
9D0274A0  8C440304   LW A0, 772(V0)
9D0274A4  3C05A001   LUI A1, -24575
9D0274A8  0F40656E   JAL ppu_setpal
9D0274AC  24A59EA4   ADDIU A1, A1, -24924
344:                 }
9D0274B0  8FBF0014   LW RA, 20(SP)
9D0274B4  8FB00010   LW S0, 16(SP)
9D0274B8  03E00008   JR RA
9D0274BC  27BD0018   ADDIU SP, SP, 24
345:                 
346:                 static void func_event_joypad1_a(int code)
347:                 {
9D027440  27BDFFE8   ADDIU SP, SP, -24
9D027444  AFBF0014   SW RA, 20(SP)
9D027448  00802821   ADDU A1, A0, ZERO
348:                    input_event(&kb_input, code, INP_PAD_A);
9D02744C  27848038   ADDIU A0, GP, -32712
9D027450  0F40CEFB   JAL input_event
9D027454  24060001   ADDIU A2, ZERO, 1
349:                 }
9D027458  8FBF0014   LW RA, 20(SP)
9D02745C  03E00008   JR RA
9D027460  27BD0018   ADDIU SP, SP, 24
350:                 
351:                 static void func_event_joypad1_b(int code)
352:                 {
9D02741C  27BDFFE8   ADDIU SP, SP, -24
9D027420  AFBF0014   SW RA, 20(SP)
9D027424  00802821   ADDU A1, A0, ZERO
353:                    input_event(&kb_input, code, INP_PAD_B);
9D027428  27848038   ADDIU A0, GP, -32712
9D02742C  0F40CEFB   JAL input_event
9D027430  24060002   ADDIU A2, ZERO, 2
354:                 }
9D027434  8FBF0014   LW RA, 20(SP)
9D027438  03E00008   JR RA
9D02743C  27BD0018   ADDIU SP, SP, 24
355:                 
356:                 static void func_event_joypad1_start(int code)
357:                 {
9D0273F8  27BDFFE8   ADDIU SP, SP, -24
9D0273FC  AFBF0014   SW RA, 20(SP)
9D027400  00802821   ADDU A1, A0, ZERO
358:                    input_event(&kb_input, code, INP_PAD_START);
9D027404  27848038   ADDIU A0, GP, -32712
9D027408  0F40CEFB   JAL input_event
9D02740C  24060008   ADDIU A2, ZERO, 8
359:                 }
9D027410  8FBF0014   LW RA, 20(SP)
9D027414  03E00008   JR RA
9D027418  27BD0018   ADDIU SP, SP, 24
360:                 
361:                 static void func_event_joypad1_select(int code)
362:                 {
9D0273D4  27BDFFE8   ADDIU SP, SP, -24
9D0273D8  AFBF0014   SW RA, 20(SP)
9D0273DC  00802821   ADDU A1, A0, ZERO
363:                    input_event(&kb_input, code, INP_PAD_SELECT);
9D0273E0  27848038   ADDIU A0, GP, -32712
9D0273E4  0F40CEFB   JAL input_event
9D0273E8  24060004   ADDIU A2, ZERO, 4
364:                 }
9D0273EC  8FBF0014   LW RA, 20(SP)
9D0273F0  03E00008   JR RA
9D0273F4  27BD0018   ADDIU SP, SP, 24
365:                 
366:                 static void func_event_joypad1_up(int code)
367:                 {
9D0273B0  27BDFFE8   ADDIU SP, SP, -24
9D0273B4  AFBF0014   SW RA, 20(SP)
9D0273B8  00802821   ADDU A1, A0, ZERO
368:                    input_event(&kb_input, code, INP_PAD_UP);
9D0273BC  27848038   ADDIU A0, GP, -32712
9D0273C0  0F40CEFB   JAL input_event
9D0273C4  24060010   ADDIU A2, ZERO, 16
369:                 }
9D0273C8  8FBF0014   LW RA, 20(SP)
9D0273CC  03E00008   JR RA
9D0273D0  27BD0018   ADDIU SP, SP, 24
370:                 
371:                 static void func_event_joypad1_down(int code)
372:                 {
9D02738C  27BDFFE8   ADDIU SP, SP, -24
9D027390  AFBF0014   SW RA, 20(SP)
9D027394  00802821   ADDU A1, A0, ZERO
373:                    input_event(&kb_input, code, INP_PAD_DOWN);
9D027398  27848038   ADDIU A0, GP, -32712
9D02739C  0F40CEFB   JAL input_event
9D0273A0  24060020   ADDIU A2, ZERO, 32
374:                 }
9D0273A4  8FBF0014   LW RA, 20(SP)
9D0273A8  03E00008   JR RA
9D0273AC  27BD0018   ADDIU SP, SP, 24
375:                 
376:                 static void func_event_joypad1_left(int code)
377:                 {
9D027368  27BDFFE8   ADDIU SP, SP, -24
9D02736C  AFBF0014   SW RA, 20(SP)
9D027370  00802821   ADDU A1, A0, ZERO
378:                    input_event(&kb_input, code, INP_PAD_LEFT);
9D027374  27848038   ADDIU A0, GP, -32712
9D027378  0F40CEFB   JAL input_event
9D02737C  24060040   ADDIU A2, ZERO, 64
379:                 }
9D027380  8FBF0014   LW RA, 20(SP)
9D027384  03E00008   JR RA
9D027388  27BD0018   ADDIU SP, SP, 24
380:                 
381:                 static void func_event_joypad1_right(int code)
382:                 {
9D027344  27BDFFE8   ADDIU SP, SP, -24
9D027348  AFBF0014   SW RA, 20(SP)
9D02734C  00802821   ADDU A1, A0, ZERO
383:                    input_event(&kb_input, code, INP_PAD_RIGHT);
9D027350  27848038   ADDIU A0, GP, -32712
9D027354  0F40CEFB   JAL input_event
9D027358  24060080   ADDIU A2, ZERO, 128
384:                 }
9D02735C  8FBF0014   LW RA, 20(SP)
9D027360  03E00008   JR RA
9D027364  27BD0018   ADDIU SP, SP, 24
385:                 
386:                 static void func_event_joypad2_a(int code)
387:                 {
9D027320  27BDFFE8   ADDIU SP, SP, -24
9D027324  AFBF0014   SW RA, 20(SP)
9D027328  00802821   ADDU A1, A0, ZERO
388:                    input_event(&kb_alt_input, code, INP_PAD_A);
9D02732C  27848030   ADDIU A0, GP, -32720
9D027330  0F40CEFB   JAL input_event
9D027334  24060001   ADDIU A2, ZERO, 1
389:                 }
9D027338  8FBF0014   LW RA, 20(SP)
9D02733C  03E00008   JR RA
9D027340  27BD0018   ADDIU SP, SP, 24
390:                 
391:                 static void func_event_joypad2_b(int code)
392:                 {
9D0272FC  27BDFFE8   ADDIU SP, SP, -24
9D027300  AFBF0014   SW RA, 20(SP)
9D027304  00802821   ADDU A1, A0, ZERO
393:                    input_event(&kb_alt_input, code, INP_PAD_B);
9D027308  27848030   ADDIU A0, GP, -32720
9D02730C  0F40CEFB   JAL input_event
9D027310  24060002   ADDIU A2, ZERO, 2
394:                 }
9D027314  8FBF0014   LW RA, 20(SP)
9D027318  03E00008   JR RA
9D02731C  27BD0018   ADDIU SP, SP, 24
395:                 
396:                 static void func_event_joypad2_start(int code)
397:                 {
9D0272D8  27BDFFE8   ADDIU SP, SP, -24
9D0272DC  AFBF0014   SW RA, 20(SP)
9D0272E0  00802821   ADDU A1, A0, ZERO
398:                    input_event(&kb_alt_input, code, INP_PAD_START);
9D0272E4  27848030   ADDIU A0, GP, -32720
9D0272E8  0F40CEFB   JAL input_event
9D0272EC  24060008   ADDIU A2, ZERO, 8
399:                 }
9D0272F0  8FBF0014   LW RA, 20(SP)
9D0272F4  03E00008   JR RA
9D0272F8  27BD0018   ADDIU SP, SP, 24
400:                 
401:                 static void func_event_joypad2_select(int code)
402:                 {
9D0272B4  27BDFFE8   ADDIU SP, SP, -24
9D0272B8  AFBF0014   SW RA, 20(SP)
9D0272BC  00802821   ADDU A1, A0, ZERO
403:                    input_event(&kb_alt_input, code, INP_PAD_SELECT);
9D0272C0  27848030   ADDIU A0, GP, -32720
9D0272C4  0F40CEFB   JAL input_event
9D0272C8  24060004   ADDIU A2, ZERO, 4
404:                 }
9D0272CC  8FBF0014   LW RA, 20(SP)
9D0272D0  03E00008   JR RA
9D0272D4  27BD0018   ADDIU SP, SP, 24
405:                 
406:                 static void func_event_joypad2_up(int code)
407:                 {
9D027290  27BDFFE8   ADDIU SP, SP, -24
9D027294  AFBF0014   SW RA, 20(SP)
9D027298  00802821   ADDU A1, A0, ZERO
408:                    input_event(&kb_alt_input, code, INP_PAD_UP);
9D02729C  27848030   ADDIU A0, GP, -32720
9D0272A0  0F40CEFB   JAL input_event
9D0272A4  24060010   ADDIU A2, ZERO, 16
409:                 }
9D0272A8  8FBF0014   LW RA, 20(SP)
9D0272AC  03E00008   JR RA
9D0272B0  27BD0018   ADDIU SP, SP, 24
410:                 
411:                 static void func_event_joypad2_down(int code)
412:                 {
9D02726C  27BDFFE8   ADDIU SP, SP, -24
9D027270  AFBF0014   SW RA, 20(SP)
9D027274  00802821   ADDU A1, A0, ZERO
413:                    input_event(&kb_alt_input, code, INP_PAD_DOWN);
9D027278  27848030   ADDIU A0, GP, -32720
9D02727C  0F40CEFB   JAL input_event
9D027280  24060020   ADDIU A2, ZERO, 32
414:                 }
9D027284  8FBF0014   LW RA, 20(SP)
9D027288  03E00008   JR RA
9D02728C  27BD0018   ADDIU SP, SP, 24
415:                 
416:                 static void func_event_joypad2_left(int code)
417:                 {
9D027248  27BDFFE8   ADDIU SP, SP, -24
9D02724C  AFBF0014   SW RA, 20(SP)
9D027250  00802821   ADDU A1, A0, ZERO
418:                    input_event(&kb_alt_input, code, INP_PAD_LEFT);
9D027254  27848030   ADDIU A0, GP, -32720
9D027258  0F40CEFB   JAL input_event
9D02725C  24060040   ADDIU A2, ZERO, 64
419:                 }
9D027260  8FBF0014   LW RA, 20(SP)
9D027264  03E00008   JR RA
9D027268  27BD0018   ADDIU SP, SP, 24
420:                 
421:                 static void func_event_joypad2_right(int code)
422:                 {
9D027224  27BDFFE8   ADDIU SP, SP, -24
9D027228  AFBF0014   SW RA, 20(SP)
9D02722C  00802821   ADDU A1, A0, ZERO
423:                    input_event(&kb_alt_input, code, INP_PAD_RIGHT);
9D027230  27848030   ADDIU A0, GP, -32720
9D027234  0F40CEFB   JAL input_event
9D027238  24060080   ADDIU A2, ZERO, 128
424:                 }
9D02723C  8FBF0014   LW RA, 20(SP)
9D027240  03E00008   JR RA
9D027244  27BD0018   ADDIU SP, SP, 24
425:                 
426:                 static void func_event_songup(int code)
427:                 {
428:                 }
429:                 
430:                 static void func_event_songdown(int code)
431:                 {
432:                 }
433:                 
434:                 static void func_event_startsong(int code)
435:                 {
436:                 }
437:                 
438:                 /* NES events */
439:                 static event_t nes_events[] =
440:                 {
441:                    NULL, /* 0 */
442:                    func_event_quit,
443:                    func_event_insert,
444:                    func_event_eject,
445:                    func_event_togglepause,
446:                    func_event_soft_reset,
447:                    func_event_hard_reset,
448:                    func_event_snapshot,
449:                    func_event_toggle_frameskip,
450:                    /* saves */
451:                    func_event_state_save,
452:                    func_event_state_load, /* 10 */
453:                    func_event_state_slot_0,
454:                    func_event_state_slot_1,
455:                    func_event_state_slot_2,
456:                    func_event_state_slot_3,
457:                    func_event_state_slot_4,
458:                    func_event_state_slot_5,
459:                    func_event_state_slot_6,
460:                    func_event_state_slot_7,
461:                    func_event_state_slot_8,
462:                    func_event_state_slot_9, /* 20 */
463:                    /* GUI */
464:                    func_event_gui_toggle_oam,
465:                    func_event_gui_toggle_wave,
466:                    func_event_gui_toggle_pattern,
467:                    func_event_gui_pattern_color_up,
468:                    func_event_gui_pattern_color_down,
469:                    func_event_gui_toggle_fps,
470:                    func_event_gui_display_info,
471:                    func_event_gui_toggle,
472:                    /* sound */
473:                    func_event_toggle_channel_0,
474:                    func_event_toggle_channel_1, /* 30 */
475:                    func_event_toggle_channel_2,
476:                    func_event_toggle_channel_3,
477:                    func_event_toggle_channel_4,
478:                    func_event_toggle_channel_5,
479:                    func_event_set_filter_0,
480:                    func_event_set_filter_1,
481:                    func_event_set_filter_2,
482:                    /* picture */
483:                    func_event_toggle_sprites,
484:                    func_event_palette_hue_up,
485:                    func_event_palette_hue_down,
486:                    func_event_palette_tint_up, /* 40 */
487:                    func_event_palette_tint_down,
488:                    func_event_palette_set_default,
489:                    func_event_palette_set_shady,
490:                    /* joypad 1 */
491:                    func_event_joypad1_a,
492:                    func_event_joypad1_b, 
493:                    func_event_joypad1_start,
494:                    func_event_joypad1_select,
495:                    func_event_joypad1_up,
496:                    func_event_joypad1_down,
497:                    func_event_joypad1_left, /* 50 */
498:                    func_event_joypad1_right,
499:                    /* joypad 2 */
500:                    func_event_joypad2_a,
501:                    func_event_joypad2_b,
502:                    func_event_joypad2_start,
503:                    func_event_joypad2_select,
504:                    func_event_joypad2_up,
505:                    func_event_joypad2_down,
506:                    func_event_joypad2_left,
507:                    func_event_joypad2_right,
508:                    /* NSF control */
509:                    NULL, /* 60 */
510:                    NULL,
511:                    NULL,
512:                    /* OS-specific */
513:                    NULL,
514:                    NULL,
515:                    NULL,
516:                    NULL,
517:                    NULL,
518:                    NULL,
519:                    NULL,
520:                    NULL, /* 70 */
521:                    NULL,
522:                    /* last */
523:                    NULL
524:                 };
525:                 
526:                 
527:                 static event_t *event_system_table[NUM_SUPPORTED_SYSTEMS] =
528:                 {
529:                    NULL, /* unknown */
530:                    NULL, /* autodetect */
531:                    nes_events, /* nes */
532:                 };
533:                 
534:                 void event_init(void)
535:                 {
9D027CD0  27BDFFE8   ADDIU SP, SP, -24
9D027CD4  AFBF0014   SW RA, 20(SP)
536:                    input_register(&kb_input);
9D027CD8  0F40CEF0   JAL input_register
9D027CDC  27848038   ADDIU A0, GP, -32712
537:                    input_register(&kb_alt_input);
9D027CE0  0F40CEF0   JAL input_register
9D027CE4  27848030   ADDIU A0, GP, -32720
538:                 }
9D027CE8  8FBF0014   LW RA, 20(SP)
9D027CEC  03E00008   JR RA
9D027CF0  27BD0018   ADDIU SP, SP, 24
539:                 
540:                 /* set up the event system for a certain console/system type */
541:                 void event_set_system(system_t type)
542:                 {
543:                    ASSERT(type < NUM_SUPPORTED_SYSTEMS);
544:                 
545:                    system_events = event_system_table[type];
9D027CF4  00042080   SLL A0, A0, 2
9D027CF8  3C029D04   LUI V0, -25340
9D027CFC  2442CC1C   ADDIU V0, V0, -13284
9D027D00  00822021   ADDU A0, A0, V0
9D027D04  8C820000   LW V0, 0(A0)
9D027D08  03E00008   JR RA
9D027D0C  AF828160   SW V0, -32416(GP)
546:                 }
547:                 
548:                 void event_set(int index, event_t handler)
549:                 {
550:                    /* now, event_set is used to set osd-specific events.  We should assume
551:                    ** (for now, at least) that these events should be used across all
552:                    ** emulated systems, so let's loop through all system event handler
553:                    ** tables and add this event...
554:                    */
555:                    int i;
556:                 
557:                    for (i = 0; i < NUM_SUPPORTED_SYSTEMS; i++)
558:                    {
559:                       if(event_system_table[i])
560:                       {
561:                          event_system_table[i][index] = handler;
9D027D10  00042080   SLL A0, A0, 2
9D027D14  3C02A001   LUI V0, -24575
9D027D18  2442A4E8   ADDIU V0, V0, -23320
9D027D1C  00441021   ADDU V0, V0, A0
9D027D20  03E00008   JR RA
9D027D24  AC450000   SW A1, 0(V0)
562:                       }
563:                    }
564:                 }
565:                 
566:                 event_t event_get(int index)
567:                 {
568:                    return system_events[index];
9D027D28  00042080   SLL A0, A0, 2
9D027D2C  8F828160   LW V0, -32416(GP)
9D027D30  00442021   ADDU A0, V0, A0
569:                 }
9D027D34  03E00008   JR RA
9D027D38  8C820000   LW V0, 0(A0)
570:                 
571:                 
572:                 /*
573:                 ** $Log: event.c,v $
574:                 ** Revision 1.3  2001/04/27 14:37:11  neil
575:                 ** wheeee
576:                 **
577:                 ** Revision 1.2  2001/04/27 11:10:08  neil
578:                 ** compile
579:                 **
580:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
581:                 ** initial
582:                 **
583:                 ** Revision 1.18  2000/11/25 20:26:05  matt
584:                 ** removed fds "system"
585:                 **
586:                 ** Revision 1.17  2000/11/09 14:05:42  matt
587:                 ** state load fixed, state save mostly fixed
588:                 **
589:                 ** Revision 1.16  2000/11/05 16:37:18  matt
590:                 ** rolled rgb.h into bitmap.h
591:                 **
592:                 ** Revision 1.15  2000/11/01 17:33:26  neil
593:                 ** little crash bugs fixed
594:                 **
595:                 ** Revision 1.14  2000/11/01 14:15:35  matt
596:                 ** multi-system event system, or whatever
597:                 **
598:                 ** Revision 1.13  2000/10/27 12:59:48  matt
599:                 ** api change for ppu palette functions
600:                 **
601:                 ** Revision 1.12  2000/10/26 22:48:05  matt
602:                 ** no need for extern
603:                 **
604:                 ** Revision 1.11  2000/10/25 00:23:16  matt
605:                 ** makefiles updated for new directory structure
606:                 **
607:                 ** Revision 1.10  2000/10/23 17:50:46  matt
608:                 ** adding fds support
609:                 **
610:                 ** Revision 1.9  2000/10/23 15:52:04  matt
611:                 ** better system handling
612:                 **
613:                 ** Revision 1.8  2000/10/22 15:01:51  matt
614:                 ** prevented palette changing in VS unisystem games
615:                 **
616:                 ** Revision 1.7  2000/10/10 13:03:54  matt
617:                 ** Mr. Clean makes a guest appearance
618:                 **
619:                 ** Revision 1.6  2000/08/16 02:58:34  matt
620:                 ** random cleanups
621:                 **
622:                 ** Revision 1.5  2000/07/27 01:15:33  matt
623:                 ** name changes
624:                 **
625:                 ** Revision 1.4  2000/07/26 21:36:13  neil
626:                 ** Big honkin' change -- see the mailing list
627:                 **
628:                 ** Revision 1.3  2000/07/23 15:17:19  matt
629:                 ** non-osd calls moved from osd.c to gui.c
630:                 **
631:                 ** Revision 1.2  2000/07/21 12:07:40  neil
632:                 ** added room in event_array for all osd events
633:                 **
634:                 ** Revision 1.1  2000/07/21 04:26:38  matt
635:                 ** initial revision
636:                 **
637:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/cpu/nes6502.c  -----------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** nes6502.c
21:                  **
22:                  ** NES custom 6502 (2A03) CPU implementation
23:                  ** $Id: nes6502.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  
27:                  #include <noftypes.h>
28:                  #include "nes6502.h"
29:                  #include "dis6502.h"
30:                  
31:                  #//define  NES6502_DISASM
32:                  
33:                  #ifdef __GNUC__
34:                  #define  NES6502_JUMPTABLE
35:                  #endif /* __GNUC__ */
36:                  
37:                  
38:                  #define  ADD_CYCLES(x) \
39:                  { \
40:                     remaining_cycles -= (x); \
41:                     cpu.total_cycles += (x); \
42:                  }
43:                  
44:                  /*
45:                  ** Check to see if an index reg addition overflowed to next page
46:                  */
47:                  #define PAGE_CROSS_CHECK(addr, reg) \
48:                  { \
49:                     if ((reg) > (uint8) (addr)) \
50:                        ADD_CYCLES(1); \
51:                  }
52:                  
53:                  #define EMPTY_READ(value)  /* empty */
54:                  
55:                  /*
56:                  ** Addressing mode macros
57:                  */
58:                  
59:                  /* Immediate */
60:                  #define IMMEDIATE_BYTE(value) \
61:                  { \
62:                     value = bank_readbyte(PC++); \
63:                  }
64:                  
65:                  /* Absolute */
66:                  #define ABSOLUTE_ADDR(address) \
67:                  { \
68:                     address = bank_readword(PC); \
69:                     PC += 2; \
70:                  }
71:                  
72:                  #define ABSOLUTE(address, value) \
73:                  { \
74:                     ABSOLUTE_ADDR(address); \
75:                     value = mem_readbyte(address); \
76:                  }
77:                  
78:                  #define ABSOLUTE_BYTE(value) \
79:                  { \
80:                     ABSOLUTE(temp, value); \
81:                  }
82:                  
83:                  /* Absolute indexed X */
84:                  #define ABS_IND_X_ADDR(address) \
85:                  { \
86:                     ABSOLUTE_ADDR(address); \
87:                     address = (address + X) & 0xFFFF; \
88:                  }
89:                  
90:                  #define ABS_IND_X(address, value) \
91:                  { \
92:                     ABS_IND_X_ADDR(address); \
93:                     value = mem_readbyte(address); \
94:                  }
95:                  
96:                  #define ABS_IND_X_BYTE(value) \
97:                  { \
98:                     ABS_IND_X(temp, value); \
99:                  }
100:                 
101:                 /* special page-cross check version for read instructions */
102:                 #define ABS_IND_X_BYTE_READ(value) \
103:                 { \
104:                    ABS_IND_X_ADDR(temp); \
105:                    PAGE_CROSS_CHECK(temp, X); \
106:                    value = mem_readbyte(temp); \
107:                 }
108:                 
109:                 /* Absolute indexed Y */
110:                 #define ABS_IND_Y_ADDR(address) \
111:                 { \
112:                    ABSOLUTE_ADDR(address); \
113:                    address = (address + Y) & 0xFFFF; \
114:                 }
115:                 
116:                 #define ABS_IND_Y(address, value) \
117:                 { \
118:                    ABS_IND_Y_ADDR(address); \
119:                    value = mem_readbyte(address); \
120:                 }
121:                 
122:                 #define ABS_IND_Y_BYTE(value) \
123:                 { \
124:                    ABS_IND_Y(temp, value); \
125:                 }
126:                 
127:                 /* special page-cross check version for read instructions */
128:                 #define ABS_IND_Y_BYTE_READ(value) \
129:                 { \
130:                    ABS_IND_Y_ADDR(temp); \
131:                    PAGE_CROSS_CHECK(temp, Y); \
132:                    value = mem_readbyte(temp); \
133:                 }
134:                 
135:                 /* Zero-page */
136:                 #define ZERO_PAGE_ADDR(address) \
137:                 { \
138:                    IMMEDIATE_BYTE(address); \
139:                 }
140:                 
141:                 #define ZERO_PAGE(address, value) \
142:                 { \
143:                    ZERO_PAGE_ADDR(address); \
144:                    value = ZP_READBYTE(address); \
145:                 }
146:                 
147:                 #define ZERO_PAGE_BYTE(value) \
148:                 { \
149:                    ZERO_PAGE(btemp, value); \
150:                 }
151:                 
152:                 /* Zero-page indexed X */
153:                 #define ZP_IND_X_ADDR(address) \
154:                 { \
155:                    ZERO_PAGE_ADDR(address); \
156:                    address += X; \
157:                 }
158:                 
159:                 #define ZP_IND_X(address, value) \
160:                 { \
161:                    ZP_IND_X_ADDR(address); \
162:                    value = ZP_READBYTE(address); \
163:                 }
164:                 
165:                 #define ZP_IND_X_BYTE(value) \
166:                 { \
167:                    ZP_IND_X(btemp, value); \
168:                 }
169:                 
170:                 /* Zero-page indexed Y */
171:                 /* Not really an adressing mode, just for LDx/STx */
172:                 #define ZP_IND_Y_ADDR(address) \
173:                 { \
174:                    ZERO_PAGE_ADDR(address); \
175:                    address += Y; \
176:                 }
177:                 
178:                 #define ZP_IND_Y_BYTE(value) \
179:                 { \
180:                    ZP_IND_Y_ADDR(btemp); \
181:                    value = ZP_READBYTE(btemp); \
182:                 }  
183:                 
184:                 /* Indexed indirect */
185:                 #define INDIR_X_ADDR(address) \
186:                 { \
187:                    ZERO_PAGE_ADDR(btemp); \
188:                    btemp += X; \
189:                    address = zp_readword(btemp); \
190:                 }
191:                 
192:                 #define INDIR_X(address, value) \
193:                 { \
194:                    INDIR_X_ADDR(address); \
195:                    value = mem_readbyte(address); \
196:                 } 
197:                 
198:                 #define INDIR_X_BYTE(value) \
199:                 { \
200:                    INDIR_X(temp, value); \
201:                 }
202:                 
203:                 /* Indirect indexed */
204:                 #define INDIR_Y_ADDR(address) \
205:                 { \
206:                    ZERO_PAGE_ADDR(btemp); \
207:                    address = (zp_readword(btemp) + Y) & 0xFFFF; \
208:                 }
209:                 
210:                 #define INDIR_Y(address, value) \
211:                 { \
212:                    INDIR_Y_ADDR(address); \
213:                    value = mem_readbyte(address); \
214:                 } 
215:                 
216:                 #define INDIR_Y_BYTE(value) \
217:                 { \
218:                    INDIR_Y(temp, value); \
219:                 }
220:                 
221:                 /* special page-cross check version for read instructions */
222:                 #define INDIR_Y_BYTE_READ(value) \
223:                 { \
224:                    INDIR_Y_ADDR(temp); \
225:                    PAGE_CROSS_CHECK(temp, Y); \
226:                    value = mem_readbyte(temp); \
227:                 }
228:                 
229:                 
230:                 
231:                 /* Stack push/pull */
232:                 #define  PUSH(value)             stack[S--] = (uint8) (value)
233:                 #define  PULL()                  stack[++S]
234:                 
235:                 
236:                 /*
237:                 ** flag register helper macros
238:                 */
239:                 
240:                 /* Theory: Z and N flags are set in just about every
241:                 ** instruction, so we will just store the value in those
242:                 ** flag variables, and mask out the irrelevant data when
243:                 ** we need to check them (branches, etc).  This makes the
244:                 ** zero flag only really be 'set' when z_flag == 0.
245:                 ** The rest of the flags are stored as true booleans.
246:                 */
247:                 
248:                 /* Scatter flags to separate variables */
249:                 #define  SCATTER_FLAGS(value) \
250:                 { \
251:                    n_flag = (value) & N_FLAG; \
252:                    v_flag = (value) & V_FLAG; \
253:                    b_flag = (value) & B_FLAG; \
254:                    d_flag = (value) & D_FLAG; \
255:                    i_flag = (value) & I_FLAG; \
256:                    z_flag = (0 == ((value) & Z_FLAG)); \
257:                    c_flag = (value) & C_FLAG; \
258:                 }
259:                 
260:                 /* Combine flags into flag register */
261:                 #define  COMBINE_FLAGS() \
262:                 ( \
263:                    (n_flag & N_FLAG) \
264:                    | (v_flag ? V_FLAG : 0) \
265:                    | R_FLAG \
266:                    | (b_flag ? B_FLAG : 0) \
267:                    | (d_flag ? D_FLAG : 0) \
268:                    | (i_flag ? I_FLAG : 0) \
269:                    | (z_flag ? 0 : Z_FLAG) \
270:                    | c_flag \
271:                 )
272:                 
273:                 /* Set N and Z flags based on given value */
274:                 #define  SET_NZ_FLAGS(value)     n_flag = z_flag = (value);
275:                 
276:                 /* For BCC, BCS, BEQ, BMI, BNE, BPL, BVC, BVS */
277:                 #define RELATIVE_BRANCH(condition) \
278:                 { \
279:                    if (condition) \
280:                    { \
281:                       IMMEDIATE_BYTE(btemp); \
282:                       if (((int8) btemp + (PC & 0x00FF)) & 0x100) \
283:                          ADD_CYCLES(1); \
284:                       ADD_CYCLES(3); \
285:                       PC += (int8) btemp; \
286:                    } \
287:                    else \
288:                    { \
289:                       PC++; \
290:                       ADD_CYCLES(2); \
291:                    } \
292:                 }
293:                 
294:                 #define JUMP(address) \
295:                 { \
296:                    PC = bank_readword((address)); \
297:                 }
298:                 
299:                 /*
300:                 ** Interrupt macros
301:                 */
302:                 #define NMI_PROC() \
303:                 { \
304:                    PUSH(PC >> 8); \
305:                    PUSH(PC & 0xFF); \
306:                    b_flag = 0; \
307:                    PUSH(COMBINE_FLAGS()); \
308:                    i_flag = 1; \
309:                    JUMP(NMI_VECTOR); \
310:                 }
311:                 
312:                 #define IRQ_PROC() \
313:                 { \
314:                    PUSH(PC >> 8); \
315:                    PUSH(PC & 0xFF); \
316:                    b_flag = 0; \
317:                    PUSH(COMBINE_FLAGS()); \
318:                    i_flag = 1; \
319:                    JUMP(IRQ_VECTOR); \
320:                 }
321:                 
322:                 /*
323:                 ** Instruction macros
324:                 */
325:                 
326:                 /* Warning! NES CPU has no decimal mode, so by default this does no BCD! */
327:                 #ifdef NES6502_DECIMAL
328:                 #define ADC(cycles, read_func) \
329:                 { \
330:                    read_func(data); \
331:                    if (d_flag) \
332:                    { \
333:                       temp = (A & 0x0F) + (data & 0x0F) + c_flag; \
334:                       if (temp >= 10) \
335:                          temp = (temp - 10) | 0x10; \
336:                       temp += (A & 0xF0) + (data & 0xF0); \
337:                       z_flag = (A + data + c_flag) & 0xFF; \
338:                       n_flag = temp; \
339:                       v_flag = ((~(A ^ data)) & (A ^ temp) & 0x80); \
340:                       if (temp > 0x90) \
341:                       { \
342:                          temp += 0x60; \
343:                          c_flag = 1; \
344:                       } \
345:                       else \
346:                       { \
347:                          c_flag = 0; \
348:                       } \
349:                       A = (uint8) temp; \
350:                    } \
351:                    else \
352:                    { \
353:                       temp = A + data + c_flag; \
354:                       c_flag = (temp >> 8) & 1; \
355:                       v_flag = ((~(A ^ data)) & (A ^ temp) & 0x80); \
356:                       A = (uint8) temp; \
357:                       SET_NZ_FLAGS(A); \
358:                    }\
359:                    ADD_CYCLES(cycles); \
360:                 }
361:                 #else
362:                 #define ADC(cycles, read_func) \
363:                 { \
364:                    read_func(data); \
365:                    temp = A + data + c_flag; \
366:                    c_flag = (temp >> 8) & 1; \
367:                    v_flag = ((~(A ^ data)) & (A ^ temp) & 0x80); \
368:                    A = (uint8) temp; \
369:                    SET_NZ_FLAGS(A); \
370:                    ADD_CYCLES(cycles); \
371:                 }
372:                 #endif /* NES6502_DECIMAL */
373:                 
374:                 /* undocumented */
375:                 #define ANC(cycles, read_func) \
376:                 { \
377:                    read_func(data); \
378:                    A &= data; \
379:                    c_flag = (n_flag & N_FLAG) >> 7; \
380:                    SET_NZ_FLAGS(A); \
381:                    ADD_CYCLES(cycles); \
382:                 }
383:                 
384:                 #define AND(cycles, read_func) \
385:                 { \
386:                    read_func(data); \
387:                    A &= data; \
388:                    SET_NZ_FLAGS(A); \
389:                    ADD_CYCLES(cycles); \
390:                 }
391:                 
392:                 /* undocumented */
393:                 #define ANE(cycles, read_func) \
394:                 { \
395:                    read_func(data); \
396:                    A = (A | 0xEE) & X & data; \
397:                    SET_NZ_FLAGS(A); \
398:                    ADD_CYCLES(cycles); \
399:                 }
400:                 
401:                 /* undocumented */
402:                 #ifdef NES6502_DECIMAL
403:                 #define ARR(cycles, read_func) \
404:                 { \
405:                    read_func(data); \
406:                    data &= A; \
407:                    if (d_flag) \
408:                    { \
409:                       temp = (data >> 1) | (c_flag << 7); \
410:                       SET_NZ_FLAGS(temp); \
411:                       v_flag = (temp ^ data) & 0x40; \
412:                       if (((data & 0x0F) + (data & 0x01)) > 5) \
413:                          temp = (temp & 0xF0) | ((temp + 0x6) & 0x0F); \
414:                       if (((data & 0xF0) + (data & 0x10)) > 0x50) \
415:                       { \
416:                          temp = (temp & 0x0F) | ((temp + 0x60) & 0xF0); \
417:                          c_flag = 1; \
418:                       } \
419:                       else \
420:                       { \
421:                          c_flag = 0; \
422:                       } \
423:                       A = (uint8) temp; \
424:                    } \
425:                    else \
426:                    { \
427:                       A = (data >> 1) | (c_flag << 7); \
428:                       SET_NZ_FLAGS(A); \
429:                       c_flag = (A & 0x40) >> 6; \
430:                       v_flag = ((A >> 6) ^ (A >> 5)) & 1; \
431:                    }\
432:                    ADD_CYCLES(cycles); \
433:                 }
434:                 #else
435:                 #define ARR(cycles, read_func) \
436:                 { \
437:                    read_func(data); \
438:                    data &= A; \
439:                    A = (data >> 1) | (c_flag << 7); \
440:                    SET_NZ_FLAGS(A); \
441:                    c_flag = (A & 0x40) >> 6; \
442:                    v_flag = ((A >> 6) ^ (A >> 5)) & 1; \
443:                    ADD_CYCLES(cycles); \
444:                 }
445:                 #endif /* NES6502_DECIMAL */
446:                 
447:                 #define ASL(cycles, read_func, write_func, addr) \
448:                 { \
449:                    read_func(addr, data); \
450:                    c_flag = data >> 7; \
451:                    data <<= 1; \
452:                    write_func(addr, data); \
453:                    SET_NZ_FLAGS(data); \
454:                    ADD_CYCLES(cycles); \
455:                 }
456:                 
457:                 #define ASL_A() \
458:                 { \
459:                    c_flag = A >> 7; \
460:                    A <<= 1; \
461:                    SET_NZ_FLAGS(A); \
462:                    ADD_CYCLES(2); \
463:                 }
464:                 
465:                 /* undocumented */
466:                 #define ASR(cycles, read_func) \
467:                 { \
468:                    read_func(data); \
469:                    data &= A; \
470:                    c_flag = data & 1; \
471:                    A = data >> 1; \
472:                    SET_NZ_FLAGS(A); \
473:                    ADD_CYCLES(cycles); \
474:                 }
475:                 
476:                 #define BCC() \
477:                 { \
478:                    RELATIVE_BRANCH(0 == c_flag); \
479:                 }
480:                 
481:                 #define BCS() \
482:                 { \
483:                    RELATIVE_BRANCH(0 != c_flag); \
484:                 }
485:                 
486:                 #define BEQ() \
487:                 { \
488:                    RELATIVE_BRANCH(0 == z_flag); \
489:                 }
490:                 
491:                 /* bit 7/6 of data move into N/V flags */
492:                 #define BIT(cycles, read_func) \
493:                 { \
494:                    read_func(data); \
495:                    n_flag = data; \
496:                    v_flag = data & V_FLAG; \
497:                    z_flag = data & A; \
498:                    ADD_CYCLES(cycles); \
499:                 }
500:                 
501:                 #define BMI() \
502:                 { \
503:                    RELATIVE_BRANCH(n_flag & N_FLAG); \
504:                 }
505:                 
506:                 #define BNE() \
507:                 { \
508:                    RELATIVE_BRANCH(0 != z_flag); \
509:                 }
510:                 
511:                 #define BPL() \
512:                 { \
513:                    RELATIVE_BRANCH(0 == (n_flag & N_FLAG)); \
514:                 }
515:                 
516:                 /* Software interrupt type thang */
517:                 #define BRK() \
518:                 { \
519:                    PC++; \
520:                    PUSH(PC >> 8); \
521:                    PUSH(PC & 0xFF); \
522:                    b_flag = 1; \
523:                    PUSH(COMBINE_FLAGS()); \
524:                    i_flag = 1; \
525:                    JUMP(IRQ_VECTOR); \
526:                    ADD_CYCLES(7); \
527:                 }
528:                 
529:                 #define BVC() \
530:                 { \
531:                    RELATIVE_BRANCH(0 == v_flag); \
532:                 }
533:                 
534:                 #define BVS() \
535:                 { \
536:                    RELATIVE_BRANCH(0 != v_flag); \
537:                 }
538:                 
539:                 #define CLC() \
540:                 { \
541:                    c_flag = 0; \
542:                    ADD_CYCLES(2); \
543:                 }
544:                 
545:                 #define CLD() \
546:                 { \
547:                    d_flag = 0; \
548:                    ADD_CYCLES(2); \
549:                 }
550:                 
551:                 #define CLI() \
552:                 { \
553:                    i_flag = 0; \
554:                    ADD_CYCLES(2); \
555:                    if (cpu.int_pending && remaining_cycles > 0) \
556:                    { \
557:                       cpu.int_pending = 0; \
558:                       IRQ_PROC(); \
559:                       ADD_CYCLES(INT_CYCLES); \
560:                    } \
561:                 }
562:                 
563:                 #define CLV() \
564:                 { \
565:                    v_flag = 0; \
566:                    ADD_CYCLES(2); \
567:                 }
568:                 
569:                 /* C is clear when data > A */ 
570:                 #define _COMPARE(reg, value) \
571:                 { \
572:                    temp = (reg) - (value); \
573:                    c_flag = ((temp & 0x100) >> 8) ^ 1; \
574:                    SET_NZ_FLAGS((uint8) temp); \
575:                 }
576:                 
577:                 #define CMP(cycles, read_func) \
578:                 { \
579:                    read_func(data); \
580:                    _COMPARE(A, data); \
581:                    ADD_CYCLES(cycles); \
582:                 }
583:                 
584:                 #define CPX(cycles, read_func) \
585:                 { \
586:                    read_func(data); \
587:                    _COMPARE(X, data); \
588:                    ADD_CYCLES(cycles); \
589:                 }
590:                 
591:                 #define CPY(cycles, read_func) \
592:                 { \
593:                    read_func(data); \
594:                    _COMPARE(Y, data); \
595:                    ADD_CYCLES(cycles); \
596:                 }
597:                 
598:                 /* undocumented */
599:                 #define DCP(cycles, read_func, write_func, addr) \
600:                 { \
601:                    read_func(addr, data); \
602:                    data--; \
603:                    write_func(addr, data); \
604:                    CMP(cycles, EMPTY_READ); \
605:                 }
606:                 
607:                 #define DEC(cycles, read_func, write_func, addr) \
608:                 { \
609:                    read_func(addr, data); \
610:                    data--; \
611:                    write_func(addr, data); \
612:                    SET_NZ_FLAGS(data); \
613:                    ADD_CYCLES(cycles); \
614:                 }
615:                 
616:                 #define DEX() \
617:                 { \
618:                    X--; \
619:                    SET_NZ_FLAGS(X); \
620:                    ADD_CYCLES(2); \
621:                 }
622:                 
623:                 #define DEY() \
624:                 { \
625:                    Y--; \
626:                    SET_NZ_FLAGS(Y); \
627:                    ADD_CYCLES(2); \
628:                 }
629:                 
630:                 /* undocumented (double-NOP) */
631:                 #define DOP(cycles) \
632:                 { \
633:                    PC++; \
634:                    ADD_CYCLES(cycles); \
635:                 }
636:                 
637:                 #define EOR(cycles, read_func) \
638:                 { \
639:                    read_func(data); \
640:                    A ^= data; \
641:                    SET_NZ_FLAGS(A); \
642:                    ADD_CYCLES(cycles); \
643:                 }
644:                 
645:                 #define INC(cycles, read_func, write_func, addr) \
646:                 { \
647:                    read_func(addr, data); \
648:                    data++; \
649:                    write_func(addr, data); \
650:                    SET_NZ_FLAGS(data); \
651:                    ADD_CYCLES(cycles); \
652:                 }
653:                 
654:                 #define INX() \
655:                 { \
656:                    X++; \
657:                    SET_NZ_FLAGS(X); \
658:                    ADD_CYCLES(2); \
659:                 }
660:                 
661:                 #define INY() \
662:                 { \
663:                    Y++; \
664:                    SET_NZ_FLAGS(Y); \
665:                    ADD_CYCLES(2); \
666:                 }
667:                 
668:                 /* undocumented */
669:                 #define ISB(cycles, read_func, write_func, addr) \
670:                 { \
671:                    read_func(addr, data); \
672:                    data++; \
673:                    write_func(addr, data); \
674:                    SBC(cycles, EMPTY_READ); \
675:                 }
676:                 
677:                 /* TODO: make this a function callback */
678:                 #ifdef NES6502_TESTOPS
679:                 #define JAM() \
680:                 { \
681:                    cpu_Jam(); \
682:                 }
683:                 #else /* !NES6502_TESTOPS */
684:                 #define JAM() \
685:                 { \
686:                    PC--; \
687:                    cpu.jammed = true; \
688:                    cpu.int_pending = 0; \
689:                    ADD_CYCLES(2); \
690:                 }
691:                 #endif /* !NES6502_TESTOPS */
692:                 
693:                 #define JMP_INDIRECT() \
694:                 { \
695:                    temp = bank_readword(PC); \
696:                    /* bug in crossing page boundaries */ \
697:                    if (0xFF == (temp & 0xFF)) \
698:                       PC = (bank_readbyte(temp & 0xFF00) << 8) | bank_readbyte(temp); \
699:                    else \
700:                       JUMP(temp); \
701:                    ADD_CYCLES(5); \
702:                 }
703:                 
704:                 #define JMP_ABSOLUTE() \
705:                 { \
706:                    JUMP(PC); \
707:                    ADD_CYCLES(3); \
708:                 }
709:                 
710:                 #define JSR() \
711:                 { \
712:                    PC++; \
713:                    PUSH(PC >> 8); \
714:                    PUSH(PC & 0xFF); \
715:                    JUMP(PC - 1); \
716:                    ADD_CYCLES(6); \
717:                 }
718:                 
719:                 /* undocumented */
720:                 #define LAS(cycles, read_func) \
721:                 { \
722:                    read_func(data); \
723:                    A = X = S = (S & data); \
724:                    SET_NZ_FLAGS(A); \
725:                    ADD_CYCLES(cycles); \
726:                 }
727:                 
728:                 /* undocumented */
729:                 #define LAX(cycles, read_func) \
730:                 { \
731:                    read_func(A); \
732:                    X = A; \
733:                    SET_NZ_FLAGS(A); \
734:                    ADD_CYCLES(cycles); \
735:                 }
736:                 
737:                 #define LDA(cycles, read_func) \
738:                 { \
739:                    read_func(A); \
740:                    SET_NZ_FLAGS(A); \
741:                    ADD_CYCLES(cycles); \
742:                 }
743:                 
744:                 #define LDX(cycles, read_func) \
745:                 { \
746:                    read_func(X); \
747:                    SET_NZ_FLAGS(X);\
748:                    ADD_CYCLES(cycles); \
749:                 }
750:                 
751:                 #define LDY(cycles, read_func) \
752:                 { \
753:                    read_func(Y); \
754:                    SET_NZ_FLAGS(Y);\
755:                    ADD_CYCLES(cycles); \
756:                 }
757:                 
758:                 #define LSR(cycles, read_func, write_func, addr) \
759:                 { \
760:                    read_func(addr, data); \
761:                    c_flag = data & 1; \
762:                    data >>= 1; \
763:                    write_func(addr, data); \
764:                    SET_NZ_FLAGS(data); \
765:                    ADD_CYCLES(cycles); \
766:                 }
767:                 
768:                 #define LSR_A() \
769:                 { \
770:                    c_flag = A & 1; \
771:                    A >>= 1; \
772:                    SET_NZ_FLAGS(A); \
773:                    ADD_CYCLES(2); \
774:                 }
775:                 
776:                 /* undocumented */
777:                 #define LXA(cycles, read_func) \
778:                 { \
779:                    read_func(data); \
780:                    A = X = ((A | 0xEE) & data); \
781:                    SET_NZ_FLAGS(A); \
782:                    ADD_CYCLES(cycles); \
783:                 }
784:                 
785:                 #define NOP() \
786:                 { \
787:                    ADD_CYCLES(2); \
788:                 }
789:                 
790:                 #define ORA(cycles, read_func) \
791:                 { \
792:                    read_func(data); \
793:                    A |= data; \
794:                    SET_NZ_FLAGS(A);\
795:                    ADD_CYCLES(cycles); \
796:                 }
797:                 
798:                 #define PHA() \
799:                 { \
800:                    PUSH(A); \
801:                    ADD_CYCLES(3); \
802:                 }
803:                 
804:                 #define PHP() \
805:                 { \
806:                    /* B flag is pushed on stack as well */ \
807:                    PUSH(COMBINE_FLAGS() | B_FLAG); \
808:                    ADD_CYCLES(3); \
809:                 }
810:                 
811:                 #define PLA() \
812:                 { \
813:                    A = PULL(); \
814:                    SET_NZ_FLAGS(A); \
815:                    ADD_CYCLES(4); \
816:                 }
817:                 
818:                 #define PLP() \
819:                 { \
820:                    btemp = PULL(); \
821:                    SCATTER_FLAGS(btemp); \
822:                    ADD_CYCLES(4); \
823:                 }
824:                 
825:                 /* undocumented */
826:                 #define RLA(cycles, read_func, write_func, addr) \
827:                 { \
828:                    read_func(addr, data); \
829:                    btemp = c_flag; \
830:                    c_flag = data >> 7; \
831:                    data = (data << 1) | btemp; \
832:                    write_func(addr, data); \
833:                    A &= data; \
834:                    SET_NZ_FLAGS(A); \
835:                    ADD_CYCLES(cycles); \
836:                 }
837:                 
838:                 /* 9-bit rotation (carry flag used for rollover) */
839:                 #define ROL(cycles, read_func, write_func, addr) \
840:                 { \
841:                    read_func(addr, data); \
842:                    btemp = c_flag; \
843:                    c_flag = data >> 7; \
844:                    data = (data << 1) | btemp; \
845:                    write_func(addr, data); \
846:                    SET_NZ_FLAGS(data); \
847:                    ADD_CYCLES(cycles); \
848:                 }
849:                 
850:                 #define ROL_A() \
851:                 { \
852:                    btemp = c_flag; \
853:                    c_flag = A >> 7; \
854:                    A = (A << 1) | btemp; \
855:                    SET_NZ_FLAGS(A); \
856:                    ADD_CYCLES(2); \
857:                 }
858:                 
859:                 #define ROR(cycles, read_func, write_func, addr) \
860:                 { \
861:                    read_func(addr, data); \
862:                    btemp = c_flag << 7; \
863:                    c_flag = data & 1; \
864:                    data = (data >> 1) | btemp; \
865:                    write_func(addr, data); \
866:                    SET_NZ_FLAGS(data); \
867:                    ADD_CYCLES(cycles); \
868:                 }
869:                 
870:                 #define ROR_A() \
871:                 { \
872:                    btemp = c_flag << 7; \
873:                    c_flag = A & 1; \
874:                    A = (A >> 1) | btemp; \
875:                    SET_NZ_FLAGS(A); \
876:                    ADD_CYCLES(2); \
877:                 }
878:                 
879:                 /* undocumented */
880:                 #define RRA(cycles, read_func, write_func, addr) \
881:                 { \
882:                    read_func(addr, data); \
883:                    btemp = c_flag << 7; \
884:                    c_flag = data & 1; \
885:                    data = (data >> 1) | btemp; \
886:                    write_func(addr, data); \
887:                    ADC(cycles, EMPTY_READ); \
888:                 }
889:                 
890:                 #define RTI() \
891:                 { \
892:                    btemp = PULL(); \
893:                    SCATTER_FLAGS(btemp); \
894:                    PC = PULL(); \
895:                    PC |= PULL() << 8; \
896:                    ADD_CYCLES(6); \
897:                    if (0 == i_flag && cpu.int_pending && remaining_cycles > 0) \
898:                    { \
899:                       cpu.int_pending = 0; \
900:                       IRQ_PROC(); \
901:                       ADD_CYCLES(INT_CYCLES); \
902:                    } \
903:                 }
904:                 
905:                 #define RTS() \
906:                 { \
907:                    PC = PULL(); \
908:                    PC = (PC | (PULL() << 8)) + 1; \
909:                    ADD_CYCLES(6); \
910:                 }
911:                 
912:                 /* undocumented */
913:                 #define SAX(cycles, read_func, write_func, addr) \
914:                 { \
915:                    read_func(addr); \
916:                    data = A & X; \
917:                    write_func(addr, data); \
918:                    ADD_CYCLES(cycles); \
919:                 }
920:                 
921:                 /* Warning! NES CPU has no decimal mode, so by default this does no BCD! */
922:                 #ifdef NES6502_DECIMAL
923:                 #define SBC(cycles, read_func) \
924:                 { \
925:                    read_func(data); \
926:                    temp = A - data - (c_flag ^ 1); \
927:                    if (d_flag) \
928:                    { \
929:                       uint8 al, ah; \
930:                       al = (A & 0x0F) - (data & 0x0F) - (c_flag ^ 1); \
931:                       ah = (A >> 4) - (data >> 4); \
932:                       if (al & 0x10) \
933:                       { \
934:                          al -= 6; \
935:                          ah--; \
936:                       } \
937:                       if (ah & 0x10) \
938:                       { \
939:                          ah -= 6; \
940:                          c_flag = 0; \
941:                       } \
942:                       else \
943:                       { \
944:                          c_flag = 1; \
945:                       } \
946:                       v_flag = (A ^ temp) & (A ^ data) & 0x80; \
947:                       SET_NZ_FLAGS(temp & 0xFF); \
948:                       A = (ah << 4) | (al & 0x0F); \
949:                    } \
950:                    else \
951:                    { \
952:                       v_flag = (A ^ temp) & (A ^ data) & 0x80; \
953:                       c_flag = ((temp & 0x100) >> 8) ^ 1; \
954:                       A = (uint8) temp; \
955:                       SET_NZ_FLAGS(A & 0xFF); \
956:                    } \
957:                    ADD_CYCLES(cycles); \
958:                 }
959:                 #else
960:                 #define SBC(cycles, read_func) \
961:                 { \
962:                    read_func(data); \
963:                    temp = A - data - (c_flag ^ 1); \
964:                    v_flag = (A ^ data) & (A ^ temp) & 0x80; \
965:                    c_flag = ((temp >> 8) & 1) ^ 1; \
966:                    A = (uint8) temp; \
967:                    SET_NZ_FLAGS(A); \
968:                    ADD_CYCLES(cycles); \
969:                 }
970:                 #endif /* NES6502_DECIMAL */
971:                 
972:                 /* undocumented */
973:                 #define SBX(cycles, read_func) \
974:                 { \
975:                    read_func(data); \
976:                    temp = (A & X) - data; \
977:                    c_flag = ((temp >> 8) & 1) ^ 1; \
978:                    X = temp & 0xFF; \
979:                    SET_NZ_FLAGS(X); \
980:                    ADD_CYCLES(cycles); \
981:                 }
982:                 
983:                 #define SEC() \
984:                 { \
985:                    c_flag = 1; \
986:                    ADD_CYCLES(2); \
987:                 }
988:                 
989:                 #define SED() \
990:                 { \
991:                    d_flag = 1; \
992:                    ADD_CYCLES(2); \
993:                 }
994:                 
995:                 #define SEI() \
996:                 { \
997:                    i_flag = 1; \
998:                    ADD_CYCLES(2); \
999:                 }
1000:                
1001:                /* undocumented */
1002:                #define SHA(cycles, read_func, write_func, addr) \
1003:                { \
1004:                   read_func(addr); \
1005:                   data = A & X & ((uint8) ((addr >> 8) + 1)); \
1006:                   write_func(addr, data); \
1007:                   ADD_CYCLES(cycles); \
1008:                }
1009:                
1010:                /* undocumented */
1011:                #define SHS(cycles, read_func, write_func, addr) \
1012:                { \
1013:                   read_func(addr); \
1014:                   S = A & X; \
1015:                   data = S & ((uint8) ((addr >> 8) + 1)); \
1016:                   write_func(addr, data); \
1017:                   ADD_CYCLES(cycles); \
1018:                }
1019:                
1020:                /* undocumented */
1021:                #define SHX(cycles, read_func, write_func, addr) \
1022:                { \
1023:                   read_func(addr); \
1024:                   data = X & ((uint8) ((addr >> 8) + 1)); \
1025:                   write_func(addr, data); \
1026:                   ADD_CYCLES(cycles); \
1027:                }
1028:                
1029:                /* undocumented */
1030:                #define SHY(cycles, read_func, write_func, addr) \
1031:                { \
1032:                   read_func(addr); \
1033:                   data = Y & ((uint8) ((addr >> 8 ) + 1)); \
1034:                   write_func(addr, data); \
1035:                   ADD_CYCLES(cycles); \
1036:                }
1037:                
1038:                /* undocumented */
1039:                #define SLO(cycles, read_func, write_func, addr) \
1040:                { \
1041:                   read_func(addr, data); \
1042:                   c_flag = data >> 7; \
1043:                   data <<= 1; \
1044:                   write_func(addr, data); \
1045:                   A |= data; \
1046:                   SET_NZ_FLAGS(A); \
1047:                   ADD_CYCLES(cycles); \
1048:                }
1049:                
1050:                /* undocumented */
1051:                #define SRE(cycles, read_func, write_func, addr) \
1052:                { \
1053:                   read_func(addr, data); \
1054:                   c_flag = data & 1; \
1055:                   data >>= 1; \
1056:                   write_func(addr, data); \
1057:                   A ^= data; \
1058:                   SET_NZ_FLAGS(A); \
1059:                   ADD_CYCLES(cycles); \
1060:                }
1061:                
1062:                #define STA(cycles, read_func, write_func, addr) \
1063:                { \
1064:                   read_func(addr); \
1065:                   write_func(addr, A); \
1066:                   ADD_CYCLES(cycles); \
1067:                }
1068:                
1069:                #define STX(cycles, read_func, write_func, addr) \
1070:                { \
1071:                   read_func(addr); \
1072:                   write_func(addr, X); \
1073:                   ADD_CYCLES(cycles); \
1074:                }
1075:                
1076:                #define STY(cycles, read_func, write_func, addr) \
1077:                { \
1078:                   read_func(addr); \
1079:                   write_func(addr, Y); \
1080:                   ADD_CYCLES(cycles); \
1081:                }
1082:                
1083:                #define TAX() \
1084:                { \
1085:                   X = A; \
1086:                   SET_NZ_FLAGS(X);\
1087:                   ADD_CYCLES(2); \
1088:                }
1089:                
1090:                #define TAY() \
1091:                { \
1092:                   Y = A; \
1093:                   SET_NZ_FLAGS(Y);\
1094:                   ADD_CYCLES(2); \
1095:                }
1096:                
1097:                /* undocumented (triple-NOP) */
1098:                #define TOP() \
1099:                { \
1100:                   PC += 2; \
1101:                   ADD_CYCLES(4); \
1102:                }
1103:                
1104:                #define TSX() \
1105:                { \
1106:                   X = S; \
1107:                   SET_NZ_FLAGS(X);\
1108:                   ADD_CYCLES(2); \
1109:                }
1110:                
1111:                #define TXA() \
1112:                { \
1113:                   A = X; \
1114:                   SET_NZ_FLAGS(A);\
1115:                   ADD_CYCLES(2); \
1116:                }
1117:                
1118:                #define TXS() \
1119:                { \
1120:                   S = X; \
1121:                   ADD_CYCLES(2); \
1122:                }
1123:                
1124:                #define TYA() \
1125:                { \
1126:                   A = Y; \
1127:                   SET_NZ_FLAGS(A); \
1128:                   ADD_CYCLES(2); \
1129:                }
1130:                
1131:                
1132:                
1133:                /* internal CPU context */
1134:                static nes6502_context cpu;
1135:                static int remaining_cycles = 0; /* so we can release timeslice */
1136:                /* memory region pointers */
1137:                static uint8 *ram = NULL, *stack = NULL;
1138:                static uint8 null_page[NES6502_BANKSIZE];
1139:                
1140:                
1141:                /*
1142:                ** Zero-page helper macros
1143:                */
1144:                
1145:                #define  ZP_READBYTE(addr)          ram[(addr)]
1146:                #define  ZP_WRITEBYTE(addr, value)  ram[(addr)] = (uint8) (value)
1147:                
1148:                #ifdef HOST_LITTLE_ENDIAN
1149:                
1150:                /* NOTE: following two functions will fail on architectures
1151:                ** which do not support byte alignment
1152:                */
1153:                INLINE uint32 zp_readword(register uint8 address)
1154:                {
1155:                    return (uint32) (ram[address]) | (ram[(address+1)]);
9D00068C  304200FF   ANDI V0, V0, 255
9D0007B4  304200FF   ANDI V0, V0, 255
9D0007B8  8F838054   LW V1, -32684(GP)
9D0007BC  00621021   ADDU V0, V1, V0
9D0007C0  90550001   LBU S5, 1(V0)
9D0007C4  90420000   LBU V0, 0(V0)
9D0007C8  02A2A825   OR S5, S5, V0
9D0007CC  32B500FF   ANDI S5, S5, 255
9D001040  90420000   LBU V0, 0(V0)
9D001044  8F838054   LW V1, -32684(GP)
9D001048  00621021   ADDU V0, V1, V0
9D00104C  90440001   LBU A0, 1(V0)
9D001050  90420000   LBU V0, 0(V0)
9D001054  00822025   OR A0, A0, V0
9D001058  308400FF   ANDI A0, A0, 255
9D00111C  90420000   LBU V0, 0(V0)
9D001120  8F838054   LW V1, -32684(GP)
9D001124  00621021   ADDU V0, V1, V0
9D001128  90550001   LBU S5, 1(V0)
9D00112C  90420000   LBU V0, 0(V0)
9D001130  02A2A825   OR S5, S5, V0
9D001134  32B500FF   ANDI S5, S5, 255
9D001A80  304200FF   ANDI V0, V0, 255
9D001A84  8F838054   LW V1, -32684(GP)
9D001A88  00621021   ADDU V0, V1, V0
9D001A8C  90440001   LBU A0, 1(V0)
9D001A90  90420000   LBU V0, 0(V0)
9D001A94  00822025   OR A0, A0, V0
9D001B2C  304200FF   ANDI V0, V0, 255
9D001B30  8F838054   LW V1, -32684(GP)
9D001B34  00621021   ADDU V0, V1, V0
9D001B38  90550001   LBU S5, 1(V0)
9D001B3C  90420000   LBU V0, 0(V0)
9D001B40  02A2A825   OR S5, S5, V0
9D001B44  32B500FF   ANDI S5, S5, 255
9D002468  90420000   LBU V0, 0(V0)
9D00246C  8F838054   LW V1, -32684(GP)
9D002470  00621021   ADDU V0, V1, V0
9D002474  90440001   LBU A0, 1(V0)
9D002478  90420000   LBU V0, 0(V0)
9D00247C  00822025   OR A0, A0, V0
9D002480  308400FF   ANDI A0, A0, 255
9D002544  90420000   LBU V0, 0(V0)
9D002548  8F838054   LW V1, -32684(GP)
9D00254C  00621021   ADDU V0, V1, V0
9D002550  90550001   LBU S5, 1(V0)
9D002554  90420000   LBU V0, 0(V0)
9D002558  02A2A825   OR S5, S5, V0
9D00255C  32B500FF   ANDI S5, S5, 255
9D002E58  304200FF   ANDI V0, V0, 255
9D002E5C  8F838054   LW V1, -32684(GP)
9D002E60  00621021   ADDU V0, V1, V0
9D002E64  90440001   LBU A0, 1(V0)
9D002E68  90420000   LBU V0, 0(V0)
9D002E6C  00822025   OR A0, A0, V0
9D002F04  304200FF   ANDI V0, V0, 255
9D002F08  8F838054   LW V1, -32684(GP)
9D002F0C  00621021   ADDU V0, V1, V0
9D002F10  90550001   LBU S5, 1(V0)
9D002F14  90420000   LBU V0, 0(V0)
9D002F18  02A2A825   OR S5, S5, V0
9D002F1C  32B500FF   ANDI S5, S5, 255
9D0036F8  90420000   LBU V0, 0(V0)
9D0036FC  8F838054   LW V1, -32684(GP)
9D003700  00621021   ADDU V0, V1, V0
9D003704  90440001   LBU A0, 1(V0)
9D003708  90420000   LBU V0, 0(V0)
9D00370C  00822025   OR A0, A0, V0
9D003710  308400FF   ANDI A0, A0, 255
9D0037D4  90420000   LBU V0, 0(V0)
9D0037D8  8F838054   LW V1, -32684(GP)
9D0037DC  00621021   ADDU V0, V1, V0
9D0037E0  90550001   LBU S5, 1(V0)
9D0037E4  90420000   LBU V0, 0(V0)
9D0037E8  02A2A825   OR S5, S5, V0
9D0037EC  32B500FF   ANDI S5, S5, 255
9D004064  304200FF   ANDI V0, V0, 255
9D004068  8F838054   LW V1, -32684(GP)
9D00406C  00621021   ADDU V0, V1, V0
9D004070  90440001   LBU A0, 1(V0)
9D004074  90420000   LBU V0, 0(V0)
9D004078  00822025   OR A0, A0, V0
9D004134  304200FF   ANDI V0, V0, 255
9D004138  8F838054   LW V1, -32684(GP)
9D00413C  00621021   ADDU V0, V1, V0
9D004140  90530001   LBU S3, 1(V0)
9D004144  90420000   LBU V0, 0(V0)
9D004148  02629825   OR S3, S3, V0
9D00414C  327300FF   ANDI S3, S3, 255
9D004ACC  90420000   LBU V0, 0(V0)
9D004AD0  8F838054   LW V1, -32684(GP)
9D004AD4  00621021   ADDU V0, V1, V0
9D004AD8  90440001   LBU A0, 1(V0)
9D004ADC  90420000   LBU V0, 0(V0)
9D004AE0  00822025   OR A0, A0, V0
9D004AE4  308400FF   ANDI A0, A0, 255
9D004BCC  90420000   LBU V0, 0(V0)
9D004BD0  8F838054   LW V1, -32684(GP)
9D004BD4  00621021   ADDU V0, V1, V0
9D004BD8  90530001   LBU S3, 1(V0)
9D004BDC  90420000   LBU V0, 0(V0)
9D004BE0  02629825   OR S3, S3, V0
9D004BE4  327300FF   ANDI S3, S3, 255
9D0054DC  304200FF   ANDI V0, V0, 255
9D0054E0  8F838054   LW V1, -32684(GP)
9D0054E4  00621021   ADDU V0, V1, V0
9D0054E8  90440001   LBU A0, 1(V0)
9D0054EC  90420000   LBU V0, 0(V0)
9D0054F0  00822025   OR A0, A0, V0
9D005570  304200FF   ANDI V0, V0, 255
9D005574  8F838054   LW V1, -32684(GP)
9D005578  00621021   ADDU V0, V1, V0
9D00557C  90440001   LBU A0, 1(V0)
9D005580  90420000   LBU V0, 0(V0)
9D005584  00822025   OR A0, A0, V0
9D005C88  90420000   LBU V0, 0(V0)
9D005C8C  8F838054   LW V1, -32684(GP)
9D005C90  00621021   ADDU V0, V1, V0
9D005C94  90440001   LBU A0, 1(V0)
9D005C98  90420000   LBU V0, 0(V0)
9D005C9C  00822025   OR A0, A0, V0
9D005CA0  308400FF   ANDI A0, A0, 255
9D005D20  90420000   LBU V0, 0(V0)
9D005D24  8F838054   LW V1, -32684(GP)
9D005D28  00621021   ADDU V0, V1, V0
9D005D2C  90440001   LBU A0, 1(V0)
9D005D30  90420000   LBU V0, 0(V0)
9D005D34  00822025   OR A0, A0, V0
9D005D38  308400FF   ANDI A0, A0, 255
9D006550  304200FF   ANDI V0, V0, 255
9D006554  8F838054   LW V1, -32684(GP)
9D006558  00621021   ADDU V0, V1, V0
9D00655C  90440001   LBU A0, 1(V0)
9D006560  90420000   LBU V0, 0(V0)
9D006564  00822025   OR A0, A0, V0
9D006678  304200FF   ANDI V0, V0, 255
9D00667C  8F838054   LW V1, -32684(GP)
9D006680  00621021   ADDU V0, V1, V0
9D006684  90440001   LBU A0, 1(V0)
9D006688  90420000   LBU V0, 0(V0)
9D00668C  00822025   OR A0, A0, V0
9D006EC8  90420000   LBU V0, 0(V0)
9D006ECC  8F838054   LW V1, -32684(GP)
9D006ED0  00621021   ADDU V0, V1, V0
9D006ED4  90440001   LBU A0, 1(V0)
9D006ED8  90420000   LBU V0, 0(V0)
9D006EDC  00822025   OR A0, A0, V0
9D006EE0  308400FF   ANDI A0, A0, 255
9D006F9C  90420000   LBU V0, 0(V0)
9D006FA0  8F838054   LW V1, -32684(GP)
9D006FA4  00621021   ADDU V0, V1, V0
9D006FA8  90440001   LBU A0, 1(V0)
9D006FAC  90420000   LBU V0, 0(V0)
9D006FB0  00822025   OR A0, A0, V0
9D006FB4  308400FF   ANDI A0, A0, 255
9D0079AC  304200FF   ANDI V0, V0, 255
9D0079B0  8F838054   LW V1, -32684(GP)
9D0079B4  00621021   ADDU V0, V1, V0
9D0079B8  90440001   LBU A0, 1(V0)
9D0079BC  90420000   LBU V0, 0(V0)
9D0079C0  00822025   OR A0, A0, V0
9D007A58  304200FF   ANDI V0, V0, 255
9D007A5C  8F838054   LW V1, -32684(GP)
9D007A60  00621021   ADDU V0, V1, V0
9D007A64  90550001   LBU S5, 1(V0)
9D007A68  90420000   LBU V0, 0(V0)
9D007A6C  02A2A825   OR S5, S5, V0
9D007A70  32B500FF   ANDI S5, S5, 255
9D00831C  90420000   LBU V0, 0(V0)
9D008320  8F838054   LW V1, -32684(GP)
9D008324  00621021   ADDU V0, V1, V0
9D008328  90440001   LBU A0, 1(V0)
9D00832C  90420000   LBU V0, 0(V0)
9D008330  00822025   OR A0, A0, V0
9D008334  308400FF   ANDI A0, A0, 255
9D0083F8  90420000   LBU V0, 0(V0)
9D0083FC  8F838054   LW V1, -32684(GP)
9D008400  00621021   ADDU V0, V1, V0
9D008404  90550001   LBU S5, 1(V0)
9D008408  90420000   LBU V0, 0(V0)
9D00840C  02A2A825   OR S5, S5, V0
9D008410  32B500FF   ANDI S5, S5, 255
9D008BC4  304200FF   ANDI V0, V0, 255
9D008BC8  8F838054   LW V1, -32684(GP)
9D008BCC  00621021   ADDU V0, V1, V0
9D008BD0  90440001   LBU A0, 1(V0)
9D008BD4  90420000   LBU V0, 0(V0)
9D008BD8  00822025   OR A0, A0, V0
9D008C98  304200FF   ANDI V0, V0, 255
9D008C9C  8F838054   LW V1, -32684(GP)
9D008CA0  00621021   ADDU V0, V1, V0
9D008CA4  90530001   LBU S3, 1(V0)
9D008CA8  90420000   LBU V0, 0(V0)
9D008CAC  02629825   OR S3, S3, V0
9D008CB0  327300FF   ANDI S3, S3, 255
9D009590  90420000   LBU V0, 0(V0)
9D009594  8F838054   LW V1, -32684(GP)
9D009598  00621021   ADDU V0, V1, V0
9D00959C  90440001   LBU A0, 1(V0)
9D0095A0  90420000   LBU V0, 0(V0)
9D0095A4  00822025   OR A0, A0, V0
9D0095A8  308400FF   ANDI A0, A0, 255
9D009690  90420000   LBU V0, 0(V0)
9D009694  8F838054   LW V1, -32684(GP)
9D009698  00621021   ADDU V0, V1, V0
9D00969C  90530001   LBU S3, 1(V0)
9D0096A0  90420000   LBU V0, 0(V0)
9D0096A4  02629825   OR S3, S3, V0
9D0096A8  327300FF   ANDI S3, S3, 255
1156:                }
1157:                
1158:                
1159:                inline uint32 bank_readword(register uint32 address)
1160:                {
1161:                   /* technically, this should fail if the address is $xFFF, but
1162:                   ** any code that does this would be suspect anyway, as it would
1163:                   ** be fetching a word across page boundaries, which only would
1164:                   ** make sense if the banks were physically consecutive.
1165:                   */ 
1166:                   return (uint32) (cpu.mem_page[address >> NES6502_BANKSHIFT][address & NES6502_BANKMASK]) 
9D0001A0  00042B02   SRL A1, A0, 12
9D0001A4  00052880   SLL A1, A1, 2
9D0001A8  00A21021   ADDU V0, A1, V0
9D0001AC  30840FFF   ANDI A0, A0, 4095
9D0001B0  8C420000   LW V0, 0(V0)
9D0001B4  00442021   ADDU A0, V0, A0
9D0004B8  3C02A001   LUI V0, -24575
9D0004D0  325200FF   ANDI S2, S2, 255
9D0005E4  8E22003C   LW V0, 60(S1)
9D0005F4  325200FF   ANDI S2, S2, 255
9D000D40  00102302   SRL A0, S0, 12
9D000D44  00042080   SLL A0, A0, 2
9D000D48  00912021   ADDU A0, A0, S1
9D000D4C  32020FFF   ANDI V0, S0, 4095
9D000D50  8C840000   LW A0, 0(A0)
9D000D54  00821021   ADDU V0, A0, V0
9D000DF0  00102302   SRL A0, S0, 12
9D000DF4  00042080   SLL A0, A0, 2
9D000DF8  00912021   ADDU A0, A0, S1
9D000DFC  32020FFF   ANDI V0, S0, 4095
9D000E00  8C840000   LW A0, 0(A0)
9D000E04  00821021   ADDU V0, A0, V0
9D000E14  32B500FF   ANDI S5, S5, 255
9D000EB0  00102302   SRL A0, S0, 12
9D000EB4  00042080   SLL A0, A0, 2
9D000EB8  00912021   ADDU A0, A0, S1
9D000EBC  32020FFF   ANDI V0, S0, 4095
9D000EC0  8C840000   LW A0, 0(A0)
9D000EC4  00821021   ADDU V0, A0, V0
9D000ED4  32B500FF   ANDI S5, S5, 255
9D001498  00102302   SRL A0, S0, 12
9D00149C  00042080   SLL A0, A0, 2
9D0014A0  00912021   ADDU A0, A0, S1
9D0014A4  32020FFF   ANDI V0, S0, 4095
9D0014A8  8C840000   LW A0, 0(A0)
9D0014AC  00821021   ADDU V0, A0, V0
9D0014BC  308400FF   ANDI A0, A0, 255
9D0015F8  00102302   SRL A0, S0, 12
9D0015FC  00042080   SLL A0, A0, 2
9D001600  00912021   ADDU A0, A0, S1
9D001604  32020FFF   ANDI V0, S0, 4095
9D001608  8C840000   LW A0, 0(A0)
9D00160C  00821021   ADDU V0, A0, V0
9D00161C  32B500FF   ANDI S5, S5, 255
9D001740  00102302   SRL A0, S0, 12
9D001744  00042080   SLL A0, A0, 2
9D001748  00912021   ADDU A0, A0, S1
9D00174C  32020FFF   ANDI V0, S0, 4095
9D001750  8C840000   LW A0, 0(A0)
9D001754  00821021   ADDU V0, A0, V0
9D001764  308400FF   ANDI A0, A0, 255
9D001828  00102302   SRL A0, S0, 12
9D00182C  00042080   SLL A0, A0, 2
9D001830  00912021   ADDU A0, A0, S1
9D001834  32020FFF   ANDI V0, S0, 4095
9D001838  8C840000   LW A0, 0(A0)
9D00183C  00821021   ADDU V0, A0, V0
9D00184C  32B500FF   ANDI S5, S5, 255
9D0018F0  00102302   SRL A0, S0, 12
9D0018F4  00042080   SLL A0, A0, 2
9D0018F8  00912021   ADDU A0, A0, S1
9D0018FC  32020FFF   ANDI V0, S0, 4095
9D001900  8C840000   LW A0, 0(A0)
9D001904  00821021   ADDU V0, A0, V0
9D001914  32B500FF   ANDI S5, S5, 255
9D0019F8  00101302   SRL V0, S0, 12
9D0019FC  00021080   SLL V0, V0, 2
9D001A00  00511021   ADDU V0, V0, S1
9D001A04  32100FFF   ANDI S0, S0, 4095
9D001A08  8C420000   LW V0, 0(V0)
9D001A0C  00501021   ADDU V0, V0, S0
9D00209C  00102302   SRL A0, S0, 12
9D0020A0  00042080   SLL A0, A0, 2
9D0020A4  00912021   ADDU A0, A0, S1
9D0020A8  32020FFF   ANDI V0, S0, 4095
9D0020AC  8C840000   LW A0, 0(A0)
9D0020B0  00821021   ADDU V0, A0, V0
9D00214C  00102302   SRL A0, S0, 12
9D002150  00042080   SLL A0, A0, 2
9D002154  00912021   ADDU A0, A0, S1
9D002158  32020FFF   ANDI V0, S0, 4095
9D00215C  8C840000   LW A0, 0(A0)
9D002160  00821021   ADDU V0, A0, V0
9D0021FC  00102302   SRL A0, S0, 12
9D002200  00042080   SLL A0, A0, 2
9D002204  00912021   ADDU A0, A0, S1
9D002208  32020FFF   ANDI V0, S0, 4095
9D00220C  8C840000   LW A0, 0(A0)
9D002210  00821021   ADDU V0, A0, V0
9D002220  32B500FF   ANDI S5, S5, 255
9D0022CC  00102302   SRL A0, S0, 12
9D0022D0  00042080   SLL A0, A0, 2
9D0022D4  00912021   ADDU A0, A0, S1
9D0022D8  32020FFF   ANDI V0, S0, 4095
9D0022DC  8C840000   LW A0, 0(A0)
9D0022E0  00821021   ADDU V0, A0, V0
9D0022F0  32B500FF   ANDI S5, S5, 255
9D00286C  00102302   SRL A0, S0, 12
9D002870  00042080   SLL A0, A0, 2
9D002874  00912021   ADDU A0, A0, S1
9D002878  32020FFF   ANDI V0, S0, 4095
9D00287C  8C840000   LW A0, 0(A0)
9D002880  00821021   ADDU V0, A0, V0
9D002890  308400FF   ANDI A0, A0, 255
9D00295C  00102302   SRL A0, S0, 12
9D002960  00042080   SLL A0, A0, 2
9D002964  00912021   ADDU A0, A0, S1
9D002968  32020FFF   ANDI V0, S0, 4095
9D00296C  8C840000   LW A0, 0(A0)
9D002970  00821021   ADDU V0, A0, V0
9D002980  32B500FF   ANDI S5, S5, 255
9D002A40  00102302   SRL A0, S0, 12
9D002A44  00042080   SLL A0, A0, 2
9D002A48  00912021   ADDU A0, A0, S1
9D002A4C  32020FFF   ANDI V0, S0, 4095
9D002A50  8C840000   LW A0, 0(A0)
9D002A54  00821021   ADDU V0, A0, V0
9D002A64  308400FF   ANDI A0, A0, 255
9D002B28  00102302   SRL A0, S0, 12
9D002B2C  00042080   SLL A0, A0, 2
9D002B30  00912021   ADDU A0, A0, S1
9D002B34  32020FFF   ANDI V0, S0, 4095
9D002B38  8C840000   LW A0, 0(A0)
9D002B3C  00821021   ADDU V0, A0, V0
9D002B4C  32B500FF   ANDI S5, S5, 255
9D002C00  00102302   SRL A0, S0, 12
9D002C04  00042080   SLL A0, A0, 2
9D002C08  00912021   ADDU A0, A0, S1
9D002C0C  32020FFF   ANDI V0, S0, 4095
9D002C10  8C840000   LW A0, 0(A0)
9D002C14  00821021   ADDU V0, A0, V0
9D002C24  32B500FF   ANDI S5, S5, 255
9D002DBC  8E22003C   LW V0, 60(S1)
9D002DCC  325200FF   ANDI S2, S2, 255
9D00337C  00101302   SRL V0, S0, 12
9D003380  00021080   SLL V0, V0, 2
9D003384  00511021   ADDU V0, V0, S1
9D003388  32100FFF   ANDI S0, S0, 4095
9D00338C  8C420000   LW V0, 0(V0)
9D003390  00501021   ADDU V0, V0, S0
9D003400  00102302   SRL A0, S0, 12
9D003404  00042080   SLL A0, A0, 2
9D003408  00912021   ADDU A0, A0, S1
9D00340C  32020FFF   ANDI V0, S0, 4095
9D003410  8C840000   LW A0, 0(A0)
9D003414  00821021   ADDU V0, A0, V0
9D0034B0  00102302   SRL A0, S0, 12
9D0034B4  00042080   SLL A0, A0, 2
9D0034B8  00912021   ADDU A0, A0, S1
9D0034BC  32020FFF   ANDI V0, S0, 4095
9D0034C0  8C840000   LW A0, 0(A0)
9D0034C4  00821021   ADDU V0, A0, V0
9D0034D4  32B500FF   ANDI S5, S5, 255
9D00356C  00102302   SRL A0, S0, 12
9D003570  00042080   SLL A0, A0, 2
9D003574  00912021   ADDU A0, A0, S1
9D003578  32020FFF   ANDI V0, S0, 4095
9D00357C  8C840000   LW A0, 0(A0)
9D003580  00821021   ADDU V0, A0, V0
9D003590  32B500FF   ANDI S5, S5, 255
9D003B08  8E23003C   LW V1, 60(S1)
9D003B18  321000FF   ANDI S0, S0, 255
9D003B9C  00102302   SRL A0, S0, 12
9D003BA0  00042080   SLL A0, A0, 2
9D003BA4  00912021   ADDU A0, A0, S1
9D003BA8  32020FFF   ANDI V0, S0, 4095
9D003BAC  8C840000   LW A0, 0(A0)
9D003BB0  00821021   ADDU V0, A0, V0
9D003BC0  308400FF   ANDI A0, A0, 255
9D003C88  00102302   SRL A0, S0, 12
9D003C8C  00042080   SLL A0, A0, 2
9D003C90  00912021   ADDU A0, A0, S1
9D003C94  32020FFF   ANDI V0, S0, 4095
9D003C98  8C840000   LW A0, 0(A0)
9D003C9C  00821021   ADDU V0, A0, V0
9D003CAC  32B500FF   ANDI S5, S5, 255
9D003D5C  00102302   SRL A0, S0, 12
9D003D60  00042080   SLL A0, A0, 2
9D003D64  00912021   ADDU A0, A0, S1
9D003D68  32020FFF   ANDI V0, S0, 4095
9D003D6C  8C840000   LW A0, 0(A0)
9D003D70  00821021   ADDU V0, A0, V0
9D003D80  308400FF   ANDI A0, A0, 255
9D003E44  00102302   SRL A0, S0, 12
9D003E48  00042080   SLL A0, A0, 2
9D003E4C  00912021   ADDU A0, A0, S1
9D003E50  32020FFF   ANDI V0, S0, 4095
9D003E54  8C840000   LW A0, 0(A0)
9D003E58  00821021   ADDU V0, A0, V0
9D003E68  32B500FF   ANDI S5, S5, 255
9D003F08  00102302   SRL A0, S0, 12
9D003F0C  00042080   SLL A0, A0, 2
9D003F10  00912021   ADDU A0, A0, S1
9D003F14  32020FFF   ANDI V0, S0, 4095
9D003F18  8C840000   LW A0, 0(A0)
9D003F1C  00821021   ADDU V0, A0, V0
9D003F2C  32B500FF   ANDI S5, S5, 255
9D0046A0  00101302   SRL V0, S0, 12
9D0046A4  00021080   SLL V0, V0, 2
9D0046A8  00511021   ADDU V0, V0, S1
9D0046AC  32100FFF   ANDI S0, S0, 4095
9D0046B0  8C420000   LW V0, 0(V0)
9D0046B4  00501021   ADDU V0, V0, S0
9D0046FC  325200FF   ANDI S2, S2, 255
9D00476C  00102302   SRL A0, S0, 12
9D004770  00042080   SLL A0, A0, 2
9D004774  00912021   ADDU A0, A0, S1
9D004778  32020FFF   ANDI V0, S0, 4095
9D00477C  8C840000   LW A0, 0(A0)
9D004780  00821021   ADDU V0, A0, V0
9D004840  00102302   SRL A0, S0, 12
9D004844  00042080   SLL A0, A0, 2
9D004848  00912021   ADDU A0, A0, S1
9D00484C  32020FFF   ANDI V0, S0, 4095
9D004850  8C840000   LW A0, 0(A0)
9D004854  00821021   ADDU V0, A0, V0
9D004864  32B500FF   ANDI S5, S5, 255
9D004908  00102302   SRL A0, S0, 12
9D00490C  00042080   SLL A0, A0, 2
9D004910  00912021   ADDU A0, A0, S1
9D004914  32020FFF   ANDI V0, S0, 4095
9D004918  8C840000   LW A0, 0(A0)
9D00491C  00821021   ADDU V0, A0, V0
9D00492C  327300FF   ANDI S3, S3, 255
9D004F6C  00102302   SRL A0, S0, 12
9D004F70  00042080   SLL A0, A0, 2
9D004F74  00912021   ADDU A0, A0, S1
9D004F78  32020FFF   ANDI V0, S0, 4095
9D004F7C  8C840000   LW A0, 0(A0)
9D004F80  00821021   ADDU V0, A0, V0
9D004F90  308400FF   ANDI A0, A0, 255
9D00507C  00102302   SRL A0, S0, 12
9D005080  00042080   SLL A0, A0, 2
9D005084  00912021   ADDU A0, A0, S1
9D005088  32020FFF   ANDI V0, S0, 4095
9D00508C  8C840000   LW A0, 0(A0)
9D005090  00821021   ADDU V0, A0, V0
9D0050A0  327300FF   ANDI S3, S3, 255
9D005188  00102302   SRL A0, S0, 12
9D00518C  00042080   SLL A0, A0, 2
9D005190  00912021   ADDU A0, A0, S1
9D005194  32020FFF   ANDI V0, S0, 4095
9D005198  8C840000   LW A0, 0(A0)
9D00519C  00821021   ADDU V0, A0, V0
9D0051AC  308400FF   ANDI A0, A0, 255
9D005294  00102302   SRL A0, S0, 12
9D005298  00042080   SLL A0, A0, 2
9D00529C  00912021   ADDU A0, A0, S1
9D0052A0  32020FFF   ANDI V0, S0, 4095
9D0052A4  8C840000   LW A0, 0(A0)
9D0052A8  00821021   ADDU V0, A0, V0
9D0052B8  32B500FF   ANDI S5, S5, 255
9D005364  00102302   SRL A0, S0, 12
9D005368  00042080   SLL A0, A0, 2
9D00536C  00912021   ADDU A0, A0, S1
9D005370  32020FFF   ANDI V0, S0, 4095
9D005374  8C840000   LW A0, 0(A0)
9D005378  00821021   ADDU V0, A0, V0
9D005388  327300FF   ANDI S3, S3, 255
9D005958  00102302   SRL A0, S0, 12
9D00595C  00042080   SLL A0, A0, 2
9D005960  00912021   ADDU A0, A0, S1
9D005964  32020FFF   ANDI V0, S0, 4095
9D005968  8C840000   LW A0, 0(A0)
9D00596C  00821021   ADDU V0, A0, V0
9D0059F4  00102302   SRL A0, S0, 12
9D0059F8  00042080   SLL A0, A0, 2
9D0059FC  00912021   ADDU A0, A0, S1
9D005A00  32020FFF   ANDI V0, S0, 4095
9D005A04  8C840000   LW A0, 0(A0)
9D005A08  00821021   ADDU V0, A0, V0
9D005A90  00102302   SRL A0, S0, 12
9D005A94  00042080   SLL A0, A0, 2
9D005A98  00912021   ADDU A0, A0, S1
9D005A9C  32020FFF   ANDI V0, S0, 4095
9D005AA0  8C840000   LW A0, 0(A0)
9D005AA4  00821021   ADDU V0, A0, V0
9D005B2C  00102302   SRL A0, S0, 12
9D005B30  00042080   SLL A0, A0, 2
9D005B34  00912021   ADDU A0, A0, S1
9D005B38  32020FFF   ANDI V0, S0, 4095
9D005B3C  8C840000   LW A0, 0(A0)
9D005B40  00821021   ADDU V0, A0, V0
9D006048  00102302   SRL A0, S0, 12
9D00604C  00042080   SLL A0, A0, 2
9D006050  00912021   ADDU A0, A0, S1
9D006054  32020FFF   ANDI V0, S0, 4095
9D006058  8C840000   LW A0, 0(A0)
9D00605C  00821021   ADDU V0, A0, V0
9D00606C  308400FF   ANDI A0, A0, 255
9D00614C  00102302   SRL A0, S0, 12
9D006150  00042080   SLL A0, A0, 2
9D006154  00912021   ADDU A0, A0, S1
9D006158  32020FFF   ANDI V0, S0, 4095
9D00615C  8C840000   LW A0, 0(A0)
9D006160  00821021   ADDU V0, A0, V0
9D006170  308400FF   ANDI A0, A0, 255
9D006208  00102302   SRL A0, S0, 12
9D00620C  00042080   SLL A0, A0, 2
9D006210  00912021   ADDU A0, A0, S1
9D006214  32020FFF   ANDI V0, S0, 4095
9D006218  8C840000   LW A0, 0(A0)
9D00621C  00821021   ADDU V0, A0, V0
9D00622C  308400FF   ANDI A0, A0, 255
9D0062BC  00102302   SRL A0, S0, 12
9D0062C0  00042080   SLL A0, A0, 2
9D0062C4  00912021   ADDU A0, A0, S1
9D0062C8  32020FFF   ANDI V0, S0, 4095
9D0062CC  8C840000   LW A0, 0(A0)
9D0062D0  00821021   ADDU V0, A0, V0
9D0062E0  308400FF   ANDI A0, A0, 255
9D006360  00102302   SRL A0, S0, 12
9D006364  00042080   SLL A0, A0, 2
9D006368  00912021   ADDU A0, A0, S1
9D00636C  32020FFF   ANDI V0, S0, 4095
9D006370  8C840000   LW A0, 0(A0)
9D006374  00821021   ADDU V0, A0, V0
9D006384  308400FF   ANDI A0, A0, 255
9D006414  00102302   SRL A0, S0, 12
9D006418  00042080   SLL A0, A0, 2
9D00641C  00912021   ADDU A0, A0, S1
9D006420  32020FFF   ANDI V0, S0, 4095
9D006424  8C840000   LW A0, 0(A0)
9D006428  00821021   ADDU V0, A0, V0
9D006438  308400FF   ANDI A0, A0, 255
9D006B48  00102302   SRL A0, S0, 12
9D006B4C  00042080   SLL A0, A0, 2
9D006B50  00912021   ADDU A0, A0, S1
9D006B54  32020FFF   ANDI V0, S0, 4095
9D006B58  8C840000   LW A0, 0(A0)
9D006B5C  00821021   ADDU V0, A0, V0
9D006BF8  00102302   SRL A0, S0, 12
9D006BFC  00042080   SLL A0, A0, 2
9D006C00  00912021   ADDU A0, A0, S1
9D006C04  32020FFF   ANDI V0, S0, 4095
9D006C08  8C840000   LW A0, 0(A0)
9D006C0C  00821021   ADDU V0, A0, V0
9D006CA8  00102302   SRL A0, S0, 12
9D006CAC  00042080   SLL A0, A0, 2
9D006CB0  00912021   ADDU A0, A0, S1
9D006CB4  32020FFF   ANDI V0, S0, 4095
9D006CB8  8C840000   LW A0, 0(A0)
9D006CBC  00821021   ADDU V0, A0, V0
9D006D58  00102302   SRL A0, S0, 12
9D006D5C  00042080   SLL A0, A0, 2
9D006D60  00912021   ADDU A0, A0, S1
9D006D64  32020FFF   ANDI V0, S0, 4095
9D006D68  8C840000   LW A0, 0(A0)
9D006D6C  00821021   ADDU V0, A0, V0
9D007338  00102302   SRL A0, S0, 12
9D00733C  00042080   SLL A0, A0, 2
9D007340  00912021   ADDU A0, A0, S1
9D007344  32020FFF   ANDI V0, S0, 4095
9D007348  8C840000   LW A0, 0(A0)
9D00734C  00821021   ADDU V0, A0, V0
9D00735C  308400FF   ANDI A0, A0, 255
9D00748C  00102302   SRL A0, S0, 12
9D007490  00042080   SLL A0, A0, 2
9D007494  00912021   ADDU A0, A0, S1
9D007498  32020FFF   ANDI V0, S0, 4095
9D00749C  8C840000   LW A0, 0(A0)
9D0074A0  00821021   ADDU V0, A0, V0
9D0074B0  308400FF   ANDI A0, A0, 255
9D007588  00102302   SRL A0, S0, 12
9D00758C  00042080   SLL A0, A0, 2
9D007590  00912021   ADDU A0, A0, S1
9D007594  32020FFF   ANDI V0, S0, 4095
9D007598  8C840000   LW A0, 0(A0)
9D00759C  00821021   ADDU V0, A0, V0
9D0075AC  308400FF   ANDI A0, A0, 255
9D007668  00102302   SRL A0, S0, 12
9D00766C  00042080   SLL A0, A0, 2
9D007670  00912021   ADDU A0, A0, S1
9D007674  32020FFF   ANDI V0, S0, 4095
9D007678  8C840000   LW A0, 0(A0)
9D00767C  00821021   ADDU V0, A0, V0
9D00768C  308400FF   ANDI A0, A0, 255
9D007748  00102302   SRL A0, S0, 12
9D00774C  00042080   SLL A0, A0, 2
9D007750  00912021   ADDU A0, A0, S1
9D007754  32020FFF   ANDI V0, S0, 4095
9D007758  8C840000   LW A0, 0(A0)
9D00775C  00821021   ADDU V0, A0, V0
9D00776C  308400FF   ANDI A0, A0, 255
9D00782C  00102302   SRL A0, S0, 12
9D007830  00042080   SLL A0, A0, 2
9D007834  00912021   ADDU A0, A0, S1
9D007838  32020FFF   ANDI V0, S0, 4095
9D00783C  8C840000   LW A0, 0(A0)
9D007840  00821021   ADDU V0, A0, V0
9D007850  308400FF   ANDI A0, A0, 255
9D007F70  00102302   SRL A0, S0, 12
9D007F74  00042080   SLL A0, A0, 2
9D007F78  00912021   ADDU A0, A0, S1
9D007F7C  32020FFF   ANDI V0, S0, 4095
9D007F80  8C840000   LW A0, 0(A0)
9D007F84  00821021   ADDU V0, A0, V0
9D008028  00102302   SRL A0, S0, 12
9D00802C  00042080   SLL A0, A0, 2
9D008030  00912021   ADDU A0, A0, S1
9D008034  32020FFF   ANDI V0, S0, 4095
9D008038  8C840000   LW A0, 0(A0)
9D00803C  00821021   ADDU V0, A0, V0
9D0080D8  00102302   SRL A0, S0, 12
9D0080DC  00042080   SLL A0, A0, 2
9D0080E0  00912021   ADDU A0, A0, S1
9D0080E4  32020FFF   ANDI V0, S0, 4095
9D0080E8  8C840000   LW A0, 0(A0)
9D0080EC  00821021   ADDU V0, A0, V0
9D0080FC  32B500FF   ANDI S5, S5, 255
9D008194  00102302   SRL A0, S0, 12
9D008198  00042080   SLL A0, A0, 2
9D00819C  00912021   ADDU A0, A0, S1
9D0081A0  32020FFF   ANDI V0, S0, 4095
9D0081A4  8C840000   LW A0, 0(A0)
9D0081A8  00821021   ADDU V0, A0, V0
9D0081B8  32B500FF   ANDI S5, S5, 255
9D0086F8  00102302   SRL A0, S0, 12
9D0086FC  00042080   SLL A0, A0, 2
9D008700  00912021   ADDU A0, A0, S1
9D008704  32020FFF   ANDI V0, S0, 4095
9D008708  8C840000   LW A0, 0(A0)
9D00870C  00821021   ADDU V0, A0, V0
9D00871C  308400FF   ANDI A0, A0, 255
9D0087E4  00102302   SRL A0, S0, 12
9D0087E8  00042080   SLL A0, A0, 2
9D0087EC  00912021   ADDU A0, A0, S1
9D0087F0  32020FFF   ANDI V0, S0, 4095
9D0087F4  8C840000   LW A0, 0(A0)
9D0087F8  00821021   ADDU V0, A0, V0
9D008808  32B500FF   ANDI S5, S5, 255
9D0088B8  00102302   SRL A0, S0, 12
9D0088BC  00042080   SLL A0, A0, 2
9D0088C0  00912021   ADDU A0, A0, S1
9D0088C4  32020FFF   ANDI V0, S0, 4095
9D0088C8  8C840000   LW A0, 0(A0)
9D0088CC  00821021   ADDU V0, A0, V0
9D0088DC  308400FF   ANDI A0, A0, 255
9D0089A0  00102302   SRL A0, S0, 12
9D0089A4  00042080   SLL A0, A0, 2
9D0089A8  00912021   ADDU A0, A0, S1
9D0089AC  32020FFF   ANDI V0, S0, 4095
9D0089B0  8C840000   LW A0, 0(A0)
9D0089B4  00821021   ADDU V0, A0, V0
9D0089C4  32B500FF   ANDI S5, S5, 255
9D008A64  00102302   SRL A0, S0, 12
9D008A68  00042080   SLL A0, A0, 2
9D008A6C  00912021   ADDU A0, A0, S1
9D008A70  32020FFF   ANDI V0, S0, 4095
9D008A74  8C840000   LW A0, 0(A0)
9D008A78  00821021   ADDU V0, A0, V0
9D008A88  32B500FF   ANDI S5, S5, 255
9D009198  00102302   SRL A0, S0, 12
9D00919C  00042080   SLL A0, A0, 2
9D0091A0  00912021   ADDU A0, A0, S1
9D0091A4  32020FFF   ANDI V0, S0, 4095
9D0091A8  8C840000   LW A0, 0(A0)
9D0091AC  00821021   ADDU V0, A0, V0
9D00924C  00102302   SRL A0, S0, 12
9D009250  00042080   SLL A0, A0, 2
9D009254  00912021   ADDU A0, A0, S1
9D009258  32020FFF   ANDI V0, S0, 4095
9D00925C  8C840000   LW A0, 0(A0)
9D009260  00821021   ADDU V0, A0, V0
9D009324  00102302   SRL A0, S0, 12
9D009328  00042080   SLL A0, A0, 2
9D00932C  00912021   ADDU A0, A0, S1
9D009330  32020FFF   ANDI V0, S0, 4095
9D009334  8C840000   LW A0, 0(A0)
9D009338  00821021   ADDU V0, A0, V0
9D009348  32B500FF   ANDI S5, S5, 255
9D0093E0  00102302   SRL A0, S0, 12
9D0093E4  00042080   SLL A0, A0, 2
9D0093E8  00912021   ADDU A0, A0, S1
9D0093EC  32020FFF   ANDI V0, S0, 4095
9D0093F0  8C840000   LW A0, 0(A0)
9D0093F4  00821021   ADDU V0, A0, V0
9D009404  327300FF   ANDI S3, S3, 255
9D009A10  00102302   SRL A0, S0, 12
9D009A14  00042080   SLL A0, A0, 2
9D009A18  00912021   ADDU A0, A0, S1
9D009A1C  32020FFF   ANDI V0, S0, 4095
9D009A20  8C840000   LW A0, 0(A0)
9D009A24  00821021   ADDU V0, A0, V0
9D009A34  308400FF   ANDI A0, A0, 255
9D009B20  00102302   SRL A0, S0, 12
9D009B24  00042080   SLL A0, A0, 2
9D009B28  00912021   ADDU A0, A0, S1
9D009B2C  32020FFF   ANDI V0, S0, 4095
9D009B30  8C840000   LW A0, 0(A0)
9D009B34  00821021   ADDU V0, A0, V0
9D009B44  327300FF   ANDI S3, S3, 255
9D009C1C  00102302   SRL A0, S0, 12
9D009C20  00042080   SLL A0, A0, 2
9D009C24  00912021   ADDU A0, A0, S1
9D009C28  32020FFF   ANDI V0, S0, 4095
9D009C2C  8C840000   LW A0, 0(A0)
9D009C30  00821021   ADDU V0, A0, V0
9D009C40  308400FF   ANDI A0, A0, 255
9D009D28  00102302   SRL A0, S0, 12
9D009D2C  00042080   SLL A0, A0, 2
9D009D30  00912021   ADDU A0, A0, S1
9D009D34  32020FFF   ANDI V0, S0, 4095
9D009D38  8C840000   LW A0, 0(A0)
9D009D3C  00821021   ADDU V0, A0, V0
9D009D4C  32B500FF   ANDI S5, S5, 255
9D009DEC  00102302   SRL A0, S0, 12
9D009DF0  00042080   SLL A0, A0, 2
9D009DF4  00912021   ADDU A0, A0, S1
9D009DF8  32020FFF   ANDI V0, S0, 4095
9D009DFC  8C840000   LW A0, 0(A0)
9D009E00  00821021   ADDU V0, A0, V0
9D009E10  327300FF   ANDI S3, S3, 255
9D009FAC  8C43003C   LW V1, 60(V0)
9D009FBC  306300FF   ANDI V1, V1, 255
9D00A07C  3C02A001   LUI V0, -24575
9D00A094  306300FF   ANDI V1, V1, 255
9D00A1A0  3C02A001   LUI V0, -24575
9D00A1B8  30C600FF   ANDI A2, A2, 255
1167:                           | (cpu.mem_page[(address+1) >> NES6502_BANKSHIFT][(address+1) & NES6502_BANKMASK]);
9D00017C  24830001   ADDIU V1, A0, 1
9D000180  00032B02   SRL A1, V1, 12
9D000184  00052880   SLL A1, A1, 2
9D000188  3C02A001   LUI V0, -24575
9D00018C  24428FD0   ADDIU V0, V0, -28720
9D000190  00A22821   ADDU A1, A1, V0
9D000194  30630FFF   ANDI V1, V1, 4095
9D000198  8CA50000   LW A1, 0(A1)
9D00019C  00A31821   ADDU V1, A1, V1
9D0001B8  90630000   LBU V1, 0(V1)
9D0001BC  90820000   LBU V0, 0(A0)
9D0001C0  00621025   OR V0, V1, V0
9D0004C4  90920FFF   LBU S2, 4095(A0)
9D000538  3C11A001   LUI S1, -24575
9D00053C  26318FD0   ADDIU S1, S1, -28720
9D0005E8  90520FFF   LBU S2, 4095(V0)
9D000D20  26020001   ADDIU V0, S0, 1
9D000D28  00021B02   SRL V1, V0, 12
9D000D2C  00031880   SLL V1, V1, 2
9D000D30  00711821   ADDU V1, V1, S1
9D000D34  30420FFF   ANDI V0, V0, 4095
9D000D38  8C630000   LW V1, 0(V1)
9D000D3C  00621821   ADDU V1, V1, V0
9D000D58  90640000   LBU A0, 0(V1)
9D000D5C  90420000   LBU V0, 0(V0)
9D000D60  00822025   OR A0, A0, V0
9D000DD4  26020001   ADDIU V0, S0, 1
9D000DD8  00021B02   SRL V1, V0, 12
9D000DDC  00031880   SLL V1, V1, 2
9D000DE0  00711821   ADDU V1, V1, S1
9D000DE4  30420FFF   ANDI V0, V0, 4095
9D000DE8  8C630000   LW V1, 0(V1)
9D000DEC  00621821   ADDU V1, V1, V0
9D000E08  90750000   LBU S5, 0(V1)
9D000E0C  90420000   LBU V0, 0(V0)
9D000E10  02A2A825   OR S5, S5, V0
9D000E94  26020001   ADDIU V0, S0, 1
9D000E98  00021B02   SRL V1, V0, 12
9D000E9C  00031880   SLL V1, V1, 2
9D000EA0  00711821   ADDU V1, V1, S1
9D000EA4  30420FFF   ANDI V0, V0, 4095
9D000EA8  8C630000   LW V1, 0(V1)
9D000EAC  00621821   ADDU V1, V1, V0
9D000EC8  90750000   LBU S5, 0(V1)
9D000ECC  90420000   LBU V0, 0(V0)
9D000ED0  02A2A825   OR S5, S5, V0
9D00147C  26020001   ADDIU V0, S0, 1
9D001480  00021B02   SRL V1, V0, 12
9D001484  00031880   SLL V1, V1, 2
9D001488  00711821   ADDU V1, V1, S1
9D00148C  30420FFF   ANDI V0, V0, 4095
9D001490  8C630000   LW V1, 0(V1)
9D001494  00621821   ADDU V1, V1, V0
9D0014B0  90640000   LBU A0, 0(V1)
9D0014B4  90420000   LBU V0, 0(V0)
9D0014B8  00822025   OR A0, A0, V0
9D0015D8  26020001   ADDIU V0, S0, 1
9D0015E0  00021B02   SRL V1, V0, 12
9D0015E4  00031880   SLL V1, V1, 2
9D0015E8  00711821   ADDU V1, V1, S1
9D0015EC  30420FFF   ANDI V0, V0, 4095
9D0015F0  8C630000   LW V1, 0(V1)
9D0015F4  00621821   ADDU V1, V1, V0
9D001610  90750000   LBU S5, 0(V1)
9D001614  90420000   LBU V0, 0(V0)
9D001618  02A2A825   OR S5, S5, V0
9D001724  26020001   ADDIU V0, S0, 1
9D001728  00021B02   SRL V1, V0, 12
9D00172C  00031880   SLL V1, V1, 2
9D001730  00711821   ADDU V1, V1, S1
9D001734  30420FFF   ANDI V0, V0, 4095
9D001738  8C630000   LW V1, 0(V1)
9D00173C  00621821   ADDU V1, V1, V0
9D001758  90640000   LBU A0, 0(V1)
9D00175C  90420000   LBU V0, 0(V0)
9D001760  00822025   OR A0, A0, V0
9D001808  26020001   ADDIU V0, S0, 1
9D001810  00021B02   SRL V1, V0, 12
9D001814  00031880   SLL V1, V1, 2
9D001818  00711821   ADDU V1, V1, S1
9D00181C  30420FFF   ANDI V0, V0, 4095
9D001820  8C630000   LW V1, 0(V1)
9D001824  00621821   ADDU V1, V1, V0
9D001840  90750000   LBU S5, 0(V1)
9D001844  90420000   LBU V0, 0(V0)
9D001848  02A2A825   OR S5, S5, V0
9D0018D0  26020001   ADDIU V0, S0, 1
9D0018D8  00021B02   SRL V1, V0, 12
9D0018DC  00031880   SLL V1, V1, 2
9D0018E0  00711821   ADDU V1, V1, S1
9D0018E4  30420FFF   ANDI V0, V0, 4095
9D0018E8  8C630000   LW V1, 0(V1)
9D0018EC  00621821   ADDU V1, V1, V0
9D001908  90750000   LBU S5, 0(V1)
9D00190C  90420000   LBU V0, 0(V0)
9D001910  02A2A825   OR S5, S5, V0
9D0019E0  00021B02   SRL V1, V0, 12
9D0019E4  00031880   SLL V1, V1, 2
9D0019E8  00711821   ADDU V1, V1, S1
9D0019EC  30420FFF   ANDI V0, V0, 4095
9D0019F0  8C630000   LW V1, 0(V1)
9D0019F4  00621821   ADDU V1, V1, V0
9D001A10  90720000   LBU S2, 0(V1)
9D001A14  90420000   LBU V0, 0(V0)
9D001A18  02429025   OR S2, S2, V0
9D001A1C  325200FF   ANDI S2, S2, 255
9D00207C  26020001   ADDIU V0, S0, 1
9D002084  00021B02   SRL V1, V0, 12
9D002088  00031880   SLL V1, V1, 2
9D00208C  00711821   ADDU V1, V1, S1
9D002090  30420FFF   ANDI V0, V0, 4095
9D002094  8C630000   LW V1, 0(V1)
9D002098  00621821   ADDU V1, V1, V0
9D0020B4  90640000   LBU A0, 0(V1)
9D0020B8  90420000   LBU V0, 0(V0)
9D0020BC  00822025   OR A0, A0, V0
9D00212C  26020001   ADDIU V0, S0, 1
9D002134  00021B02   SRL V1, V0, 12
9D002138  00031880   SLL V1, V1, 2
9D00213C  00711821   ADDU V1, V1, S1
9D002140  30420FFF   ANDI V0, V0, 4095
9D002144  8C630000   LW V1, 0(V1)
9D002148  00621821   ADDU V1, V1, V0
9D002164  90640000   LBU A0, 0(V1)
9D002168  90420000   LBU V0, 0(V0)
9D00216C  00822025   OR A0, A0, V0
9D0021E0  26020001   ADDIU V0, S0, 1
9D0021E4  00021B02   SRL V1, V0, 12
9D0021E8  00031880   SLL V1, V1, 2
9D0021EC  00711821   ADDU V1, V1, S1
9D0021F0  30420FFF   ANDI V0, V0, 4095
9D0021F4  8C630000   LW V1, 0(V1)
9D0021F8  00621821   ADDU V1, V1, V0
9D002214  90750000   LBU S5, 0(V1)
9D002218  90420000   LBU V0, 0(V0)
9D00221C  02A2A825   OR S5, S5, V0
9D0022B0  26020001   ADDIU V0, S0, 1
9D0022B4  00021B02   SRL V1, V0, 12
9D0022B8  00031880   SLL V1, V1, 2
9D0022BC  00711821   ADDU V1, V1, S1
9D0022C0  30420FFF   ANDI V0, V0, 4095
9D0022C4  8C630000   LW V1, 0(V1)
9D0022C8  00621821   ADDU V1, V1, V0
9D0022E4  90750000   LBU S5, 0(V1)
9D0022E8  90420000   LBU V0, 0(V0)
9D0022EC  02A2A825   OR S5, S5, V0
9D002850  26020001   ADDIU V0, S0, 1
9D002854  00021B02   SRL V1, V0, 12
9D002858  00031880   SLL V1, V1, 2
9D00285C  00711821   ADDU V1, V1, S1
9D002860  30420FFF   ANDI V0, V0, 4095
9D002864  8C630000   LW V1, 0(V1)
9D002868  00621821   ADDU V1, V1, V0
9D002884  90640000   LBU A0, 0(V1)
9D002888  90420000   LBU V0, 0(V0)
9D00288C  00822025   OR A0, A0, V0
9D00293C  26020001   ADDIU V0, S0, 1
9D002944  00021B02   SRL V1, V0, 12
9D002948  00031880   SLL V1, V1, 2
9D00294C  00711821   ADDU V1, V1, S1
9D002950  30420FFF   ANDI V0, V0, 4095
9D002954  8C630000   LW V1, 0(V1)
9D002958  00621821   ADDU V1, V1, V0
9D002974  90750000   LBU S5, 0(V1)
9D002978  90420000   LBU V0, 0(V0)
9D00297C  02A2A825   OR S5, S5, V0
9D002A24  26020001   ADDIU V0, S0, 1
9D002A28  00021B02   SRL V1, V0, 12
9D002A2C  00031880   SLL V1, V1, 2
9D002A30  00711821   ADDU V1, V1, S1
9D002A34  30420FFF   ANDI V0, V0, 4095
9D002A38  8C630000   LW V1, 0(V1)
9D002A3C  00621821   ADDU V1, V1, V0
9D002A58  90640000   LBU A0, 0(V1)
9D002A5C  90420000   LBU V0, 0(V0)
9D002A60  00822025   OR A0, A0, V0
9D002B08  26020001   ADDIU V0, S0, 1
9D002B10  00021B02   SRL V1, V0, 12
9D002B14  00031880   SLL V1, V1, 2
9D002B18  00711821   ADDU V1, V1, S1
9D002B1C  30420FFF   ANDI V0, V0, 4095
9D002B20  8C630000   LW V1, 0(V1)
9D002B24  00621821   ADDU V1, V1, V0
9D002B40  90750000   LBU S5, 0(V1)
9D002B44  90420000   LBU V0, 0(V0)
9D002B48  02A2A825   OR S5, S5, V0
9D002BE0  26020001   ADDIU V0, S0, 1
9D002BE8  00021B02   SRL V1, V0, 12
9D002BEC  00031880   SLL V1, V1, 2
9D002BF0  00711821   ADDU V1, V1, S1
9D002BF4  30420FFF   ANDI V0, V0, 4095
9D002BF8  8C630000   LW V1, 0(V1)
9D002BFC  00621821   ADDU V1, V1, V0
9D002C18  90750000   LBU S5, 0(V1)
9D002C1C  90420000   LBU V0, 0(V0)
9D002C20  02A2A825   OR S5, S5, V0
9D002DC0  90520FFF   LBU S2, 4095(V0)
9D002DC4  90420FFE   LBU V0, 4094(V0)
9D002DC8  02429025   OR S2, S2, V0
9D003360  26020001   ADDIU V0, S0, 1
9D003364  00021B02   SRL V1, V0, 12
9D003368  00031880   SLL V1, V1, 2
9D00336C  00711821   ADDU V1, V1, S1
9D003370  30420FFF   ANDI V0, V0, 4095
9D003374  8C630000   LW V1, 0(V1)
9D003378  00621821   ADDU V1, V1, V0
9D003394  90720000   LBU S2, 0(V1)
9D003398  90420000   LBU V0, 0(V0)
9D00339C  02429025   OR S2, S2, V0
9D0033A0  325200FF   ANDI S2, S2, 255
9D0033E0  26020001   ADDIU V0, S0, 1
9D0033E8  00021B02   SRL V1, V0, 12
9D0033EC  00031880   SLL V1, V1, 2
9D0033F0  00711821   ADDU V1, V1, S1
9D0033F4  30420FFF   ANDI V0, V0, 4095
9D0033F8  8C630000   LW V1, 0(V1)
9D0033FC  00621821   ADDU V1, V1, V0
9D003418  90640000   LBU A0, 0(V1)
9D00341C  90420000   LBU V0, 0(V0)
9D003420  00822025   OR A0, A0, V0
9D003494  26020001   ADDIU V0, S0, 1
9D003498  00021B02   SRL V1, V0, 12
9D00349C  00031880   SLL V1, V1, 2
9D0034A0  00711821   ADDU V1, V1, S1
9D0034A4  30420FFF   ANDI V0, V0, 4095
9D0034A8  8C630000   LW V1, 0(V1)
9D0034AC  00621821   ADDU V1, V1, V0
9D0034C8  90750000   LBU S5, 0(V1)
9D0034CC  90420000   LBU V0, 0(V0)
9D0034D0  02A2A825   OR S5, S5, V0
9D003550  26020001   ADDIU V0, S0, 1
9D003554  00021B02   SRL V1, V0, 12
9D003558  00031880   SLL V1, V1, 2
9D00355C  00711821   ADDU V1, V1, S1
9D003560  30420FFF   ANDI V0, V0, 4095
9D003564  8C630000   LW V1, 0(V1)
9D003568  00621821   ADDU V1, V1, V0
9D003584  90750000   LBU S5, 0(V1)
9D003588  90420000   LBU V0, 0(V0)
9D00358C  02A2A825   OR S5, S5, V0
9D003B0C  90700FFF   LBU S0, 4095(V1)
9D003B10  90630FFE   LBU V1, 4094(V1)
9D003B14  02038025   OR S0, S0, V1
9D003B80  26020001   ADDIU V0, S0, 1
9D003B84  00021B02   SRL V1, V0, 12
9D003B88  00031880   SLL V1, V1, 2
9D003B8C  00711821   ADDU V1, V1, S1
9D003B90  30420FFF   ANDI V0, V0, 4095
9D003B94  8C630000   LW V1, 0(V1)
9D003B98  00621821   ADDU V1, V1, V0
9D003BB4  90640000   LBU A0, 0(V1)
9D003BB8  90420000   LBU V0, 0(V0)
9D003BBC  00822025   OR A0, A0, V0
9D003C68  26020001   ADDIU V0, S0, 1
9D003C70  00021B02   SRL V1, V0, 12
9D003C74  00031880   SLL V1, V1, 2
9D003C78  00711821   ADDU V1, V1, S1
9D003C7C  30420FFF   ANDI V0, V0, 4095
9D003C80  8C630000   LW V1, 0(V1)
9D003C84  00621821   ADDU V1, V1, V0
9D003CA0  90750000   LBU S5, 0(V1)
9D003CA4  90420000   LBU V0, 0(V0)
9D003CA8  02A2A825   OR S5, S5, V0
9D003D40  26020001   ADDIU V0, S0, 1
9D003D44  00021B02   SRL V1, V0, 12
9D003D48  00031880   SLL V1, V1, 2
9D003D4C  00711821   ADDU V1, V1, S1
9D003D50  30420FFF   ANDI V0, V0, 4095
9D003D54  8C630000   LW V1, 0(V1)
9D003D58  00621821   ADDU V1, V1, V0
9D003D74  90640000   LBU A0, 0(V1)
9D003D78  90420000   LBU V0, 0(V0)
9D003D7C  00822025   OR A0, A0, V0
9D003E24  26020001   ADDIU V0, S0, 1
9D003E2C  00021B02   SRL V1, V0, 12
9D003E30  00031880   SLL V1, V1, 2
9D003E34  00711821   ADDU V1, V1, S1
9D003E38  30420FFF   ANDI V0, V0, 4095
9D003E3C  8C630000   LW V1, 0(V1)
9D003E40  00621821   ADDU V1, V1, V0
9D003E5C  90750000   LBU S5, 0(V1)
9D003E60  90420000   LBU V0, 0(V0)
9D003E64  02A2A825   OR S5, S5, V0
9D003EE8  26020001   ADDIU V0, S0, 1
9D003EF0  00021B02   SRL V1, V0, 12
9D003EF4  00031880   SLL V1, V1, 2
9D003EF8  00711821   ADDU V1, V1, S1
9D003EFC  30420FFF   ANDI V0, V0, 4095
9D003F00  8C630000   LW V1, 0(V1)
9D003F04  00621821   ADDU V1, V1, V0
9D003F20  90750000   LBU S5, 0(V1)
9D003F24  90420000   LBU V0, 0(V0)
9D003F28  02A2A825   OR S5, S5, V0
9D004684  26020001   ADDIU V0, S0, 1
9D004688  00021B02   SRL V1, V0, 12
9D00468C  00031880   SLL V1, V1, 2
9D004690  00711821   ADDU V1, V1, S1
9D004694  30420FFF   ANDI V0, V0, 4095
9D004698  8C630000   LW V1, 0(V1)
9D00469C  00621821   ADDU V1, V1, V0
9D0046B8  90630000   LBU V1, 0(V1)
9D0046BC  90420000   LBU V0, 0(V0)
9D0046C0  00621025   OR V0, V1, V0
9D0046C4  304200FF   ANDI V0, V0, 255
9D0046EC  00621821   ADDU V1, V1, V0
9D0046F0  90720001   LBU S2, 1(V1)
9D0046F4  90620000   LBU V0, 0(V1)
9D0046F8  02429025   OR S2, S2, V0
9D00474C  26020001   ADDIU V0, S0, 1
9D004754  00021B02   SRL V1, V0, 12
9D004758  00031880   SLL V1, V1, 2
9D00475C  00711821   ADDU V1, V1, S1
9D004760  30420FFF   ANDI V0, V0, 4095
9D004764  8C630000   LW V1, 0(V1)
9D004768  00621821   ADDU V1, V1, V0
9D004784  90640000   LBU A0, 0(V1)
9D004788  90420000   LBU V0, 0(V0)
9D00478C  00822025   OR A0, A0, V0
9D004824  26020001   ADDIU V0, S0, 1
9D004828  00021B02   SRL V1, V0, 12
9D00482C  00031880   SLL V1, V1, 2
9D004830  00711821   ADDU V1, V1, S1
9D004834  30420FFF   ANDI V0, V0, 4095
9D004838  8C630000   LW V1, 0(V1)
9D00483C  00621821   ADDU V1, V1, V0
9D004858  90750000   LBU S5, 0(V1)
9D00485C  90420000   LBU V0, 0(V0)
9D004860  02A2A825   OR S5, S5, V0
9D0048EC  26020001   ADDIU V0, S0, 1
9D0048F0  00021B02   SRL V1, V0, 12
9D0048F4  00031880   SLL V1, V1, 2
9D0048F8  00711821   ADDU V1, V1, S1
9D0048FC  30420FFF   ANDI V0, V0, 4095
9D004900  8C630000   LW V1, 0(V1)
9D004904  00621821   ADDU V1, V1, V0
9D004920  90730000   LBU S3, 0(V1)
9D004924  90420000   LBU V0, 0(V0)
9D004928  02629825   OR S3, S3, V0
9D004F50  26020001   ADDIU V0, S0, 1
9D004F54  00021B02   SRL V1, V0, 12
9D004F58  00031880   SLL V1, V1, 2
9D004F5C  00711821   ADDU V1, V1, S1
9D004F60  30420FFF   ANDI V0, V0, 4095
9D004F64  8C630000   LW V1, 0(V1)
9D004F68  00621821   ADDU V1, V1, V0
9D004F84  90640000   LBU A0, 0(V1)
9D004F88  90420000   LBU V0, 0(V0)
9D004F8C  00822025   OR A0, A0, V0
9D00505C  26020001   ADDIU V0, S0, 1
9D005064  00021B02   SRL V1, V0, 12
9D005068  00031880   SLL V1, V1, 2
9D00506C  00711821   ADDU V1, V1, S1
9D005070  30420FFF   ANDI V0, V0, 4095
9D005074  8C630000   LW V1, 0(V1)
9D005078  00621821   ADDU V1, V1, V0
9D005094  90730000   LBU S3, 0(V1)
9D005098  90420000   LBU V0, 0(V0)
9D00509C  02629825   OR S3, S3, V0
9D00516C  26020001   ADDIU V0, S0, 1
9D005170  00021B02   SRL V1, V0, 12
9D005174  00031880   SLL V1, V1, 2
9D005178  00711821   ADDU V1, V1, S1
9D00517C  30420FFF   ANDI V0, V0, 4095
9D005180  8C630000   LW V1, 0(V1)
9D005184  00621821   ADDU V1, V1, V0
9D0051A0  90640000   LBU A0, 0(V1)
9D0051A4  90420000   LBU V0, 0(V0)
9D0051A8  00822025   OR A0, A0, V0
9D005274  26020001   ADDIU V0, S0, 1
9D00527C  00021B02   SRL V1, V0, 12
9D005280  00031880   SLL V1, V1, 2
9D005284  00711821   ADDU V1, V1, S1
9D005288  30420FFF   ANDI V0, V0, 4095
9D00528C  8C630000   LW V1, 0(V1)
9D005290  00621821   ADDU V1, V1, V0
9D0052AC  90750000   LBU S5, 0(V1)
9D0052B0  90420000   LBU V0, 0(V0)
9D0052B4  02A2A825   OR S5, S5, V0
9D005344  26020001   ADDIU V0, S0, 1
9D00534C  00021B02   SRL V1, V0, 12
9D005350  00031880   SLL V1, V1, 2
9D005354  00711821   ADDU V1, V1, S1
9D005358  30420FFF   ANDI V0, V0, 4095
9D00535C  8C630000   LW V1, 0(V1)
9D005360  00621821   ADDU V1, V1, V0
9D00537C  90730000   LBU S3, 0(V1)
9D005380  90420000   LBU V0, 0(V0)
9D005384  02629825   OR S3, S3, V0
9D005938  26020001   ADDIU V0, S0, 1
9D005940  00021B02   SRL V1, V0, 12
9D005944  00031880   SLL V1, V1, 2
9D005948  00711821   ADDU V1, V1, S1
9D00594C  30420FFF   ANDI V0, V0, 4095
9D005950  8C630000   LW V1, 0(V1)
9D005954  00621821   ADDU V1, V1, V0
9D005970  90640000   LBU A0, 0(V1)
9D005974  90420000   LBU V0, 0(V0)
9D005978  00822025   OR A0, A0, V0
9D0059D4  26020001   ADDIU V0, S0, 1
9D0059DC  00021B02   SRL V1, V0, 12
9D0059E0  00031880   SLL V1, V1, 2
9D0059E4  00711821   ADDU V1, V1, S1
9D0059E8  30420FFF   ANDI V0, V0, 4095
9D0059EC  8C630000   LW V1, 0(V1)
9D0059F0  00621821   ADDU V1, V1, V0
9D005A0C  90640000   LBU A0, 0(V1)
9D005A10  90420000   LBU V0, 0(V0)
9D005A14  00822025   OR A0, A0, V0
9D005A70  26020001   ADDIU V0, S0, 1
9D005A78  00021B02   SRL V1, V0, 12
9D005A7C  00031880   SLL V1, V1, 2
9D005A80  00711821   ADDU V1, V1, S1
9D005A84  30420FFF   ANDI V0, V0, 4095
9D005A88  8C630000   LW V1, 0(V1)
9D005A8C  00621821   ADDU V1, V1, V0
9D005AA8  90640000   LBU A0, 0(V1)
9D005AAC  90420000   LBU V0, 0(V0)
9D005AB0  00822025   OR A0, A0, V0
9D005B0C  26020001   ADDIU V0, S0, 1
9D005B14  00021B02   SRL V1, V0, 12
9D005B18  00031880   SLL V1, V1, 2
9D005B1C  00711821   ADDU V1, V1, S1
9D005B20  30420FFF   ANDI V0, V0, 4095
9D005B24  8C630000   LW V1, 0(V1)
9D005B28  00621821   ADDU V1, V1, V0
9D005B44  90640000   LBU A0, 0(V1)
9D005B48  90420000   LBU V0, 0(V0)
9D005B4C  00822025   OR A0, A0, V0
9D006028  26020001   ADDIU V0, S0, 1
9D006030  00021B02   SRL V1, V0, 12
9D006034  00031880   SLL V1, V1, 2
9D006038  00711821   ADDU V1, V1, S1
9D00603C  30420FFF   ANDI V0, V0, 4095
9D006040  8C630000   LW V1, 0(V1)
9D006044  00621821   ADDU V1, V1, V0
9D006060  90640000   LBU A0, 0(V1)
9D006064  90420000   LBU V0, 0(V0)
9D006068  00822025   OR A0, A0, V0
9D00612C  26020001   ADDIU V0, S0, 1
9D006134  00021B02   SRL V1, V0, 12
9D006138  00031880   SLL V1, V1, 2
9D00613C  00711821   ADDU V1, V1, S1
9D006140  30420FFF   ANDI V0, V0, 4095
9D006144  8C630000   LW V1, 0(V1)
9D006148  00621821   ADDU V1, V1, V0
9D006164  90640000   LBU A0, 0(V1)
9D006168  90420000   LBU V0, 0(V0)
9D00616C  00822025   OR A0, A0, V0
9D0061E8  26020001   ADDIU V0, S0, 1
9D0061F0  00021B02   SRL V1, V0, 12
9D0061F4  00031880   SLL V1, V1, 2
9D0061F8  00711821   ADDU V1, V1, S1
9D0061FC  30420FFF   ANDI V0, V0, 4095
9D006200  8C630000   LW V1, 0(V1)
9D006204  00621821   ADDU V1, V1, V0
9D006220  90640000   LBU A0, 0(V1)
9D006224  90420000   LBU V0, 0(V0)
9D006228  00822025   OR A0, A0, V0
9D00629C  26020001   ADDIU V0, S0, 1
9D0062A4  00021B02   SRL V1, V0, 12
9D0062A8  00031880   SLL V1, V1, 2
9D0062AC  00711821   ADDU V1, V1, S1
9D0062B0  30420FFF   ANDI V0, V0, 4095
9D0062B4  8C630000   LW V1, 0(V1)
9D0062B8  00621821   ADDU V1, V1, V0
9D0062D4  90640000   LBU A0, 0(V1)
9D0062D8  90420000   LBU V0, 0(V0)
9D0062DC  00822025   OR A0, A0, V0
9D006340  26020001   ADDIU V0, S0, 1
9D006348  00021B02   SRL V1, V0, 12
9D00634C  00031880   SLL V1, V1, 2
9D006350  00711821   ADDU V1, V1, S1
9D006354  30420FFF   ANDI V0, V0, 4095
9D006358  8C630000   LW V1, 0(V1)
9D00635C  00621821   ADDU V1, V1, V0
9D006378  90640000   LBU A0, 0(V1)
9D00637C  90420000   LBU V0, 0(V0)
9D006380  00822025   OR A0, A0, V0
9D0063F4  26020001   ADDIU V0, S0, 1
9D0063FC  00021B02   SRL V1, V0, 12
9D006400  00031880   SLL V1, V1, 2
9D006404  00711821   ADDU V1, V1, S1
9D006408  30420FFF   ANDI V0, V0, 4095
9D00640C  8C630000   LW V1, 0(V1)
9D006410  00621821   ADDU V1, V1, V0
9D00642C  90640000   LBU A0, 0(V1)
9D006430  90420000   LBU V0, 0(V0)
9D006434  00822025   OR A0, A0, V0
9D006B28  26020001   ADDIU V0, S0, 1
9D006B30  00021B02   SRL V1, V0, 12
9D006B34  00031880   SLL V1, V1, 2
9D006B38  00711821   ADDU V1, V1, S1
9D006B3C  30420FFF   ANDI V0, V0, 4095
9D006B40  8C630000   LW V1, 0(V1)
9D006B44  00621821   ADDU V1, V1, V0
9D006B60  90640000   LBU A0, 0(V1)
9D006B64  90420000   LBU V0, 0(V0)
9D006B68  00822025   OR A0, A0, V0
9D006BD8  26020001   ADDIU V0, S0, 1
9D006BE0  00021B02   SRL V1, V0, 12
9D006BE4  00031880   SLL V1, V1, 2
9D006BE8  00711821   ADDU V1, V1, S1
9D006BEC  30420FFF   ANDI V0, V0, 4095
9D006BF0  8C630000   LW V1, 0(V1)
9D006BF4  00621821   ADDU V1, V1, V0
9D006C10  90640000   LBU A0, 0(V1)
9D006C14  90420000   LBU V0, 0(V0)
9D006C18  00822025   OR A0, A0, V0
9D006C88  26020001   ADDIU V0, S0, 1
9D006C90  00021B02   SRL V1, V0, 12
9D006C94  00031880   SLL V1, V1, 2
9D006C98  00711821   ADDU V1, V1, S1
9D006C9C  30420FFF   ANDI V0, V0, 4095
9D006CA0  8C630000   LW V1, 0(V1)
9D006CA4  00621821   ADDU V1, V1, V0
9D006CC0  90640000   LBU A0, 0(V1)
9D006CC4  90420000   LBU V0, 0(V0)
9D006CC8  00822025   OR A0, A0, V0
9D006D38  26020001   ADDIU V0, S0, 1
9D006D40  00021B02   SRL V1, V0, 12
9D006D44  00031880   SLL V1, V1, 2
9D006D48  00711821   ADDU V1, V1, S1
9D006D4C  30420FFF   ANDI V0, V0, 4095
9D006D50  8C630000   LW V1, 0(V1)
9D006D54  00621821   ADDU V1, V1, V0
9D006D70  90640000   LBU A0, 0(V1)
9D006D74  90420000   LBU V0, 0(V0)
9D006D78  00822025   OR A0, A0, V0
9D00731C  26020001   ADDIU V0, S0, 1
9D007320  00021B02   SRL V1, V0, 12
9D007324  00031880   SLL V1, V1, 2
9D007328  00711821   ADDU V1, V1, S1
9D00732C  30420FFF   ANDI V0, V0, 4095
9D007330  8C630000   LW V1, 0(V1)
9D007334  00621821   ADDU V1, V1, V0
9D007350  90640000   LBU A0, 0(V1)
9D007354  90420000   LBU V0, 0(V0)
9D007358  00822025   OR A0, A0, V0
9D007470  26020001   ADDIU V0, S0, 1
9D007474  00021B02   SRL V1, V0, 12
9D007478  00031880   SLL V1, V1, 2
9D00747C  00711821   ADDU V1, V1, S1
9D007480  30420FFF   ANDI V0, V0, 4095
9D007484  8C630000   LW V1, 0(V1)
9D007488  00621821   ADDU V1, V1, V0
9D0074A4  90640000   LBU A0, 0(V1)
9D0074A8  90420000   LBU V0, 0(V0)
9D0074AC  00822025   OR A0, A0, V0
9D00756C  26020001   ADDIU V0, S0, 1
9D007570  00021B02   SRL V1, V0, 12
9D007574  00031880   SLL V1, V1, 2
9D007578  00711821   ADDU V1, V1, S1
9D00757C  30420FFF   ANDI V0, V0, 4095
9D007580  8C630000   LW V1, 0(V1)
9D007584  00621821   ADDU V1, V1, V0
9D0075A0  90640000   LBU A0, 0(V1)
9D0075A4  90420000   LBU V0, 0(V0)
9D0075A8  00822025   OR A0, A0, V0
9D00764C  26020001   ADDIU V0, S0, 1
9D007650  00021B02   SRL V1, V0, 12
9D007654  00031880   SLL V1, V1, 2
9D007658  00711821   ADDU V1, V1, S1
9D00765C  30420FFF   ANDI V0, V0, 4095
9D007660  8C630000   LW V1, 0(V1)
9D007664  00621821   ADDU V1, V1, V0
9D007680  90640000   LBU A0, 0(V1)
9D007684  90420000   LBU V0, 0(V0)
9D007688  00822025   OR A0, A0, V0
9D00772C  26020001   ADDIU V0, S0, 1
9D007730  00021B02   SRL V1, V0, 12
9D007734  00031880   SLL V1, V1, 2
9D007738  00711821   ADDU V1, V1, S1
9D00773C  30420FFF   ANDI V0, V0, 4095
9D007740  8C630000   LW V1, 0(V1)
9D007744  00621821   ADDU V1, V1, V0
9D007760  90640000   LBU A0, 0(V1)
9D007764  90420000   LBU V0, 0(V0)
9D007768  00822025   OR A0, A0, V0
9D007810  26020001   ADDIU V0, S0, 1
9D007814  00021B02   SRL V1, V0, 12
9D007818  00031880   SLL V1, V1, 2
9D00781C  00711821   ADDU V1, V1, S1
9D007820  30420FFF   ANDI V0, V0, 4095
9D007824  8C630000   LW V1, 0(V1)
9D007828  00621821   ADDU V1, V1, V0
9D007844  90640000   LBU A0, 0(V1)
9D007848  90420000   LBU V0, 0(V0)
9D00784C  00822025   OR A0, A0, V0
9D007F50  26020001   ADDIU V0, S0, 1
9D007F58  00021B02   SRL V1, V0, 12
9D007F5C  00031880   SLL V1, V1, 2
9D007F60  00711821   ADDU V1, V1, S1
9D007F64  30420FFF   ANDI V0, V0, 4095
9D007F68  8C630000   LW V1, 0(V1)
9D007F6C  00621821   ADDU V1, V1, V0
9D007F88  90640000   LBU A0, 0(V1)
9D007F8C  90420000   LBU V0, 0(V0)
9D007F90  00822025   OR A0, A0, V0
9D008008  26020001   ADDIU V0, S0, 1
9D008010  00021B02   SRL V1, V0, 12
9D008014  00031880   SLL V1, V1, 2
9D008018  00711821   ADDU V1, V1, S1
9D00801C  30420FFF   ANDI V0, V0, 4095
9D008020  8C630000   LW V1, 0(V1)
9D008024  00621821   ADDU V1, V1, V0
9D008040  90640000   LBU A0, 0(V1)
9D008044  90420000   LBU V0, 0(V0)
9D008048  00822025   OR A0, A0, V0
9D0080BC  26020001   ADDIU V0, S0, 1
9D0080C0  00021B02   SRL V1, V0, 12
9D0080C4  00031880   SLL V1, V1, 2
9D0080C8  00711821   ADDU V1, V1, S1
9D0080CC  30420FFF   ANDI V0, V0, 4095
9D0080D0  8C630000   LW V1, 0(V1)
9D0080D4  00621821   ADDU V1, V1, V0
9D0080F0  90750000   LBU S5, 0(V1)
9D0080F4  90420000   LBU V0, 0(V0)
9D0080F8  02A2A825   OR S5, S5, V0
9D008178  26020001   ADDIU V0, S0, 1
9D00817C  00021B02   SRL V1, V0, 12
9D008180  00031880   SLL V1, V1, 2
9D008184  00711821   ADDU V1, V1, S1
9D008188  30420FFF   ANDI V0, V0, 4095
9D00818C  8C630000   LW V1, 0(V1)
9D008190  00621821   ADDU V1, V1, V0
9D0081AC  90750000   LBU S5, 0(V1)
9D0081B0  90420000   LBU V0, 0(V0)
9D0081B4  02A2A825   OR S5, S5, V0
9D0086DC  26020001   ADDIU V0, S0, 1
9D0086E0  00021B02   SRL V1, V0, 12
9D0086E4  00031880   SLL V1, V1, 2
9D0086E8  00711821   ADDU V1, V1, S1
9D0086EC  30420FFF   ANDI V0, V0, 4095
9D0086F0  8C630000   LW V1, 0(V1)
9D0086F4  00621821   ADDU V1, V1, V0
9D008710  90640000   LBU A0, 0(V1)
9D008714  90420000   LBU V0, 0(V0)
9D008718  00822025   OR A0, A0, V0
9D0087C4  26020001   ADDIU V0, S0, 1
9D0087CC  00021B02   SRL V1, V0, 12
9D0087D0  00031880   SLL V1, V1, 2
9D0087D4  00711821   ADDU V1, V1, S1
9D0087D8  30420FFF   ANDI V0, V0, 4095
9D0087DC  8C630000   LW V1, 0(V1)
9D0087E0  00621821   ADDU V1, V1, V0
9D0087FC  90750000   LBU S5, 0(V1)
9D008800  90420000   LBU V0, 0(V0)
9D008804  02A2A825   OR S5, S5, V0
9D00889C  26020001   ADDIU V0, S0, 1
9D0088A0  00021B02   SRL V1, V0, 12
9D0088A4  00031880   SLL V1, V1, 2
9D0088A8  00711821   ADDU V1, V1, S1
9D0088AC  30420FFF   ANDI V0, V0, 4095
9D0088B0  8C630000   LW V1, 0(V1)
9D0088B4  00621821   ADDU V1, V1, V0
9D0088D0  90640000   LBU A0, 0(V1)
9D0088D4  90420000   LBU V0, 0(V0)
9D0088D8  00822025   OR A0, A0, V0
9D008980  26020001   ADDIU V0, S0, 1
9D008988  00021B02   SRL V1, V0, 12
9D00898C  00031880   SLL V1, V1, 2
9D008990  00711821   ADDU V1, V1, S1
9D008994  30420FFF   ANDI V0, V0, 4095
9D008998  8C630000   LW V1, 0(V1)
9D00899C  00621821   ADDU V1, V1, V0
9D0089B8  90750000   LBU S5, 0(V1)
9D0089BC  90420000   LBU V0, 0(V0)
9D0089C0  02A2A825   OR S5, S5, V0
9D008A44  26020001   ADDIU V0, S0, 1
9D008A4C  00021B02   SRL V1, V0, 12
9D008A50  00031880   SLL V1, V1, 2
9D008A54  00711821   ADDU V1, V1, S1
9D008A58  30420FFF   ANDI V0, V0, 4095
9D008A5C  8C630000   LW V1, 0(V1)
9D008A60  00621821   ADDU V1, V1, V0
9D008A7C  90750000   LBU S5, 0(V1)
9D008A80  90420000   LBU V0, 0(V0)
9D008A84  02A2A825   OR S5, S5, V0
9D009178  26020001   ADDIU V0, S0, 1
9D009180  00021B02   SRL V1, V0, 12
9D009184  00031880   SLL V1, V1, 2
9D009188  00711821   ADDU V1, V1, S1
9D00918C  30420FFF   ANDI V0, V0, 4095
9D009190  8C630000   LW V1, 0(V1)
9D009194  00621821   ADDU V1, V1, V0
9D0091B0  90640000   LBU A0, 0(V1)
9D0091B4  90420000   LBU V0, 0(V0)
9D0091B8  00822025   OR A0, A0, V0
9D00922C  26020001   ADDIU V0, S0, 1
9D009234  00021B02   SRL V1, V0, 12
9D009238  00031880   SLL V1, V1, 2
9D00923C  00711821   ADDU V1, V1, S1
9D009240  30420FFF   ANDI V0, V0, 4095
9D009244  8C630000   LW V1, 0(V1)
9D009248  00621821   ADDU V1, V1, V0
9D009264  90640000   LBU A0, 0(V1)
9D009268  90420000   LBU V0, 0(V0)
9D00926C  00822025   OR A0, A0, V0
9D009308  26020001   ADDIU V0, S0, 1
9D00930C  00021B02   SRL V1, V0, 12
9D009310  00031880   SLL V1, V1, 2
9D009314  00711821   ADDU V1, V1, S1
9D009318  30420FFF   ANDI V0, V0, 4095
9D00931C  8C630000   LW V1, 0(V1)
9D009320  00621821   ADDU V1, V1, V0
9D00933C  90750000   LBU S5, 0(V1)
9D009340  90420000   LBU V0, 0(V0)
9D009344  02A2A825   OR S5, S5, V0
9D0093C4  26020001   ADDIU V0, S0, 1
9D0093C8  00021B02   SRL V1, V0, 12
9D0093CC  00031880   SLL V1, V1, 2
9D0093D0  00711821   ADDU V1, V1, S1
9D0093D4  30420FFF   ANDI V0, V0, 4095
9D0093D8  8C630000   LW V1, 0(V1)
9D0093DC  00621821   ADDU V1, V1, V0
9D0093F8  90730000   LBU S3, 0(V1)
9D0093FC  90420000   LBU V0, 0(V0)
9D009400  02629825   OR S3, S3, V0
9D0099F4  26020001   ADDIU V0, S0, 1
9D0099F8  00021B02   SRL V1, V0, 12
9D0099FC  00031880   SLL V1, V1, 2
9D009A00  00711821   ADDU V1, V1, S1
9D009A04  30420FFF   ANDI V0, V0, 4095
9D009A08  8C630000   LW V1, 0(V1)
9D009A0C  00621821   ADDU V1, V1, V0
9D009A28  90640000   LBU A0, 0(V1)
9D009A2C  90420000   LBU V0, 0(V0)
9D009A30  00822025   OR A0, A0, V0
9D009B00  26020001   ADDIU V0, S0, 1
9D009B08  00021B02   SRL V1, V0, 12
9D009B0C  00031880   SLL V1, V1, 2
9D009B10  00711821   ADDU V1, V1, S1
9D009B14  30420FFF   ANDI V0, V0, 4095
9D009B18  8C630000   LW V1, 0(V1)
9D009B1C  00621821   ADDU V1, V1, V0
9D009B38  90730000   LBU S3, 0(V1)
9D009B3C  90420000   LBU V0, 0(V0)
9D009B40  02629825   OR S3, S3, V0
9D009C00  26020001   ADDIU V0, S0, 1
9D009C04  00021B02   SRL V1, V0, 12
9D009C08  00031880   SLL V1, V1, 2
9D009C0C  00711821   ADDU V1, V1, S1
9D009C10  30420FFF   ANDI V0, V0, 4095
9D009C14  8C630000   LW V1, 0(V1)
9D009C18  00621821   ADDU V1, V1, V0
9D009C34  90640000   LBU A0, 0(V1)
9D009C38  90420000   LBU V0, 0(V0)
9D009C3C  00822025   OR A0, A0, V0
9D009D08  26020001   ADDIU V0, S0, 1
9D009D10  00021B02   SRL V1, V0, 12
9D009D14  00031880   SLL V1, V1, 2
9D009D18  00711821   ADDU V1, V1, S1
9D009D1C  30420FFF   ANDI V0, V0, 4095
9D009D20  8C630000   LW V1, 0(V1)
9D009D24  00621821   ADDU V1, V1, V0
9D009D40  90750000   LBU S5, 0(V1)
9D009D44  90420000   LBU V0, 0(V0)
9D009D48  02A2A825   OR S5, S5, V0
9D009DCC  26020001   ADDIU V0, S0, 1
9D009DD4  00021B02   SRL V1, V0, 12
9D009DD8  00031880   SLL V1, V1, 2
9D009DDC  00711821   ADDU V1, V1, S1
9D009DE0  30420FFF   ANDI V0, V0, 4095
9D009DE4  8C630000   LW V1, 0(V1)
9D009DE8  00621821   ADDU V1, V1, V0
9D009E04  90730000   LBU S3, 0(V1)
9D009E08  90420000   LBU V0, 0(V0)
9D009E0C  02629825   OR S3, S3, V0
9D009FB0  90640FFD   LBU A0, 4093(V1)
9D00A088  90640FFB   LBU A0, 4091(V1)
9D00A1AC  90660FFF   LBU A2, 4095(V1)
9D00A1B0  90630FFE   LBU V1, 4094(V1)
9D00A1B4  00C33025   OR A2, A2, V1
9D00A1B8  30C600FF   ANDI A2, A2, 255
1168:                }
9D0001C4  03E00008   JR RA
9D0001C8  304200FF   ANDI V0, V0, 255
1169:                #else /* !HOST_LITTLE_ENDIAN */
1170:                
1171:                INLINE uint32 zp_readword(register uint8 address)
1172:                {
1173:                #ifdef TARGET_CPU_PPC
1174:                   return __lhbrx(ram, address);
1175:                #else /* !TARGET_CPU_PPC */
1176:                   uint32 x = (uint32) *(uint16 *)(ram + address);
1177:                   return (x << 8) | (x >> 8);
1178:                #endif /* !TARGET_CPU_PPC */
1179:                }
1180:                
1181:                INLINE uint32 bank_readword(register uint32 address)
1182:                {
1183:                #ifdef TARGET_CPU_PPC
1184:                   return __lhbrx(cpu.mem_page[address >> NES6502_BANKSHIFT], address & NES6502_BANKMASK);
1185:                #else /* !TARGET_CPU_PPC */
1186:                   uint32 x = (uint32) *(uint16 *)(cpu.mem_page[address >> NES6502_BANKSHIFT] + (address & NES6502_BANKMASK));
1187:                   return (x << 8) | (x >> 8);
1188:                #endif /* !TARGET_CPU_PPC */
1189:                }
1190:                
1191:                #endif /* !HOST_LITTLE_ENDIAN */
1192:                
1193:                INLINE uint8 bank_readbyte(register uint32 address)
1194:                {
1195:                   return cpu.mem_page[address >> NES6502_BANKSHIFT][address & NES6502_BANKMASK];
9D000030  00041B02   SRL V1, A0, 12
9D0000A8  00041B02   SRL V1, A0, 12
9D0002E8  00041B02   SRL V1, A0, 12
9D0002EC  00031880   SLL V1, V1, 2
9D0002F0  3C02A001   LUI V0, -24575
9D0002F4  24428FD0   ADDIU V0, V0, -28720
9D0002F8  00621021   ADDU V0, V1, V0
9D0002FC  30840FFF   ANDI A0, A0, 4095
9D000300  8C420000   LW V0, 0(V0)
9D000304  00442021   ADDU A0, V0, A0
9D000500  00121B02   SRL V1, S2, 12
9D00062C  00121302   SRL V0, S2, 12
9D00066C  00101B02   SRL V1, S0, 12
9D0006E0  00121302   SRL V0, S2, 12
9D0006E4  00021080   SLL V0, V0, 2
9D0006E8  00511021   ADDU V0, V0, S1
9D0006EC  32520FFF   ANDI S2, S2, 4095
9D0006F0  8C420000   LW V0, 0(V0)
9D0006F4  00521021   ADDU V0, V0, S2
9D000794  00101B02   SRL V1, S0, 12
9D000798  00031880   SLL V1, V1, 2
9D00079C  00711821   ADDU V1, V1, S1
9D0007A0  32020FFF   ANDI V0, S0, 4095
9D0007A4  8C630000   LW V1, 0(V1)
9D0007A8  00621021   ADDU V0, V1, V0
9D000824  00121302   SRL V0, S2, 12
9D000828  00021080   SLL V0, V0, 2
9D00082C  00511021   ADDU V0, V0, S1
9D000830  32520FFF   ANDI S2, S2, 4095
9D000834  8C420000   LW V0, 0(V0)
9D000838  00521021   ADDU V0, V0, S2
9D000884  00121302   SRL V0, S2, 12
9D000888  00021080   SLL V0, V0, 2
9D00088C  00511021   ADDU V0, V0, S1
9D000890  32520FFF   ANDI S2, S2, 4095
9D000894  8C420000   LW V0, 0(V0)
9D000898  00521021   ADDU V0, V0, S2
9D0008B4  00101B02   SRL V1, S0, 12
9D0008B8  00031880   SLL V1, V1, 2
9D0008BC  00711821   ADDU V1, V1, S1
9D0008C0  32020FFF   ANDI V0, S0, 4095
9D0008C4  8C630000   LW V1, 0(V1)
9D0008C8  00621021   ADDU V0, V1, V0
9D000910  00121302   SRL V0, S2, 12
9D000914  00021080   SLL V0, V0, 2
9D000918  00511021   ADDU V0, V0, S1
9D00091C  32520FFF   ANDI S2, S2, 4095
9D000920  8C420000   LW V0, 0(V0)
9D000924  00521021   ADDU V0, V0, S2
9D000948  00101B02   SRL V1, S0, 12
9D00094C  00031880   SLL V1, V1, 2
9D000950  00711821   ADDU V1, V1, S1
9D000954  32020FFF   ANDI V0, S0, 4095
9D000958  8C630000   LW V1, 0(V1)
9D00095C  00621021   ADDU V0, V1, V0
9D0009A8  00121302   SRL V0, S2, 12
9D0009AC  00021080   SLL V0, V0, 2
9D0009B0  00511021   ADDU V0, V0, S1
9D0009B4  32520FFF   ANDI S2, S2, 4095
9D0009B8  8C420000   LW V0, 0(V0)
9D0009BC  00521021   ADDU V0, V0, S2
9D0009DC  00101B02   SRL V1, S0, 12
9D0009E0  00031880   SLL V1, V1, 2
9D0009E4  00711821   ADDU V1, V1, S1
9D0009E8  32020FFF   ANDI V0, S0, 4095
9D0009EC  8C630000   LW V1, 0(V1)
9D0009F0  00621021   ADDU V0, V1, V0
9D000A48  00121302   SRL V0, S2, 12
9D000A4C  00021080   SLL V0, V0, 2
9D000A50  00511021   ADDU V0, V0, S1
9D000A54  32520FFF   ANDI S2, S2, 4095
9D000A58  8C420000   LW V0, 0(V0)
9D000A5C  00521021   ADDU V0, V0, S2
9D000B1C  00102302   SRL A0, S0, 12
9D000B20  00042080   SLL A0, A0, 2
9D000B24  00912021   ADDU A0, A0, S1
9D000B28  32020FFF   ANDI V0, S0, 4095
9D000B2C  8C840000   LW A0, 0(A0)
9D000B30  00821021   ADDU V0, A0, V0
9D000B54  00101B02   SRL V1, S0, 12
9D000B58  00031880   SLL V1, V1, 2
9D000B5C  00711821   ADDU V1, V1, S1
9D000B60  32020FFF   ANDI V0, S0, 4095
9D000B64  8C630000   LW V1, 0(V1)
9D000B68  00621021   ADDU V0, V1, V0
9D000BA4  00121302   SRL V0, S2, 12
9D000BA8  00021080   SLL V0, V0, 2
9D000BAC  00511021   ADDU V0, V0, S1
9D000BB0  32520FFF   ANDI S2, S2, 4095
9D000BB4  8C420000   LW V0, 0(V0)
9D000BB8  00521021   ADDU V0, V0, S2
9D000C10  00101B02   SRL V1, S0, 12
9D000C14  00031880   SLL V1, V1, 2
9D000C18  00711821   ADDU V1, V1, S1
9D000C1C  32020FFF   ANDI V0, S0, 4095
9D000C20  8C630000   LW V1, 0(V1)
9D000C24  00621021   ADDU V0, V1, V0
9D000C4C  00101B02   SRL V1, S0, 12
9D000C50  00031880   SLL V1, V1, 2
9D000C54  00711821   ADDU V1, V1, S1
9D000C58  32020FFF   ANDI V0, S0, 4095
9D000C5C  8C630000   LW V1, 0(V1)
9D000C60  00621021   ADDU V0, V1, V0
9D000C9C  00121302   SRL V0, S2, 12
9D000CA0  00021080   SLL V0, V0, 2
9D000CA4  00511021   ADDU V0, V0, S1
9D000CA8  32520FFF   ANDI S2, S2, 4095
9D000CAC  8C420000   LW V0, 0(V0)
9D000CB0  00521021   ADDU V0, V0, S2
9D000CF4  00121302   SRL V0, S2, 12
9D000CF8  00021080   SLL V0, V0, 2
9D000CFC  00511021   ADDU V0, V0, S1
9D000D00  32520FFF   ANDI S2, S2, 4095
9D000D04  8C420000   LW V0, 0(V0)
9D000D08  00521021   ADDU V0, V0, S2
9D000DA0  00121302   SRL V0, S2, 12
9D000DA4  00021080   SLL V0, V0, 2
9D000DA8  00511021   ADDU V0, V0, S1
9D000DAC  32520FFF   ANDI S2, S2, 4095
9D000DB0  8C420000   LW V0, 0(V0)
9D000DB4  00521021   ADDU V0, V0, S2
9D000E64  00121302   SRL V0, S2, 12
9D000E68  00021080   SLL V0, V0, 2
9D000E6C  00511021   ADDU V0, V0, S1
9D000E70  32520FFF   ANDI S2, S2, 4095
9D000E74  8C420000   LW V0, 0(V0)
9D000E78  00521021   ADDU V0, V0, S2
9D000F30  00121302   SRL V0, S2, 12
9D000F34  00021080   SLL V0, V0, 2
9D000F38  00511021   ADDU V0, V0, S1
9D000F3C  32520FFF   ANDI S2, S2, 4095
9D000F40  8C420000   LW V0, 0(V0)
9D000F44  00521021   ADDU V0, V0, S2
9D000F70  00101B02   SRL V1, S0, 12
9D000F74  00031880   SLL V1, V1, 2
9D000F78  00711821   ADDU V1, V1, S1
9D000F7C  32100FFF   ANDI S0, S0, 4095
9D000F80  8C630000   LW V1, 0(V1)
9D000F84  00701821   ADDU V1, V1, S0
9D000FFC  00121302   SRL V0, S2, 12
9D001000  00021080   SLL V0, V0, 2
9D001004  00511021   ADDU V0, V0, S1
9D001008  32520FFF   ANDI S2, S2, 4095
9D00100C  8C420000   LW V0, 0(V0)
9D001010  00521021   ADDU V0, V0, S2
9D001028  00101B02   SRL V1, S0, 12
9D00102C  00031880   SLL V1, V1, 2
9D001030  00711821   ADDU V1, V1, S1
9D001034  32020FFF   ANDI V0, S0, 4095
9D001038  8C630000   LW V1, 0(V1)
9D00103C  00621021   ADDU V0, V1, V0
9D0010CC  00121302   SRL V0, S2, 12
9D0010D0  00021080   SLL V0, V0, 2
9D0010D4  00511021   ADDU V0, V0, S1
9D0010D8  32520FFF   ANDI S2, S2, 4095
9D0010DC  8C420000   LW V0, 0(V0)
9D0010E0  00521021   ADDU V0, V0, S2
9D001104  00101B02   SRL V1, S0, 12
9D001108  00031880   SLL V1, V1, 2
9D00110C  00711821   ADDU V1, V1, S1
9D001110  32020FFF   ANDI V0, S0, 4095
9D001114  8C630000   LW V1, 0(V1)
9D001118  00621021   ADDU V0, V1, V0
9D001198  00121302   SRL V0, S2, 12
9D00119C  00021080   SLL V0, V0, 2
9D0011A0  00511021   ADDU V0, V0, S1
9D0011A4  32520FFF   ANDI S2, S2, 4095
9D0011A8  8C420000   LW V0, 0(V0)
9D0011AC  00521021   ADDU V0, V0, S2
9D001210  00121302   SRL V0, S2, 12
9D001214  00021080   SLL V0, V0, 2
9D001218  00511021   ADDU V0, V0, S1
9D00121C  32520FFF   ANDI S2, S2, 4095
9D001220  8C420000   LW V0, 0(V0)
9D001224  00529021   ADDU S2, V0, S2
9D001240  00101B02   SRL V1, S0, 12
9D001244  00031880   SLL V1, V1, 2
9D001248  00711821   ADDU V1, V1, S1
9D00124C  32020FFF   ANDI V0, S0, 4095
9D001250  8C630000   LW V1, 0(V1)
9D001254  00621021   ADDU V0, V1, V0
9D0012A4  00121302   SRL V0, S2, 12
9D0012A8  00021080   SLL V0, V0, 2
9D0012AC  00511021   ADDU V0, V0, S1
9D0012B0  32520FFF   ANDI S2, S2, 4095
9D0012B4  8C420000   LW V0, 0(V0)
9D0012B8  00521021   ADDU V0, V0, S2
9D0012DC  00101B02   SRL V1, S0, 12
9D0012E0  00031880   SLL V1, V1, 2
9D0012E4  00711821   ADDU V1, V1, S1
9D0012E8  32020FFF   ANDI V0, S0, 4095
9D0012EC  8C630000   LW V1, 0(V1)
9D0012F0  00621021   ADDU V0, V1, V0
9D001344  00121302   SRL V0, S2, 12
9D001348  00021080   SLL V0, V0, 2
9D00134C  00511021   ADDU V0, V0, S1
9D001350  32520FFF   ANDI S2, S2, 4095
9D001354  8C420000   LW V0, 0(V0)
9D001358  00521021   ADDU V0, V0, S2
9D001378  00101B02   SRL V1, S0, 12
9D00137C  00031880   SLL V1, V1, 2
9D001380  00711821   ADDU V1, V1, S1
9D001384  32020FFF   ANDI V0, S0, 4095
9D001388  8C630000   LW V1, 0(V1)
9D00138C  00621021   ADDU V0, V1, V0
9D0013EC  00121302   SRL V0, S2, 12
9D0013F0  00021080   SLL V0, V0, 2
9D0013F4  00511021   ADDU V0, V0, S1
9D0013F8  32520FFF   ANDI S2, S2, 4095
9D0013FC  8C420000   LW V0, 0(V0)
9D001400  00521021   ADDU V0, V0, S2
9D001448  00101B02   SRL V1, S0, 12
9D00144C  00031880   SLL V1, V1, 2
9D001450  00711821   ADDU V1, V1, S1
9D001454  32020FFF   ANDI V0, S0, 4095
9D001458  8C630000   LW V1, 0(V1)
9D00145C  00621021   ADDU V0, V1, V0
9D001530  00121302   SRL V0, S2, 12
9D001534  00021080   SLL V0, V0, 2
9D001538  00511021   ADDU V0, V0, S1
9D00153C  32520FFF   ANDI S2, S2, 4095
9D001540  8C420000   LW V0, 0(V0)
9D001544  00521021   ADDU V0, V0, S2
9D0015A8  00101B02   SRL V1, S0, 12
9D0015AC  00031880   SLL V1, V1, 2
9D0015B0  00711821   ADDU V1, V1, S1
9D0015B4  32020FFF   ANDI V0, S0, 4095
9D0015B8  8C630000   LW V1, 0(V1)
9D0015BC  00621021   ADDU V0, V1, V0
9D001680  00121302   SRL V0, S2, 12
9D001684  00021080   SLL V0, V0, 2
9D001688  00511021   ADDU V0, V0, S1
9D00168C  32520FFF   ANDI S2, S2, 4095
9D001690  8C420000   LW V0, 0(V0)
9D001694  00521021   ADDU V0, V0, S2
9D0016F8  00121302   SRL V0, S2, 12
9D0016FC  00021080   SLL V0, V0, 2
9D001700  00511021   ADDU V0, V0, S1
9D001704  32520FFF   ANDI S2, S2, 4095
9D001708  8C420000   LW V0, 0(V0)
9D00170C  00529021   ADDU S2, V0, S2
9D0017D4  00121302   SRL V0, S2, 12
9D0017D8  00021080   SLL V0, V0, 2
9D0017DC  00511021   ADDU V0, V0, S1
9D0017E0  32520FFF   ANDI S2, S2, 4095
9D0017E4  8C420000   LW V0, 0(V0)
9D0017E8  00521021   ADDU V0, V0, S2
9D0018A0  00121302   SRL V0, S2, 12
9D0018A4  00021080   SLL V0, V0, 2
9D0018A8  00511021   ADDU V0, V0, S1
9D0018AC  32520FFF   ANDI S2, S2, 4095
9D0018B0  8C420000   LW V0, 0(V0)
9D0018B4  00521021   ADDU V0, V0, S2
9D001974  00121302   SRL V0, S2, 12
9D001978  00021080   SLL V0, V0, 2
9D00197C  00511021   ADDU V0, V0, S1
9D001980  32520FFF   ANDI S2, S2, 4095
9D001984  8C420000   LW V0, 0(V0)
9D001988  00521021   ADDU V0, V0, S2
9D001A40  8E220000   LW V0, 0(S1)
9D001A44  00529021   ADDU S2, V0, S2
9D001A60  00101B02   SRL V1, S0, 12
9D001A64  00031880   SLL V1, V1, 2
9D001A68  00711821   ADDU V1, V1, S1
9D001A6C  32020FFF   ANDI V0, S0, 4095
9D001A70  8C630000   LW V1, 0(V1)
9D001A74  00621021   ADDU V0, V1, V0
9D001AD4  00121302   SRL V0, S2, 12
9D001AD8  00021080   SLL V0, V0, 2
9D001ADC  00511021   ADDU V0, V0, S1
9D001AE0  32520FFF   ANDI S2, S2, 4095
9D001AE4  8C420000   LW V0, 0(V0)
9D001AE8  00521021   ADDU V0, V0, S2
9D001B0C  00101B02   SRL V1, S0, 12
9D001B10  00031880   SLL V1, V1, 2
9D001B14  00711821   ADDU V1, V1, S1
9D001B18  32020FFF   ANDI V0, S0, 4095
9D001B1C  8C630000   LW V1, 0(V1)
9D001B20  00621021   ADDU V0, V1, V0
9D001BA4  00121302   SRL V0, S2, 12
9D001BA8  00021080   SLL V0, V0, 2
9D001BAC  00511021   ADDU V0, V0, S1
9D001BB0  32520FFF   ANDI S2, S2, 4095
9D001BB4  8C420000   LW V0, 0(V0)
9D001BB8  00521021   ADDU V0, V0, S2
9D001BE0  00101B02   SRL V1, S0, 12
9D001BE4  00031880   SLL V1, V1, 2
9D001BE8  00711821   ADDU V1, V1, S1
9D001BEC  32020FFF   ANDI V0, S0, 4095
9D001BF0  8C630000   LW V1, 0(V1)
9D001BF4  00621021   ADDU V0, V1, V0
9D001C38  00121302   SRL V0, S2, 12
9D001C3C  00021080   SLL V0, V0, 2
9D001C40  00511021   ADDU V0, V0, S1
9D001C44  32520FFF   ANDI S2, S2, 4095
9D001C48  8C420000   LW V0, 0(V0)
9D001C4C  00521021   ADDU V0, V0, S2
9D001C68  00101B02   SRL V1, S0, 12
9D001C6C  00031880   SLL V1, V1, 2
9D001C70  00711821   ADDU V1, V1, S1
9D001C74  32020FFF   ANDI V0, S0, 4095
9D001C78  8C630000   LW V1, 0(V1)
9D001C7C  00621021   ADDU V0, V1, V0
9D001CC0  00121302   SRL V0, S2, 12
9D001CC4  00021080   SLL V0, V0, 2
9D001CC8  00511021   ADDU V0, V0, S1
9D001CCC  32520FFF   ANDI S2, S2, 4095
9D001CD0  8C420000   LW V0, 0(V0)
9D001CD4  00521021   ADDU V0, V0, S2
9D001CF8  00101B02   SRL V1, S0, 12
9D001CFC  00031880   SLL V1, V1, 2
9D001D00  00711821   ADDU V1, V1, S1
9D001D04  32020FFF   ANDI V0, S0, 4095
9D001D08  8C630000   LW V1, 0(V1)
9D001D0C  00621021   ADDU V0, V1, V0
9D001D60  00121302   SRL V0, S2, 12
9D001D64  00021080   SLL V0, V0, 2
9D001D68  00511021   ADDU V0, V0, S1
9D001D6C  32520FFF   ANDI S2, S2, 4095
9D001D70  8C420000   LW V0, 0(V0)
9D001D74  00521021   ADDU V0, V0, S2
9D001D98  00101B02   SRL V1, S0, 12
9D001D9C  00031880   SLL V1, V1, 2
9D001DA0  00711821   ADDU V1, V1, S1
9D001DA4  32020FFF   ANDI V0, S0, 4095
9D001DA8  8C630000   LW V1, 0(V1)
9D001DAC  00621021   ADDU V0, V1, V0
9D001E08  00121302   SRL V0, S2, 12
9D001E0C  00021080   SLL V0, V0, 2
9D001E10  00511021   ADDU V0, V0, S1
9D001E14  32520FFF   ANDI S2, S2, 4095
9D001E18  8C420000   LW V0, 0(V0)
9D001E1C  00521021   ADDU V0, V0, S2
9D001EC4  00101B02   SRL V1, S0, 12
9D001EC8  00031880   SLL V1, V1, 2
9D001ECC  00711821   ADDU V1, V1, S1
9D001ED0  32020FFF   ANDI V0, S0, 4095
9D001ED4  8C630000   LW V1, 0(V1)
9D001ED8  00621021   ADDU V0, V1, V0
9D001EF8  00101B02   SRL V1, S0, 12
9D001EFC  00031880   SLL V1, V1, 2
9D001F00  00711821   ADDU V1, V1, S1
9D001F04  32020FFF   ANDI V0, S0, 4095
9D001F08  8C630000   LW V1, 0(V1)
9D001F0C  00621021   ADDU V0, V1, V0
9D001F44  00121302   SRL V0, S2, 12
9D001F48  00021080   SLL V0, V0, 2
9D001F4C  00511021   ADDU V0, V0, S1
9D001F50  32520FFF   ANDI S2, S2, 4095
9D001F54  8C420000   LW V0, 0(V0)
9D001F58  00521021   ADDU V0, V0, S2
9D001FB8  00102302   SRL A0, S0, 12
9D001FBC  00042080   SLL A0, A0, 2
9D001FC0  00912021   ADDU A0, A0, S1
9D001FC4  32020FFF   ANDI V0, S0, 4095
9D001FC8  8C840000   LW A0, 0(A0)
9D001FCC  00821021   ADDU V0, A0, V0
9D001FF8  00101B02   SRL V1, S0, 12
9D001FFC  00031880   SLL V1, V1, 2
9D002000  00711821   ADDU V1, V1, S1
9D002004  32020FFF   ANDI V0, S0, 4095
9D002008  8C630000   LW V1, 0(V1)
9D00200C  00621021   ADDU V0, V1, V0
9D002048  00121302   SRL V0, S2, 12
9D00204C  00021080   SLL V0, V0, 2
9D002050  00511021   ADDU V0, V0, S1
9D002054  32520FFF   ANDI S2, S2, 4095
9D002058  8C420000   LW V0, 0(V0)
9D00205C  00521021   ADDU V0, V0, S2
9D002100  00121302   SRL V0, S2, 12
9D002104  00021080   SLL V0, V0, 2
9D002108  00511021   ADDU V0, V0, S1
9D00210C  32520FFF   ANDI S2, S2, 4095
9D002110  8C420000   LW V0, 0(V0)
9D002114  00521021   ADDU V0, V0, S2
9D0021AC  00121302   SRL V0, S2, 12
9D0021B0  00021080   SLL V0, V0, 2
9D0021B4  00511021   ADDU V0, V0, S1
9D0021B8  32520FFF   ANDI S2, S2, 4095
9D0021BC  8C420000   LW V0, 0(V0)
9D0021C0  00521021   ADDU V0, V0, S2
9D00227C  00121302   SRL V0, S2, 12
9D002280  00021080   SLL V0, V0, 2
9D002284  00511021   ADDU V0, V0, S1
9D002288  32520FFF   ANDI S2, S2, 4095
9D00228C  8C420000   LW V0, 0(V0)
9D002290  00521021   ADDU V0, V0, S2
9D002354  00121302   SRL V0, S2, 12
9D002358  00021080   SLL V0, V0, 2
9D00235C  00511021   ADDU V0, V0, S1
9D002360  32520FFF   ANDI S2, S2, 4095
9D002364  8C420000   LW V0, 0(V0)
9D002368  00521021   ADDU V0, V0, S2
9D00239C  00101B02   SRL V1, S0, 12
9D0023A0  00031880   SLL V1, V1, 2
9D0023A4  00711821   ADDU V1, V1, S1
9D0023A8  32100FFF   ANDI S0, S0, 4095
9D0023AC  8C630000   LW V1, 0(V1)
9D0023B0  00701821   ADDU V1, V1, S0
9D002424  00121302   SRL V0, S2, 12
9D002428  00021080   SLL V0, V0, 2
9D00242C  00511021   ADDU V0, V0, S1
9D002430  32520FFF   ANDI S2, S2, 4095
9D002434  8C420000   LW V0, 0(V0)
9D002438  00521021   ADDU V0, V0, S2
9D002450  00101B02   SRL V1, S0, 12
9D002454  00031880   SLL V1, V1, 2
9D002458  00711821   ADDU V1, V1, S1
9D00245C  32020FFF   ANDI V0, S0, 4095
9D002460  8C630000   LW V1, 0(V1)
9D002464  00621021   ADDU V0, V1, V0
9D0024F4  00121302   SRL V0, S2, 12
9D0024F8  00021080   SLL V0, V0, 2
9D0024FC  00511021   ADDU V0, V0, S1
9D002500  32520FFF   ANDI S2, S2, 4095
9D002504  8C420000   LW V0, 0(V0)
9D002508  00521021   ADDU V0, V0, S2
9D00252C  00101B02   SRL V1, S0, 12
9D002530  00031880   SLL V1, V1, 2
9D002534  00711821   ADDU V1, V1, S1
9D002538  32020FFF   ANDI V0, S0, 4095
9D00253C  8C630000   LW V1, 0(V1)
9D002540  00621021   ADDU V0, V1, V0
9D0025C8  00121302   SRL V0, S2, 12
9D0025CC  00021080   SLL V0, V0, 2
9D0025D0  00511021   ADDU V0, V0, S1
9D0025D4  32520FFF   ANDI S2, S2, 4095
9D0025D8  8C420000   LW V0, 0(V0)
9D0025DC  00521021   ADDU V0, V0, S2
9D002604  00101B02   SRL V1, S0, 12
9D002608  00031880   SLL V1, V1, 2
9D00260C  00711821   ADDU V1, V1, S1
9D002610  32020FFF   ANDI V0, S0, 4095
9D002614  8C630000   LW V1, 0(V1)
9D002618  00621021   ADDU V0, V1, V0
9D002664  00121302   SRL V0, S2, 12
9D002668  00021080   SLL V0, V0, 2
9D00266C  00511021   ADDU V0, V0, S1
9D002670  32520FFF   ANDI S2, S2, 4095
9D002674  8C420000   LW V0, 0(V0)
9D002678  00521021   ADDU V0, V0, S2
9D00269C  00101B02   SRL V1, S0, 12
9D0026A0  00031880   SLL V1, V1, 2
9D0026A4  00711821   ADDU V1, V1, S1
9D0026A8  32020FFF   ANDI V0, S0, 4095
9D0026AC  8C630000   LW V1, 0(V1)
9D0026B0  00621021   ADDU V0, V1, V0
9D00270C  00121302   SRL V0, S2, 12
9D002710  00021080   SLL V0, V0, 2
9D002714  00511021   ADDU V0, V0, S1
9D002718  32520FFF   ANDI S2, S2, 4095
9D00271C  8C420000   LW V0, 0(V0)
9D002720  00521021   ADDU V0, V0, S2
9D002744  00101B02   SRL V1, S0, 12
9D002748  00031880   SLL V1, V1, 2
9D00274C  00711821   ADDU V1, V1, S1
9D002750  32020FFF   ANDI V0, S0, 4095
9D002754  8C630000   LW V1, 0(V1)
9D002758  00621021   ADDU V0, V1, V0
9D0027BC  00121302   SRL V0, S2, 12
9D0027C0  00021080   SLL V0, V0, 2
9D0027C4  00511021   ADDU V0, V0, S1
9D0027C8  32520FFF   ANDI S2, S2, 4095
9D0027CC  8C420000   LW V0, 0(V0)
9D0027D0  00521021   ADDU V0, V0, S2
9D00281C  00101B02   SRL V1, S0, 12
9D002820  00031880   SLL V1, V1, 2
9D002824  00711821   ADDU V1, V1, S1
9D002828  32020FFF   ANDI V0, S0, 4095
9D00282C  8C630000   LW V1, 0(V1)
9D002830  00621021   ADDU V0, V1, V0
9D002908  00121302   SRL V0, S2, 12
9D00290C  00021080   SLL V0, V0, 2
9D002910  00511021   ADDU V0, V0, S1
9D002914  32520FFF   ANDI S2, S2, 4095
9D002918  8C420000   LW V0, 0(V0)
9D00291C  00521021   ADDU V0, V0, S2
9D0029EC  00121302   SRL V0, S2, 12
9D0029F0  00021080   SLL V0, V0, 2
9D0029F4  00511021   ADDU V0, V0, S1
9D0029F8  32520FFF   ANDI S2, S2, 4095
9D0029FC  8C420000   LW V0, 0(V0)
9D002A00  00521021   ADDU V0, V0, S2
9D002AD4  00121302   SRL V0, S2, 12
9D002AD8  00021080   SLL V0, V0, 2
9D002ADC  00511021   ADDU V0, V0, S1
9D002AE0  32520FFF   ANDI S2, S2, 4095
9D002AE4  8C420000   LW V0, 0(V0)
9D002AE8  00521021   ADDU V0, V0, S2
9D002BAC  00121302   SRL V0, S2, 12
9D002BB0  00021080   SLL V0, V0, 2
9D002BB4  00511021   ADDU V0, V0, S1
9D002BB8  32520FFF   ANDI S2, S2, 4095
9D002BBC  8C420000   LW V0, 0(V0)
9D002BC0  00521021   ADDU V0, V0, S2
9D002C8C  00121302   SRL V0, S2, 12
9D002C90  00021080   SLL V0, V0, 2
9D002C94  00511021   ADDU V0, V0, S1
9D002C98  32520FFF   ANDI S2, S2, 4095
9D002C9C  8C420000   LW V0, 0(V0)
9D002CA0  00521021   ADDU V0, V0, S2
9D002E04  00121302   SRL V0, S2, 12
9D002E08  00021080   SLL V0, V0, 2
9D002E0C  00511021   ADDU V0, V0, S1
9D002E10  32520FFF   ANDI S2, S2, 4095
9D002E14  8C420000   LW V0, 0(V0)
9D002E18  00521021   ADDU V0, V0, S2
9D002E38  00101B02   SRL V1, S0, 12
9D002E3C  00031880   SLL V1, V1, 2
9D002E40  00711821   ADDU V1, V1, S1
9D002E44  32020FFF   ANDI V0, S0, 4095
9D002E48  8C630000   LW V1, 0(V1)
9D002E4C  00621021   ADDU V0, V1, V0
9D002EAC  00121302   SRL V0, S2, 12
9D002EB0  00021080   SLL V0, V0, 2
9D002EB4  00511021   ADDU V0, V0, S1
9D002EB8  32520FFF   ANDI S2, S2, 4095
9D002EBC  8C420000   LW V0, 0(V0)
9D002EC0  00521021   ADDU V0, V0, S2
9D002EE4  00101B02   SRL V1, S0, 12
9D002EE8  00031880   SLL V1, V1, 2
9D002EEC  00711821   ADDU V1, V1, S1
9D002EF0  32020FFF   ANDI V0, S0, 4095
9D002EF4  8C630000   LW V1, 0(V1)
9D002EF8  00621021   ADDU V0, V1, V0
9D002F70  00121302   SRL V0, S2, 12
9D002F74  00021080   SLL V0, V0, 2
9D002F78  00511021   ADDU V0, V0, S1
9D002F7C  32520FFF   ANDI S2, S2, 4095
9D002F80  8C420000   LW V0, 0(V0)
9D002F84  00521021   ADDU V0, V0, S2
9D002FA8  00101B02   SRL V1, S0, 12
9D002FAC  00031880   SLL V1, V1, 2
9D002FB0  00711821   ADDU V1, V1, S1
9D002FB4  32020FFF   ANDI V0, S0, 4095
9D002FB8  8C630000   LW V1, 0(V1)
9D002FBC  00621021   ADDU V0, V1, V0
9D003004  00121302   SRL V0, S2, 12
9D003008  00021080   SLL V0, V0, 2
9D00300C  00511021   ADDU V0, V0, S1
9D003010  32520FFF   ANDI S2, S2, 4095
9D003014  8C420000   LW V0, 0(V0)
9D003018  00521021   ADDU V0, V0, S2
9D00303C  00101B02   SRL V1, S0, 12
9D003040  00031880   SLL V1, V1, 2
9D003044  00711821   ADDU V1, V1, S1
9D003048  32020FFF   ANDI V0, S0, 4095
9D00304C  8C630000   LW V1, 0(V1)
9D003050  00621021   ADDU V0, V1, V0
9D003098  00121302   SRL V0, S2, 12
9D00309C  00021080   SLL V0, V0, 2
9D0030A0  00511021   ADDU V0, V0, S1
9D0030A4  32520FFF   ANDI S2, S2, 4095
9D0030A8  8C420000   LW V0, 0(V0)
9D0030AC  00521021   ADDU V0, V0, S2
9D0030CC  00101B02   SRL V1, S0, 12
9D0030D0  00031880   SLL V1, V1, 2
9D0030D4  00711821   ADDU V1, V1, S1
9D0030D8  32020FFF   ANDI V0, S0, 4095
9D0030DC  8C630000   LW V1, 0(V1)
9D0030E0  00621021   ADDU V0, V1, V0
9D003134  00121302   SRL V0, S2, 12
9D003138  00021080   SLL V0, V0, 2
9D00313C  00511021   ADDU V0, V0, S1
9D003140  32520FFF   ANDI S2, S2, 4095
9D003144  8C420000   LW V0, 0(V0)
9D003148  00521021   ADDU V0, V0, S2
9D0031AC  00102302   SRL A0, S0, 12
9D0031B0  00042080   SLL A0, A0, 2
9D0031B4  00912021   ADDU A0, A0, S1
9D0031B8  32020FFF   ANDI V0, S0, 4095
9D0031BC  8C840000   LW A0, 0(A0)
9D0031C0  00821021   ADDU V0, A0, V0
9D0031E4  00101B02   SRL V1, S0, 12
9D0031E8  00031880   SLL V1, V1, 2
9D0031EC  00711821   ADDU V1, V1, S1
9D0031F0  32020FFF   ANDI V0, S0, 4095
9D0031F4  8C630000   LW V1, 0(V1)
9D0031F8  00621021   ADDU V0, V1, V0
9D003234  00121302   SRL V0, S2, 12
9D003238  00021080   SLL V0, V0, 2
9D00323C  00511021   ADDU V0, V0, S1
9D003240  32520FFF   ANDI S2, S2, 4095
9D003244  8C420000   LW V0, 0(V0)
9D003248  00521021   ADDU V0, V0, S2
9D00329C  00101B02   SRL V1, S0, 12
9D0032A0  00031880   SLL V1, V1, 2
9D0032A4  00711821   ADDU V1, V1, S1
9D0032A8  32020FFF   ANDI V0, S0, 4095
9D0032AC  8C630000   LW V1, 0(V1)
9D0032B0  00621021   ADDU V0, V1, V0
9D0032D8  00101B02   SRL V1, S0, 12
9D0032DC  00031880   SLL V1, V1, 2
9D0032E0  00711821   ADDU V1, V1, S1
9D0032E4  32020FFF   ANDI V0, S0, 4095
9D0032E8  8C630000   LW V1, 0(V1)
9D0032EC  00621021   ADDU V0, V1, V0
9D00332C  00121302   SRL V0, S2, 12
9D003330  00021080   SLL V0, V0, 2
9D003334  00511021   ADDU V0, V0, S1
9D003338  32520FFF   ANDI S2, S2, 4095
9D00333C  8C420000   LW V0, 0(V0)
9D003340  00521021   ADDU V0, V0, S2
9D0033C4  8E220000   LW V0, 0(S1)
9D0033C8  00529021   ADDU S2, V0, S2
9D003460  00121302   SRL V0, S2, 12
9D003464  00021080   SLL V0, V0, 2
9D003468  00511021   ADDU V0, V0, S1
9D00346C  32520FFF   ANDI S2, S2, 4095
9D003470  8C420000   LW V0, 0(V0)
9D003474  00521021   ADDU V0, V0, S2
9D003520  00121302   SRL V0, S2, 12
9D003524  00021080   SLL V0, V0, 2
9D003528  00511021   ADDU V0, V0, S1
9D00352C  32520FFF   ANDI S2, S2, 4095
9D003530  8C420000   LW V0, 0(V0)
9D003534  00521021   ADDU V0, V0, S2
9D0035E8  00121302   SRL V0, S2, 12
9D0035EC  00021080   SLL V0, V0, 2
9D0035F0  00511021   ADDU V0, V0, S1
9D0035F4  32520FFF   ANDI S2, S2, 4095
9D0035F8  8C420000   LW V0, 0(V0)
9D0035FC  00521021   ADDU V0, V0, S2
9D00362C  00101B02   SRL V1, S0, 12
9D003630  00031880   SLL V1, V1, 2
9D003634  00711821   ADDU V1, V1, S1
9D003638  32100FFF   ANDI S0, S0, 4095
9D00363C  8C630000   LW V1, 0(V1)
9D003640  00701821   ADDU V1, V1, S0
9D0036B4  00121302   SRL V0, S2, 12
9D0036B8  00021080   SLL V0, V0, 2
9D0036BC  00511021   ADDU V0, V0, S1
9D0036C0  32520FFF   ANDI S2, S2, 4095
9D0036C4  8C420000   LW V0, 0(V0)
9D0036C8  00521021   ADDU V0, V0, S2
9D0036E0  00101B02   SRL V1, S0, 12
9D0036E4  00031880   SLL V1, V1, 2
9D0036E8  00711821   ADDU V1, V1, S1
9D0036EC  32020FFF   ANDI V0, S0, 4095
9D0036F0  8C630000   LW V1, 0(V1)
9D0036F4  00621021   ADDU V0, V1, V0
9D003784  00121302   SRL V0, S2, 12
9D003788  00021080   SLL V0, V0, 2
9D00378C  00511021   ADDU V0, V0, S1
9D003790  32520FFF   ANDI S2, S2, 4095
9D003794  8C420000   LW V0, 0(V0)
9D003798  00521021   ADDU V0, V0, S2
9D0037BC  00101B02   SRL V1, S0, 12
9D0037C0  00031880   SLL V1, V1, 2
9D0037C4  00711821   ADDU V1, V1, S1
9D0037C8  32020FFF   ANDI V0, S0, 4095
9D0037CC  8C630000   LW V1, 0(V1)
9D0037D0  00621021   ADDU V0, V1, V0
9D00384C  00121302   SRL V0, S2, 12
9D003850  00021080   SLL V0, V0, 2
9D003854  00511021   ADDU V0, V0, S1
9D003858  32520FFF   ANDI S2, S2, 4095
9D00385C  8C420000   LW V0, 0(V0)
9D003860  00521021   ADDU V0, V0, S2
9D003884  00101B02   SRL V1, S0, 12
9D003888  00031880   SLL V1, V1, 2
9D00388C  00711821   ADDU V1, V1, S1
9D003890  32020FFF   ANDI V0, S0, 4095
9D003894  8C630000   LW V1, 0(V1)
9D003898  00621021   ADDU V0, V1, V0
9D0038E8  00121302   SRL V0, S2, 12
9D0038EC  00021080   SLL V0, V0, 2
9D0038F0  00511021   ADDU V0, V0, S1
9D0038F4  32520FFF   ANDI S2, S2, 4095
9D0038F8  8C420000   LW V0, 0(V0)
9D0038FC  00521021   ADDU V0, V0, S2
9D003920  00101B02   SRL V1, S0, 12
9D003924  00031880   SLL V1, V1, 2
9D003928  00711821   ADDU V1, V1, S1
9D00392C  32020FFF   ANDI V0, S0, 4095
9D003930  8C630000   LW V1, 0(V1)
9D003934  00621021   ADDU V0, V1, V0
9D003984  00121302   SRL V0, S2, 12
9D003988  00021080   SLL V0, V0, 2
9D00398C  00511021   ADDU V0, V0, S1
9D003990  32520FFF   ANDI S2, S2, 4095
9D003994  8C420000   LW V0, 0(V0)
9D003998  00521021   ADDU V0, V0, S2
9D0039B8  00101B02   SRL V1, S0, 12
9D0039BC  00031880   SLL V1, V1, 2
9D0039C0  00711821   ADDU V1, V1, S1
9D0039C4  32020FFF   ANDI V0, S0, 4095
9D0039C8  8C630000   LW V1, 0(V1)
9D0039CC  00621021   ADDU V0, V1, V0
9D003A28  00121302   SRL V0, S2, 12
9D003A2C  00021080   SLL V0, V0, 2
9D003A30  00511021   ADDU V0, V0, S1
9D003A34  32520FFF   ANDI S2, S2, 4095
9D003A38  8C420000   LW V0, 0(V0)
9D003A3C  00521021   ADDU V0, V0, S2
9D003B54  00031880   SLL V1, V1, 2
9D003B58  00711821   ADDU V1, V1, S1
9D003B5C  32020FFF   ANDI V0, S0, 4095
9D003B60  8C630000   LW V1, 0(V1)
9D003B64  00621021   ADDU V0, V1, V0
9D003C34  00121302   SRL V0, S2, 12
9D003C38  00021080   SLL V0, V0, 2
9D003C3C  00511021   ADDU V0, V0, S1
9D003C40  32520FFF   ANDI S2, S2, 4095
9D003C44  8C420000   LW V0, 0(V0)
9D003C48  00521021   ADDU V0, V0, S2
9D003D0C  00121302   SRL V0, S2, 12
9D003D10  00021080   SLL V0, V0, 2
9D003D14  00511021   ADDU V0, V0, S1
9D003D18  32520FFF   ANDI S2, S2, 4095
9D003D1C  8C420000   LW V0, 0(V0)
9D003D20  00521021   ADDU V0, V0, S2
9D003DF0  00121302   SRL V0, S2, 12
9D003DF4  00021080   SLL V0, V0, 2
9D003DF8  00511021   ADDU V0, V0, S1
9D003DFC  32520FFF   ANDI S2, S2, 4095
9D003E00  8C420000   LW V0, 0(V0)
9D003E04  00521021   ADDU V0, V0, S2
9D003EB8  00121302   SRL V0, S2, 12
9D003EBC  00021080   SLL V0, V0, 2
9D003EC0  00511021   ADDU V0, V0, S1
9D003EC4  32520FFF   ANDI S2, S2, 4095
9D003EC8  8C420000   LW V0, 0(V0)
9D003ECC  00521021   ADDU V0, V0, S2
9D003F88  00121302   SRL V0, S2, 12
9D003F8C  00021080   SLL V0, V0, 2
9D003F90  00511021   ADDU V0, V0, S1
9D003F94  32520FFF   ANDI S2, S2, 4095
9D003F98  8C420000   LW V0, 0(V0)
9D003F9C  00521021   ADDU V0, V0, S2
9D004014  00121302   SRL V0, S2, 12
9D004018  00021080   SLL V0, V0, 2
9D00401C  00511021   ADDU V0, V0, S1
9D004020  32520FFF   ANDI S2, S2, 4095
9D004024  8C420000   LW V0, 0(V0)
9D004028  00521021   ADDU V0, V0, S2
9D004044  00101B02   SRL V1, S0, 12
9D004048  00031880   SLL V1, V1, 2
9D00404C  00711821   ADDU V1, V1, S1
9D004050  32020FFF   ANDI V0, S0, 4095
9D004054  8C630000   LW V1, 0(V1)
9D004058  00621021   ADDU V0, V1, V0
9D0040DC  00121302   SRL V0, S2, 12
9D0040E0  00021080   SLL V0, V0, 2
9D0040E4  00511021   ADDU V0, V0, S1
9D0040E8  32520FFF   ANDI S2, S2, 4095
9D0040EC  8C420000   LW V0, 0(V0)
9D0040F0  00521021   ADDU V0, V0, S2
9D004114  00101B02   SRL V1, S0, 12
9D004118  00031880   SLL V1, V1, 2
9D00411C  00711821   ADDU V1, V1, S1
9D004120  32020FFF   ANDI V0, S0, 4095
9D004124  8C630000   LW V1, 0(V1)
9D004128  00621021   ADDU V0, V1, V0
9D0041D8  00121302   SRL V0, S2, 12
9D0041DC  00021080   SLL V0, V0, 2
9D0041E0  00511021   ADDU V0, V0, S1
9D0041E4  32520FFF   ANDI S2, S2, 4095
9D0041E8  8C420000   LW V0, 0(V0)
9D0041EC  00521021   ADDU V0, V0, S2
9D004210  00101B02   SRL V1, S0, 12
9D004214  00031880   SLL V1, V1, 2
9D004218  00711821   ADDU V1, V1, S1
9D00421C  32020FFF   ANDI V0, S0, 4095
9D004220  8C630000   LW V1, 0(V1)
9D004224  00621021   ADDU V0, V1, V0
9D004290  00121302   SRL V0, S2, 12
9D004294  00021080   SLL V0, V0, 2
9D004298  00511021   ADDU V0, V0, S1
9D00429C  32520FFF   ANDI S2, S2, 4095
9D0042A0  8C420000   LW V0, 0(V0)
9D0042A4  00521021   ADDU V0, V0, S2
9D0042C8  00101B02   SRL V1, S0, 12
9D0042CC  00031880   SLL V1, V1, 2
9D0042D0  00711821   ADDU V1, V1, S1
9D0042D4  32020FFF   ANDI V0, S0, 4095
9D0042D8  8C630000   LW V1, 0(V1)
9D0042DC  00621021   ADDU V0, V1, V0
9D004330  00121302   SRL V0, S2, 12
9D004334  00021080   SLL V0, V0, 2
9D004338  00511021   ADDU V0, V0, S1
9D00433C  32520FFF   ANDI S2, S2, 4095
9D004340  8C420000   LW V0, 0(V0)
9D004344  00521021   ADDU V0, V0, S2
9D004364  00101B02   SRL V1, S0, 12
9D004368  00031880   SLL V1, V1, 2
9D00436C  00711821   ADDU V1, V1, S1
9D004370  32020FFF   ANDI V0, S0, 4095
9D004374  8C630000   LW V1, 0(V1)
9D004378  00621021   ADDU V0, V1, V0
9D0043FC  00121302   SRL V0, S2, 12
9D004400  00021080   SLL V0, V0, 2
9D004404  00511021   ADDU V0, V0, S1
9D004408  32520FFF   ANDI S2, S2, 4095
9D00440C  8C420000   LW V0, 0(V0)
9D004410  00521021   ADDU V0, V0, S2
9D00447C  00101B02   SRL V1, S0, 12
9D004480  00031880   SLL V1, V1, 2
9D004484  00711821   ADDU V1, V1, S1
9D004488  32020FFF   ANDI V0, S0, 4095
9D00448C  8C630000   LW V1, 0(V1)
9D004490  00621021   ADDU V0, V1, V0
9D0044B8  00101B02   SRL V1, S0, 12
9D0044BC  00031880   SLL V1, V1, 2
9D0044C0  00711821   ADDU V1, V1, S1
9D0044C4  32020FFF   ANDI V0, S0, 4095
9D0044C8  8C630000   LW V1, 0(V1)
9D0044CC  00621021   ADDU V0, V1, V0
9D0044D0  90420000   LBU V0, 0(V0)
9D00452C  00121302   SRL V0, S2, 12
9D004530  00021080   SLL V0, V0, 2
9D004534  00511021   ADDU V0, V0, S1
9D004538  32520FFF   ANDI S2, S2, 4095
9D00453C  8C420000   LW V0, 0(V0)
9D004540  00521021   ADDU V0, V0, S2
9D0045A0  00101B02   SRL V1, S0, 12
9D0045A4  00031880   SLL V1, V1, 2
9D0045A8  00711821   ADDU V1, V1, S1
9D0045AC  32020FFF   ANDI V0, S0, 4095
9D0045B0  8C630000   LW V1, 0(V1)
9D0045B4  00621021   ADDU V0, V1, V0
9D0045DC  00101B02   SRL V1, S0, 12
9D0045E0  00031880   SLL V1, V1, 2
9D0045E4  00711821   ADDU V1, V1, S1
9D0045E8  32020FFF   ANDI V0, S0, 4095
9D0045EC  8C630000   LW V1, 0(V1)
9D0045F0  00621021   ADDU V0, V1, V0
9D004650  00121302   SRL V0, S2, 12
9D004654  00021080   SLL V0, V0, 2
9D004658  00511021   ADDU V0, V0, S1
9D00465C  32520FFF   ANDI S2, S2, 4095
9D004660  8C420000   LW V0, 0(V0)
9D004664  00521021   ADDU V0, V0, S2
9D0046DC  00621021   ADDU V0, V1, V0
9D004720  00121302   SRL V0, S2, 12
9D004724  00021080   SLL V0, V0, 2
9D004728  00511021   ADDU V0, V0, S1
9D00472C  32520FFF   ANDI S2, S2, 4095
9D004730  8C420000   LW V0, 0(V0)
9D004734  00521021   ADDU V0, V0, S2
9D0047F0  00121302   SRL V0, S2, 12
9D0047F4  00021080   SLL V0, V0, 2
9D0047F8  00511021   ADDU V0, V0, S1
9D0047FC  32520FFF   ANDI S2, S2, 4095
9D004800  8C420000   LW V0, 0(V0)
9D004804  00521021   ADDU V0, V0, S2
9D0048BC  00121302   SRL V0, S2, 12
9D0048C0  00021080   SLL V0, V0, 2
9D0048C4  00511021   ADDU V0, V0, S1
9D0048C8  32520FFF   ANDI S2, S2, 4095
9D0048CC  8C420000   LW V0, 0(V0)
9D0048D0  00521021   ADDU V0, V0, S2
9D0049BC  00121302   SRL V0, S2, 12
9D0049C0  00021080   SLL V0, V0, 2
9D0049C4  00511021   ADDU V0, V0, S1
9D0049C8  32520FFF   ANDI S2, S2, 4095
9D0049CC  8C420000   LW V0, 0(V0)
9D0049D0  00521021   ADDU V0, V0, S2
9D004A00  00101B02   SRL V1, S0, 12
9D004A04  00031880   SLL V1, V1, 2
9D004A08  00711821   ADDU V1, V1, S1
9D004A0C  32100FFF   ANDI S0, S0, 4095
9D004A10  8C630000   LW V1, 0(V1)
9D004A14  00701821   ADDU V1, V1, S0
9D004A88  00121302   SRL V0, S2, 12
9D004A8C  00021080   SLL V0, V0, 2
9D004A90  00511021   ADDU V0, V0, S1
9D004A94  32520FFF   ANDI S2, S2, 4095
9D004A98  8C420000   LW V0, 0(V0)
9D004A9C  00521021   ADDU V0, V0, S2
9D004AB4  00101B02   SRL V1, S0, 12
9D004AB8  00031880   SLL V1, V1, 2
9D004ABC  00711821   ADDU V1, V1, S1
9D004AC0  32020FFF   ANDI V0, S0, 4095
9D004AC4  8C630000   LW V1, 0(V1)
9D004AC8  00621021   ADDU V0, V1, V0
9D004B7C  00121302   SRL V0, S2, 12
9D004B80  00021080   SLL V0, V0, 2
9D004B84  00511021   ADDU V0, V0, S1
9D004B88  32520FFF   ANDI S2, S2, 4095
9D004B8C  8C420000   LW V0, 0(V0)
9D004B90  00521021   ADDU V0, V0, S2
9D004BB4  00101B02   SRL V1, S0, 12
9D004BB8  00031880   SLL V1, V1, 2
9D004BBC  00711821   ADDU V1, V1, S1
9D004BC0  32020FFF   ANDI V0, S0, 4095
9D004BC4  8C630000   LW V1, 0(V1)
9D004BC8  00621021   ADDU V0, V1, V0
9D004C7C  00121302   SRL V0, S2, 12
9D004C80  00021080   SLL V0, V0, 2
9D004C84  00511021   ADDU V0, V0, S1
9D004C88  32520FFF   ANDI S2, S2, 4095
9D004C8C  8C420000   LW V0, 0(V0)
9D004C90  00521021   ADDU V0, V0, S2
9D004CB4  00101B02   SRL V1, S0, 12
9D004CB8  00031880   SLL V1, V1, 2
9D004CBC  00711821   ADDU V1, V1, S1
9D004CC0  32020FFF   ANDI V0, S0, 4095
9D004CC4  8C630000   LW V1, 0(V1)
9D004CC8  00621021   ADDU V0, V1, V0
9D004D3C  00121302   SRL V0, S2, 12
9D004D40  00021080   SLL V0, V0, 2
9D004D44  00511021   ADDU V0, V0, S1
9D004D48  32520FFF   ANDI S2, S2, 4095
9D004D4C  8C420000   LW V0, 0(V0)
9D004D50  00521021   ADDU V0, V0, S2
9D004D74  00101B02   SRL V1, S0, 12
9D004D78  00031880   SLL V1, V1, 2
9D004D7C  00711821   ADDU V1, V1, S1
9D004D80  32020FFF   ANDI V0, S0, 4095
9D004D84  8C630000   LW V1, 0(V1)
9D004D88  00621021   ADDU V0, V1, V0
9D004DE4  00121302   SRL V0, S2, 12
9D004DE8  00021080   SLL V0, V0, 2
9D004DEC  00511021   ADDU V0, V0, S1
9D004DF0  32520FFF   ANDI S2, S2, 4095
9D004DF4  8C420000   LW V0, 0(V0)
9D004DF8  00521021   ADDU V0, V0, S2
9D004E18  00101B02   SRL V1, S0, 12
9D004E1C  00031880   SLL V1, V1, 2
9D004E20  00711821   ADDU V1, V1, S1
9D004E24  32020FFF   ANDI V0, S0, 4095
9D004E28  8C630000   LW V1, 0(V1)
9D004E2C  00621021   ADDU V0, V1, V0
9D004EB8  00121302   SRL V0, S2, 12
9D004EBC  00021080   SLL V0, V0, 2
9D004EC0  00511021   ADDU V0, V0, S1
9D004EC4  32520FFF   ANDI S2, S2, 4095
9D004EC8  8C420000   LW V0, 0(V0)
9D004ECC  00521021   ADDU V0, V0, S2
9D004F18  00101B02   SRL V1, S0, 12
9D004F1C  00031880   SLL V1, V1, 2
9D004F20  00711821   ADDU V1, V1, S1
9D004F24  32020FFF   ANDI V0, S0, 4095
9D004F28  8C630000   LW V1, 0(V1)
9D004F2C  00621021   ADDU V0, V1, V0
9D005028  00121302   SRL V0, S2, 12
9D00502C  00021080   SLL V0, V0, 2
9D005030  00511021   ADDU V0, V0, S1
9D005034  32520FFF   ANDI S2, S2, 4095
9D005038  8C420000   LW V0, 0(V0)
9D00503C  00521021   ADDU V0, V0, S2
9D005138  00121302   SRL V0, S2, 12
9D00513C  00021080   SLL V0, V0, 2
9D005140  00511021   ADDU V0, V0, S1
9D005144  32520FFF   ANDI S2, S2, 4095
9D005148  8C420000   LW V0, 0(V0)
9D00514C  00521021   ADDU V0, V0, S2
9D005240  00121302   SRL V0, S2, 12
9D005244  00021080   SLL V0, V0, 2
9D005248  00511021   ADDU V0, V0, S1
9D00524C  32520FFF   ANDI S2, S2, 4095
9D005250  8C420000   LW V0, 0(V0)
9D005254  00521021   ADDU V0, V0, S2
9D005314  00121302   SRL V0, S2, 12
9D005318  00021080   SLL V0, V0, 2
9D00531C  00511021   ADDU V0, V0, S1
9D005320  32520FFF   ANDI S2, S2, 4095
9D005324  8C420000   LW V0, 0(V0)
9D005328  00521021   ADDU V0, V0, S2
9D00541C  00121302   SRL V0, S2, 12
9D005420  00021080   SLL V0, V0, 2
9D005424  00511021   ADDU V0, V0, S1
9D005428  32520FFF   ANDI S2, S2, 4095
9D00542C  8C420000   LW V0, 0(V0)
9D005430  00521021   ADDU V0, V0, S2
9D00548C  00121302   SRL V0, S2, 12
9D005490  00021080   SLL V0, V0, 2
9D005494  00511021   ADDU V0, V0, S1
9D005498  32520FFF   ANDI S2, S2, 4095
9D00549C  8C420000   LW V0, 0(V0)
9D0054A0  00529021   ADDU S2, V0, S2
9D0054BC  00101B02   SRL V1, S0, 12
9D0054C0  00031880   SLL V1, V1, 2
9D0054C4  00711821   ADDU V1, V1, S1
9D0054C8  32020FFF   ANDI V0, S0, 4095
9D0054CC  8C630000   LW V1, 0(V1)
9D0054D0  00621021   ADDU V0, V1, V0
9D005520  00121302   SRL V0, S2, 12
9D005524  00021080   SLL V0, V0, 2
9D005528  00511021   ADDU V0, V0, S1
9D00552C  32520FFF   ANDI S2, S2, 4095
9D005530  8C420000   LW V0, 0(V0)
9D005534  00521021   ADDU V0, V0, S2
9D005550  00101B02   SRL V1, S0, 12
9D005554  00031880   SLL V1, V1, 2
9D005558  00711821   ADDU V1, V1, S1
9D00555C  32020FFF   ANDI V0, S0, 4095
9D005560  8C630000   LW V1, 0(V1)
9D005564  00621021   ADDU V0, V1, V0
9D0055B8  00121302   SRL V0, S2, 12
9D0055BC  00021080   SLL V0, V0, 2
9D0055C0  00511021   ADDU V0, V0, S1
9D0055C4  32520FFF   ANDI S2, S2, 4095
9D0055C8  8C420000   LW V0, 0(V0)
9D0055CC  00521021   ADDU V0, V0, S2
9D0055E8  00101B02   SRL V1, S0, 12
9D0055EC  00031880   SLL V1, V1, 2
9D0055F0  00711821   ADDU V1, V1, S1
9D0055F4  32020FFF   ANDI V0, S0, 4095
9D0055F8  8C630000   LW V1, 0(V1)
9D0055FC  00621021   ADDU V0, V1, V0
9D005634  00121302   SRL V0, S2, 12
9D005638  00021080   SLL V0, V0, 2
9D00563C  00511021   ADDU V0, V0, S1
9D005640  32520FFF   ANDI S2, S2, 4095
9D005644  8C420000   LW V0, 0(V0)
9D005648  00521021   ADDU V0, V0, S2
9D005664  00101B02   SRL V1, S0, 12
9D005668  00031880   SLL V1, V1, 2
9D00566C  00711821   ADDU V1, V1, S1
9D005670  32020FFF   ANDI V0, S0, 4095
9D005674  8C630000   LW V1, 0(V1)
9D005678  00621021   ADDU V0, V1, V0
9D0056AC  00121302   SRL V0, S2, 12
9D0056B0  00021080   SLL V0, V0, 2
9D0056B4  00511021   ADDU V0, V0, S1
9D0056B8  32520FFF   ANDI S2, S2, 4095
9D0056BC  8C420000   LW V0, 0(V0)
9D0056C0  00521021   ADDU V0, V0, S2
9D0056DC  00101B02   SRL V1, S0, 12
9D0056E0  00031880   SLL V1, V1, 2
9D0056E4  00711821   ADDU V1, V1, S1
9D0056E8  32020FFF   ANDI V0, S0, 4095
9D0056EC  8C630000   LW V1, 0(V1)
9D0056F0  00621021   ADDU V0, V1, V0
9D005724  00121302   SRL V0, S2, 12
9D005728  00021080   SLL V0, V0, 2
9D00572C  00511021   ADDU V0, V0, S1
9D005730  32520FFF   ANDI S2, S2, 4095
9D005734  8C420000   LW V0, 0(V0)
9D005738  00521021   ADDU V0, V0, S2
9D005754  00101B02   SRL V1, S0, 12
9D005758  00031880   SLL V1, V1, 2
9D00575C  00711821   ADDU V1, V1, S1
9D005760  32020FFF   ANDI V0, S0, 4095
9D005764  8C630000   LW V1, 0(V1)
9D005768  00621021   ADDU V0, V1, V0
9D0057A0  00121302   SRL V0, S2, 12
9D0057A4  00021080   SLL V0, V0, 2
9D0057A8  00511021   ADDU V0, V0, S1
9D0057AC  32520FFF   ANDI S2, S2, 4095
9D0057B0  8C420000   LW V0, 0(V0)
9D0057B4  00521021   ADDU V0, V0, S2
9D005804  00101B02   SRL V1, S0, 12
9D005808  00031880   SLL V1, V1, 2
9D00580C  00711821   ADDU V1, V1, S1
9D005810  32020FFF   ANDI V0, S0, 4095
9D005814  8C630000   LW V1, 0(V1)
9D005818  00621021   ADDU V0, V1, V0
9D00586C  00101B02   SRL V1, S0, 12
9D005870  00031880   SLL V1, V1, 2
9D005874  00711821   ADDU V1, V1, S1
9D005878  32020FFF   ANDI V0, S0, 4095
9D00587C  8C630000   LW V1, 0(V1)
9D005880  00621021   ADDU V0, V1, V0
9D0058B8  00101B02   SRL V1, S0, 12
9D0058BC  00031880   SLL V1, V1, 2
9D0058C0  00711821   ADDU V1, V1, S1
9D0058C4  32020FFF   ANDI V0, S0, 4095
9D0058C8  8C630000   LW V1, 0(V1)
9D0058CC  00621021   ADDU V0, V1, V0
9D005904  00121302   SRL V0, S2, 12
9D005908  00021080   SLL V0, V0, 2
9D00590C  00511021   ADDU V0, V0, S1
9D005910  32520FFF   ANDI S2, S2, 4095
9D005914  8C420000   LW V0, 0(V0)
9D005918  00521021   ADDU V0, V0, S2
9D0059A8  00121302   SRL V0, S2, 12
9D0059AC  00021080   SLL V0, V0, 2
9D0059B0  00511021   ADDU V0, V0, S1
9D0059B4  32520FFF   ANDI S2, S2, 4095
9D0059B8  8C420000   LW V0, 0(V0)
9D0059BC  00521021   ADDU V0, V0, S2
9D005A44  00121302   SRL V0, S2, 12
9D005A48  00021080   SLL V0, V0, 2
9D005A4C  00511021   ADDU V0, V0, S1
9D005A50  32520FFF   ANDI S2, S2, 4095
9D005A54  8C420000   LW V0, 0(V0)
9D005A58  00521021   ADDU V0, V0, S2
9D005AE0  00121302   SRL V0, S2, 12
9D005AE4  00021080   SLL V0, V0, 2
9D005AE8  00511021   ADDU V0, V0, S1
9D005AEC  32520FFF   ANDI S2, S2, 4095
9D005AF0  8C420000   LW V0, 0(V0)
9D005AF4  00521021   ADDU V0, V0, S2
9D005B80  00121302   SRL V0, S2, 12
9D005B84  00021080   SLL V0, V0, 2
9D005B88  00511021   ADDU V0, V0, S1
9D005B8C  32520FFF   ANDI S2, S2, 4095
9D005B90  8C420000   LW V0, 0(V0)
9D005B94  00521021   ADDU V0, V0, S2
9D005BB8  00101B02   SRL V1, S0, 12
9D005BBC  00031880   SLL V1, V1, 2
9D005BC0  00711821   ADDU V1, V1, S1
9D005BC4  32100FFF   ANDI S0, S0, 4095
9D005BC8  8C630000   LW V1, 0(V1)
9D005BCC  00701821   ADDU V1, V1, S0
9D005C40  00121302   SRL V0, S2, 12
9D005C44  00021080   SLL V0, V0, 2
9D005C48  00511021   ADDU V0, V0, S1
9D005C4C  32520FFF   ANDI S2, S2, 4095
9D005C50  8C420000   LW V0, 0(V0)
9D005C54  00521021   ADDU V0, V0, S2
9D005C70  00101B02   SRL V1, S0, 12
9D005C74  00031880   SLL V1, V1, 2
9D005C78  00711821   ADDU V1, V1, S1
9D005C7C  32020FFF   ANDI V0, S0, 4095
9D005C80  8C630000   LW V1, 0(V1)
9D005C84  00621021   ADDU V0, V1, V0
9D005CD8  00121302   SRL V0, S2, 12
9D005CDC  00021080   SLL V0, V0, 2
9D005CE0  00511021   ADDU V0, V0, S1
9D005CE4  32520FFF   ANDI S2, S2, 4095
9D005CE8  8C420000   LW V0, 0(V0)
9D005CEC  00521021   ADDU V0, V0, S2
9D005D08  00101B02   SRL V1, S0, 12
9D005D0C  00031880   SLL V1, V1, 2
9D005D10  00711821   ADDU V1, V1, S1
9D005D14  32020FFF   ANDI V0, S0, 4095
9D005D18  8C630000   LW V1, 0(V1)
9D005D1C  00621021   ADDU V0, V1, V0
9D005D80  00121302   SRL V0, S2, 12
9D005D84  00021080   SLL V0, V0, 2
9D005D88  00511021   ADDU V0, V0, S1
9D005D8C  32520FFF   ANDI S2, S2, 4095
9D005D90  8C420000   LW V0, 0(V0)
9D005D94  00521021   ADDU V0, V0, S2
9D005DB0  00101B02   SRL V1, S0, 12
9D005DB4  00031880   SLL V1, V1, 2
9D005DB8  00711821   ADDU V1, V1, S1
9D005DBC  32020FFF   ANDI V0, S0, 4095
9D005DC0  8C630000   LW V1, 0(V1)
9D005DC4  00621021   ADDU V0, V1, V0
9D005E04  00121302   SRL V0, S2, 12
9D005E08  00021080   SLL V0, V0, 2
9D005E0C  00511021   ADDU V0, V0, S1
9D005E10  32520FFF   ANDI S2, S2, 4095
9D005E14  8C420000   LW V0, 0(V0)
9D005E18  00521021   ADDU V0, V0, S2
9D005E34  00101B02   SRL V1, S0, 12
9D005E38  00031880   SLL V1, V1, 2
9D005E3C  00711821   ADDU V1, V1, S1
9D005E40  32020FFF   ANDI V0, S0, 4095
9D005E44  8C630000   LW V1, 0(V1)
9D005E48  00621021   ADDU V0, V1, V0
9D005E84  00121302   SRL V0, S2, 12
9D005E88  00021080   SLL V0, V0, 2
9D005E8C  00511021   ADDU V0, V0, S1
9D005E90  32520FFF   ANDI S2, S2, 4095
9D005E94  8C420000   LW V0, 0(V0)
9D005E98  00521021   ADDU V0, V0, S2
9D005EB4  00101B02   SRL V1, S0, 12
9D005EB8  00031880   SLL V1, V1, 2
9D005EBC  00711821   ADDU V1, V1, S1
9D005EC0  32020FFF   ANDI V0, S0, 4095
9D005EC4  8C630000   LW V1, 0(V1)
9D005EC8  00621021   ADDU V0, V1, V0
9D005F08  00121302   SRL V0, S2, 12
9D005F0C  00021080   SLL V0, V0, 2
9D005F10  00511021   ADDU V0, V0, S1
9D005F14  32520FFF   ANDI S2, S2, 4095
9D005F18  8C420000   LW V0, 0(V0)
9D005F1C  00521021   ADDU V0, V0, S2
9D005F38  00101B02   SRL V1, S0, 12
9D005F3C  00031880   SLL V1, V1, 2
9D005F40  00711821   ADDU V1, V1, S1
9D005F44  32020FFF   ANDI V0, S0, 4095
9D005F48  8C630000   LW V1, 0(V1)
9D005F4C  00621021   ADDU V0, V1, V0
9D005F90  00121302   SRL V0, S2, 12
9D005F94  00021080   SLL V0, V0, 2
9D005F98  00511021   ADDU V0, V0, S1
9D005F9C  32520FFF   ANDI S2, S2, 4095
9D005FA0  8C420000   LW V0, 0(V0)
9D005FA4  00521021   ADDU V0, V0, S2
9D005FEC  00101B02   SRL V1, S0, 12
9D005FF0  00031880   SLL V1, V1, 2
9D005FF4  00711821   ADDU V1, V1, S1
9D005FF8  32020FFF   ANDI V0, S0, 4095
9D005FFC  8C630000   LW V1, 0(V1)
9D006000  00621021   ADDU V0, V1, V0
9D0060A4  00121302   SRL V0, S2, 12
9D0060A8  00021080   SLL V0, V0, 2
9D0060AC  00511021   ADDU V0, V0, S1
9D0060B0  32520FFF   ANDI S2, S2, 4095
9D0060B4  8C420000   LW V0, 0(V0)
9D0060B8  00521021   ADDU V0, V0, S2
9D0060F8  00101B02   SRL V1, S0, 12
9D0060FC  00031880   SLL V1, V1, 2
9D006100  00711821   ADDU V1, V1, S1
9D006104  32020FFF   ANDI V0, S0, 4095
9D006108  8C630000   LW V1, 0(V1)
9D00610C  00621021   ADDU V0, V1, V0
9D0061BC  00121302   SRL V0, S2, 12
9D0061C0  00021080   SLL V0, V0, 2
9D0061C4  00511021   ADDU V0, V0, S1
9D0061C8  32520FFF   ANDI S2, S2, 4095
9D0061CC  8C420000   LW V0, 0(V0)
9D0061D0  00521021   ADDU V0, V0, S2
9D006270  00121302   SRL V0, S2, 12
9D006274  00021080   SLL V0, V0, 2
9D006278  00511021   ADDU V0, V0, S1
9D00627C  32520FFF   ANDI S2, S2, 4095
9D006280  8C420000   LW V0, 0(V0)
9D006284  00521021   ADDU V0, V0, S2
9D006314  00121302   SRL V0, S2, 12
9D006318  00021080   SLL V0, V0, 2
9D00631C  00511021   ADDU V0, V0, S1
9D006320  32520FFF   ANDI S2, S2, 4095
9D006324  8C420000   LW V0, 0(V0)
9D006328  00521021   ADDU V0, V0, S2
9D0063C8  00121302   SRL V0, S2, 12
9D0063CC  00021080   SLL V0, V0, 2
9D0063D0  00511021   ADDU V0, V0, S1
9D0063D4  32520FFF   ANDI S2, S2, 4095
9D0063D8  8C420000   LW V0, 0(V0)
9D0063DC  00521021   ADDU V0, V0, S2
9D006480  00121302   SRL V0, S2, 12
9D006484  00021080   SLL V0, V0, 2
9D006488  00511021   ADDU V0, V0, S1
9D00648C  32520FFF   ANDI S2, S2, 4095
9D006490  8C420000   LW V0, 0(V0)
9D006494  00521021   ADDU V0, V0, S2
9D0064B0  00101B02   SRL V1, S0, 12
9D0064B4  00031880   SLL V1, V1, 2
9D0064B8  00711821   ADDU V1, V1, S1
9D0064BC  32020FFF   ANDI V0, S0, 4095
9D0064C0  8C630000   LW V1, 0(V1)
9D0064C4  00621021   ADDU V0, V1, V0
9D0064C8  90530000   LBU S3, 0(V0)
9D0064E8  AFB30010   SW S3, 16(SP)
9D0064EC  0B4027B2   J .L45
9D0064F0  0260A821   ADDU S5, S3, ZERO
9D0064F8  00121302   SRL V0, S2, 12
9D0064FC  00021080   SLL V0, V0, 2
9D006500  00511021   ADDU V0, V0, S1
9D006504  32520FFF   ANDI S2, S2, 4095
9D006508  8C420000   LW V0, 0(V0)
9D00650C  00521021   ADDU V0, V0, S2
9D006520  AFB30010   SW S3, 16(SP)
9D006530  00101B02   SRL V1, S0, 12
9D006534  00031880   SLL V1, V1, 2
9D006538  00711821   ADDU V1, V1, S1
9D00653C  32020FFF   ANDI V0, S0, 4095
9D006540  8C630000   LW V1, 0(V1)
9D006544  00621021   ADDU V0, V1, V0
9D0065A0  00121302   SRL V0, S2, 12
9D0065A4  00021080   SLL V0, V0, 2
9D0065A8  00511021   ADDU V0, V0, S1
9D0065AC  32520FFF   ANDI S2, S2, 4095
9D0065B0  8C420000   LW V0, 0(V0)
9D0065B4  00521021   ADDU V0, V0, S2
9D0065D8  00101B02   SRL V1, S0, 12
9D0065DC  00031880   SLL V1, V1, 2
9D0065E0  00711821   ADDU V1, V1, S1
9D0065E4  32020FFF   ANDI V0, S0, 4095
9D0065E8  8C630000   LW V1, 0(V1)
9D0065EC  00621021   ADDU V0, V1, V0
9D0065F0  90530000   LBU S3, 0(V0)
9D006610  0260F021   ADDU FP, S3, ZERO
9D006614  0B4027B2   J .L45
9D006618  0260A821   ADDU S5, S3, ZERO
9D006620  00121302   SRL V0, S2, 12
9D006624  00021080   SLL V0, V0, 2
9D006628  00511021   ADDU V0, V0, S1
9D00662C  32520FFF   ANDI S2, S2, 4095
9D006630  8C420000   LW V0, 0(V0)
9D006634  00521021   ADDU V0, V0, S2
9D006648  0260F021   ADDU FP, S3, ZERO
9D006658  00101B02   SRL V1, S0, 12
9D00665C  00031880   SLL V1, V1, 2
9D006660  00711821   ADDU V1, V1, S1
9D006664  32020FFF   ANDI V0, S0, 4095
9D006668  8C630000   LW V1, 0(V1)
9D00666C  00621021   ADDU V0, V1, V0
9D0066CC  00121302   SRL V0, S2, 12
9D0066D0  00021080   SLL V0, V0, 2
9D0066D4  00511021   ADDU V0, V0, S1
9D0066D8  32520FFF   ANDI S2, S2, 4095
9D0066DC  8C420000   LW V0, 0(V0)
9D0066E0  00521021   ADDU V0, V0, S2
9D006708  00101B02   SRL V1, S0, 12
9D00670C  00031880   SLL V1, V1, 2
9D006710  00711821   ADDU V1, V1, S1
9D006714  32020FFF   ANDI V0, S0, 4095
9D006718  8C630000   LW V1, 0(V1)
9D00671C  00621021   ADDU V0, V1, V0
9D00675C  00121302   SRL V0, S2, 12
9D006760  00021080   SLL V0, V0, 2
9D006764  00511021   ADDU V0, V0, S1
9D006768  32520FFF   ANDI S2, S2, 4095
9D00676C  8C420000   LW V0, 0(V0)
9D006770  00521021   ADDU V0, V0, S2
9D006794  00101B02   SRL V1, S0, 12
9D006798  00031880   SLL V1, V1, 2
9D00679C  00711821   ADDU V1, V1, S1
9D0067A0  32020FFF   ANDI V0, S0, 4095
9D0067A4  8C630000   LW V1, 0(V1)
9D0067A8  00621021   ADDU V0, V1, V0
9D0067E8  00121302   SRL V0, S2, 12
9D0067EC  00021080   SLL V0, V0, 2
9D0067F0  00511021   ADDU V0, V0, S1
9D0067F4  32520FFF   ANDI S2, S2, 4095
9D0067F8  8C420000   LW V0, 0(V0)
9D0067FC  00521021   ADDU V0, V0, S2
9D006820  00101B02   SRL V1, S0, 12
9D006824  00031880   SLL V1, V1, 2
9D006828  00711821   ADDU V1, V1, S1
9D00682C  32020FFF   ANDI V0, S0, 4095
9D006830  8C630000   LW V1, 0(V1)
9D006834  00621021   ADDU V0, V1, V0
9D006874  00121302   SRL V0, S2, 12
9D006878  00021080   SLL V0, V0, 2
9D00687C  00511021   ADDU V0, V0, S1
9D006880  32520FFF   ANDI S2, S2, 4095
9D006884  8C420000   LW V0, 0(V0)
9D006888  00521021   ADDU V0, V0, S2
9D0068AC  00101B02   SRL V1, S0, 12
9D0068B0  00031880   SLL V1, V1, 2
9D0068B4  00711821   ADDU V1, V1, S1
9D0068B8  32020FFF   ANDI V0, S0, 4095
9D0068BC  8C630000   LW V1, 0(V1)
9D0068C0  00621021   ADDU V0, V1, V0
9D006904  00121302   SRL V0, S2, 12
9D006908  00021080   SLL V0, V0, 2
9D00690C  00511021   ADDU V0, V0, S1
9D006910  32520FFF   ANDI S2, S2, 4095
9D006914  8C420000   LW V0, 0(V0)
9D006918  00521021   ADDU V0, V0, S2
9D00696C  00101B02   SRL V1, S0, 12
9D006970  00031880   SLL V1, V1, 2
9D006974  00711821   ADDU V1, V1, S1
9D006978  32020FFF   ANDI V0, S0, 4095
9D00697C  8C630000   LW V1, 0(V1)
9D006980  00621021   ADDU V0, V1, V0
9D0069AC  00101B02   SRL V1, S0, 12
9D0069B0  00031880   SLL V1, V1, 2
9D0069B4  00711821   ADDU V1, V1, S1
9D0069B8  32020FFF   ANDI V0, S0, 4095
9D0069BC  8C630000   LW V1, 0(V1)
9D0069C0  00621021   ADDU V0, V1, V0
9D0069C4  90530000   LBU S3, 0(V0)
9D0069E4  0260A021   ADDU S4, S3, ZERO
9D0069E8  0B4027B2   J .L45
9D0069EC  0260A821   ADDU S5, S3, ZERO
9D0069F4  00121302   SRL V0, S2, 12
9D0069F8  00021080   SLL V0, V0, 2
9D0069FC  00511021   ADDU V0, V0, S1
9D006A00  32520FFF   ANDI S2, S2, 4095
9D006A04  8C420000   LW V0, 0(V0)
9D006A08  00521021   ADDU V0, V0, S2
9D006A1C  0260A021   ADDU S4, S3, ZERO
9D006A58  00101B02   SRL V1, S0, 12
9D006A5C  00031880   SLL V1, V1, 2
9D006A60  00711821   ADDU V1, V1, S1
9D006A64  32020FFF   ANDI V0, S0, 4095
9D006A68  8C630000   LW V1, 0(V1)
9D006A6C  00621021   ADDU V0, V1, V0
9D006AA0  00101B02   SRL V1, S0, 12
9D006AA4  00031880   SLL V1, V1, 2
9D006AA8  00711821   ADDU V1, V1, S1
9D006AAC  32020FFF   ANDI V0, S0, 4095
9D006AB0  8C630000   LW V1, 0(V1)
9D006AB4  00621021   ADDU V0, V1, V0
9D006AF0  00121302   SRL V0, S2, 12
9D006AF4  00021080   SLL V0, V0, 2
9D006AF8  00511021   ADDU V0, V0, S1
9D006AFC  32520FFF   ANDI S2, S2, 4095
9D006B00  8C420000   LW V0, 0(V0)
9D006B04  00521021   ADDU V0, V0, S2
9D006BA4  00121302   SRL V0, S2, 12
9D006BA8  00021080   SLL V0, V0, 2
9D006BAC  00511021   ADDU V0, V0, S1
9D006BB0  32520FFF   ANDI S2, S2, 4095
9D006BB4  8C420000   LW V0, 0(V0)
9D006BB8  00521021   ADDU V0, V0, S2
9D006C54  00121302   SRL V0, S2, 12
9D006C58  00021080   SLL V0, V0, 2
9D006C5C  00511021   ADDU V0, V0, S1
9D006C60  32520FFF   ANDI S2, S2, 4095
9D006C64  8C420000   LW V0, 0(V0)
9D006C68  00521021   ADDU V0, V0, S2
9D006D04  00121302   SRL V0, S2, 12
9D006D08  00021080   SLL V0, V0, 2
9D006D0C  00511021   ADDU V0, V0, S1
9D006D10  32520FFF   ANDI S2, S2, 4095
9D006D14  8C420000   LW V0, 0(V0)
9D006D18  00521021   ADDU V0, V0, S2
9D006DB8  00121302   SRL V0, S2, 12
9D006DBC  00021080   SLL V0, V0, 2
9D006DC0  00511021   ADDU V0, V0, S1
9D006DC4  32520FFF   ANDI S2, S2, 4095
9D006DC8  8C420000   LW V0, 0(V0)
9D006DCC  00521021   ADDU V0, V0, S2
9D006DFC  00101B02   SRL V1, S0, 12
9D006E00  00031880   SLL V1, V1, 2
9D006E04  00711821   ADDU V1, V1, S1
9D006E08  32100FFF   ANDI S0, S0, 4095
9D006E0C  8C630000   LW V1, 0(V1)
9D006E10  00701821   ADDU V1, V1, S0
9D006E84  00121302   SRL V0, S2, 12
9D006E88  00021080   SLL V0, V0, 2
9D006E8C  00511021   ADDU V0, V0, S1
9D006E90  32520FFF   ANDI S2, S2, 4095
9D006E94  8C420000   LW V0, 0(V0)
9D006E98  00521021   ADDU V0, V0, S2
9D006EB0  00101B02   SRL V1, S0, 12
9D006EB4  00031880   SLL V1, V1, 2
9D006EB8  00711821   ADDU V1, V1, S1
9D006EBC  32020FFF   ANDI V0, S0, 4095
9D006EC0  8C630000   LW V1, 0(V1)
9D006EC4  00621021   ADDU V0, V1, V0
9D006F50  00121302   SRL V0, S2, 12
9D006F54  00021080   SLL V0, V0, 2
9D006F58  00511021   ADDU V0, V0, S1
9D006F5C  32520FFF   ANDI S2, S2, 4095
9D006F60  8C420000   LW V0, 0(V0)
9D006F64  00521021   ADDU V0, V0, S2
9D006F84  00101B02   SRL V1, S0, 12
9D006F88  00031880   SLL V1, V1, 2
9D006F8C  00711821   ADDU V1, V1, S1
9D006F90  32020FFF   ANDI V0, S0, 4095
9D006F94  8C630000   LW V1, 0(V1)
9D006F98  00621021   ADDU V0, V1, V0
9D007028  00121302   SRL V0, S2, 12
9D00702C  00021080   SLL V0, V0, 2
9D007030  00511021   ADDU V0, V0, S1
9D007034  32520FFF   ANDI S2, S2, 4095
9D007038  8C420000   LW V0, 0(V0)
9D00703C  00521021   ADDU V0, V0, S2
9D007064  00101B02   SRL V1, S0, 12
9D007068  00031880   SLL V1, V1, 2
9D00706C  00711821   ADDU V1, V1, S1
9D007070  32020FFF   ANDI V0, S0, 4095
9D007074  8C630000   LW V1, 0(V1)
9D007078  00621021   ADDU V0, V1, V0
9D0070C0  00121302   SRL V0, S2, 12
9D0070C4  00021080   SLL V0, V0, 2
9D0070C8  00511021   ADDU V0, V0, S1
9D0070CC  32520FFF   ANDI S2, S2, 4095
9D0070D0  8C420000   LW V0, 0(V0)
9D0070D4  00521021   ADDU V0, V0, S2
9D0070F8  00101B02   SRL V1, S0, 12
9D0070FC  00031880   SLL V1, V1, 2
9D007100  00711821   ADDU V1, V1, S1
9D007104  32020FFF   ANDI V0, S0, 4095
9D007108  8C630000   LW V1, 0(V1)
9D00710C  00621021   ADDU V0, V1, V0
9D007154  00121302   SRL V0, S2, 12
9D007158  00021080   SLL V0, V0, 2
9D00715C  00511021   ADDU V0, V0, S1
9D007160  32520FFF   ANDI S2, S2, 4095
9D007164  8C420000   LW V0, 0(V0)
9D007168  00521021   ADDU V0, V0, S2
9D00718C  00101B02   SRL V1, S0, 12
9D007190  00031880   SLL V1, V1, 2
9D007194  00711821   ADDU V1, V1, S1
9D007198  32020FFF   ANDI V0, S0, 4095
9D00719C  8C630000   LW V1, 0(V1)
9D0071A0  00621021   ADDU V0, V1, V0
9D0071EC  00121302   SRL V0, S2, 12
9D0071F0  00021080   SLL V0, V0, 2
9D0071F4  00511021   ADDU V0, V0, S1
9D0071F8  32520FFF   ANDI S2, S2, 4095
9D0071FC  8C420000   LW V0, 0(V0)
9D007200  00521021   ADDU V0, V0, S2
9D007224  00101B02   SRL V1, S0, 12
9D007228  00031880   SLL V1, V1, 2
9D00722C  00711821   ADDU V1, V1, S1
9D007230  32020FFF   ANDI V0, S0, 4095
9D007234  8C630000   LW V1, 0(V1)
9D007238  00621021   ADDU V0, V1, V0
9D007288  00121302   SRL V0, S2, 12
9D00728C  00021080   SLL V0, V0, 2
9D007290  00511021   ADDU V0, V0, S1
9D007294  32520FFF   ANDI S2, S2, 4095
9D007298  8C420000   LW V0, 0(V0)
9D00729C  00521021   ADDU V0, V0, S2
9D0072E8  00101B02   SRL V1, S0, 12
9D0072EC  00031880   SLL V1, V1, 2
9D0072F0  00711821   ADDU V1, V1, S1
9D0072F4  32020FFF   ANDI V0, S0, 4095
9D0072F8  8C630000   LW V1, 0(V1)
9D0072FC  00621021   ADDU V0, V1, V0
9D0073D0  00121302   SRL V0, S2, 12
9D0073D4  00021080   SLL V0, V0, 2
9D0073D8  00511021   ADDU V0, V0, S1
9D0073DC  32520FFF   ANDI S2, S2, 4095
9D0073E0  8C420000   LW V0, 0(V0)
9D0073E4  00521021   ADDU V0, V0, S2
9D007434  00101B02   SRL V1, S0, 12
9D007438  00031880   SLL V1, V1, 2
9D00743C  00711821   ADDU V1, V1, S1
9D007440  32020FFF   ANDI V0, S0, 4095
9D007444  8C630000   LW V1, 0(V1)
9D007448  00621021   ADDU V0, V1, V0
9D007530  00121302   SRL V0, S2, 12
9D007534  00021080   SLL V0, V0, 2
9D007538  00511021   ADDU V0, V0, S1
9D00753C  32520FFF   ANDI S2, S2, 4095
9D007540  8C420000   LW V0, 0(V0)
9D007544  00521021   ADDU V0, V0, S2
9D007618  00121302   SRL V0, S2, 12
9D00761C  00021080   SLL V0, V0, 2
9D007620  00511021   ADDU V0, V0, S1
9D007624  32520FFF   ANDI S2, S2, 4095
9D007628  8C420000   LW V0, 0(V0)
9D00762C  00521021   ADDU V0, V0, S2
9D0076F8  00121302   SRL V0, S2, 12
9D0076FC  00021080   SLL V0, V0, 2
9D007700  00511021   ADDU V0, V0, S1
9D007704  32520FFF   ANDI S2, S2, 4095
9D007708  8C420000   LW V0, 0(V0)
9D00770C  00521021   ADDU V0, V0, S2
9D0077DC  00121302   SRL V0, S2, 12
9D0077E0  00021080   SLL V0, V0, 2
9D0077E4  00511021   ADDU V0, V0, S1
9D0077E8  32520FFF   ANDI S2, S2, 4095
9D0077EC  8C420000   LW V0, 0(V0)
9D0077F0  00521021   ADDU V0, V0, S2
9D0078C4  00121302   SRL V0, S2, 12
9D0078C8  00021080   SLL V0, V0, 2
9D0078CC  00511021   ADDU V0, V0, S1
9D0078D0  32520FFF   ANDI S2, S2, 4095
9D0078D4  8C420000   LW V0, 0(V0)
9D0078D8  00521021   ADDU V0, V0, S2
9D007900  00101B02   SRL V1, S0, 12
9D007904  00031880   SLL V1, V1, 2
9D007908  00711821   ADDU V1, V1, S1
9D00790C  32020FFF   ANDI V0, S0, 4095
9D007910  8C630000   LW V1, 0(V1)
9D007914  00621021   ADDU V0, V1, V0
9D007958  00121302   SRL V0, S2, 12
9D00795C  00021080   SLL V0, V0, 2
9D007960  00511021   ADDU V0, V0, S1
9D007964  32520FFF   ANDI S2, S2, 4095
9D007968  8C420000   LW V0, 0(V0)
9D00796C  00521021   ADDU V0, V0, S2
9D00798C  00101B02   SRL V1, S0, 12
9D007990  00031880   SLL V1, V1, 2
9D007994  00711821   ADDU V1, V1, S1
9D007998  32020FFF   ANDI V0, S0, 4095
9D00799C  8C630000   LW V1, 0(V1)
9D0079A0  00621021   ADDU V0, V1, V0
9D007A04  00121302   SRL V0, S2, 12
9D007A08  00021080   SLL V0, V0, 2
9D007A0C  00511021   ADDU V0, V0, S1
9D007A10  32520FFF   ANDI S2, S2, 4095
9D007A14  8C420000   LW V0, 0(V0)
9D007A18  00521021   ADDU V0, V0, S2
9D007A38  00101B02   SRL V1, S0, 12
9D007A3C  00031880   SLL V1, V1, 2
9D007A40  00711821   ADDU V1, V1, S1
9D007A44  32020FFF   ANDI V0, S0, 4095
9D007A48  8C630000   LW V1, 0(V1)
9D007A4C  00621021   ADDU V0, V1, V0
9D007AC8  00121302   SRL V0, S2, 12
9D007ACC  00021080   SLL V0, V0, 2
9D007AD0  00511021   ADDU V0, V0, S1
9D007AD4  32520FFF   ANDI S2, S2, 4095
9D007AD8  8C420000   LW V0, 0(V0)
9D007ADC  00521021   ADDU V0, V0, S2
9D007AFC  00101B02   SRL V1, S0, 12
9D007B00  00031880   SLL V1, V1, 2
9D007B04  00711821   ADDU V1, V1, S1
9D007B08  32020FFF   ANDI V0, S0, 4095
9D007B0C  8C630000   LW V1, 0(V1)
9D007B10  00621021   ADDU V0, V1, V0
9D007B60  00121302   SRL V0, S2, 12
9D007B64  00021080   SLL V0, V0, 2
9D007B68  00511021   ADDU V0, V0, S1
9D007B6C  32520FFF   ANDI S2, S2, 4095
9D007B70  8C420000   LW V0, 0(V0)
9D007B74  00521021   ADDU V0, V0, S2
9D007B94  00101B02   SRL V1, S0, 12
9D007B98  00031880   SLL V1, V1, 2
9D007B9C  00711821   ADDU V1, V1, S1
9D007BA0  32020FFF   ANDI V0, S0, 4095
9D007BA4  8C630000   LW V1, 0(V1)
9D007BA8  00621021   ADDU V0, V1, V0
9D007BF4  00121302   SRL V0, S2, 12
9D007BF8  00021080   SLL V0, V0, 2
9D007BFC  00511021   ADDU V0, V0, S1
9D007C00  32520FFF   ANDI S2, S2, 4095
9D007C04  8C420000   LW V0, 0(V0)
9D007C08  00521021   ADDU V0, V0, S2
9D007C28  00101B02   SRL V1, S0, 12
9D007C2C  00031880   SLL V1, V1, 2
9D007C30  00711821   ADDU V1, V1, S1
9D007C34  32020FFF   ANDI V0, S0, 4095
9D007C38  8C630000   LW V1, 0(V1)
9D007C3C  00621021   ADDU V0, V1, V0
9D007C84  00121302   SRL V0, S2, 12
9D007C88  00021080   SLL V0, V0, 2
9D007C8C  00511021   ADDU V0, V0, S1
9D007C90  32520FFF   ANDI S2, S2, 4095
9D007C94  8C420000   LW V0, 0(V0)
9D007C98  00521021   ADDU V0, V0, S2
9D007CB8  00101B02   SRL V1, S0, 12
9D007CBC  00031880   SLL V1, V1, 2
9D007CC0  00711821   ADDU V1, V1, S1
9D007CC4  32020FFF   ANDI V0, S0, 4095
9D007CC8  8C630000   LW V1, 0(V1)
9D007CCC  00621021   ADDU V0, V1, V0
9D007D24  00121302   SRL V0, S2, 12
9D007D28  00021080   SLL V0, V0, 2
9D007D2C  00511021   ADDU V0, V0, S1
9D007D30  32520FFF   ANDI S2, S2, 4095
9D007D34  8C420000   LW V0, 0(V0)
9D007D38  00521021   ADDU V0, V0, S2
9D007D8C  00101B02   SRL V1, S0, 12
9D007D90  00031880   SLL V1, V1, 2
9D007D94  00711821   ADDU V1, V1, S1
9D007D98  32020FFF   ANDI V0, S0, 4095
9D007D9C  8C630000   LW V1, 0(V1)
9D007DA0  00621021   ADDU V0, V1, V0
9D007DC8  00101B02   SRL V1, S0, 12
9D007DCC  00031880   SLL V1, V1, 2
9D007DD0  00711821   ADDU V1, V1, S1
9D007DD4  32020FFF   ANDI V0, S0, 4095
9D007DD8  8C630000   LW V1, 0(V1)
9D007DDC  00621021   ADDU V0, V1, V0
9D007E1C  00121302   SRL V0, S2, 12
9D007E20  00021080   SLL V0, V0, 2
9D007E24  00511021   ADDU V0, V0, S1
9D007E28  32520FFF   ANDI S2, S2, 4095
9D007E2C  8C420000   LW V0, 0(V0)
9D007E30  00521021   ADDU V0, V0, S2
9D007E80  00101B02   SRL V1, S0, 12
9D007E84  00031880   SLL V1, V1, 2
9D007E88  00711821   ADDU V1, V1, S1
9D007E8C  32020FFF   ANDI V0, S0, 4095
9D007E90  8C630000   LW V1, 0(V1)
9D007E94  00621021   ADDU V0, V1, V0
9D007EC4  00101B02   SRL V1, S0, 12
9D007EC8  00031880   SLL V1, V1, 2
9D007ECC  00711821   ADDU V1, V1, S1
9D007ED0  32020FFF   ANDI V0, S0, 4095
9D007ED4  8C630000   LW V1, 0(V1)
9D007ED8  00621021   ADDU V0, V1, V0
9D007F1C  00121302   SRL V0, S2, 12
9D007F20  00021080   SLL V0, V0, 2
9D007F24  00511021   ADDU V0, V0, S1
9D007F28  32520FFF   ANDI S2, S2, 4095
9D007F2C  8C420000   LW V0, 0(V0)
9D007F30  00521021   ADDU V0, V0, S2
9D007FD8  00121302   SRL V0, S2, 12
9D007FDC  00021080   SLL V0, V0, 2
9D007FE0  00511021   ADDU V0, V0, S1
9D007FE4  32520FFF   ANDI S2, S2, 4095
9D007FE8  8C420000   LW V0, 0(V0)
9D007FEC  00521021   ADDU V0, V0, S2
9D00808C  00121302   SRL V0, S2, 12
9D008090  00021080   SLL V0, V0, 2
9D008094  00511021   ADDU V0, V0, S1
9D008098  32520FFF   ANDI S2, S2, 4095
9D00809C  8C420000   LW V0, 0(V0)
9D0080A0  00521021   ADDU V0, V0, S2
9D008148  00121302   SRL V0, S2, 12
9D00814C  00021080   SLL V0, V0, 2
9D008150  00511021   ADDU V0, V0, S1
9D008154  32520FFF   ANDI S2, S2, 4095
9D008158  8C420000   LW V0, 0(V0)
9D00815C  00521021   ADDU V0, V0, S2
9D008214  00121302   SRL V0, S2, 12
9D008218  00021080   SLL V0, V0, 2
9D00821C  00511021   ADDU V0, V0, S1
9D008220  32520FFF   ANDI S2, S2, 4095
9D008224  8C420000   LW V0, 0(V0)
9D008228  00521021   ADDU V0, V0, S2
9D008250  00101B02   SRL V1, S0, 12
9D008254  00031880   SLL V1, V1, 2
9D008258  00711821   ADDU V1, V1, S1
9D00825C  32100FFF   ANDI S0, S0, 4095
9D008260  8C630000   LW V1, 0(V1)
9D008264  00701821   ADDU V1, V1, S0
9D0082D8  00121302   SRL V0, S2, 12
9D0082DC  00021080   SLL V0, V0, 2
9D0082E0  00511021   ADDU V0, V0, S1
9D0082E4  32520FFF   ANDI S2, S2, 4095
9D0082E8  8C420000   LW V0, 0(V0)
9D0082EC  00521021   ADDU V0, V0, S2
9D008304  00101B02   SRL V1, S0, 12
9D008308  00031880   SLL V1, V1, 2
9D00830C  00711821   ADDU V1, V1, S1
9D008310  32020FFF   ANDI V0, S0, 4095
9D008314  8C630000   LW V1, 0(V1)
9D008318  00621021   ADDU V0, V1, V0
9D0083AC  00121302   SRL V0, S2, 12
9D0083B0  00021080   SLL V0, V0, 2
9D0083B4  00511021   ADDU V0, V0, S1
9D0083B8  32520FFF   ANDI S2, S2, 4095
9D0083BC  8C420000   LW V0, 0(V0)
9D0083C0  00521021   ADDU V0, V0, S2
9D0083E0  00101B02   SRL V1, S0, 12
9D0083E4  00031880   SLL V1, V1, 2
9D0083E8  00711821   ADDU V1, V1, S1
9D0083EC  32020FFF   ANDI V0, S0, 4095
9D0083F0  8C630000   LW V1, 0(V1)
9D0083F4  00621021   ADDU V0, V1, V0
9D008474  00121302   SRL V0, S2, 12
9D008478  00021080   SLL V0, V0, 2
9D00847C  00511021   ADDU V0, V0, S1
9D008480  32520FFF   ANDI S2, S2, 4095
9D008484  8C420000   LW V0, 0(V0)
9D008488  00521021   ADDU V0, V0, S2
9D0084A8  00101B02   SRL V1, S0, 12
9D0084AC  00031880   SLL V1, V1, 2
9D0084B0  00711821   ADDU V1, V1, S1
9D0084B4  32020FFF   ANDI V0, S0, 4095
9D0084B8  8C630000   LW V1, 0(V1)
9D0084BC  00621021   ADDU V0, V1, V0
9D008510  00121302   SRL V0, S2, 12
9D008514  00021080   SLL V0, V0, 2
9D008518  00511021   ADDU V0, V0, S1
9D00851C  32520FFF   ANDI S2, S2, 4095
9D008520  8C420000   LW V0, 0(V0)
9D008524  00521021   ADDU V0, V0, S2
9D008544  00101B02   SRL V1, S0, 12
9D008548  00031880   SLL V1, V1, 2
9D00854C  00711821   ADDU V1, V1, S1
9D008550  32020FFF   ANDI V0, S0, 4095
9D008554  8C630000   LW V1, 0(V1)
9D008558  00621021   ADDU V0, V1, V0
9D0085A8  00121302   SRL V0, S2, 12
9D0085AC  00021080   SLL V0, V0, 2
9D0085B0  00511021   ADDU V0, V0, S1
9D0085B4  32520FFF   ANDI S2, S2, 4095
9D0085B8  8C420000   LW V0, 0(V0)
9D0085BC  00521021   ADDU V0, V0, S2
9D0085DC  00101B02   SRL V1, S0, 12
9D0085E0  00031880   SLL V1, V1, 2
9D0085E4  00711821   ADDU V1, V1, S1
9D0085E8  32020FFF   ANDI V0, S0, 4095
9D0085EC  8C630000   LW V1, 0(V1)
9D0085F0  00621021   ADDU V0, V1, V0
9D008650  00121302   SRL V0, S2, 12
9D008654  00021080   SLL V0, V0, 2
9D008658  00511021   ADDU V0, V0, S1
9D00865C  32520FFF   ANDI S2, S2, 4095
9D008660  8C420000   LW V0, 0(V0)
9D008664  00521021   ADDU V0, V0, S2
9D0086A8  00101B02   SRL V1, S0, 12
9D0086AC  00031880   SLL V1, V1, 2
9D0086B0  00711821   ADDU V1, V1, S1
9D0086B4  32020FFF   ANDI V0, S0, 4095
9D0086B8  8C630000   LW V1, 0(V1)
9D0086BC  00621021   ADDU V0, V1, V0
9D008794  00121302   SRL V0, S2, 12
9D008798  00021080   SLL V0, V0, 2
9D00879C  00511021   ADDU V0, V0, S1
9D0087A0  32520FFF   ANDI S2, S2, 4095
9D0087A4  8C420000   LW V0, 0(V0)
9D0087A8  00521021   ADDU V0, V0, S2
9D00886C  00121302   SRL V0, S2, 12
9D008870  00021080   SLL V0, V0, 2
9D008874  00511021   ADDU V0, V0, S1
9D008878  32520FFF   ANDI S2, S2, 4095
9D00887C  8C420000   LW V0, 0(V0)
9D008880  00521021   ADDU V0, V0, S2
9D008950  00121302   SRL V0, S2, 12
9D008954  00021080   SLL V0, V0, 2
9D008958  00511021   ADDU V0, V0, S1
9D00895C  32520FFF   ANDI S2, S2, 4095
9D008960  8C420000   LW V0, 0(V0)
9D008964  00521021   ADDU V0, V0, S2
9D008A14  00121302   SRL V0, S2, 12
9D008A18  00021080   SLL V0, V0, 2
9D008A1C  00511021   ADDU V0, V0, S1
9D008A20  32520FFF   ANDI S2, S2, 4095
9D008A24  8C420000   LW V0, 0(V0)
9D008A28  00521021   ADDU V0, V0, S2
9D008AE8  00121302   SRL V0, S2, 12
9D008AEC  00021080   SLL V0, V0, 2
9D008AF0  00511021   ADDU V0, V0, S1
9D008AF4  32520FFF   ANDI S2, S2, 4095
9D008AF8  8C420000   LW V0, 0(V0)
9D008AFC  00521021   ADDU V0, V0, S2
9D008B1C  00101B02   SRL V1, S0, 12
9D008B20  00031880   SLL V1, V1, 2
9D008B24  00711821   ADDU V1, V1, S1
9D008B28  32020FFF   ANDI V0, S0, 4095
9D008B2C  8C630000   LW V1, 0(V1)
9D008B30  00621021   ADDU V0, V1, V0
9D008B70  00121302   SRL V0, S2, 12
9D008B74  00021080   SLL V0, V0, 2
9D008B78  00511021   ADDU V0, V0, S1
9D008B7C  32520FFF   ANDI S2, S2, 4095
9D008B80  8C420000   LW V0, 0(V0)
9D008B84  00521021   ADDU V0, V0, S2
9D008BA4  00101B02   SRL V1, S0, 12
9D008BA8  00031880   SLL V1, V1, 2
9D008BAC  00711821   ADDU V1, V1, S1
9D008BB0  32020FFF   ANDI V0, S0, 4095
9D008BB4  8C630000   LW V1, 0(V1)
9D008BB8  00621021   ADDU V0, V1, V0
9D008C40  00121302   SRL V0, S2, 12
9D008C44  00021080   SLL V0, V0, 2
9D008C48  00511021   ADDU V0, V0, S1
9D008C4C  32520FFF   ANDI S2, S2, 4095
9D008C50  8C420000   LW V0, 0(V0)
9D008C54  00521021   ADDU V0, V0, S2
9D008C78  00101B02   SRL V1, S0, 12
9D008C7C  00031880   SLL V1, V1, 2
9D008C80  00711821   ADDU V1, V1, S1
9D008C84  32020FFF   ANDI V0, S0, 4095
9D008C88  8C630000   LW V1, 0(V1)
9D008C8C  00621021   ADDU V0, V1, V0
9D008D2C  00121302   SRL V0, S2, 12
9D008D30  00021080   SLL V0, V0, 2
9D008D34  00511021   ADDU V0, V0, S1
9D008D38  32520FFF   ANDI S2, S2, 4095
9D008D3C  8C420000   LW V0, 0(V0)
9D008D40  00521021   ADDU V0, V0, S2
9D008D64  00101B02   SRL V1, S0, 12
9D008D68  00031880   SLL V1, V1, 2
9D008D6C  00711821   ADDU V1, V1, S1
9D008D70  32020FFF   ANDI V0, S0, 4095
9D008D74  8C630000   LW V1, 0(V1)
9D008D78  00621021   ADDU V0, V1, V0
9D008DC4  00121302   SRL V0, S2, 12
9D008DC8  00021080   SLL V0, V0, 2
9D008DCC  00511021   ADDU V0, V0, S1
9D008DD0  32520FFF   ANDI S2, S2, 4095
9D008DD4  8C420000   LW V0, 0(V0)
9D008DD8  00521021   ADDU V0, V0, S2
9D008DF8  00101B02   SRL V1, S0, 12
9D008DFC  00031880   SLL V1, V1, 2
9D008E00  00711821   ADDU V1, V1, S1
9D008E04  32020FFF   ANDI V0, S0, 4095
9D008E08  8C630000   LW V1, 0(V1)
9D008E0C  00621021   ADDU V0, V1, V0
9D008E7C  00121302   SRL V0, S2, 12
9D008E80  00021080   SLL V0, V0, 2
9D008E84  00511021   ADDU V0, V0, S1
9D008E88  32520FFF   ANDI S2, S2, 4095
9D008E8C  8C420000   LW V0, 0(V0)
9D008E90  00521021   ADDU V0, V0, S2
9D008EB4  00101B02   SRL V1, S0, 12
9D008EB8  00031880   SLL V1, V1, 2
9D008EBC  00711821   ADDU V1, V1, S1
9D008EC0  32020FFF   ANDI V0, S0, 4095
9D008EC4  8C630000   LW V1, 0(V1)
9D008EC8  00621021   ADDU V0, V1, V0
9D008F10  00121302   SRL V0, S2, 12
9D008F14  00021080   SLL V0, V0, 2
9D008F18  00511021   ADDU V0, V0, S1
9D008F1C  32520FFF   ANDI S2, S2, 4095
9D008F20  8C420000   LW V0, 0(V0)
9D008F24  00521021   ADDU V0, V0, S2
9D008F44  00101B02   SRL V1, S0, 12
9D008F48  00031880   SLL V1, V1, 2
9D008F4C  00711821   ADDU V1, V1, S1
9D008F50  32020FFF   ANDI V0, S0, 4095
9D008F54  8C630000   LW V1, 0(V1)
9D008F58  00621021   ADDU V0, V1, V0
9D008FD4  00121302   SRL V0, S2, 12
9D008FD8  00021080   SLL V0, V0, 2
9D008FDC  00511021   ADDU V0, V0, S1
9D008FE0  32520FFF   ANDI S2, S2, 4095
9D008FE4  8C420000   LW V0, 0(V0)
9D008FE8  00521021   ADDU V0, V0, S2
9D00903C  00101B02   SRL V1, S0, 12
9D009040  00031880   SLL V1, V1, 2
9D009044  00711821   ADDU V1, V1, S1
9D009048  32020FFF   ANDI V0, S0, 4095
9D00904C  8C630000   LW V1, 0(V1)
9D009050  00621021   ADDU V0, V1, V0
9D009078  00101B02   SRL V1, S0, 12
9D00907C  00031880   SLL V1, V1, 2
9D009080  00711821   ADDU V1, V1, S1
9D009084  32020FFF   ANDI V0, S0, 4095
9D009088  8C630000   LW V1, 0(V1)
9D00908C  00621021   ADDU V0, V1, V0
9D009090  90430000   LBU V1, 0(V0)
9D0090F0  00121302   SRL V0, S2, 12
9D0090F4  00021080   SLL V0, V0, 2
9D0090F8  00511021   ADDU V0, V0, S1
9D0090FC  32520FFF   ANDI S2, S2, 4095
9D009100  8C420000   LW V0, 0(V0)
9D009104  00521021   ADDU V0, V0, S2
9D009148  00101B02   SRL V1, S0, 12
9D00914C  00031880   SLL V1, V1, 2
9D009150  00711821   ADDU V1, V1, S1
9D009154  32020FFF   ANDI V0, S0, 4095
9D009158  8C630000   LW V1, 0(V1)
9D00915C  00621021   ADDU V0, V1, V0
9D0091FC  00121302   SRL V0, S2, 12
9D009200  00021080   SLL V0, V0, 2
9D009204  00511021   ADDU V0, V0, S1
9D009208  32520FFF   ANDI S2, S2, 4095
9D00920C  8C420000   LW V0, 0(V0)
9D009210  00521021   ADDU V0, V0, S2
9D0092D4  00121302   SRL V0, S2, 12
9D0092D8  00021080   SLL V0, V0, 2
9D0092DC  00511021   ADDU V0, V0, S1
9D0092E0  32520FFF   ANDI S2, S2, 4095
9D0092E4  8C420000   LW V0, 0(V0)
9D0092E8  00521021   ADDU V0, V0, S2
9D009394  00121302   SRL V0, S2, 12
9D009398  00021080   SLL V0, V0, 2
9D00939C  00511021   ADDU V0, V0, S1
9D0093A0  32520FFF   ANDI S2, S2, 4095
9D0093A4  8C420000   LW V0, 0(V0)
9D0093A8  00521021   ADDU V0, V0, S2
9D009484  00121302   SRL V0, S2, 12
9D009488  00021080   SLL V0, V0, 2
9D00948C  00511021   ADDU V0, V0, S1
9D009490  32520FFF   ANDI S2, S2, 4095
9D009494  8C420000   LW V0, 0(V0)
9D009498  00521021   ADDU V0, V0, S2
9D0094C4  00101B02   SRL V1, S0, 12
9D0094C8  00031880   SLL V1, V1, 2
9D0094CC  00711821   ADDU V1, V1, S1
9D0094D0  32100FFF   ANDI S0, S0, 4095
9D0094D4  8C630000   LW V1, 0(V1)
9D0094D8  00701821   ADDU V1, V1, S0
9D00954C  00121302   SRL V0, S2, 12
9D009550  00021080   SLL V0, V0, 2
9D009554  00511021   ADDU V0, V0, S1
9D009558  32520FFF   ANDI S2, S2, 4095
9D00955C  8C420000   LW V0, 0(V0)
9D009560  00521021   ADDU V0, V0, S2
9D009578  00101B02   SRL V1, S0, 12
9D00957C  00031880   SLL V1, V1, 2
9D009580  00711821   ADDU V1, V1, S1
9D009584  32020FFF   ANDI V0, S0, 4095
9D009588  8C630000   LW V1, 0(V1)
9D00958C  00621021   ADDU V0, V1, V0
9D009640  00121302   SRL V0, S2, 12
9D009644  00021080   SLL V0, V0, 2
9D009648  00511021   ADDU V0, V0, S1
9D00964C  32520FFF   ANDI S2, S2, 4095
9D009650  8C420000   LW V0, 0(V0)
9D009654  00521021   ADDU V0, V0, S2
9D009678  00101B02   SRL V1, S0, 12
9D00967C  00031880   SLL V1, V1, 2
9D009680  00711821   ADDU V1, V1, S1
9D009684  32020FFF   ANDI V0, S0, 4095
9D009688  8C630000   LW V1, 0(V1)
9D00968C  00621021   ADDU V0, V1, V0
9D009730  00121302   SRL V0, S2, 12
9D009734  00021080   SLL V0, V0, 2
9D009738  00511021   ADDU V0, V0, S1
9D00973C  32520FFF   ANDI S2, S2, 4095
9D009740  8C420000   LW V0, 0(V0)
9D009744  00521021   ADDU V0, V0, S2
9D009768  00101B02   SRL V1, S0, 12
9D00976C  00031880   SLL V1, V1, 2
9D009770  00711821   ADDU V1, V1, S1
9D009774  32020FFF   ANDI V0, S0, 4095
9D009778  8C630000   LW V1, 0(V1)
9D00977C  00621021   ADDU V0, V1, V0
9D0097F4  00121302   SRL V0, S2, 12
9D0097F8  00021080   SLL V0, V0, 2
9D0097FC  00511021   ADDU V0, V0, S1
9D009800  32520FFF   ANDI S2, S2, 4095
9D009804  8C420000   LW V0, 0(V0)
9D009808  00521021   ADDU V0, V0, S2
9D00982C  00101B02   SRL V1, S0, 12
9D009830  00031880   SLL V1, V1, 2
9D009834  00711821   ADDU V1, V1, S1
9D009838  32020FFF   ANDI V0, S0, 4095
9D00983C  8C630000   LW V1, 0(V1)
9D009840  00621021   ADDU V0, V1, V0
9D009890  00121302   SRL V0, S2, 12
9D009894  00021080   SLL V0, V0, 2
9D009898  00511021   ADDU V0, V0, S1
9D00989C  32520FFF   ANDI S2, S2, 4095
9D0098A0  8C420000   LW V0, 0(V0)
9D0098A4  00521021   ADDU V0, V0, S2
9D0098C4  00101B02   SRL V1, S0, 12
9D0098C8  00031880   SLL V1, V1, 2
9D0098CC  00711821   ADDU V1, V1, S1
9D0098D0  32020FFF   ANDI V0, S0, 4095
9D0098D4  8C630000   LW V1, 0(V1)
9D0098D8  00621021   ADDU V0, V1, V0
9D00995C  00121302   SRL V0, S2, 12
9D009960  00021080   SLL V0, V0, 2
9D009964  00511021   ADDU V0, V0, S1
9D009968  32520FFF   ANDI S2, S2, 4095
9D00996C  8C420000   LW V0, 0(V0)
9D009970  00521021   ADDU V0, V0, S2
9D0099BC  00101B02   SRL V1, S0, 12
9D0099C0  00031880   SLL V1, V1, 2
9D0099C4  00711821   ADDU V1, V1, S1
9D0099C8  32020FFF   ANDI V0, S0, 4095
9D0099CC  8C630000   LW V1, 0(V1)
9D0099D0  00621021   ADDU V0, V1, V0
9D009ACC  00121302   SRL V0, S2, 12
9D009AD0  00021080   SLL V0, V0, 2
9D009AD4  00511021   ADDU V0, V0, S1
9D009AD8  32520FFF   ANDI S2, S2, 4095
9D009ADC  8C420000   LW V0, 0(V0)
9D009AE0  00521021   ADDU V0, V0, S2
9D009BCC  00121302   SRL V0, S2, 12
9D009BD0  00021080   SLL V0, V0, 2
9D009BD4  00511021   ADDU V0, V0, S1
9D009BD8  32520FFF   ANDI S2, S2, 4095
9D009BDC  8C420000   LW V0, 0(V0)
9D009BE0  00521021   ADDU V0, V0, S2
9D009CD4  00121302   SRL V0, S2, 12
9D009CD8  00021080   SLL V0, V0, 2
9D009CDC  00511021   ADDU V0, V0, S1
9D009CE0  32520FFF   ANDI S2, S2, 4095
9D009CE4  8C420000   LW V0, 0(V0)
9D009CE8  00521021   ADDU V0, V0, S2
9D009D9C  00121302   SRL V0, S2, 12
9D009DA0  00021080   SLL V0, V0, 2
9D009DA4  00511021   ADDU V0, V0, S1
9D009DA8  32520FFF   ANDI S2, S2, 4095
9D009DAC  8C420000   LW V0, 0(V0)
9D009DB0  00521021   ADDU V0, V0, S2
9D009E94  00121302   SRL V0, S2, 12
9D009E98  00021080   SLL V0, V0, 2
9D009E9C  00511021   ADDU V0, V0, S1
9D009EA0  32520FFF   ANDI S2, S2, 4095
9D009EA4  8C420000   LW V0, 0(V0)
9D009EA8  00521021   ADDU V0, V0, S2
1196:                }
1197:                
1198:                INLINE void bank_writebyte(register uint32 address, register uint8 value)
1199:                {
1200:                   cpu.mem_page[address >> NES6502_BANKSHIFT][address & NES6502_BANKMASK] = value;
9D00014C  00041B02   SRL V1, A0, 12
9D000150  00031880   SLL V1, V1, 2
9D000154  3C02A001   LUI V0, -24575
9D000158  24428FD0   ADDIU V0, V0, -28720
9D00015C  00621021   ADDU V0, V1, V0
9D000160  30840FFF   ANDI A0, A0, 4095
9D000164  8C420000   LW V0, 0(V0)
9D000168  00442021   ADDU A0, V0, A0
9D00016C  A0850000   SB A1, 0(A0)
1201:                }
1202:                
1203:                /* read a byte of 6502 memory */
1204:                static uint8 mem_readbyte(uint32 address)
1205:                {
9D000000  27BDFFE8   ADDIU SP, SP, -24
1206:                   nes6502_memread *mr;
1207:                
1208:                   /* TODO: following 2 cases are N2A03-specific */
1209:                   if (address < 0x800)
9D000004  2C820800   SLTIU V0, A0, 2048
9D000008  10400005   BEQ V0, ZERO, 0x9D000020
9D00000C  AFBF0014   SW RA, 20(SP)
1210:                   {
1211:                      /* RAM */
1212:                      return ram[address];
9D000010  8F828054   LW V0, -32684(GP)
9D000014  00442021   ADDU A0, V0, A0
9D000018  0B400033   J .LBE919
9D00001C  90820000   LBU V0, 0(A0)
1213:                   }
1214:                   else if (address >= 0x8000)
9D000020  34028000   ORI V0, ZERO, -32768
9D000024  0082102B   SLTU V0, A0, V0
9D000028  5440000B   BNEL V0, ZERO, 0x9D000058
9D00002C  3C02A001   LUI V0, -24575
1215:                   {
1216:                      /* always paged memory */
1217:                      return bank_readbyte(address);
9D000050  0B400033   J .LBE919
9D000054  90820000   LBU V0, 0(A0)
1218:                   }
1219:                   /* check memory range handlers */
1220:                   else
1221:                   {
1222:                      for (mr = cpu.read_handler; mr->min_range != 0xFFFFFFFF; mr++)
9D000058  8C429010   LW V0, -28656(V0)
9D00005C  8C430000   LW V1, 0(V0)
9D000060  2405FFFF   ADDIU A1, ZERO, -1
9D000064  50650011   BEQL V1, A1, 0x9D0000AC
9D000068  00041B02   SRL V1, A0, 12
9D00009C  8C430000   LW V1, 0(V0)
9D0000A0  1465FFF3   BNE V1, A1, 0x9D000070
9D0000A4  0083182B   SLTU V1, A0, V1
1223:                      {
1224:                         if (address >= mr->min_range && address <= mr->max_range)
9D00006C  0083182B   SLTU V1, A0, V1
9D000070  5460000A   BNEL V1, ZERO, 0x9D00009C
9D000074  2442000C   ADDIU V0, V0, 12
9D000078  8C430004   LW V1, 4(V0)
9D00007C  0064182B   SLTU V1, V1, A0
9D000080  54600006   BNEL V1, ZERO, 0x9D00009C
9D000084  2442000C   ADDIU V0, V0, 12
1225:                            return mr->read_func(address);
9D000088  8C420008   LW V0, 8(V0)
9D00008C  0040F809   JALR V0
9D000090  00000000   NOP
9D000094  0B400034   J 0x9D0000D0
9D000098  8FBF0014   LW RA, 20(SP)
1226:                      }
1227:                   }
1228:                
1229:                   /* return paged memory */
1230:                   return bank_readbyte(address);
1231:                }
9D0000CC  8FBF0014   LW RA, 20(SP)
9D0000D0  03E00008   JR RA
9D0000D4  27BD0018   ADDIU SP, SP, 24
1232:                
1233:                /* write a byte of data to 6502 memory */
1234:                static void mem_writebyte(uint32 address, uint8 value)
1235:                {
9D0000D8  27BDFFE8   ADDIU SP, SP, -24
1236:                   nes6502_memwrite *mw;
1237:                
1238:                   /* RAM */
1239:                   if (address < 0x800)
9D0000DC  2C820800   SLTIU V0, A0, 2048
9D0000E0  10400005   BEQ V0, ZERO, 0x9D0000F8
9D0000E4  AFBF0014   SW RA, 20(SP)
1240:                   {
1241:                      ram[address] = value;
9D0000E8  8F828054   LW V0, -32684(GP)
9D0000EC  00442021   ADDU A0, V0, A0
1242:                      return;
9D0000F0  0B40005C   J .LBE921
9D0000F4  A0850000   SB A1, 0(A0)
1243:                   }
1244:                   /* check memory range handlers */
1245:                   else
1246:                   {
1247:                      for (mw = cpu.write_handler; mw->min_range != 0xFFFFFFFF; mw++)
9D0000F8  3C02A001   LUI V0, -24575
9D0000FC  8C429014   LW V0, -28652(V0)
9D000100  8C430000   LW V1, 0(V0)
9D000104  2406FFFF   ADDIU A2, ZERO, -1
9D000108  50660011   BEQL V1, A2, 0x9D000150
9D00010C  00041B02   SRL V1, A0, 12
9D000140  8C430000   LW V1, 0(V0)
9D000144  1466FFF3   BNE V1, A2, 0x9D000114
9D000148  0083182B   SLTU V1, A0, V1
1248:                      {
1249:                         if (address >= mw->min_range && address <= mw->max_range)
9D000110  0083182B   SLTU V1, A0, V1
9D000114  5460000A   BNEL V1, ZERO, 0x9D000140
9D000118  2442000C   ADDIU V0, V0, 12
9D00011C  8C430004   LW V1, 4(V0)
9D000120  0064182B   SLTU V1, V1, A0
9D000124  54600006   BNEL V1, ZERO, 0x9D000140
9D000128  2442000C   ADDIU V0, V0, 12
1250:                         {
1251:                            mw->write_func(address, value);
9D00012C  8C420008   LW V0, 8(V0)
9D000130  0040F809   JALR V0
9D000134  00000000   NOP
1252:                            return;
9D000138  0B40005D   J 0x9D000174
9D00013C  8FBF0014   LW RA, 20(SP)
1253:                         }
1254:                      }
1255:                   }
1256:                
1257:                   /* write to paged memory */
1258:                   bank_writebyte(address, value);
1259:                }
9D000170  8FBF0014   LW RA, 20(SP)
9D000174  03E00008   JR RA
9D000178  27BD0018   ADDIU SP, SP, 24
1260:                
1261:                /* set the current context */
1262:                void nes6502_setcontext(nes6502_context *context)
1263:                {
1264:                   int loop;
1265:                
1266:                   ASSERT(context);
1267:                
1268:                   cpu = *context;
9D0001CC  00801021   ADDU V0, A0, ZERO
9D0001D0  3C03A001   LUI V1, -24575
9D0001D4  24638FD0   ADDIU V1, V1, -28720
9D0001D8  24840050   ADDIU A0, A0, 80
9D0001DC  8C480000   LW T0, 0(V0)
9D0001E0  8C470004   LW A3, 4(V0)
9D0001E4  8C460008   LW A2, 8(V0)
9D0001E8  8C45000C   LW A1, 12(V0)
9D0001EC  AC680000   SW T0, 0(V1)
9D0001F0  AC670004   SW A3, 4(V1)
9D0001F4  AC660008   SW A2, 8(V1)
9D0001F8  AC65000C   SW A1, 12(V1)
9D0001FC  24420010   ADDIU V0, V0, 16
9D000200  1444FFF6   BNE V0, A0, 0x9D0001DC
9D000204  24630010   ADDIU V1, V1, 16
9D000208  8C450000   LW A1, 0(V0)
9D00020C  8C440004   LW A0, 4(V0)
9D000210  8C420008   LW V0, 8(V0)
9D000214  AC650000   SW A1, 0(V1)
9D000218  AC640004   SW A0, 4(V1)
9D00021C  AC620008   SW V0, 8(V1)
9D000220  3C02A001   LUI V0, -24575
9D000224  24428FD0   ADDIU V0, V0, -28720
9D000228  24440040   ADDIU A0, V0, 64
1269:                
1270:                   /* set dead page for all pages not pointed at anything */
1271:                   for (loop = 0; loop < NES6502_NUMBANKS; loop++)
9D000244  5444FFFC   BNEL V0, A0, 0x9D000238
9D000248  8C430000   LW V1, 0(V0)
1272:                   {
1273:                      if (NULL == cpu.mem_page[loop])
9D000234  8C430000   LW V1, 0(V0)
9D000238  50600001   BEQL V1, ZERO, 0x9D000240
9D00023C  AC450000   SW A1, 0(V0)
9D000240  24420004   ADDIU V0, V0, 4
1274:                         cpu.mem_page[loop] = null_page;
9D00022C  3C05A000   LUI A1, -24576
9D000230  24A57FD0   ADDIU A1, A1, 32720
1275:                   }
1276:                
1277:                   ram = cpu.mem_page[0];  /* quick zero-page/RAM references */
9D00024C  3C02A001   LUI V0, -24575
9D000250  8C428FD0   LW V0, -28720(V0)
9D000254  AF828054   SW V0, -32684(GP)
1278:                   stack = ram + STACK_OFFSET;
9D000258  24420100   ADDIU V0, V0, 256
9D00025C  03E00008   JR RA
9D000260  AF828050   SW V0, -32688(GP)
1279:                }
1280:                
1281:                /* get the current context */
1282:                void nes6502_getcontext(nes6502_context *context)
1283:                {
1284:                   int loop;
1285:                
1286:                   ASSERT(context);
1287:                
1288:                   *context = cpu;
9D000264  3C02A001   LUI V0, -24575
9D000268  24428FD0   ADDIU V0, V0, -28720
9D00026C  00801821   ADDU V1, A0, ZERO
9D000270  24450050   ADDIU A1, V0, 80
9D000274  8C490000   LW T1, 0(V0)
9D000278  8C480004   LW T0, 4(V0)
9D00027C  8C470008   LW A3, 8(V0)
9D000280  8C46000C   LW A2, 12(V0)
9D000284  AC690000   SW T1, 0(V1)
9D000288  AC680004   SW T0, 4(V1)
9D00028C  AC670008   SW A3, 8(V1)
9D000290  AC66000C   SW A2, 12(V1)
9D000294  24420010   ADDIU V0, V0, 16
9D000298  1445FFF6   BNE V0, A1, 0x9D000274
9D00029C  24630010   ADDIU V1, V1, 16
9D0002A0  8C460000   LW A2, 0(V0)
9D0002A4  8C450004   LW A1, 4(V0)
9D0002A8  8C420008   LW V0, 8(V0)
9D0002AC  AC660000   SW A2, 0(V1)
9D0002B0  AC650004   SW A1, 4(V1)
9D0002B4  AC620008   SW V0, 8(V1)
1289:                
1290:                   /* reset dead pages to null */
1291:                   for (loop = 0; loop < NES6502_NUMBANKS; loop++)
9D0002B8  00001021   ADDU V0, ZERO, ZERO
9D0002C4  24050010   ADDIU A1, ZERO, 16
9D0002D4  24420001   ADDIU V0, V0, 1
9D0002D8  1445FFFB   BNE V0, A1, 0x9D0002C8
9D0002DC  24840004   ADDIU A0, A0, 4
1292:                   {
1293:                      if (null_page == context->mem_page[loop])
9D0002BC  3C06A000   LUI A2, -24576
9D0002C0  24C67FD0   ADDIU A2, A2, 32720
9D0002C8  8C830000   LW V1, 0(A0)
9D0002CC  50660001   BEQL V1, A2, 0x9D0002D4
9D0002D0  AC800000   SW ZERO, 0(A0)
1294:                         context->mem_page[loop] = NULL;
1295:                   }
1296:                }
9D0002E0  03E00008   JR RA
9D0002E4  00000000   NOP
1297:                
1298:                /* DMA a byte of data from ROM */
1299:                uint8 nes6502_getbyte(uint32 address)
1300:                {
1301:                   return bank_readbyte(address);
1302:                }
9D000308  03E00008   JR RA
9D00030C  90820000   LBU V0, 0(A0)
1303:                
1304:                /* get number of elapsed cycles */
1305:                uint32 nes6502_getcycles(bool reset_flag)
1306:                {
1307:                   uint32 cycles = cpu.total_cycles;
9D000310  3C02A001   LUI V0, -24575
1308:                
1309:                   if (reset_flag)
9D000314  10800003   BEQ A0, ZERO, 0x9D000324
9D000318  8C429024   LW V0, -28636(V0)
1310:                      cpu.total_cycles = 0;
9D00031C  3C03A001   LUI V1, -24575
9D000320  AC609024   SW ZERO, -28636(V1)
1311:                
1312:                   return cycles;
1313:                }
9D000324  03E00008   JR RA
9D000328  00000000   NOP
1314:                
1315:                #define  GET_GLOBAL_REGS() \
1316:                { \
1317:                   PC = cpu.pc_reg; \
1318:                   A = cpu.a_reg; \
1319:                   X = cpu.x_reg; \
1320:                   Y = cpu.y_reg; \
1321:                   SCATTER_FLAGS(cpu.p_reg); \
1322:                   S = cpu.s_reg; \
1323:                }
1324:                
1325:                #define  STORE_LOCAL_REGS() \
1326:                { \
1327:                   cpu.pc_reg = PC; \
1328:                   cpu.a_reg = A; \
1329:                   cpu.x_reg = X; \
1330:                   cpu.y_reg = Y; \
1331:                   cpu.p_reg = COMBINE_FLAGS(); \
1332:                   cpu.s_reg = S; \
1333:                }
1334:                
1335:                #define  MIN(a,b)    (((a) < (b)) ? (a) : (b))
1336:                
1337:                #ifdef NES6502_JUMPTABLE
1338:                
1339:                #define  OPCODE_BEGIN(xx)  op##xx:
1340:                #ifdef NES6502_DISASM
1341:                
1342:                #define  OPCODE_END \
1343:                   if (remaining_cycles <= 0) \
1344:                      goto end_execute; \
1345:                   log_printf(nes6502_disasm(PC, COMBINE_FLAGS(), A, X, Y, S)); \
1346:                   goto *opcode_table[bank_readbyte(PC++)];
1347:                
1348:                #else /* !NES6520_DISASM */
1349:                
1350:                #define  OPCODE_END \
1351:                   if (remaining_cycles <= 0) \
1352:                      goto end_execute; \
1353:                   goto *opcode_table[bank_readbyte(PC++)];
1354:                
1355:                #endif /* !NES6502_DISASM */
1356:                
1357:                #else /* !NES6502_JUMPTABLE */
1358:                #define  OPCODE_BEGIN(xx)  case 0x##xx:
1359:                #define  OPCODE_END        break;
1360:                #endif /* !NES6502_JUMPTABLE */
1361:                
1362:                
1363:                /* Execute instructions until count expires
1364:                **
1365:                ** Returns the number of cycles *actually* executed, which will be
1366:                ** anywhere from zero to timeslice_cycles + 6
1367:                */
1368:                int nes6502_execute(int timeslice_cycles)
1369:                {
9D00032C  27BDFFA8   ADDIU SP, SP, -88
9D000330  AFBF0054   SW RA, 84(SP)
9D000334  AFBE0050   SW FP, 80(SP)
9D000338  AFB7004C   SW S7, 76(SP)
9D00033C  AFB60048   SW S6, 72(SP)
9D000340  AFB50044   SW S5, 68(SP)
9D000344  AFB40040   SW S4, 64(SP)
9D000348  AFB3003C   SW S3, 60(SP)
9D00034C  AFB20038   SW S2, 56(SP)
9D000350  AFB10034   SW S1, 52(SP)
9D000354  AFB00030   SW S0, 48(SP)
1370:                   int old_cycles = cpu.total_cycles;
9D000358  3C02A001   LUI V0, -24575
9D00035C  24428FD0   ADDIU V0, V0, -28720
9D000360  8C430054   LW V1, 84(V0)
9D000364  AFA30024   SW V1, 36(SP)
1371:                
1372:                   uint32 temp, addr; /* for macros */
1373:                   uint8 btemp, baddr; /* for macros */
1374:                   uint8 data;
1375:                
1376:                   /* flags */
1377:                   uint8 n_flag, v_flag, b_flag;
1378:                   uint8 d_flag, i_flag, z_flag, c_flag;
1379:                
1380:                   /* local copies of regs */
1381:                   uint32 PC;
1382:                   uint8 A, X, Y, S;
1383:                
1384:                #ifdef NES6502_JUMPTABLE
1385:                   
1386:                   static const void *opcode_table[256] =
1387:                   {
1388:                      &&op00, &&op01, &&op02, &&op03, &&op04, &&op05, &&op06, &&op07,
1389:                      &&op08, &&op09, &&op0A, &&op0B, &&op0C, &&op0D, &&op0E, &&op0F,
1390:                      &&op10, &&op11, &&op12, &&op13, &&op14, &&op15, &&op16, &&op17,
1391:                      &&op18, &&op19, &&op1A, &&op1B, &&op1C, &&op1D, &&op1E, &&op1F,
1392:                      &&op20, &&op21, &&op22, &&op23, &&op24, &&op25, &&op26, &&op27,
1393:                      &&op28, &&op29, &&op2A, &&op2B, &&op2C, &&op2D, &&op2E, &&op2F,
1394:                      &&op30, &&op31, &&op32, &&op33, &&op34, &&op35, &&op36, &&op37,
1395:                      &&op38, &&op39, &&op3A, &&op3B, &&op3C, &&op3D, &&op3E, &&op3F,
1396:                      &&op40, &&op41, &&op42, &&op43, &&op44, &&op45, &&op46, &&op47,
1397:                      &&op48, &&op49, &&op4A, &&op4B, &&op4C, &&op4D, &&op4E, &&op4F,
1398:                      &&op50, &&op51, &&op52, &&op53, &&op54, &&op55, &&op56, &&op57,
1399:                      &&op58, &&op59, &&op5A, &&op5B, &&op5C, &&op5D, &&op5E, &&op5F,
1400:                      &&op60, &&op61, &&op62, &&op63, &&op64, &&op65, &&op66, &&op67,
1401:                      &&op68, &&op69, &&op6A, &&op6B, &&op6C, &&op6D, &&op6E, &&op6F,
1402:                      &&op70, &&op71, &&op72, &&op73, &&op74, &&op75, &&op76, &&op77,
1403:                      &&op78, &&op79, &&op7A, &&op7B, &&op7C, &&op7D, &&op7E, &&op7F,
1404:                      &&op80, &&op81, &&op82, &&op83, &&op84, &&op85, &&op86, &&op87,
1405:                      &&op88, &&op89, &&op8A, &&op8B, &&op8C, &&op8D, &&op8E, &&op8F,
1406:                      &&op90, &&op91, &&op92, &&op93, &&op94, &&op95, &&op96, &&op97,
1407:                      &&op98, &&op99, &&op9A, &&op9B, &&op9C, &&op9D, &&op9E, &&op9F,
1408:                      &&opA0, &&opA1, &&opA2, &&opA3, &&opA4, &&opA5, &&opA6, &&opA7,
1409:                      &&opA8, &&opA9, &&opAA, &&opAB, &&opAC, &&opAD, &&opAE, &&opAF,
1410:                      &&opB0, &&opB1, &&opB2, &&opB3, &&opB4, &&opB5, &&opB6, &&opB7,
1411:                      &&opB8, &&opB9, &&opBA, &&opBB, &&opBC, &&opBD, &&opBE, &&opBF,
1412:                      &&opC0, &&opC1, &&opC2, &&opC3, &&opC4, &&opC5, &&opC6, &&opC7,
1413:                      &&opC8, &&opC9, &&opCA, &&opCB, &&opCC, &&opCD, &&opCE, &&opCF,
1414:                      &&opD0, &&opD1, &&opD2, &&opD3, &&opD4, &&opD5, &&opD6, &&opD7,
1415:                      &&opD8, &&opD9, &&opDA, &&opDB, &&opDC, &&opDD, &&opDE, &&opDF,
1416:                      &&opE0, &&opE1, &&opE2, &&opE3, &&opE4, &&opE5, &&opE6, &&opE7,
1417:                      &&opE8, &&opE9, &&opEA, &&opEB, &&opEC, &&opED, &&opEE, &&opEF,
1418:                      &&opF0, &&opF1, &&opF2, &&opF3, &&opF4, &&opF5, &&opF6, &&opF7,
1419:                      &&opF8, &&opF9, &&opFA, &&opFB, &&opFC, &&opFD, &&opFE, &&opFF
1420:                   };
1421:                
1422:                #endif /* NES6502_JUMPTABLE */
1423:                
1424:                   remaining_cycles = timeslice_cycles;
9D000368  AF848058   SW A0, -32680(GP)
1425:                
1426:                   GET_GLOBAL_REGS();
9D00036C  8C520048   LW S2, 72(V0)
9D000370  9054004C   LBU S4, 76(V0)
9D000374  905E004E   LBU FP, 78(V0)
9D000378  9045004F   LBU A1, 79(V0)
9D00037C  AFA50010   SW A1, 16(SP)
9D000380  9057004D   LBU S7, 77(V0)
9D000384  32F30080   ANDI S3, S7, 128
9D000388  32E30040   ANDI V1, S7, 64
9D00038C  306300FF   ANDI V1, V1, 255
9D000390  AFA30018   SW V1, 24(SP)
9D000394  32E30010   ANDI V1, S7, 16
9D000398  306300FF   ANDI V1, V1, 255
9D00039C  AFA30028   SW V1, 40(SP)
9D0003A0  32E30008   ANDI V1, S7, 8
9D0003A4  306300FF   ANDI V1, V1, 255
9D0003A8  AFA30020   SW V1, 32(SP)
9D0003AC  32E30004   ANDI V1, S7, 4
9D0003B0  306300FF   ANDI V1, V1, 255
9D0003B4  AFA3001C   SW V1, 28(SP)
9D0003B8  3AF50002   XORI S5, S7, 2
9D0003BC  7EB50040   EXT S5, S5, 1, 1
9D0003C0  90460050   LBU A2, 80(V0)
9D0003C4  AFA60014   SW A2, 20(SP)
1427:                
1428:                   /* check for DMA cycle burning */
1429:                   if (cpu.burn_cycles && remaining_cycles > 0)
9D0003C8  8C420058   LW V0, 88(V0)
9D0003CC  1040000E   BEQ V0, ZERO, .LBE925
9D0003D0  32F70001   ANDI S7, S7, 1
9D0003D4  1880000C   BLEZ A0, .LBE925
9D0003D8  0044182A   SLT V1, V0, A0
1430:                   {
1431:                      int burn_for;
1432:                      
1433:                      burn_for = MIN(remaining_cycles, cpu.burn_cycles);
9D0003DC  00403821   ADDU A3, V0, ZERO
9D0003E0  0083380A   MOVZ A3, A0, V1
1434:                      ADD_CYCLES(burn_for);
9D0003E4  00872023   SUBU A0, A0, A3
9D0003E8  AF848058   SW A0, -32680(GP)
9D0003EC  3C04A001   LUI A0, -24575
9D0003F0  24848FD0   ADDIU A0, A0, -28720
9D0003F4  8FA80024   LW T0, 36(SP)
9D0003F8  01072821   ADDU A1, T0, A3
9D0003FC  AC850054   SW A1, 84(A0)
1435:                      cpu.burn_cycles -= burn_for;
9D000400  00471023   SUBU V0, V0, A3
9D000404  AC820058   SW V0, 88(A0)
1436:                   }
1437:                
1438:                   if (0 == i_flag && cpu.int_pending && remaining_cycles > 0)
9D000408  8FA2001C   LW V0, 28(SP)
9D00040C  1440003A   BNE V0, ZERO, 0x9D0004F8
9D000410  8F828058   LW V0, -32680(GP)
9D000414  3C02A001   LUI V0, -24575
9D000418  90429022   LBU V0, -28638(V0)
9D00041C  10400036   BEQ V0, ZERO, 0x9D0004F8
9D000420  8F828058   LW V0, -32680(GP)
9D000424  8F838058   LW V1, -32680(GP)
9D000428  186026A7   BLEZ V1, .L45
9D00042C  3C02A001   LUI V0, -24575
1439:                   {
1440:                      cpu.int_pending = 0;
9D000430  A0409022   SB ZERO, -28638(V0)
1441:                      IRQ_PROC();
9D000434  8F828050   LW V0, -32688(GP)
9D000438  8FA50014   LW A1, 20(SP)
9D00043C  00452021   ADDU A0, V0, A1
9D000440  00122A02   SRL A1, S2, 8
9D000444  A0850000   SB A1, 0(A0)
9D000448  8FA60014   LW A2, 20(SP)
9D00044C  24C4FFFE   ADDIU A0, A2, -2
9D000450  308400FF   ANDI A0, A0, 255
9D000454  24C5FFFF   ADDIU A1, A2, -1
9D000458  30A500FF   ANDI A1, A1, 255
9D00045C  00452821   ADDU A1, V0, A1
9D000460  A0B20000   SB S2, 0(A1)
9D000464  24C5FFFD   ADDIU A1, A2, -3
9D000468  30A500FF   ANDI A1, A1, 255
9D00046C  AFA50014   SW A1, 20(SP)
9D000470  00441021   ADDU V0, V0, A0
9D000474  2407FF80   ADDIU A3, ZERO, -128
9D000478  02674024   AND T0, S3, A3
9D00047C  7C084420   SEB T0, T0
9D000480  24070040   ADDIU A3, ZERO, 64
9D000484  8FA40018   LW A0, 24(SP)
9D000488  0004380A   MOVZ A3, ZERO, A0
9D00048C  24060008   ADDIU A2, ZERO, 8
9D000490  8FA50020   LW A1, 32(SP)
9D000494  0005300A   MOVZ A2, ZERO, A1
9D000498  24050002   ADDIU A1, ZERO, 2
9D00049C  0015280B   MOVN A1, ZERO, S5
9D0004A0  36E40020   ORI A0, S7, 32
9D0004A4  01042025   OR A0, T0, A0
9D0004A8  00E42025   OR A0, A3, A0
9D0004AC  00C42025   OR A0, A2, A0
9D0004B0  00A42025   OR A0, A1, A0
9D0004B4  A0440000   SB A0, 0(V0)
9D0004E8  24060001   ADDIU A2, ZERO, 1
9D0004EC  AFA6001C   SW A2, 28(SP)
9D0004F0  AFA00028   SW ZERO, 40(SP)
1442:                      ADD_CYCLES(INT_CYCLES);
9D0004D4  2463FFF9   ADDIU V1, V1, -7
9D0004D8  AF838058   SW V1, -32680(GP)
9D0004DC  8C430054   LW V1, 84(V0)
9D0004E0  24630007   ADDIU V1, V1, 7
9D0004E4  AC430054   SW V1, 84(V0)
1443:                   }
1444:                
1445:                #ifdef NES6502_JUMPTABLE
1446:                   /* fetch first instruction */
1447:                   OPCODE_END
9D0004F4  8F828058   LW V0, -32680(GP)
9D0004F8  18402673   BLEZ V0, .L45
9D0004FC  26500001   ADDIU S0, S2, 1
9D000520  92430000   LBU V1, 0(S2)
9D000524  00031880   SLL V1, V1, 2
9D000528  3C029D03   LUI V0, -25341
9D00052C  244200C4   ADDIU V0, V0, 196
9D000530  00621021   ADDU V0, V1, V0
9D000534  8C420000   LW V0, 0(V0)
1448:                
1449:                #else /* !NES6502_JUMPTABLE */
1450:                
1451:                   /* Continue until we run out of cycles */
1452:                   while (remaining_cycles > 0)
1453:                   {
1454:                #ifdef NES6502_DISASM
1455:                      log_printf(nes6502_disasm(PC, COMBINE_FLAGS(), A, X, Y, S));
1456:                #endif /* NES6502_DISASM */
1457:                
1458:                      /* Fetch and execute instruction */
1459:                      switch (bank_readbyte(PC++))
1460:                      {
1461:                #endif /* !NES6502_JUMPTABLE */
1462:                
1463:                      OPCODE_BEGIN(00)  /* BRK */
1464:                         BRK();
9D000550  26100001   ADDIU S0, S0, 1
9D000554  8F828050   LW V0, -32688(GP)
9D000558  8FA70014   LW A3, 20(SP)
9D00055C  00471821   ADDU V1, V0, A3
9D000560  00102202   SRL A0, S0, 8
9D000564  A0640000   SB A0, 0(V1)
9D000568  24E3FFFE   ADDIU V1, A3, -2
9D00056C  306300FF   ANDI V1, V1, 255
9D000570  24E4FFFF   ADDIU A0, A3, -1
9D000574  308400FF   ANDI A0, A0, 255
9D000578  00442021   ADDU A0, V0, A0
9D00057C  A0900000   SB S0, 0(A0)
9D000580  24E4FFFD   ADDIU A0, A3, -3
9D000584  308400FF   ANDI A0, A0, 255
9D000588  AFA40014   SW A0, 20(SP)
9D00058C  00431021   ADDU V0, V0, V1
9D000590  2403FF80   ADDIU V1, ZERO, -128
9D000594  02634024   AND T0, S3, V1
9D000598  7C084420   SEB T0, T0
9D00059C  24070040   ADDIU A3, ZERO, 64
9D0005A0  8FA40018   LW A0, 24(SP)
9D0005A4  0004380A   MOVZ A3, ZERO, A0
9D0005A8  24060008   ADDIU A2, ZERO, 8
9D0005AC  8FA50020   LW A1, 32(SP)
9D0005B0  0005300A   MOVZ A2, ZERO, A1
9D0005B4  24050004   ADDIU A1, ZERO, 4
9D0005B8  8FA3001C   LW V1, 28(SP)
9D0005BC  0003280A   MOVZ A1, ZERO, V1
9D0005C0  24040002   ADDIU A0, ZERO, 2
9D0005C4  0015200B   MOVN A0, ZERO, S5
9D0005C8  36E30030   ORI V1, S7, 48
9D0005CC  01031825   OR V1, T0, V1
9D0005D0  00E31825   OR V1, A3, V1
9D0005D4  00C31825   OR V1, A2, V1
9D0005D8  00A31825   OR V1, A1, V1
9D0005DC  00831825   OR V1, A0, V1
9D0005E0  A0430000   SB V1, 0(V0)
9D0005F8  8F828058   LW V0, -32680(GP)
9D0005FC  2442FFF9   ADDIU V0, V0, -7
9D000600  AF828058   SW V0, -32680(GP)
9D000604  8E230054   LW V1, 84(S1)
9D000608  24630007   ADDIU V1, V1, 7
9D000614  24040001   ADDIU A0, ZERO, 1
9D000618  AFA4001C   SW A0, 28(SP)
9D00061C  24050001   ADDIU A1, ZERO, 1
9D000620  0B4027B2   J .L45
9D000624  AFA50028   SW A1, 40(SP)
9D000654  24060001   ADDIU A2, ZERO, 1
9D000658  AFA6001C   SW A2, 28(SP)
9D00065C  24070001   ADDIU A3, ZERO, 1
1465:                         OPCODE_END
9D00060C  1C400006   BGTZ V0, 0x9D000628
9D000610  AE230054   SW V1, 84(S1)
9D000628  26500001   ADDIU S0, S2, 1
9D000644  90420000   LBU V0, 0(V0)
9D000648  00021080   SLL V0, V0, 2
9D00064C  00561021   ADDU V0, V0, S6
9D000650  8C420000   LW V0, 0(V0)
9D000660  0B400152   J 0x9D000548
9D000664  AFA70028   SW A3, 40(SP)
1466:                
1467:                      OPCODE_BEGIN(01)  /* ORA ($nn,X) */
1468:                         ORA(6, INDIR_X_BYTE);
9D000668  26120001   ADDIU S2, S0, 1
9D000684  90420000   LBU V0, 0(V0)
9D000688  03C21021   ADDU V0, FP, V0
9D0006A4  0F400000   JAL mem_readbyte
9D0006A8  308400FF   ANDI A0, A0, 255
9D0006AC  00541025   OR V0, V0, S4
9D0006B0  305300FF   ANDI S3, V0, 255
9D0006B4  8F828058   LW V0, -32680(GP)
9D0006B8  2442FFFA   ADDIU V0, V0, -6
9D0006BC  AF828058   SW V0, -32680(GP)
9D0006C0  8E230054   LW V1, 84(S1)
9D0006C4  24630006   ADDIU V1, V1, 6
9D0006D0  0260A021   ADDU S4, S3, ZERO
9D0006D4  0B4027B2   J .L45
9D0006D8  0260A821   ADDU S5, S3, ZERO
9D000708  0260A021   ADDU S4, S3, ZERO
1469:                         OPCODE_END
9D0006C8  1C400004   BGTZ V0, 0x9D0006DC
9D0006CC  AE230054   SW V1, 84(S1)
9D0006DC  26100002   ADDIU S0, S0, 2
9D0006F8  90420000   LBU V0, 0(V0)
9D0006FC  00021080   SLL V0, V0, 2
9D000700  00561021   ADDU V0, V0, S6
9D000704  8C420000   LW V0, 0(V0)
9D00070C  0B400152   J 0x9D000548
9D000710  0260A821   ADDU S5, S3, ZERO
1470:                
1471:                      OPCODE_BEGIN(02)  /* JAM */
1472:                      OPCODE_BEGIN(12)  /* JAM */
1473:                      OPCODE_BEGIN(22)  /* JAM */
1474:                      OPCODE_BEGIN(32)  /* JAM */
1475:                      OPCODE_BEGIN(42)  /* JAM */
1476:                      OPCODE_BEGIN(52)  /* JAM */
1477:                      OPCODE_BEGIN(62)  /* JAM */
1478:                      OPCODE_BEGIN(72)  /* JAM */
1479:                      OPCODE_BEGIN(92)  /* JAM */
1480:                      OPCODE_BEGIN(B2)  /* JAM */
1481:                      OPCODE_BEGIN(D2)  /* JAM */
1482:                      OPCODE_BEGIN(F2)  /* JAM */
1483:                         JAM();
9D000714  0B4001DA   J 0x9D000768
9D000718  2612FFFF   ADDIU S2, S0, -1
9D00071C  0B4001DA   J 0x9D000768
9D000720  2612FFFF   ADDIU S2, S0, -1
9D000724  0B4001DA   J 0x9D000768
9D000728  2612FFFF   ADDIU S2, S0, -1
9D00072C  0B4001DA   J 0x9D000768
9D000730  2612FFFF   ADDIU S2, S0, -1
9D000734  0B4001DA   J 0x9D000768
9D000738  2612FFFF   ADDIU S2, S0, -1
9D00073C  0B4001DA   J 0x9D000768
9D000740  2612FFFF   ADDIU S2, S0, -1
9D000744  0B4001DA   J 0x9D000768
9D000748  2612FFFF   ADDIU S2, S0, -1
9D00074C  0B4001DA   J 0x9D000768
9D000750  2612FFFF   ADDIU S2, S0, -1
9D000754  0B4001DA   J 0x9D000768
9D000758  2612FFFF   ADDIU S2, S0, -1
9D00075C  0B4001DA   J 0x9D000768
9D000760  2612FFFF   ADDIU S2, S0, -1
9D000764  2612FFFF   ADDIU S2, S0, -1
9D000768  3C02A001   LUI V0, -24575
9D00076C  24428FD0   ADDIU V0, V0, -28720
9D000770  24030001   ADDIU V1, ZERO, 1
9D000774  A0430051   SB V1, 81(V0)
9D000778  A0400052   SB ZERO, 82(V0)
9D00077C  8C430054   LW V1, 84(V0)
9D000780  24630002   ADDIU V1, V1, 2
9D000784  AC430054   SW V1, 84(V0)
9D000788  0B4027B2   J .L45
9D00078C  AF808058   SW ZERO, -32680(GP)
1484:                         /* kill the CPU */
1485:                         remaining_cycles = 0;
1486:                         OPCODE_END
1487:                
1488:                      OPCODE_BEGIN(03)  /* SLO ($nn,X) */
1489:                         SLO(8, INDIR_X, mem_writebyte, addr);
9D000790  26120001   ADDIU S2, S0, 1
9D0007AC  90420000   LBU V0, 0(V0)
9D0007B0  03C21021   ADDU V0, FP, V0
9D0007D0  0F400000   JAL mem_readbyte
9D0007D4  02A02021   ADDU A0, S5, ZERO
9D0007D8  7C5739C0   EXT S7, V0, 7, 8
9D0007DC  00021040   SLL V0, V0, 1
9D0007E0  305300FF   ANDI S3, V0, 255
9D0007E4  02A02021   ADDU A0, S5, ZERO
9D0007E8  0F400036   JAL mem_writebyte
9D0007EC  02602821   ADDU A1, S3, ZERO
9D0007F0  02749825   OR S3, S3, S4
9D0007F4  327300FF   ANDI S3, S3, 255
9D0007F8  8F828058   LW V0, -32680(GP)
9D0007FC  2442FFF8   ADDIU V0, V0, -8
9D000800  AF828058   SW V0, -32680(GP)
9D000804  8E230054   LW V1, 84(S1)
9D000808  24630008   ADDIU V1, V1, 8
9D000814  0260A021   ADDU S4, S3, ZERO
9D000818  0B4027B2   J .L45
9D00081C  0260A821   ADDU S5, S3, ZERO
9D00084C  0260A021   ADDU S4, S3, ZERO
1490:                         OPCODE_END
9D00080C  1C400004   BGTZ V0, 0x9D000820
9D000810  AE230054   SW V1, 84(S1)
9D000820  26100002   ADDIU S0, S0, 2
9D00083C  90420000   LBU V0, 0(V0)
9D000840  00021080   SLL V0, V0, 2
9D000844  00561021   ADDU V0, V0, S6
9D000848  8C420000   LW V0, 0(V0)
9D000850  0B400152   J 0x9D000548
9D000854  0260A821   ADDU S5, S3, ZERO
1491:                
1492:                      OPCODE_BEGIN(04)  /* NOP $nn */
1493:                      OPCODE_BEGIN(44)  /* NOP $nn */
1494:                      OPCODE_BEGIN(64)  /* NOP $nn */
1495:                         DOP(3);
9D000858  0B400219   J 0x9D000864
9D00085C  26120001   ADDIU S2, S0, 1
9D000860  26120001   ADDIU S2, S0, 1
9D000864  8F828058   LW V0, -32680(GP)
9D000868  2442FFFD   ADDIU V0, V0, -3
9D00086C  AF828058   SW V0, -32680(GP)
9D000870  8E230054   LW V1, 84(S1)
9D000874  24630003   ADDIU V1, V1, 3
1496:                         OPCODE_END
9D000878  18402593   BLEZ V0, .L45
9D00087C  AE230054   SW V1, 84(S1)
9D000880  26100002   ADDIU S0, S0, 2
9D00089C  90420000   LBU V0, 0(V0)
9D0008A0  00021080   SLL V0, V0, 2
9D0008A4  00561021   ADDU V0, V0, S6
9D0008A8  0B400152   J 0x9D000548
9D0008AC  8C420000   LW V0, 0(V0)
1497:                
1498:                      OPCODE_BEGIN(05)  /* ORA $nn */
1499:                         ORA(3, ZERO_PAGE_BYTE); 
9D0008B0  26120001   ADDIU S2, S0, 1
9D0008CC  90420000   LBU V0, 0(V0)
9D0008D0  8F838054   LW V1, -32684(GP)
9D0008D4  00621021   ADDU V0, V1, V0
9D0008D8  90530000   LBU S3, 0(V0)
9D0008DC  02939825   OR S3, S4, S3
9D0008E0  327300FF   ANDI S3, S3, 255
9D0008E4  8F828058   LW V0, -32680(GP)
9D0008E8  2442FFFD   ADDIU V0, V0, -3
9D0008EC  AF828058   SW V0, -32680(GP)
9D0008F0  8E230054   LW V1, 84(S1)
9D0008F4  24630003   ADDIU V1, V1, 3
9D000900  0260A021   ADDU S4, S3, ZERO
9D000904  0B4027B2   J .L45
9D000908  0260A821   ADDU S5, S3, ZERO
9D000938  0260A021   ADDU S4, S3, ZERO
1500:                         OPCODE_END
9D0008F8  1C400004   BGTZ V0, 0x9D00090C
9D0008FC  AE230054   SW V1, 84(S1)
9D00090C  26100002   ADDIU S0, S0, 2
9D000928  90420000   LBU V0, 0(V0)
9D00092C  00021080   SLL V0, V0, 2
9D000930  00561021   ADDU V0, V0, S6
9D000934  8C420000   LW V0, 0(V0)
9D00093C  0B400152   J 0x9D000548
9D000940  0260A821   ADDU S5, S3, ZERO
1501:                
1502:                      OPCODE_BEGIN(06)  /* ASL $nn */
1503:                         ASL(5, ZERO_PAGE, ZP_WRITEBYTE, baddr);
9D000944  26120001   ADDIU S2, S0, 1
9D000960  90420000   LBU V0, 0(V0)
9D000964  8F838054   LW V1, -32684(GP)
9D000968  00621021   ADDU V0, V1, V0
9D00096C  90430000   LBU V1, 0(V0)
9D000970  0003B9C2   SRL S7, V1, 7
9D000974  00031840   SLL V1, V1, 1
9D000978  307300FF   ANDI S3, V1, 255
9D00097C  A0530000   SB S3, 0(V0)
9D000980  8F828058   LW V0, -32680(GP)
9D000984  2442FFFB   ADDIU V0, V0, -5
9D000988  AF828058   SW V0, -32680(GP)
9D00098C  8E230054   LW V1, 84(S1)
9D000990  24630005   ADDIU V1, V1, 5
9D00099C  0B4027B2   J .L45
9D0009A0  0260A821   ADDU S5, S3, ZERO
1504:                         OPCODE_END
9D000994  1C400003   BGTZ V0, 0x9D0009A4
9D000998  AE230054   SW V1, 84(S1)
9D0009A4  26100002   ADDIU S0, S0, 2
9D0009C0  90420000   LBU V0, 0(V0)
9D0009C4  00021080   SLL V0, V0, 2
9D0009C8  00561021   ADDU V0, V0, S6
9D0009CC  8C420000   LW V0, 0(V0)
9D0009D0  0B400152   J 0x9D000548
9D0009D4  0260A821   ADDU S5, S3, ZERO
1505:                
1506:                      OPCODE_BEGIN(07)  /* SLO $nn */
1507:                         SLO(5, ZERO_PAGE, ZP_WRITEBYTE, baddr);
9D0009D8  26120001   ADDIU S2, S0, 1
9D0009F4  90420000   LBU V0, 0(V0)
9D0009F8  8F838054   LW V1, -32684(GP)
9D0009FC  00621821   ADDU V1, V1, V0
9D000A00  90620000   LBU V0, 0(V1)
9D000A04  0002B9C2   SRL S7, V0, 7
9D000A08  00021040   SLL V0, V0, 1
9D000A0C  304200FF   ANDI V0, V0, 255
9D000A10  A0620000   SB V0, 0(V1)
9D000A14  00541025   OR V0, V0, S4
9D000A18  305300FF   ANDI S3, V0, 255
9D000A1C  8F828058   LW V0, -32680(GP)
9D000A20  2442FFFB   ADDIU V0, V0, -5
9D000A24  AF828058   SW V0, -32680(GP)
9D000A28  8E230054   LW V1, 84(S1)
9D000A2C  24630005   ADDIU V1, V1, 5
9D000A38  0260A021   ADDU S4, S3, ZERO
9D000A3C  0B4027B2   J .L45
9D000A40  0260A821   ADDU S5, S3, ZERO
9D000A70  0260A021   ADDU S4, S3, ZERO
1508:                         OPCODE_END
9D000A30  1C400004   BGTZ V0, 0x9D000A44
9D000A34  AE230054   SW V1, 84(S1)
9D000A44  26100002   ADDIU S0, S0, 2
9D000A60  90420000   LBU V0, 0(V0)
9D000A64  00021080   SLL V0, V0, 2
9D000A68  00561021   ADDU V0, V0, S6
9D000A6C  8C420000   LW V0, 0(V0)
9D000A74  0B400152   J 0x9D000548
9D000A78  0260A821   ADDU S5, S3, ZERO
1509:                
1510:                      OPCODE_BEGIN(08)  /* PHP */
1511:                         PHP(); 
9D000A7C  8FA80014   LW T0, 20(SP)
9D000A80  2503FFFF   ADDIU V1, T0, -1
9D000A84  306300FF   ANDI V1, V1, 255
9D000A88  8F828050   LW V0, -32688(GP)
9D000A8C  00481021   ADDU V0, V0, T0
9D000A90  2404FF80   ADDIU A0, ZERO, -128
9D000A94  02645024   AND T2, S3, A0
9D000A98  7C0A5420   SEB T2, T2
9D000A9C  24090040   ADDIU T1, ZERO, 64
9D000AA0  8FA50018   LW A1, 24(SP)
9D000AA4  0005480A   MOVZ T1, ZERO, A1
9D000AA8  24080010   ADDIU T0, ZERO, 16
9D000AAC  8FA60028   LW A2, 40(SP)
9D000AB0  0006400A   MOVZ T0, ZERO, A2
9D000AB4  24070008   ADDIU A3, ZERO, 8
9D000AB8  8FA40020   LW A0, 32(SP)
9D000ABC  0004380A   MOVZ A3, ZERO, A0
9D000AC0  24060004   ADDIU A2, ZERO, 4
9D000AC4  8FA5001C   LW A1, 28(SP)
9D000AC8  0005300A   MOVZ A2, ZERO, A1
9D000ACC  24050002   ADDIU A1, ZERO, 2
9D000AD0  0015280B   MOVN A1, ZERO, S5
9D000AD4  36E40030   ORI A0, S7, 48
9D000AD8  01442025   OR A0, T2, A0
9D000ADC  01242025   OR A0, T1, A0
9D000AE0  01042025   OR A0, T0, A0
9D000AE4  00E42025   OR A0, A3, A0
9D000AE8  00C42025   OR A0, A2, A0
9D000AEC  00A42025   OR A0, A1, A0
9D000AF0  A0440000   SB A0, 0(V0)
9D000AF4  8F828058   LW V0, -32680(GP)
9D000AF8  2442FFFD   ADDIU V0, V0, -3
9D000AFC  AF828058   SW V0, -32680(GP)
9D000B00  8E240054   LW A0, 84(S1)
9D000B04  24840003   ADDIU A0, A0, 3
9D000B10  AFA30014   SW V1, 20(SP)
9D000B44  AFA30014   SW V1, 20(SP)
1512:                         OPCODE_END
9D000B08  1C400004   BGTZ V0, .LBB964
9D000B0C  AE240054   SW A0, 84(S1)
9D000B14  0B4027B2   J .L45
9D000B18  02009021   ADDU S2, S0, ZERO
9D000B34  90420000   LBU V0, 0(V0)
9D000B38  00021080   SLL V0, V0, 2
9D000B3C  00561021   ADDU V0, V0, S6
9D000B40  8C420000   LW V0, 0(V0)
9D000B48  0B400152   J 0x9D000548
9D000B4C  26100001   ADDIU S0, S0, 1
1513:                
1514:                      OPCODE_BEGIN(09)  /* ORA #$nn */
1515:                         ORA(2, IMMEDIATE_BYTE);
9D000B50  26120001   ADDIU S2, S0, 1
9D000B6C  90530000   LBU S3, 0(V0)
9D000B70  02939825   OR S3, S4, S3
9D000B74  327300FF   ANDI S3, S3, 255
9D000B78  8F828058   LW V0, -32680(GP)
9D000B7C  2442FFFE   ADDIU V0, V0, -2
9D000B80  AF828058   SW V0, -32680(GP)
9D000B84  8E230054   LW V1, 84(S1)
9D000B88  24630002   ADDIU V1, V1, 2
9D000B94  0260A021   ADDU S4, S3, ZERO
9D000B98  0B4027B2   J .L45
9D000B9C  0260A821   ADDU S5, S3, ZERO
9D000BCC  0260A021   ADDU S4, S3, ZERO
1516:                         OPCODE_END
9D000B8C  1C400004   BGTZ V0, 0x9D000BA0
9D000B90  AE230054   SW V1, 84(S1)
9D000BA0  26100002   ADDIU S0, S0, 2
9D000BBC  90420000   LBU V0, 0(V0)
9D000BC0  00021080   SLL V0, V0, 2
9D000BC4  00561021   ADDU V0, V0, S6
9D000BC8  8C420000   LW V0, 0(V0)
9D000BD0  0B400152   J 0x9D000548
9D000BD4  0260A821   ADDU S5, S3, ZERO
1517:                
1518:                      OPCODE_BEGIN(0A)  /* ASL A */
1519:                         ASL_A();
9D000BD8  7E9739C0   EXT S7, S4, 7, 8
9D000BDC  00149840   SLL S3, S4, 1
9D000BE0  327300FF   ANDI S3, S3, 255
9D000BE4  8F828058   LW V0, -32680(GP)
9D000BE8  2442FFFE   ADDIU V0, V0, -2
9D000BEC  AF828058   SW V0, -32680(GP)
9D000BF0  8E230054   LW V1, 84(S1)
9D000BF4  24630002   ADDIU V1, V1, 2
9D000C00  0260A021   ADDU S4, S3, ZERO
9D000C08  0B4027B2   J .L45
9D000C0C  0260A821   ADDU S5, S3, ZERO
9D000C38  0260A021   ADDU S4, S3, ZERO
1520:                         OPCODE_END
9D000BF8  1C400005   BGTZ V0, .LBB970
9D000BFC  AE230054   SW V1, 84(S1)
9D000C04  02009021   ADDU S2, S0, ZERO
9D000C28  90420000   LBU V0, 0(V0)
9D000C2C  00021080   SLL V0, V0, 2
9D000C30  00561021   ADDU V0, V0, S6
9D000C34  8C420000   LW V0, 0(V0)
9D000C3C  26100001   ADDIU S0, S0, 1
9D000C40  0B400152   J 0x9D000548
9D000C44  0260A821   ADDU S5, S3, ZERO
1521:                
1522:                      OPCODE_BEGIN(0B)  /* ANC #$nn */
1523:                         ANC(2, IMMEDIATE_BYTE);
9D000C48  26120001   ADDIU S2, S0, 1
9D000C64  90550000   LBU S5, 0(V0)
9D000C68  0295A824   AND S5, S4, S5
9D000C6C  7E7739C0   EXT S7, S3, 7, 8
9D000C70  8F828058   LW V0, -32680(GP)
9D000C74  2442FFFE   ADDIU V0, V0, -2
9D000C78  AF828058   SW V0, -32680(GP)
9D000C7C  8E230054   LW V1, 84(S1)
9D000C80  24630002   ADDIU V1, V1, 2
9D000C8C  02A0A021   ADDU S4, S5, ZERO
9D000C90  0B4027B2   J .L45
9D000C94  02A09821   ADDU S3, S5, ZERO
9D000CC4  02A0A021   ADDU S4, S5, ZERO
1524:                         OPCODE_END
9D000C84  1C400004   BGTZ V0, 0x9D000C98
9D000C88  AE230054   SW V1, 84(S1)
9D000C98  26100002   ADDIU S0, S0, 2
9D000CB4  90420000   LBU V0, 0(V0)
9D000CB8  00021080   SLL V0, V0, 2
9D000CBC  00561021   ADDU V0, V0, S6
9D000CC0  8C420000   LW V0, 0(V0)
9D000CC8  0B400152   J 0x9D000548
9D000CCC  02A09821   ADDU S3, S5, ZERO
1525:                
1526:                      OPCODE_BEGIN(0C)  /* NOP $nnnn */
1527:                         TOP(); 
9D000CD0  26120002   ADDIU S2, S0, 2
9D000CD4  8F828058   LW V0, -32680(GP)
9D000CD8  2442FFFC   ADDIU V0, V0, -4
9D000CDC  AF828058   SW V0, -32680(GP)
9D000CE0  8E230054   LW V1, 84(S1)
9D000CE4  24630004   ADDIU V1, V1, 4
1528:                         OPCODE_END
9D000CE8  18402477   BLEZ V0, .L45
9D000CEC  AE230054   SW V1, 84(S1)
9D000CF0  26100003   ADDIU S0, S0, 3
9D000D0C  90420000   LBU V0, 0(V0)
9D000D10  00021080   SLL V0, V0, 2
9D000D14  00561021   ADDU V0, V0, S6
9D000D18  0B400152   J 0x9D000548
9D000D1C  8C420000   LW V0, 0(V0)
1529:                
1530:                      OPCODE_BEGIN(0D)  /* ORA $nnnn */
1531:                         ORA(4, ABSOLUTE_BYTE);
9D000D24  26120002   ADDIU S2, S0, 2
9D000D64  0F400000   JAL mem_readbyte
9D000D68  308400FF   ANDI A0, A0, 255
9D000D6C  00541025   OR V0, V0, S4
9D000D70  305300FF   ANDI S3, V0, 255
9D000D74  8F828058   LW V0, -32680(GP)
9D000D78  2442FFFC   ADDIU V0, V0, -4
9D000D7C  AF828058   SW V0, -32680(GP)
9D000D80  8E230054   LW V1, 84(S1)
9D000D84  24630004   ADDIU V1, V1, 4
9D000D90  0260A021   ADDU S4, S3, ZERO
9D000D94  0B4027B2   J .L45
9D000D98  0260A821   ADDU S5, S3, ZERO
9D000DC8  0260A021   ADDU S4, S3, ZERO
1532:                         OPCODE_END
9D000D88  1C400004   BGTZ V0, 0x9D000D9C
9D000D8C  AE230054   SW V1, 84(S1)
9D000D9C  26100003   ADDIU S0, S0, 3
9D000DB8  90420000   LBU V0, 0(V0)
9D000DBC  00021080   SLL V0, V0, 2
9D000DC0  00561021   ADDU V0, V0, S6
9D000DC4  8C420000   LW V0, 0(V0)
9D000DCC  0B400152   J 0x9D000548
9D000DD0  0260A821   ADDU S5, S3, ZERO
1533:                
1534:                      OPCODE_BEGIN(0E)  /* ASL $nnnn */
1535:                         ASL(6, ABSOLUTE, mem_writebyte, addr);
9D000E18  26120002   ADDIU S2, S0, 2
9D000E1C  0F400000   JAL mem_readbyte
9D000E20  02A02021   ADDU A0, S5, ZERO
9D000E24  7C5739C0   EXT S7, V0, 7, 8
9D000E28  00021040   SLL V0, V0, 1
9D000E2C  305300FF   ANDI S3, V0, 255
9D000E30  02A02021   ADDU A0, S5, ZERO
9D000E34  0F400036   JAL mem_writebyte
9D000E38  02602821   ADDU A1, S3, ZERO
9D000E3C  8F828058   LW V0, -32680(GP)
9D000E40  2442FFFA   ADDIU V0, V0, -6
9D000E44  AF828058   SW V0, -32680(GP)
9D000E48  8E230054   LW V1, 84(S1)
9D000E4C  24630006   ADDIU V1, V1, 6
9D000E58  0B4027B2   J .L45
9D000E5C  0260A821   ADDU S5, S3, ZERO
1536:                         OPCODE_END
9D000E50  1C400003   BGTZ V0, 0x9D000E60
9D000E54  AE230054   SW V1, 84(S1)
9D000E60  26100003   ADDIU S0, S0, 3
9D000E7C  90420000   LBU V0, 0(V0)
9D000E80  00021080   SLL V0, V0, 2
9D000E84  00561021   ADDU V0, V0, S6
9D000E88  8C420000   LW V0, 0(V0)
9D000E8C  0B400152   J 0x9D000548
9D000E90  0260A821   ADDU S5, S3, ZERO
1537:                
1538:                      OPCODE_BEGIN(0F)  /* SLO $nnnn */
1539:                         SLO(6, ABSOLUTE, mem_writebyte, addr);
9D000ED8  26120002   ADDIU S2, S0, 2
9D000EDC  0F400000   JAL mem_readbyte
9D000EE0  02A02021   ADDU A0, S5, ZERO
9D000EE4  7C5739C0   EXT S7, V0, 7, 8
9D000EE8  00021040   SLL V0, V0, 1
9D000EEC  305300FF   ANDI S3, V0, 255
9D000EF0  02A02021   ADDU A0, S5, ZERO
9D000EF4  0F400036   JAL mem_writebyte
9D000EF8  02602821   ADDU A1, S3, ZERO
9D000EFC  02749825   OR S3, S3, S4
9D000F00  327300FF   ANDI S3, S3, 255
9D000F04  8F828058   LW V0, -32680(GP)
9D000F08  2442FFFA   ADDIU V0, V0, -6
9D000F0C  AF828058   SW V0, -32680(GP)
9D000F10  8E230054   LW V1, 84(S1)
9D000F14  24630006   ADDIU V1, V1, 6
9D000F20  0260A021   ADDU S4, S3, ZERO
9D000F24  0B4027B2   J .L45
9D000F28  0260A821   ADDU S5, S3, ZERO
9D000F58  0260A021   ADDU S4, S3, ZERO
1540:                         OPCODE_END
9D000F18  1C400004   BGTZ V0, 0x9D000F2C
9D000F1C  AE230054   SW V1, 84(S1)
9D000F2C  26100003   ADDIU S0, S0, 3
9D000F48  90420000   LBU V0, 0(V0)
9D000F4C  00021080   SLL V0, V0, 2
9D000F50  00561021   ADDU V0, V0, S6
9D000F54  8C420000   LW V0, 0(V0)
9D000F5C  0B400152   J 0x9D000548
9D000F60  0260A821   ADDU S5, S3, ZERO
1541:                
1542:                      OPCODE_BEGIN(10)  /* BPL $nnnn */
1543:                         BPL();
9D000F64  7C131420   SEB V0, S3
9D000F68  0440001A   BLTZ V0, 0x9D000FD4
9D000F6C  26020001   ADDIU V0, S0, 1
9D000F88  80720000   LB S2, 0(V1)
9D000F8C  304300FF   ANDI V1, V0, 255
9D000F90  02431821   ADDU V1, S2, V1
9D000F94  30630100   ANDI V1, V1, 256
9D000F98  10600007   BEQ V1, ZERO, 0x9D000FB8
9D000F9C  8F838058   LW V1, -32680(GP)
9D000FA0  2463FFFF   ADDIU V1, V1, -1
9D000FA4  AF838058   SW V1, -32680(GP)
9D000FA8  8E230054   LW V1, 84(S1)
9D000FAC  24630001   ADDIU V1, V1, 1
9D000FB0  AE230054   SW V1, 84(S1)
9D000FB4  8F838058   LW V1, -32680(GP)
9D000FB8  2463FFFD   ADDIU V1, V1, -3
9D000FBC  AF838058   SW V1, -32680(GP)
9D000FC0  8E230054   LW V1, 84(S1)
9D000FC4  24630003   ADDIU V1, V1, 3
9D000FC8  AE230054   SW V1, 84(S1)
9D000FCC  0B4003FC   J 0x9D000FF0
9D000FD0  02429021   ADDU S2, S2, V0
9D000FD4  26120001   ADDIU S2, S0, 1
9D000FD8  8F828058   LW V0, -32680(GP)
9D000FDC  2442FFFE   ADDIU V0, V0, -2
9D000FE0  AF828058   SW V0, -32680(GP)
9D000FE4  8E220054   LW V0, 84(S1)
9D000FE8  24420002   ADDIU V0, V0, 2
9D000FEC  AE220054   SW V0, 84(S1)
1544:                         OPCODE_END
9D000FF0  8F828058   LW V0, -32680(GP)
9D000FF4  184023B4   BLEZ V0, .L45
9D000FF8  26500001   ADDIU S0, S2, 1
9D001014  90420000   LBU V0, 0(V0)
9D001018  00021080   SLL V0, V0, 2
9D00101C  00561021   ADDU V0, V0, S6
9D001020  0B400152   J 0x9D000548
9D001024  8C420000   LW V0, 0(V0)
1545:                
1546:                      OPCODE_BEGIN(11)  /* ORA ($nn),Y */
1547:                         ORA(5, INDIR_Y_BYTE_READ);
9D00105C  8FA60010   LW A2, 16(SP)
9D001060  00862021   ADDU A0, A0, A2
9D001064  3084FFFF   ANDI A0, A0, -1
9D001068  308200FF   ANDI V0, A0, 255
9D00106C  0046102B   SLTU V0, V0, A2
9D001070  10400007   BEQ V0, ZERO, 0x9D001090
9D001074  26120001   ADDIU S2, S0, 1
9D001078  8F828058   LW V0, -32680(GP)
9D00107C  2442FFFF   ADDIU V0, V0, -1
9D001080  AF828058   SW V0, -32680(GP)
9D001084  8E220054   LW V0, 84(S1)
9D001088  24420001   ADDIU V0, V0, 1
9D00108C  AE220054   SW V0, 84(S1)
9D001090  0F400000   JAL mem_readbyte
9D001094  00000000   NOP
9D001098  00541025   OR V0, V0, S4
9D00109C  305300FF   ANDI S3, V0, 255
9D0010A0  8F828058   LW V0, -32680(GP)
9D0010A4  2442FFFB   ADDIU V0, V0, -5
9D0010A8  AF828058   SW V0, -32680(GP)
9D0010AC  8E230054   LW V1, 84(S1)
9D0010B0  24630005   ADDIU V1, V1, 5
9D0010BC  0260A021   ADDU S4, S3, ZERO
9D0010C0  0B4027B2   J .L45
9D0010C4  0260A821   ADDU S5, S3, ZERO
9D0010F4  0260A021   ADDU S4, S3, ZERO
1548:                         OPCODE_END
9D0010B4  1C400004   BGTZ V0, 0x9D0010C8
9D0010B8  AE230054   SW V1, 84(S1)
9D0010C8  26100002   ADDIU S0, S0, 2
9D0010E4  90420000   LBU V0, 0(V0)
9D0010E8  00021080   SLL V0, V0, 2
9D0010EC  00561021   ADDU V0, V0, S6
9D0010F0  8C420000   LW V0, 0(V0)
9D0010F8  0B400152   J 0x9D000548
9D0010FC  0260A821   ADDU S5, S3, ZERO
1549:                      
1550:                      OPCODE_BEGIN(13)  /* SLO ($nn),Y */
1551:                         SLO(8, INDIR_Y, mem_writebyte, addr);
9D001100  26120001   ADDIU S2, S0, 1
9D001138  8FA70010   LW A3, 16(SP)
9D00113C  02A7A821   ADDU S5, S5, A3
9D001140  32B5FFFF   ANDI S5, S5, -1
9D001144  0F400000   JAL mem_readbyte
9D001148  02A02021   ADDU A0, S5, ZERO
9D00114C  7C5739C0   EXT S7, V0, 7, 8
9D001150  00021040   SLL V0, V0, 1
9D001154  305300FF   ANDI S3, V0, 255
9D001158  02A02021   ADDU A0, S5, ZERO
9D00115C  0F400036   JAL mem_writebyte
9D001160  02602821   ADDU A1, S3, ZERO
9D001164  02749825   OR S3, S3, S4
9D001168  327300FF   ANDI S3, S3, 255
9D00116C  8F828058   LW V0, -32680(GP)
9D001170  2442FFF8   ADDIU V0, V0, -8
9D001174  AF828058   SW V0, -32680(GP)
9D001178  8E230054   LW V1, 84(S1)
9D00117C  24630008   ADDIU V1, V1, 8
9D001188  0260A021   ADDU S4, S3, ZERO
9D00118C  0B4027B2   J .L45
9D001190  0260A821   ADDU S5, S3, ZERO
9D0011C0  0260A021   ADDU S4, S3, ZERO
1552:                         OPCODE_END
9D001180  1C400004   BGTZ V0, 0x9D001194
9D001184  AE230054   SW V1, 84(S1)
9D001194  26100002   ADDIU S0, S0, 2
9D0011B0  90420000   LBU V0, 0(V0)
9D0011B4  00021080   SLL V0, V0, 2
9D0011B8  00561021   ADDU V0, V0, S6
9D0011BC  8C420000   LW V0, 0(V0)
9D0011C4  0B400152   J 0x9D000548
9D0011C8  0260A821   ADDU S5, S3, ZERO
1553:                
1554:                      OPCODE_BEGIN(14)  /* NOP $nn,X */
1555:                      OPCODE_BEGIN(34)  /* NOP */
1556:                      OPCODE_BEGIN(54)  /* NOP $nn,X */
1557:                      OPCODE_BEGIN(74)  /* NOP $nn,X */
1558:                      OPCODE_BEGIN(D4)  /* NOP $nn,X */
1559:                      OPCODE_BEGIN(F4)  /* NOP ($nn,X) */
1560:                         DOP(4);
9D0011CC  0B40047C   J 0x9D0011F0
9D0011D0  26120001   ADDIU S2, S0, 1
9D0011D4  0B40047C   J 0x9D0011F0
9D0011D8  26120001   ADDIU S2, S0, 1
9D0011DC  0B40047C   J 0x9D0011F0
9D0011E0  26120001   ADDIU S2, S0, 1
9D0011E4  0B40047C   J 0x9D0011F0
9D0011E8  26120001   ADDIU S2, S0, 1
9D0011EC  26120001   ADDIU S2, S0, 1
9D0011F0  8F828058   LW V0, -32680(GP)
9D0011F4  2442FFFC   ADDIU V0, V0, -4
9D0011F8  AF828058   SW V0, -32680(GP)
9D0011FC  8E230054   LW V1, 84(S1)
9D001200  24630004   ADDIU V1, V1, 4
1561:                         OPCODE_END
9D001204  18402330   BLEZ V0, .L45
9D001208  AE230054   SW V1, 84(S1)
9D00120C  26100002   ADDIU S0, S0, 2
9D001228  92420000   LBU V0, 0(S2)
9D00122C  00021080   SLL V0, V0, 2
9D001230  00561021   ADDU V0, V0, S6
9D001234  0B400152   J 0x9D000548
9D001238  8C420000   LW V0, 0(V0)
1562:                
1563:                      OPCODE_BEGIN(15)  /* ORA $nn,X */
1564:                         ORA(4, ZP_IND_X_BYTE);
9D00123C  26120001   ADDIU S2, S0, 1
9D001258  90420000   LBU V0, 0(V0)
9D00125C  03C21021   ADDU V0, FP, V0
9D001260  304200FF   ANDI V0, V0, 255
9D001264  8F838054   LW V1, -32684(GP)
9D001268  00621021   ADDU V0, V1, V0
9D00126C  90530000   LBU S3, 0(V0)
9D001270  02749825   OR S3, S3, S4
9D001274  327300FF   ANDI S3, S3, 255
9D001278  8F828058   LW V0, -32680(GP)
9D00127C  2442FFFC   ADDIU V0, V0, -4
9D001280  AF828058   SW V0, -32680(GP)
9D001284  8E230054   LW V1, 84(S1)
9D001288  24630004   ADDIU V1, V1, 4
9D001294  0260A021   ADDU S4, S3, ZERO
9D001298  0B4027B2   J .L45
9D00129C  0260A821   ADDU S5, S3, ZERO
9D0012CC  0260A021   ADDU S4, S3, ZERO
1565:                         OPCODE_END
9D00128C  1C400004   BGTZ V0, 0x9D0012A0
9D001290  AE230054   SW V1, 84(S1)
9D0012A0  26100002   ADDIU S0, S0, 2
9D0012BC  90420000   LBU V0, 0(V0)
9D0012C0  00021080   SLL V0, V0, 2
9D0012C4  00561021   ADDU V0, V0, S6
9D0012C8  8C420000   LW V0, 0(V0)
9D0012D0  0B400152   J 0x9D000548
9D0012D4  0260A821   ADDU S5, S3, ZERO
1566:                
1567:                      OPCODE_BEGIN(16)  /* ASL $nn,X */
1568:                         ASL(6, ZP_IND_X, ZP_WRITEBYTE, baddr);
9D0012D8  26120001   ADDIU S2, S0, 1
9D0012F4  90420000   LBU V0, 0(V0)
9D0012F8  03C21021   ADDU V0, FP, V0
9D0012FC  304200FF   ANDI V0, V0, 255
9D001300  8F838054   LW V1, -32684(GP)
9D001304  00621021   ADDU V0, V1, V0
9D001308  90430000   LBU V1, 0(V0)
9D00130C  0003B9C2   SRL S7, V1, 7
9D001310  00031840   SLL V1, V1, 1
9D001314  307300FF   ANDI S3, V1, 255
9D001318  A0530000   SB S3, 0(V0)
9D00131C  8F828058   LW V0, -32680(GP)
9D001320  2442FFFA   ADDIU V0, V0, -6
9D001324  AF828058   SW V0, -32680(GP)
9D001328  8E230054   LW V1, 84(S1)
9D00132C  24630006   ADDIU V1, V1, 6
9D001338  0B4027B2   J .L45
9D00133C  0260A821   ADDU S5, S3, ZERO
1569:                         OPCODE_END
9D001330  1C400003   BGTZ V0, 0x9D001340
9D001334  AE230054   SW V1, 84(S1)
9D001340  26100002   ADDIU S0, S0, 2
9D00135C  90420000   LBU V0, 0(V0)
9D001360  00021080   SLL V0, V0, 2
9D001364  00561021   ADDU V0, V0, S6
9D001368  8C420000   LW V0, 0(V0)
9D00136C  0B400152   J 0x9D000548
9D001370  0260A821   ADDU S5, S3, ZERO
1570:                
1571:                      OPCODE_BEGIN(17)  /* SLO $nn,X */
1572:                         SLO(6, ZP_IND_X, ZP_WRITEBYTE, baddr);
9D001374  26120001   ADDIU S2, S0, 1
9D001390  90420000   LBU V0, 0(V0)
9D001394  03C21021   ADDU V0, FP, V0
9D001398  304200FF   ANDI V0, V0, 255
9D00139C  8F838054   LW V1, -32684(GP)
9D0013A0  00621821   ADDU V1, V1, V0
9D0013A4  90620000   LBU V0, 0(V1)
9D0013A8  0002B9C2   SRL S7, V0, 7
9D0013AC  00021040   SLL V0, V0, 1
9D0013B0  304200FF   ANDI V0, V0, 255
9D0013B4  A0620000   SB V0, 0(V1)
9D0013B8  00541025   OR V0, V0, S4
9D0013BC  305300FF   ANDI S3, V0, 255
9D0013C0  8F828058   LW V0, -32680(GP)
9D0013C4  2442FFFA   ADDIU V0, V0, -6
9D0013C8  AF828058   SW V0, -32680(GP)
9D0013CC  8E230054   LW V1, 84(S1)
9D0013D0  24630006   ADDIU V1, V1, 6
9D0013DC  0260A021   ADDU S4, S3, ZERO
9D0013E0  0B4027B2   J .L45
9D0013E4  0260A821   ADDU S5, S3, ZERO
9D001414  0260A021   ADDU S4, S3, ZERO
1573:                         OPCODE_END
9D0013D4  1C400004   BGTZ V0, 0x9D0013E8
9D0013D8  AE230054   SW V1, 84(S1)
9D0013E8  26100002   ADDIU S0, S0, 2
9D001404  90420000   LBU V0, 0(V0)
9D001408  00021080   SLL V0, V0, 2
9D00140C  00561021   ADDU V0, V0, S6
9D001410  8C420000   LW V0, 0(V0)
9D001418  0B400152   J 0x9D000548
9D00141C  0260A821   ADDU S5, S3, ZERO
1574:                
1575:                      OPCODE_BEGIN(18)  /* CLC */
1576:                         CLC();
9D001420  8F828058   LW V0, -32680(GP)
9D001424  2442FFFE   ADDIU V0, V0, -2
9D001428  AF828058   SW V0, -32680(GP)
9D00142C  8E230054   LW V1, 84(S1)
9D001430  24630002   ADDIU V1, V1, 2
9D001440  0B4027B2   J .L45
9D001444  0000B821   ADDU S7, ZERO, ZERO
1577:                         OPCODE_END
9D001434  1C400004   BGTZ V0, .LBB1022
9D001438  AE230054   SW V1, 84(S1)
9D00143C  02009021   ADDU S2, S0, ZERO
9D001460  90420000   LBU V0, 0(V0)
9D001464  00021080   SLL V0, V0, 2
9D001468  00561021   ADDU V0, V0, S6
9D00146C  8C420000   LW V0, 0(V0)
9D001470  26100001   ADDIU S0, S0, 1
9D001474  0B400152   J 0x9D000548
9D001478  0000B821   ADDU S7, ZERO, ZERO
1578:                
1579:                      OPCODE_BEGIN(19)  /* ORA $nnnn,Y */
1580:                         ORA(4, ABS_IND_Y_BYTE_READ);
9D0014C0  8FA80010   LW T0, 16(SP)
9D0014C4  00882021   ADDU A0, A0, T0
9D0014C8  3084FFFF   ANDI A0, A0, -1
9D0014CC  308200FF   ANDI V0, A0, 255
9D0014D0  0048102B   SLTU V0, V0, T0
9D0014D4  10400007   BEQ V0, ZERO, 0x9D0014F4
9D0014D8  26120002   ADDIU S2, S0, 2
9D0014DC  8F828058   LW V0, -32680(GP)
9D0014E0  2442FFFF   ADDIU V0, V0, -1
9D0014E4  AF828058   SW V0, -32680(GP)
9D0014E8  8E220054   LW V0, 84(S1)
9D0014EC  24420001   ADDIU V0, V0, 1
9D0014F0  AE220054   SW V0, 84(S1)
9D0014F4  0F400000   JAL mem_readbyte
9D0014F8  00000000   NOP
9D0014FC  00541025   OR V0, V0, S4
9D001500  305300FF   ANDI S3, V0, 255
9D001504  8F828058   LW V0, -32680(GP)
9D001508  2442FFFC   ADDIU V0, V0, -4
9D00150C  AF828058   SW V0, -32680(GP)
9D001510  8E230054   LW V1, 84(S1)
9D001514  24630004   ADDIU V1, V1, 4
9D001520  0260A021   ADDU S4, S3, ZERO
9D001524  0B4027B2   J .L45
9D001528  0260A821   ADDU S5, S3, ZERO
9D001558  0260A021   ADDU S4, S3, ZERO
1581:                         OPCODE_END
9D001518  1C400004   BGTZ V0, 0x9D00152C
9D00151C  AE230054   SW V1, 84(S1)
9D00152C  26100003   ADDIU S0, S0, 3
9D001548  90420000   LBU V0, 0(V0)
9D00154C  00021080   SLL V0, V0, 2
9D001550  00561021   ADDU V0, V0, S6
9D001554  8C420000   LW V0, 0(V0)
9D00155C  0B400152   J 0x9D000548
9D001560  0260A821   ADDU S5, S3, ZERO
1582:                      
1583:                      OPCODE_BEGIN(1A)  /* NOP */
1584:                      OPCODE_BEGIN(3A)  /* NOP */
1585:                      OPCODE_BEGIN(5A)  /* NOP */
1586:                      OPCODE_BEGIN(7A)  /* NOP */
1587:                      OPCODE_BEGIN(DA)  /* NOP */
1588:                      OPCODE_BEGIN(FA)  /* NOP */
1589:                         NOP();
9D001564  0B400562   J 0x9D001588
9D001568  8F828058   LW V0, -32680(GP)
9D00156C  0B400562   J 0x9D001588
9D001570  8F828058   LW V0, -32680(GP)
9D001574  0B400562   J 0x9D001588
9D001578  8F828058   LW V0, -32680(GP)
9D00157C  0B400562   J 0x9D001588
9D001580  8F828058   LW V0, -32680(GP)
9D001584  8F828058   LW V0, -32680(GP)
9D001588  2442FFFE   ADDIU V0, V0, -2
9D00158C  AF828058   SW V0, -32680(GP)
9D001590  8E230054   LW V1, 84(S1)
9D001594  24630002   ADDIU V1, V1, 2
1590:                         OPCODE_END
9D001598  1C400003   BGTZ V0, .LBB1028
9D00159C  AE230054   SW V1, 84(S1)
9D0015A0  0B4027B2   J .L45
9D0015A4  02009021   ADDU S2, S0, ZERO
9D0015C0  90420000   LBU V0, 0(V0)
9D0015C4  00021080   SLL V0, V0, 2
9D0015C8  00561021   ADDU V0, V0, S6
9D0015CC  8C420000   LW V0, 0(V0)
9D0015D0  0B400152   J 0x9D000548
9D0015D4  26100001   ADDIU S0, S0, 1
1591:                
1592:                      OPCODE_BEGIN(1B)  /* SLO $nnnn,Y */
1593:                         SLO(7, ABS_IND_Y, mem_writebyte, addr);
9D0015DC  26120002   ADDIU S2, S0, 2
9D001620  8FA20010   LW V0, 16(SP)
9D001624  02A2A821   ADDU S5, S5, V0
9D001628  32B5FFFF   ANDI S5, S5, -1
9D00162C  0F400000   JAL mem_readbyte
9D001630  02A02021   ADDU A0, S5, ZERO
9D001634  7C5739C0   EXT S7, V0, 7, 8
9D001638  00021040   SLL V0, V0, 1
9D00163C  305300FF   ANDI S3, V0, 255
9D001640  02A02021   ADDU A0, S5, ZERO
9D001644  0F400036   JAL mem_writebyte
9D001648  02602821   ADDU A1, S3, ZERO
9D00164C  02749825   OR S3, S3, S4
9D001650  327300FF   ANDI S3, S3, 255
9D001654  8F828058   LW V0, -32680(GP)
9D001658  2442FFF9   ADDIU V0, V0, -7
9D00165C  AF828058   SW V0, -32680(GP)
9D001660  8E230054   LW V1, 84(S1)
9D001664  24630007   ADDIU V1, V1, 7
9D001670  0260A021   ADDU S4, S3, ZERO
9D001674  0B4027B2   J .L45
9D001678  0260A821   ADDU S5, S3, ZERO
9D0016A8  0260A021   ADDU S4, S3, ZERO
1594:                         OPCODE_END
9D001668  1C400004   BGTZ V0, 0x9D00167C
9D00166C  AE230054   SW V1, 84(S1)
9D00167C  26100003   ADDIU S0, S0, 3
9D001698  90420000   LBU V0, 0(V0)
9D00169C  00021080   SLL V0, V0, 2
9D0016A0  00561021   ADDU V0, V0, S6
9D0016A4  8C420000   LW V0, 0(V0)
9D0016AC  0B400152   J 0x9D000548
9D0016B0  0260A821   ADDU S5, S3, ZERO
1595:                
1596:                      OPCODE_BEGIN(1C)  /* NOP $nnnn,X */
1597:                      OPCODE_BEGIN(3C)  /* NOP $nnnn,X */
1598:                      OPCODE_BEGIN(5C)  /* NOP $nnnn,X */
1599:                      OPCODE_BEGIN(7C)  /* NOP $nnnn,X */
1600:                      OPCODE_BEGIN(DC)  /* NOP $nnnn,X */
1601:                      OPCODE_BEGIN(FC)  /* NOP $nnnn,X */
1602:                         TOP();
9D0016B4  0B4005B6   J 0x9D0016D8
9D0016B8  26120002   ADDIU S2, S0, 2
9D0016BC  0B4005B6   J 0x9D0016D8
9D0016C0  26120002   ADDIU S2, S0, 2
9D0016C4  0B4005B6   J 0x9D0016D8
9D0016C8  26120002   ADDIU S2, S0, 2
9D0016CC  0B4005B6   J 0x9D0016D8
9D0016D0  26120002   ADDIU S2, S0, 2
9D0016D4  26120002   ADDIU S2, S0, 2
9D0016D8  8F828058   LW V0, -32680(GP)
9D0016DC  2442FFFC   ADDIU V0, V0, -4
9D0016E0  AF828058   SW V0, -32680(GP)
9D0016E4  8E230054   LW V1, 84(S1)
9D0016E8  24630004   ADDIU V1, V1, 4
1603:                         OPCODE_END
9D0016EC  184021F6   BLEZ V0, .L45
9D0016F0  AE230054   SW V1, 84(S1)
9D0016F4  26100003   ADDIU S0, S0, 3
9D001710  92420000   LBU V0, 0(S2)
9D001714  00021080   SLL V0, V0, 2
9D001718  00561021   ADDU V0, V0, S6
9D00171C  0B400152   J 0x9D000548
9D001720  8C420000   LW V0, 0(V0)
1604:                
1605:                      OPCODE_BEGIN(1D)  /* ORA $nnnn,X */
1606:                         ORA(4, ABS_IND_X_BYTE_READ);
9D001768  009E2021   ADDU A0, A0, FP
9D00176C  3084FFFF   ANDI A0, A0, -1
9D001770  308200FF   ANDI V0, A0, 255
9D001774  005E102B   SLTU V0, V0, FP
9D001778  10400007   BEQ V0, ZERO, 0x9D001798
9D00177C  26120002   ADDIU S2, S0, 2
9D001780  8F828058   LW V0, -32680(GP)
9D001784  2442FFFF   ADDIU V0, V0, -1
9D001788  AF828058   SW V0, -32680(GP)
9D00178C  8E220054   LW V0, 84(S1)
9D001790  24420001   ADDIU V0, V0, 1
9D001794  AE220054   SW V0, 84(S1)
9D001798  0F400000   JAL mem_readbyte
9D00179C  00000000   NOP
9D0017A0  00541025   OR V0, V0, S4
9D0017A4  305300FF   ANDI S3, V0, 255
9D0017A8  8F828058   LW V0, -32680(GP)
9D0017AC  2442FFFC   ADDIU V0, V0, -4
9D0017B0  AF828058   SW V0, -32680(GP)
9D0017B4  8E230054   LW V1, 84(S1)
9D0017B8  24630004   ADDIU V1, V1, 4
9D0017C4  0260A021   ADDU S4, S3, ZERO
9D0017C8  0B4027B2   J .L45
9D0017CC  0260A821   ADDU S5, S3, ZERO
9D0017FC  0260A021   ADDU S4, S3, ZERO
1607:                         OPCODE_END
9D0017BC  1C400004   BGTZ V0, 0x9D0017D0
9D0017C0  AE230054   SW V1, 84(S1)
9D0017D0  26100003   ADDIU S0, S0, 3
9D0017EC  90420000   LBU V0, 0(V0)
9D0017F0  00021080   SLL V0, V0, 2
9D0017F4  00561021   ADDU V0, V0, S6
9D0017F8  8C420000   LW V0, 0(V0)
9D001800  0B400152   J 0x9D000548
9D001804  0260A821   ADDU S5, S3, ZERO
1608:                
1609:                      OPCODE_BEGIN(1E)  /* ASL $nnnn,X */
1610:                         ASL(7, ABS_IND_X, mem_writebyte, addr);
9D00180C  26120002   ADDIU S2, S0, 2
9D001850  02BEA821   ADDU S5, S5, FP
9D001854  32B5FFFF   ANDI S5, S5, -1
9D001858  0F400000   JAL mem_readbyte
9D00185C  02A02021   ADDU A0, S5, ZERO
9D001860  7C5739C0   EXT S7, V0, 7, 8
9D001864  00021040   SLL V0, V0, 1
9D001868  305300FF   ANDI S3, V0, 255
9D00186C  02A02021   ADDU A0, S5, ZERO
9D001870  0F400036   JAL mem_writebyte
9D001874  02602821   ADDU A1, S3, ZERO
9D001878  8F828058   LW V0, -32680(GP)
9D00187C  2442FFF9   ADDIU V0, V0, -7
9D001880  AF828058   SW V0, -32680(GP)
9D001884  8E230054   LW V1, 84(S1)
9D001888  24630007   ADDIU V1, V1, 7
9D001894  0B4027B2   J .L45
9D001898  0260A821   ADDU S5, S3, ZERO
1611:                         OPCODE_END
9D00188C  1C400003   BGTZ V0, 0x9D00189C
9D001890  AE230054   SW V1, 84(S1)
9D00189C  26100003   ADDIU S0, S0, 3
9D0018B8  90420000   LBU V0, 0(V0)
9D0018BC  00021080   SLL V0, V0, 2
9D0018C0  00561021   ADDU V0, V0, S6
9D0018C4  8C420000   LW V0, 0(V0)
9D0018C8  0B400152   J 0x9D000548
9D0018CC  0260A821   ADDU S5, S3, ZERO
1612:                
1613:                      OPCODE_BEGIN(1F)  /* SLO $nnnn,X */
1614:                         SLO(7, ABS_IND_X, mem_writebyte, addr);
9D0018D4  26120002   ADDIU S2, S0, 2
9D001918  02BEA821   ADDU S5, S5, FP
9D00191C  32B5FFFF   ANDI S5, S5, -1
9D001920  0F400000   JAL mem_readbyte
9D001924  02A02021   ADDU A0, S5, ZERO
9D001928  7C5739C0   EXT S7, V0, 7, 8
9D00192C  00021040   SLL V0, V0, 1
9D001930  305300FF   ANDI S3, V0, 255
9D001934  02A02021   ADDU A0, S5, ZERO
9D001938  0F400036   JAL mem_writebyte
9D00193C  02602821   ADDU A1, S3, ZERO
9D001940  02749825   OR S3, S3, S4
9D001944  327300FF   ANDI S3, S3, 255
9D001948  8F828058   LW V0, -32680(GP)
9D00194C  2442FFF9   ADDIU V0, V0, -7
9D001950  AF828058   SW V0, -32680(GP)
9D001954  8E230054   LW V1, 84(S1)
9D001958  24630007   ADDIU V1, V1, 7
9D001964  0260A021   ADDU S4, S3, ZERO
9D001968  0B4027B2   J .L45
9D00196C  0260A821   ADDU S5, S3, ZERO
9D00199C  0260A021   ADDU S4, S3, ZERO
1615:                         OPCODE_END
9D00195C  1C400004   BGTZ V0, 0x9D001970
9D001960  AE230054   SW V1, 84(S1)
9D001970  26100003   ADDIU S0, S0, 3
9D00198C  90420000   LBU V0, 0(V0)
9D001990  00021080   SLL V0, V0, 2
9D001994  00561021   ADDU V0, V0, S6
9D001998  8C420000   LW V0, 0(V0)
9D0019A0  0B400152   J 0x9D000548
9D0019A4  0260A821   ADDU S5, S3, ZERO
1616:                      
1617:                      OPCODE_BEGIN(20)  /* JSR $nnnn */
1618:                         JSR();
9D0019A8  26020001   ADDIU V0, S0, 1
9D0019AC  8F838050   LW V1, -32688(GP)
9D0019B0  8FA50014   LW A1, 20(SP)
9D0019B4  24A4FFFF   ADDIU A0, A1, -1
9D0019B8  308400FF   ANDI A0, A0, 255
9D0019BC  00652821   ADDU A1, V1, A1
9D0019C0  00023202   SRL A2, V0, 8
9D0019C4  A0A60000   SB A2, 0(A1)
9D0019C8  8FA60014   LW A2, 20(SP)
9D0019CC  24C5FFFE   ADDIU A1, A2, -2
9D0019D0  30A500FF   ANDI A1, A1, 255
9D0019D4  AFA50014   SW A1, 20(SP)
9D0019D8  00641821   ADDU V1, V1, A0
9D0019DC  A0620000   SB V0, 0(V1)
9D001A20  8F828058   LW V0, -32680(GP)
9D001A24  2442FFFA   ADDIU V0, V0, -6
9D001A28  AF828058   SW V0, -32680(GP)
9D001A2C  8E230054   LW V1, 84(S1)
9D001A30  24630006   ADDIU V1, V1, 6
1619:                         OPCODE_END
9D001A34  18402124   BLEZ V0, .L45
9D001A38  AE230054   SW V1, 84(S1)
9D001A3C  26500001   ADDIU S0, S2, 1
9D001A48  92420000   LBU V0, 0(S2)
9D001A4C  00021080   SLL V0, V0, 2
9D001A50  00561021   ADDU V0, V0, S6
9D001A54  0B400152   J 0x9D000548
9D001A58  8C420000   LW V0, 0(V0)
1620:                
1621:                      OPCODE_BEGIN(21)  /* AND ($nn,X) */
1622:                         AND(6, INDIR_X_BYTE);
9D001A5C  26120001   ADDIU S2, S0, 1
9D001A78  90420000   LBU V0, 0(V0)
9D001A7C  03C21021   ADDU V0, FP, V0
9D001A98  0F400000   JAL mem_readbyte
9D001A9C  308400FF   ANDI A0, A0, 255
9D001AA0  00541024   AND V0, V0, S4
9D001AA4  305300FF   ANDI S3, V0, 255
9D001AA8  8F828058   LW V0, -32680(GP)
9D001AAC  2442FFFA   ADDIU V0, V0, -6
9D001AB0  AF828058   SW V0, -32680(GP)
9D001AB4  8E230054   LW V1, 84(S1)
9D001AB8  24630006   ADDIU V1, V1, 6
9D001AC4  0260A021   ADDU S4, S3, ZERO
9D001AC8  0B4027B2   J .L45
9D001ACC  0260A821   ADDU S5, S3, ZERO
9D001AFC  0260A021   ADDU S4, S3, ZERO
1623:                         OPCODE_END
9D001ABC  1C400004   BGTZ V0, 0x9D001AD0
9D001AC0  AE230054   SW V1, 84(S1)
9D001AD0  26100002   ADDIU S0, S0, 2
9D001AEC  90420000   LBU V0, 0(V0)
9D001AF0  00021080   SLL V0, V0, 2
9D001AF4  00561021   ADDU V0, V0, S6
9D001AF8  8C420000   LW V0, 0(V0)
9D001B00  0B400152   J 0x9D000548
9D001B04  0260A821   ADDU S5, S3, ZERO
1624:                
1625:                      OPCODE_BEGIN(23)  /* RLA ($nn,X) */
1626:                         RLA(8, INDIR_X, mem_writebyte, addr);
9D001B08  26120001   ADDIU S2, S0, 1
9D001B24  90420000   LBU V0, 0(V0)
9D001B28  03C21021   ADDU V0, FP, V0
9D001B48  0F400000   JAL mem_readbyte
9D001B4C  02A02021   ADDU A0, S5, ZERO
9D001B50  7C4739C0   EXT A3, V0, 7, 8
9D001B54  AFA7002C   SW A3, 44(SP)
9D001B58  00021040   SLL V0, V0, 1
9D001B5C  00579825   OR S3, V0, S7
9D001B60  327300FF   ANDI S3, S3, 255
9D001B64  02A02021   ADDU A0, S5, ZERO
9D001B68  0F400036   JAL mem_writebyte
9D001B6C  02602821   ADDU A1, S3, ZERO
9D001B70  02749824   AND S3, S3, S4
9D001B74  8F828058   LW V0, -32680(GP)
9D001B78  2442FFF8   ADDIU V0, V0, -8
9D001B7C  AF828058   SW V0, -32680(GP)
9D001B80  8E230054   LW V1, 84(S1)
9D001B84  24630008   ADDIU V1, V1, 8
9D001B90  0260A021   ADDU S4, S3, ZERO
9D001B94  8FB7002C   LW S7, 44(SP)
9D001B98  0B4027B2   J .L45
9D001B9C  0260A821   ADDU S5, S3, ZERO
9D001BCC  0260A021   ADDU S4, S3, ZERO
9D001BD0  8FB7002C   LW S7, 44(SP)
1627:                         OPCODE_END
9D001B88  1C400005   BGTZ V0, 0x9D001BA0
9D001B8C  AE230054   SW V1, 84(S1)
9D001BA0  26100002   ADDIU S0, S0, 2
9D001BBC  90420000   LBU V0, 0(V0)
9D001BC0  00021080   SLL V0, V0, 2
9D001BC4  00561021   ADDU V0, V0, S6
9D001BC8  8C420000   LW V0, 0(V0)
9D001BD4  0B400152   J 0x9D000548
9D001BD8  0260A821   ADDU S5, S3, ZERO
1628:                
1629:                      OPCODE_BEGIN(24)  /* BIT $nn */
1630:                         BIT(3, ZERO_PAGE_BYTE);
9D001BDC  26120001   ADDIU S2, S0, 1
9D001BF8  90420000   LBU V0, 0(V0)
9D001BFC  8F838054   LW V1, -32684(GP)
9D001C00  00621021   ADDU V0, V1, V0
9D001C04  90530000   LBU S3, 0(V0)
9D001C08  32620040   ANDI V0, S3, 64
9D001C0C  304200FF   ANDI V0, V0, 255
9D001C10  AFA20018   SW V0, 24(SP)
9D001C14  0274A824   AND S5, S3, S4
9D001C18  8F828058   LW V0, -32680(GP)
9D001C1C  2442FFFD   ADDIU V0, V0, -3
9D001C20  AF828058   SW V0, -32680(GP)
9D001C24  8E230054   LW V1, 84(S1)
9D001C28  24630003   ADDIU V1, V1, 3
1631:                         OPCODE_END
9D001C2C  184020A6   BLEZ V0, .L45
9D001C30  AE230054   SW V1, 84(S1)
9D001C34  26100002   ADDIU S0, S0, 2
9D001C50  90420000   LBU V0, 0(V0)
9D001C54  00021080   SLL V0, V0, 2
9D001C58  00561021   ADDU V0, V0, S6
9D001C5C  0B400152   J 0x9D000548
9D001C60  8C420000   LW V0, 0(V0)
1632:                
1633:                      OPCODE_BEGIN(25)  /* AND $nn */
1634:                         AND(3, ZERO_PAGE_BYTE);
9D001C64  26120001   ADDIU S2, S0, 1
9D001C80  90420000   LBU V0, 0(V0)
9D001C84  8F838054   LW V1, -32684(GP)
9D001C88  00621021   ADDU V0, V1, V0
9D001C8C  90530000   LBU S3, 0(V0)
9D001C90  02939824   AND S3, S4, S3
9D001C94  8F828058   LW V0, -32680(GP)
9D001C98  2442FFFD   ADDIU V0, V0, -3
9D001C9C  AF828058   SW V0, -32680(GP)
9D001CA0  8E230054   LW V1, 84(S1)
9D001CA4  24630003   ADDIU V1, V1, 3
9D001CB0  0260A021   ADDU S4, S3, ZERO
9D001CB4  0B4027B2   J .L45
9D001CB8  0260A821   ADDU S5, S3, ZERO
9D001CE8  0260A021   ADDU S4, S3, ZERO
1635:                         OPCODE_END
9D001CA8  1C400004   BGTZ V0, 0x9D001CBC
9D001CAC  AE230054   SW V1, 84(S1)
9D001CBC  26100002   ADDIU S0, S0, 2
9D001CD8  90420000   LBU V0, 0(V0)
9D001CDC  00021080   SLL V0, V0, 2
9D001CE0  00561021   ADDU V0, V0, S6
9D001CE4  8C420000   LW V0, 0(V0)
9D001CEC  0B400152   J 0x9D000548
9D001CF0  0260A821   ADDU S5, S3, ZERO
1636:                
1637:                      OPCODE_BEGIN(26)  /* ROL $nn */
1638:                         ROL(5, ZERO_PAGE, ZP_WRITEBYTE, baddr);
9D001CF4  26120001   ADDIU S2, S0, 1
9D001D10  90420000   LBU V0, 0(V0)
9D001D14  8F838054   LW V1, -32684(GP)
9D001D18  00621021   ADDU V0, V1, V0
9D001D1C  90430000   LBU V1, 0(V0)
9D001D20  000321C2   SRL A0, V1, 7
9D001D24  00031840   SLL V1, V1, 1
9D001D28  00779825   OR S3, V1, S7
9D001D2C  327300FF   ANDI S3, S3, 255
9D001D30  A0530000   SB S3, 0(V0)
9D001D34  8F828058   LW V0, -32680(GP)
9D001D38  2442FFFB   ADDIU V0, V0, -5
9D001D3C  AF828058   SW V0, -32680(GP)
9D001D40  8E230054   LW V1, 84(S1)
9D001D44  24630005   ADDIU V1, V1, 5
9D001D50  0080B821   ADDU S7, A0, ZERO
9D001D54  0B4027B2   J .L45
9D001D58  0260A821   ADDU S5, S3, ZERO
9D001D88  0080B821   ADDU S7, A0, ZERO
1639:                         OPCODE_END
9D001D48  1C400004   BGTZ V0, 0x9D001D5C
9D001D4C  AE230054   SW V1, 84(S1)
9D001D5C  26100002   ADDIU S0, S0, 2
9D001D78  90420000   LBU V0, 0(V0)
9D001D7C  00021080   SLL V0, V0, 2
9D001D80  00561021   ADDU V0, V0, S6
9D001D84  8C420000   LW V0, 0(V0)
9D001D8C  0B400152   J 0x9D000548
9D001D90  0260A821   ADDU S5, S3, ZERO
1640:                
1641:                      OPCODE_BEGIN(27)  /* RLA $nn */
1642:                         RLA(5, ZERO_PAGE, ZP_WRITEBYTE, baddr);
9D001D94  26120001   ADDIU S2, S0, 1
9D001DB0  90420000   LBU V0, 0(V0)
9D001DB4  8F838054   LW V1, -32684(GP)
9D001DB8  00621021   ADDU V0, V1, V0
9D001DBC  90430000   LBU V1, 0(V0)
9D001DC0  000321C2   SRL A0, V1, 7
9D001DC4  00031840   SLL V1, V1, 1
9D001DC8  00779825   OR S3, V1, S7
9D001DCC  327300FF   ANDI S3, S3, 255
9D001DD0  A0530000   SB S3, 0(V0)
9D001DD4  02749824   AND S3, S3, S4
9D001DD8  8F828058   LW V0, -32680(GP)
9D001DDC  2442FFFB   ADDIU V0, V0, -5
9D001DE0  AF828058   SW V0, -32680(GP)
9D001DE4  8E230054   LW V1, 84(S1)
9D001DE8  24630005   ADDIU V1, V1, 5
9D001DF4  0260A021   ADDU S4, S3, ZERO
9D001DF8  0080B821   ADDU S7, A0, ZERO
9D001DFC  0B4027B2   J .L45
9D001E00  0260A821   ADDU S5, S3, ZERO
9D001E30  0260A021   ADDU S4, S3, ZERO
9D001E34  0080B821   ADDU S7, A0, ZERO
1643:                         OPCODE_END
9D001DEC  1C400005   BGTZ V0, 0x9D001E04
9D001DF0  AE230054   SW V1, 84(S1)
9D001E04  26100002   ADDIU S0, S0, 2
9D001E20  90420000   LBU V0, 0(V0)
9D001E24  00021080   SLL V0, V0, 2
9D001E28  00561021   ADDU V0, V0, S6
9D001E2C  8C420000   LW V0, 0(V0)
9D001E38  0B400152   J 0x9D000548
9D001E3C  0260A821   ADDU S5, S3, ZERO
1644:                
1645:                      OPCODE_BEGIN(28)  /* PLP */
1646:                         PLP();
9D001E40  8FA80014   LW T0, 20(SP)
9D001E44  25020001   ADDIU V0, T0, 1
9D001E48  304200FF   ANDI V0, V0, 255
9D001E4C  AFA20014   SW V0, 20(SP)
9D001E50  8F828050   LW V0, -32688(GP)
9D001E54  8FA30014   LW V1, 20(SP)
9D001E58  00431021   ADDU V0, V0, V1
9D001E5C  90570000   LBU S7, 0(V0)
9D001E60  32F30080   ANDI S3, S7, 128
9D001E64  32E20040   ANDI V0, S7, 64
9D001E68  304200FF   ANDI V0, V0, 255
9D001E6C  AFA20018   SW V0, 24(SP)
9D001E70  32E20010   ANDI V0, S7, 16
9D001E74  304200FF   ANDI V0, V0, 255
9D001E78  AFA20028   SW V0, 40(SP)
9D001E7C  32E20008   ANDI V0, S7, 8
9D001E80  304200FF   ANDI V0, V0, 255
9D001E84  AFA20020   SW V0, 32(SP)
9D001E88  32E20004   ANDI V0, S7, 4
9D001E8C  304200FF   ANDI V0, V0, 255
9D001E90  AFA2001C   SW V0, 28(SP)
9D001E94  3AF50002   XORI S5, S7, 2
9D001E98  7EB50040   EXT S5, S5, 1, 1
9D001E9C  32F70001   ANDI S7, S7, 1
9D001EA0  8F828058   LW V0, -32680(GP)
9D001EA4  2442FFFC   ADDIU V0, V0, -4
9D001EA8  AF828058   SW V0, -32680(GP)
9D001EAC  8E230054   LW V1, 84(S1)
9D001EB0  24630004   ADDIU V1, V1, 4
1647:                         OPCODE_END
9D001EB4  1C400003   BGTZ V0, .LBB1086
9D001EB8  AE230054   SW V1, 84(S1)
9D001EBC  0B4027B2   J .L45
9D001EC0  02009021   ADDU S2, S0, ZERO
9D001EDC  90420000   LBU V0, 0(V0)
9D001EE0  00021080   SLL V0, V0, 2
9D001EE4  00561021   ADDU V0, V0, S6
9D001EE8  8C420000   LW V0, 0(V0)
9D001EEC  0B400152   J 0x9D000548
9D001EF0  26100001   ADDIU S0, S0, 1
1648:                
1649:                      OPCODE_BEGIN(29)  /* AND #$nn */
1650:                         AND(2, IMMEDIATE_BYTE);
9D001EF4  26120001   ADDIU S2, S0, 1
9D001F10  90530000   LBU S3, 0(V0)
9D001F14  02939824   AND S3, S4, S3
9D001F18  8F828058   LW V0, -32680(GP)
9D001F1C  2442FFFE   ADDIU V0, V0, -2
9D001F20  AF828058   SW V0, -32680(GP)
9D001F24  8E230054   LW V1, 84(S1)
9D001F28  24630002   ADDIU V1, V1, 2
9D001F34  0260A021   ADDU S4, S3, ZERO
9D001F38  0B4027B2   J .L45
9D001F3C  0260A821   ADDU S5, S3, ZERO
9D001F6C  0260A021   ADDU S4, S3, ZERO
1651:                         OPCODE_END
9D001F2C  1C400004   BGTZ V0, 0x9D001F40
9D001F30  AE230054   SW V1, 84(S1)
9D001F40  26100002   ADDIU S0, S0, 2
9D001F5C  90420000   LBU V0, 0(V0)
9D001F60  00021080   SLL V0, V0, 2
9D001F64  00561021   ADDU V0, V0, S6
9D001F68  8C420000   LW V0, 0(V0)
9D001F70  0B400152   J 0x9D000548
9D001F74  0260A821   ADDU S5, S3, ZERO
1652:                
1653:                      OPCODE_BEGIN(2A)  /* ROL A */
1654:                         ROL_A();
9D001F78  7E8339C0   EXT V1, S4, 7, 8
9D001F7C  00149840   SLL S3, S4, 1
9D001F80  02779825   OR S3, S3, S7
9D001F84  327300FF   ANDI S3, S3, 255
9D001F88  8F828058   LW V0, -32680(GP)
9D001F8C  2442FFFE   ADDIU V0, V0, -2
9D001F90  AF828058   SW V0, -32680(GP)
9D001F94  8E240054   LW A0, 84(S1)
9D001F98  24840002   ADDIU A0, A0, 2
9D001FA4  0260A021   ADDU S4, S3, ZERO
9D001FAC  0060B821   ADDU S7, V1, ZERO
9D001FB0  0B4027B2   J .L45
9D001FB4  0260A821   ADDU S5, S3, ZERO
9D001FE0  0260A021   ADDU S4, S3, ZERO
9D001FE8  0060B821   ADDU S7, V1, ZERO
1655:                         OPCODE_END
9D001F9C  1C400006   BGTZ V0, .LBB1092
9D001FA0  AE240054   SW A0, 84(S1)
9D001FA8  02009021   ADDU S2, S0, ZERO
9D001FD0  90420000   LBU V0, 0(V0)
9D001FD4  00021080   SLL V0, V0, 2
9D001FD8  00561021   ADDU V0, V0, S6
9D001FDC  8C420000   LW V0, 0(V0)
9D001FE4  26100001   ADDIU S0, S0, 1
9D001FEC  0B400152   J 0x9D000548
9D001FF0  0260A821   ADDU S5, S3, ZERO
1656:                
1657:                      OPCODE_BEGIN(2B)  /* ANC #$nn */
1658:                         ANC(2, IMMEDIATE_BYTE);
9D001FF4  26120001   ADDIU S2, S0, 1
9D002010  90550000   LBU S5, 0(V0)
9D002014  0295A824   AND S5, S4, S5
9D002018  7E7739C0   EXT S7, S3, 7, 8
9D00201C  8F828058   LW V0, -32680(GP)
9D002020  2442FFFE   ADDIU V0, V0, -2
9D002024  AF828058   SW V0, -32680(GP)
9D002028  8E230054   LW V1, 84(S1)
9D00202C  24630002   ADDIU V1, V1, 2
9D002038  02A0A021   ADDU S4, S5, ZERO
9D00203C  0B4027B2   J .L45
9D002040  02A09821   ADDU S3, S5, ZERO
9D002070  02A0A021   ADDU S4, S5, ZERO
1659:                         OPCODE_END
9D002030  1C400004   BGTZ V0, 0x9D002044
9D002034  AE230054   SW V1, 84(S1)
9D002044  26100002   ADDIU S0, S0, 2
9D002060  90420000   LBU V0, 0(V0)
9D002064  00021080   SLL V0, V0, 2
9D002068  00561021   ADDU V0, V0, S6
9D00206C  8C420000   LW V0, 0(V0)
9D002074  0B400152   J 0x9D000548
9D002078  02A09821   ADDU S3, S5, ZERO
1660:                
1661:                      OPCODE_BEGIN(2C)  /* BIT $nnnn */
1662:                         BIT(4, ABSOLUTE_BYTE);
9D002080  26120002   ADDIU S2, S0, 2
9D0020C0  0F400000   JAL mem_readbyte
9D0020C4  308400FF   ANDI A0, A0, 255
9D0020C8  00409821   ADDU S3, V0, ZERO
9D0020CC  30420040   ANDI V0, V0, 64
9D0020D0  304200FF   ANDI V0, V0, 255
9D0020D4  AFA20018   SW V0, 24(SP)
9D0020D8  0274A824   AND S5, S3, S4
9D0020DC  32B500FF   ANDI S5, S5, 255
9D0020E0  8F828058   LW V0, -32680(GP)
9D0020E4  2442FFFC   ADDIU V0, V0, -4
9D0020E8  AF828058   SW V0, -32680(GP)
9D0020EC  8E230054   LW V1, 84(S1)
9D0020F0  24630004   ADDIU V1, V1, 4
1663:                         OPCODE_END
9D0020F4  18401F74   BLEZ V0, .L45
9D0020F8  AE230054   SW V1, 84(S1)
9D0020FC  26100003   ADDIU S0, S0, 3
9D002118  90420000   LBU V0, 0(V0)
9D00211C  00021080   SLL V0, V0, 2
9D002120  00561021   ADDU V0, V0, S6
9D002124  0B400152   J 0x9D000548
9D002128  8C420000   LW V0, 0(V0)
1664:                
1665:                      OPCODE_BEGIN(2D)  /* AND $nnnn */
1666:                         AND(4, ABSOLUTE_BYTE);
9D002130  26120002   ADDIU S2, S0, 2
9D002170  0F400000   JAL mem_readbyte
9D002174  308400FF   ANDI A0, A0, 255
9D002178  00541024   AND V0, V0, S4
9D00217C  305300FF   ANDI S3, V0, 255
9D002180  8F828058   LW V0, -32680(GP)
9D002184  2442FFFC   ADDIU V0, V0, -4
9D002188  AF828058   SW V0, -32680(GP)
9D00218C  8E230054   LW V1, 84(S1)
9D002190  24630004   ADDIU V1, V1, 4
9D00219C  0260A021   ADDU S4, S3, ZERO
9D0021A0  0B4027B2   J .L45
9D0021A4  0260A821   ADDU S5, S3, ZERO
9D0021D4  0260A021   ADDU S4, S3, ZERO
1667:                         OPCODE_END
9D002194  1C400004   BGTZ V0, 0x9D0021A8
9D002198  AE230054   SW V1, 84(S1)
9D0021A8  26100003   ADDIU S0, S0, 3
9D0021C4  90420000   LBU V0, 0(V0)
9D0021C8  00021080   SLL V0, V0, 2
9D0021CC  00561021   ADDU V0, V0, S6
9D0021D0  8C420000   LW V0, 0(V0)
9D0021D8  0B400152   J 0x9D000548
9D0021DC  0260A821   ADDU S5, S3, ZERO
1668:                
1669:                      OPCODE_BEGIN(2E)  /* ROL $nnnn */
1670:                         ROL(6, ABSOLUTE, mem_writebyte, addr);
9D002224  26120002   ADDIU S2, S0, 2
9D002228  0F400000   JAL mem_readbyte
9D00222C  02A02021   ADDU A0, S5, ZERO
9D002230  7C4439C0   EXT A0, V0, 7, 8
9D002234  AFA4002C   SW A0, 44(SP)
9D002238  00021040   SLL V0, V0, 1
9D00223C  00579825   OR S3, V0, S7
9D002240  327300FF   ANDI S3, S3, 255
9D002244  02A02021   ADDU A0, S5, ZERO
9D002248  0F400036   JAL mem_writebyte
9D00224C  02602821   ADDU A1, S3, ZERO
9D002250  8F828058   LW V0, -32680(GP)
9D002254  2442FFFA   ADDIU V0, V0, -6
9D002258  AF828058   SW V0, -32680(GP)
9D00225C  8E230054   LW V1, 84(S1)
9D002260  24630006   ADDIU V1, V1, 6
9D00226C  8FB7002C   LW S7, 44(SP)
9D002270  0B4027B2   J .L45
9D002274  0260A821   ADDU S5, S3, ZERO
9D0022A4  8FB7002C   LW S7, 44(SP)
1671:                         OPCODE_END
9D002264  1C400004   BGTZ V0, 0x9D002278
9D002268  AE230054   SW V1, 84(S1)
9D002278  26100003   ADDIU S0, S0, 3
9D002294  90420000   LBU V0, 0(V0)
9D002298  00021080   SLL V0, V0, 2
9D00229C  00561021   ADDU V0, V0, S6
9D0022A0  8C420000   LW V0, 0(V0)
9D0022A8  0B400152   J 0x9D000548
9D0022AC  0260A821   ADDU S5, S3, ZERO
1672:                
1673:                      OPCODE_BEGIN(2F)  /* RLA $nnnn */
1674:                         RLA(6, ABSOLUTE, mem_writebyte, addr);
9D0022F4  26120002   ADDIU S2, S0, 2
9D0022F8  0F400000   JAL mem_readbyte
9D0022FC  02A02021   ADDU A0, S5, ZERO
9D002300  7C4539C0   EXT A1, V0, 7, 8
9D002304  AFA5002C   SW A1, 44(SP)
9D002308  00021040   SLL V0, V0, 1
9D00230C  00579825   OR S3, V0, S7
9D002310  327300FF   ANDI S3, S3, 255
9D002314  02A02021   ADDU A0, S5, ZERO
9D002318  0F400036   JAL mem_writebyte
9D00231C  02602821   ADDU A1, S3, ZERO
9D002320  02749824   AND S3, S3, S4
9D002324  8F828058   LW V0, -32680(GP)
9D002328  2442FFFA   ADDIU V0, V0, -6
9D00232C  AF828058   SW V0, -32680(GP)
9D002330  8E230054   LW V1, 84(S1)
9D002334  24630006   ADDIU V1, V1, 6
9D002340  0260A021   ADDU S4, S3, ZERO
9D002344  8FB7002C   LW S7, 44(SP)
9D002348  0B4027B2   J .L45
9D00234C  0260A821   ADDU S5, S3, ZERO
9D00237C  0260A021   ADDU S4, S3, ZERO
9D002380  8FB7002C   LW S7, 44(SP)
1675:                         OPCODE_END
9D002338  1C400005   BGTZ V0, 0x9D002350
9D00233C  AE230054   SW V1, 84(S1)
9D002350  26100003   ADDIU S0, S0, 3
9D00236C  90420000   LBU V0, 0(V0)
9D002370  00021080   SLL V0, V0, 2
9D002374  00561021   ADDU V0, V0, S6
9D002378  8C420000   LW V0, 0(V0)
9D002384  0B400152   J 0x9D000548
9D002388  0260A821   ADDU S5, S3, ZERO
1676:                
1677:                      OPCODE_BEGIN(30)  /* BMI $nnnn */
1678:                         BMI();
9D00238C  7C131420   SEB V0, S3
9D002390  0441001B   BGEZ V0, 0x9D002400
9D002394  26120001   ADDIU S2, S0, 1
9D002398  26020001   ADDIU V0, S0, 1
9D0023B4  80720000   LB S2, 0(V1)
9D0023B8  304300FF   ANDI V1, V0, 255
9D0023BC  02431821   ADDU V1, S2, V1
9D0023C0  30630100   ANDI V1, V1, 256
9D0023C4  10600007   BEQ V1, ZERO, 0x9D0023E4
9D0023C8  8F838058   LW V1, -32680(GP)
9D0023CC  2463FFFF   ADDIU V1, V1, -1
9D0023D0  AF838058   SW V1, -32680(GP)
9D0023D4  8E230054   LW V1, 84(S1)
9D0023D8  24630001   ADDIU V1, V1, 1
9D0023DC  AE230054   SW V1, 84(S1)
9D0023E0  8F838058   LW V1, -32680(GP)
9D0023E4  2463FFFD   ADDIU V1, V1, -3
9D0023E8  AF838058   SW V1, -32680(GP)
9D0023EC  8E230054   LW V1, 84(S1)
9D0023F0  24630003   ADDIU V1, V1, 3
9D0023F4  AE230054   SW V1, 84(S1)
9D0023F8  0B400906   J 0x9D002418
9D0023FC  02429021   ADDU S2, S2, V0
9D002400  8F828058   LW V0, -32680(GP)
9D002404  2442FFFE   ADDIU V0, V0, -2
9D002408  AF828058   SW V0, -32680(GP)
9D00240C  8E220054   LW V0, 84(S1)
9D002410  24420002   ADDIU V0, V0, 2
9D002414  AE220054   SW V0, 84(S1)
1679:                         OPCODE_END
9D002418  8F828058   LW V0, -32680(GP)
9D00241C  18401EAA   BLEZ V0, .L45
9D002420  26500001   ADDIU S0, S2, 1
9D00243C  90420000   LBU V0, 0(V0)
9D002440  00021080   SLL V0, V0, 2
9D002444  00561021   ADDU V0, V0, S6
9D002448  0B400152   J 0x9D000548
9D00244C  8C420000   LW V0, 0(V0)
1680:                
1681:                      OPCODE_BEGIN(31)  /* AND ($nn),Y */
1682:                         AND(5, INDIR_Y_BYTE_READ);
9D002484  8FA60010   LW A2, 16(SP)
9D002488  00862021   ADDU A0, A0, A2
9D00248C  3084FFFF   ANDI A0, A0, -1
9D002490  308200FF   ANDI V0, A0, 255
9D002494  0046102B   SLTU V0, V0, A2
9D002498  10400007   BEQ V0, ZERO, 0x9D0024B8
9D00249C  26120001   ADDIU S2, S0, 1
9D0024A0  8F828058   LW V0, -32680(GP)
9D0024A4  2442FFFF   ADDIU V0, V0, -1
9D0024A8  AF828058   SW V0, -32680(GP)
9D0024AC  8E220054   LW V0, 84(S1)
9D0024B0  24420001   ADDIU V0, V0, 1
9D0024B4  AE220054   SW V0, 84(S1)
9D0024B8  0F400000   JAL mem_readbyte
9D0024BC  00000000   NOP
9D0024C0  00541024   AND V0, V0, S4
9D0024C4  305300FF   ANDI S3, V0, 255
9D0024C8  8F828058   LW V0, -32680(GP)
9D0024CC  2442FFFB   ADDIU V0, V0, -5
9D0024D0  AF828058   SW V0, -32680(GP)
9D0024D4  8E230054   LW V1, 84(S1)
9D0024D8  24630005   ADDIU V1, V1, 5
9D0024E4  0260A021   ADDU S4, S3, ZERO
9D0024E8  0B4027B2   J .L45
9D0024EC  0260A821   ADDU S5, S3, ZERO
9D00251C  0260A021   ADDU S4, S3, ZERO
1683:                         OPCODE_END
9D0024DC  1C400004   BGTZ V0, 0x9D0024F0
9D0024E0  AE230054   SW V1, 84(S1)
9D0024F0  26100002   ADDIU S0, S0, 2
9D00250C  90420000   LBU V0, 0(V0)
9D002510  00021080   SLL V0, V0, 2
9D002514  00561021   ADDU V0, V0, S6
9D002518  8C420000   LW V0, 0(V0)
9D002520  0B400152   J 0x9D000548
9D002524  0260A821   ADDU S5, S3, ZERO
1684:                
1685:                      OPCODE_BEGIN(33)  /* RLA ($nn),Y */
1686:                         RLA(8, INDIR_Y, mem_writebyte, addr);
9D002528  26120001   ADDIU S2, S0, 1
9D002560  8FA70010   LW A3, 16(SP)
9D002564  02A7A821   ADDU S5, S5, A3
9D002568  32B5FFFF   ANDI S5, S5, -1
9D00256C  0F400000   JAL mem_readbyte
9D002570  02A02021   ADDU A0, S5, ZERO
9D002574  7C4839C0   EXT T0, V0, 7, 8
9D002578  AFA8002C   SW T0, 44(SP)
9D00257C  00021040   SLL V0, V0, 1
9D002580  00579825   OR S3, V0, S7
9D002584  327300FF   ANDI S3, S3, 255
9D002588  02A02021   ADDU A0, S5, ZERO
9D00258C  0F400036   JAL mem_writebyte
9D002590  02602821   ADDU A1, S3, ZERO
9D002594  02749824   AND S3, S3, S4
9D002598  8F828058   LW V0, -32680(GP)
9D00259C  2442FFF8   ADDIU V0, V0, -8
9D0025A0  AF828058   SW V0, -32680(GP)
9D0025A4  8E230054   LW V1, 84(S1)
9D0025A8  24630008   ADDIU V1, V1, 8
9D0025B4  0260A021   ADDU S4, S3, ZERO
9D0025B8  8FB7002C   LW S7, 44(SP)
9D0025BC  0B4027B2   J .L45
9D0025C0  0260A821   ADDU S5, S3, ZERO
9D0025F0  0260A021   ADDU S4, S3, ZERO
9D0025F4  8FB7002C   LW S7, 44(SP)
1687:                         OPCODE_END
9D0025AC  1C400005   BGTZ V0, 0x9D0025C4
9D0025B0  AE230054   SW V1, 84(S1)
9D0025C4  26100002   ADDIU S0, S0, 2
9D0025E0  90420000   LBU V0, 0(V0)
9D0025E4  00021080   SLL V0, V0, 2
9D0025E8  00561021   ADDU V0, V0, S6
9D0025EC  8C420000   LW V0, 0(V0)
9D0025F8  0B400152   J 0x9D000548
9D0025FC  0260A821   ADDU S5, S3, ZERO
1688:                
1689:                      OPCODE_BEGIN(35)  /* AND $nn,X */
1690:                         AND(4, ZP_IND_X_BYTE);
9D002600  26120001   ADDIU S2, S0, 1
9D00261C  90420000   LBU V0, 0(V0)
9D002620  03C21021   ADDU V0, FP, V0
9D002624  304200FF   ANDI V0, V0, 255
9D002628  8F838054   LW V1, -32684(GP)
9D00262C  00621021   ADDU V0, V1, V0
9D002630  90530000   LBU S3, 0(V0)
9D002634  02749824   AND S3, S3, S4
9D002638  8F828058   LW V0, -32680(GP)
9D00263C  2442FFFC   ADDIU V0, V0, -4
9D002640  AF828058   SW V0, -32680(GP)
9D002644  8E230054   LW V1, 84(S1)
9D002648  24630004   ADDIU V1, V1, 4
9D002654  0260A021   ADDU S4, S3, ZERO
9D002658  0B4027B2   J .L45
9D00265C  0260A821   ADDU S5, S3, ZERO
9D00268C  0260A021   ADDU S4, S3, ZERO
1691:                         OPCODE_END
9D00264C  1C400004   BGTZ V0, 0x9D002660
9D002650  AE230054   SW V1, 84(S1)
9D002660  26100002   ADDIU S0, S0, 2
9D00267C  90420000   LBU V0, 0(V0)
9D002680  00021080   SLL V0, V0, 2
9D002684  00561021   ADDU V0, V0, S6
9D002688  8C420000   LW V0, 0(V0)
9D002690  0B400152   J 0x9D000548
9D002694  0260A821   ADDU S5, S3, ZERO
1692:                
1693:                      OPCODE_BEGIN(36)  /* ROL $nn,X */
1694:                         ROL(6, ZP_IND_X, ZP_WRITEBYTE, baddr);
9D002698  26120001   ADDIU S2, S0, 1
9D0026B4  90420000   LBU V0, 0(V0)
9D0026B8  03C21021   ADDU V0, FP, V0
9D0026BC  304200FF   ANDI V0, V0, 255
9D0026C0  8F838054   LW V1, -32684(GP)
9D0026C4  00621021   ADDU V0, V1, V0
9D0026C8  90430000   LBU V1, 0(V0)
9D0026CC  000321C2   SRL A0, V1, 7
9D0026D0  00031840   SLL V1, V1, 1
9D0026D4  00779825   OR S3, V1, S7
9D0026D8  327300FF   ANDI S3, S3, 255
9D0026DC  A0530000   SB S3, 0(V0)
9D0026E0  8F828058   LW V0, -32680(GP)
9D0026E4  2442FFFA   ADDIU V0, V0, -6
9D0026E8  AF828058   SW V0, -32680(GP)
9D0026EC  8E230054   LW V1, 84(S1)
9D0026F0  24630006   ADDIU V1, V1, 6
9D0026FC  0080B821   ADDU S7, A0, ZERO
9D002700  0B4027B2   J .L45
9D002704  0260A821   ADDU S5, S3, ZERO
9D002734  0080B821   ADDU S7, A0, ZERO
1695:                         OPCODE_END
9D0026F4  1C400004   BGTZ V0, 0x9D002708
9D0026F8  AE230054   SW V1, 84(S1)
9D002708  26100002   ADDIU S0, S0, 2
9D002724  90420000   LBU V0, 0(V0)
9D002728  00021080   SLL V0, V0, 2
9D00272C  00561021   ADDU V0, V0, S6
9D002730  8C420000   LW V0, 0(V0)
9D002738  0B400152   J 0x9D000548
9D00273C  0260A821   ADDU S5, S3, ZERO
1696:                
1697:                      OPCODE_BEGIN(37)  /* RLA $nn,X */
1698:                         RLA(6, ZP_IND_X, ZP_WRITEBYTE, baddr);
9D002740  26120001   ADDIU S2, S0, 1
9D00275C  90420000   LBU V0, 0(V0)
9D002760  03C21021   ADDU V0, FP, V0
9D002764  304200FF   ANDI V0, V0, 255
9D002768  8F838054   LW V1, -32684(GP)
9D00276C  00621021   ADDU V0, V1, V0
9D002770  90430000   LBU V1, 0(V0)
9D002774  000321C2   SRL A0, V1, 7
9D002778  00031840   SLL V1, V1, 1
9D00277C  00779825   OR S3, V1, S7
9D002780  327300FF   ANDI S3, S3, 255
9D002784  A0530000   SB S3, 0(V0)
9D002788  02749824   AND S3, S3, S4
9D00278C  8F828058   LW V0, -32680(GP)
9D002790  2442FFFA   ADDIU V0, V0, -6
9D002794  AF828058   SW V0, -32680(GP)
9D002798  8E230054   LW V1, 84(S1)
9D00279C  24630006   ADDIU V1, V1, 6
9D0027A8  0260A021   ADDU S4, S3, ZERO
9D0027AC  0080B821   ADDU S7, A0, ZERO
9D0027B0  0B4027B2   J .L45
9D0027B4  0260A821   ADDU S5, S3, ZERO
9D0027E4  0260A021   ADDU S4, S3, ZERO
9D0027E8  0080B821   ADDU S7, A0, ZERO
1699:                         OPCODE_END
9D0027A0  1C400005   BGTZ V0, 0x9D0027B8
9D0027A4  AE230054   SW V1, 84(S1)
9D0027B8  26100002   ADDIU S0, S0, 2
9D0027D4  90420000   LBU V0, 0(V0)
9D0027D8  00021080   SLL V0, V0, 2
9D0027DC  00561021   ADDU V0, V0, S6
9D0027E0  8C420000   LW V0, 0(V0)
9D0027EC  0B400152   J 0x9D000548
9D0027F0  0260A821   ADDU S5, S3, ZERO
1700:                
1701:                      OPCODE_BEGIN(38)  /* SEC */
1702:                         SEC();
9D0027F4  8F828058   LW V0, -32680(GP)
9D0027F8  2442FFFE   ADDIU V0, V0, -2
9D0027FC  AF828058   SW V0, -32680(GP)
9D002800  8E230054   LW V1, 84(S1)
9D002804  24630002   ADDIU V1, V1, 2
9D002814  0B4027B2   J .L45
9D002818  24170001   ADDIU S7, ZERO, 1
1703:                         OPCODE_END
9D002808  1C400004   BGTZ V0, .LBB1146
9D00280C  AE230054   SW V1, 84(S1)
9D002810  02009021   ADDU S2, S0, ZERO
9D002834  90420000   LBU V0, 0(V0)
9D002838  00021080   SLL V0, V0, 2
9D00283C  00561021   ADDU V0, V0, S6
9D002840  8C420000   LW V0, 0(V0)
9D002844  26100001   ADDIU S0, S0, 1
9D002848  0B400152   J 0x9D000548
9D00284C  24170001   ADDIU S7, ZERO, 1
1704:                
1705:                      OPCODE_BEGIN(39)  /* AND $nnnn,Y */
1706:                         AND(4, ABS_IND_Y_BYTE_READ);
9D002894  8FA20010   LW V0, 16(SP)
9D002898  00822021   ADDU A0, A0, V0
9D00289C  3084FFFF   ANDI A0, A0, -1
9D0028A0  308200FF   ANDI V0, A0, 255
9D0028A4  8FA30010   LW V1, 16(SP)
9D0028A8  0043102B   SLTU V0, V0, V1
9D0028AC  10400007   BEQ V0, ZERO, 0x9D0028CC
9D0028B0  26120002   ADDIU S2, S0, 2
9D0028B4  8F828058   LW V0, -32680(GP)
9D0028B8  2442FFFF   ADDIU V0, V0, -1
9D0028BC  AF828058   SW V0, -32680(GP)
9D0028C0  8E220054   LW V0, 84(S1)
9D0028C4  24420001   ADDIU V0, V0, 1
9D0028C8  AE220054   SW V0, 84(S1)
9D0028CC  0F400000   JAL mem_readbyte
9D0028D0  00000000   NOP
9D0028D4  00541024   AND V0, V0, S4
9D0028D8  305300FF   ANDI S3, V0, 255
9D0028DC  8F828058   LW V0, -32680(GP)
9D0028E0  2442FFFC   ADDIU V0, V0, -4
9D0028E4  AF828058   SW V0, -32680(GP)
9D0028E8  8E230054   LW V1, 84(S1)
9D0028EC  24630004   ADDIU V1, V1, 4
9D0028F8  0260A021   ADDU S4, S3, ZERO
9D0028FC  0B4027B2   J .L45
9D002900  0260A821   ADDU S5, S3, ZERO
9D002930  0260A021   ADDU S4, S3, ZERO
1707:                         OPCODE_END
9D0028F0  1C400004   BGTZ V0, 0x9D002904
9D0028F4  AE230054   SW V1, 84(S1)
9D002904  26100003   ADDIU S0, S0, 3
9D002920  90420000   LBU V0, 0(V0)
9D002924  00021080   SLL V0, V0, 2
9D002928  00561021   ADDU V0, V0, S6
9D00292C  8C420000   LW V0, 0(V0)
9D002934  0B400152   J 0x9D000548
9D002938  0260A821   ADDU S5, S3, ZERO
1708:                
1709:                      OPCODE_BEGIN(3B)  /* RLA $nnnn,Y */
1710:                         RLA(7, ABS_IND_Y, mem_writebyte, addr);
9D002940  26120002   ADDIU S2, S0, 2
9D002984  8FA40010   LW A0, 16(SP)
9D002988  02A4A821   ADDU S5, S5, A0
9D00298C  32B5FFFF   ANDI S5, S5, -1
9D002990  0F400000   JAL mem_readbyte
9D002994  02A02021   ADDU A0, S5, ZERO
9D002998  7C4539C0   EXT A1, V0, 7, 8
9D00299C  AFA5002C   SW A1, 44(SP)
9D0029A0  00021040   SLL V0, V0, 1
9D0029A4  00579825   OR S3, V0, S7
9D0029A8  327300FF   ANDI S3, S3, 255
9D0029AC  02A02021   ADDU A0, S5, ZERO
9D0029B0  0F400036   JAL mem_writebyte
9D0029B4  02602821   ADDU A1, S3, ZERO
9D0029B8  02749824   AND S3, S3, S4
9D0029BC  8F828058   LW V0, -32680(GP)
9D0029C0  2442FFF9   ADDIU V0, V0, -7
9D0029C4  AF828058   SW V0, -32680(GP)
9D0029C8  8E230054   LW V1, 84(S1)
9D0029CC  24630007   ADDIU V1, V1, 7
9D0029D8  0260A021   ADDU S4, S3, ZERO
9D0029DC  8FB7002C   LW S7, 44(SP)
9D0029E0  0B4027B2   J .L45
9D0029E4  0260A821   ADDU S5, S3, ZERO
9D002A14  0260A021   ADDU S4, S3, ZERO
9D002A18  8FB7002C   LW S7, 44(SP)
1711:                         OPCODE_END
9D0029D0  1C400005   BGTZ V0, 0x9D0029E8
9D0029D4  AE230054   SW V1, 84(S1)
9D0029E8  26100003   ADDIU S0, S0, 3
9D002A04  90420000   LBU V0, 0(V0)
9D002A08  00021080   SLL V0, V0, 2
9D002A0C  00561021   ADDU V0, V0, S6
9D002A10  8C420000   LW V0, 0(V0)
9D002A1C  0B400152   J 0x9D000548
9D002A20  0260A821   ADDU S5, S3, ZERO
1712:                
1713:                      OPCODE_BEGIN(3D)  /* AND $nnnn,X */
1714:                         AND(4, ABS_IND_X_BYTE_READ);
9D002A68  009E2021   ADDU A0, A0, FP
9D002A6C  3084FFFF   ANDI A0, A0, -1
9D002A70  308200FF   ANDI V0, A0, 255
9D002A74  005E102B   SLTU V0, V0, FP
9D002A78  10400007   BEQ V0, ZERO, 0x9D002A98
9D002A7C  26120002   ADDIU S2, S0, 2
9D002A80  8F828058   LW V0, -32680(GP)
9D002A84  2442FFFF   ADDIU V0, V0, -1
9D002A88  AF828058   SW V0, -32680(GP)
9D002A8C  8E220054   LW V0, 84(S1)
9D002A90  24420001   ADDIU V0, V0, 1
9D002A94  AE220054   SW V0, 84(S1)
9D002A98  0F400000   JAL mem_readbyte
9D002A9C  00000000   NOP
9D002AA0  00541024   AND V0, V0, S4
9D002AA4  305300FF   ANDI S3, V0, 255
9D002AA8  8F828058   LW V0, -32680(GP)
9D002AAC  2442FFFC   ADDIU V0, V0, -4
9D002AB0  AF828058   SW V0, -32680(GP)
9D002AB4  8E230054   LW V1, 84(S1)
9D002AB8  24630004   ADDIU V1, V1, 4
9D002AC4  0260A021   ADDU S4, S3, ZERO
9D002AC8  0B4027B2   J .L45
9D002ACC  0260A821   ADDU S5, S3, ZERO
9D002AFC  0260A021   ADDU S4, S3, ZERO
1715:                         OPCODE_END
9D002ABC  1C400004   BGTZ V0, 0x9D002AD0
9D002AC0  AE230054   SW V1, 84(S1)
9D002AD0  26100003   ADDIU S0, S0, 3
9D002AEC  90420000   LBU V0, 0(V0)
9D002AF0  00021080   SLL V0, V0, 2
9D002AF4  00561021   ADDU V0, V0, S6
9D002AF8  8C420000   LW V0, 0(V0)
9D002B00  0B400152   J 0x9D000548
9D002B04  0260A821   ADDU S5, S3, ZERO
1716:                
1717:                      OPCODE_BEGIN(3E)  /* ROL $nnnn,X */
1718:                         ROL(7, ABS_IND_X, mem_writebyte, addr);
9D002B0C  26120002   ADDIU S2, S0, 2
9D002B50  02BEA821   ADDU S5, S5, FP
9D002B54  32B5FFFF   ANDI S5, S5, -1
9D002B58  0F400000   JAL mem_readbyte
9D002B5C  02A02021   ADDU A0, S5, ZERO
9D002B60  7C4639C0   EXT A2, V0, 7, 8
9D002B64  AFA6002C   SW A2, 44(SP)
9D002B68  00021040   SLL V0, V0, 1
9D002B6C  00579825   OR S3, V0, S7
9D002B70  327300FF   ANDI S3, S3, 255
9D002B74  02A02021   ADDU A0, S5, ZERO
9D002B78  0F400036   JAL mem_writebyte
9D002B7C  02602821   ADDU A1, S3, ZERO
9D002B80  8F828058   LW V0, -32680(GP)
9D002B84  2442FFF9   ADDIU V0, V0, -7
9D002B88  AF828058   SW V0, -32680(GP)
9D002B8C  8E230054   LW V1, 84(S1)
9D002B90  24630007   ADDIU V1, V1, 7
9D002B9C  8FB7002C   LW S7, 44(SP)
9D002BA0  0B4027B2   J .L45
9D002BA4  0260A821   ADDU S5, S3, ZERO
9D002BD4  8FB7002C   LW S7, 44(SP)
1719:                         OPCODE_END
9D002B94  1C400004   BGTZ V0, 0x9D002BA8
9D002B98  AE230054   SW V1, 84(S1)
9D002BA8  26100003   ADDIU S0, S0, 3
9D002BC4  90420000   LBU V0, 0(V0)
9D002BC8  00021080   SLL V0, V0, 2
9D002BCC  00561021   ADDU V0, V0, S6
9D002BD0  8C420000   LW V0, 0(V0)
9D002BD8  0B400152   J 0x9D000548
9D002BDC  0260A821   ADDU S5, S3, ZERO
1720:                
1721:                      OPCODE_BEGIN(3F)  /* RLA $nnnn,X */
1722:                         RLA(7, ABS_IND_X, mem_writebyte, addr);
9D002BE4  26120002   ADDIU S2, S0, 2
9D002C28  02BEA821   ADDU S5, S5, FP
9D002C2C  32B5FFFF   ANDI S5, S5, -1
9D002C30  0F400000   JAL mem_readbyte
9D002C34  02A02021   ADDU A0, S5, ZERO
9D002C38  7C4739C0   EXT A3, V0, 7, 8
9D002C3C  AFA7002C   SW A3, 44(SP)
9D002C40  00021040   SLL V0, V0, 1
9D002C44  00579825   OR S3, V0, S7
9D002C48  327300FF   ANDI S3, S3, 255
9D002C4C  02A02021   ADDU A0, S5, ZERO
9D002C50  0F400036   JAL mem_writebyte
9D002C54  02602821   ADDU A1, S3, ZERO
9D002C58  02749824   AND S3, S3, S4
9D002C5C  8F828058   LW V0, -32680(GP)
9D002C60  2442FFF9   ADDIU V0, V0, -7
9D002C64  AF828058   SW V0, -32680(GP)
9D002C68  8E230054   LW V1, 84(S1)
9D002C6C  24630007   ADDIU V1, V1, 7
9D002C78  0260A021   ADDU S4, S3, ZERO
9D002C7C  8FB7002C   LW S7, 44(SP)
9D002C80  0B4027B2   J .L45
9D002C84  0260A821   ADDU S5, S3, ZERO
9D002CB4  0260A021   ADDU S4, S3, ZERO
9D002CB8  8FB7002C   LW S7, 44(SP)
1723:                         OPCODE_END
9D002C70  1C400005   BGTZ V0, 0x9D002C88
9D002C74  AE230054   SW V1, 84(S1)
9D002C88  26100003   ADDIU S0, S0, 3
9D002CA4  90420000   LBU V0, 0(V0)
9D002CA8  00021080   SLL V0, V0, 2
9D002CAC  00561021   ADDU V0, V0, S6
9D002CB0  8C420000   LW V0, 0(V0)
9D002CBC  0B400152   J 0x9D000548
9D002CC0  0260A821   ADDU S5, S3, ZERO
1724:                
1725:                      OPCODE_BEGIN(40)  /* RTI */
1726:                         RTI();
9D002CC4  8F828050   LW V0, -32688(GP)
9D002CC8  8FA80014   LW T0, 20(SP)
9D002CCC  25050001   ADDIU A1, T0, 1
9D002CD0  30A500FF   ANDI A1, A1, 255
9D002CD4  00452821   ADDU A1, V0, A1
9D002CD8  90B70000   LBU S7, 0(A1)
9D002CDC  32F30080   ANDI S3, S7, 128
9D002CE0  32E30040   ANDI V1, S7, 64
9D002CE4  306300FF   ANDI V1, V1, 255
9D002CE8  AFA30018   SW V1, 24(SP)
9D002CEC  32E30010   ANDI V1, S7, 16
9D002CF0  306300FF   ANDI V1, V1, 255
9D002CF4  AFA30028   SW V1, 40(SP)
9D002CF8  32E30008   ANDI V1, S7, 8
9D002CFC  306300FF   ANDI V1, V1, 255
9D002D00  AFA30020   SW V1, 32(SP)
9D002D04  32E30004   ANDI V1, S7, 4
9D002D08  306300FF   ANDI V1, V1, 255
9D002D0C  AFA3001C   SW V1, 28(SP)
9D002D10  3AF50002   XORI S5, S7, 2
9D002D14  7EB50040   EXT S5, S5, 1, 1
9D002D18  25060002   ADDIU A2, T0, 2
9D002D1C  30C600FF   ANDI A2, A2, 255
9D002D20  00463021   ADDU A2, V0, A2
9D002D24  90C40000   LBU A0, 0(A2)
9D002D28  25030003   ADDIU V1, T0, 3
9D002D2C  306300FF   ANDI V1, V1, 255
9D002D30  00431021   ADDU V0, V0, V1
9D002D34  90520000   LBU S2, 0(V0)
9D002D38  00129200   SLL S2, S2, 8
9D002D3C  02449025   OR S2, S2, A0
9D002D40  8F848058   LW A0, -32680(GP)
9D002D44  2487FFFA   ADDIU A3, A0, -6
9D002D48  AF878058   SW A3, -32680(GP)
9D002D4C  8E280054   LW T0, 84(S1)
9D002D50  25080006   ADDIU T0, T0, 6
9D002D54  AE280054   SW T0, 84(S1)
9D002D58  8FA8001C   LW T0, 28(SP)
9D002D5C  15000024   BNE T0, ZERO, 0x9D002DF0
9D002D60  32F70001   ANDI S7, S7, 1
9D002D64  92280052   LBU T0, 82(S1)
9D002D68  51000022   BEQL T0, ZERO, 0x9D002DF4
9D002D6C  8F828058   LW V0, -32680(GP)
9D002D70  18E0001F   BLEZ A3, 0x9D002DF0
9D002D74  2484FFF3   ADDIU A0, A0, -13
9D002D78  A2200052   SB ZERO, 82(S1)
9D002D7C  00121A02   SRL V1, S2, 8
9D002D80  A0430000   SB V1, 0(V0)
9D002D84  A0D20000   SB S2, 0(A2)
9D002D88  2402FF80   ADDIU V0, ZERO, -128
9D002D8C  02623024   AND A2, S3, V0
9D002D90  7C063420   SEB A2, A2
9D002D94  24030002   ADDIU V1, ZERO, 2
9D002D98  0015180B   MOVN V1, ZERO, S5
9D002D9C  36E20020   ORI V0, S7, 32
9D002DA0  00C21025   OR V0, A2, V0
9D002DA4  8FA60018   LW A2, 24(SP)
9D002DA8  00C21025   OR V0, A2, V0
9D002DAC  8FA70020   LW A3, 32(SP)
9D002DB0  00E21025   OR V0, A3, V0
9D002DB4  00621025   OR V0, V1, V0
9D002DB8  A0A20000   SB V0, 0(A1)
9D002DD0  AF848058   SW A0, -32680(GP)
9D002DD4  8E220054   LW V0, 84(S1)
9D002DD8  24420007   ADDIU V0, V0, 7
9D002DDC  AE220054   SW V0, 84(S1)
9D002DE0  8FA30014   LW V1, 20(SP)
9D002DE4  24080001   ADDIU T0, ZERO, 1
9D002DE8  AFA8001C   SW T0, 28(SP)
9D002DEC  AFA00028   SW ZERO, 40(SP)
1727:                         OPCODE_END
9D002DF0  8F828058   LW V0, -32680(GP)
9D002DF4  1C400003   BGTZ V0, .LBB1176
9D002DF8  26500001   ADDIU S0, S2, 1
9D002DFC  0B4027B2   J .L45
9D002E00  AFA30014   SW V1, 20(SP)
9D002E1C  90420000   LBU V0, 0(V0)
9D002E20  00021080   SLL V0, V0, 2
9D002E24  00561021   ADDU V0, V0, S6
9D002E28  8C420000   LW V0, 0(V0)
9D002E2C  0B400152   J 0x9D000548
9D002E30  AFA30014   SW V1, 20(SP)
1728:                
1729:                      OPCODE_BEGIN(41)  /* EOR ($nn,X) */
1730:                         EOR(6, INDIR_X_BYTE);
9D002E34  26120001   ADDIU S2, S0, 1
9D002E50  90420000   LBU V0, 0(V0)
9D002E54  03C21021   ADDU V0, FP, V0
9D002E70  0F400000   JAL mem_readbyte
9D002E74  308400FF   ANDI A0, A0, 255
9D002E78  00541026   XOR V0, V0, S4
9D002E7C  305300FF   ANDI S3, V0, 255
9D002E80  8F828058   LW V0, -32680(GP)
9D002E84  2442FFFA   ADDIU V0, V0, -6
9D002E88  AF828058   SW V0, -32680(GP)
9D002E8C  8E230054   LW V1, 84(S1)
9D002E90  24630006   ADDIU V1, V1, 6
9D002E9C  0260A021   ADDU S4, S3, ZERO
9D002EA0  0B4027B2   J .L45
9D002EA4  0260A821   ADDU S5, S3, ZERO
9D002ED4  0260A021   ADDU S4, S3, ZERO
1731:                         OPCODE_END
9D002E94  1C400004   BGTZ V0, 0x9D002EA8
9D002E98  AE230054   SW V1, 84(S1)
9D002EA8  26100002   ADDIU S0, S0, 2
9D002EC4  90420000   LBU V0, 0(V0)
9D002EC8  00021080   SLL V0, V0, 2
9D002ECC  00561021   ADDU V0, V0, S6
9D002ED0  8C420000   LW V0, 0(V0)
9D002ED8  0B400152   J 0x9D000548
9D002EDC  0260A821   ADDU S5, S3, ZERO
1732:                
1733:                      OPCODE_BEGIN(43)  /* SRE ($nn,X) */
1734:                         SRE(8, INDIR_X, mem_writebyte, addr);
9D002EE0  26120001   ADDIU S2, S0, 1
9D002EFC  90420000   LBU V0, 0(V0)
9D002F00  03C21021   ADDU V0, FP, V0
9D002F20  0F400000   JAL mem_readbyte
9D002F24  02A02021   ADDU A0, S5, ZERO
9D002F28  30570001   ANDI S7, V0, 1
9D002F2C  7C533840   EXT S3, V0, 1, 8
9D002F30  02A02021   ADDU A0, S5, ZERO
9D002F34  0F400036   JAL mem_writebyte
9D002F38  02602821   ADDU A1, S3, ZERO
9D002F3C  02749826   XOR S3, S3, S4
9D002F40  327300FF   ANDI S3, S3, 255
9D002F44  8F828058   LW V0, -32680(GP)
9D002F48  2442FFF8   ADDIU V0, V0, -8
9D002F4C  AF828058   SW V0, -32680(GP)
9D002F50  8E230054   LW V1, 84(S1)
9D002F54  24630008   ADDIU V1, V1, 8
9D002F60  0260A021   ADDU S4, S3, ZERO
9D002F64  0B4027B2   J .L45
9D002F68  0260A821   ADDU S5, S3, ZERO
9D002F98  0260A021   ADDU S4, S3, ZERO
1735:                         OPCODE_END
9D002F58  1C400004   BGTZ V0, 0x9D002F6C
9D002F5C  AE230054   SW V1, 84(S1)
9D002F6C  26100002   ADDIU S0, S0, 2
9D002F88  90420000   LBU V0, 0(V0)
9D002F8C  00021080   SLL V0, V0, 2
9D002F90  00561021   ADDU V0, V0, S6
9D002F94  8C420000   LW V0, 0(V0)
9D002F9C  0B400152   J 0x9D000548
9D002FA0  0260A821   ADDU S5, S3, ZERO
1736:                
1737:                      OPCODE_BEGIN(45)  /* EOR $nn */
1738:                         EOR(3, ZERO_PAGE_BYTE);
9D002FA4  26120001   ADDIU S2, S0, 1
9D002FC0  90420000   LBU V0, 0(V0)
9D002FC4  8F838054   LW V1, -32684(GP)
9D002FC8  00621021   ADDU V0, V1, V0
9D002FCC  90530000   LBU S3, 0(V0)
9D002FD0  02939826   XOR S3, S4, S3
9D002FD4  327300FF   ANDI S3, S3, 255
9D002FD8  8F828058   LW V0, -32680(GP)
9D002FDC  2442FFFD   ADDIU V0, V0, -3
9D002FE0  AF828058   SW V0, -32680(GP)
9D002FE4  8E230054   LW V1, 84(S1)
9D002FE8  24630003   ADDIU V1, V1, 3
9D002FF4  0260A021   ADDU S4, S3, ZERO
9D002FF8  0B4027B2   J .L45
9D002FFC  0260A821   ADDU S5, S3, ZERO
9D00302C  0260A021   ADDU S4, S3, ZERO
1739:                         OPCODE_END
9D002FEC  1C400004   BGTZ V0, 0x9D003000
9D002FF0  AE230054   SW V1, 84(S1)
9D003000  26100002   ADDIU S0, S0, 2
9D00301C  90420000   LBU V0, 0(V0)
9D003020  00021080   SLL V0, V0, 2
9D003024  00561021   ADDU V0, V0, S6
9D003028  8C420000   LW V0, 0(V0)
9D003030  0B400152   J 0x9D000548
9D003034  0260A821   ADDU S5, S3, ZERO
1740:                
1741:                      OPCODE_BEGIN(46)  /* LSR $nn */
1742:                         LSR(5, ZERO_PAGE, ZP_WRITEBYTE, baddr);
9D003038  26120001   ADDIU S2, S0, 1
9D003054  90420000   LBU V0, 0(V0)
9D003058  8F838054   LW V1, -32684(GP)
9D00305C  00621021   ADDU V0, V1, V0
9D003060  90530000   LBU S3, 0(V0)
9D003064  32770001   ANDI S7, S3, 1
9D003068  00139842   SRL S3, S3, 1
9D00306C  A0530000   SB S3, 0(V0)
9D003070  8F828058   LW V0, -32680(GP)
9D003074  2442FFFB   ADDIU V0, V0, -5
9D003078  AF828058   SW V0, -32680(GP)
9D00307C  8E230054   LW V1, 84(S1)
9D003080  24630005   ADDIU V1, V1, 5
9D00308C  0B4027B2   J .L45
9D003090  0260A821   ADDU S5, S3, ZERO
1743:                         OPCODE_END
9D003084  1C400003   BGTZ V0, 0x9D003094
9D003088  AE230054   SW V1, 84(S1)
9D003094  26100002   ADDIU S0, S0, 2
9D0030B0  90420000   LBU V0, 0(V0)
9D0030B4  00021080   SLL V0, V0, 2
9D0030B8  00561021   ADDU V0, V0, S6
9D0030BC  8C420000   LW V0, 0(V0)
9D0030C0  0B400152   J 0x9D000548
9D0030C4  0260A821   ADDU S5, S3, ZERO
1744:                
1745:                      OPCODE_BEGIN(47)  /* SRE $nn */
1746:                         SRE(5, ZERO_PAGE, ZP_WRITEBYTE, baddr);
9D0030C8  26120001   ADDIU S2, S0, 1
9D0030E4  90420000   LBU V0, 0(V0)
9D0030E8  8F838054   LW V1, -32684(GP)
9D0030EC  00621821   ADDU V1, V1, V0
9D0030F0  90620000   LBU V0, 0(V1)
9D0030F4  30570001   ANDI S7, V0, 1
9D0030F8  00021042   SRL V0, V0, 1
9D0030FC  A0620000   SB V0, 0(V1)
9D003100  00541026   XOR V0, V0, S4
9D003104  305300FF   ANDI S3, V0, 255
9D003108  8F828058   LW V0, -32680(GP)
9D00310C  2442FFFB   ADDIU V0, V0, -5
9D003110  AF828058   SW V0, -32680(GP)
9D003114  8E230054   LW V1, 84(S1)
9D003118  24630005   ADDIU V1, V1, 5
9D003124  0260A021   ADDU S4, S3, ZERO
9D003128  0B4027B2   J .L45
9D00312C  0260A821   ADDU S5, S3, ZERO
9D00315C  0260A021   ADDU S4, S3, ZERO
1747:                         OPCODE_END
9D00311C  1C400004   BGTZ V0, 0x9D003130
9D003120  AE230054   SW V1, 84(S1)
9D003130  26100002   ADDIU S0, S0, 2
9D00314C  90420000   LBU V0, 0(V0)
9D003150  00021080   SLL V0, V0, 2
9D003154  00561021   ADDU V0, V0, S6
9D003158  8C420000   LW V0, 0(V0)
9D003160  0B400152   J 0x9D000548
9D003164  0260A821   ADDU S5, S3, ZERO
1748:                
1749:                      OPCODE_BEGIN(48)  /* PHA */
1750:                         PHA();
9D003168  8FA20014   LW V0, 20(SP)
9D00316C  2443FFFF   ADDIU V1, V0, -1
9D003170  306300FF   ANDI V1, V1, 255
9D003174  8F828050   LW V0, -32688(GP)
9D003178  8FA40014   LW A0, 20(SP)
9D00317C  00441021   ADDU V0, V0, A0
9D003180  A0540000   SB S4, 0(V0)
9D003184  8F828058   LW V0, -32680(GP)
9D003188  2442FFFD   ADDIU V0, V0, -3
9D00318C  AF828058   SW V0, -32680(GP)
9D003190  8E240054   LW A0, 84(S1)
9D003194  24840003   ADDIU A0, A0, 3
9D0031A0  AFA30014   SW V1, 20(SP)
9D0031D4  AFA30014   SW V1, 20(SP)
1751:                         OPCODE_END
9D003198  1C400004   BGTZ V0, .LBB1202
9D00319C  AE240054   SW A0, 84(S1)
9D0031A4  0B4027B2   J .L45
9D0031A8  02009021   ADDU S2, S0, ZERO
9D0031C4  90420000   LBU V0, 0(V0)
9D0031C8  00021080   SLL V0, V0, 2
9D0031CC  00561021   ADDU V0, V0, S6
9D0031D0  8C420000   LW V0, 0(V0)
9D0031D8  0B400152   J 0x9D000548
9D0031DC  26100001   ADDIU S0, S0, 1
1752:                
1753:                      OPCODE_BEGIN(49)  /* EOR #$nn */
1754:                         EOR(2, IMMEDIATE_BYTE);
9D0031E0  26120001   ADDIU S2, S0, 1
9D0031FC  90530000   LBU S3, 0(V0)
9D003200  02939826   XOR S3, S4, S3
9D003204  327300FF   ANDI S3, S3, 255
9D003208  8F828058   LW V0, -32680(GP)
9D00320C  2442FFFE   ADDIU V0, V0, -2
9D003210  AF828058   SW V0, -32680(GP)
9D003214  8E230054   LW V1, 84(S1)
9D003218  24630002   ADDIU V1, V1, 2
9D003224  0260A021   ADDU S4, S3, ZERO
9D003228  0B4027B2   J .L45
9D00322C  0260A821   ADDU S5, S3, ZERO
9D00325C  0260A021   ADDU S4, S3, ZERO
1755:                         OPCODE_END
9D00321C  1C400004   BGTZ V0, 0x9D003230
9D003220  AE230054   SW V1, 84(S1)
9D003230  26100002   ADDIU S0, S0, 2
9D00324C  90420000   LBU V0, 0(V0)
9D003250  00021080   SLL V0, V0, 2
9D003254  00561021   ADDU V0, V0, S6
9D003258  8C420000   LW V0, 0(V0)
9D003260  0B400152   J 0x9D000548
9D003264  0260A821   ADDU S5, S3, ZERO
1756:                
1757:                      OPCODE_BEGIN(4A)  /* LSR A */
1758:                         LSR_A();
9D003268  32970001   ANDI S7, S4, 1
9D00326C  7E933840   EXT S3, S4, 1, 8
9D003270  8F828058   LW V0, -32680(GP)
9D003274  2442FFFE   ADDIU V0, V0, -2
9D003278  AF828058   SW V0, -32680(GP)
9D00327C  8E230054   LW V1, 84(S1)
9D003280  24630002   ADDIU V1, V1, 2
9D00328C  0260A021   ADDU S4, S3, ZERO
9D003294  0B4027B2   J .L45
9D003298  0260A821   ADDU S5, S3, ZERO
9D0032C4  0260A021   ADDU S4, S3, ZERO
1759:                         OPCODE_END
9D003284  1C400005   BGTZ V0, .LBB1208
9D003288  AE230054   SW V1, 84(S1)
9D003290  02009021   ADDU S2, S0, ZERO
9D0032B4  90420000   LBU V0, 0(V0)
9D0032B8  00021080   SLL V0, V0, 2
9D0032BC  00561021   ADDU V0, V0, S6
9D0032C0  8C420000   LW V0, 0(V0)
9D0032C8  26100001   ADDIU S0, S0, 1
9D0032CC  0B400152   J 0x9D000548
9D0032D0  0260A821   ADDU S5, S3, ZERO
1760:                
1761:                      OPCODE_BEGIN(4B)  /* ASR #$nn */
1762:                         ASR(2, IMMEDIATE_BYTE);
9D0032D4  26120001   ADDIU S2, S0, 1
9D0032F0  90530000   LBU S3, 0(V0)
9D0032F4  02939824   AND S3, S4, S3
9D0032F8  32770001   ANDI S7, S3, 1
9D0032FC  00139842   SRL S3, S3, 1
9D003300  8F828058   LW V0, -32680(GP)
9D003304  2442FFFE   ADDIU V0, V0, -2
9D003308  AF828058   SW V0, -32680(GP)
9D00330C  8E230054   LW V1, 84(S1)
9D003310  24630002   ADDIU V1, V1, 2
9D00331C  0260A021   ADDU S4, S3, ZERO
9D003320  0B4027B2   J .L45
9D003324  0260A821   ADDU S5, S3, ZERO
9D003354  0260A021   ADDU S4, S3, ZERO
1763:                         OPCODE_END
9D003314  1C400004   BGTZ V0, 0x9D003328
9D003318  AE230054   SW V1, 84(S1)
9D003328  26100002   ADDIU S0, S0, 2
9D003344  90420000   LBU V0, 0(V0)
9D003348  00021080   SLL V0, V0, 2
9D00334C  00561021   ADDU V0, V0, S6
9D003350  8C420000   LW V0, 0(V0)
9D003358  0B400152   J 0x9D000548
9D00335C  0260A821   ADDU S5, S3, ZERO
1764:                
1765:                      OPCODE_BEGIN(4C)  /* JMP $nnnn */
1766:                         JMP_ABSOLUTE();
9D0033A4  8F828058   LW V0, -32680(GP)
9D0033A8  2442FFFD   ADDIU V0, V0, -3
9D0033AC  AF828058   SW V0, -32680(GP)
9D0033B0  8E230054   LW V1, 84(S1)
9D0033B4  24630003   ADDIU V1, V1, 3
1767:                         OPCODE_END
9D0033B8  18401AC3   BLEZ V0, .L45
9D0033BC  AE230054   SW V1, 84(S1)
9D0033C0  26500001   ADDIU S0, S2, 1
9D0033CC  92420000   LBU V0, 0(S2)
9D0033D0  00021080   SLL V0, V0, 2
9D0033D4  00561021   ADDU V0, V0, S6
9D0033D8  0B400152   J 0x9D000548
9D0033DC  8C420000   LW V0, 0(V0)
1768:                
1769:                      OPCODE_BEGIN(4D)  /* EOR $nnnn */
1770:                         EOR(4, ABSOLUTE_BYTE);
9D0033E4  26120002   ADDIU S2, S0, 2
9D003424  0F400000   JAL mem_readbyte
9D003428  308400FF   ANDI A0, A0, 255
9D00342C  00541026   XOR V0, V0, S4
9D003430  305300FF   ANDI S3, V0, 255
9D003434  8F828058   LW V0, -32680(GP)
9D003438  2442FFFC   ADDIU V0, V0, -4
9D00343C  AF828058   SW V0, -32680(GP)
9D003440  8E230054   LW V1, 84(S1)
9D003444  24630004   ADDIU V1, V1, 4
9D003450  0260A021   ADDU S4, S3, ZERO
9D003454  0B4027B2   J .L45
9D003458  0260A821   ADDU S5, S3, ZERO
9D003488  0260A021   ADDU S4, S3, ZERO
1771:                         OPCODE_END
9D003448  1C400004   BGTZ V0, 0x9D00345C
9D00344C  AE230054   SW V1, 84(S1)
9D00345C  26100003   ADDIU S0, S0, 3
9D003478  90420000   LBU V0, 0(V0)
9D00347C  00021080   SLL V0, V0, 2
9D003480  00561021   ADDU V0, V0, S6
9D003484  8C420000   LW V0, 0(V0)
9D00348C  0B400152   J 0x9D000548
9D003490  0260A821   ADDU S5, S3, ZERO
1772:                
1773:                      OPCODE_BEGIN(4E)  /* LSR $nnnn */
1774:                         LSR(6, ABSOLUTE, mem_writebyte, addr);
9D0034D8  26120002   ADDIU S2, S0, 2
9D0034DC  0F400000   JAL mem_readbyte
9D0034E0  02A02021   ADDU A0, S5, ZERO
9D0034E4  30570001   ANDI S7, V0, 1
9D0034E8  7C533840   EXT S3, V0, 1, 8
9D0034EC  02A02021   ADDU A0, S5, ZERO
9D0034F0  0F400036   JAL mem_writebyte
9D0034F4  02602821   ADDU A1, S3, ZERO
9D0034F8  8F828058   LW V0, -32680(GP)
9D0034FC  2442FFFA   ADDIU V0, V0, -6
9D003500  AF828058   SW V0, -32680(GP)
9D003504  8E230054   LW V1, 84(S1)
9D003508  24630006   ADDIU V1, V1, 6
9D003514  0B4027B2   J .L45
9D003518  0260A821   ADDU S5, S3, ZERO
1775:                         OPCODE_END
9D00350C  1C400003   BGTZ V0, 0x9D00351C
9D003510  AE230054   SW V1, 84(S1)
9D00351C  26100003   ADDIU S0, S0, 3
9D003538  90420000   LBU V0, 0(V0)
9D00353C  00021080   SLL V0, V0, 2
9D003540  00561021   ADDU V0, V0, S6
9D003544  8C420000   LW V0, 0(V0)
9D003548  0B400152   J 0x9D000548
9D00354C  0260A821   ADDU S5, S3, ZERO
1776:                
1777:                      OPCODE_BEGIN(4F)  /* SRE $nnnn */
1778:                         SRE(6, ABSOLUTE, mem_writebyte, addr);
9D003594  26120002   ADDIU S2, S0, 2
9D003598  0F400000   JAL mem_readbyte
9D00359C  02A02021   ADDU A0, S5, ZERO
9D0035A0  30570001   ANDI S7, V0, 1
9D0035A4  7C533840   EXT S3, V0, 1, 8
9D0035A8  02A02021   ADDU A0, S5, ZERO
9D0035AC  0F400036   JAL mem_writebyte
9D0035B0  02602821   ADDU A1, S3, ZERO
9D0035B4  02749826   XOR S3, S3, S4
9D0035B8  327300FF   ANDI S3, S3, 255
9D0035BC  8F828058   LW V0, -32680(GP)
9D0035C0  2442FFFA   ADDIU V0, V0, -6
9D0035C4  AF828058   SW V0, -32680(GP)
9D0035C8  8E230054   LW V1, 84(S1)
9D0035CC  24630006   ADDIU V1, V1, 6
9D0035D8  0260A021   ADDU S4, S3, ZERO
9D0035DC  0B4027B2   J .L45
9D0035E0  0260A821   ADDU S5, S3, ZERO
9D003610  0260A021   ADDU S4, S3, ZERO
1779:                         OPCODE_END
9D0035D0  1C400004   BGTZ V0, 0x9D0035E4
9D0035D4  AE230054   SW V1, 84(S1)
9D0035E4  26100003   ADDIU S0, S0, 3
9D003600  90420000   LBU V0, 0(V0)
9D003604  00021080   SLL V0, V0, 2
9D003608  00561021   ADDU V0, V0, S6
9D00360C  8C420000   LW V0, 0(V0)
9D003614  0B400152   J 0x9D000548
9D003618  0260A821   ADDU S5, S3, ZERO
1780:                
1781:                      OPCODE_BEGIN(50)  /* BVC $nnnn */
1782:                         BVC();
9D00361C  8FA50018   LW A1, 24(SP)
9D003620  14A0001B   BNE A1, ZERO, 0x9D003690
9D003624  26120001   ADDIU S2, S0, 1
9D003628  26020001   ADDIU V0, S0, 1
9D003644  80720000   LB S2, 0(V1)
9D003648  304300FF   ANDI V1, V0, 255
9D00364C  02431821   ADDU V1, S2, V1
9D003650  30630100   ANDI V1, V1, 256
9D003654  10600007   BEQ V1, ZERO, 0x9D003674
9D003658  8F838058   LW V1, -32680(GP)
9D00365C  2463FFFF   ADDIU V1, V1, -1
9D003660  AF838058   SW V1, -32680(GP)
9D003664  8E230054   LW V1, 84(S1)
9D003668  24630001   ADDIU V1, V1, 1
9D00366C  AE230054   SW V1, 84(S1)
9D003670  8F838058   LW V1, -32680(GP)
9D003674  2463FFFD   ADDIU V1, V1, -3
9D003678  AF838058   SW V1, -32680(GP)
9D00367C  8E230054   LW V1, 84(S1)
9D003680  24630003   ADDIU V1, V1, 3
9D003684  AE230054   SW V1, 84(S1)
9D003688  0B400DAA   J 0x9D0036A8
9D00368C  02429021   ADDU S2, S2, V0
9D003690  8F828058   LW V0, -32680(GP)
9D003694  2442FFFE   ADDIU V0, V0, -2
9D003698  AF828058   SW V0, -32680(GP)
9D00369C  8E220054   LW V0, 84(S1)
9D0036A0  24420002   ADDIU V0, V0, 2
9D0036A4  AE220054   SW V0, 84(S1)
1783:                         OPCODE_END
9D0036A8  8F828058   LW V0, -32680(GP)
9D0036AC  18401A06   BLEZ V0, .L45
9D0036B0  26500001   ADDIU S0, S2, 1
9D0036CC  90420000   LBU V0, 0(V0)
9D0036D0  00021080   SLL V0, V0, 2
9D0036D4  00561021   ADDU V0, V0, S6
9D0036D8  0B400152   J 0x9D000548
9D0036DC  8C420000   LW V0, 0(V0)
1784:                
1785:                      OPCODE_BEGIN(51)  /* EOR ($nn),Y */
1786:                         EOR(5, INDIR_Y_BYTE_READ);
9D003714  8FA60010   LW A2, 16(SP)
9D003718  00862021   ADDU A0, A0, A2
9D00371C  3084FFFF   ANDI A0, A0, -1
9D003720  308200FF   ANDI V0, A0, 255
9D003724  0046102B   SLTU V0, V0, A2
9D003728  10400007   BEQ V0, ZERO, 0x9D003748
9D00372C  26120001   ADDIU S2, S0, 1
9D003730  8F828058   LW V0, -32680(GP)
9D003734  2442FFFF   ADDIU V0, V0, -1
9D003738  AF828058   SW V0, -32680(GP)
9D00373C  8E220054   LW V0, 84(S1)
9D003740  24420001   ADDIU V0, V0, 1
9D003744  AE220054   SW V0, 84(S1)
9D003748  0F400000   JAL mem_readbyte
9D00374C  00000000   NOP
9D003750  00541026   XOR V0, V0, S4
9D003754  305300FF   ANDI S3, V0, 255
9D003758  8F828058   LW V0, -32680(GP)
9D00375C  2442FFFB   ADDIU V0, V0, -5
9D003760  AF828058   SW V0, -32680(GP)
9D003764  8E230054   LW V1, 84(S1)
9D003768  24630005   ADDIU V1, V1, 5
9D003774  0260A021   ADDU S4, S3, ZERO
9D003778  0B4027B2   J .L45
9D00377C  0260A821   ADDU S5, S3, ZERO
9D0037AC  0260A021   ADDU S4, S3, ZERO
1787:                         OPCODE_END
9D00376C  1C400004   BGTZ V0, 0x9D003780
9D003770  AE230054   SW V1, 84(S1)
9D003780  26100002   ADDIU S0, S0, 2
9D00379C  90420000   LBU V0, 0(V0)
9D0037A0  00021080   SLL V0, V0, 2
9D0037A4  00561021   ADDU V0, V0, S6
9D0037A8  8C420000   LW V0, 0(V0)
9D0037B0  0B400152   J 0x9D000548
9D0037B4  0260A821   ADDU S5, S3, ZERO
1788:                
1789:                      OPCODE_BEGIN(53)  /* SRE ($nn),Y */
1790:                         SRE(8, INDIR_Y, mem_writebyte, addr);
9D0037B8  26120001   ADDIU S2, S0, 1
9D0037F0  8FA70010   LW A3, 16(SP)
9D0037F4  02A7A821   ADDU S5, S5, A3
9D0037F8  32B5FFFF   ANDI S5, S5, -1
9D0037FC  0F400000   JAL mem_readbyte
9D003800  02A02021   ADDU A0, S5, ZERO
9D003804  30570001   ANDI S7, V0, 1
9D003808  7C533840   EXT S3, V0, 1, 8
9D00380C  02A02021   ADDU A0, S5, ZERO
9D003810  0F400036   JAL mem_writebyte
9D003814  02602821   ADDU A1, S3, ZERO
9D003818  02749826   XOR S3, S3, S4
9D00381C  327300FF   ANDI S3, S3, 255
9D003820  8F828058   LW V0, -32680(GP)
9D003824  2442FFF8   ADDIU V0, V0, -8
9D003828  AF828058   SW V0, -32680(GP)
9D00382C  8E230054   LW V1, 84(S1)
9D003830  24630008   ADDIU V1, V1, 8
9D00383C  0260A021   ADDU S4, S3, ZERO
9D003840  0B4027B2   J .L45
9D003844  0260A821   ADDU S5, S3, ZERO
9D003874  0260A021   ADDU S4, S3, ZERO
1791:                         OPCODE_END
9D003834  1C400004   BGTZ V0, 0x9D003848
9D003838  AE230054   SW V1, 84(S1)
9D003848  26100002   ADDIU S0, S0, 2
9D003864  90420000   LBU V0, 0(V0)
9D003868  00021080   SLL V0, V0, 2
9D00386C  00561021   ADDU V0, V0, S6
9D003870  8C420000   LW V0, 0(V0)
9D003878  0B400152   J 0x9D000548
9D00387C  0260A821   ADDU S5, S3, ZERO
1792:                
1793:                      OPCODE_BEGIN(55)  /* EOR $nn,X */
1794:                         EOR(4, ZP_IND_X_BYTE);
9D003880  26120001   ADDIU S2, S0, 1
9D00389C  90420000   LBU V0, 0(V0)
9D0038A0  03C21021   ADDU V0, FP, V0
9D0038A4  304200FF   ANDI V0, V0, 255
9D0038A8  8F838054   LW V1, -32684(GP)
9D0038AC  00621021   ADDU V0, V1, V0
9D0038B0  90530000   LBU S3, 0(V0)
9D0038B4  02749826   XOR S3, S3, S4
9D0038B8  327300FF   ANDI S3, S3, 255
9D0038BC  8F828058   LW V0, -32680(GP)
9D0038C0  2442FFFC   ADDIU V0, V0, -4
9D0038C4  AF828058   SW V0, -32680(GP)
9D0038C8  8E230054   LW V1, 84(S1)
9D0038CC  24630004   ADDIU V1, V1, 4
9D0038D8  0260A021   ADDU S4, S3, ZERO
9D0038DC  0B4027B2   J .L45
9D0038E0  0260A821   ADDU S5, S3, ZERO
9D003910  0260A021   ADDU S4, S3, ZERO
1795:                         OPCODE_END
9D0038D0  1C400004   BGTZ V0, 0x9D0038E4
9D0038D4  AE230054   SW V1, 84(S1)
9D0038E4  26100002   ADDIU S0, S0, 2
9D003900  90420000   LBU V0, 0(V0)
9D003904  00021080   SLL V0, V0, 2
9D003908  00561021   ADDU V0, V0, S6
9D00390C  8C420000   LW V0, 0(V0)
9D003914  0B400152   J 0x9D000548
9D003918  0260A821   ADDU S5, S3, ZERO
1796:                
1797:                      OPCODE_BEGIN(56)  /* LSR $nn,X */
1798:                         LSR(6, ZP_IND_X, ZP_WRITEBYTE, baddr);
9D00391C  26120001   ADDIU S2, S0, 1
9D003938  90420000   LBU V0, 0(V0)
9D00393C  03C21021   ADDU V0, FP, V0
9D003940  304200FF   ANDI V0, V0, 255
9D003944  8F838054   LW V1, -32684(GP)
9D003948  00621021   ADDU V0, V1, V0
9D00394C  90530000   LBU S3, 0(V0)
9D003950  32770001   ANDI S7, S3, 1
9D003954  00139842   SRL S3, S3, 1
9D003958  A0530000   SB S3, 0(V0)
9D00395C  8F828058   LW V0, -32680(GP)
9D003960  2442FFFA   ADDIU V0, V0, -6
9D003964  AF828058   SW V0, -32680(GP)
9D003968  8E230054   LW V1, 84(S1)
9D00396C  24630006   ADDIU V1, V1, 6
9D003978  0B4027B2   J .L45
9D00397C  0260A821   ADDU S5, S3, ZERO
1799:                         OPCODE_END
9D003970  1C400003   BGTZ V0, 0x9D003980
9D003974  AE230054   SW V1, 84(S1)
9D003980  26100002   ADDIU S0, S0, 2
9D00399C  90420000   LBU V0, 0(V0)
9D0039A0  00021080   SLL V0, V0, 2
9D0039A4  00561021   ADDU V0, V0, S6
9D0039A8  8C420000   LW V0, 0(V0)
9D0039AC  0B400152   J 0x9D000548
9D0039B0  0260A821   ADDU S5, S3, ZERO
1800:                
1801:                      OPCODE_BEGIN(57)  /* SRE $nn,X */
1802:                         SRE(6, ZP_IND_X, ZP_WRITEBYTE, baddr);
9D0039B4  26120001   ADDIU S2, S0, 1
9D0039D0  90420000   LBU V0, 0(V0)
9D0039D4  03C21021   ADDU V0, FP, V0
9D0039D8  304200FF   ANDI V0, V0, 255
9D0039DC  8F838054   LW V1, -32684(GP)
9D0039E0  00621821   ADDU V1, V1, V0
9D0039E4  90620000   LBU V0, 0(V1)
9D0039E8  30570001   ANDI S7, V0, 1
9D0039EC  00021042   SRL V0, V0, 1
9D0039F0  A0620000   SB V0, 0(V1)
9D0039F4  00541026   XOR V0, V0, S4
9D0039F8  305300FF   ANDI S3, V0, 255
9D0039FC  8F828058   LW V0, -32680(GP)
9D003A00  2442FFFA   ADDIU V0, V0, -6
9D003A04  AF828058   SW V0, -32680(GP)
9D003A08  8E230054   LW V1, 84(S1)
9D003A0C  24630006   ADDIU V1, V1, 6
9D003A18  0260A021   ADDU S4, S3, ZERO
9D003A1C  0B4027B2   J .L45
9D003A20  0260A821   ADDU S5, S3, ZERO
9D003A50  0260A021   ADDU S4, S3, ZERO
1803:                         OPCODE_END
9D003A10  1C400004   BGTZ V0, 0x9D003A24
9D003A14  AE230054   SW V1, 84(S1)
9D003A24  26100002   ADDIU S0, S0, 2
9D003A40  90420000   LBU V0, 0(V0)
9D003A44  00021080   SLL V0, V0, 2
9D003A48  00561021   ADDU V0, V0, S6
9D003A4C  8C420000   LW V0, 0(V0)
9D003A54  0B400152   J 0x9D000548
9D003A58  0260A821   ADDU S5, S3, ZERO
1804:                
1805:                      OPCODE_BEGIN(58)  /* CLI */
1806:                         CLI();
9D003A5C  8F828058   LW V0, -32680(GP)
9D003A60  2443FFFE   ADDIU V1, V0, -2
9D003A64  AF838058   SW V1, -32680(GP)
9D003A68  8E240054   LW A0, 84(S1)
9D003A6C  24840002   ADDIU A0, A0, 2
9D003A70  AE240054   SW A0, 84(S1)
9D003A74  92240052   LBU A0, 82(S1)
9D003A78  10800031   BEQ A0, ZERO, 0x9D003B40
9D003A7C  AFA0001C   SW ZERO, 28(SP)
9D003A80  1860002F   BLEZ V1, 0x9D003B40
9D003A84  00102A02   SRL A1, S0, 8
9D003A88  A2200052   SB ZERO, 82(S1)
9D003A8C  8F838050   LW V1, -32688(GP)
9D003A90  8FA80014   LW T0, 20(SP)
9D003A94  00682021   ADDU A0, V1, T0
9D003A98  A0850000   SB A1, 0(A0)
9D003A9C  2504FFFE   ADDIU A0, T0, -2
9D003AA0  308400FF   ANDI A0, A0, 255
9D003AA4  2505FFFF   ADDIU A1, T0, -1
9D003AA8  30A500FF   ANDI A1, A1, 255
9D003AAC  00652821   ADDU A1, V1, A1
9D003AB0  A0B00000   SB S0, 0(A1)
9D003AB4  2505FFFD   ADDIU A1, T0, -3
9D003AB8  30A500FF   ANDI A1, A1, 255
9D003ABC  AFA50014   SW A1, 20(SP)
9D003AC0  00641821   ADDU V1, V1, A0
9D003AC4  2404FF80   ADDIU A0, ZERO, -128
9D003AC8  02644024   AND T0, S3, A0
9D003ACC  7C084420   SEB T0, T0
9D003AD0  24070040   ADDIU A3, ZERO, 64
9D003AD4  8FA50018   LW A1, 24(SP)
9D003AD8  0005380A   MOVZ A3, ZERO, A1
9D003ADC  24060008   ADDIU A2, ZERO, 8
9D003AE0  8FA40020   LW A0, 32(SP)
9D003AE4  0004300A   MOVZ A2, ZERO, A0
9D003AE8  24050002   ADDIU A1, ZERO, 2
9D003AEC  0015280B   MOVN A1, ZERO, S5
9D003AF0  36E40020   ORI A0, S7, 32
9D003AF4  01042025   OR A0, T0, A0
9D003AF8  00E42025   OR A0, A3, A0
9D003AFC  00C42025   OR A0, A2, A0
9D003B00  00A42025   OR A0, A1, A0
9D003B04  A0640000   SB A0, 0(V1)
9D003B1C  2442FFF7   ADDIU V0, V0, -9
9D003B20  AF828058   SW V0, -32680(GP)
9D003B24  8E220054   LW V0, 84(S1)
9D003B28  24420007   ADDIU V0, V0, 7
9D003B2C  AE220054   SW V0, 84(S1)
9D003B30  24050001   ADDIU A1, ZERO, 1
9D003B34  AFA5001C   SW A1, 28(SP)
9D003B38  0B400ED0   J 0x9D003B40
9D003B3C  AFA00028   SW ZERO, 40(SP)
1807:                         OPCODE_END
9D003B40  8F828058   LW V0, -32680(GP)
9D003B44  1C400003   BGTZ V0, .LBB1262
9D003B48  00101B02   SRL V1, S0, 12
9D003B4C  0B4027B2   J .L45
9D003B50  02009021   ADDU S2, S0, ZERO
9D003B68  90420000   LBU V0, 0(V0)
9D003B6C  00021080   SLL V0, V0, 2
9D003B70  00561021   ADDU V0, V0, S6
9D003B74  8C420000   LW V0, 0(V0)
9D003B78  0B400152   J 0x9D000548
9D003B7C  26100001   ADDIU S0, S0, 1
1808:                
1809:                      OPCODE_BEGIN(59)  /* EOR $nnnn,Y */
1810:                         EOR(4, ABS_IND_Y_BYTE_READ);
9D003BC4  8FA60010   LW A2, 16(SP)
9D003BC8  00862021   ADDU A0, A0, A2
9D003BCC  3084FFFF   ANDI A0, A0, -1
9D003BD0  308200FF   ANDI V0, A0, 255
9D003BD4  0046102B   SLTU V0, V0, A2
9D003BD8  10400007   BEQ V0, ZERO, 0x9D003BF8
9D003BDC  26120002   ADDIU S2, S0, 2
9D003BE0  8F828058   LW V0, -32680(GP)
9D003BE4  2442FFFF   ADDIU V0, V0, -1
9D003BE8  AF828058   SW V0, -32680(GP)
9D003BEC  8E220054   LW V0, 84(S1)
9D003BF0  24420001   ADDIU V0, V0, 1
9D003BF4  AE220054   SW V0, 84(S1)
9D003BF8  0F400000   JAL mem_readbyte
9D003BFC  00000000   NOP
9D003C00  00541026   XOR V0, V0, S4
9D003C04  305300FF   ANDI S3, V0, 255
9D003C08  8F828058   LW V0, -32680(GP)
9D003C0C  2442FFFC   ADDIU V0, V0, -4
9D003C10  AF828058   SW V0, -32680(GP)
9D003C14  8E230054   LW V1, 84(S1)
9D003C18  24630004   ADDIU V1, V1, 4
9D003C24  0260A021   ADDU S4, S3, ZERO
9D003C28  0B4027B2   J .L45
9D003C2C  0260A821   ADDU S5, S3, ZERO
9D003C5C  0260A021   ADDU S4, S3, ZERO
1811:                         OPCODE_END
9D003C1C  1C400004   BGTZ V0, 0x9D003C30
9D003C20  AE230054   SW V1, 84(S1)
9D003C30  26100003   ADDIU S0, S0, 3
9D003C4C  90420000   LBU V0, 0(V0)
9D003C50  00021080   SLL V0, V0, 2
9D003C54  00561021   ADDU V0, V0, S6
9D003C58  8C420000   LW V0, 0(V0)
9D003C60  0B400152   J 0x9D000548
9D003C64  0260A821   ADDU S5, S3, ZERO
1812:                
1813:                      OPCODE_BEGIN(5B)  /* SRE $nnnn,Y */
1814:                         SRE(7, ABS_IND_Y, mem_writebyte, addr);
9D003C6C  26120002   ADDIU S2, S0, 2
9D003CB0  8FA70010   LW A3, 16(SP)
9D003CB4  02A7A821   ADDU S5, S5, A3
9D003CB8  32B5FFFF   ANDI S5, S5, -1
9D003CBC  0F400000   JAL mem_readbyte
9D003CC0  02A02021   ADDU A0, S5, ZERO
9D003CC4  30570001   ANDI S7, V0, 1
9D003CC8  7C533840   EXT S3, V0, 1, 8
9D003CCC  02A02021   ADDU A0, S5, ZERO
9D003CD0  0F400036   JAL mem_writebyte
9D003CD4  02602821   ADDU A1, S3, ZERO
9D003CD8  02749826   XOR S3, S3, S4
9D003CDC  327300FF   ANDI S3, S3, 255
9D003CE0  8F828058   LW V0, -32680(GP)
9D003CE4  2442FFF9   ADDIU V0, V0, -7
9D003CE8  AF828058   SW V0, -32680(GP)
9D003CEC  8E230054   LW V1, 84(S1)
9D003CF0  24630007   ADDIU V1, V1, 7
9D003CFC  0260A021   ADDU S4, S3, ZERO
9D003D00  0B4027B2   J .L45
9D003D04  0260A821   ADDU S5, S3, ZERO
9D003D34  0260A021   ADDU S4, S3, ZERO
1815:                         OPCODE_END
9D003CF4  1C400004   BGTZ V0, 0x9D003D08
9D003CF8  AE230054   SW V1, 84(S1)
9D003D08  26100003   ADDIU S0, S0, 3
9D003D24  90420000   LBU V0, 0(V0)
9D003D28  00021080   SLL V0, V0, 2
9D003D2C  00561021   ADDU V0, V0, S6
9D003D30  8C420000   LW V0, 0(V0)
9D003D38  0B400152   J 0x9D000548
9D003D3C  0260A821   ADDU S5, S3, ZERO
1816:                
1817:                      OPCODE_BEGIN(5D)  /* EOR $nnnn,X */
1818:                         EOR(4, ABS_IND_X_BYTE_READ);
9D003D84  009E2021   ADDU A0, A0, FP
9D003D88  3084FFFF   ANDI A0, A0, -1
9D003D8C  308200FF   ANDI V0, A0, 255
9D003D90  005E102B   SLTU V0, V0, FP
9D003D94  10400007   BEQ V0, ZERO, 0x9D003DB4
9D003D98  26120002   ADDIU S2, S0, 2
9D003D9C  8F828058   LW V0, -32680(GP)
9D003DA0  2442FFFF   ADDIU V0, V0, -1
9D003DA4  AF828058   SW V0, -32680(GP)
9D003DA8  8E220054   LW V0, 84(S1)
9D003DAC  24420001   ADDIU V0, V0, 1
9D003DB0  AE220054   SW V0, 84(S1)
9D003DB4  0F400000   JAL mem_readbyte
9D003DB8  00000000   NOP
9D003DBC  00541026   XOR V0, V0, S4
9D003DC0  305300FF   ANDI S3, V0, 255
9D003DC4  8F828058   LW V0, -32680(GP)
9D003DC8  2442FFFC   ADDIU V0, V0, -4
9D003DCC  AF828058   SW V0, -32680(GP)
9D003DD0  8E230054   LW V1, 84(S1)
9D003DD4  24630004   ADDIU V1, V1, 4
9D003DE0  0260A021   ADDU S4, S3, ZERO
9D003DE4  0B4027B2   J .L45
9D003DE8  0260A821   ADDU S5, S3, ZERO
9D003E18  0260A021   ADDU S4, S3, ZERO
1819:                         OPCODE_END
9D003DD8  1C400004   BGTZ V0, 0x9D003DEC
9D003DDC  AE230054   SW V1, 84(S1)
9D003DEC  26100003   ADDIU S0, S0, 3
9D003E08  90420000   LBU V0, 0(V0)
9D003E0C  00021080   SLL V0, V0, 2
9D003E10  00561021   ADDU V0, V0, S6
9D003E14  8C420000   LW V0, 0(V0)
9D003E1C  0B400152   J 0x9D000548
9D003E20  0260A821   ADDU S5, S3, ZERO
1820:                
1821:                      OPCODE_BEGIN(5E)  /* LSR $nnnn,X */
1822:                         LSR(7, ABS_IND_X, mem_writebyte, addr);
9D003E28  26120002   ADDIU S2, S0, 2
9D003E6C  02BEA821   ADDU S5, S5, FP
9D003E70  32B5FFFF   ANDI S5, S5, -1
9D003E74  0F400000   JAL mem_readbyte
9D003E78  02A02021   ADDU A0, S5, ZERO
9D003E7C  30570001   ANDI S7, V0, 1
9D003E80  7C533840   EXT S3, V0, 1, 8
9D003E84  02A02021   ADDU A0, S5, ZERO
9D003E88  0F400036   JAL mem_writebyte
9D003E8C  02602821   ADDU A1, S3, ZERO
9D003E90  8F828058   LW V0, -32680(GP)
9D003E94  2442FFF9   ADDIU V0, V0, -7
9D003E98  AF828058   SW V0, -32680(GP)
9D003E9C  8E230054   LW V1, 84(S1)
9D003EA0  24630007   ADDIU V1, V1, 7
9D003EAC  0B4027B2   J .L45
9D003EB0  0260A821   ADDU S5, S3, ZERO
1823:                         OPCODE_END
9D003EA4  1C400003   BGTZ V0, 0x9D003EB4
9D003EA8  AE230054   SW V1, 84(S1)
9D003EB4  26100003   ADDIU S0, S0, 3
9D003ED0  90420000   LBU V0, 0(V0)
9D003ED4  00021080   SLL V0, V0, 2
9D003ED8  00561021   ADDU V0, V0, S6
9D003EDC  8C420000   LW V0, 0(V0)
9D003EE0  0B400152   J 0x9D000548
9D003EE4  0260A821   ADDU S5, S3, ZERO
1824:                
1825:                      OPCODE_BEGIN(5F)  /* SRE $nnnn,X */
1826:                         SRE(7, ABS_IND_X, mem_writebyte, addr);
9D003EEC  26120002   ADDIU S2, S0, 2
9D003F30  02BEA821   ADDU S5, S5, FP
9D003F34  32B5FFFF   ANDI S5, S5, -1
9D003F38  0F400000   JAL mem_readbyte
9D003F3C  02A02021   ADDU A0, S5, ZERO
9D003F40  30570001   ANDI S7, V0, 1
9D003F44  7C533840   EXT S3, V0, 1, 8
9D003F48  02A02021   ADDU A0, S5, ZERO
9D003F4C  0F400036   JAL mem_writebyte
9D003F50  02602821   ADDU A1, S3, ZERO
9D003F54  02749826   XOR S3, S3, S4
9D003F58  327300FF   ANDI S3, S3, 255
9D003F5C  8F828058   LW V0, -32680(GP)
9D003F60  2442FFF9   ADDIU V0, V0, -7
9D003F64  AF828058   SW V0, -32680(GP)
9D003F68  8E230054   LW V1, 84(S1)
9D003F6C  24630007   ADDIU V1, V1, 7
9D003F78  0260A021   ADDU S4, S3, ZERO
9D003F7C  0B4027B2   J .L45
9D003F80  0260A821   ADDU S5, S3, ZERO
9D003FB0  0260A021   ADDU S4, S3, ZERO
1827:                         OPCODE_END
9D003F70  1C400004   BGTZ V0, 0x9D003F84
9D003F74  AE230054   SW V1, 84(S1)
9D003F84  26100003   ADDIU S0, S0, 3
9D003FA0  90420000   LBU V0, 0(V0)
9D003FA4  00021080   SLL V0, V0, 2
9D003FA8  00561021   ADDU V0, V0, S6
9D003FAC  8C420000   LW V0, 0(V0)
9D003FB4  0B400152   J 0x9D000548
9D003FB8  0260A821   ADDU S5, S3, ZERO
1828:                
1829:                      OPCODE_BEGIN(60)  /* RTS */
1830:                         RTS();
9D003FBC  8F828050   LW V0, -32688(GP)
9D003FC0  8FA80014   LW T0, 20(SP)
9D003FC4  25030001   ADDIU V1, T0, 1
9D003FC8  306300FF   ANDI V1, V1, 255
9D003FCC  00431821   ADDU V1, V0, V1
9D003FD0  90630000   LBU V1, 0(V1)
9D003FD4  25040002   ADDIU A0, T0, 2
9D003FD8  308400FF   ANDI A0, A0, 255
9D003FDC  AFA40014   SW A0, 20(SP)
9D003FE0  00441021   ADDU V0, V0, A0
9D003FE4  90500000   LBU S0, 0(V0)
9D003FE8  00108200   SLL S0, S0, 8
9D003FEC  02038025   OR S0, S0, V1
9D003FF0  26120001   ADDIU S2, S0, 1
9D003FF4  8F828058   LW V0, -32680(GP)
9D003FF8  2442FFFA   ADDIU V0, V0, -6
9D003FFC  AF828058   SW V0, -32680(GP)
9D004000  8E230054   LW V1, 84(S1)
9D004004  24630006   ADDIU V1, V1, 6
1831:                         OPCODE_END
9D004008  184017AF   BLEZ V0, .L45
9D00400C  AE230054   SW V1, 84(S1)
9D004010  26100002   ADDIU S0, S0, 2
9D00402C  90420000   LBU V0, 0(V0)
9D004030  00021080   SLL V0, V0, 2
9D004034  00561021   ADDU V0, V0, S6
9D004038  0B400152   J 0x9D000548
9D00403C  8C420000   LW V0, 0(V0)
1832:                
1833:                      OPCODE_BEGIN(61)  /* ADC ($nn,X) */
1834:                         ADC(6, INDIR_X_BYTE);
9D004040  26120001   ADDIU S2, S0, 1
9D00405C  90420000   LBU V0, 0(V0)
9D004060  03C21021   ADDU V0, FP, V0
9D00407C  0F400000   JAL mem_readbyte
9D004080  308400FF   ANDI A0, A0, 255
9D004084  02829821   ADDU S3, S4, V0
9D004088  02779821   ADDU S3, S3, S7
9D00408C  7E770200   EXT S7, S3, 8, 1
9D004090  327300FF   ANDI S3, S3, 255
9D004094  00541026   XOR V0, V0, S4
9D004098  00021027   NOR V0, ZERO, V0
9D00409C  7C023004   INS V0, ZERO, 0, 7
9D0040A0  0274A026   XOR S4, S3, S4
9D0040A4  00541024   AND V0, V0, S4
9D0040A8  304200FF   ANDI V0, V0, 255
9D0040AC  AFA20018   SW V0, 24(SP)
9D0040B0  8F828058   LW V0, -32680(GP)
9D0040B4  2442FFFA   ADDIU V0, V0, -6
9D0040B8  AF828058   SW V0, -32680(GP)
9D0040BC  8E230054   LW V1, 84(S1)
9D0040C0  24630006   ADDIU V1, V1, 6
9D0040CC  0260A021   ADDU S4, S3, ZERO
9D0040D0  0B4027B2   J .L45
9D0040D4  0260A821   ADDU S5, S3, ZERO
9D004104  0260A021   ADDU S4, S3, ZERO
1835:                         OPCODE_END
9D0040C4  1C400004   BGTZ V0, 0x9D0040D8
9D0040C8  AE230054   SW V1, 84(S1)
9D0040D8  26100002   ADDIU S0, S0, 2
9D0040F4  90420000   LBU V0, 0(V0)
9D0040F8  00021080   SLL V0, V0, 2
9D0040FC  00561021   ADDU V0, V0, S6
9D004100  8C420000   LW V0, 0(V0)
9D004108  0B400152   J 0x9D000548
9D00410C  0260A821   ADDU S5, S3, ZERO
1836:                
1837:                      OPCODE_BEGIN(63)  /* RRA ($nn,X) */
1838:                         RRA(8, INDIR_X, mem_writebyte, addr);
9D004110  26120001   ADDIU S2, S0, 1
9D00412C  90420000   LBU V0, 0(V0)
9D004130  03C21021   ADDU V0, FP, V0
9D004150  0F400000   JAL mem_readbyte
9D004154  02602021   ADDU A0, S3, ZERO
9D004158  AFA20018   SW V0, 24(SP)
9D00415C  7C553840   EXT S5, V0, 1, 8
9D004160  0017B9C0   SLL S7, S7, 7
9D004164  02B7A825   OR S5, S5, S7
9D004168  32B500FF   ANDI S5, S5, 255
9D00416C  02602021   ADDU A0, S3, ZERO
9D004170  0F400036   JAL mem_writebyte
9D004174  02A02821   ADDU A1, S5, ZERO
9D004178  02959821   ADDU S3, S4, S5
9D00417C  8FA30018   LW V1, 24(SP)
9D004180  30620001   ANDI V0, V1, 1
9D004184  02629821   ADDU S3, S3, V0
9D004188  7E770200   EXT S7, S3, 8, 1
9D00418C  327300FF   ANDI S3, S3, 255
9D004190  02B41026   XOR V0, S5, S4
9D004194  00021027   NOR V0, ZERO, V0
9D004198  7C023004   INS V0, ZERO, 0, 7
9D00419C  0274A026   XOR S4, S3, S4
9D0041A0  00541024   AND V0, V0, S4
9D0041A4  304200FF   ANDI V0, V0, 255
9D0041A8  AFA20018   SW V0, 24(SP)
9D0041AC  8F828058   LW V0, -32680(GP)
9D0041B0  2442FFF8   ADDIU V0, V0, -8
9D0041B4  AF828058   SW V0, -32680(GP)
9D0041B8  8E230054   LW V1, 84(S1)
9D0041BC  24630008   ADDIU V1, V1, 8
9D0041C8  0260A021   ADDU S4, S3, ZERO
9D0041CC  0B4027B2   J .L45
9D0041D0  0260A821   ADDU S5, S3, ZERO
9D004200  0260A021   ADDU S4, S3, ZERO
1839:                         OPCODE_END
9D0041C0  1C400004   BGTZ V0, 0x9D0041D4
9D0041C4  AE230054   SW V1, 84(S1)
9D0041D4  26100002   ADDIU S0, S0, 2
9D0041F0  90420000   LBU V0, 0(V0)
9D0041F4  00021080   SLL V0, V0, 2
9D0041F8  00561021   ADDU V0, V0, S6
9D0041FC  8C420000   LW V0, 0(V0)
9D004204  0B400152   J 0x9D000548
9D004208  0260A821   ADDU S5, S3, ZERO
1840:                
1841:                      OPCODE_BEGIN(65)  /* ADC $nn */
1842:                         ADC(3, ZERO_PAGE_BYTE);
9D00420C  26120001   ADDIU S2, S0, 1
9D004228  90420000   LBU V0, 0(V0)
9D00422C  8F838054   LW V1, -32684(GP)
9D004230  00621021   ADDU V0, V1, V0
9D004234  90420000   LBU V0, 0(V0)
9D004238  02829821   ADDU S3, S4, V0
9D00423C  02779821   ADDU S3, S3, S7
9D004240  7E770200   EXT S7, S3, 8, 1
9D004244  327300FF   ANDI S3, S3, 255
9D004248  00541026   XOR V0, V0, S4
9D00424C  00021027   NOR V0, ZERO, V0
9D004250  7C023004   INS V0, ZERO, 0, 7
9D004254  0274A026   XOR S4, S3, S4
9D004258  00541024   AND V0, V0, S4
9D00425C  304200FF   ANDI V0, V0, 255
9D004260  AFA20018   SW V0, 24(SP)
9D004264  8F828058   LW V0, -32680(GP)
9D004268  2442FFFD   ADDIU V0, V0, -3
9D00426C  AF828058   SW V0, -32680(GP)
9D004270  8E230054   LW V1, 84(S1)
9D004274  24630003   ADDIU V1, V1, 3
9D004280  0260A021   ADDU S4, S3, ZERO
9D004284  0B4027B2   J .L45
9D004288  0260A821   ADDU S5, S3, ZERO
9D0042B8  0260A021   ADDU S4, S3, ZERO
1843:                         OPCODE_END
9D004278  1C400004   BGTZ V0, 0x9D00428C
9D00427C  AE230054   SW V1, 84(S1)
9D00428C  26100002   ADDIU S0, S0, 2
9D0042A8  90420000   LBU V0, 0(V0)
9D0042AC  00021080   SLL V0, V0, 2
9D0042B0  00561021   ADDU V0, V0, S6
9D0042B4  8C420000   LW V0, 0(V0)
9D0042BC  0B400152   J 0x9D000548
9D0042C0  0260A821   ADDU S5, S3, ZERO
1844:                
1845:                      OPCODE_BEGIN(66)  /* ROR $nn */
1846:                         ROR(5, ZERO_PAGE, ZP_WRITEBYTE, baddr);
9D0042C4  26120001   ADDIU S2, S0, 1
9D0042E0  90420000   LBU V0, 0(V0)
9D0042E4  8F838054   LW V1, -32684(GP)
9D0042E8  00621021   ADDU V0, V1, V0
9D0042EC  90430000   LBU V1, 0(V0)
9D0042F0  001799C0   SLL S3, S7, 7
9D0042F4  327300FF   ANDI S3, S3, 255
9D0042F8  30770001   ANDI S7, V1, 1
9D0042FC  00031842   SRL V1, V1, 1
9D004300  02639825   OR S3, S3, V1
9D004304  A0530000   SB S3, 0(V0)
9D004308  8F828058   LW V0, -32680(GP)
9D00430C  2442FFFB   ADDIU V0, V0, -5
9D004310  AF828058   SW V0, -32680(GP)
9D004314  8E230054   LW V1, 84(S1)
9D004318  24630005   ADDIU V1, V1, 5
9D004324  0B4027B2   J .L45
9D004328  0260A821   ADDU S5, S3, ZERO
1847:                         OPCODE_END
9D00431C  1C400003   BGTZ V0, 0x9D00432C
9D004320  AE230054   SW V1, 84(S1)
9D00432C  26100002   ADDIU S0, S0, 2
9D004348  90420000   LBU V0, 0(V0)
9D00434C  00021080   SLL V0, V0, 2
9D004350  00561021   ADDU V0, V0, S6
9D004354  8C420000   LW V0, 0(V0)
9D004358  0B400152   J 0x9D000548
9D00435C  0260A821   ADDU S5, S3, ZERO
1848:                
1849:                      OPCODE_BEGIN(67)  /* RRA $nn */
1850:                         RRA(5, ZERO_PAGE, ZP_WRITEBYTE, baddr);
9D004360  26120001   ADDIU S2, S0, 1
9D00437C  90420000   LBU V0, 0(V0)
9D004380  8F848054   LW A0, -32684(GP)
9D004384  00822021   ADDU A0, A0, V0
9D004388  90830000   LBU V1, 0(A0)
9D00438C  00031042   SRL V0, V1, 1
9D004390  0017B9C0   SLL S7, S7, 7
9D004394  00571025   OR V0, V0, S7
9D004398  304200FF   ANDI V0, V0, 255
9D00439C  A0820000   SB V0, 0(A0)
9D0043A0  02829821   ADDU S3, S4, V0
9D0043A4  30630001   ANDI V1, V1, 1
9D0043A8  02639821   ADDU S3, S3, V1
9D0043AC  7E770200   EXT S7, S3, 8, 1
9D0043B0  327300FF   ANDI S3, S3, 255
9D0043B4  00541026   XOR V0, V0, S4
9D0043B8  00021027   NOR V0, ZERO, V0
9D0043BC  7C023004   INS V0, ZERO, 0, 7
9D0043C0  0274A026   XOR S4, S3, S4
9D0043C4  00541024   AND V0, V0, S4
9D0043C8  304200FF   ANDI V0, V0, 255
9D0043CC  AFA20018   SW V0, 24(SP)
9D0043D0  8F828058   LW V0, -32680(GP)
9D0043D4  2442FFFB   ADDIU V0, V0, -5
9D0043D8  AF828058   SW V0, -32680(GP)
9D0043DC  8E230054   LW V1, 84(S1)
9D0043E0  24630005   ADDIU V1, V1, 5
9D0043EC  0260A021   ADDU S4, S3, ZERO
9D0043F0  0B4027B2   J .L45
9D0043F4  0260A821   ADDU S5, S3, ZERO
9D004424  0260A021   ADDU S4, S3, ZERO
1851:                         OPCODE_END
9D0043E4  1C400004   BGTZ V0, 0x9D0043F8
9D0043E8  AE230054   SW V1, 84(S1)
9D0043F8  26100002   ADDIU S0, S0, 2
9D004414  90420000   LBU V0, 0(V0)
9D004418  00021080   SLL V0, V0, 2
9D00441C  00561021   ADDU V0, V0, S6
9D004420  8C420000   LW V0, 0(V0)
9D004428  0B400152   J 0x9D000548
9D00442C  0260A821   ADDU S5, S3, ZERO
1852:                
1853:                      OPCODE_BEGIN(68)  /* PLA */
1854:                         PLA();
9D004430  8FA40014   LW A0, 20(SP)
9D004434  24820001   ADDIU V0, A0, 1
9D004438  304200FF   ANDI V0, V0, 255
9D00443C  AFA20014   SW V0, 20(SP)
9D004440  8F828050   LW V0, -32688(GP)
9D004444  8FA50014   LW A1, 20(SP)
9D004448  00451021   ADDU V0, V0, A1
9D00444C  90530000   LBU S3, 0(V0)
9D004450  8F828058   LW V0, -32680(GP)
9D004454  2442FFFC   ADDIU V0, V0, -4
9D004458  AF828058   SW V0, -32680(GP)
9D00445C  8E230054   LW V1, 84(S1)
9D004460  24630004   ADDIU V1, V1, 4
9D00446C  0260A021   ADDU S4, S3, ZERO
9D004474  0B4027B2   J .L45
9D004478  0260A821   ADDU S5, S3, ZERO
9D0044A4  0260A021   ADDU S4, S3, ZERO
1855:                         OPCODE_END
9D004464  1C400005   BGTZ V0, .LBB1316
9D004468  AE230054   SW V1, 84(S1)
9D004470  02009021   ADDU S2, S0, ZERO
9D004494  90420000   LBU V0, 0(V0)
9D004498  00021080   SLL V0, V0, 2
9D00449C  00561021   ADDU V0, V0, S6
9D0044A0  8C420000   LW V0, 0(V0)
9D0044A8  26100001   ADDIU S0, S0, 1
9D0044AC  0B400152   J 0x9D000548
9D0044B0  0260A821   ADDU S5, S3, ZERO
1856:                
1857:                      OPCODE_BEGIN(69)  /* ADC #$nn */
1858:                         ADC(2, IMMEDIATE_BYTE);
9D0044B4  26120001   ADDIU S2, S0, 1
9D0044D4  02829821   ADDU S3, S4, V0
9D0044D8  02779821   ADDU S3, S3, S7
9D0044DC  7E770200   EXT S7, S3, 8, 1
9D0044E0  327300FF   ANDI S3, S3, 255
9D0044E4  00541026   XOR V0, V0, S4
9D0044E8  00021027   NOR V0, ZERO, V0
9D0044EC  7C023004   INS V0, ZERO, 0, 7
9D0044F0  0274A026   XOR S4, S3, S4
9D0044F4  00541024   AND V0, V0, S4
9D0044F8  304200FF   ANDI V0, V0, 255
9D0044FC  AFA20018   SW V0, 24(SP)
9D004500  8F828058   LW V0, -32680(GP)
9D004504  2442FFFE   ADDIU V0, V0, -2
9D004508  AF828058   SW V0, -32680(GP)
9D00450C  8E230054   LW V1, 84(S1)
9D004510  24630002   ADDIU V1, V1, 2
9D00451C  0260A021   ADDU S4, S3, ZERO
9D004520  0B4027B2   J .L45
9D004524  0260A821   ADDU S5, S3, ZERO
9D004554  0260A021   ADDU S4, S3, ZERO
1859:                         OPCODE_END
9D004514  1C400004   BGTZ V0, 0x9D004528
9D004518  AE230054   SW V1, 84(S1)
9D004528  26100002   ADDIU S0, S0, 2
9D004544  90420000   LBU V0, 0(V0)
9D004548  00021080   SLL V0, V0, 2
9D00454C  00561021   ADDU V0, V0, S6
9D004550  8C420000   LW V0, 0(V0)
9D004558  0B400152   J 0x9D000548
9D00455C  0260A821   ADDU S5, S3, ZERO
1860:                
1861:                      OPCODE_BEGIN(6A)  /* ROR A */
1862:                         ROR_A();
9D004560  001711C0   SLL V0, S7, 7
9D004564  304200FF   ANDI V0, V0, 255
9D004568  32970001   ANDI S7, S4, 1
9D00456C  7E933840   EXT S3, S4, 1, 8
9D004570  02629825   OR S3, S3, V0
9D004574  8F828058   LW V0, -32680(GP)
9D004578  2442FFFE   ADDIU V0, V0, -2
9D00457C  AF828058   SW V0, -32680(GP)
9D004580  8E230054   LW V1, 84(S1)
9D004584  24630002   ADDIU V1, V1, 2
9D004590  0260A021   ADDU S4, S3, ZERO
9D004598  0B4027B2   J .L45
9D00459C  0260A821   ADDU S5, S3, ZERO
9D0045C8  0260A021   ADDU S4, S3, ZERO
1863:                         OPCODE_END
9D004588  1C400005   BGTZ V0, .LBB1322
9D00458C  AE230054   SW V1, 84(S1)
9D004594  02009021   ADDU S2, S0, ZERO
9D0045B8  90420000   LBU V0, 0(V0)
9D0045BC  00021080   SLL V0, V0, 2
9D0045C0  00561021   ADDU V0, V0, S6
9D0045C4  8C420000   LW V0, 0(V0)
9D0045CC  26100001   ADDIU S0, S0, 1
9D0045D0  0B400152   J 0x9D000548
9D0045D4  0260A821   ADDU S5, S3, ZERO
1864:                
1865:                      OPCODE_BEGIN(6B)  /* ARR #$nn */
1866:                         ARR(2, IMMEDIATE_BYTE);
9D0045D8  26120001   ADDIU S2, S0, 1
9D0045F4  90530000   LBU S3, 0(V0)
9D0045F8  02939824   AND S3, S4, S3
9D0045FC  00139842   SRL S3, S3, 1
9D004600  0017B9C0   SLL S7, S7, 7
9D004604  02779825   OR S3, S3, S7
9D004608  327300FF   ANDI S3, S3, 255
9D00460C  7E770180   EXT S7, S3, 6, 1
9D004610  00131942   SRL V1, S3, 5
9D004614  00131182   SRL V0, S3, 6
9D004618  00621026   XOR V0, V1, V0
9D00461C  30420001   ANDI V0, V0, 1
9D004620  AFA20018   SW V0, 24(SP)
9D004624  8F828058   LW V0, -32680(GP)
9D004628  2442FFFE   ADDIU V0, V0, -2
9D00462C  AF828058   SW V0, -32680(GP)
9D004630  8E230054   LW V1, 84(S1)
9D004634  24630002   ADDIU V1, V1, 2
9D004640  0260A021   ADDU S4, S3, ZERO
9D004644  0B4027B2   J .L45
9D004648  0260A821   ADDU S5, S3, ZERO
9D004678  0260A021   ADDU S4, S3, ZERO
1867:                         OPCODE_END
9D004638  1C400004   BGTZ V0, 0x9D00464C
9D00463C  AE230054   SW V1, 84(S1)
9D00464C  26100002   ADDIU S0, S0, 2
9D004668  90420000   LBU V0, 0(V0)
9D00466C  00021080   SLL V0, V0, 2
9D004670  00561021   ADDU V0, V0, S6
9D004674  8C420000   LW V0, 0(V0)
9D00467C  0B400152   J 0x9D000548
9D004680  0260A821   ADDU S5, S3, ZERO
1868:                
1869:                      OPCODE_BEGIN(6C)  /* JMP ($nnnn) */
1870:                         JMP_INDIRECT();
9D0046C8  240300FF   ADDIU V1, ZERO, 255
9D0046CC  14430007   BNE V0, V1, .LBB1332
9D0046D0  8E230000   LW V1, 0(S1)
9D0046D4  90720000   LBU S2, 0(V1)
9D0046D8  00129200   SLL S2, S2, 8
9D0046E0  90420000   LBU V0, 0(V0)
9D0046E4  0B4011C0   J .LBE1332
9D0046E8  02429025   OR S2, S2, V0
9D004700  8F828058   LW V0, -32680(GP)
9D004704  2442FFFB   ADDIU V0, V0, -5
9D004708  AF828058   SW V0, -32680(GP)
9D00470C  8E230054   LW V1, 84(S1)
9D004710  24630005   ADDIU V1, V1, 5
1871:                         OPCODE_END
9D004714  184015EC   BLEZ V0, .L45
9D004718  AE230054   SW V1, 84(S1)
9D00471C  26500001   ADDIU S0, S2, 1
9D004738  90420000   LBU V0, 0(V0)
9D00473C  00021080   SLL V0, V0, 2
9D004740  00561021   ADDU V0, V0, S6
9D004744  0B400152   J 0x9D000548
9D004748  8C420000   LW V0, 0(V0)
1872:                
1873:                      OPCODE_BEGIN(6D)  /* ADC $nnnn */
1874:                         ADC(4, ABSOLUTE_BYTE);
9D004750  26120002   ADDIU S2, S0, 2
9D004790  0F400000   JAL mem_readbyte
9D004794  308400FF   ANDI A0, A0, 255
9D004798  02829821   ADDU S3, S4, V0
9D00479C  02779821   ADDU S3, S3, S7
9D0047A0  7E770200   EXT S7, S3, 8, 1
9D0047A4  327300FF   ANDI S3, S3, 255
9D0047A8  00541026   XOR V0, V0, S4
9D0047AC  00021027   NOR V0, ZERO, V0
9D0047B0  7C023004   INS V0, ZERO, 0, 7
9D0047B4  0274A026   XOR S4, S3, S4
9D0047B8  00541024   AND V0, V0, S4
9D0047BC  304200FF   ANDI V0, V0, 255
9D0047C0  AFA20018   SW V0, 24(SP)
9D0047C4  8F828058   LW V0, -32680(GP)
9D0047C8  2442FFFC   ADDIU V0, V0, -4
9D0047CC  AF828058   SW V0, -32680(GP)
9D0047D0  8E230054   LW V1, 84(S1)
9D0047D4  24630004   ADDIU V1, V1, 4
9D0047E0  0260A021   ADDU S4, S3, ZERO
9D0047E4  0B4027B2   J .L45
9D0047E8  0260A821   ADDU S5, S3, ZERO
9D004818  0260A021   ADDU S4, S3, ZERO
1875:                         OPCODE_END
9D0047D8  1C400004   BGTZ V0, 0x9D0047EC
9D0047DC  AE230054   SW V1, 84(S1)
9D0047EC  26100003   ADDIU S0, S0, 3
9D004808  90420000   LBU V0, 0(V0)
9D00480C  00021080   SLL V0, V0, 2
9D004810  00561021   ADDU V0, V0, S6
9D004814  8C420000   LW V0, 0(V0)
9D00481C  0B400152   J 0x9D000548
9D004820  0260A821   ADDU S5, S3, ZERO
1876:                
1877:                      OPCODE_BEGIN(6E)  /* ROR $nnnn */
1878:                         ROR(6, ABSOLUTE, mem_writebyte, addr);
9D004868  26120002   ADDIU S2, S0, 2
9D00486C  0F400000   JAL mem_readbyte
9D004870  02A02021   ADDU A0, S5, ZERO
9D004874  001719C0   SLL V1, S7, 7
9D004878  306300FF   ANDI V1, V1, 255
9D00487C  30570001   ANDI S7, V0, 1
9D004880  7C423840   EXT V0, V0, 1, 8
9D004884  00439825   OR S3, V0, V1
9D004888  02A02021   ADDU A0, S5, ZERO
9D00488C  0F400036   JAL mem_writebyte
9D004890  02602821   ADDU A1, S3, ZERO
9D004894  8F828058   LW V0, -32680(GP)
9D004898  2442FFFA   ADDIU V0, V0, -6
9D00489C  AF828058   SW V0, -32680(GP)
9D0048A0  8E230054   LW V1, 84(S1)
9D0048A4  24630006   ADDIU V1, V1, 6
9D0048B0  0B4027B2   J .L45
9D0048B4  0260A821   ADDU S5, S3, ZERO
1879:                         OPCODE_END
9D0048A8  1C400003   BGTZ V0, 0x9D0048B8
9D0048AC  AE230054   SW V1, 84(S1)
9D0048B8  26100003   ADDIU S0, S0, 3
9D0048D4  90420000   LBU V0, 0(V0)
9D0048D8  00021080   SLL V0, V0, 2
9D0048DC  00561021   ADDU V0, V0, S6
9D0048E0  8C420000   LW V0, 0(V0)
9D0048E4  0B400152   J 0x9D000548
9D0048E8  0260A821   ADDU S5, S3, ZERO
1880:                
1881:                      OPCODE_BEGIN(6F)  /* RRA $nnnn */
1882:                         RRA(6, ABSOLUTE, mem_writebyte, addr);
9D004930  26120002   ADDIU S2, S0, 2
9D004934  0F400000   JAL mem_readbyte
9D004938  02602021   ADDU A0, S3, ZERO
9D00493C  AFA20018   SW V0, 24(SP)
9D004940  7C553840   EXT S5, V0, 1, 8
9D004944  0017B9C0   SLL S7, S7, 7
9D004948  02B7A825   OR S5, S5, S7
9D00494C  32B500FF   ANDI S5, S5, 255
9D004950  02602021   ADDU A0, S3, ZERO
9D004954  0F400036   JAL mem_writebyte
9D004958  02A02821   ADDU A1, S5, ZERO
9D00495C  02959821   ADDU S3, S4, S5
9D004960  8FA60018   LW A2, 24(SP)
9D004964  30C20001   ANDI V0, A2, 1
9D004968  02629821   ADDU S3, S3, V0
9D00496C  7E770200   EXT S7, S3, 8, 1
9D004970  327300FF   ANDI S3, S3, 255
9D004974  02B41026   XOR V0, S5, S4
9D004978  00021027   NOR V0, ZERO, V0
9D00497C  7C023004   INS V0, ZERO, 0, 7
9D004980  0274A026   XOR S4, S3, S4
9D004984  00541024   AND V0, V0, S4
9D004988  304200FF   ANDI V0, V0, 255
9D00498C  AFA20018   SW V0, 24(SP)
9D004990  8F828058   LW V0, -32680(GP)
9D004994  2442FFFA   ADDIU V0, V0, -6
9D004998  AF828058   SW V0, -32680(GP)
9D00499C  8E230054   LW V1, 84(S1)
9D0049A0  24630006   ADDIU V1, V1, 6
9D0049AC  0260A021   ADDU S4, S3, ZERO
9D0049B0  0B4027B2   J .L45
9D0049B4  0260A821   ADDU S5, S3, ZERO
9D0049E4  0260A021   ADDU S4, S3, ZERO
1883:                         OPCODE_END
9D0049A4  1C400004   BGTZ V0, 0x9D0049B8
9D0049A8  AE230054   SW V1, 84(S1)
9D0049B8  26100003   ADDIU S0, S0, 3
9D0049D4  90420000   LBU V0, 0(V0)
9D0049D8  00021080   SLL V0, V0, 2
9D0049DC  00561021   ADDU V0, V0, S6
9D0049E0  8C420000   LW V0, 0(V0)
9D0049E8  0B400152   J 0x9D000548
9D0049EC  0260A821   ADDU S5, S3, ZERO
1884:                
1885:                      OPCODE_BEGIN(70)  /* BVS $nnnn */
1886:                         BVS();
9D0049F0  8FA70018   LW A3, 24(SP)
9D0049F4  10E0001B   BEQ A3, ZERO, 0x9D004A64
9D0049F8  26120001   ADDIU S2, S0, 1
9D0049FC  26020001   ADDIU V0, S0, 1
9D004A18  80720000   LB S2, 0(V1)
9D004A1C  304300FF   ANDI V1, V0, 255
9D004A20  02431821   ADDU V1, S2, V1
9D004A24  30630100   ANDI V1, V1, 256
9D004A28  10600007   BEQ V1, ZERO, 0x9D004A48
9D004A2C  8F838058   LW V1, -32680(GP)
9D004A30  2463FFFF   ADDIU V1, V1, -1
9D004A34  AF838058   SW V1, -32680(GP)
9D004A38  8E230054   LW V1, 84(S1)
9D004A3C  24630001   ADDIU V1, V1, 1
9D004A40  AE230054   SW V1, 84(S1)
9D004A44  8F838058   LW V1, -32680(GP)
9D004A48  2463FFFD   ADDIU V1, V1, -3
9D004A4C  AF838058   SW V1, -32680(GP)
9D004A50  8E230054   LW V1, 84(S1)
9D004A54  24630003   ADDIU V1, V1, 3
9D004A58  AE230054   SW V1, 84(S1)
9D004A5C  0B40129F   J 0x9D004A7C
9D004A60  02429021   ADDU S2, S2, V0
9D004A64  8F828058   LW V0, -32680(GP)
9D004A68  2442FFFE   ADDIU V0, V0, -2
9D004A6C  AF828058   SW V0, -32680(GP)
9D004A70  8E220054   LW V0, 84(S1)
9D004A74  24420002   ADDIU V0, V0, 2
9D004A78  AE220054   SW V0, 84(S1)
1887:                         OPCODE_END
9D004A7C  8F828058   LW V0, -32680(GP)
9D004A80  18401511   BLEZ V0, .L45
9D004A84  26500001   ADDIU S0, S2, 1
9D004AA0  90420000   LBU V0, 0(V0)
9D004AA4  00021080   SLL V0, V0, 2
9D004AA8  00561021   ADDU V0, V0, S6
9D004AAC  0B400152   J 0x9D000548
9D004AB0  8C420000   LW V0, 0(V0)
1888:                
1889:                      OPCODE_BEGIN(71)  /* ADC ($nn),Y */
1890:                         ADC(5, INDIR_Y_BYTE_READ);
9D004AE8  8FA80010   LW T0, 16(SP)
9D004AEC  00882021   ADDU A0, A0, T0
9D004AF0  3084FFFF   ANDI A0, A0, -1
9D004AF4  308200FF   ANDI V0, A0, 255
9D004AF8  0048102B   SLTU V0, V0, T0
9D004AFC  10400007   BEQ V0, ZERO, 0x9D004B1C
9D004B00  26120001   ADDIU S2, S0, 1
9D004B04  8F828058   LW V0, -32680(GP)
9D004B08  2442FFFF   ADDIU V0, V0, -1
9D004B0C  AF828058   SW V0, -32680(GP)
9D004B10  8E220054   LW V0, 84(S1)
9D004B14  24420001   ADDIU V0, V0, 1
9D004B18  AE220054   SW V0, 84(S1)
9D004B1C  0F400000   JAL mem_readbyte
9D004B20  00000000   NOP
9D004B24  02829821   ADDU S3, S4, V0
9D004B28  02779821   ADDU S3, S3, S7
9D004B2C  7E770200   EXT S7, S3, 8, 1
9D004B30  327300FF   ANDI S3, S3, 255
9D004B34  00541026   XOR V0, V0, S4
9D004B38  00021027   NOR V0, ZERO, V0
9D004B3C  7C023004   INS V0, ZERO, 0, 7
9D004B40  0274A026   XOR S4, S3, S4
9D004B44  00541024   AND V0, V0, S4
9D004B48  304200FF   ANDI V0, V0, 255
9D004B4C  AFA20018   SW V0, 24(SP)
9D004B50  8F828058   LW V0, -32680(GP)
9D004B54  2442FFFB   ADDIU V0, V0, -5
9D004B58  AF828058   SW V0, -32680(GP)
9D004B5C  8E230054   LW V1, 84(S1)
9D004B60  24630005   ADDIU V1, V1, 5
9D004B6C  0260A021   ADDU S4, S3, ZERO
9D004B70  0B4027B2   J .L45
9D004B74  0260A821   ADDU S5, S3, ZERO
9D004BA4  0260A021   ADDU S4, S3, ZERO
1891:                         OPCODE_END
9D004B64  1C400004   BGTZ V0, 0x9D004B78
9D004B68  AE230054   SW V1, 84(S1)
9D004B78  26100002   ADDIU S0, S0, 2
9D004B94  90420000   LBU V0, 0(V0)
9D004B98  00021080   SLL V0, V0, 2
9D004B9C  00561021   ADDU V0, V0, S6
9D004BA0  8C420000   LW V0, 0(V0)
9D004BA8  0B400152   J 0x9D000548
9D004BAC  0260A821   ADDU S5, S3, ZERO
1892:                
1893:                      OPCODE_BEGIN(73)  /* RRA ($nn),Y */
1894:                         RRA(8, INDIR_Y, mem_writebyte, addr);
9D004BB0  26120001   ADDIU S2, S0, 1
9D004BE8  8FA20010   LW V0, 16(SP)
9D004BEC  02629821   ADDU S3, S3, V0
9D004BF0  3273FFFF   ANDI S3, S3, -1
9D004BF4  0F400000   JAL mem_readbyte
9D004BF8  02602021   ADDU A0, S3, ZERO
9D004BFC  AFA20018   SW V0, 24(SP)
9D004C00  7C553840   EXT S5, V0, 1, 8
9D004C04  0017B9C0   SLL S7, S7, 7
9D004C08  02B7A825   OR S5, S5, S7
9D004C0C  32B500FF   ANDI S5, S5, 255
9D004C10  02602021   ADDU A0, S3, ZERO
9D004C14  0F400036   JAL mem_writebyte
9D004C18  02A02821   ADDU A1, S5, ZERO
9D004C1C  02959821   ADDU S3, S4, S5
9D004C20  8FA30018   LW V1, 24(SP)
9D004C24  30620001   ANDI V0, V1, 1
9D004C28  02629821   ADDU S3, S3, V0
9D004C2C  7E770200   EXT S7, S3, 8, 1
9D004C30  327300FF   ANDI S3, S3, 255
9D004C34  02B41026   XOR V0, S5, S4
9D004C38  00021027   NOR V0, ZERO, V0
9D004C3C  7C023004   INS V0, ZERO, 0, 7
9D004C40  0274A026   XOR S4, S3, S4
9D004C44  00541024   AND V0, V0, S4
9D004C48  304200FF   ANDI V0, V0, 255
9D004C4C  AFA20018   SW V0, 24(SP)
9D004C50  8F828058   LW V0, -32680(GP)
9D004C54  2442FFF8   ADDIU V0, V0, -8
9D004C58  AF828058   SW V0, -32680(GP)
9D004C5C  8E230054   LW V1, 84(S1)
9D004C60  24630008   ADDIU V1, V1, 8
9D004C6C  0260A021   ADDU S4, S3, ZERO
9D004C70  0B4027B2   J .L45
9D004C74  0260A821   ADDU S5, S3, ZERO
9D004CA4  0260A021   ADDU S4, S3, ZERO
1895:                         OPCODE_END
9D004C64  1C400004   BGTZ V0, 0x9D004C78
9D004C68  AE230054   SW V1, 84(S1)
9D004C78  26100002   ADDIU S0, S0, 2
9D004C94  90420000   LBU V0, 0(V0)
9D004C98  00021080   SLL V0, V0, 2
9D004C9C  00561021   ADDU V0, V0, S6
9D004CA0  8C420000   LW V0, 0(V0)
9D004CA8  0B400152   J 0x9D000548
9D004CAC  0260A821   ADDU S5, S3, ZERO
1896:                
1897:                      OPCODE_BEGIN(75)  /* ADC $nn,X */
1898:                         ADC(4, ZP_IND_X_BYTE);
9D004CB0  26120001   ADDIU S2, S0, 1
9D004CCC  90420000   LBU V0, 0(V0)
9D004CD0  03C21021   ADDU V0, FP, V0
9D004CD4  304200FF   ANDI V0, V0, 255
9D004CD8  8F838054   LW V1, -32684(GP)
9D004CDC  00621021   ADDU V0, V1, V0
9D004CE0  90420000   LBU V0, 0(V0)
9D004CE4  02829821   ADDU S3, S4, V0
9D004CE8  02779821   ADDU S3, S3, S7
9D004CEC  7E770200   EXT S7, S3, 8, 1
9D004CF0  327300FF   ANDI S3, S3, 255
9D004CF4  00541026   XOR V0, V0, S4
9D004CF8  00021027   NOR V0, ZERO, V0
9D004CFC  7C023004   INS V0, ZERO, 0, 7
9D004D00  0274A026   XOR S4, S3, S4
9D004D04  00541024   AND V0, V0, S4
9D004D08  304200FF   ANDI V0, V0, 255
9D004D0C  AFA20018   SW V0, 24(SP)
9D004D10  8F828058   LW V0, -32680(GP)
9D004D14  2442FFFC   ADDIU V0, V0, -4
9D004D18  AF828058   SW V0, -32680(GP)
9D004D1C  8E230054   LW V1, 84(S1)
9D004D20  24630004   ADDIU V1, V1, 4
9D004D2C  0260A021   ADDU S4, S3, ZERO
9D004D30  0B4027B2   J .L45
9D004D34  0260A821   ADDU S5, S3, ZERO
9D004D64  0260A021   ADDU S4, S3, ZERO
1899:                         OPCODE_END
9D004D24  1C400004   BGTZ V0, 0x9D004D38
9D004D28  AE230054   SW V1, 84(S1)
9D004D38  26100002   ADDIU S0, S0, 2
9D004D54  90420000   LBU V0, 0(V0)
9D004D58  00021080   SLL V0, V0, 2
9D004D5C  00561021   ADDU V0, V0, S6
9D004D60  8C420000   LW V0, 0(V0)
9D004D68  0B400152   J 0x9D000548
9D004D6C  0260A821   ADDU S5, S3, ZERO
1900:                
1901:                      OPCODE_BEGIN(76)  /* ROR $nn,X */
1902:                         ROR(6, ZP_IND_X, ZP_WRITEBYTE, baddr);
9D004D70  26120001   ADDIU S2, S0, 1
9D004D8C  90420000   LBU V0, 0(V0)
9D004D90  03C21021   ADDU V0, FP, V0
9D004D94  304200FF   ANDI V0, V0, 255
9D004D98  8F838054   LW V1, -32684(GP)
9D004D9C  00621021   ADDU V0, V1, V0
9D004DA0  90430000   LBU V1, 0(V0)
9D004DA4  001799C0   SLL S3, S7, 7
9D004DA8  327300FF   ANDI S3, S3, 255
9D004DAC  30770001   ANDI S7, V1, 1
9D004DB0  00031842   SRL V1, V1, 1
9D004DB4  02639825   OR S3, S3, V1
9D004DB8  A0530000   SB S3, 0(V0)
9D004DBC  8F828058   LW V0, -32680(GP)
9D004DC0  2442FFFA   ADDIU V0, V0, -6
9D004DC4  AF828058   SW V0, -32680(GP)
9D004DC8  8E230054   LW V1, 84(S1)
9D004DCC  24630006   ADDIU V1, V1, 6
9D004DD8  0B4027B2   J .L45
9D004DDC  0260A821   ADDU S5, S3, ZERO
1903:                         OPCODE_END
9D004DD0  1C400003   BGTZ V0, 0x9D004DE0
9D004DD4  AE230054   SW V1, 84(S1)
9D004DE0  26100002   ADDIU S0, S0, 2
9D004DFC  90420000   LBU V0, 0(V0)
9D004E00  00021080   SLL V0, V0, 2
9D004E04  00561021   ADDU V0, V0, S6
9D004E08  8C420000   LW V0, 0(V0)
9D004E0C  0B400152   J 0x9D000548
9D004E10  0260A821   ADDU S5, S3, ZERO
1904:                
1905:                      OPCODE_BEGIN(77)  /* RRA $nn,X */
1906:                         RRA(6, ZP_IND_X, ZP_WRITEBYTE, baddr);
9D004E14  26120001   ADDIU S2, S0, 1
9D004E30  90420000   LBU V0, 0(V0)
9D004E34  03C21021   ADDU V0, FP, V0
9D004E38  304200FF   ANDI V0, V0, 255
9D004E3C  8F848054   LW A0, -32684(GP)
9D004E40  00822021   ADDU A0, A0, V0
9D004E44  90830000   LBU V1, 0(A0)
9D004E48  00031042   SRL V0, V1, 1
9D004E4C  0017B9C0   SLL S7, S7, 7
9D004E50  00571025   OR V0, V0, S7
9D004E54  304200FF   ANDI V0, V0, 255
9D004E58  A0820000   SB V0, 0(A0)
9D004E5C  02829821   ADDU S3, S4, V0
9D004E60  30630001   ANDI V1, V1, 1
9D004E64  02639821   ADDU S3, S3, V1
9D004E68  7E770200   EXT S7, S3, 8, 1
9D004E6C  327300FF   ANDI S3, S3, 255
9D004E70  00541026   XOR V0, V0, S4
9D004E74  00021027   NOR V0, ZERO, V0
9D004E78  7C023004   INS V0, ZERO, 0, 7
9D004E7C  0274A026   XOR S4, S3, S4
9D004E80  00541024   AND V0, V0, S4
9D004E84  304200FF   ANDI V0, V0, 255
9D004E88  AFA20018   SW V0, 24(SP)
9D004E8C  8F828058   LW V0, -32680(GP)
9D004E90  2442FFFA   ADDIU V0, V0, -6
9D004E94  AF828058   SW V0, -32680(GP)
9D004E98  8E230054   LW V1, 84(S1)
9D004E9C  24630006   ADDIU V1, V1, 6
9D004EA8  0260A021   ADDU S4, S3, ZERO
9D004EAC  0B4027B2   J .L45
9D004EB0  0260A821   ADDU S5, S3, ZERO
9D004EE0  0260A021   ADDU S4, S3, ZERO
1907:                         OPCODE_END
9D004EA0  1C400004   BGTZ V0, 0x9D004EB4
9D004EA4  AE230054   SW V1, 84(S1)
9D004EB4  26100002   ADDIU S0, S0, 2
9D004ED0  90420000   LBU V0, 0(V0)
9D004ED4  00021080   SLL V0, V0, 2
9D004ED8  00561021   ADDU V0, V0, S6
9D004EDC  8C420000   LW V0, 0(V0)
9D004EE4  0B400152   J 0x9D000548
9D004EE8  0260A821   ADDU S5, S3, ZERO
1908:                
1909:                      OPCODE_BEGIN(78)  /* SEI */
1910:                         SEI();
9D004EEC  8F828058   LW V0, -32680(GP)
9D004EF0  2442FFFE   ADDIU V0, V0, -2
9D004EF4  AF828058   SW V0, -32680(GP)
9D004EF8  8E230054   LW V1, 84(S1)
9D004EFC  24630002   ADDIU V1, V1, 2
9D004F0C  24040001   ADDIU A0, ZERO, 1
9D004F10  0B4027B2   J .L45
9D004F14  AFA4001C   SW A0, 28(SP)
9D004F44  24050001   ADDIU A1, ZERO, 1
1911:                         OPCODE_END
9D004F00  1C400005   BGTZ V0, .LBB1378
9D004F04  AE230054   SW V1, 84(S1)
9D004F08  02009021   ADDU S2, S0, ZERO
9D004F30  90420000   LBU V0, 0(V0)
9D004F34  00021080   SLL V0, V0, 2
9D004F38  00561021   ADDU V0, V0, S6
9D004F3C  8C420000   LW V0, 0(V0)
9D004F40  26100001   ADDIU S0, S0, 1
9D004F48  0B400152   J 0x9D000548
9D004F4C  AFA5001C   SW A1, 28(SP)
1912:                
1913:                      OPCODE_BEGIN(79)  /* ADC $nnnn,Y */
1914:                         ADC(4, ABS_IND_Y_BYTE_READ);
9D004F94  8FA60010   LW A2, 16(SP)
9D004F98  00862021   ADDU A0, A0, A2
9D004F9C  3084FFFF   ANDI A0, A0, -1
9D004FA0  308200FF   ANDI V0, A0, 255
9D004FA4  0046102B   SLTU V0, V0, A2
9D004FA8  10400007   BEQ V0, ZERO, 0x9D004FC8
9D004FAC  26120002   ADDIU S2, S0, 2
9D004FB0  8F828058   LW V0, -32680(GP)
9D004FB4  2442FFFF   ADDIU V0, V0, -1
9D004FB8  AF828058   SW V0, -32680(GP)
9D004FBC  8E220054   LW V0, 84(S1)
9D004FC0  24420001   ADDIU V0, V0, 1
9D004FC4  AE220054   SW V0, 84(S1)
9D004FC8  0F400000   JAL mem_readbyte
9D004FCC  00000000   NOP
9D004FD0  02829821   ADDU S3, S4, V0
9D004FD4  02779821   ADDU S3, S3, S7
9D004FD8  7E770200   EXT S7, S3, 8, 1
9D004FDC  327300FF   ANDI S3, S3, 255
9D004FE0  00541026   XOR V0, V0, S4
9D004FE4  00021027   NOR V0, ZERO, V0
9D004FE8  7C023004   INS V0, ZERO, 0, 7
9D004FEC  0274A026   XOR S4, S3, S4
9D004FF0  00541024   AND V0, V0, S4
9D004FF4  304200FF   ANDI V0, V0, 255
9D004FF8  AFA20018   SW V0, 24(SP)
9D004FFC  8F828058   LW V0, -32680(GP)
9D005000  2442FFFC   ADDIU V0, V0, -4
9D005004  AF828058   SW V0, -32680(GP)
9D005008  8E230054   LW V1, 84(S1)
9D00500C  24630004   ADDIU V1, V1, 4
9D005018  0260A021   ADDU S4, S3, ZERO
9D00501C  0B4027B2   J .L45
9D005020  0260A821   ADDU S5, S3, ZERO
9D005050  0260A021   ADDU S4, S3, ZERO
1915:                         OPCODE_END
9D005010  1C400004   BGTZ V0, 0x9D005024
9D005014  AE230054   SW V1, 84(S1)
9D005024  26100003   ADDIU S0, S0, 3
9D005040  90420000   LBU V0, 0(V0)
9D005044  00021080   SLL V0, V0, 2
9D005048  00561021   ADDU V0, V0, S6
9D00504C  8C420000   LW V0, 0(V0)
9D005054  0B400152   J 0x9D000548
9D005058  0260A821   ADDU S5, S3, ZERO
1916:                
1917:                      OPCODE_BEGIN(7B)  /* RRA $nnnn,Y */
1918:                         RRA(7, ABS_IND_Y, mem_writebyte, addr);
9D005060  26120002   ADDIU S2, S0, 2
9D0050A4  8FA70010   LW A3, 16(SP)
9D0050A8  02679821   ADDU S3, S3, A3
9D0050AC  3273FFFF   ANDI S3, S3, -1
9D0050B0  0F400000   JAL mem_readbyte
9D0050B4  02602021   ADDU A0, S3, ZERO
9D0050B8  AFA20018   SW V0, 24(SP)
9D0050BC  7C553840   EXT S5, V0, 1, 8
9D0050C0  0017B9C0   SLL S7, S7, 7
9D0050C4  02B7A825   OR S5, S5, S7
9D0050C8  32B500FF   ANDI S5, S5, 255
9D0050CC  02602021   ADDU A0, S3, ZERO
9D0050D0  0F400036   JAL mem_writebyte
9D0050D4  02A02821   ADDU A1, S5, ZERO
9D0050D8  02959821   ADDU S3, S4, S5
9D0050DC  8FA80018   LW T0, 24(SP)
9D0050E0  31020001   ANDI V0, T0, 1
9D0050E4  02629821   ADDU S3, S3, V0
9D0050E8  7E770200   EXT S7, S3, 8, 1
9D0050EC  327300FF   ANDI S3, S3, 255
9D0050F0  02B41026   XOR V0, S5, S4
9D0050F4  00021027   NOR V0, ZERO, V0
9D0050F8  7C023004   INS V0, ZERO, 0, 7
9D0050FC  0274A026   XOR S4, S3, S4
9D005100  00541024   AND V0, V0, S4
9D005104  304200FF   ANDI V0, V0, 255
9D005108  AFA20018   SW V0, 24(SP)
9D00510C  8F828058   LW V0, -32680(GP)
9D005110  2442FFF9   ADDIU V0, V0, -7
9D005114  AF828058   SW V0, -32680(GP)
9D005118  8E230054   LW V1, 84(S1)
9D00511C  24630007   ADDIU V1, V1, 7
9D005128  0260A021   ADDU S4, S3, ZERO
9D00512C  0B4027B2   J .L45
9D005130  0260A821   ADDU S5, S3, ZERO
9D005160  0260A021   ADDU S4, S3, ZERO
1919:                         OPCODE_END
9D005120  1C400004   BGTZ V0, 0x9D005134
9D005124  AE230054   SW V1, 84(S1)
9D005134  26100003   ADDIU S0, S0, 3
9D005150  90420000   LBU V0, 0(V0)
9D005154  00021080   SLL V0, V0, 2
9D005158  00561021   ADDU V0, V0, S6
9D00515C  8C420000   LW V0, 0(V0)
9D005164  0B400152   J 0x9D000548
9D005168  0260A821   ADDU S5, S3, ZERO
1920:                
1921:                      OPCODE_BEGIN(7D)  /* ADC $nnnn,X */
1922:                         ADC(4, ABS_IND_X_BYTE_READ);
9D0051B0  009E2021   ADDU A0, A0, FP
9D0051B4  3084FFFF   ANDI A0, A0, -1
9D0051B8  308200FF   ANDI V0, A0, 255
9D0051BC  005E102B   SLTU V0, V0, FP
9D0051C0  10400007   BEQ V0, ZERO, 0x9D0051E0
9D0051C4  26120002   ADDIU S2, S0, 2
9D0051C8  8F828058   LW V0, -32680(GP)
9D0051CC  2442FFFF   ADDIU V0, V0, -1
9D0051D0  AF828058   SW V0, -32680(GP)
9D0051D4  8E220054   LW V0, 84(S1)
9D0051D8  24420001   ADDIU V0, V0, 1
9D0051DC  AE220054   SW V0, 84(S1)
9D0051E0  0F400000   JAL mem_readbyte
9D0051E4  00000000   NOP
9D0051E8  02829821   ADDU S3, S4, V0
9D0051EC  02779821   ADDU S3, S3, S7
9D0051F0  7E770200   EXT S7, S3, 8, 1
9D0051F4  327300FF   ANDI S3, S3, 255
9D0051F8  00541026   XOR V0, V0, S4
9D0051FC  00021027   NOR V0, ZERO, V0
9D005200  7C023004   INS V0, ZERO, 0, 7
9D005204  0274A026   XOR S4, S3, S4
9D005208  00541024   AND V0, V0, S4
9D00520C  304200FF   ANDI V0, V0, 255
9D005210  AFA20018   SW V0, 24(SP)
9D005214  8F828058   LW V0, -32680(GP)
9D005218  2442FFFC   ADDIU V0, V0, -4
9D00521C  AF828058   SW V0, -32680(GP)
9D005220  8E230054   LW V1, 84(S1)
9D005224  24630004   ADDIU V1, V1, 4
9D005230  0260A021   ADDU S4, S3, ZERO
9D005234  0B4027B2   J .L45
9D005238  0260A821   ADDU S5, S3, ZERO
9D005268  0260A021   ADDU S4, S3, ZERO
1923:                         OPCODE_END
9D005228  1C400004   BGTZ V0, 0x9D00523C
9D00522C  AE230054   SW V1, 84(S1)
9D00523C  26100003   ADDIU S0, S0, 3
9D005258  90420000   LBU V0, 0(V0)
9D00525C  00021080   SLL V0, V0, 2
9D005260  00561021   ADDU V0, V0, S6
9D005264  8C420000   LW V0, 0(V0)
9D00526C  0B400152   J 0x9D000548
9D005270  0260A821   ADDU S5, S3, ZERO
1924:                
1925:                      OPCODE_BEGIN(7E)  /* ROR $nnnn,X */
1926:                         ROR(7, ABS_IND_X, mem_writebyte, addr);
9D005278  26120002   ADDIU S2, S0, 2
9D0052BC  02BEA821   ADDU S5, S5, FP
9D0052C0  32B5FFFF   ANDI S5, S5, -1
9D0052C4  0F400000   JAL mem_readbyte
9D0052C8  02A02021   ADDU A0, S5, ZERO
9D0052CC  001719C0   SLL V1, S7, 7
9D0052D0  306300FF   ANDI V1, V1, 255
9D0052D4  30570001   ANDI S7, V0, 1
9D0052D8  7C423840   EXT V0, V0, 1, 8
9D0052DC  00439825   OR S3, V0, V1
9D0052E0  02A02021   ADDU A0, S5, ZERO
9D0052E4  0F400036   JAL mem_writebyte
9D0052E8  02602821   ADDU A1, S3, ZERO
9D0052EC  8F828058   LW V0, -32680(GP)
9D0052F0  2442FFF9   ADDIU V0, V0, -7
9D0052F4  AF828058   SW V0, -32680(GP)
9D0052F8  8E230054   LW V1, 84(S1)
9D0052FC  24630007   ADDIU V1, V1, 7
9D005308  0B4027B2   J .L45
9D00530C  0260A821   ADDU S5, S3, ZERO
1927:                         OPCODE_END
9D005300  1C400003   BGTZ V0, 0x9D005310
9D005304  AE230054   SW V1, 84(S1)
9D005310  26100003   ADDIU S0, S0, 3
9D00532C  90420000   LBU V0, 0(V0)
9D005330  00021080   SLL V0, V0, 2
9D005334  00561021   ADDU V0, V0, S6
9D005338  8C420000   LW V0, 0(V0)
9D00533C  0B400152   J 0x9D000548
9D005340  0260A821   ADDU S5, S3, ZERO
1928:                
1929:                      OPCODE_BEGIN(7F)  /* RRA $nnnn,X */
1930:                         RRA(7, ABS_IND_X, mem_writebyte, addr);
9D005348  26120002   ADDIU S2, S0, 2
9D00538C  027E9821   ADDU S3, S3, FP
9D005390  3273FFFF   ANDI S3, S3, -1
9D005394  0F400000   JAL mem_readbyte
9D005398  02602021   ADDU A0, S3, ZERO
9D00539C  AFA20018   SW V0, 24(SP)
9D0053A0  7C553840   EXT S5, V0, 1, 8
9D0053A4  0017B9C0   SLL S7, S7, 7
9D0053A8  02B7A825   OR S5, S5, S7
9D0053AC  32B500FF   ANDI S5, S5, 255
9D0053B0  02602021   ADDU A0, S3, ZERO
9D0053B4  0F400036   JAL mem_writebyte
9D0053B8  02A02821   ADDU A1, S5, ZERO
9D0053BC  02959821   ADDU S3, S4, S5
9D0053C0  8FA30018   LW V1, 24(SP)
9D0053C4  30620001   ANDI V0, V1, 1
9D0053C8  02629821   ADDU S3, S3, V0
9D0053CC  7E770200   EXT S7, S3, 8, 1
9D0053D0  327300FF   ANDI S3, S3, 255
9D0053D4  02B41026   XOR V0, S5, S4
9D0053D8  00021027   NOR V0, ZERO, V0
9D0053DC  7C023004   INS V0, ZERO, 0, 7
9D0053E0  0274A026   XOR S4, S3, S4
9D0053E4  00541024   AND V0, V0, S4
9D0053E8  304200FF   ANDI V0, V0, 255
9D0053EC  AFA20018   SW V0, 24(SP)
9D0053F0  8F828058   LW V0, -32680(GP)
9D0053F4  2442FFF9   ADDIU V0, V0, -7
9D0053F8  AF828058   SW V0, -32680(GP)
9D0053FC  8E230054   LW V1, 84(S1)
9D005400  24630007   ADDIU V1, V1, 7
9D00540C  0260A021   ADDU S4, S3, ZERO
9D005410  0B4027B2   J .L45
9D005414  0260A821   ADDU S5, S3, ZERO
9D005444  0260A021   ADDU S4, S3, ZERO
1931:                         OPCODE_END
9D005404  1C400004   BGTZ V0, 0x9D005418
9D005408  AE230054   SW V1, 84(S1)
9D005418  26100003   ADDIU S0, S0, 3
9D005434  90420000   LBU V0, 0(V0)
9D005438  00021080   SLL V0, V0, 2
9D00543C  00561021   ADDU V0, V0, S6
9D005440  8C420000   LW V0, 0(V0)
9D005448  0B400152   J 0x9D000548
9D00544C  0260A821   ADDU S5, S3, ZERO
1932:                
1933:                      OPCODE_BEGIN(80)  /* NOP #$nn */
1934:                      OPCODE_BEGIN(82)  /* NOP #$nn */
1935:                      OPCODE_BEGIN(89)  /* NOP #$nn */
1936:                      OPCODE_BEGIN(C2)  /* NOP #$nn */
1937:                      OPCODE_BEGIN(E2)  /* NOP #$nn */
1938:                         DOP(2);
9D005450  0B40151B   J 0x9D00546C
9D005454  26120001   ADDIU S2, S0, 1
9D005458  0B40151B   J 0x9D00546C
9D00545C  26120001   ADDIU S2, S0, 1
9D005460  0B40151B   J 0x9D00546C
9D005464  26120001   ADDIU S2, S0, 1
9D005468  26120001   ADDIU S2, S0, 1
9D00546C  8F828058   LW V0, -32680(GP)
9D005470  2442FFFE   ADDIU V0, V0, -2
9D005474  AF828058   SW V0, -32680(GP)
9D005478  8E230054   LW V1, 84(S1)
9D00547C  24630002   ADDIU V1, V1, 2
1939:                         OPCODE_END
9D005480  18401291   BLEZ V0, .L45
9D005484  AE230054   SW V1, 84(S1)
9D005488  26100002   ADDIU S0, S0, 2
9D0054A4  92420000   LBU V0, 0(S2)
9D0054A8  00021080   SLL V0, V0, 2
9D0054AC  00561021   ADDU V0, V0, S6
9D0054B0  0B400152   J 0x9D000548
9D0054B4  8C420000   LW V0, 0(V0)
1940:                
1941:                      OPCODE_BEGIN(81)  /* STA ($nn,X) */
1942:                         STA(6, INDIR_X_ADDR, mem_writebyte, addr);
9D0054B8  26120001   ADDIU S2, S0, 1
9D0054D4  90420000   LBU V0, 0(V0)
9D0054D8  03C21021   ADDU V0, FP, V0
9D0054F4  308400FF   ANDI A0, A0, 255
9D0054F8  0F400036   JAL mem_writebyte
9D0054FC  02802821   ADDU A1, S4, ZERO
9D005500  8F828058   LW V0, -32680(GP)
9D005504  2442FFFA   ADDIU V0, V0, -6
9D005508  AF828058   SW V0, -32680(GP)
9D00550C  8E230054   LW V1, 84(S1)
9D005510  24630006   ADDIU V1, V1, 6
1943:                         OPCODE_END
9D005514  1840126C   BLEZ V0, .L45
9D005518  AE230054   SW V1, 84(S1)
9D00551C  26100002   ADDIU S0, S0, 2
9D005538  90420000   LBU V0, 0(V0)
9D00553C  00021080   SLL V0, V0, 2
9D005540  00561021   ADDU V0, V0, S6
9D005544  0B400152   J 0x9D000548
9D005548  8C420000   LW V0, 0(V0)
1944:                
1945:                      OPCODE_BEGIN(83)  /* SAX ($nn,X) */
1946:                         SAX(6, INDIR_X_ADDR, mem_writebyte, addr);
9D00554C  26120001   ADDIU S2, S0, 1
9D005568  90420000   LBU V0, 0(V0)
9D00556C  03C21021   ADDU V0, FP, V0
9D005588  03D42824   AND A1, FP, S4
9D00558C  308400FF   ANDI A0, A0, 255
9D005590  0F400036   JAL mem_writebyte
9D005594  30A500FF   ANDI A1, A1, 255
9D005598  8F828058   LW V0, -32680(GP)
9D00559C  2442FFFA   ADDIU V0, V0, -6
9D0055A0  AF828058   SW V0, -32680(GP)
9D0055A4  8E230054   LW V1, 84(S1)
9D0055A8  24630006   ADDIU V1, V1, 6
1947:                         OPCODE_END
9D0055AC  18401246   BLEZ V0, .L45
9D0055B0  AE230054   SW V1, 84(S1)
9D0055B4  26100002   ADDIU S0, S0, 2
9D0055D0  90420000   LBU V0, 0(V0)
9D0055D4  00021080   SLL V0, V0, 2
9D0055D8  00561021   ADDU V0, V0, S6
9D0055DC  0B400152   J 0x9D000548
9D0055E0  8C420000   LW V0, 0(V0)
1948:                
1949:                      OPCODE_BEGIN(84)  /* STY $nn */
1950:                         STY(3, ZERO_PAGE_ADDR, ZP_WRITEBYTE, baddr);
9D0055E4  26120001   ADDIU S2, S0, 1
9D005600  90420000   LBU V0, 0(V0)
9D005604  8F838054   LW V1, -32684(GP)
9D005608  00621021   ADDU V0, V1, V0
9D00560C  8FA40010   LW A0, 16(SP)
9D005610  A0440000   SB A0, 0(V0)
9D005614  8F828058   LW V0, -32680(GP)
9D005618  2442FFFD   ADDIU V0, V0, -3
9D00561C  AF828058   SW V0, -32680(GP)
9D005620  8E230054   LW V1, 84(S1)
9D005624  24630003   ADDIU V1, V1, 3
1951:                         OPCODE_END
9D005628  18401227   BLEZ V0, .L45
9D00562C  AE230054   SW V1, 84(S1)
9D005630  26100002   ADDIU S0, S0, 2
9D00564C  90420000   LBU V0, 0(V0)
9D005650  00021080   SLL V0, V0, 2
9D005654  00561021   ADDU V0, V0, S6
9D005658  0B400152   J 0x9D000548
9D00565C  8C420000   LW V0, 0(V0)
1952:                
1953:                      OPCODE_BEGIN(85)  /* STA $nn */
1954:                         STA(3, ZERO_PAGE_ADDR, ZP_WRITEBYTE, baddr);
9D005660  26120001   ADDIU S2, S0, 1
9D00567C  90420000   LBU V0, 0(V0)
9D005680  8F838054   LW V1, -32684(GP)
9D005684  00621021   ADDU V0, V1, V0
9D005688  A0540000   SB S4, 0(V0)
9D00568C  8F828058   LW V0, -32680(GP)
9D005690  2442FFFD   ADDIU V0, V0, -3
9D005694  AF828058   SW V0, -32680(GP)
9D005698  8E230054   LW V1, 84(S1)
9D00569C  24630003   ADDIU V1, V1, 3
1955:                         OPCODE_END
9D0056A0  18401209   BLEZ V0, .L45
9D0056A4  AE230054   SW V1, 84(S1)
9D0056A8  26100002   ADDIU S0, S0, 2
9D0056C4  90420000   LBU V0, 0(V0)
9D0056C8  00021080   SLL V0, V0, 2
9D0056CC  00561021   ADDU V0, V0, S6
9D0056D0  0B400152   J 0x9D000548
9D0056D4  8C420000   LW V0, 0(V0)
1956:                
1957:                      OPCODE_BEGIN(86)  /* STX $nn */
1958:                         STX(3, ZERO_PAGE_ADDR, ZP_WRITEBYTE, baddr);
9D0056D8  26120001   ADDIU S2, S0, 1
9D0056F4  90420000   LBU V0, 0(V0)
9D0056F8  8F838054   LW V1, -32684(GP)
9D0056FC  00621021   ADDU V0, V1, V0
9D005700  A05E0000   SB FP, 0(V0)
9D005704  8F828058   LW V0, -32680(GP)
9D005708  2442FFFD   ADDIU V0, V0, -3
9D00570C  AF828058   SW V0, -32680(GP)
9D005710  8E230054   LW V1, 84(S1)
9D005714  24630003   ADDIU V1, V1, 3
1959:                         OPCODE_END
9D005718  184011EB   BLEZ V0, .L45
9D00571C  AE230054   SW V1, 84(S1)
9D005720  26100002   ADDIU S0, S0, 2
9D00573C  90420000   LBU V0, 0(V0)
9D005740  00021080   SLL V0, V0, 2
9D005744  00561021   ADDU V0, V0, S6
9D005748  0B400152   J 0x9D000548
9D00574C  8C420000   LW V0, 0(V0)
1960:                
1961:                      OPCODE_BEGIN(87)  /* SAX $nn */
1962:                         SAX(3, ZERO_PAGE_ADDR, ZP_WRITEBYTE, baddr);
9D005750  26120001   ADDIU S2, S0, 1
9D00576C  90420000   LBU V0, 0(V0)
9D005770  8F838054   LW V1, -32684(GP)
9D005774  00621021   ADDU V0, V1, V0
9D005778  03D41824   AND V1, FP, S4
9D00577C  A0430000   SB V1, 0(V0)
9D005780  8F828058   LW V0, -32680(GP)
9D005784  2442FFFD   ADDIU V0, V0, -3
9D005788  AF828058   SW V0, -32680(GP)
9D00578C  8E230054   LW V1, 84(S1)
9D005790  24630003   ADDIU V1, V1, 3
1963:                         OPCODE_END
9D005794  184011CC   BLEZ V0, .L45
9D005798  AE230054   SW V1, 84(S1)
9D00579C  26100002   ADDIU S0, S0, 2
9D0057B8  90420000   LBU V0, 0(V0)
9D0057BC  00021080   SLL V0, V0, 2
9D0057C0  00561021   ADDU V0, V0, S6
9D0057C4  0B400152   J 0x9D000548
9D0057C8  8C420000   LW V0, 0(V0)
1964:                
1965:                      OPCODE_BEGIN(88)  /* DEY */
1966:                         DEY();
9D0057CC  8FA50010   LW A1, 16(SP)
9D0057D0  24B3FFFF   ADDIU S3, A1, -1
9D0057D4  327300FF   ANDI S3, S3, 255
9D0057D8  8F828058   LW V0, -32680(GP)
9D0057DC  2442FFFE   ADDIU V0, V0, -2
9D0057E0  AF828058   SW V0, -32680(GP)
9D0057E4  8E230054   LW V1, 84(S1)
9D0057E8  24630002   ADDIU V1, V1, 2
9D0057F4  AFB30010   SW S3, 16(SP)
9D0057FC  0B4027B2   J .L45
9D005800  0260A821   ADDU S5, S3, ZERO
9D00582C  AFB30010   SW S3, 16(SP)
1967:                         OPCODE_END
9D0057EC  1C400005   BGTZ V0, .LBB1436
9D0057F0  AE230054   SW V1, 84(S1)
9D0057F8  02009021   ADDU S2, S0, ZERO
9D00581C  90420000   LBU V0, 0(V0)
9D005820  00021080   SLL V0, V0, 2
9D005824  00561021   ADDU V0, V0, S6
9D005828  8C420000   LW V0, 0(V0)
9D005830  26100001   ADDIU S0, S0, 1
9D005834  0B400152   J 0x9D000548
9D005838  0260A821   ADDU S5, S3, ZERO
1968:                
1969:                      OPCODE_BEGIN(8A)  /* TXA */
1970:                         TXA();
9D00583C  8F828058   LW V0, -32680(GP)
9D005840  2442FFFE   ADDIU V0, V0, -2
9D005844  AF828058   SW V0, -32680(GP)
9D005848  8E230054   LW V1, 84(S1)
9D00584C  24630002   ADDIU V1, V1, 2
1971:                         OPCODE_END
9D005850  1C400006   BGTZ V0, .LBB1438
9D005854  AE230054   SW V1, 84(S1)
9D005858  03C09821   ADDU S3, FP, ZERO
9D00585C  03C0A021   ADDU S4, FP, ZERO
9D005860  02009021   ADDU S2, S0, ZERO
9D005864  0B4027B2   J .L45
9D005868  03C0A821   ADDU S5, FP, ZERO
9D005884  90420000   LBU V0, 0(V0)
9D005888  00021080   SLL V0, V0, 2
9D00588C  00561021   ADDU V0, V0, S6
9D005890  8C420000   LW V0, 0(V0)
9D005894  03C0A021   ADDU S4, FP, ZERO
9D005898  26100001   ADDIU S0, S0, 1
9D00589C  03C0A821   ADDU S5, FP, ZERO
9D0058A0  0B400152   J 0x9D000548
9D0058A4  03C09821   ADDU S3, FP, ZERO
1972:                
1973:                      OPCODE_BEGIN(8B)  /* ANE #$nn */
1974:                         ANE(2, IMMEDIATE_BYTE);
9D0058A8  26120001   ADDIU S2, S0, 1
9D0058AC  2406FFEE   ADDIU A2, ZERO, -18
9D0058B0  02869825   OR S3, S4, A2
9D0058B4  03D39824   AND S3, FP, S3
9D0058D0  90420000   LBU V0, 0(V0)
9D0058D4  02629824   AND S3, S3, V0
9D0058D8  8F828058   LW V0, -32680(GP)
9D0058DC  2442FFFE   ADDIU V0, V0, -2
9D0058E0  AF828058   SW V0, -32680(GP)
9D0058E4  8E230054   LW V1, 84(S1)
9D0058E8  24630002   ADDIU V1, V1, 2
9D0058F4  0260A021   ADDU S4, S3, ZERO
9D0058F8  0B4027B2   J .L45
9D0058FC  0260A821   ADDU S5, S3, ZERO
9D00592C  0260A021   ADDU S4, S3, ZERO
1975:                         OPCODE_END
9D0058EC  1C400004   BGTZ V0, 0x9D005900
9D0058F0  AE230054   SW V1, 84(S1)
9D005900  26100002   ADDIU S0, S0, 2
9D00591C  90420000   LBU V0, 0(V0)
9D005920  00021080   SLL V0, V0, 2
9D005924  00561021   ADDU V0, V0, S6
9D005928  8C420000   LW V0, 0(V0)
9D005930  0B400152   J 0x9D000548
9D005934  0260A821   ADDU S5, S3, ZERO
1976:                
1977:                      OPCODE_BEGIN(8C)  /* STY $nnnn */
1978:                         STY(4, ABSOLUTE_ADDR, mem_writebyte, addr);
9D00593C  26120002   ADDIU S2, S0, 2
9D00597C  308400FF   ANDI A0, A0, 255
9D005980  0F400036   JAL mem_writebyte
9D005984  8FA50010   LW A1, 16(SP)
9D005988  8F828058   LW V0, -32680(GP)
9D00598C  2442FFFC   ADDIU V0, V0, -4
9D005990  AF828058   SW V0, -32680(GP)
9D005994  8E230054   LW V1, 84(S1)
9D005998  24630004   ADDIU V1, V1, 4
1979:                         OPCODE_END
9D00599C  1840114A   BLEZ V0, .L45
9D0059A0  AE230054   SW V1, 84(S1)
9D0059A4  26100003   ADDIU S0, S0, 3
9D0059C0  90420000   LBU V0, 0(V0)
9D0059C4  00021080   SLL V0, V0, 2
9D0059C8  00561021   ADDU V0, V0, S6
9D0059CC  0B400152   J 0x9D000548
9D0059D0  8C420000   LW V0, 0(V0)
1980:                
1981:                      OPCODE_BEGIN(8D)  /* STA $nnnn */
1982:                         STA(4, ABSOLUTE_ADDR, mem_writebyte, addr);
9D0059D8  26120002   ADDIU S2, S0, 2
9D005A18  308400FF   ANDI A0, A0, 255
9D005A1C  0F400036   JAL mem_writebyte
9D005A20  02802821   ADDU A1, S4, ZERO
9D005A24  8F828058   LW V0, -32680(GP)
9D005A28  2442FFFC   ADDIU V0, V0, -4
9D005A2C  AF828058   SW V0, -32680(GP)
9D005A30  8E230054   LW V1, 84(S1)
9D005A34  24630004   ADDIU V1, V1, 4
1983:                         OPCODE_END
9D005A38  18401123   BLEZ V0, .L45
9D005A3C  AE230054   SW V1, 84(S1)
9D005A40  26100003   ADDIU S0, S0, 3
9D005A5C  90420000   LBU V0, 0(V0)
9D005A60  00021080   SLL V0, V0, 2
9D005A64  00561021   ADDU V0, V0, S6
9D005A68  0B400152   J 0x9D000548
9D005A6C  8C420000   LW V0, 0(V0)
1984:                
1985:                      OPCODE_BEGIN(8E)  /* STX $nnnn */
1986:                         STX(4, ABSOLUTE_ADDR, mem_writebyte, addr);
9D005A74  26120002   ADDIU S2, S0, 2
9D005AB4  308400FF   ANDI A0, A0, 255
9D005AB8  0F400036   JAL mem_writebyte
9D005ABC  03C02821   ADDU A1, FP, ZERO
9D005AC0  8F828058   LW V0, -32680(GP)
9D005AC4  2442FFFC   ADDIU V0, V0, -4
9D005AC8  AF828058   SW V0, -32680(GP)
9D005ACC  8E230054   LW V1, 84(S1)
9D005AD0  24630004   ADDIU V1, V1, 4
1987:                         OPCODE_END
9D005AD4  184010FC   BLEZ V0, .L45
9D005AD8  AE230054   SW V1, 84(S1)
9D005ADC  26100003   ADDIU S0, S0, 3
9D005AF8  90420000   LBU V0, 0(V0)
9D005AFC  00021080   SLL V0, V0, 2
9D005B00  00561021   ADDU V0, V0, S6
9D005B04  0B400152   J 0x9D000548
9D005B08  8C420000   LW V0, 0(V0)
1988:                      
1989:                      OPCODE_BEGIN(8F)  /* SAX $nnnn */
1990:                         SAX(4, ABSOLUTE_ADDR, mem_writebyte, addr);
9D005B10  26120002   ADDIU S2, S0, 2
9D005B50  03D42824   AND A1, FP, S4
9D005B54  308400FF   ANDI A0, A0, 255
9D005B58  0F400036   JAL mem_writebyte
9D005B5C  30A500FF   ANDI A1, A1, 255
9D005B60  8F828058   LW V0, -32680(GP)
9D005B64  2442FFFC   ADDIU V0, V0, -4
9D005B68  AF828058   SW V0, -32680(GP)
9D005B6C  8E230054   LW V1, 84(S1)
9D005B70  24630004   ADDIU V1, V1, 4
1991:                         OPCODE_END
9D005B74  184010D4   BLEZ V0, .L45
9D005B78  AE230054   SW V1, 84(S1)
9D005B7C  26100003   ADDIU S0, S0, 3
9D005B98  90420000   LBU V0, 0(V0)
9D005B9C  00021080   SLL V0, V0, 2
9D005BA0  00561021   ADDU V0, V0, S6
9D005BA4  0B400152   J 0x9D000548
9D005BA8  8C420000   LW V0, 0(V0)
1992:                
1993:                      OPCODE_BEGIN(90)  /* BCC $nnnn */
1994:                         BCC();
9D005BAC  16E0001B   BNE S7, ZERO, 0x9D005C1C
9D005BB0  26120001   ADDIU S2, S0, 1
9D005BB4  26020001   ADDIU V0, S0, 1
9D005BD0  80720000   LB S2, 0(V1)
9D005BD4  304300FF   ANDI V1, V0, 255
9D005BD8  02431821   ADDU V1, S2, V1
9D005BDC  30630100   ANDI V1, V1, 256
9D005BE0  10600007   BEQ V1, ZERO, 0x9D005C00
9D005BE4  8F838058   LW V1, -32680(GP)
9D005BE8  2463FFFF   ADDIU V1, V1, -1
9D005BEC  AF838058   SW V1, -32680(GP)
9D005BF0  8E230054   LW V1, 84(S1)
9D005BF4  24630001   ADDIU V1, V1, 1
9D005BF8  AE230054   SW V1, 84(S1)
9D005BFC  8F838058   LW V1, -32680(GP)
9D005C00  2463FFFD   ADDIU V1, V1, -3
9D005C04  AF838058   SW V1, -32680(GP)
9D005C08  8E230054   LW V1, 84(S1)
9D005C0C  24630003   ADDIU V1, V1, 3
9D005C10  AE230054   SW V1, 84(S1)
9D005C14  0B40170D   J 0x9D005C34
9D005C18  02429021   ADDU S2, S2, V0
9D005C1C  8F828058   LW V0, -32680(GP)
9D005C20  2442FFFE   ADDIU V0, V0, -2
9D005C24  AF828058   SW V0, -32680(GP)
9D005C28  8E220054   LW V0, 84(S1)
9D005C2C  24420002   ADDIU V0, V0, 2
9D005C30  AE220054   SW V0, 84(S1)
1995:                         OPCODE_END
9D005C34  8F828058   LW V0, -32680(GP)
9D005C38  184010A3   BLEZ V0, .L45
9D005C3C  26500001   ADDIU S0, S2, 1
9D005C58  90420000   LBU V0, 0(V0)
9D005C5C  00021080   SLL V0, V0, 2
9D005C60  00561021   ADDU V0, V0, S6
9D005C64  0B400152   J 0x9D000548
9D005C68  8C420000   LW V0, 0(V0)
1996:                
1997:                      OPCODE_BEGIN(91)  /* STA ($nn),Y */
1998:                         STA(6, INDIR_Y_ADDR, mem_writebyte, addr);
9D005C6C  26120001   ADDIU S2, S0, 1
9D005CA4  8FA70010   LW A3, 16(SP)
9D005CA8  00872021   ADDU A0, A0, A3
9D005CAC  3084FFFF   ANDI A0, A0, -1
9D005CB0  0F400036   JAL mem_writebyte
9D005CB4  02802821   ADDU A1, S4, ZERO
9D005CB8  8F828058   LW V0, -32680(GP)
9D005CBC  2442FFFA   ADDIU V0, V0, -6
9D005CC0  AF828058   SW V0, -32680(GP)
9D005CC4  8E230054   LW V1, 84(S1)
9D005CC8  24630006   ADDIU V1, V1, 6
1999:                         OPCODE_END
9D005CCC  1840107E   BLEZ V0, .L45
9D005CD0  AE230054   SW V1, 84(S1)
9D005CD4  26100002   ADDIU S0, S0, 2
9D005CF0  90420000   LBU V0, 0(V0)
9D005CF4  00021080   SLL V0, V0, 2
9D005CF8  00561021   ADDU V0, V0, S6
9D005CFC  0B400152   J 0x9D000548
9D005D00  8C420000   LW V0, 0(V0)
2000:                
2001:                      OPCODE_BEGIN(93)  /* SHA ($nn),Y */
2002:                         SHA(6, INDIR_Y_ADDR, mem_writebyte, addr);
9D005D04  26120001   ADDIU S2, S0, 1
9D005D3C  8FA80010   LW T0, 16(SP)
9D005D40  00882021   ADDU A0, A0, T0
9D005D44  3084FFFF   ANDI A0, A0, -1
9D005D48  03D42824   AND A1, FP, S4
9D005D4C  00041202   SRL V0, A0, 8
9D005D50  24420001   ADDIU V0, V0, 1
9D005D54  00A22824   AND A1, A1, V0
9D005D58  0F400036   JAL mem_writebyte
9D005D5C  30A500FF   ANDI A1, A1, 255
9D005D60  8F828058   LW V0, -32680(GP)
9D005D64  2442FFFA   ADDIU V0, V0, -6
9D005D68  AF828058   SW V0, -32680(GP)
9D005D6C  8E230054   LW V1, 84(S1)
9D005D70  24630006   ADDIU V1, V1, 6
2003:                         OPCODE_END
9D005D74  18401054   BLEZ V0, .L45
9D005D78  AE230054   SW V1, 84(S1)
9D005D7C  26100002   ADDIU S0, S0, 2
9D005D98  90420000   LBU V0, 0(V0)
9D005D9C  00021080   SLL V0, V0, 2
9D005DA0  00561021   ADDU V0, V0, S6
9D005DA4  0B400152   J 0x9D000548
9D005DA8  8C420000   LW V0, 0(V0)
2004:                
2005:                      OPCODE_BEGIN(94)  /* STY $nn,X */
2006:                         STY(4, ZP_IND_X_ADDR, ZP_WRITEBYTE, baddr);
9D005DAC  26120001   ADDIU S2, S0, 1
9D005DC8  90420000   LBU V0, 0(V0)
9D005DCC  03C21021   ADDU V0, FP, V0
9D005DD0  304200FF   ANDI V0, V0, 255
9D005DD4  8F838054   LW V1, -32684(GP)
9D005DD8  00621021   ADDU V0, V1, V0
9D005DDC  8FA30010   LW V1, 16(SP)
9D005DE0  A0430000   SB V1, 0(V0)
9D005DE4  8F828058   LW V0, -32680(GP)
9D005DE8  2442FFFC   ADDIU V0, V0, -4
9D005DEC  AF828058   SW V0, -32680(GP)
9D005DF0  8E230054   LW V1, 84(S1)
9D005DF4  24630004   ADDIU V1, V1, 4
2007:                         OPCODE_END
9D005DF8  18401033   BLEZ V0, .L45
9D005DFC  AE230054   SW V1, 84(S1)
9D005E00  26100002   ADDIU S0, S0, 2
9D005E1C  90420000   LBU V0, 0(V0)
9D005E20  00021080   SLL V0, V0, 2
9D005E24  00561021   ADDU V0, V0, S6
9D005E28  0B400152   J 0x9D000548
9D005E2C  8C420000   LW V0, 0(V0)
2008:                
2009:                      OPCODE_BEGIN(95)  /* STA $nn,X */
2010:                         STA(4, ZP_IND_X_ADDR, ZP_WRITEBYTE, baddr);
9D005E30  26120001   ADDIU S2, S0, 1
9D005E4C  90420000   LBU V0, 0(V0)
9D005E50  03C21021   ADDU V0, FP, V0
9D005E54  304200FF   ANDI V0, V0, 255
9D005E58  8F838054   LW V1, -32684(GP)
9D005E5C  00621021   ADDU V0, V1, V0
9D005E60  A0540000   SB S4, 0(V0)
9D005E64  8F828058   LW V0, -32680(GP)
9D005E68  2442FFFC   ADDIU V0, V0, -4
9D005E6C  AF828058   SW V0, -32680(GP)
9D005E70  8E230054   LW V1, 84(S1)
9D005E74  24630004   ADDIU V1, V1, 4
2011:                         OPCODE_END
9D005E78  18401013   BLEZ V0, .L45
9D005E7C  AE230054   SW V1, 84(S1)
9D005E80  26100002   ADDIU S0, S0, 2
9D005E9C  90420000   LBU V0, 0(V0)
9D005EA0  00021080   SLL V0, V0, 2
9D005EA4  00561021   ADDU V0, V0, S6
9D005EA8  0B400152   J 0x9D000548
9D005EAC  8C420000   LW V0, 0(V0)
2012:                
2013:                      OPCODE_BEGIN(96)  /* STX $nn,Y */
2014:                         STX(4, ZP_IND_Y_ADDR, ZP_WRITEBYTE, baddr);
9D005EB0  26120001   ADDIU S2, S0, 1
9D005ECC  90420000   LBU V0, 0(V0)
9D005ED0  8FA40010   LW A0, 16(SP)
9D005ED4  00821021   ADDU V0, A0, V0
9D005ED8  304200FF   ANDI V0, V0, 255
9D005EDC  8F838054   LW V1, -32684(GP)
9D005EE0  00621021   ADDU V0, V1, V0
9D005EE4  A05E0000   SB FP, 0(V0)
9D005EE8  8F828058   LW V0, -32680(GP)
9D005EEC  2442FFFC   ADDIU V0, V0, -4
9D005EF0  AF828058   SW V0, -32680(GP)
9D005EF4  8E230054   LW V1, 84(S1)
9D005EF8  24630004   ADDIU V1, V1, 4
2015:                         OPCODE_END
9D005EFC  18400FF2   BLEZ V0, .L45
9D005F00  AE230054   SW V1, 84(S1)
9D005F04  26100002   ADDIU S0, S0, 2
9D005F20  90420000   LBU V0, 0(V0)
9D005F24  00021080   SLL V0, V0, 2
9D005F28  00561021   ADDU V0, V0, S6
9D005F2C  0B400152   J 0x9D000548
9D005F30  8C420000   LW V0, 0(V0)
2016:                
2017:                      OPCODE_BEGIN(97)  /* SAX $nn,Y */
2018:                         SAX(4, ZP_IND_Y_ADDR, ZP_WRITEBYTE, baddr);
9D005F34  26120001   ADDIU S2, S0, 1
9D005F50  90420000   LBU V0, 0(V0)
9D005F54  8FA50010   LW A1, 16(SP)
9D005F58  00A21021   ADDU V0, A1, V0
9D005F5C  304200FF   ANDI V0, V0, 255
9D005F60  8F838054   LW V1, -32684(GP)
9D005F64  00621021   ADDU V0, V1, V0
9D005F68  03D41824   AND V1, FP, S4
9D005F6C  A0430000   SB V1, 0(V0)
9D005F70  8F828058   LW V0, -32680(GP)
9D005F74  2442FFFC   ADDIU V0, V0, -4
9D005F78  AF828058   SW V0, -32680(GP)
9D005F7C  8E230054   LW V1, 84(S1)
9D005F80  24630004   ADDIU V1, V1, 4
2019:                         OPCODE_END
9D005F84  18400FD0   BLEZ V0, .L45
9D005F88  AE230054   SW V1, 84(S1)
9D005F8C  26100002   ADDIU S0, S0, 2
9D005FA8  90420000   LBU V0, 0(V0)
9D005FAC  00021080   SLL V0, V0, 2
9D005FB0  00561021   ADDU V0, V0, S6
9D005FB4  0B400152   J 0x9D000548
9D005FB8  8C420000   LW V0, 0(V0)
2020:                
2021:                      OPCODE_BEGIN(98)  /* TYA */
2022:                         TYA();
9D005FBC  8F828058   LW V0, -32680(GP)
9D005FC0  2442FFFE   ADDIU V0, V0, -2
9D005FC4  AF828058   SW V0, -32680(GP)
9D005FC8  8E230054   LW V1, 84(S1)
9D005FCC  24630002   ADDIU V1, V1, 2
2023:                         OPCODE_END
9D005FD0  1C400006   BGTZ V0, .LBB1500
9D005FD4  AE230054   SW V1, 84(S1)
9D005FD8  8FB30010   LW S3, 16(SP)
9D005FDC  0260A021   ADDU S4, S3, ZERO
9D005FE0  02009021   ADDU S2, S0, ZERO
9D005FE4  0B4027B2   J .L45
9D005FE8  0260A821   ADDU S5, S3, ZERO
9D006004  90420000   LBU V0, 0(V0)
9D006008  00021080   SLL V0, V0, 2
9D00600C  00561021   ADDU V0, V0, S6
9D006010  8C420000   LW V0, 0(V0)
9D006014  8FB40010   LW S4, 16(SP)
9D006018  26100001   ADDIU S0, S0, 1
9D00601C  0280A821   ADDU S5, S4, ZERO
9D006020  0B400152   J 0x9D000548
9D006024  02809821   ADDU S3, S4, ZERO
2024:                
2025:                      OPCODE_BEGIN(99)  /* STA $nnnn,Y */
2026:                         STA(5, ABS_IND_Y_ADDR, mem_writebyte, addr);
9D00602C  26120002   ADDIU S2, S0, 2
9D006070  8FA60010   LW A2, 16(SP)
9D006074  00862021   ADDU A0, A0, A2
9D006078  3084FFFF   ANDI A0, A0, -1
9D00607C  0F400036   JAL mem_writebyte
9D006080  02802821   ADDU A1, S4, ZERO
9D006084  8F828058   LW V0, -32680(GP)
9D006088  2442FFFB   ADDIU V0, V0, -5
9D00608C  AF828058   SW V0, -32680(GP)
9D006090  8E230054   LW V1, 84(S1)
9D006094  24630005   ADDIU V1, V1, 5
2027:                         OPCODE_END
9D006098  18400F8B   BLEZ V0, .L45
9D00609C  AE230054   SW V1, 84(S1)
9D0060A0  26100003   ADDIU S0, S0, 3
9D0060BC  90420000   LBU V0, 0(V0)
9D0060C0  00021080   SLL V0, V0, 2
9D0060C4  00561021   ADDU V0, V0, S6
9D0060C8  0B400152   J 0x9D000548
9D0060CC  8C420000   LW V0, 0(V0)
2028:                
2029:                      OPCODE_BEGIN(9A)  /* TXS */
2030:                         TXS();
9D0060D0  8F828058   LW V0, -32680(GP)
9D0060D4  2442FFFE   ADDIU V0, V0, -2
9D0060D8  AF828058   SW V0, -32680(GP)
9D0060DC  8E230054   LW V1, 84(S1)
9D0060E0  24630002   ADDIU V1, V1, 2
2031:                         OPCODE_END
9D0060E4  1C400004   BGTZ V0, .LBB1508
9D0060E8  AE230054   SW V1, 84(S1)
9D0060EC  AFBE0014   SW FP, 20(SP)
9D0060F0  0B4027B2   J .L45
9D0060F4  02009021   ADDU S2, S0, ZERO
9D006110  90420000   LBU V0, 0(V0)
9D006114  00021080   SLL V0, V0, 2
9D006118  00561021   ADDU V0, V0, S6
9D00611C  8C420000   LW V0, 0(V0)
9D006120  AFBE0014   SW FP, 20(SP)
9D006124  0B400152   J 0x9D000548
9D006128  26100001   ADDIU S0, S0, 1
2032:                
2033:                      OPCODE_BEGIN(9B)  /* SHS $nnnn,Y */
2034:                         SHS(5, ABS_IND_Y_ADDR, mem_writebyte, addr);
9D006130  26120002   ADDIU S2, S0, 2
9D006174  8FA70010   LW A3, 16(SP)
9D006178  00872021   ADDU A0, A0, A3
9D00617C  3084FFFF   ANDI A0, A0, -1
9D006180  03D41024   AND V0, FP, S4
9D006184  304200FF   ANDI V0, V0, 255
9D006188  AFA20014   SW V0, 20(SP)
9D00618C  00042A02   SRL A1, A0, 8
9D006190  24A50001   ADDIU A1, A1, 1
9D006194  0F400036   JAL mem_writebyte
9D006198  00452824   AND A1, V0, A1
9D00619C  8F828058   LW V0, -32680(GP)
9D0061A0  2442FFFB   ADDIU V0, V0, -5
9D0061A4  AF828058   SW V0, -32680(GP)
9D0061A8  8E230054   LW V1, 84(S1)
9D0061AC  24630005   ADDIU V1, V1, 5
2035:                         OPCODE_END
9D0061B0  18400F45   BLEZ V0, .L45
9D0061B4  AE230054   SW V1, 84(S1)
9D0061B8  26100003   ADDIU S0, S0, 3
9D0061D4  90420000   LBU V0, 0(V0)
9D0061D8  00021080   SLL V0, V0, 2
9D0061DC  00561021   ADDU V0, V0, S6
9D0061E0  0B400152   J 0x9D000548
9D0061E4  8C420000   LW V0, 0(V0)
2036:                
2037:                      OPCODE_BEGIN(9C)  /* SHY $nnnn,X */
2038:                         SHY(5, ABS_IND_X_ADDR, mem_writebyte, addr);
9D0061EC  26120002   ADDIU S2, S0, 2
9D006230  009E2021   ADDU A0, A0, FP
9D006234  3084FFFF   ANDI A0, A0, -1
9D006238  00042A02   SRL A1, A0, 8
9D00623C  24A50001   ADDIU A1, A1, 1
9D006240  8FA80010   LW T0, 16(SP)
9D006244  01052824   AND A1, T0, A1
9D006248  0F400036   JAL mem_writebyte
9D00624C  30A500FF   ANDI A1, A1, 255
9D006250  8F828058   LW V0, -32680(GP)
9D006254  2442FFFB   ADDIU V0, V0, -5
9D006258  AF828058   SW V0, -32680(GP)
9D00625C  8E230054   LW V1, 84(S1)
9D006260  24630005   ADDIU V1, V1, 5
2039:                         OPCODE_END
9D006264  18400F18   BLEZ V0, .L45
9D006268  AE230054   SW V1, 84(S1)
9D00626C  26100003   ADDIU S0, S0, 3
9D006288  90420000   LBU V0, 0(V0)
9D00628C  00021080   SLL V0, V0, 2
9D006290  00561021   ADDU V0, V0, S6
9D006294  0B400152   J 0x9D000548
9D006298  8C420000   LW V0, 0(V0)
2040:                
2041:                      OPCODE_BEGIN(9D)  /* STA $nnnn,X */
2042:                         STA(5, ABS_IND_X_ADDR, mem_writebyte, addr);
9D0062A0  26120002   ADDIU S2, S0, 2
9D0062E4  009E2021   ADDU A0, A0, FP
9D0062E8  3084FFFF   ANDI A0, A0, -1
9D0062EC  0F400036   JAL mem_writebyte
9D0062F0  02802821   ADDU A1, S4, ZERO
9D0062F4  8F828058   LW V0, -32680(GP)
9D0062F8  2442FFFB   ADDIU V0, V0, -5
9D0062FC  AF828058   SW V0, -32680(GP)
9D006300  8E230054   LW V1, 84(S1)
9D006304  24630005   ADDIU V1, V1, 5
2043:                         OPCODE_END
9D006308  18400EEF   BLEZ V0, .L45
9D00630C  AE230054   SW V1, 84(S1)
9D006310  26100003   ADDIU S0, S0, 3
9D00632C  90420000   LBU V0, 0(V0)
9D006330  00021080   SLL V0, V0, 2
9D006334  00561021   ADDU V0, V0, S6
9D006338  0B400152   J 0x9D000548
9D00633C  8C420000   LW V0, 0(V0)
2044:                
2045:                      OPCODE_BEGIN(9E)  /* SHX $nnnn,Y */
2046:                         SHX(5, ABS_IND_Y_ADDR, mem_writebyte, addr);
9D006344  26120002   ADDIU S2, S0, 2
9D006388  8FA20010   LW V0, 16(SP)
9D00638C  00822021   ADDU A0, A0, V0
9D006390  3084FFFF   ANDI A0, A0, -1
9D006394  00042A02   SRL A1, A0, 8
9D006398  24A50001   ADDIU A1, A1, 1
9D00639C  03C52824   AND A1, FP, A1
9D0063A0  0F400036   JAL mem_writebyte
9D0063A4  30A500FF   ANDI A1, A1, 255
9D0063A8  8F828058   LW V0, -32680(GP)
9D0063AC  2442FFFB   ADDIU V0, V0, -5
9D0063B0  AF828058   SW V0, -32680(GP)
9D0063B4  8E230054   LW V1, 84(S1)
9D0063B8  24630005   ADDIU V1, V1, 5
2047:                         OPCODE_END
9D0063BC  18400EC2   BLEZ V0, .L45
9D0063C0  AE230054   SW V1, 84(S1)
9D0063C4  26100003   ADDIU S0, S0, 3
9D0063E0  90420000   LBU V0, 0(V0)
9D0063E4  00021080   SLL V0, V0, 2
9D0063E8  00561021   ADDU V0, V0, S6
9D0063EC  0B400152   J 0x9D000548
9D0063F0  8C420000   LW V0, 0(V0)
2048:                
2049:                      OPCODE_BEGIN(9F)  /* SHA $nnnn,Y */
2050:                         SHA(5, ABS_IND_Y_ADDR, mem_writebyte, addr);
9D0063F8  26120002   ADDIU S2, S0, 2
9D00643C  8FA30010   LW V1, 16(SP)
9D006440  00832021   ADDU A0, A0, V1
9D006444  3084FFFF   ANDI A0, A0, -1
9D006448  03D42824   AND A1, FP, S4
9D00644C  00041202   SRL V0, A0, 8
9D006450  24420001   ADDIU V0, V0, 1
9D006454  00A22824   AND A1, A1, V0
9D006458  0F400036   JAL mem_writebyte
9D00645C  30A500FF   ANDI A1, A1, 255
9D006460  8F828058   LW V0, -32680(GP)
9D006464  2442FFFB   ADDIU V0, V0, -5
9D006468  AF828058   SW V0, -32680(GP)
9D00646C  8E230054   LW V1, 84(S1)
9D006470  24630005   ADDIU V1, V1, 5
2051:                         OPCODE_END
9D006474  18400E94   BLEZ V0, .L45
9D006478  AE230054   SW V1, 84(S1)
9D00647C  26100003   ADDIU S0, S0, 3
9D006498  90420000   LBU V0, 0(V0)
9D00649C  00021080   SLL V0, V0, 2
9D0064A0  00561021   ADDU V0, V0, S6
9D0064A4  0B400152   J 0x9D000548
9D0064A8  8C420000   LW V0, 0(V0)
2052:                      
2053:                      OPCODE_BEGIN(A0)  /* LDY #$nn */
2054:                         LDY(2, IMMEDIATE_BYTE);
9D0064AC  26120001   ADDIU S2, S0, 1
9D0064CC  8F828058   LW V0, -32680(GP)
9D0064D0  2442FFFE   ADDIU V0, V0, -2
9D0064D4  AF828058   SW V0, -32680(GP)
9D0064D8  8E230054   LW V1, 84(S1)
9D0064DC  24630002   ADDIU V1, V1, 2
2055:                         OPCODE_END
9D0064E0  1C400004   BGTZ V0, 0x9D0064F4
9D0064E4  AE230054   SW V1, 84(S1)
9D0064F4  26100002   ADDIU S0, S0, 2
9D006510  90420000   LBU V0, 0(V0)
9D006514  00021080   SLL V0, V0, 2
9D006518  00561021   ADDU V0, V0, S6
9D00651C  8C420000   LW V0, 0(V0)
9D006524  0B400152   J 0x9D000548
9D006528  0260A821   ADDU S5, S3, ZERO
2056:                
2057:                      OPCODE_BEGIN(A1)  /* LDA ($nn,X) */
2058:                         LDA(6, INDIR_X_BYTE);
9D00652C  26120001   ADDIU S2, S0, 1
9D006548  90420000   LBU V0, 0(V0)
9D00654C  03C21021   ADDU V0, FP, V0
9D006568  0F400000   JAL mem_readbyte
9D00656C  308400FF   ANDI A0, A0, 255
9D006570  00409821   ADDU S3, V0, ZERO
9D006574  8F828058   LW V0, -32680(GP)
9D006578  2442FFFA   ADDIU V0, V0, -6
9D00657C  AF828058   SW V0, -32680(GP)
9D006580  8E230054   LW V1, 84(S1)
9D006584  24630006   ADDIU V1, V1, 6
9D006590  0260A021   ADDU S4, S3, ZERO
9D006594  0B4027B2   J .L45
9D006598  0260A821   ADDU S5, S3, ZERO
9D0065C8  0260A021   ADDU S4, S3, ZERO
2059:                         OPCODE_END
9D006588  1C400004   BGTZ V0, 0x9D00659C
9D00658C  AE230054   SW V1, 84(S1)
9D00659C  26100002   ADDIU S0, S0, 2
9D0065B8  90420000   LBU V0, 0(V0)
9D0065BC  00021080   SLL V0, V0, 2
9D0065C0  00561021   ADDU V0, V0, S6
9D0065C4  8C420000   LW V0, 0(V0)
9D0065CC  0B400152   J 0x9D000548
9D0065D0  0260A821   ADDU S5, S3, ZERO
2060:                
2061:                      OPCODE_BEGIN(A2)  /* LDX #$nn */
2062:                         LDX(2, IMMEDIATE_BYTE);
9D0065D4  26120001   ADDIU S2, S0, 1
9D0065F4  8F828058   LW V0, -32680(GP)
9D0065F8  2442FFFE   ADDIU V0, V0, -2
9D0065FC  AF828058   SW V0, -32680(GP)
9D006600  8E230054   LW V1, 84(S1)
9D006604  24630002   ADDIU V1, V1, 2
2063:                         OPCODE_END
9D006608  1C400004   BGTZ V0, 0x9D00661C
9D00660C  AE230054   SW V1, 84(S1)
9D00661C  26100002   ADDIU S0, S0, 2
9D006638  90420000   LBU V0, 0(V0)
9D00663C  00021080   SLL V0, V0, 2
9D006640  00561021   ADDU V0, V0, S6
9D006644  8C420000   LW V0, 0(V0)
9D00664C  0B400152   J 0x9D000548
9D006650  0260A821   ADDU S5, S3, ZERO
2064:                
2065:                      OPCODE_BEGIN(A3)  /* LAX ($nn,X) */
2066:                         LAX(6, INDIR_X_BYTE);
9D006654  26120001   ADDIU S2, S0, 1
9D006670  90420000   LBU V0, 0(V0)
9D006674  03C21021   ADDU V0, FP, V0
9D006690  0F400000   JAL mem_readbyte
9D006694  308400FF   ANDI A0, A0, 255
9D006698  00409821   ADDU S3, V0, ZERO
9D00669C  8F828058   LW V0, -32680(GP)
9D0066A0  2442FFFA   ADDIU V0, V0, -6
9D0066A4  AF828058   SW V0, -32680(GP)
9D0066A8  8E230054   LW V1, 84(S1)
9D0066AC  24630006   ADDIU V1, V1, 6
9D0066B8  0260F021   ADDU FP, S3, ZERO
9D0066BC  0260A021   ADDU S4, S3, ZERO
9D0066C0  0B4027B2   J .L45
9D0066C4  0260A821   ADDU S5, S3, ZERO
9D0066F4  0260F021   ADDU FP, S3, ZERO
9D0066F8  0260A021   ADDU S4, S3, ZERO
2067:                         OPCODE_END
9D0066B0  1C400005   BGTZ V0, 0x9D0066C8
9D0066B4  AE230054   SW V1, 84(S1)
9D0066C8  26100002   ADDIU S0, S0, 2
9D0066E4  90420000   LBU V0, 0(V0)
9D0066E8  00021080   SLL V0, V0, 2
9D0066EC  00561021   ADDU V0, V0, S6
9D0066F0  8C420000   LW V0, 0(V0)
9D0066FC  0B400152   J 0x9D000548
9D006700  0260A821   ADDU S5, S3, ZERO
2068:                
2069:                      OPCODE_BEGIN(A4)  /* LDY $nn */
2070:                         LDY(3, ZERO_PAGE_BYTE);
9D006704  26120001   ADDIU S2, S0, 1
9D006720  90420000   LBU V0, 0(V0)
9D006724  8F838054   LW V1, -32684(GP)
9D006728  00621021   ADDU V0, V1, V0
9D00672C  90530000   LBU S3, 0(V0)
9D006730  8F828058   LW V0, -32680(GP)
9D006734  2442FFFD   ADDIU V0, V0, -3
9D006738  AF828058   SW V0, -32680(GP)
9D00673C  8E230054   LW V1, 84(S1)
9D006740  24630003   ADDIU V1, V1, 3
9D00674C  AFB30010   SW S3, 16(SP)
9D006750  0B4027B2   J .L45
9D006754  0260A821   ADDU S5, S3, ZERO
9D006784  AFB30010   SW S3, 16(SP)
2071:                         OPCODE_END
9D006744  1C400004   BGTZ V0, 0x9D006758
9D006748  AE230054   SW V1, 84(S1)
9D006758  26100002   ADDIU S0, S0, 2
9D006774  90420000   LBU V0, 0(V0)
9D006778  00021080   SLL V0, V0, 2
9D00677C  00561021   ADDU V0, V0, S6
9D006780  8C420000   LW V0, 0(V0)
9D006788  0B400152   J 0x9D000548
9D00678C  0260A821   ADDU S5, S3, ZERO
2072:                
2073:                      OPCODE_BEGIN(A5)  /* LDA $nn */
2074:                         LDA(3, ZERO_PAGE_BYTE);
9D006790  26120001   ADDIU S2, S0, 1
9D0067AC  90420000   LBU V0, 0(V0)
9D0067B0  8F838054   LW V1, -32684(GP)
9D0067B4  00621021   ADDU V0, V1, V0
9D0067B8  90530000   LBU S3, 0(V0)
9D0067BC  8F828058   LW V0, -32680(GP)
9D0067C0  2442FFFD   ADDIU V0, V0, -3
9D0067C4  AF828058   SW V0, -32680(GP)
9D0067C8  8E230054   LW V1, 84(S1)
9D0067CC  24630003   ADDIU V1, V1, 3
9D0067D8  0260A021   ADDU S4, S3, ZERO
9D0067DC  0B4027B2   J .L45
9D0067E0  0260A821   ADDU S5, S3, ZERO
9D006810  0260A021   ADDU S4, S3, ZERO
2075:                         OPCODE_END
9D0067D0  1C400004   BGTZ V0, 0x9D0067E4
9D0067D4  AE230054   SW V1, 84(S1)
9D0067E4  26100002   ADDIU S0, S0, 2
9D006800  90420000   LBU V0, 0(V0)
9D006804  00021080   SLL V0, V0, 2
9D006808  00561021   ADDU V0, V0, S6
9D00680C  8C420000   LW V0, 0(V0)
9D006814  0B400152   J 0x9D000548
9D006818  0260A821   ADDU S5, S3, ZERO
2076:                
2077:                      OPCODE_BEGIN(A6)  /* LDX $nn */
2078:                         LDX(3, ZERO_PAGE_BYTE);
9D00681C  26120001   ADDIU S2, S0, 1
9D006838  90420000   LBU V0, 0(V0)
9D00683C  8F838054   LW V1, -32684(GP)
9D006840  00621021   ADDU V0, V1, V0
9D006844  90530000   LBU S3, 0(V0)
9D006848  8F828058   LW V0, -32680(GP)
9D00684C  2442FFFD   ADDIU V0, V0, -3
9D006850  AF828058   SW V0, -32680(GP)
9D006854  8E230054   LW V1, 84(S1)
9D006858  24630003   ADDIU V1, V1, 3
9D006864  0260F021   ADDU FP, S3, ZERO
9D006868  0B4027B2   J .L45
9D00686C  0260A821   ADDU S5, S3, ZERO
9D00689C  0260F021   ADDU FP, S3, ZERO
2079:                         OPCODE_END
9D00685C  1C400004   BGTZ V0, 0x9D006870
9D006860  AE230054   SW V1, 84(S1)
9D006870  26100002   ADDIU S0, S0, 2
9D00688C  90420000   LBU V0, 0(V0)
9D006890  00021080   SLL V0, V0, 2
9D006894  00561021   ADDU V0, V0, S6
9D006898  8C420000   LW V0, 0(V0)
9D0068A0  0B400152   J 0x9D000548
9D0068A4  0260A821   ADDU S5, S3, ZERO
2080:                
2081:                      OPCODE_BEGIN(A7)  /* LAX $nn */
2082:                         LAX(3, ZERO_PAGE_BYTE);
9D0068A8  26120001   ADDIU S2, S0, 1
9D0068C4  90420000   LBU V0, 0(V0)
9D0068C8  8F838054   LW V1, -32684(GP)
9D0068CC  00621021   ADDU V0, V1, V0
9D0068D0  90530000   LBU S3, 0(V0)
9D0068D4  8F828058   LW V0, -32680(GP)
9D0068D8  2442FFFD   ADDIU V0, V0, -3
9D0068DC  AF828058   SW V0, -32680(GP)
9D0068E0  8E230054   LW V1, 84(S1)
9D0068E4  24630003   ADDIU V1, V1, 3
9D0068F0  0260F021   ADDU FP, S3, ZERO
9D0068F4  0260A021   ADDU S4, S3, ZERO
9D0068F8  0B4027B2   J .L45
9D0068FC  0260A821   ADDU S5, S3, ZERO
9D00692C  0260F021   ADDU FP, S3, ZERO
9D006930  0260A021   ADDU S4, S3, ZERO
2083:                         OPCODE_END
9D0068E8  1C400005   BGTZ V0, 0x9D006900
9D0068EC  AE230054   SW V1, 84(S1)
9D006900  26100002   ADDIU S0, S0, 2
9D00691C  90420000   LBU V0, 0(V0)
9D006920  00021080   SLL V0, V0, 2
9D006924  00561021   ADDU V0, V0, S6
9D006928  8C420000   LW V0, 0(V0)
9D006934  0B400152   J 0x9D000548
9D006938  0260A821   ADDU S5, S3, ZERO
2084:                
2085:                      OPCODE_BEGIN(A8)  /* TAY */
2086:                         TAY();
9D00693C  8F828058   LW V0, -32680(GP)
9D006940  2442FFFE   ADDIU V0, V0, -2
9D006944  AF828058   SW V0, -32680(GP)
9D006948  8E230054   LW V1, 84(S1)
9D00694C  24630002   ADDIU V1, V1, 2
2087:                         OPCODE_END
9D006950  1C400006   BGTZ V0, .LBB1584
9D006954  AE230054   SW V1, 84(S1)
9D006958  02809821   ADDU S3, S4, ZERO
9D00695C  AFB40010   SW S4, 16(SP)
9D006960  02009021   ADDU S2, S0, ZERO
9D006964  0B4027B2   J .L45
9D006968  0280A821   ADDU S5, S4, ZERO
9D006984  90420000   LBU V0, 0(V0)
9D006988  00021080   SLL V0, V0, 2
9D00698C  00561021   ADDU V0, V0, S6
9D006990  8C420000   LW V0, 0(V0)
9D006994  AFB40010   SW S4, 16(SP)
9D006998  26100001   ADDIU S0, S0, 1
9D00699C  0280A821   ADDU S5, S4, ZERO
9D0069A0  0B400152   J 0x9D000548
9D0069A4  02809821   ADDU S3, S4, ZERO
2088:                
2089:                      OPCODE_BEGIN(A9)  /* LDA #$nn */
2090:                         LDA(2, IMMEDIATE_BYTE);
9D0069A8  26120001   ADDIU S2, S0, 1
9D0069C8  8F828058   LW V0, -32680(GP)
9D0069CC  2442FFFE   ADDIU V0, V0, -2
9D0069D0  AF828058   SW V0, -32680(GP)
9D0069D4  8E230054   LW V1, 84(S1)
9D0069D8  24630002   ADDIU V1, V1, 2
2091:                         OPCODE_END
9D0069DC  1C400004   BGTZ V0, 0x9D0069F0
9D0069E0  AE230054   SW V1, 84(S1)
9D0069F0  26100002   ADDIU S0, S0, 2
9D006A0C  90420000   LBU V0, 0(V0)
9D006A10  00021080   SLL V0, V0, 2
9D006A14  00561021   ADDU V0, V0, S6
9D006A18  8C420000   LW V0, 0(V0)
9D006A20  0B400152   J 0x9D000548
9D006A24  0260A821   ADDU S5, S3, ZERO
2092:                
2093:                      OPCODE_BEGIN(AA)  /* TAX */
2094:                         TAX();
9D006A28  8F828058   LW V0, -32680(GP)
9D006A2C  2442FFFE   ADDIU V0, V0, -2
9D006A30  AF828058   SW V0, -32680(GP)
9D006A34  8E230054   LW V1, 84(S1)
9D006A38  24630002   ADDIU V1, V1, 2
2095:                         OPCODE_END
9D006A3C  1C400006   BGTZ V0, .LBB1594
9D006A40  AE230054   SW V1, 84(S1)
9D006A44  02809821   ADDU S3, S4, ZERO
9D006A48  0280F021   ADDU FP, S4, ZERO
9D006A4C  02009021   ADDU S2, S0, ZERO
9D006A50  0B4027B2   J .L45
9D006A54  0280A821   ADDU S5, S4, ZERO
9D006A70  90420000   LBU V0, 0(V0)
9D006A74  00021080   SLL V0, V0, 2
9D006A78  00561021   ADDU V0, V0, S6
9D006A7C  8C420000   LW V0, 0(V0)
9D006A80  0280F021   ADDU FP, S4, ZERO
9D006A84  26100001   ADDIU S0, S0, 1
9D006A88  0280A821   ADDU S5, S4, ZERO
9D006A8C  0B400152   J 0x9D000548
9D006A90  02809821   ADDU S3, S4, ZERO
2096:                
2097:                      OPCODE_BEGIN(AB)  /* LXA #$nn */
2098:                         LXA(2, IMMEDIATE_BYTE);
9D006A94  26120001   ADDIU S2, S0, 1
9D006A98  2404FFEE   ADDIU A0, ZERO, -18
9D006A9C  02849825   OR S3, S4, A0
9D006AB8  90420000   LBU V0, 0(V0)
9D006ABC  02629824   AND S3, S3, V0
9D006AC0  8F828058   LW V0, -32680(GP)
9D006AC4  2442FFFE   ADDIU V0, V0, -2
9D006AC8  AF828058   SW V0, -32680(GP)
9D006ACC  8E230054   LW V1, 84(S1)
9D006AD0  24630002   ADDIU V1, V1, 2
9D006ADC  0260F021   ADDU FP, S3, ZERO
9D006AE0  0260A021   ADDU S4, S3, ZERO
9D006AE4  0B4027B2   J .L45
9D006AE8  0260A821   ADDU S5, S3, ZERO
9D006B18  0260F021   ADDU FP, S3, ZERO
9D006B1C  0260A021   ADDU S4, S3, ZERO
2099:                         OPCODE_END
9D006AD4  1C400005   BGTZ V0, 0x9D006AEC
9D006AD8  AE230054   SW V1, 84(S1)
9D006AEC  26100002   ADDIU S0, S0, 2
9D006B08  90420000   LBU V0, 0(V0)
9D006B0C  00021080   SLL V0, V0, 2
9D006B10  00561021   ADDU V0, V0, S6
9D006B14  8C420000   LW V0, 0(V0)
9D006B20  0B400152   J 0x9D000548
9D006B24  0260A821   ADDU S5, S3, ZERO
2100:                
2101:                      OPCODE_BEGIN(AC)  /* LDY $nnnn */
2102:                         LDY(4, ABSOLUTE_BYTE);
9D006B2C  26120002   ADDIU S2, S0, 2
9D006B6C  0F400000   JAL mem_readbyte
9D006B70  308400FF   ANDI A0, A0, 255
9D006B74  00409821   ADDU S3, V0, ZERO
9D006B78  8F828058   LW V0, -32680(GP)
9D006B7C  2442FFFC   ADDIU V0, V0, -4
9D006B80  AF828058   SW V0, -32680(GP)
9D006B84  8E230054   LW V1, 84(S1)
9D006B88  24630004   ADDIU V1, V1, 4
9D006B94  AFB30010   SW S3, 16(SP)
9D006B98  0B4027B2   J .L45
9D006B9C  0260A821   ADDU S5, S3, ZERO
9D006BCC  AFB30010   SW S3, 16(SP)
2103:                         OPCODE_END
9D006B8C  1C400004   BGTZ V0, 0x9D006BA0
9D006B90  AE230054   SW V1, 84(S1)
9D006BA0  26100003   ADDIU S0, S0, 3
9D006BBC  90420000   LBU V0, 0(V0)
9D006BC0  00021080   SLL V0, V0, 2
9D006BC4  00561021   ADDU V0, V0, S6
9D006BC8  8C420000   LW V0, 0(V0)
9D006BD0  0B400152   J 0x9D000548
9D006BD4  0260A821   ADDU S5, S3, ZERO
2104:                
2105:                      OPCODE_BEGIN(AD)  /* LDA $nnnn */
2106:                         LDA(4, ABSOLUTE_BYTE);
9D006BDC  26120002   ADDIU S2, S0, 2
9D006C1C  0F400000   JAL mem_readbyte
9D006C20  308400FF   ANDI A0, A0, 255
9D006C24  00409821   ADDU S3, V0, ZERO
9D006C28  8F828058   LW V0, -32680(GP)
9D006C2C  2442FFFC   ADDIU V0, V0, -4
9D006C30  AF828058   SW V0, -32680(GP)
9D006C34  8E230054   LW V1, 84(S1)
9D006C38  24630004   ADDIU V1, V1, 4
9D006C44  0260A021   ADDU S4, S3, ZERO
9D006C48  0B4027B2   J .L45
9D006C4C  0260A821   ADDU S5, S3, ZERO
9D006C7C  0260A021   ADDU S4, S3, ZERO
2107:                         OPCODE_END
9D006C3C  1C400004   BGTZ V0, 0x9D006C50
9D006C40  AE230054   SW V1, 84(S1)
9D006C50  26100003   ADDIU S0, S0, 3
9D006C6C  90420000   LBU V0, 0(V0)
9D006C70  00021080   SLL V0, V0, 2
9D006C74  00561021   ADDU V0, V0, S6
9D006C78  8C420000   LW V0, 0(V0)
9D006C80  0B400152   J 0x9D000548
9D006C84  0260A821   ADDU S5, S3, ZERO
2108:                      
2109:                      OPCODE_BEGIN(AE)  /* LDX $nnnn */
2110:                         LDX(4, ABSOLUTE_BYTE);
9D006C8C  26120002   ADDIU S2, S0, 2
9D006CCC  0F400000   JAL mem_readbyte
9D006CD0  308400FF   ANDI A0, A0, 255
9D006CD4  00409821   ADDU S3, V0, ZERO
9D006CD8  8F828058   LW V0, -32680(GP)
9D006CDC  2442FFFC   ADDIU V0, V0, -4
9D006CE0  AF828058   SW V0, -32680(GP)
9D006CE4  8E230054   LW V1, 84(S1)
9D006CE8  24630004   ADDIU V1, V1, 4
9D006CF4  0260F021   ADDU FP, S3, ZERO
9D006CF8  0B4027B2   J .L45
9D006CFC  0260A821   ADDU S5, S3, ZERO
9D006D2C  0260F021   ADDU FP, S3, ZERO
2111:                         OPCODE_END
9D006CEC  1C400004   BGTZ V0, 0x9D006D00
9D006CF0  AE230054   SW V1, 84(S1)
9D006D00  26100003   ADDIU S0, S0, 3
9D006D1C  90420000   LBU V0, 0(V0)
9D006D20  00021080   SLL V0, V0, 2
9D006D24  00561021   ADDU V0, V0, S6
9D006D28  8C420000   LW V0, 0(V0)
9D006D30  0B400152   J 0x9D000548
9D006D34  0260A821   ADDU S5, S3, ZERO
2112:                
2113:                      OPCODE_BEGIN(AF)  /* LAX $nnnn */
2114:                         LAX(4, ABSOLUTE_BYTE);
9D006D3C  26120002   ADDIU S2, S0, 2
9D006D7C  0F400000   JAL mem_readbyte
9D006D80  308400FF   ANDI A0, A0, 255
9D006D84  00409821   ADDU S3, V0, ZERO
9D006D88  8F828058   LW V0, -32680(GP)
9D006D8C  2442FFFC   ADDIU V0, V0, -4
9D006D90  AF828058   SW V0, -32680(GP)
9D006D94  8E230054   LW V1, 84(S1)
9D006D98  24630004   ADDIU V1, V1, 4
9D006DA4  0260F021   ADDU FP, S3, ZERO
9D006DA8  0260A021   ADDU S4, S3, ZERO
9D006DAC  0B4027B2   J .L45
9D006DB0  0260A821   ADDU S5, S3, ZERO
9D006DE0  0260F021   ADDU FP, S3, ZERO
9D006DE4  0260A021   ADDU S4, S3, ZERO
2115:                         OPCODE_END
9D006D9C  1C400005   BGTZ V0, 0x9D006DB4
9D006DA0  AE230054   SW V1, 84(S1)
9D006DB4  26100003   ADDIU S0, S0, 3
9D006DD0  90420000   LBU V0, 0(V0)
9D006DD4  00021080   SLL V0, V0, 2
9D006DD8  00561021   ADDU V0, V0, S6
9D006DDC  8C420000   LW V0, 0(V0)
9D006DE8  0B400152   J 0x9D000548
9D006DEC  0260A821   ADDU S5, S3, ZERO
2116:                
2117:                      OPCODE_BEGIN(B0)  /* BCS $nnnn */
2118:                         BCS();
9D006DF0  12E0001B   BEQ S7, ZERO, 0x9D006E60
9D006DF4  26120001   ADDIU S2, S0, 1
9D006DF8  26020001   ADDIU V0, S0, 1
9D006E14  80720000   LB S2, 0(V1)
9D006E18  304300FF   ANDI V1, V0, 255
9D006E1C  02431821   ADDU V1, S2, V1
9D006E20  30630100   ANDI V1, V1, 256
9D006E24  10600007   BEQ V1, ZERO, 0x9D006E44
9D006E28  8F838058   LW V1, -32680(GP)
9D006E2C  2463FFFF   ADDIU V1, V1, -1
9D006E30  AF838058   SW V1, -32680(GP)
9D006E34  8E230054   LW V1, 84(S1)
9D006E38  24630001   ADDIU V1, V1, 1
9D006E3C  AE230054   SW V1, 84(S1)
9D006E40  8F838058   LW V1, -32680(GP)
9D006E44  2463FFFD   ADDIU V1, V1, -3
9D006E48  AF838058   SW V1, -32680(GP)
9D006E4C  8E230054   LW V1, 84(S1)
9D006E50  24630003   ADDIU V1, V1, 3
9D006E54  AE230054   SW V1, 84(S1)
9D006E58  0B401B9E   J 0x9D006E78
9D006E5C  02429021   ADDU S2, S2, V0
9D006E60  8F828058   LW V0, -32680(GP)
9D006E64  2442FFFE   ADDIU V0, V0, -2
9D006E68  AF828058   SW V0, -32680(GP)
9D006E6C  8E220054   LW V0, 84(S1)
9D006E70  24420002   ADDIU V0, V0, 2
9D006E74  AE220054   SW V0, 84(S1)
2119:                         OPCODE_END
9D006E78  8F828058   LW V0, -32680(GP)
9D006E7C  18400C12   BLEZ V0, .L45
9D006E80  26500001   ADDIU S0, S2, 1
9D006E9C  90420000   LBU V0, 0(V0)
9D006EA0  00021080   SLL V0, V0, 2
9D006EA4  00561021   ADDU V0, V0, S6
9D006EA8  0B400152   J 0x9D000548
9D006EAC  8C420000   LW V0, 0(V0)
2120:                
2121:                      OPCODE_BEGIN(B1)  /* LDA ($nn),Y */
2122:                         LDA(5, INDIR_Y_BYTE_READ);
9D006EE4  8FA50010   LW A1, 16(SP)
9D006EE8  00852021   ADDU A0, A0, A1
9D006EEC  3084FFFF   ANDI A0, A0, -1
9D006EF0  308200FF   ANDI V0, A0, 255
9D006EF4  0045102B   SLTU V0, V0, A1
9D006EF8  10400007   BEQ V0, ZERO, 0x9D006F18
9D006EFC  26120001   ADDIU S2, S0, 1
9D006F00  8F828058   LW V0, -32680(GP)
9D006F04  2442FFFF   ADDIU V0, V0, -1
9D006F08  AF828058   SW V0, -32680(GP)
9D006F0C  8E220054   LW V0, 84(S1)
9D006F10  24420001   ADDIU V0, V0, 1
9D006F14  AE220054   SW V0, 84(S1)
9D006F18  0F400000   JAL mem_readbyte
9D006F1C  00000000   NOP
9D006F20  00409821   ADDU S3, V0, ZERO
9D006F24  8F828058   LW V0, -32680(GP)
9D006F28  2442FFFB   ADDIU V0, V0, -5
9D006F2C  AF828058   SW V0, -32680(GP)
9D006F30  8E230054   LW V1, 84(S1)
9D006F34  24630005   ADDIU V1, V1, 5
9D006F40  0260A021   ADDU S4, S3, ZERO
9D006F44  0B4027B2   J .L45
9D006F48  0260A821   ADDU S5, S3, ZERO
9D006F78  0260A021   ADDU S4, S3, ZERO
2123:                         OPCODE_END
9D006F38  1C400004   BGTZ V0, 0x9D006F4C
9D006F3C  AE230054   SW V1, 84(S1)
9D006F4C  26100002   ADDIU S0, S0, 2
9D006F68  90420000   LBU V0, 0(V0)
9D006F6C  00021080   SLL V0, V0, 2
9D006F70  00561021   ADDU V0, V0, S6
9D006F74  8C420000   LW V0, 0(V0)
9D006F7C  0B400152   J 0x9D000548
9D006F80  0260A821   ADDU S5, S3, ZERO
2124:                
2125:                      OPCODE_BEGIN(B3)  /* LAX ($nn),Y */
2126:                         LAX(5, INDIR_Y_BYTE_READ);
9D006FB8  8FA60010   LW A2, 16(SP)
9D006FBC  00862021   ADDU A0, A0, A2
9D006FC0  3084FFFF   ANDI A0, A0, -1
9D006FC4  308200FF   ANDI V0, A0, 255
9D006FC8  0046102B   SLTU V0, V0, A2
9D006FCC  10400007   BEQ V0, ZERO, 0x9D006FEC
9D006FD0  26120001   ADDIU S2, S0, 1
9D006FD4  8F828058   LW V0, -32680(GP)
9D006FD8  2442FFFF   ADDIU V0, V0, -1
9D006FDC  AF828058   SW V0, -32680(GP)
9D006FE0  8E220054   LW V0, 84(S1)
9D006FE4  24420001   ADDIU V0, V0, 1
9D006FE8  AE220054   SW V0, 84(S1)
9D006FEC  0F400000   JAL mem_readbyte
9D006FF0  00000000   NOP
9D006FF4  00409821   ADDU S3, V0, ZERO
9D006FF8  8F828058   LW V0, -32680(GP)
9D006FFC  2442FFFB   ADDIU V0, V0, -5
9D007000  AF828058   SW V0, -32680(GP)
9D007004  8E230054   LW V1, 84(S1)
9D007008  24630005   ADDIU V1, V1, 5
9D007014  0260F021   ADDU FP, S3, ZERO
9D007018  0260A021   ADDU S4, S3, ZERO
9D00701C  0B4027B2   J .L45
9D007020  0260A821   ADDU S5, S3, ZERO
9D007050  0260F021   ADDU FP, S3, ZERO
9D007054  0260A021   ADDU S4, S3, ZERO
2127:                         OPCODE_END
9D00700C  1C400005   BGTZ V0, 0x9D007024
9D007010  AE230054   SW V1, 84(S1)
9D007024  26100002   ADDIU S0, S0, 2
9D007040  90420000   LBU V0, 0(V0)
9D007044  00021080   SLL V0, V0, 2
9D007048  00561021   ADDU V0, V0, S6
9D00704C  8C420000   LW V0, 0(V0)
9D007058  0B400152   J 0x9D000548
9D00705C  0260A821   ADDU S5, S3, ZERO
2128:                
2129:                      OPCODE_BEGIN(B4)  /* LDY $nn,X */
2130:                         LDY(4, ZP_IND_X_BYTE);
9D007060  26120001   ADDIU S2, S0, 1
9D00707C  90420000   LBU V0, 0(V0)
9D007080  03C21021   ADDU V0, FP, V0
9D007084  304200FF   ANDI V0, V0, 255
9D007088  8F838054   LW V1, -32684(GP)
9D00708C  00621021   ADDU V0, V1, V0
9D007090  90530000   LBU S3, 0(V0)
9D007094  8F828058   LW V0, -32680(GP)
9D007098  2442FFFC   ADDIU V0, V0, -4
9D00709C  AF828058   SW V0, -32680(GP)
9D0070A0  8E230054   LW V1, 84(S1)
9D0070A4  24630004   ADDIU V1, V1, 4
9D0070B0  AFB30010   SW S3, 16(SP)
9D0070B4  0B4027B2   J .L45
9D0070B8  0260A821   ADDU S5, S3, ZERO
9D0070E8  AFB30010   SW S3, 16(SP)
2131:                         OPCODE_END
9D0070A8  1C400004   BGTZ V0, 0x9D0070BC
9D0070AC  AE230054   SW V1, 84(S1)
9D0070BC  26100002   ADDIU S0, S0, 2
9D0070D8  90420000   LBU V0, 0(V0)
9D0070DC  00021080   SLL V0, V0, 2
9D0070E0  00561021   ADDU V0, V0, S6
9D0070E4  8C420000   LW V0, 0(V0)
9D0070EC  0B400152   J 0x9D000548
9D0070F0  0260A821   ADDU S5, S3, ZERO
2132:                
2133:                      OPCODE_BEGIN(B5)  /* LDA $nn,X */
2134:                         LDA(4, ZP_IND_X_BYTE);
9D0070F4  26120001   ADDIU S2, S0, 1
9D007110  90420000   LBU V0, 0(V0)
9D007114  03C21021   ADDU V0, FP, V0
9D007118  304200FF   ANDI V0, V0, 255
9D00711C  8F838054   LW V1, -32684(GP)
9D007120  00621021   ADDU V0, V1, V0
9D007124  90530000   LBU S3, 0(V0)
9D007128  8F828058   LW V0, -32680(GP)
9D00712C  2442FFFC   ADDIU V0, V0, -4
9D007130  AF828058   SW V0, -32680(GP)
9D007134  8E230054   LW V1, 84(S1)
9D007138  24630004   ADDIU V1, V1, 4
9D007144  0260A021   ADDU S4, S3, ZERO
9D007148  0B4027B2   J .L45
9D00714C  0260A821   ADDU S5, S3, ZERO
9D00717C  0260A021   ADDU S4, S3, ZERO
2135:                         OPCODE_END
9D00713C  1C400004   BGTZ V0, 0x9D007150
9D007140  AE230054   SW V1, 84(S1)
9D007150  26100002   ADDIU S0, S0, 2
9D00716C  90420000   LBU V0, 0(V0)
9D007170  00021080   SLL V0, V0, 2
9D007174  00561021   ADDU V0, V0, S6
9D007178  8C420000   LW V0, 0(V0)
9D007180  0B400152   J 0x9D000548
9D007184  0260A821   ADDU S5, S3, ZERO
2136:                
2137:                      OPCODE_BEGIN(B6)  /* LDX $nn,Y */
2138:                         LDX(4, ZP_IND_Y_BYTE);
9D007188  26120001   ADDIU S2, S0, 1
9D0071A4  90420000   LBU V0, 0(V0)
9D0071A8  8FA70010   LW A3, 16(SP)
9D0071AC  00E21021   ADDU V0, A3, V0
9D0071B0  304200FF   ANDI V0, V0, 255
9D0071B4  8F838054   LW V1, -32684(GP)
9D0071B8  00621021   ADDU V0, V1, V0
9D0071BC  90530000   LBU S3, 0(V0)
9D0071C0  8F828058   LW V0, -32680(GP)
9D0071C4  2442FFFC   ADDIU V0, V0, -4
9D0071C8  AF828058   SW V0, -32680(GP)
9D0071CC  8E230054   LW V1, 84(S1)
9D0071D0  24630004   ADDIU V1, V1, 4
9D0071DC  0260F021   ADDU FP, S3, ZERO
9D0071E0  0B4027B2   J .L45
9D0071E4  0260A821   ADDU S5, S3, ZERO
9D007214  0260F021   ADDU FP, S3, ZERO
2139:                         OPCODE_END
9D0071D4  1C400004   BGTZ V0, 0x9D0071E8
9D0071D8  AE230054   SW V1, 84(S1)
9D0071E8  26100002   ADDIU S0, S0, 2
9D007204  90420000   LBU V0, 0(V0)
9D007208  00021080   SLL V0, V0, 2
9D00720C  00561021   ADDU V0, V0, S6
9D007210  8C420000   LW V0, 0(V0)
9D007218  0B400152   J 0x9D000548
9D00721C  0260A821   ADDU S5, S3, ZERO
2140:                
2141:                      OPCODE_BEGIN(B7)  /* LAX $nn,Y */
2142:                         LAX(4, ZP_IND_Y_BYTE);
9D007220  26120001   ADDIU S2, S0, 1
9D00723C  90420000   LBU V0, 0(V0)
9D007240  8FA80010   LW T0, 16(SP)
9D007244  01021021   ADDU V0, T0, V0
9D007248  304200FF   ANDI V0, V0, 255
9D00724C  8F838054   LW V1, -32684(GP)
9D007250  00621021   ADDU V0, V1, V0
9D007254  90530000   LBU S3, 0(V0)
9D007258  8F828058   LW V0, -32680(GP)
9D00725C  2442FFFC   ADDIU V0, V0, -4
9D007260  AF828058   SW V0, -32680(GP)
9D007264  8E230054   LW V1, 84(S1)
9D007268  24630004   ADDIU V1, V1, 4
9D007274  0260F021   ADDU FP, S3, ZERO
9D007278  0260A021   ADDU S4, S3, ZERO
9D00727C  0B4027B2   J .L45
9D007280  0260A821   ADDU S5, S3, ZERO
9D0072B0  0260F021   ADDU FP, S3, ZERO
9D0072B4  0260A021   ADDU S4, S3, ZERO
2143:                         OPCODE_END
9D00726C  1C400005   BGTZ V0, 0x9D007284
9D007270  AE230054   SW V1, 84(S1)
9D007284  26100002   ADDIU S0, S0, 2
9D0072A0  90420000   LBU V0, 0(V0)
9D0072A4  00021080   SLL V0, V0, 2
9D0072A8  00561021   ADDU V0, V0, S6
9D0072AC  8C420000   LW V0, 0(V0)
9D0072B8  0B400152   J 0x9D000548
9D0072BC  0260A821   ADDU S5, S3, ZERO
2144:                
2145:                      OPCODE_BEGIN(B8)  /* CLV */
2146:                         CLV();
9D0072C0  8F828058   LW V0, -32680(GP)
9D0072C4  2442FFFE   ADDIU V0, V0, -2
9D0072C8  AF828058   SW V0, -32680(GP)
9D0072CC  8E230054   LW V1, 84(S1)
9D0072D0  24630002   ADDIU V1, V1, 2
9D0072E0  0B4027B2   J .L45
9D0072E4  AFA00018   SW ZERO, 24(SP)
2147:                         OPCODE_END
9D0072D4  1C400004   BGTZ V0, .LBB1656
9D0072D8  AE230054   SW V1, 84(S1)
9D0072DC  02009021   ADDU S2, S0, ZERO
9D007300  90420000   LBU V0, 0(V0)
9D007304  00021080   SLL V0, V0, 2
9D007308  00561021   ADDU V0, V0, S6
9D00730C  8C420000   LW V0, 0(V0)
9D007310  26100001   ADDIU S0, S0, 1
9D007314  0B400152   J 0x9D000548
9D007318  AFA00018   SW ZERO, 24(SP)
2148:                
2149:                      OPCODE_BEGIN(B9)  /* LDA $nnnn,Y */
2150:                         LDA(4, ABS_IND_Y_BYTE_READ);
9D007360  8FA20010   LW V0, 16(SP)
9D007364  00822021   ADDU A0, A0, V0
9D007368  3084FFFF   ANDI A0, A0, -1
9D00736C  308200FF   ANDI V0, A0, 255
9D007370  8FA30010   LW V1, 16(SP)
9D007374  0043102B   SLTU V0, V0, V1
9D007378  10400007   BEQ V0, ZERO, 0x9D007398
9D00737C  26120002   ADDIU S2, S0, 2
9D007380  8F828058   LW V0, -32680(GP)
9D007384  2442FFFF   ADDIU V0, V0, -1
9D007388  AF828058   SW V0, -32680(GP)
9D00738C  8E220054   LW V0, 84(S1)
9D007390  24420001   ADDIU V0, V0, 1
9D007394  AE220054   SW V0, 84(S1)
9D007398  0F400000   JAL mem_readbyte
9D00739C  00000000   NOP
9D0073A0  00409821   ADDU S3, V0, ZERO
9D0073A4  8F828058   LW V0, -32680(GP)
9D0073A8  2442FFFC   ADDIU V0, V0, -4
9D0073AC  AF828058   SW V0, -32680(GP)
9D0073B0  8E230054   LW V1, 84(S1)
9D0073B4  24630004   ADDIU V1, V1, 4
9D0073C0  0260A021   ADDU S4, S3, ZERO
9D0073C4  0B4027B2   J .L45
9D0073C8  0260A821   ADDU S5, S3, ZERO
9D0073F8  0260A021   ADDU S4, S3, ZERO
2151:                         OPCODE_END
9D0073B8  1C400004   BGTZ V0, 0x9D0073CC
9D0073BC  AE230054   SW V1, 84(S1)
9D0073CC  26100003   ADDIU S0, S0, 3
9D0073E8  90420000   LBU V0, 0(V0)
9D0073EC  00021080   SLL V0, V0, 2
9D0073F0  00561021   ADDU V0, V0, S6
9D0073F4  8C420000   LW V0, 0(V0)
9D0073FC  0B400152   J 0x9D000548
9D007400  0260A821   ADDU S5, S3, ZERO
2152:                
2153:                      OPCODE_BEGIN(BA)  /* TSX */
2154:                         TSX();
9D007404  8F828058   LW V0, -32680(GP)
9D007408  2442FFFE   ADDIU V0, V0, -2
9D00740C  AF828058   SW V0, -32680(GP)
9D007410  8E230054   LW V1, 84(S1)
9D007414  24630002   ADDIU V1, V1, 2
2155:                         OPCODE_END
9D007418  1C400006   BGTZ V0, .LBB1662
9D00741C  AE230054   SW V1, 84(S1)
9D007420  8FB30014   LW S3, 20(SP)
9D007424  0260F021   ADDU FP, S3, ZERO
9D007428  02009021   ADDU S2, S0, ZERO
9D00742C  0B4027B2   J .L45
9D007430  0260A821   ADDU S5, S3, ZERO
9D00744C  90420000   LBU V0, 0(V0)
9D007450  00021080   SLL V0, V0, 2
9D007454  00561021   ADDU V0, V0, S6
9D007458  8C420000   LW V0, 0(V0)
9D00745C  8FBE0014   LW FP, 20(SP)
9D007460  26100001   ADDIU S0, S0, 1
9D007464  03C0A821   ADDU S5, FP, ZERO
9D007468  0B400152   J 0x9D000548
9D00746C  03C09821   ADDU S3, FP, ZERO
2156:                
2157:                      OPCODE_BEGIN(BB)  /* LAS $nnnn,Y */
2158:                         LAS(4, ABS_IND_Y_BYTE_READ);
9D0074B4  8FA50010   LW A1, 16(SP)
9D0074B8  00852021   ADDU A0, A0, A1
9D0074BC  3084FFFF   ANDI A0, A0, -1
9D0074C0  308200FF   ANDI V0, A0, 255
9D0074C4  0045102B   SLTU V0, V0, A1
9D0074C8  10400007   BEQ V0, ZERO, 0x9D0074E8
9D0074CC  26120002   ADDIU S2, S0, 2
9D0074D0  8F828058   LW V0, -32680(GP)
9D0074D4  2442FFFF   ADDIU V0, V0, -1
9D0074D8  AF828058   SW V0, -32680(GP)
9D0074DC  8E220054   LW V0, 84(S1)
9D0074E0  24420001   ADDIU V0, V0, 1
9D0074E4  AE220054   SW V0, 84(S1)
9D0074E8  0F400000   JAL mem_readbyte
9D0074EC  00000000   NOP
9D0074F0  8FA60014   LW A2, 20(SP)
9D0074F4  00461024   AND V0, V0, A2
9D0074F8  305300FF   ANDI S3, V0, 255
9D0074FC  8F828058   LW V0, -32680(GP)
9D007500  2442FFFC   ADDIU V0, V0, -4
9D007504  AF828058   SW V0, -32680(GP)
9D007508  8E230054   LW V1, 84(S1)
9D00750C  24630004   ADDIU V1, V1, 4
9D007518  AFB30014   SW S3, 20(SP)
9D00751C  0260F021   ADDU FP, S3, ZERO
9D007520  0260A021   ADDU S4, S3, ZERO
9D007524  0B4027B2   J .L45
9D007528  0260A821   ADDU S5, S3, ZERO
9D007558  AFB30014   SW S3, 20(SP)
9D00755C  0260F021   ADDU FP, S3, ZERO
9D007560  0260A021   ADDU S4, S3, ZERO
2159:                         OPCODE_END
9D007510  1C400006   BGTZ V0, 0x9D00752C
9D007514  AE230054   SW V1, 84(S1)
9D00752C  26100003   ADDIU S0, S0, 3
9D007548  90420000   LBU V0, 0(V0)
9D00754C  00021080   SLL V0, V0, 2
9D007550  00561021   ADDU V0, V0, S6
9D007554  8C420000   LW V0, 0(V0)
9D007564  0B400152   J 0x9D000548
9D007568  0260A821   ADDU S5, S3, ZERO
2160:                
2161:                      OPCODE_BEGIN(BC)  /* LDY $nnnn,X */
2162:                         LDY(4, ABS_IND_X_BYTE_READ);
9D0075B0  009E2021   ADDU A0, A0, FP
9D0075B4  3084FFFF   ANDI A0, A0, -1
9D0075B8  308200FF   ANDI V0, A0, 255
9D0075BC  005E102B   SLTU V0, V0, FP
9D0075C0  10400007   BEQ V0, ZERO, 0x9D0075E0
9D0075C4  26120002   ADDIU S2, S0, 2
9D0075C8  8F828058   LW V0, -32680(GP)
9D0075CC  2442FFFF   ADDIU V0, V0, -1
9D0075D0  AF828058   SW V0, -32680(GP)
9D0075D4  8E220054   LW V0, 84(S1)
9D0075D8  24420001   ADDIU V0, V0, 1
9D0075DC  AE220054   SW V0, 84(S1)
9D0075E0  0F400000   JAL mem_readbyte
9D0075E4  00000000   NOP
9D0075E8  00409821   ADDU S3, V0, ZERO
9D0075EC  8F828058   LW V0, -32680(GP)
9D0075F0  2442FFFC   ADDIU V0, V0, -4
9D0075F4  AF828058   SW V0, -32680(GP)
9D0075F8  8E230054   LW V1, 84(S1)
9D0075FC  24630004   ADDIU V1, V1, 4
9D007608  AFB30010   SW S3, 16(SP)
9D00760C  0B4027B2   J .L45
9D007610  0260A821   ADDU S5, S3, ZERO
9D007640  AFB30010   SW S3, 16(SP)
2163:                         OPCODE_END
9D007600  1C400004   BGTZ V0, 0x9D007614
9D007604  AE230054   SW V1, 84(S1)
9D007614  26100003   ADDIU S0, S0, 3
9D007630  90420000   LBU V0, 0(V0)
9D007634  00021080   SLL V0, V0, 2
9D007638  00561021   ADDU V0, V0, S6
9D00763C  8C420000   LW V0, 0(V0)
9D007644  0B400152   J 0x9D000548
9D007648  0260A821   ADDU S5, S3, ZERO
2164:                
2165:                      OPCODE_BEGIN(BD)  /* LDA $nnnn,X */
2166:                         LDA(4, ABS_IND_X_BYTE_READ);
9D007690  009E2021   ADDU A0, A0, FP
9D007694  3084FFFF   ANDI A0, A0, -1
9D007698  308200FF   ANDI V0, A0, 255
9D00769C  005E102B   SLTU V0, V0, FP
9D0076A0  10400007   BEQ V0, ZERO, 0x9D0076C0
9D0076A4  26120002   ADDIU S2, S0, 2
9D0076A8  8F828058   LW V0, -32680(GP)
9D0076AC  2442FFFF   ADDIU V0, V0, -1
9D0076B0  AF828058   SW V0, -32680(GP)
9D0076B4  8E220054   LW V0, 84(S1)
9D0076B8  24420001   ADDIU V0, V0, 1
9D0076BC  AE220054   SW V0, 84(S1)
9D0076C0  0F400000   JAL mem_readbyte
9D0076C4  00000000   NOP
9D0076C8  00409821   ADDU S3, V0, ZERO
9D0076CC  8F828058   LW V0, -32680(GP)
9D0076D0  2442FFFC   ADDIU V0, V0, -4
9D0076D4  AF828058   SW V0, -32680(GP)
9D0076D8  8E230054   LW V1, 84(S1)
9D0076DC  24630004   ADDIU V1, V1, 4
9D0076E8  0260A021   ADDU S4, S3, ZERO
9D0076EC  0B4027B2   J .L45
9D0076F0  0260A821   ADDU S5, S3, ZERO
9D007720  0260A021   ADDU S4, S3, ZERO
2167:                         OPCODE_END
9D0076E0  1C400004   BGTZ V0, 0x9D0076F4
9D0076E4  AE230054   SW V1, 84(S1)
9D0076F4  26100003   ADDIU S0, S0, 3
9D007710  90420000   LBU V0, 0(V0)
9D007714  00021080   SLL V0, V0, 2
9D007718  00561021   ADDU V0, V0, S6
9D00771C  8C420000   LW V0, 0(V0)
9D007724  0B400152   J 0x9D000548
9D007728  0260A821   ADDU S5, S3, ZERO
2168:                
2169:                      OPCODE_BEGIN(BE)  /* LDX $nnnn,Y */
2170:                         LDX(4, ABS_IND_Y_BYTE_READ);
9D007770  8FA70010   LW A3, 16(SP)
9D007774  00872021   ADDU A0, A0, A3
9D007778  3084FFFF   ANDI A0, A0, -1
9D00777C  308200FF   ANDI V0, A0, 255
9D007780  0047102B   SLTU V0, V0, A3
9D007784  10400007   BEQ V0, ZERO, 0x9D0077A4
9D007788  26120002   ADDIU S2, S0, 2
9D00778C  8F828058   LW V0, -32680(GP)
9D007790  2442FFFF   ADDIU V0, V0, -1
9D007794  AF828058   SW V0, -32680(GP)
9D007798  8E220054   LW V0, 84(S1)
9D00779C  24420001   ADDIU V0, V0, 1
9D0077A0  AE220054   SW V0, 84(S1)
9D0077A4  0F400000   JAL mem_readbyte
9D0077A8  00000000   NOP
9D0077AC  00409821   ADDU S3, V0, ZERO
9D0077B0  8F828058   LW V0, -32680(GP)
9D0077B4  2442FFFC   ADDIU V0, V0, -4
9D0077B8  AF828058   SW V0, -32680(GP)
9D0077BC  8E230054   LW V1, 84(S1)
9D0077C0  24630004   ADDIU V1, V1, 4
9D0077CC  0260F021   ADDU FP, S3, ZERO
9D0077D0  0B4027B2   J .L45
9D0077D4  0260A821   ADDU S5, S3, ZERO
9D007804  0260F021   ADDU FP, S3, ZERO
2171:                         OPCODE_END
9D0077C4  1C400004   BGTZ V0, 0x9D0077D8
9D0077C8  AE230054   SW V1, 84(S1)
9D0077D8  26100003   ADDIU S0, S0, 3
9D0077F4  90420000   LBU V0, 0(V0)
9D0077F8  00021080   SLL V0, V0, 2
9D0077FC  00561021   ADDU V0, V0, S6
9D007800  8C420000   LW V0, 0(V0)
9D007808  0B400152   J 0x9D000548
9D00780C  0260A821   ADDU S5, S3, ZERO
2172:                
2173:                      OPCODE_BEGIN(BF)  /* LAX $nnnn,Y */
2174:                         LAX(4, ABS_IND_Y_BYTE_READ);
9D007854  8FA80010   LW T0, 16(SP)
9D007858  00882021   ADDU A0, A0, T0
9D00785C  3084FFFF   ANDI A0, A0, -1
9D007860  308200FF   ANDI V0, A0, 255
9D007864  0048102B   SLTU V0, V0, T0
9D007868  10400007   BEQ V0, ZERO, 0x9D007888
9D00786C  26120002   ADDIU S2, S0, 2
9D007870  8F828058   LW V0, -32680(GP)
9D007874  2442FFFF   ADDIU V0, V0, -1
9D007878  AF828058   SW V0, -32680(GP)
9D00787C  8E220054   LW V0, 84(S1)
9D007880  24420001   ADDIU V0, V0, 1
9D007884  AE220054   SW V0, 84(S1)
9D007888  0F400000   JAL mem_readbyte
9D00788C  00000000   NOP
9D007890  00409821   ADDU S3, V0, ZERO
9D007894  8F828058   LW V0, -32680(GP)
9D007898  2442FFFC   ADDIU V0, V0, -4
9D00789C  AF828058   SW V0, -32680(GP)
9D0078A0  8E230054   LW V1, 84(S1)
9D0078A4  24630004   ADDIU V1, V1, 4
9D0078B0  0260F021   ADDU FP, S3, ZERO
9D0078B4  0260A021   ADDU S4, S3, ZERO
9D0078B8  0B4027B2   J .L45
9D0078BC  0260A821   ADDU S5, S3, ZERO
9D0078EC  0260F021   ADDU FP, S3, ZERO
9D0078F0  0260A021   ADDU S4, S3, ZERO
2175:                         OPCODE_END
9D0078A8  1C400005   BGTZ V0, 0x9D0078C0
9D0078AC  AE230054   SW V1, 84(S1)
9D0078C0  26100003   ADDIU S0, S0, 3
9D0078DC  90420000   LBU V0, 0(V0)
9D0078E0  00021080   SLL V0, V0, 2
9D0078E4  00561021   ADDU V0, V0, S6
9D0078E8  8C420000   LW V0, 0(V0)
9D0078F4  0B400152   J 0x9D000548
9D0078F8  0260A821   ADDU S5, S3, ZERO
2176:                
2177:                      OPCODE_BEGIN(C0)  /* CPY #$nn */
2178:                         CPY(2, IMMEDIATE_BYTE);
9D0078FC  26120001   ADDIU S2, S0, 1
9D007918  90530000   LBU S3, 0(V0)
9D00791C  8FA20010   LW V0, 16(SP)
9D007920  00539823   SUBU S3, V0, S3
9D007924  7E770200   EXT S7, S3, 8, 1
9D007928  3AF70001   XORI S7, S7, 1
9D00792C  327300FF   ANDI S3, S3, 255
9D007930  8F828058   LW V0, -32680(GP)
9D007934  2442FFFE   ADDIU V0, V0, -2
9D007938  AF828058   SW V0, -32680(GP)
9D00793C  8E230054   LW V1, 84(S1)
9D007940  24630002   ADDIU V1, V1, 2
9D00794C  0B4027B2   J .L45
9D007950  0260A821   ADDU S5, S3, ZERO
2179:                         OPCODE_END
9D007944  1C400003   BGTZ V0, 0x9D007954
9D007948  AE230054   SW V1, 84(S1)
9D007954  26100002   ADDIU S0, S0, 2
9D007970  90420000   LBU V0, 0(V0)
9D007974  00021080   SLL V0, V0, 2
9D007978  00561021   ADDU V0, V0, S6
9D00797C  8C420000   LW V0, 0(V0)
9D007980  0B400152   J 0x9D000548
9D007984  0260A821   ADDU S5, S3, ZERO
2180:                
2181:                      OPCODE_BEGIN(C1)  /* CMP ($nn,X) */
2182:                         CMP(6, INDIR_X_BYTE);
9D007988  26120001   ADDIU S2, S0, 1
9D0079A4  90420000   LBU V0, 0(V0)
9D0079A8  03C21021   ADDU V0, FP, V0
9D0079C4  0F400000   JAL mem_readbyte
9D0079C8  308400FF   ANDI A0, A0, 255
9D0079CC  02821023   SUBU V0, S4, V0
9D0079D0  7C570200   EXT S7, V0, 8, 1
9D0079D4  3AF70001   XORI S7, S7, 1
9D0079D8  305300FF   ANDI S3, V0, 255
9D0079DC  8F828058   LW V0, -32680(GP)
9D0079E0  2442FFFA   ADDIU V0, V0, -6
9D0079E4  AF828058   SW V0, -32680(GP)
9D0079E8  8E230054   LW V1, 84(S1)
9D0079EC  24630006   ADDIU V1, V1, 6
9D0079F8  0B4027B2   J .L45
9D0079FC  0260A821   ADDU S5, S3, ZERO
2183:                         OPCODE_END
9D0079F0  1C400003   BGTZ V0, 0x9D007A00
9D0079F4  AE230054   SW V1, 84(S1)
9D007A00  26100002   ADDIU S0, S0, 2
9D007A1C  90420000   LBU V0, 0(V0)
9D007A20  00021080   SLL V0, V0, 2
9D007A24  00561021   ADDU V0, V0, S6
9D007A28  8C420000   LW V0, 0(V0)
9D007A2C  0B400152   J 0x9D000548
9D007A30  0260A821   ADDU S5, S3, ZERO
2184:                
2185:                      OPCODE_BEGIN(C3)  /* DCP ($nn,X) */
2186:                         DCP(8, INDIR_X, mem_writebyte, addr);
9D007A34  26120001   ADDIU S2, S0, 1
9D007A50  90420000   LBU V0, 0(V0)
9D007A54  03C21021   ADDU V0, FP, V0
9D007A74  0F400000   JAL mem_readbyte
9D007A78  02A02021   ADDU A0, S5, ZERO
9D007A7C  2442FFFF   ADDIU V0, V0, -1
9D007A80  305300FF   ANDI S3, V0, 255
9D007A84  02A02021   ADDU A0, S5, ZERO
9D007A88  0F400036   JAL mem_writebyte
9D007A8C  02602821   ADDU A1, S3, ZERO
9D007A90  02939823   SUBU S3, S4, S3
9D007A94  7E770200   EXT S7, S3, 8, 1
9D007A98  3AF70001   XORI S7, S7, 1
9D007A9C  327300FF   ANDI S3, S3, 255
9D007AA0  8F828058   LW V0, -32680(GP)
9D007AA4  2442FFF8   ADDIU V0, V0, -8
9D007AA8  AF828058   SW V0, -32680(GP)
9D007AAC  8E230054   LW V1, 84(S1)
9D007AB0  24630008   ADDIU V1, V1, 8
9D007ABC  0B4027B2   J .L45
9D007AC0  0260A821   ADDU S5, S3, ZERO
2187:                         OPCODE_END
9D007AB4  1C400003   BGTZ V0, 0x9D007AC4
9D007AB8  AE230054   SW V1, 84(S1)
9D007AC4  26100002   ADDIU S0, S0, 2
9D007AE0  90420000   LBU V0, 0(V0)
9D007AE4  00021080   SLL V0, V0, 2
9D007AE8  00561021   ADDU V0, V0, S6
9D007AEC  8C420000   LW V0, 0(V0)
9D007AF0  0B400152   J 0x9D000548
9D007AF4  0260A821   ADDU S5, S3, ZERO
2188:                
2189:                      OPCODE_BEGIN(C4)  /* CPY $nn */
2190:                         CPY(3, ZERO_PAGE_BYTE);
9D007AF8  26120001   ADDIU S2, S0, 1
9D007B14  90420000   LBU V0, 0(V0)
9D007B18  8F838054   LW V1, -32684(GP)
9D007B1C  00621021   ADDU V0, V1, V0
9D007B20  90530000   LBU S3, 0(V0)
9D007B24  8FA30010   LW V1, 16(SP)
9D007B28  00739823   SUBU S3, V1, S3
9D007B2C  7E770200   EXT S7, S3, 8, 1
9D007B30  3AF70001   XORI S7, S7, 1
9D007B34  327300FF   ANDI S3, S3, 255
9D007B38  8F828058   LW V0, -32680(GP)
9D007B3C  2442FFFD   ADDIU V0, V0, -3
9D007B40  AF828058   SW V0, -32680(GP)
9D007B44  8E230054   LW V1, 84(S1)
9D007B48  24630003   ADDIU V1, V1, 3
9D007B54  0B4027B2   J .L45
9D007B58  0260A821   ADDU S5, S3, ZERO
2191:                         OPCODE_END
9D007B4C  1C400003   BGTZ V0, 0x9D007B5C
9D007B50  AE230054   SW V1, 84(S1)
9D007B5C  26100002   ADDIU S0, S0, 2
9D007B78  90420000   LBU V0, 0(V0)
9D007B7C  00021080   SLL V0, V0, 2
9D007B80  00561021   ADDU V0, V0, S6
9D007B84  8C420000   LW V0, 0(V0)
9D007B88  0B400152   J 0x9D000548
9D007B8C  0260A821   ADDU S5, S3, ZERO
2192:                
2193:                      OPCODE_BEGIN(C5)  /* CMP $nn */
2194:                         CMP(3, ZERO_PAGE_BYTE);
9D007B90  26120001   ADDIU S2, S0, 1
9D007BAC  90420000   LBU V0, 0(V0)
9D007BB0  8F838054   LW V1, -32684(GP)
9D007BB4  00621021   ADDU V0, V1, V0
9D007BB8  90530000   LBU S3, 0(V0)
9D007BBC  02939823   SUBU S3, S4, S3
9D007BC0  7E770200   EXT S7, S3, 8, 1
9D007BC4  3AF70001   XORI S7, S7, 1
9D007BC8  327300FF   ANDI S3, S3, 255
9D007BCC  8F828058   LW V0, -32680(GP)
9D007BD0  2442FFFD   ADDIU V0, V0, -3
9D007BD4  AF828058   SW V0, -32680(GP)
9D007BD8  8E230054   LW V1, 84(S1)
9D007BDC  24630003   ADDIU V1, V1, 3
9D007BE8  0B4027B2   J .L45
9D007BEC  0260A821   ADDU S5, S3, ZERO
2195:                         OPCODE_END
9D007BE0  1C400003   BGTZ V0, 0x9D007BF0
9D007BE4  AE230054   SW V1, 84(S1)
9D007BF0  26100002   ADDIU S0, S0, 2
9D007C0C  90420000   LBU V0, 0(V0)
9D007C10  00021080   SLL V0, V0, 2
9D007C14  00561021   ADDU V0, V0, S6
9D007C18  8C420000   LW V0, 0(V0)
9D007C1C  0B400152   J 0x9D000548
9D007C20  0260A821   ADDU S5, S3, ZERO
2196:                
2197:                      OPCODE_BEGIN(C6)  /* DEC $nn */
2198:                         DEC(5, ZERO_PAGE, ZP_WRITEBYTE, baddr);
9D007C24  26120001   ADDIU S2, S0, 1
9D007C40  90420000   LBU V0, 0(V0)
9D007C44  8F838054   LW V1, -32684(GP)
9D007C48  00621021   ADDU V0, V1, V0
9D007C4C  90530000   LBU S3, 0(V0)
9D007C50  2673FFFF   ADDIU S3, S3, -1
9D007C54  327300FF   ANDI S3, S3, 255
9D007C58  A0530000   SB S3, 0(V0)
9D007C5C  8F828058   LW V0, -32680(GP)
9D007C60  2442FFFB   ADDIU V0, V0, -5
9D007C64  AF828058   SW V0, -32680(GP)
9D007C68  8E230054   LW V1, 84(S1)
9D007C6C  24630005   ADDIU V1, V1, 5
9D007C78  0B4027B2   J .L45
9D007C7C  0260A821   ADDU S5, S3, ZERO
2199:                         OPCODE_END
9D007C70  1C400003   BGTZ V0, 0x9D007C80
9D007C74  AE230054   SW V1, 84(S1)
9D007C80  26100002   ADDIU S0, S0, 2
9D007C9C  90420000   LBU V0, 0(V0)
9D007CA0  00021080   SLL V0, V0, 2
9D007CA4  00561021   ADDU V0, V0, S6
9D007CA8  8C420000   LW V0, 0(V0)
9D007CAC  0B400152   J 0x9D000548
9D007CB0  0260A821   ADDU S5, S3, ZERO
2200:                
2201:                      OPCODE_BEGIN(C7)  /* DCP $nn */
2202:                         DCP(5, ZERO_PAGE, ZP_WRITEBYTE, baddr);
9D007CB4  26120001   ADDIU S2, S0, 1
9D007CD0  90420000   LBU V0, 0(V0)
9D007CD4  8F838054   LW V1, -32684(GP)
9D007CD8  00621021   ADDU V0, V1, V0
9D007CDC  90530000   LBU S3, 0(V0)
9D007CE0  2673FFFF   ADDIU S3, S3, -1
9D007CE4  327300FF   ANDI S3, S3, 255
9D007CE8  A0530000   SB S3, 0(V0)
9D007CEC  02939823   SUBU S3, S4, S3
9D007CF0  7E770200   EXT S7, S3, 8, 1
9D007CF4  3AF70001   XORI S7, S7, 1
9D007CF8  327300FF   ANDI S3, S3, 255
9D007CFC  8F828058   LW V0, -32680(GP)
9D007D00  2442FFFB   ADDIU V0, V0, -5
9D007D04  AF828058   SW V0, -32680(GP)
9D007D08  8E230054   LW V1, 84(S1)
9D007D0C  24630005   ADDIU V1, V1, 5
9D007D18  0B4027B2   J .L45
9D007D1C  0260A821   ADDU S5, S3, ZERO
2203:                         OPCODE_END
9D007D10  1C400003   BGTZ V0, 0x9D007D20
9D007D14  AE230054   SW V1, 84(S1)
9D007D20  26100002   ADDIU S0, S0, 2
9D007D3C  90420000   LBU V0, 0(V0)
9D007D40  00021080   SLL V0, V0, 2
9D007D44  00561021   ADDU V0, V0, S6
9D007D48  8C420000   LW V0, 0(V0)
9D007D4C  0B400152   J 0x9D000548
9D007D50  0260A821   ADDU S5, S3, ZERO
2204:                
2205:                      OPCODE_BEGIN(C8)  /* INY */
2206:                         INY();
9D007D54  8FA40010   LW A0, 16(SP)
9D007D58  24930001   ADDIU S3, A0, 1
9D007D5C  327300FF   ANDI S3, S3, 255
9D007D60  8F828058   LW V0, -32680(GP)
9D007D64  2442FFFE   ADDIU V0, V0, -2
9D007D68  AF828058   SW V0, -32680(GP)
9D007D6C  8E230054   LW V1, 84(S1)
9D007D70  24630002   ADDIU V1, V1, 2
9D007D7C  AFB30010   SW S3, 16(SP)
9D007D84  0B4027B2   J .L45
9D007D88  0260A821   ADDU S5, S3, ZERO
9D007DB4  AFB30010   SW S3, 16(SP)
2207:                         OPCODE_END
9D007D74  1C400005   BGTZ V0, .LBB1716
9D007D78  AE230054   SW V1, 84(S1)
9D007D80  02009021   ADDU S2, S0, ZERO
9D007DA4  90420000   LBU V0, 0(V0)
9D007DA8  00021080   SLL V0, V0, 2
9D007DAC  00561021   ADDU V0, V0, S6
9D007DB0  8C420000   LW V0, 0(V0)
9D007DB8  26100001   ADDIU S0, S0, 1
9D007DBC  0B400152   J 0x9D000548
9D007DC0  0260A821   ADDU S5, S3, ZERO
2208:                
2209:                      OPCODE_BEGIN(C9)  /* CMP #$nn */
2210:                         CMP(2, IMMEDIATE_BYTE);
9D007DC4  26120001   ADDIU S2, S0, 1
9D007DE0  90530000   LBU S3, 0(V0)
9D007DE4  02939823   SUBU S3, S4, S3
9D007DE8  7E770200   EXT S7, S3, 8, 1
9D007DEC  3AF70001   XORI S7, S7, 1
9D007DF0  327300FF   ANDI S3, S3, 255
9D007DF4  8F828058   LW V0, -32680(GP)
9D007DF8  2442FFFE   ADDIU V0, V0, -2
9D007DFC  AF828058   SW V0, -32680(GP)
9D007E00  8E230054   LW V1, 84(S1)
9D007E04  24630002   ADDIU V1, V1, 2
9D007E10  0B4027B2   J .L45
9D007E14  0260A821   ADDU S5, S3, ZERO
2211:                         OPCODE_END
9D007E08  1C400003   BGTZ V0, 0x9D007E18
9D007E0C  AE230054   SW V1, 84(S1)
9D007E18  26100002   ADDIU S0, S0, 2
9D007E34  90420000   LBU V0, 0(V0)
9D007E38  00021080   SLL V0, V0, 2
9D007E3C  00561021   ADDU V0, V0, S6
9D007E40  8C420000   LW V0, 0(V0)
9D007E44  0B400152   J 0x9D000548
9D007E48  0260A821   ADDU S5, S3, ZERO
2212:                
2213:                      OPCODE_BEGIN(CA)  /* DEX */
2214:                         DEX();
9D007E4C  27D3FFFF   ADDIU S3, FP, -1
9D007E50  327300FF   ANDI S3, S3, 255
9D007E54  8F828058   LW V0, -32680(GP)
9D007E58  2442FFFE   ADDIU V0, V0, -2
9D007E5C  AF828058   SW V0, -32680(GP)
9D007E60  8E230054   LW V1, 84(S1)
9D007E64  24630002   ADDIU V1, V1, 2
9D007E70  0260F021   ADDU FP, S3, ZERO
9D007E78  0B4027B2   J .L45
9D007E7C  0260A821   ADDU S5, S3, ZERO
9D007EA8  0260F021   ADDU FP, S3, ZERO
2215:                         OPCODE_END
9D007E68  1C400005   BGTZ V0, .LBB1722
9D007E6C  AE230054   SW V1, 84(S1)
9D007E74  02009021   ADDU S2, S0, ZERO
9D007E98  90420000   LBU V0, 0(V0)
9D007E9C  00021080   SLL V0, V0, 2
9D007EA0  00561021   ADDU V0, V0, S6
9D007EA4  8C420000   LW V0, 0(V0)
9D007EAC  26100001   ADDIU S0, S0, 1
9D007EB0  0B400152   J 0x9D000548
9D007EB4  0260A821   ADDU S5, S3, ZERO
2216:                
2217:                      OPCODE_BEGIN(CB)  /* SBX #$nn */
2218:                         SBX(2, IMMEDIATE_BYTE);
9D007EB8  26120001   ADDIU S2, S0, 1
9D007EBC  03D49824   AND S3, FP, S4
9D007EC0  327300FF   ANDI S3, S3, 255
9D007EDC  90420000   LBU V0, 0(V0)
9D007EE0  02629823   SUBU S3, S3, V0
9D007EE4  3A770100   XORI S7, S3, 256
9D007EE8  7EF70200   EXT S7, S7, 8, 1
9D007EEC  327300FF   ANDI S3, S3, 255
9D007EF0  8F828058   LW V0, -32680(GP)
9D007EF4  2442FFFE   ADDIU V0, V0, -2
9D007EF8  AF828058   SW V0, -32680(GP)
9D007EFC  8E230054   LW V1, 84(S1)
9D007F00  24630002   ADDIU V1, V1, 2
9D007F0C  0260F021   ADDU FP, S3, ZERO
9D007F10  0B4027B2   J .L45
9D007F14  0260A821   ADDU S5, S3, ZERO
9D007F44  0260F021   ADDU FP, S3, ZERO
2219:                         OPCODE_END
9D007F04  1C400004   BGTZ V0, 0x9D007F18
9D007F08  AE230054   SW V1, 84(S1)
9D007F18  26100002   ADDIU S0, S0, 2
9D007F34  90420000   LBU V0, 0(V0)
9D007F38  00021080   SLL V0, V0, 2
9D007F3C  00561021   ADDU V0, V0, S6
9D007F40  8C420000   LW V0, 0(V0)
9D007F48  0B400152   J 0x9D000548
9D007F4C  0260A821   ADDU S5, S3, ZERO
2220:                
2221:                      OPCODE_BEGIN(CC)  /* CPY $nnnn */
2222:                         CPY(4, ABSOLUTE_BYTE);
9D007F54  26120002   ADDIU S2, S0, 2
9D007F94  0F400000   JAL mem_readbyte
9D007F98  308400FF   ANDI A0, A0, 255
9D007F9C  8FA50010   LW A1, 16(SP)
9D007FA0  00A21023   SUBU V0, A1, V0
9D007FA4  7C570200   EXT S7, V0, 8, 1
9D007FA8  3AF70001   XORI S7, S7, 1
9D007FAC  305300FF   ANDI S3, V0, 255
9D007FB0  8F828058   LW V0, -32680(GP)
9D007FB4  2442FFFC   ADDIU V0, V0, -4
9D007FB8  AF828058   SW V0, -32680(GP)
9D007FBC  8E230054   LW V1, 84(S1)
9D007FC0  24630004   ADDIU V1, V1, 4
9D007FCC  0B4027B2   J .L45
9D007FD0  0260A821   ADDU S5, S3, ZERO
2223:                         OPCODE_END
9D007FC4  1C400003   BGTZ V0, 0x9D007FD4
9D007FC8  AE230054   SW V1, 84(S1)
9D007FD4  26100003   ADDIU S0, S0, 3
9D007FF0  90420000   LBU V0, 0(V0)
9D007FF4  00021080   SLL V0, V0, 2
9D007FF8  00561021   ADDU V0, V0, S6
9D007FFC  8C420000   LW V0, 0(V0)
9D008000  0B400152   J 0x9D000548
9D008004  0260A821   ADDU S5, S3, ZERO
2224:                
2225:                      OPCODE_BEGIN(CD)  /* CMP $nnnn */
2226:                         CMP(4, ABSOLUTE_BYTE);
9D00800C  26120002   ADDIU S2, S0, 2
9D00804C  0F400000   JAL mem_readbyte
9D008050  308400FF   ANDI A0, A0, 255
9D008054  02821023   SUBU V0, S4, V0
9D008058  7C570200   EXT S7, V0, 8, 1
9D00805C  3AF70001   XORI S7, S7, 1
9D008060  305300FF   ANDI S3, V0, 255
9D008064  8F828058   LW V0, -32680(GP)
9D008068  2442FFFC   ADDIU V0, V0, -4
9D00806C  AF828058   SW V0, -32680(GP)
9D008070  8E230054   LW V1, 84(S1)
9D008074  24630004   ADDIU V1, V1, 4
9D008080  0B4027B2   J .L45
9D008084  0260A821   ADDU S5, S3, ZERO
2227:                         OPCODE_END
9D008078  1C400003   BGTZ V0, 0x9D008088
9D00807C  AE230054   SW V1, 84(S1)
9D008088  26100003   ADDIU S0, S0, 3
9D0080A4  90420000   LBU V0, 0(V0)
9D0080A8  00021080   SLL V0, V0, 2
9D0080AC  00561021   ADDU V0, V0, S6
9D0080B0  8C420000   LW V0, 0(V0)
9D0080B4  0B400152   J 0x9D000548
9D0080B8  0260A821   ADDU S5, S3, ZERO
2228:                
2229:                      OPCODE_BEGIN(CE)  /* DEC $nnnn */
2230:                         DEC(6, ABSOLUTE, mem_writebyte, addr);
9D008100  26120002   ADDIU S2, S0, 2
9D008104  0F400000   JAL mem_readbyte
9D008108  02A02021   ADDU A0, S5, ZERO
9D00810C  2442FFFF   ADDIU V0, V0, -1
9D008110  305300FF   ANDI S3, V0, 255
9D008114  02A02021   ADDU A0, S5, ZERO
9D008118  0F400036   JAL mem_writebyte
9D00811C  02602821   ADDU A1, S3, ZERO
9D008120  8F828058   LW V0, -32680(GP)
9D008124  2442FFFA   ADDIU V0, V0, -6
9D008128  AF828058   SW V0, -32680(GP)
9D00812C  8E230054   LW V1, 84(S1)
9D008130  24630006   ADDIU V1, V1, 6
9D00813C  0B4027B2   J .L45
9D008140  0260A821   ADDU S5, S3, ZERO
2231:                         OPCODE_END
9D008134  1C400003   BGTZ V0, 0x9D008144
9D008138  AE230054   SW V1, 84(S1)
9D008144  26100003   ADDIU S0, S0, 3
9D008160  90420000   LBU V0, 0(V0)
9D008164  00021080   SLL V0, V0, 2
9D008168  00561021   ADDU V0, V0, S6
9D00816C  8C420000   LW V0, 0(V0)
9D008170  0B400152   J 0x9D000548
9D008174  0260A821   ADDU S5, S3, ZERO
2232:                
2233:                      OPCODE_BEGIN(CF)  /* DCP $nnnn */
2234:                         DCP(6, ABSOLUTE, mem_writebyte, addr);
9D0081BC  26120002   ADDIU S2, S0, 2
9D0081C0  0F400000   JAL mem_readbyte
9D0081C4  02A02021   ADDU A0, S5, ZERO
9D0081C8  2442FFFF   ADDIU V0, V0, -1
9D0081CC  305300FF   ANDI S3, V0, 255
9D0081D0  02A02021   ADDU A0, S5, ZERO
9D0081D4  0F400036   JAL mem_writebyte
9D0081D8  02602821   ADDU A1, S3, ZERO
9D0081DC  02939823   SUBU S3, S4, S3
9D0081E0  7E770200   EXT S7, S3, 8, 1
9D0081E4  3AF70001   XORI S7, S7, 1
9D0081E8  327300FF   ANDI S3, S3, 255
9D0081EC  8F828058   LW V0, -32680(GP)
9D0081F0  2442FFFA   ADDIU V0, V0, -6
9D0081F4  AF828058   SW V0, -32680(GP)
9D0081F8  8E230054   LW V1, 84(S1)
9D0081FC  24630006   ADDIU V1, V1, 6
9D008208  0B4027B2   J .L45
9D00820C  0260A821   ADDU S5, S3, ZERO
2235:                         OPCODE_END
9D008200  1C400003   BGTZ V0, 0x9D008210
9D008204  AE230054   SW V1, 84(S1)
9D008210  26100003   ADDIU S0, S0, 3
9D00822C  90420000   LBU V0, 0(V0)
9D008230  00021080   SLL V0, V0, 2
9D008234  00561021   ADDU V0, V0, S6
9D008238  8C420000   LW V0, 0(V0)
9D00823C  0B400152   J 0x9D000548
9D008240  0260A821   ADDU S5, S3, ZERO
2236:                      
2237:                      OPCODE_BEGIN(D0)  /* BNE $nnnn */
2238:                         BNE();
9D008244  12A0001B   BEQ S5, ZERO, 0x9D0082B4
9D008248  26120001   ADDIU S2, S0, 1
9D00824C  26020001   ADDIU V0, S0, 1
9D008268  80720000   LB S2, 0(V1)
9D00826C  304300FF   ANDI V1, V0, 255
9D008270  02431821   ADDU V1, S2, V1
9D008274  30630100   ANDI V1, V1, 256
9D008278  10600007   BEQ V1, ZERO, 0x9D008298
9D00827C  8F838058   LW V1, -32680(GP)
9D008280  2463FFFF   ADDIU V1, V1, -1
9D008284  AF838058   SW V1, -32680(GP)
9D008288  8E230054   LW V1, 84(S1)
9D00828C  24630001   ADDIU V1, V1, 1
9D008290  AE230054   SW V1, 84(S1)
9D008294  8F838058   LW V1, -32680(GP)
9D008298  2463FFFD   ADDIU V1, V1, -3
9D00829C  AF838058   SW V1, -32680(GP)
9D0082A0  8E230054   LW V1, 84(S1)
9D0082A4  24630003   ADDIU V1, V1, 3
9D0082A8  AE230054   SW V1, 84(S1)
9D0082AC  0B4020B3   J 0x9D0082CC
9D0082B0  02429021   ADDU S2, S2, V0
9D0082B4  8F828058   LW V0, -32680(GP)
9D0082B8  2442FFFE   ADDIU V0, V0, -2
9D0082BC  AF828058   SW V0, -32680(GP)
9D0082C0  8E220054   LW V0, 84(S1)
9D0082C4  24420002   ADDIU V0, V0, 2
9D0082C8  AE220054   SW V0, 84(S1)
2239:                         OPCODE_END
9D0082CC  8F828058   LW V0, -32680(GP)
9D0082D0  184006FD   BLEZ V0, .L45
9D0082D4  26500001   ADDIU S0, S2, 1
9D0082F0  90420000   LBU V0, 0(V0)
9D0082F4  00021080   SLL V0, V0, 2
9D0082F8  00561021   ADDU V0, V0, S6
9D0082FC  0B400152   J 0x9D000548
9D008300  8C420000   LW V0, 0(V0)
2240:                
2241:                      OPCODE_BEGIN(D1)  /* CMP ($nn),Y */
2242:                         CMP(5, INDIR_Y_BYTE_READ);
9D008338  8FA60010   LW A2, 16(SP)
9D00833C  00862021   ADDU A0, A0, A2
9D008340  3084FFFF   ANDI A0, A0, -1
9D008344  308200FF   ANDI V0, A0, 255
9D008348  0046102B   SLTU V0, V0, A2
9D00834C  10400007   BEQ V0, ZERO, 0x9D00836C
9D008350  26120001   ADDIU S2, S0, 1
9D008354  8F828058   LW V0, -32680(GP)
9D008358  2442FFFF   ADDIU V0, V0, -1
9D00835C  AF828058   SW V0, -32680(GP)
9D008360  8E220054   LW V0, 84(S1)
9D008364  24420001   ADDIU V0, V0, 1
9D008368  AE220054   SW V0, 84(S1)
9D00836C  0F400000   JAL mem_readbyte
9D008370  00000000   NOP
9D008374  02821023   SUBU V0, S4, V0
9D008378  7C570200   EXT S7, V0, 8, 1
9D00837C  3AF70001   XORI S7, S7, 1
9D008380  305300FF   ANDI S3, V0, 255
9D008384  8F828058   LW V0, -32680(GP)
9D008388  2442FFFB   ADDIU V0, V0, -5
9D00838C  AF828058   SW V0, -32680(GP)
9D008390  8E230054   LW V1, 84(S1)
9D008394  24630005   ADDIU V1, V1, 5
9D0083A0  0B4027B2   J .L45
9D0083A4  0260A821   ADDU S5, S3, ZERO
2243:                         OPCODE_END
9D008398  1C400003   BGTZ V0, 0x9D0083A8
9D00839C  AE230054   SW V1, 84(S1)
9D0083A8  26100002   ADDIU S0, S0, 2
9D0083C4  90420000   LBU V0, 0(V0)
9D0083C8  00021080   SLL V0, V0, 2
9D0083CC  00561021   ADDU V0, V0, S6
9D0083D0  8C420000   LW V0, 0(V0)
9D0083D4  0B400152   J 0x9D000548
9D0083D8  0260A821   ADDU S5, S3, ZERO
2244:                
2245:                      OPCODE_BEGIN(D3)  /* DCP ($nn),Y */
2246:                         DCP(8, INDIR_Y, mem_writebyte, addr);
9D0083DC  26120001   ADDIU S2, S0, 1
9D008414  8FA70010   LW A3, 16(SP)
9D008418  02A7A821   ADDU S5, S5, A3
9D00841C  32B5FFFF   ANDI S5, S5, -1
9D008420  0F400000   JAL mem_readbyte
9D008424  02A02021   ADDU A0, S5, ZERO
9D008428  2442FFFF   ADDIU V0, V0, -1
9D00842C  305300FF   ANDI S3, V0, 255
9D008430  02A02021   ADDU A0, S5, ZERO
9D008434  0F400036   JAL mem_writebyte
9D008438  02602821   ADDU A1, S3, ZERO
9D00843C  02939823   SUBU S3, S4, S3
9D008440  7E770200   EXT S7, S3, 8, 1
9D008444  3AF70001   XORI S7, S7, 1
9D008448  327300FF   ANDI S3, S3, 255
9D00844C  8F828058   LW V0, -32680(GP)
9D008450  2442FFF8   ADDIU V0, V0, -8
9D008454  AF828058   SW V0, -32680(GP)
9D008458  8E230054   LW V1, 84(S1)
9D00845C  24630008   ADDIU V1, V1, 8
9D008468  0B4027B2   J .L45
9D00846C  0260A821   ADDU S5, S3, ZERO
2247:                         OPCODE_END
9D008460  1C400003   BGTZ V0, 0x9D008470
9D008464  AE230054   SW V1, 84(S1)
9D008470  26100002   ADDIU S0, S0, 2
9D00848C  90420000   LBU V0, 0(V0)
9D008490  00021080   SLL V0, V0, 2
9D008494  00561021   ADDU V0, V0, S6
9D008498  8C420000   LW V0, 0(V0)
9D00849C  0B400152   J 0x9D000548
9D0084A0  0260A821   ADDU S5, S3, ZERO
2248:                
2249:                      OPCODE_BEGIN(D5)  /* CMP $nn,X */
2250:                         CMP(4, ZP_IND_X_BYTE);
9D0084A4  26120001   ADDIU S2, S0, 1
9D0084C0  90420000   LBU V0, 0(V0)
9D0084C4  03C21021   ADDU V0, FP, V0
9D0084C8  304200FF   ANDI V0, V0, 255
9D0084CC  8F838054   LW V1, -32684(GP)
9D0084D0  00621021   ADDU V0, V1, V0
9D0084D4  90530000   LBU S3, 0(V0)
9D0084D8  02939823   SUBU S3, S4, S3
9D0084DC  7E770200   EXT S7, S3, 8, 1
9D0084E0  3AF70001   XORI S7, S7, 1
9D0084E4  327300FF   ANDI S3, S3, 255
9D0084E8  8F828058   LW V0, -32680(GP)
9D0084EC  2442FFFC   ADDIU V0, V0, -4
9D0084F0  AF828058   SW V0, -32680(GP)
9D0084F4  8E230054   LW V1, 84(S1)
9D0084F8  24630004   ADDIU V1, V1, 4
9D008504  0B4027B2   J .L45
9D008508  0260A821   ADDU S5, S3, ZERO
2251:                         OPCODE_END
9D0084FC  1C400003   BGTZ V0, 0x9D00850C
9D008500  AE230054   SW V1, 84(S1)
9D00850C  26100002   ADDIU S0, S0, 2
9D008528  90420000   LBU V0, 0(V0)
9D00852C  00021080   SLL V0, V0, 2
9D008530  00561021   ADDU V0, V0, S6
9D008534  8C420000   LW V0, 0(V0)
9D008538  0B400152   J 0x9D000548
9D00853C  0260A821   ADDU S5, S3, ZERO
2252:                
2253:                      OPCODE_BEGIN(D6)  /* DEC $nn,X */
2254:                         DEC(6, ZP_IND_X, ZP_WRITEBYTE, baddr);
9D008540  26120001   ADDIU S2, S0, 1
9D00855C  90420000   LBU V0, 0(V0)
9D008560  03C21021   ADDU V0, FP, V0
9D008564  304200FF   ANDI V0, V0, 255
9D008568  8F838054   LW V1, -32684(GP)
9D00856C  00621021   ADDU V0, V1, V0
9D008570  90530000   LBU S3, 0(V0)
9D008574  2673FFFF   ADDIU S3, S3, -1
9D008578  327300FF   ANDI S3, S3, 255
9D00857C  A0530000   SB S3, 0(V0)
9D008580  8F828058   LW V0, -32680(GP)
9D008584  2442FFFA   ADDIU V0, V0, -6
9D008588  AF828058   SW V0, -32680(GP)
9D00858C  8E230054   LW V1, 84(S1)
9D008590  24630006   ADDIU V1, V1, 6
9D00859C  0B4027B2   J .L45
9D0085A0  0260A821   ADDU S5, S3, ZERO
2255:                         OPCODE_END
9D008594  1C400003   BGTZ V0, 0x9D0085A4
9D008598  AE230054   SW V1, 84(S1)
9D0085A4  26100002   ADDIU S0, S0, 2
9D0085C0  90420000   LBU V0, 0(V0)
9D0085C4  00021080   SLL V0, V0, 2
9D0085C8  00561021   ADDU V0, V0, S6
9D0085CC  8C420000   LW V0, 0(V0)
9D0085D0  0B400152   J 0x9D000548
9D0085D4  0260A821   ADDU S5, S3, ZERO
2256:                
2257:                      OPCODE_BEGIN(D7)  /* DCP $nn,X */
2258:                         DCP(6, ZP_IND_X, ZP_WRITEBYTE, baddr);
9D0085D8  26120001   ADDIU S2, S0, 1
9D0085F4  90420000   LBU V0, 0(V0)
9D0085F8  03C21021   ADDU V0, FP, V0
9D0085FC  304200FF   ANDI V0, V0, 255
9D008600  8F838054   LW V1, -32684(GP)
9D008604  00621021   ADDU V0, V1, V0
9D008608  90530000   LBU S3, 0(V0)
9D00860C  2673FFFF   ADDIU S3, S3, -1
9D008610  327300FF   ANDI S3, S3, 255
9D008614  A0530000   SB S3, 0(V0)
9D008618  02939823   SUBU S3, S4, S3
9D00861C  7E770200   EXT S7, S3, 8, 1
9D008620  3AF70001   XORI S7, S7, 1
9D008624  327300FF   ANDI S3, S3, 255
9D008628  8F828058   LW V0, -32680(GP)
9D00862C  2442FFFA   ADDIU V0, V0, -6
9D008630  AF828058   SW V0, -32680(GP)
9D008634  8E230054   LW V1, 84(S1)
9D008638  24630006   ADDIU V1, V1, 6
9D008644  0B4027B2   J .L45
9D008648  0260A821   ADDU S5, S3, ZERO
2259:                         OPCODE_END
9D00863C  1C400003   BGTZ V0, 0x9D00864C
9D008640  AE230054   SW V1, 84(S1)
9D00864C  26100002   ADDIU S0, S0, 2
9D008668  90420000   LBU V0, 0(V0)
9D00866C  00021080   SLL V0, V0, 2
9D008670  00561021   ADDU V0, V0, S6
9D008674  8C420000   LW V0, 0(V0)
9D008678  0B400152   J 0x9D000548
9D00867C  0260A821   ADDU S5, S3, ZERO
2260:                
2261:                      OPCODE_BEGIN(D8)  /* CLD */
2262:                         CLD();
9D008680  8F828058   LW V0, -32680(GP)
9D008684  2442FFFE   ADDIU V0, V0, -2
9D008688  AF828058   SW V0, -32680(GP)
9D00868C  8E230054   LW V1, 84(S1)
9D008690  24630002   ADDIU V1, V1, 2
9D0086A0  0B4027B2   J .L45
9D0086A4  AFA00020   SW ZERO, 32(SP)
2263:                         OPCODE_END
9D008694  1C400004   BGTZ V0, .LBB1776
9D008698  AE230054   SW V1, 84(S1)
9D00869C  02009021   ADDU S2, S0, ZERO
9D0086C0  90420000   LBU V0, 0(V0)
9D0086C4  00021080   SLL V0, V0, 2
9D0086C8  00561021   ADDU V0, V0, S6
9D0086CC  8C420000   LW V0, 0(V0)
9D0086D0  26100001   ADDIU S0, S0, 1
9D0086D4  0B400152   J 0x9D000548
9D0086D8  AFA00020   SW ZERO, 32(SP)
2264:                
2265:                      OPCODE_BEGIN(D9)  /* CMP $nnnn,Y */
2266:                         CMP(4, ABS_IND_Y_BYTE_READ);
9D008720  8FA80010   LW T0, 16(SP)
9D008724  00882021   ADDU A0, A0, T0
9D008728  3084FFFF   ANDI A0, A0, -1
9D00872C  308200FF   ANDI V0, A0, 255
9D008730  0048102B   SLTU V0, V0, T0
9D008734  10400007   BEQ V0, ZERO, 0x9D008754
9D008738  26120002   ADDIU S2, S0, 2
9D00873C  8F828058   LW V0, -32680(GP)
9D008740  2442FFFF   ADDIU V0, V0, -1
9D008744  AF828058   SW V0, -32680(GP)
9D008748  8E220054   LW V0, 84(S1)
9D00874C  24420001   ADDIU V0, V0, 1
9D008750  AE220054   SW V0, 84(S1)
9D008754  0F400000   JAL mem_readbyte
9D008758  00000000   NOP
9D00875C  02821023   SUBU V0, S4, V0
9D008760  7C570200   EXT S7, V0, 8, 1
9D008764  3AF70001   XORI S7, S7, 1
9D008768  305300FF   ANDI S3, V0, 255
9D00876C  8F828058   LW V0, -32680(GP)
9D008770  2442FFFC   ADDIU V0, V0, -4
9D008774  AF828058   SW V0, -32680(GP)
9D008778  8E230054   LW V1, 84(S1)
9D00877C  24630004   ADDIU V1, V1, 4
9D008788  0B4027B2   J .L45
9D00878C  0260A821   ADDU S5, S3, ZERO
2267:                         OPCODE_END
9D008780  1C400003   BGTZ V0, 0x9D008790
9D008784  AE230054   SW V1, 84(S1)
9D008790  26100003   ADDIU S0, S0, 3
9D0087AC  90420000   LBU V0, 0(V0)
9D0087B0  00021080   SLL V0, V0, 2
9D0087B4  00561021   ADDU V0, V0, S6
9D0087B8  8C420000   LW V0, 0(V0)
9D0087BC  0B400152   J 0x9D000548
9D0087C0  0260A821   ADDU S5, S3, ZERO
2268:                
2269:                      OPCODE_BEGIN(DB)  /* DCP $nnnn,Y */
2270:                         DCP(7, ABS_IND_Y, mem_writebyte, addr);
9D0087C8  26120002   ADDIU S2, S0, 2
9D00880C  8FA20010   LW V0, 16(SP)
9D008810  02A2A821   ADDU S5, S5, V0
9D008814  32B5FFFF   ANDI S5, S5, -1
9D008818  0F400000   JAL mem_readbyte
9D00881C  02A02021   ADDU A0, S5, ZERO
9D008820  2442FFFF   ADDIU V0, V0, -1
9D008824  305300FF   ANDI S3, V0, 255
9D008828  02A02021   ADDU A0, S5, ZERO
9D00882C  0F400036   JAL mem_writebyte
9D008830  02602821   ADDU A1, S3, ZERO
9D008834  02939823   SUBU S3, S4, S3
9D008838  7E770200   EXT S7, S3, 8, 1
9D00883C  3AF70001   XORI S7, S7, 1
9D008840  327300FF   ANDI S3, S3, 255
9D008844  8F828058   LW V0, -32680(GP)
9D008848  2442FFF9   ADDIU V0, V0, -7
9D00884C  AF828058   SW V0, -32680(GP)
9D008850  8E230054   LW V1, 84(S1)
9D008854  24630007   ADDIU V1, V1, 7
9D008860  0B4027B2   J .L45
9D008864  0260A821   ADDU S5, S3, ZERO
2271:                         OPCODE_END                  
9D008858  1C400003   BGTZ V0, 0x9D008868
9D00885C  AE230054   SW V1, 84(S1)
9D008868  26100003   ADDIU S0, S0, 3
9D008884  90420000   LBU V0, 0(V0)
9D008888  00021080   SLL V0, V0, 2
9D00888C  00561021   ADDU V0, V0, S6
9D008890  8C420000   LW V0, 0(V0)
9D008894  0B400152   J 0x9D000548
9D008898  0260A821   ADDU S5, S3, ZERO
2272:                
2273:                      OPCODE_BEGIN(DD)  /* CMP $nnnn,X */
2274:                         CMP(4, ABS_IND_X_BYTE_READ);
9D0088E0  009E2021   ADDU A0, A0, FP
9D0088E4  3084FFFF   ANDI A0, A0, -1
9D0088E8  308200FF   ANDI V0, A0, 255
9D0088EC  005E102B   SLTU V0, V0, FP
9D0088F0  10400007   BEQ V0, ZERO, 0x9D008910
9D0088F4  26120002   ADDIU S2, S0, 2
9D0088F8  8F828058   LW V0, -32680(GP)
9D0088FC  2442FFFF   ADDIU V0, V0, -1
9D008900  AF828058   SW V0, -32680(GP)
9D008904  8E220054   LW V0, 84(S1)
9D008908  24420001   ADDIU V0, V0, 1
9D00890C  AE220054   SW V0, 84(S1)
9D008910  0F400000   JAL mem_readbyte
9D008914  00000000   NOP
9D008918  02821023   SUBU V0, S4, V0
9D00891C  7C570200   EXT S7, V0, 8, 1
9D008920  3AF70001   XORI S7, S7, 1
9D008924  305300FF   ANDI S3, V0, 255
9D008928  8F828058   LW V0, -32680(GP)
9D00892C  2442FFFC   ADDIU V0, V0, -4
9D008930  AF828058   SW V0, -32680(GP)
9D008934  8E230054   LW V1, 84(S1)
9D008938  24630004   ADDIU V1, V1, 4
9D008944  0B4027B2   J .L45
9D008948  0260A821   ADDU S5, S3, ZERO
2275:                         OPCODE_END
9D00893C  1C400003   BGTZ V0, 0x9D00894C
9D008940  AE230054   SW V1, 84(S1)
9D00894C  26100003   ADDIU S0, S0, 3
9D008968  90420000   LBU V0, 0(V0)
9D00896C  00021080   SLL V0, V0, 2
9D008970  00561021   ADDU V0, V0, S6
9D008974  8C420000   LW V0, 0(V0)
9D008978  0B400152   J 0x9D000548
9D00897C  0260A821   ADDU S5, S3, ZERO
2276:                
2277:                      OPCODE_BEGIN(DE)  /* DEC $nnnn,X */
2278:                         DEC(7, ABS_IND_X, mem_writebyte, addr);
9D008984  26120002   ADDIU S2, S0, 2
9D0089C8  02BEA821   ADDU S5, S5, FP
9D0089CC  32B5FFFF   ANDI S5, S5, -1
9D0089D0  0F400000   JAL mem_readbyte
9D0089D4  02A02021   ADDU A0, S5, ZERO
9D0089D8  2442FFFF   ADDIU V0, V0, -1
9D0089DC  305300FF   ANDI S3, V0, 255
9D0089E0  02A02021   ADDU A0, S5, ZERO
9D0089E4  0F400036   JAL mem_writebyte
9D0089E8  02602821   ADDU A1, S3, ZERO
9D0089EC  8F828058   LW V0, -32680(GP)
9D0089F0  2442FFF9   ADDIU V0, V0, -7
9D0089F4  AF828058   SW V0, -32680(GP)
9D0089F8  8E230054   LW V1, 84(S1)
9D0089FC  24630007   ADDIU V1, V1, 7
9D008A08  0B4027B2   J .L45
9D008A0C  0260A821   ADDU S5, S3, ZERO
2279:                         OPCODE_END
9D008A00  1C400003   BGTZ V0, 0x9D008A10
9D008A04  AE230054   SW V1, 84(S1)
9D008A10  26100003   ADDIU S0, S0, 3
9D008A2C  90420000   LBU V0, 0(V0)
9D008A30  00021080   SLL V0, V0, 2
9D008A34  00561021   ADDU V0, V0, S6
9D008A38  8C420000   LW V0, 0(V0)
9D008A3C  0B400152   J 0x9D000548
9D008A40  0260A821   ADDU S5, S3, ZERO
2280:                
2281:                      OPCODE_BEGIN(DF)  /* DCP $nnnn,X */
2282:                         DCP(7, ABS_IND_X, mem_writebyte, addr);
9D008A48  26120002   ADDIU S2, S0, 2
9D008A8C  02BEA821   ADDU S5, S5, FP
9D008A90  32B5FFFF   ANDI S5, S5, -1
9D008A94  0F400000   JAL mem_readbyte
9D008A98  02A02021   ADDU A0, S5, ZERO
9D008A9C  2442FFFF   ADDIU V0, V0, -1
9D008AA0  305300FF   ANDI S3, V0, 255
9D008AA4  02A02021   ADDU A0, S5, ZERO
9D008AA8  0F400036   JAL mem_writebyte
9D008AAC  02602821   ADDU A1, S3, ZERO
9D008AB0  02939823   SUBU S3, S4, S3
9D008AB4  7E770200   EXT S7, S3, 8, 1
9D008AB8  3AF70001   XORI S7, S7, 1
9D008ABC  327300FF   ANDI S3, S3, 255
9D008AC0  8F828058   LW V0, -32680(GP)
9D008AC4  2442FFF9   ADDIU V0, V0, -7
9D008AC8  AF828058   SW V0, -32680(GP)
9D008ACC  8E230054   LW V1, 84(S1)
9D008AD0  24630007   ADDIU V1, V1, 7
9D008ADC  0B4027B2   J .L45
9D008AE0  0260A821   ADDU S5, S3, ZERO
2283:                         OPCODE_END
9D008AD4  1C400003   BGTZ V0, 0x9D008AE4
9D008AD8  AE230054   SW V1, 84(S1)
9D008AE4  26100003   ADDIU S0, S0, 3
9D008B00  90420000   LBU V0, 0(V0)
9D008B04  00021080   SLL V0, V0, 2
9D008B08  00561021   ADDU V0, V0, S6
9D008B0C  8C420000   LW V0, 0(V0)
9D008B10  0B400152   J 0x9D000548
9D008B14  0260A821   ADDU S5, S3, ZERO
2284:                
2285:                      OPCODE_BEGIN(E0)  /* CPX #$nn */
2286:                         CPX(2, IMMEDIATE_BYTE);
9D008B18  26120001   ADDIU S2, S0, 1
9D008B34  90530000   LBU S3, 0(V0)
9D008B38  03D39823   SUBU S3, FP, S3
9D008B3C  7E770200   EXT S7, S3, 8, 1
9D008B40  3AF70001   XORI S7, S7, 1
9D008B44  327300FF   ANDI S3, S3, 255
9D008B48  8F828058   LW V0, -32680(GP)
9D008B4C  2442FFFE   ADDIU V0, V0, -2
9D008B50  AF828058   SW V0, -32680(GP)
9D008B54  8E230054   LW V1, 84(S1)
9D008B58  24630002   ADDIU V1, V1, 2
9D008B64  0B4027B2   J .L45
9D008B68  0260A821   ADDU S5, S3, ZERO
2287:                         OPCODE_END
9D008B5C  1C400003   BGTZ V0, 0x9D008B6C
9D008B60  AE230054   SW V1, 84(S1)
9D008B6C  26100002   ADDIU S0, S0, 2
9D008B88  90420000   LBU V0, 0(V0)
9D008B8C  00021080   SLL V0, V0, 2
9D008B90  00561021   ADDU V0, V0, S6
9D008B94  8C420000   LW V0, 0(V0)
9D008B98  0B400152   J 0x9D000548
9D008B9C  0260A821   ADDU S5, S3, ZERO
2288:                
2289:                      OPCODE_BEGIN(E1)  /* SBC ($nn,X) */
2290:                         SBC(6, INDIR_X_BYTE);
9D008BA0  26120001   ADDIU S2, S0, 1
9D008BBC  90420000   LBU V0, 0(V0)
9D008BC0  03C21021   ADDU V0, FP, V0
9D008BDC  0F400000   JAL mem_readbyte
9D008BE0  308400FF   ANDI A0, A0, 255
9D008BE4  02821823   SUBU V1, S4, V0
9D008BE8  3AF70001   XORI S7, S7, 1
9D008BEC  00771823   SUBU V1, V1, S7
9D008BF0  307300FF   ANDI S3, V1, 255
9D008BF4  00541026   XOR V0, V0, S4
9D008BF8  7C023004   INS V0, ZERO, 0, 7
9D008BFC  0274A026   XOR S4, S3, S4
9D008C00  00541024   AND V0, V0, S4
9D008C04  304200FF   ANDI V0, V0, 255
9D008C08  AFA20018   SW V0, 24(SP)
9D008C0C  38630100   XORI V1, V1, 256
9D008C10  7C770200   EXT S7, V1, 8, 1
9D008C14  8F828058   LW V0, -32680(GP)
9D008C18  2442FFFA   ADDIU V0, V0, -6
9D008C1C  AF828058   SW V0, -32680(GP)
9D008C20  8E230054   LW V1, 84(S1)
9D008C24  24630006   ADDIU V1, V1, 6
9D008C30  0260A021   ADDU S4, S3, ZERO
9D008C34  0B4027B2   J .L45
9D008C38  0260A821   ADDU S5, S3, ZERO
9D008C68  0260A021   ADDU S4, S3, ZERO
2291:                         OPCODE_END
9D008C28  1C400004   BGTZ V0, 0x9D008C3C
9D008C2C  AE230054   SW V1, 84(S1)
9D008C3C  26100002   ADDIU S0, S0, 2
9D008C58  90420000   LBU V0, 0(V0)
9D008C5C  00021080   SLL V0, V0, 2
9D008C60  00561021   ADDU V0, V0, S6
9D008C64  8C420000   LW V0, 0(V0)
9D008C6C  0B400152   J 0x9D000548
9D008C70  0260A821   ADDU S5, S3, ZERO
2292:                
2293:                      OPCODE_BEGIN(E3)  /* ISB ($nn,X) */
2294:                         ISB(8, INDIR_X, mem_writebyte, addr);
9D008C74  26120001   ADDIU S2, S0, 1
9D008C90  90420000   LBU V0, 0(V0)
9D008C94  03C21021   ADDU V0, FP, V0
9D008CB4  0F400000   JAL mem_readbyte
9D008CB8  02602021   ADDU A0, S3, ZERO
9D008CBC  24420001   ADDIU V0, V0, 1
9D008CC0  305500FF   ANDI S5, V0, 255
9D008CC4  02602021   ADDU A0, S3, ZERO
9D008CC8  0F400036   JAL mem_writebyte
9D008CCC  02A02821   ADDU A1, S5, ZERO
9D008CD0  02951023   SUBU V0, S4, S5
9D008CD4  3AF70001   XORI S7, S7, 1
9D008CD8  00571023   SUBU V0, V0, S7
9D008CDC  305300FF   ANDI S3, V0, 255
9D008CE0  02B41826   XOR V1, S5, S4
9D008CE4  7C033004   INS V1, ZERO, 0, 7
9D008CE8  0274A026   XOR S4, S3, S4
9D008CEC  00741824   AND V1, V1, S4
9D008CF0  306300FF   ANDI V1, V1, 255
9D008CF4  AFA30018   SW V1, 24(SP)
9D008CF8  38420100   XORI V0, V0, 256
9D008CFC  7C570200   EXT S7, V0, 8, 1
9D008D00  8F828058   LW V0, -32680(GP)
9D008D04  2442FFF8   ADDIU V0, V0, -8
9D008D08  AF828058   SW V0, -32680(GP)
9D008D0C  8E230054   LW V1, 84(S1)
9D008D10  24630008   ADDIU V1, V1, 8
9D008D1C  0260A021   ADDU S4, S3, ZERO
9D008D20  0B4027B2   J .L45
9D008D24  0260A821   ADDU S5, S3, ZERO
9D008D54  0260A021   ADDU S4, S3, ZERO
2295:                         OPCODE_END
9D008D14  1C400004   BGTZ V0, 0x9D008D28
9D008D18  AE230054   SW V1, 84(S1)
9D008D28  26100002   ADDIU S0, S0, 2
9D008D44  90420000   LBU V0, 0(V0)
9D008D48  00021080   SLL V0, V0, 2
9D008D4C  00561021   ADDU V0, V0, S6
9D008D50  8C420000   LW V0, 0(V0)
9D008D58  0B400152   J 0x9D000548
9D008D5C  0260A821   ADDU S5, S3, ZERO
2296:                
2297:                      OPCODE_BEGIN(E4)  /* CPX $nn */
2298:                         CPX(3, ZERO_PAGE_BYTE);
9D008D60  26120001   ADDIU S2, S0, 1
9D008D7C  90420000   LBU V0, 0(V0)
9D008D80  8F838054   LW V1, -32684(GP)
9D008D84  00621021   ADDU V0, V1, V0
9D008D88  90530000   LBU S3, 0(V0)
9D008D8C  03D39823   SUBU S3, FP, S3
9D008D90  7E770200   EXT S7, S3, 8, 1
9D008D94  3AF70001   XORI S7, S7, 1
9D008D98  327300FF   ANDI S3, S3, 255
9D008D9C  8F828058   LW V0, -32680(GP)
9D008DA0  2442FFFD   ADDIU V0, V0, -3
9D008DA4  AF828058   SW V0, -32680(GP)
9D008DA8  8E230054   LW V1, 84(S1)
9D008DAC  24630003   ADDIU V1, V1, 3
9D008DB8  0B4027B2   J .L45
9D008DBC  0260A821   ADDU S5, S3, ZERO
2299:                         OPCODE_END
9D008DB0  1C400003   BGTZ V0, 0x9D008DC0
9D008DB4  AE230054   SW V1, 84(S1)
9D008DC0  26100002   ADDIU S0, S0, 2
9D008DDC  90420000   LBU V0, 0(V0)
9D008DE0  00021080   SLL V0, V0, 2
9D008DE4  00561021   ADDU V0, V0, S6
9D008DE8  8C420000   LW V0, 0(V0)
9D008DEC  0B400152   J 0x9D000548
9D008DF0  0260A821   ADDU S5, S3, ZERO
2300:                
2301:                      OPCODE_BEGIN(E5)  /* SBC $nn */
2302:                         SBC(3, ZERO_PAGE_BYTE);
9D008DF4  26120001   ADDIU S2, S0, 1
9D008E10  90420000   LBU V0, 0(V0)
9D008E14  8F838054   LW V1, -32684(GP)
9D008E18  00621021   ADDU V0, V1, V0
9D008E1C  90430000   LBU V1, 0(V0)
9D008E20  02831023   SUBU V0, S4, V1
9D008E24  3AF70001   XORI S7, S7, 1
9D008E28  00571023   SUBU V0, V0, S7
9D008E2C  305300FF   ANDI S3, V0, 255
9D008E30  00741826   XOR V1, V1, S4
9D008E34  7C033004   INS V1, ZERO, 0, 7
9D008E38  0274A026   XOR S4, S3, S4
9D008E3C  00741824   AND V1, V1, S4
9D008E40  306300FF   ANDI V1, V1, 255
9D008E44  AFA30018   SW V1, 24(SP)
9D008E48  38420100   XORI V0, V0, 256
9D008E4C  7C570200   EXT S7, V0, 8, 1
9D008E50  8F828058   LW V0, -32680(GP)
9D008E54  2442FFFD   ADDIU V0, V0, -3
9D008E58  AF828058   SW V0, -32680(GP)
9D008E5C  8E230054   LW V1, 84(S1)
9D008E60  24630003   ADDIU V1, V1, 3
9D008E6C  0260A021   ADDU S4, S3, ZERO
9D008E70  0B4027B2   J .L45
9D008E74  0260A821   ADDU S5, S3, ZERO
9D008EA4  0260A021   ADDU S4, S3, ZERO
2303:                         OPCODE_END
9D008E64  1C400004   BGTZ V0, 0x9D008E78
9D008E68  AE230054   SW V1, 84(S1)
9D008E78  26100002   ADDIU S0, S0, 2
9D008E94  90420000   LBU V0, 0(V0)
9D008E98  00021080   SLL V0, V0, 2
9D008E9C  00561021   ADDU V0, V0, S6
9D008EA0  8C420000   LW V0, 0(V0)
9D008EA8  0B400152   J 0x9D000548
9D008EAC  0260A821   ADDU S5, S3, ZERO
2304:                
2305:                      OPCODE_BEGIN(E6)  /* INC $nn */
2306:                         INC(5, ZERO_PAGE, ZP_WRITEBYTE, baddr);
9D008EB0  26120001   ADDIU S2, S0, 1
9D008ECC  90420000   LBU V0, 0(V0)
9D008ED0  8F838054   LW V1, -32684(GP)
9D008ED4  00621021   ADDU V0, V1, V0
9D008ED8  90530000   LBU S3, 0(V0)
9D008EDC  26730001   ADDIU S3, S3, 1
9D008EE0  327300FF   ANDI S3, S3, 255
9D008EE4  A0530000   SB S3, 0(V0)
9D008EE8  8F828058   LW V0, -32680(GP)
9D008EEC  2442FFFB   ADDIU V0, V0, -5
9D008EF0  AF828058   SW V0, -32680(GP)
9D008EF4  8E230054   LW V1, 84(S1)
9D008EF8  24630005   ADDIU V1, V1, 5
9D008F04  0B4027B2   J .L45
9D008F08  0260A821   ADDU S5, S3, ZERO
2307:                         OPCODE_END
9D008EFC  1C400003   BGTZ V0, 0x9D008F0C
9D008F00  AE230054   SW V1, 84(S1)
9D008F0C  26100002   ADDIU S0, S0, 2
9D008F28  90420000   LBU V0, 0(V0)
9D008F2C  00021080   SLL V0, V0, 2
9D008F30  00561021   ADDU V0, V0, S6
9D008F34  8C420000   LW V0, 0(V0)
9D008F38  0B400152   J 0x9D000548
9D008F3C  0260A821   ADDU S5, S3, ZERO
2308:                
2309:                      OPCODE_BEGIN(E7)  /* ISB $nn */
2310:                         ISB(5, ZERO_PAGE, ZP_WRITEBYTE, baddr);
9D008F40  26120001   ADDIU S2, S0, 1
9D008F5C  90420000   LBU V0, 0(V0)
9D008F60  8F838054   LW V1, -32684(GP)
9D008F64  00621821   ADDU V1, V1, V0
9D008F68  90620000   LBU V0, 0(V1)
9D008F6C  24420001   ADDIU V0, V0, 1
9D008F70  304200FF   ANDI V0, V0, 255
9D008F74  A0620000   SB V0, 0(V1)
9D008F78  02821823   SUBU V1, S4, V0
9D008F7C  3AF70001   XORI S7, S7, 1
9D008F80  00771823   SUBU V1, V1, S7
9D008F84  307300FF   ANDI S3, V1, 255
9D008F88  00541026   XOR V0, V0, S4
9D008F8C  7C023004   INS V0, ZERO, 0, 7
9D008F90  0274A026   XOR S4, S3, S4
9D008F94  00541024   AND V0, V0, S4
9D008F98  304200FF   ANDI V0, V0, 255
9D008F9C  AFA20018   SW V0, 24(SP)
9D008FA0  38630100   XORI V1, V1, 256
9D008FA4  7C770200   EXT S7, V1, 8, 1
9D008FA8  8F828058   LW V0, -32680(GP)
9D008FAC  2442FFFB   ADDIU V0, V0, -5
9D008FB0  AF828058   SW V0, -32680(GP)
9D008FB4  8E230054   LW V1, 84(S1)
9D008FB8  24630005   ADDIU V1, V1, 5
9D008FC4  0260A021   ADDU S4, S3, ZERO
9D008FC8  0B4027B2   J .L45
9D008FCC  0260A821   ADDU S5, S3, ZERO
9D008FFC  0260A021   ADDU S4, S3, ZERO
2311:                         OPCODE_END
9D008FBC  1C400004   BGTZ V0, 0x9D008FD0
9D008FC0  AE230054   SW V1, 84(S1)
9D008FD0  26100002   ADDIU S0, S0, 2
9D008FEC  90420000   LBU V0, 0(V0)
9D008FF0  00021080   SLL V0, V0, 2
9D008FF4  00561021   ADDU V0, V0, S6
9D008FF8  8C420000   LW V0, 0(V0)
9D009000  0B400152   J 0x9D000548
9D009004  0260A821   ADDU S5, S3, ZERO
2312:                
2313:                      OPCODE_BEGIN(E8)  /* INX */
2314:                         INX();
9D009008  27D30001   ADDIU S3, FP, 1
9D00900C  327300FF   ANDI S3, S3, 255
9D009010  8F828058   LW V0, -32680(GP)
9D009014  2442FFFE   ADDIU V0, V0, -2
9D009018  AF828058   SW V0, -32680(GP)
9D00901C  8E230054   LW V1, 84(S1)
9D009020  24630002   ADDIU V1, V1, 2
9D00902C  0260F021   ADDU FP, S3, ZERO
9D009034  0B4027B2   J .L45
9D009038  0260A821   ADDU S5, S3, ZERO
9D009064  0260F021   ADDU FP, S3, ZERO
2315:                         OPCODE_END
9D009024  1C400005   BGTZ V0, .LBB1836
9D009028  AE230054   SW V1, 84(S1)
9D009030  02009021   ADDU S2, S0, ZERO
9D009054  90420000   LBU V0, 0(V0)
9D009058  00021080   SLL V0, V0, 2
9D00905C  00561021   ADDU V0, V0, S6
9D009060  8C420000   LW V0, 0(V0)
9D009068  26100001   ADDIU S0, S0, 1
9D00906C  0B400152   J 0x9D000548
9D009070  0260A821   ADDU S5, S3, ZERO
2316:                
2317:                      OPCODE_BEGIN(E9)  /* SBC #$nn */
2318:                      OPCODE_BEGIN(EB)  /* USBC #$nn */
2319:                         SBC(2, IMMEDIATE_BYTE);
9D009074  26120001   ADDIU S2, S0, 1
9D009094  02831023   SUBU V0, S4, V1
9D009098  3AF70001   XORI S7, S7, 1
9D00909C  00571023   SUBU V0, V0, S7
9D0090A0  305300FF   ANDI S3, V0, 255
9D0090A4  00741826   XOR V1, V1, S4
9D0090A8  7C033004   INS V1, ZERO, 0, 7
9D0090AC  0274A026   XOR S4, S3, S4
9D0090B0  00741824   AND V1, V1, S4
9D0090B4  306300FF   ANDI V1, V1, 255
9D0090B8  AFA30018   SW V1, 24(SP)
9D0090BC  38420100   XORI V0, V0, 256
9D0090C0  7C570200   EXT S7, V0, 8, 1
9D0090C4  8F828058   LW V0, -32680(GP)
9D0090C8  2442FFFE   ADDIU V0, V0, -2
9D0090CC  AF828058   SW V0, -32680(GP)
9D0090D0  8E230054   LW V1, 84(S1)
9D0090D4  24630002   ADDIU V1, V1, 2
9D0090E0  0260A021   ADDU S4, S3, ZERO
9D0090E4  0B4027B2   J .L45
9D0090E8  0260A821   ADDU S5, S3, ZERO
9D009118  0260A021   ADDU S4, S3, ZERO
2320:                         OPCODE_END
9D0090D8  1C400004   BGTZ V0, 0x9D0090EC
9D0090DC  AE230054   SW V1, 84(S1)
9D0090EC  26100002   ADDIU S0, S0, 2
9D009108  90420000   LBU V0, 0(V0)
9D00910C  00021080   SLL V0, V0, 2
9D009110  00561021   ADDU V0, V0, S6
9D009114  8C420000   LW V0, 0(V0)
9D00911C  0B400152   J 0x9D000548
9D009120  0260A821   ADDU S5, S3, ZERO
2321:                
2322:                      OPCODE_BEGIN(EA)  /* NOP */
2323:                         NOP();
9D009124  8F828058   LW V0, -32680(GP)
9D009128  2442FFFE   ADDIU V0, V0, -2
9D00912C  AF828058   SW V0, -32680(GP)
9D009130  8E230054   LW V1, 84(S1)
9D009134  24630002   ADDIU V1, V1, 2
2324:                         OPCODE_END
9D009138  1C400003   BGTZ V0, .LBB1842
9D00913C  AE230054   SW V1, 84(S1)
9D009140  0B4027B2   J .L45
9D009144  02009021   ADDU S2, S0, ZERO
9D009160  90420000   LBU V0, 0(V0)
9D009164  00021080   SLL V0, V0, 2
9D009168  00561021   ADDU V0, V0, S6
9D00916C  8C420000   LW V0, 0(V0)
9D009170  0B400152   J 0x9D000548
9D009174  26100001   ADDIU S0, S0, 1
2325:                
2326:                      OPCODE_BEGIN(EC)  /* CPX $nnnn */
2327:                         CPX(4, ABSOLUTE_BYTE);
9D00917C  26120002   ADDIU S2, S0, 2
9D0091BC  0F400000   JAL mem_readbyte
9D0091C0  308400FF   ANDI A0, A0, 255
9D0091C4  03C21023   SUBU V0, FP, V0
9D0091C8  7C570200   EXT S7, V0, 8, 1
9D0091CC  3AF70001   XORI S7, S7, 1
9D0091D0  305300FF   ANDI S3, V0, 255
9D0091D4  8F828058   LW V0, -32680(GP)
9D0091D8  2442FFFC   ADDIU V0, V0, -4
9D0091DC  AF828058   SW V0, -32680(GP)
9D0091E0  8E230054   LW V1, 84(S1)
9D0091E4  24630004   ADDIU V1, V1, 4
9D0091F0  0B4027B2   J .L45
9D0091F4  0260A821   ADDU S5, S3, ZERO
2328:                         OPCODE_END
9D0091E8  1C400003   BGTZ V0, 0x9D0091F8
9D0091EC  AE230054   SW V1, 84(S1)
9D0091F8  26100003   ADDIU S0, S0, 3
9D009214  90420000   LBU V0, 0(V0)
9D009218  00021080   SLL V0, V0, 2
9D00921C  00561021   ADDU V0, V0, S6
9D009220  8C420000   LW V0, 0(V0)
9D009224  0B400152   J 0x9D000548
9D009228  0260A821   ADDU S5, S3, ZERO
2329:                
2330:                      OPCODE_BEGIN(ED)  /* SBC $nnnn */
2331:                         SBC(4, ABSOLUTE_BYTE);
9D009230  26120002   ADDIU S2, S0, 2
9D009270  0F400000   JAL mem_readbyte
9D009274  308400FF   ANDI A0, A0, 255
9D009278  02821823   SUBU V1, S4, V0
9D00927C  3AF70001   XORI S7, S7, 1
9D009280  00771823   SUBU V1, V1, S7
9D009284  307300FF   ANDI S3, V1, 255
9D009288  00541026   XOR V0, V0, S4
9D00928C  7C023004   INS V0, ZERO, 0, 7
9D009290  0274A026   XOR S4, S3, S4
9D009294  00541024   AND V0, V0, S4
9D009298  304200FF   ANDI V0, V0, 255
9D00929C  AFA20018   SW V0, 24(SP)
9D0092A0  38630100   XORI V1, V1, 256
9D0092A4  7C770200   EXT S7, V1, 8, 1
9D0092A8  8F828058   LW V0, -32680(GP)
9D0092AC  2442FFFC   ADDIU V0, V0, -4
9D0092B0  AF828058   SW V0, -32680(GP)
9D0092B4  8E230054   LW V1, 84(S1)
9D0092B8  24630004   ADDIU V1, V1, 4
9D0092C4  0260A021   ADDU S4, S3, ZERO
9D0092C8  0B4027B2   J .L45
9D0092CC  0260A821   ADDU S5, S3, ZERO
9D0092FC  0260A021   ADDU S4, S3, ZERO
2332:                         OPCODE_END
9D0092BC  1C400004   BGTZ V0, 0x9D0092D0
9D0092C0  AE230054   SW V1, 84(S1)
9D0092D0  26100003   ADDIU S0, S0, 3
9D0092EC  90420000   LBU V0, 0(V0)
9D0092F0  00021080   SLL V0, V0, 2
9D0092F4  00561021   ADDU V0, V0, S6
9D0092F8  8C420000   LW V0, 0(V0)
9D009300  0B400152   J 0x9D000548
9D009304  0260A821   ADDU S5, S3, ZERO
2333:                
2334:                      OPCODE_BEGIN(EE)  /* INC $nnnn */
2335:                         INC(6, ABSOLUTE, mem_writebyte, addr);
9D00934C  26120002   ADDIU S2, S0, 2
9D009350  0F400000   JAL mem_readbyte
9D009354  02A02021   ADDU A0, S5, ZERO
9D009358  24420001   ADDIU V0, V0, 1
9D00935C  305300FF   ANDI S3, V0, 255
9D009360  02A02021   ADDU A0, S5, ZERO
9D009364  0F400036   JAL mem_writebyte
9D009368  02602821   ADDU A1, S3, ZERO
9D00936C  8F828058   LW V0, -32680(GP)
9D009370  2442FFFA   ADDIU V0, V0, -6
9D009374  AF828058   SW V0, -32680(GP)
9D009378  8E230054   LW V1, 84(S1)
9D00937C  24630006   ADDIU V1, V1, 6
9D009388  0B4027B2   J .L45
9D00938C  0260A821   ADDU S5, S3, ZERO
2336:                         OPCODE_END
9D009380  1C400003   BGTZ V0, 0x9D009390
9D009384  AE230054   SW V1, 84(S1)
9D009390  26100003   ADDIU S0, S0, 3
9D0093AC  90420000   LBU V0, 0(V0)
9D0093B0  00021080   SLL V0, V0, 2
9D0093B4  00561021   ADDU V0, V0, S6
9D0093B8  8C420000   LW V0, 0(V0)
9D0093BC  0B400152   J 0x9D000548
9D0093C0  0260A821   ADDU S5, S3, ZERO
2337:                
2338:                      OPCODE_BEGIN(EF)  /* ISB $nnnn */
2339:                         ISB(6, ABSOLUTE, mem_writebyte, addr);
9D009408  26120002   ADDIU S2, S0, 2
9D00940C  0F400000   JAL mem_readbyte
9D009410  02602021   ADDU A0, S3, ZERO
9D009414  24420001   ADDIU V0, V0, 1
9D009418  305500FF   ANDI S5, V0, 255
9D00941C  02602021   ADDU A0, S3, ZERO
9D009420  0F400036   JAL mem_writebyte
9D009424  02A02821   ADDU A1, S5, ZERO
9D009428  02951023   SUBU V0, S4, S5
9D00942C  3AF70001   XORI S7, S7, 1
9D009430  00571023   SUBU V0, V0, S7
9D009434  305300FF   ANDI S3, V0, 255
9D009438  02B41826   XOR V1, S5, S4
9D00943C  7C033004   INS V1, ZERO, 0, 7
9D009440  0274A026   XOR S4, S3, S4
9D009444  00741824   AND V1, V1, S4
9D009448  306300FF   ANDI V1, V1, 255
9D00944C  AFA30018   SW V1, 24(SP)
9D009450  38420100   XORI V0, V0, 256
9D009454  7C570200   EXT S7, V0, 8, 1
9D009458  8F828058   LW V0, -32680(GP)
9D00945C  2442FFFA   ADDIU V0, V0, -6
9D009460  AF828058   SW V0, -32680(GP)
9D009464  8E230054   LW V1, 84(S1)
9D009468  24630006   ADDIU V1, V1, 6
9D009474  0260A021   ADDU S4, S3, ZERO
9D009478  0B4027B2   J .L45
9D00947C  0260A821   ADDU S5, S3, ZERO
9D0094AC  0260A021   ADDU S4, S3, ZERO
2340:                         OPCODE_END
9D00946C  1C400004   BGTZ V0, 0x9D009480
9D009470  AE230054   SW V1, 84(S1)
9D009480  26100003   ADDIU S0, S0, 3
9D00949C  90420000   LBU V0, 0(V0)
9D0094A0  00021080   SLL V0, V0, 2
9D0094A4  00561021   ADDU V0, V0, S6
9D0094A8  8C420000   LW V0, 0(V0)
9D0094B0  0B400152   J 0x9D000548
9D0094B4  0260A821   ADDU S5, S3, ZERO
2341:                
2342:                      OPCODE_BEGIN(F0)  /* BEQ $nnnn */
2343:                         BEQ();
9D0094B8  16A0001B   BNE S5, ZERO, 0x9D009528
9D0094BC  26120001   ADDIU S2, S0, 1
9D0094C0  26020001   ADDIU V0, S0, 1
9D0094DC  80720000   LB S2, 0(V1)
9D0094E0  304300FF   ANDI V1, V0, 255
9D0094E4  02431821   ADDU V1, S2, V1
9D0094E8  30630100   ANDI V1, V1, 256
9D0094EC  10600007   BEQ V1, ZERO, 0x9D00950C
9D0094F0  8F838058   LW V1, -32680(GP)
9D0094F4  2463FFFF   ADDIU V1, V1, -1
9D0094F8  AF838058   SW V1, -32680(GP)
9D0094FC  8E230054   LW V1, 84(S1)
9D009500  24630001   ADDIU V1, V1, 1
9D009504  AE230054   SW V1, 84(S1)
9D009508  8F838058   LW V1, -32680(GP)
9D00950C  2463FFFD   ADDIU V1, V1, -3
9D009510  AF838058   SW V1, -32680(GP)
9D009514  8E230054   LW V1, 84(S1)
9D009518  24630003   ADDIU V1, V1, 3
9D00951C  AE230054   SW V1, 84(S1)
9D009520  0B402550   J 0x9D009540
9D009524  02429021   ADDU S2, S2, V0
9D009528  8F828058   LW V0, -32680(GP)
9D00952C  2442FFFE   ADDIU V0, V0, -2
9D009530  AF828058   SW V0, -32680(GP)
9D009534  8E220054   LW V0, 84(S1)
9D009538  24420002   ADDIU V0, V0, 2
9D00953C  AE220054   SW V0, 84(S1)
2344:                         OPCODE_END
9D009540  8F828058   LW V0, -32680(GP)
9D009544  18400260   BLEZ V0, .L45
9D009548  26500001   ADDIU S0, S2, 1
9D009564  90420000   LBU V0, 0(V0)
9D009568  00021080   SLL V0, V0, 2
9D00956C  00561021   ADDU V0, V0, S6
9D009570  0B400152   J 0x9D000548
9D009574  8C420000   LW V0, 0(V0)
2345:                
2346:                      OPCODE_BEGIN(F1)  /* SBC ($nn),Y */
2347:                         SBC(5, INDIR_Y_BYTE_READ);
9D0095AC  8FA30010   LW V1, 16(SP)
9D0095B0  00832021   ADDU A0, A0, V1
9D0095B4  3084FFFF   ANDI A0, A0, -1
9D0095B8  308200FF   ANDI V0, A0, 255
9D0095BC  0043102B   SLTU V0, V0, V1
9D0095C0  10400007   BEQ V0, ZERO, 0x9D0095E0
9D0095C4  26120001   ADDIU S2, S0, 1
9D0095C8  8F828058   LW V0, -32680(GP)
9D0095CC  2442FFFF   ADDIU V0, V0, -1
9D0095D0  AF828058   SW V0, -32680(GP)
9D0095D4  8E220054   LW V0, 84(S1)
9D0095D8  24420001   ADDIU V0, V0, 1
9D0095DC  AE220054   SW V0, 84(S1)
9D0095E0  0F400000   JAL mem_readbyte
9D0095E4  3AF70001   XORI S7, S7, 1
9D0095E8  02821823   SUBU V1, S4, V0
9D0095EC  00771823   SUBU V1, V1, S7
9D0095F0  307300FF   ANDI S3, V1, 255
9D0095F4  00541026   XOR V0, V0, S4
9D0095F8  7C023004   INS V0, ZERO, 0, 7
9D0095FC  0274A026   XOR S4, S3, S4
9D009600  00541024   AND V0, V0, S4
9D009604  304200FF   ANDI V0, V0, 255
9D009608  AFA20018   SW V0, 24(SP)
9D00960C  38630100   XORI V1, V1, 256
9D009610  7C770200   EXT S7, V1, 8, 1
9D009614  8F828058   LW V0, -32680(GP)
9D009618  2442FFFB   ADDIU V0, V0, -5
9D00961C  AF828058   SW V0, -32680(GP)
9D009620  8E230054   LW V1, 84(S1)
9D009624  24630005   ADDIU V1, V1, 5
9D009630  0260A021   ADDU S4, S3, ZERO
9D009634  0B4027B2   J .L45
9D009638  0260A821   ADDU S5, S3, ZERO
9D009668  0260A021   ADDU S4, S3, ZERO
2348:                         OPCODE_END
9D009628  1C400004   BGTZ V0, 0x9D00963C
9D00962C  AE230054   SW V1, 84(S1)
9D00963C  26100002   ADDIU S0, S0, 2
9D009658  90420000   LBU V0, 0(V0)
9D00965C  00021080   SLL V0, V0, 2
9D009660  00561021   ADDU V0, V0, S6
9D009664  8C420000   LW V0, 0(V0)
9D00966C  0B400152   J 0x9D000548
9D009670  0260A821   ADDU S5, S3, ZERO
2349:                
2350:                      OPCODE_BEGIN(F3)  /* ISB ($nn),Y */
2351:                         ISB(8, INDIR_Y, mem_writebyte, addr);
9D009674  26120001   ADDIU S2, S0, 1
9D0096AC  8FA40010   LW A0, 16(SP)
9D0096B0  02649821   ADDU S3, S3, A0
9D0096B4  3273FFFF   ANDI S3, S3, -1
9D0096B8  0F400000   JAL mem_readbyte
9D0096BC  02602021   ADDU A0, S3, ZERO
9D0096C0  24420001   ADDIU V0, V0, 1
9D0096C4  305500FF   ANDI S5, V0, 255
9D0096C8  02602021   ADDU A0, S3, ZERO
9D0096CC  0F400036   JAL mem_writebyte
9D0096D0  02A02821   ADDU A1, S5, ZERO
9D0096D4  02951023   SUBU V0, S4, S5
9D0096D8  3AF70001   XORI S7, S7, 1
9D0096DC  00571023   SUBU V0, V0, S7
9D0096E0  305300FF   ANDI S3, V0, 255
9D0096E4  02B41826   XOR V1, S5, S4
9D0096E8  7C033004   INS V1, ZERO, 0, 7
9D0096EC  0274A026   XOR S4, S3, S4
9D0096F0  00741824   AND V1, V1, S4
9D0096F4  306300FF   ANDI V1, V1, 255
9D0096F8  AFA30018   SW V1, 24(SP)
9D0096FC  38420100   XORI V0, V0, 256
9D009700  7C570200   EXT S7, V0, 8, 1
9D009704  8F828058   LW V0, -32680(GP)
9D009708  2442FFF8   ADDIU V0, V0, -8
9D00970C  AF828058   SW V0, -32680(GP)
9D009710  8E230054   LW V1, 84(S1)
9D009714  24630008   ADDIU V1, V1, 8
9D009720  0260A021   ADDU S4, S3, ZERO
9D009724  0B4027B2   J .L45
9D009728  0260A821   ADDU S5, S3, ZERO
9D009758  0260A021   ADDU S4, S3, ZERO
2352:                         OPCODE_END
9D009718  1C400004   BGTZ V0, 0x9D00972C
9D00971C  AE230054   SW V1, 84(S1)
9D00972C  26100002   ADDIU S0, S0, 2
9D009748  90420000   LBU V0, 0(V0)
9D00974C  00021080   SLL V0, V0, 2
9D009750  00561021   ADDU V0, V0, S6
9D009754  8C420000   LW V0, 0(V0)
9D00975C  0B400152   J 0x9D000548
9D009760  0260A821   ADDU S5, S3, ZERO
2353:                
2354:                      OPCODE_BEGIN(F5)  /* SBC $nn,X */
2355:                         SBC(4, ZP_IND_X_BYTE);
9D009764  26120001   ADDIU S2, S0, 1
9D009780  90420000   LBU V0, 0(V0)
9D009784  03C21021   ADDU V0, FP, V0
9D009788  304200FF   ANDI V0, V0, 255
9D00978C  8F838054   LW V1, -32684(GP)
9D009790  00621021   ADDU V0, V1, V0
9D009794  90430000   LBU V1, 0(V0)
9D009798  02831023   SUBU V0, S4, V1
9D00979C  3AF70001   XORI S7, S7, 1
9D0097A0  00571023   SUBU V0, V0, S7
9D0097A4  305300FF   ANDI S3, V0, 255
9D0097A8  00741826   XOR V1, V1, S4
9D0097AC  7C033004   INS V1, ZERO, 0, 7
9D0097B0  0274A026   XOR S4, S3, S4
9D0097B4  00741824   AND V1, V1, S4
9D0097B8  306300FF   ANDI V1, V1, 255
9D0097BC  AFA30018   SW V1, 24(SP)
9D0097C0  38420100   XORI V0, V0, 256
9D0097C4  7C570200   EXT S7, V0, 8, 1
9D0097C8  8F828058   LW V0, -32680(GP)
9D0097CC  2442FFFC   ADDIU V0, V0, -4
9D0097D0  AF828058   SW V0, -32680(GP)
9D0097D4  8E230054   LW V1, 84(S1)
9D0097D8  24630004   ADDIU V1, V1, 4
9D0097E4  0260A021   ADDU S4, S3, ZERO
9D0097E8  0B4027B2   J .L45
9D0097EC  0260A821   ADDU S5, S3, ZERO
9D00981C  0260A021   ADDU S4, S3, ZERO
2356:                         OPCODE_END
9D0097DC  1C400004   BGTZ V0, 0x9D0097F0
9D0097E0  AE230054   SW V1, 84(S1)
9D0097F0  26100002   ADDIU S0, S0, 2
9D00980C  90420000   LBU V0, 0(V0)
9D009810  00021080   SLL V0, V0, 2
9D009814  00561021   ADDU V0, V0, S6
9D009818  8C420000   LW V0, 0(V0)
9D009820  0B400152   J 0x9D000548
9D009824  0260A821   ADDU S5, S3, ZERO
2357:                
2358:                      OPCODE_BEGIN(F6)  /* INC $nn,X */
2359:                         INC(6, ZP_IND_X, ZP_WRITEBYTE, baddr);
9D009828  26120001   ADDIU S2, S0, 1
9D009844  90420000   LBU V0, 0(V0)
9D009848  03C21021   ADDU V0, FP, V0
9D00984C  304200FF   ANDI V0, V0, 255
9D009850  8F838054   LW V1, -32684(GP)
9D009854  00621021   ADDU V0, V1, V0
9D009858  90530000   LBU S3, 0(V0)
9D00985C  26730001   ADDIU S3, S3, 1
9D009860  327300FF   ANDI S3, S3, 255
9D009864  A0530000   SB S3, 0(V0)
9D009868  8F828058   LW V0, -32680(GP)
9D00986C  2442FFFA   ADDIU V0, V0, -6
9D009870  AF828058   SW V0, -32680(GP)
9D009874  8E230054   LW V1, 84(S1)
9D009878  24630006   ADDIU V1, V1, 6
9D009884  0B4027B2   J .L45
9D009888  0260A821   ADDU S5, S3, ZERO
2360:                         OPCODE_END
9D00987C  1C400003   BGTZ V0, 0x9D00988C
9D009880  AE230054   SW V1, 84(S1)
9D00988C  26100002   ADDIU S0, S0, 2
9D0098A8  90420000   LBU V0, 0(V0)
9D0098AC  00021080   SLL V0, V0, 2
9D0098B0  00561021   ADDU V0, V0, S6
9D0098B4  8C420000   LW V0, 0(V0)
9D0098B8  0B400152   J 0x9D000548
9D0098BC  0260A821   ADDU S5, S3, ZERO
2361:                
2362:                      OPCODE_BEGIN(F7)  /* ISB $nn,X */
2363:                         ISB(6, ZP_IND_X, ZP_WRITEBYTE, baddr);
9D0098C0  26120001   ADDIU S2, S0, 1
9D0098DC  90420000   LBU V0, 0(V0)
9D0098E0  03C21021   ADDU V0, FP, V0
9D0098E4  304200FF   ANDI V0, V0, 255
9D0098E8  8F838054   LW V1, -32684(GP)
9D0098EC  00621821   ADDU V1, V1, V0
9D0098F0  90620000   LBU V0, 0(V1)
9D0098F4  24420001   ADDIU V0, V0, 1
9D0098F8  304200FF   ANDI V0, V0, 255
9D0098FC  A0620000   SB V0, 0(V1)
9D009900  02821823   SUBU V1, S4, V0
9D009904  3AF70001   XORI S7, S7, 1
9D009908  00771823   SUBU V1, V1, S7
9D00990C  307300FF   ANDI S3, V1, 255
9D009910  00541026   XOR V0, V0, S4
9D009914  7C023004   INS V0, ZERO, 0, 7
9D009918  0274A026   XOR S4, S3, S4
9D00991C  00541024   AND V0, V0, S4
9D009920  304200FF   ANDI V0, V0, 255
9D009924  AFA20018   SW V0, 24(SP)
9D009928  38630100   XORI V1, V1, 256
9D00992C  7C770200   EXT S7, V1, 8, 1
9D009930  8F828058   LW V0, -32680(GP)
9D009934  2442FFFA   ADDIU V0, V0, -6
9D009938  AF828058   SW V0, -32680(GP)
9D00993C  8E230054   LW V1, 84(S1)
9D009940  24630006   ADDIU V1, V1, 6
9D00994C  0260A021   ADDU S4, S3, ZERO
9D009950  0B4027B2   J .L45
9D009954  0260A821   ADDU S5, S3, ZERO
9D009984  0260A021   ADDU S4, S3, ZERO
2364:                         OPCODE_END
9D009944  1C400004   BGTZ V0, 0x9D009958
9D009948  AE230054   SW V1, 84(S1)
9D009958  26100002   ADDIU S0, S0, 2
9D009974  90420000   LBU V0, 0(V0)
9D009978  00021080   SLL V0, V0, 2
9D00997C  00561021   ADDU V0, V0, S6
9D009980  8C420000   LW V0, 0(V0)
9D009988  0B400152   J 0x9D000548
9D00998C  0260A821   ADDU S5, S3, ZERO
2365:                
2366:                      OPCODE_BEGIN(F8)  /* SED */
2367:                         SED();
9D009990  8F828058   LW V0, -32680(GP)
9D009994  2442FFFE   ADDIU V0, V0, -2
9D009998  AF828058   SW V0, -32680(GP)
9D00999C  8E230054   LW V1, 84(S1)
9D0099A0  24630002   ADDIU V1, V1, 2
9D0099B0  24050001   ADDIU A1, ZERO, 1
9D0099B4  0B4027B2   J .L45
9D0099B8  AFA50020   SW A1, 32(SP)
9D0099E8  24060001   ADDIU A2, ZERO, 1
2368:                         OPCODE_END
9D0099A4  1C400005   BGTZ V0, .LBB1892
9D0099A8  AE230054   SW V1, 84(S1)
9D0099AC  02009021   ADDU S2, S0, ZERO
9D0099D4  90420000   LBU V0, 0(V0)
9D0099D8  00021080   SLL V0, V0, 2
9D0099DC  00561021   ADDU V0, V0, S6
9D0099E0  8C420000   LW V0, 0(V0)
9D0099E4  26100001   ADDIU S0, S0, 1
9D0099EC  0B400152   J 0x9D000548
9D0099F0  AFA60020   SW A2, 32(SP)
2369:                
2370:                      OPCODE_BEGIN(F9)  /* SBC $nnnn,Y */
2371:                         SBC(4, ABS_IND_Y_BYTE_READ);
9D009A38  8FA70010   LW A3, 16(SP)
9D009A3C  00872021   ADDU A0, A0, A3
9D009A40  3084FFFF   ANDI A0, A0, -1
9D009A44  308200FF   ANDI V0, A0, 255
9D009A48  0047102B   SLTU V0, V0, A3
9D009A4C  10400007   BEQ V0, ZERO, 0x9D009A6C
9D009A50  26120002   ADDIU S2, S0, 2
9D009A54  8F828058   LW V0, -32680(GP)
9D009A58  2442FFFF   ADDIU V0, V0, -1
9D009A5C  AF828058   SW V0, -32680(GP)
9D009A60  8E220054   LW V0, 84(S1)
9D009A64  24420001   ADDIU V0, V0, 1
9D009A68  AE220054   SW V0, 84(S1)
9D009A6C  0F400000   JAL mem_readbyte
9D009A70  3AF70001   XORI S7, S7, 1
9D009A74  02821823   SUBU V1, S4, V0
9D009A78  00771823   SUBU V1, V1, S7
9D009A7C  307300FF   ANDI S3, V1, 255
9D009A80  00541026   XOR V0, V0, S4
9D009A84  7C023004   INS V0, ZERO, 0, 7
9D009A88  0274A026   XOR S4, S3, S4
9D009A8C  00541024   AND V0, V0, S4
9D009A90  304200FF   ANDI V0, V0, 255
9D009A94  AFA20018   SW V0, 24(SP)
9D009A98  38630100   XORI V1, V1, 256
9D009A9C  7C770200   EXT S7, V1, 8, 1
9D009AA0  8F828058   LW V0, -32680(GP)
9D009AA4  2442FFFC   ADDIU V0, V0, -4
9D009AA8  AF828058   SW V0, -32680(GP)
9D009AAC  8E230054   LW V1, 84(S1)
9D009AB0  24630004   ADDIU V1, V1, 4
9D009ABC  0260A021   ADDU S4, S3, ZERO
9D009AC0  0B4027B2   J .L45
9D009AC4  0260A821   ADDU S5, S3, ZERO
9D009AF4  0260A021   ADDU S4, S3, ZERO
2372:                         OPCODE_END
9D009AB4  1C400004   BGTZ V0, 0x9D009AC8
9D009AB8  AE230054   SW V1, 84(S1)
9D009AC8  26100003   ADDIU S0, S0, 3
9D009AE4  90420000   LBU V0, 0(V0)
9D009AE8  00021080   SLL V0, V0, 2
9D009AEC  00561021   ADDU V0, V0, S6
9D009AF0  8C420000   LW V0, 0(V0)
9D009AF8  0B400152   J 0x9D000548
9D009AFC  0260A821   ADDU S5, S3, ZERO
2373:                
2374:                      OPCODE_BEGIN(FB)  /* ISB $nnnn,Y */
2375:                         ISB(7, ABS_IND_Y, mem_writebyte, addr);
9D009B04  26120002   ADDIU S2, S0, 2
9D009B48  8FA80010   LW T0, 16(SP)
9D009B4C  02689821   ADDU S3, S3, T0
9D009B50  3273FFFF   ANDI S3, S3, -1
9D009B54  0F400000   JAL mem_readbyte
9D009B58  02602021   ADDU A0, S3, ZERO
9D009B5C  24420001   ADDIU V0, V0, 1
9D009B60  305500FF   ANDI S5, V0, 255
9D009B64  02602021   ADDU A0, S3, ZERO
9D009B68  0F400036   JAL mem_writebyte
9D009B6C  02A02821   ADDU A1, S5, ZERO
9D009B70  02951023   SUBU V0, S4, S5
9D009B74  3AF70001   XORI S7, S7, 1
9D009B78  00571023   SUBU V0, V0, S7
9D009B7C  305300FF   ANDI S3, V0, 255
9D009B80  02B41826   XOR V1, S5, S4
9D009B84  7C033004   INS V1, ZERO, 0, 7
9D009B88  0274A026   XOR S4, S3, S4
9D009B8C  00741824   AND V1, V1, S4
9D009B90  306300FF   ANDI V1, V1, 255
9D009B94  AFA30018   SW V1, 24(SP)
9D009B98  38420100   XORI V0, V0, 256
9D009B9C  7C570200   EXT S7, V0, 8, 1
9D009BA0  8F828058   LW V0, -32680(GP)
9D009BA4  2442FFF9   ADDIU V0, V0, -7
9D009BA8  AF828058   SW V0, -32680(GP)
9D009BAC  8E230054   LW V1, 84(S1)
9D009BB0  24630007   ADDIU V1, V1, 7
9D009BBC  0260A021   ADDU S4, S3, ZERO
9D009BC0  0B4027B2   J .L45
9D009BC4  0260A821   ADDU S5, S3, ZERO
9D009BF4  0260A021   ADDU S4, S3, ZERO
2376:                         OPCODE_END
9D009BB4  1C400004   BGTZ V0, 0x9D009BC8
9D009BB8  AE230054   SW V1, 84(S1)
9D009BC8  26100003   ADDIU S0, S0, 3
9D009BE4  90420000   LBU V0, 0(V0)
9D009BE8  00021080   SLL V0, V0, 2
9D009BEC  00561021   ADDU V0, V0, S6
9D009BF0  8C420000   LW V0, 0(V0)
9D009BF8  0B400152   J 0x9D000548
9D009BFC  0260A821   ADDU S5, S3, ZERO
2377:                
2378:                      OPCODE_BEGIN(FD)  /* SBC $nnnn,X */
2379:                         SBC(4, ABS_IND_X_BYTE_READ);
9D009C44  009E2021   ADDU A0, A0, FP
9D009C48  3084FFFF   ANDI A0, A0, -1
9D009C4C  308200FF   ANDI V0, A0, 255
9D009C50  005E102B   SLTU V0, V0, FP
9D009C54  10400007   BEQ V0, ZERO, 0x9D009C74
9D009C58  26120002   ADDIU S2, S0, 2
9D009C5C  8F828058   LW V0, -32680(GP)
9D009C60  2442FFFF   ADDIU V0, V0, -1
9D009C64  AF828058   SW V0, -32680(GP)
9D009C68  8E220054   LW V0, 84(S1)
9D009C6C  24420001   ADDIU V0, V0, 1
9D009C70  AE220054   SW V0, 84(S1)
9D009C74  0F400000   JAL mem_readbyte
9D009C78  3AF70001   XORI S7, S7, 1
9D009C7C  02821823   SUBU V1, S4, V0
9D009C80  00771823   SUBU V1, V1, S7
9D009C84  307300FF   ANDI S3, V1, 255
9D009C88  00541026   XOR V0, V0, S4
9D009C8C  7C023004   INS V0, ZERO, 0, 7
9D009C90  0274A026   XOR S4, S3, S4
9D009C94  00541024   AND V0, V0, S4
9D009C98  304200FF   ANDI V0, V0, 255
9D009C9C  AFA20018   SW V0, 24(SP)
9D009CA0  38630100   XORI V1, V1, 256
9D009CA4  7C770200   EXT S7, V1, 8, 1
9D009CA8  8F828058   LW V0, -32680(GP)
9D009CAC  2442FFFC   ADDIU V0, V0, -4
9D009CB0  AF828058   SW V0, -32680(GP)
9D009CB4  8E230054   LW V1, 84(S1)
9D009CB8  24630004   ADDIU V1, V1, 4
9D009CC4  0260A021   ADDU S4, S3, ZERO
9D009CC8  0B4027B2   J .L45
9D009CCC  0260A821   ADDU S5, S3, ZERO
9D009CFC  0260A021   ADDU S4, S3, ZERO
2380:                         OPCODE_END
9D009CBC  1C400004   BGTZ V0, 0x9D009CD0
9D009CC0  AE230054   SW V1, 84(S1)
9D009CD0  26100003   ADDIU S0, S0, 3
9D009CEC  90420000   LBU V0, 0(V0)
9D009CF0  00021080   SLL V0, V0, 2
9D009CF4  00561021   ADDU V0, V0, S6
9D009CF8  8C420000   LW V0, 0(V0)
9D009D00  0B400152   J 0x9D000548
9D009D04  0260A821   ADDU S5, S3, ZERO
2381:                
2382:                      OPCODE_BEGIN(FE)  /* INC $nnnn,X */
2383:                         INC(7, ABS_IND_X, mem_writebyte, addr);
9D009D0C  26120002   ADDIU S2, S0, 2
9D009D50  02BEA821   ADDU S5, S5, FP
9D009D54  32B5FFFF   ANDI S5, S5, -1
9D009D58  0F400000   JAL mem_readbyte
9D009D5C  02A02021   ADDU A0, S5, ZERO
9D009D60  24420001   ADDIU V0, V0, 1
9D009D64  305300FF   ANDI S3, V0, 255
9D009D68  02A02021   ADDU A0, S5, ZERO
9D009D6C  0F400036   JAL mem_writebyte
9D009D70  02602821   ADDU A1, S3, ZERO
9D009D74  8F828058   LW V0, -32680(GP)
9D009D78  2442FFF9   ADDIU V0, V0, -7
9D009D7C  AF828058   SW V0, -32680(GP)
9D009D80  8E230054   LW V1, 84(S1)
9D009D84  24630007   ADDIU V1, V1, 7
9D009D90  0B4027B2   J .L45
9D009D94  0260A821   ADDU S5, S3, ZERO
2384:                         OPCODE_END
9D009D88  1C400003   BGTZ V0, 0x9D009D98
9D009D8C  AE230054   SW V1, 84(S1)
9D009D98  26100003   ADDIU S0, S0, 3
9D009DB4  90420000   LBU V0, 0(V0)
9D009DB8  00021080   SLL V0, V0, 2
9D009DBC  00561021   ADDU V0, V0, S6
9D009DC0  8C420000   LW V0, 0(V0)
9D009DC4  0B400152   J 0x9D000548
9D009DC8  0260A821   ADDU S5, S3, ZERO
2385:                
2386:                      OPCODE_BEGIN(FF)  /* ISB $nnnn,X */
2387:                         ISB(7, ABS_IND_X, mem_writebyte, addr);
9D009DD0  26120002   ADDIU S2, S0, 2
9D009E14  027E9821   ADDU S3, S3, FP
9D009E18  3273FFFF   ANDI S3, S3, -1
9D009E1C  0F400000   JAL mem_readbyte
9D009E20  02602021   ADDU A0, S3, ZERO
9D009E24  24420001   ADDIU V0, V0, 1
9D009E28  305500FF   ANDI S5, V0, 255
9D009E2C  02602021   ADDU A0, S3, ZERO
9D009E30  0F400036   JAL mem_writebyte
9D009E34  02A02821   ADDU A1, S5, ZERO
9D009E38  02951023   SUBU V0, S4, S5
9D009E3C  3AF70001   XORI S7, S7, 1
9D009E40  00571023   SUBU V0, V0, S7
9D009E44  305300FF   ANDI S3, V0, 255
9D009E48  02B41826   XOR V1, S5, S4
9D009E4C  7C033004   INS V1, ZERO, 0, 7
9D009E50  0274A026   XOR S4, S3, S4
9D009E54  00741824   AND V1, V1, S4
9D009E58  306300FF   ANDI V1, V1, 255
9D009E5C  AFA30018   SW V1, 24(SP)
9D009E60  38420100   XORI V0, V0, 256
9D009E64  7C570200   EXT S7, V0, 8, 1
9D009E68  8F828058   LW V0, -32680(GP)
9D009E6C  2442FFF9   ADDIU V0, V0, -7
9D009E70  AF828058   SW V0, -32680(GP)
9D009E74  8E230054   LW V1, 84(S1)
9D009E78  24630007   ADDIU V1, V1, 7
9D009E84  0260A021   ADDU S4, S3, ZERO
9D009E88  0B4027B2   J .L45
9D009E8C  0260A821   ADDU S5, S3, ZERO
9D009EBC  0260A021   ADDU S4, S3, ZERO
2388:                         OPCODE_END
9D000540  3C169D03   LUI S6, -25341
9D000544  26D600C4   ADDIU S6, S6, 196
9D000548  00400008   JR V0
9D00054C  00000000   NOP
9D009E7C  1C400004   BGTZ V0, 0x9D009E90
9D009E80  AE230054   SW V1, 84(S1)
9D009E90  26100003   ADDIU S0, S0, 3
9D009EAC  90420000   LBU V0, 0(V0)
9D009EB0  00021080   SLL V0, V0, 2
9D009EB4  00561021   ADDU V0, V0, S6
9D009EB8  8C420000   LW V0, 0(V0)
9D009EC0  0B400152   J 0x9D000548
9D009EC4  0260A821   ADDU S5, S3, ZERO
2389:                
2390:                #ifdef NES6502_JUMPTABLE
2391:                end_execute:
2392:                
2393:                #else /* !NES6502_JUMPTABLE */
2394:                      }
2395:                   }
2396:                #endif /* !NES6502_JUMPTABLE */
2397:                
2398:                   /* store local copy of regs */
2399:                   STORE_LOCAL_REGS();
9D009EC8  3C02A001   LUI V0, -24575
9D009ECC  24428FD0   ADDIU V0, V0, -28720
9D009ED0  AC520048   SW S2, 72(V0)
9D009ED4  A054004C   SB S4, 76(V0)
9D009ED8  A05E004E   SB FP, 78(V0)
9D009EDC  8FA30010   LW V1, 16(SP)
9D009EE0  A043004F   SB V1, 79(V0)
9D009EE4  7C133004   INS S3, ZERO, 0, 7
9D009EE8  7C139C20   SEB S3, S3
9D009EEC  24030040   ADDIU V1, ZERO, 64
9D009EF0  8FA40018   LW A0, 24(SP)
9D009EF4  0004180A   MOVZ V1, ZERO, A0
9D009EF8  24060010   ADDIU A2, ZERO, 16
9D009EFC  8FA50028   LW A1, 40(SP)
9D009F00  0005300A   MOVZ A2, ZERO, A1
9D009F04  24050008   ADDIU A1, ZERO, 8
9D009F08  8FA70020   LW A3, 32(SP)
9D009F0C  0007280A   MOVZ A1, ZERO, A3
9D009F10  24040004   ADDIU A0, ZERO, 4
9D009F14  8FA8001C   LW T0, 28(SP)
9D009F18  0008200A   MOVZ A0, ZERO, T0
9D009F1C  24020002   ADDIU V0, ZERO, 2
9D009F20  0015100B   MOVN V0, ZERO, S5
9D009F24  0040A821   ADDU S5, V0, ZERO
9D009F28  3C02A001   LUI V0, -24575
9D009F2C  24428FD0   ADDIU V0, V0, -28720
9D009F30  36F70020   ORI S7, S7, 32
9D009F34  0277B825   OR S7, S3, S7
9D009F38  00771825   OR V1, V1, S7
9D009F3C  00C31825   OR V1, A2, V1
9D009F40  00A31825   OR V1, A1, V1
9D009F44  00831825   OR V1, A0, V1
9D009F48  02A3A825   OR S5, S5, V1
9D009F4C  A055004D   SB S5, 77(V0)
9D009F50  8FA30014   LW V1, 20(SP)
9D009F54  A0430050   SB V1, 80(V0)
2400:                
2401:                   /* Return our actual amount of executed cycles */
2402:                   return (cpu.total_cycles - old_cycles);
9D009F58  8C420054   LW V0, 84(V0)
2403:                }
9D009F5C  8FA40024   LW A0, 36(SP)
9D009F60  00441023   SUBU V0, V0, A0
9D009F64  8FBF0054   LW RA, 84(SP)
9D009F68  8FBE0050   LW FP, 80(SP)
9D009F6C  8FB7004C   LW S7, 76(SP)
9D009F70  8FB60048   LW S6, 72(SP)
9D009F74  8FB50044   LW S5, 68(SP)
9D009F78  8FB40040   LW S4, 64(SP)
9D009F7C  8FB3003C   LW S3, 60(SP)
9D009F80  8FB20038   LW S2, 56(SP)
9D009F84  8FB10034   LW S1, 52(SP)
9D009F88  8FB00030   LW S0, 48(SP)
9D009F8C  03E00008   JR RA
9D009F90  27BD0058   ADDIU SP, SP, 88
2404:                
2405:                /* Issue a CPU Reset */
2406:                void nes6502_reset(void)
2407:                {
2408:                   cpu.p_reg = Z_FLAG | R_FLAG | I_FLAG;     /* Reserved bit always 1 */
9D009F94  3C02A001   LUI V0, -24575
9D009F98  24428FD0   ADDIU V0, V0, -28720
9D009F9C  24030026   ADDIU V1, ZERO, 38
9D009FA0  A043004D   SB V1, 77(V0)
2409:                   cpu.int_pending = 0;                      /* No pending interrupts */
9D009FA4  A0400052   SB ZERO, 82(V0)
2410:                   cpu.int_latency = 0;                      /* No latent interrupts */
9D009FA8  A0400053   SB ZERO, 83(V0)
2411:                   cpu.pc_reg = bank_readword(RESET_VECTOR); /* Fetch reset vector */
2412:                   cpu.burn_cycles = RESET_CYCLES;
9D009FC4  24030006   ADDIU V1, ZERO, 6
9D009FC8  AC430058   SW V1, 88(V0)
2413:                   cpu.jammed = false;
9D009FCC  03E00008   JR RA
9D009FD0  A0400051   SB ZERO, 81(V0)
2414:                }
2415:                
2416:                /* following macro is used for below 2 functions */
2417:                #define  DECLARE_LOCAL_REGS \
2418:                   uint32 PC; \
2419:                   uint8 A, X, Y, S; \
2420:                   uint8 n_flag, v_flag, b_flag; \
2421:                   uint8 d_flag, i_flag, z_flag, c_flag;
2422:                
2423:                /* Non-maskable interrupt */
2424:                void nes6502_nmi(void)
2425:                {
2426:                   DECLARE_LOCAL_REGS
2427:                
2428:                   if (false == cpu.jammed)
9D009FD4  3C02A001   LUI V0, -24575
9D009FD8  90429021   LBU V0, -28639(V0)
9D009FDC  14400040   BNE V0, ZERO, 0x9D00A0E0
9D009FE0  3C03A001   LUI V1, -24575
2429:                   {
2430:                      GET_GLOBAL_REGS();
9D009FE4  24638FD0   ADDIU V1, V1, -28720
9D009FE8  8C670048   LW A3, 72(V1)
9D009FEC  906D004C   LBU T5, 76(V1)
9D009FF0  906C004E   LBU T4, 78(V1)
9D009FF4  906B004F   LBU T3, 79(V1)
9D009FF8  9062004D   LBU V0, 77(V1)
9D009FFC  30460040   ANDI A2, V0, 64
9D00A000  30C600FF   ANDI A2, A2, 255
9D00A004  30450008   ANDI A1, V0, 8
9D00A008  30A500FF   ANDI A1, A1, 255
9D00A00C  38490002   XORI T1, V0, 2
9D00A010  7D290040   EXT T1, T1, 1, 1
9D00A014  90630050   LBU V1, 80(V1)
2431:                      NMI_PROC();
9D00A018  8F848050   LW A0, -32688(GP)
9D00A01C  00834021   ADDU T0, A0, V1
9D00A020  00075202   SRL T2, A3, 8
9D00A024  A10A0000   SB T2, 0(T0)
9D00A028  2468FFFF   ADDIU T0, V1, -1
9D00A02C  310800FF   ANDI T0, T0, 255
9D00A030  00884021   ADDU T0, A0, T0
9D00A034  A1070000   SB A3, 0(T0)
9D00A038  246AFFFD   ADDIU T2, V1, -3
9D00A03C  2463FFFE   ADDIU V1, V1, -2
9D00A040  306300FF   ANDI V1, V1, 255
9D00A044  00832021   ADDU A0, A0, V1
9D00A048  30470080   ANDI A3, V0, 128
9D00A04C  7C073C20   SEB A3, A3
9D00A050  304E0004   ANDI T6, V0, 4
9D00A054  24030002   ADDIU V1, ZERO, 2
9D00A058  0009180B   MOVN V1, ZERO, T1
9D00A05C  30480001   ANDI T0, V0, 1
9D00A060  35020020   ORI V0, T0, 32
9D00A064  00E21025   OR V0, A3, V0
9D00A068  00C21025   OR V0, A2, V0
9D00A06C  00A21025   OR V0, A1, V0
9D00A070  01C21025   OR V0, T6, V0
9D00A074  00621025   OR V0, V1, V0
9D00A078  A0820000   SB V0, 0(A0)
2432:                      cpu.burn_cycles += INT_CYCLES;
9D00A098  8C440058   LW A0, 88(V0)
9D00A09C  24840007   ADDIU A0, A0, 7
9D00A0A0  AC440058   SW A0, 88(V0)
2433:                      STORE_LOCAL_REGS();
9D00A0A4  AC430048   SW V1, 72(V0)
9D00A0A8  A04D004C   SB T5, 76(V0)
9D00A0AC  A04C004E   SB T4, 78(V0)
9D00A0B0  A04B004F   SB T3, 79(V0)
9D00A0B4  24020002   ADDIU V0, ZERO, 2
9D00A0B8  0009100B   MOVN V0, ZERO, T1
9D00A0BC  3C03A001   LUI V1, -24575
9D00A0C0  24638FD0   ADDIU V1, V1, -28720
9D00A0C4  35080024   ORI T0, T0, 36
9D00A0C8  00E83825   OR A3, A3, T0
9D00A0CC  00C73025   OR A2, A2, A3
9D00A0D0  00A62825   OR A1, A1, A2
9D00A0D4  00452825   OR A1, V0, A1
9D00A0D8  A065004D   SB A1, 77(V1)
9D00A0DC  A06A0050   SB T2, 80(V1)
9D00A0E0  03E00008   JR RA
9D00A0E4  00000000   NOP
2434:                   }
2435:                }
2436:                
2437:                /* Interrupt request */
2438:                void nes6502_irq(void)
2439:                {
2440:                   DECLARE_LOCAL_REGS
2441:                
2442:                   if (false == cpu.jammed)
9D00A0E8  3C02A001   LUI V0, -24575
9D00A0EC  90429021   LBU V0, -28639(V0)
9D00A0F0  14400056   BNE V0, ZERO, 0x9D00A24C
9D00A0F4  3C03A001   LUI V1, -24575
2443:                   {
2444:                      GET_GLOBAL_REGS();
9D00A0F8  24638FD0   ADDIU V1, V1, -28720
9D00A0FC  8C660048   LW A2, 72(V1)
9D00A100  906E004C   LBU T6, 76(V1)
9D00A104  906D004E   LBU T5, 78(V1)
9D00A108  906C004F   LBU T4, 79(V1)
9D00A10C  9062004D   LBU V0, 77(V1)
9D00A110  304B0080   ANDI T3, V0, 128
9D00A114  30480040   ANDI T0, V0, 64
9D00A118  310800FF   ANDI T0, T0, 255
9D00A11C  30470008   ANDI A3, V0, 8
9D00A120  30E700FF   ANDI A3, A3, 255
9D00A124  30450004   ANDI A1, V0, 4
9D00A128  30A500FF   ANDI A1, A1, 255
9D00A12C  384A0002   XORI T2, V0, 2
9D00A130  7D4A0040   EXT T2, T2, 1, 1
9D00A134  30490001   ANDI T1, V0, 1
9D00A1D4  30420010   ANDI V0, V0, 16
9D00A1D8  304200FF   ANDI V0, V0, 255
2445:                      if (0 == i_flag)
9D00A138  14A00026   BNE A1, ZERO, 0x9D00A1D4
9D00A13C  90640050   LBU A0, 80(V1)
2446:                      {
2447:                         IRQ_PROC();
9D00A140  8F828050   LW V0, -32688(GP)
9D00A144  00441821   ADDU V1, V0, A0
9D00A148  00062A02   SRL A1, A2, 8
9D00A14C  A0650000   SB A1, 0(V1)
9D00A150  2483FFFE   ADDIU V1, A0, -2
9D00A154  306300FF   ANDI V1, V1, 255
9D00A158  2485FFFF   ADDIU A1, A0, -1
9D00A15C  30A500FF   ANDI A1, A1, 255
9D00A160  00452821   ADDU A1, V0, A1
9D00A164  A0A60000   SB A2, 0(A1)
9D00A168  2484FFFD   ADDIU A0, A0, -3
9D00A16C  308400FF   ANDI A0, A0, 255
9D00A170  00431021   ADDU V0, V0, V1
9D00A174  2405FF80   ADDIU A1, ZERO, -128
9D00A178  01651824   AND V1, T3, A1
9D00A17C  7C031C20   SEB V1, V1
9D00A180  24050002   ADDIU A1, ZERO, 2
9D00A184  000A280B   MOVN A1, ZERO, T2
9D00A188  35260020   ORI A2, T1, 32
9D00A18C  00661825   OR V1, V1, A2
9D00A190  01031825   OR V1, T0, V1
9D00A194  00E31825   OR V1, A3, V1
9D00A198  00A31825   OR V1, A1, V1
9D00A19C  A0430000   SB V1, 0(V0)
9D00A1C8  24050001   ADDIU A1, ZERO, 1
9D00A1CC  0B40287A   J 0x9D00A1E8
9D00A1D0  00001021   ADDU V0, ZERO, ZERO
2448:                         cpu.burn_cycles += INT_CYCLES;
9D00A1BC  8C430058   LW V1, 88(V0)
9D00A1C0  24630007   ADDIU V1, V1, 7
9D00A1C4  AC430058   SW V1, 88(V0)
2449:                      }
2450:                      else
2451:                      {
2452:                         cpu.int_pending = 1;
9D00A1DC  240F0001   ADDIU T7, ZERO, 1
9D00A1E0  3C03A001   LUI V1, -24575
9D00A1E4  A06F9022   SB T7, -28638(V1)
2453:                      }
2454:                      STORE_LOCAL_REGS();
9D00A1E8  3C03A001   LUI V1, -24575
9D00A1EC  24638FD0   ADDIU V1, V1, -28720
9D00A1F0  AC660048   SW A2, 72(V1)
9D00A1F4  A06E004C   SB T6, 76(V1)
9D00A1F8  A06D004E   SB T5, 78(V1)
9D00A1FC  A06C004F   SB T4, 79(V1)
9D00A200  7C0B3004   INS T3, ZERO, 0, 7
9D00A204  7C0B5C20   SEB T3, T3
9D00A208  24030004   ADDIU V1, ZERO, 4
9D00A20C  0005180A   MOVZ V1, ZERO, A1
9D00A210  00602821   ADDU A1, V1, ZERO
9D00A214  24030002   ADDIU V1, ZERO, 2
9D00A218  000A180B   MOVN V1, ZERO, T2
9D00A21C  00605021   ADDU T2, V1, ZERO
9D00A220  3C03A001   LUI V1, -24575
9D00A224  24638FD0   ADDIU V1, V1, -28720
9D00A228  35290020   ORI T1, T1, 32
9D00A22C  01694825   OR T1, T3, T1
9D00A230  01094025   OR T0, T0, T1
9D00A234  00484025   OR T0, V0, T0
9D00A238  00E83825   OR A3, A3, T0
9D00A23C  00A72825   OR A1, A1, A3
9D00A240  01455025   OR T2, T2, A1
9D00A244  A06A004D   SB T2, 77(V1)
9D00A248  A0640050   SB A0, 80(V1)
9D00A24C  03E00008   JR RA
9D00A250  00000000   NOP
2455:                   }
2456:                }
2457:                
2458:                /* Set dead cycle period */
2459:                void nes6502_burn(int cycles)
2460:                {
2461:                   cpu.burn_cycles += cycles;
9D00A254  3C02A001   LUI V0, -24575
9D00A258  24428FD0   ADDIU V0, V0, -28720
9D00A25C  8C430058   LW V1, 88(V0)
9D00A260  00642021   ADDU A0, V1, A0
9D00A264  03E00008   JR RA
9D00A268  AC440058   SW A0, 88(V0)
2462:                }
2463:                
2464:                /* Release our timeslice */
2465:                void nes6502_release(void)
2466:                {
2467:                   remaining_cycles = 0;
9D00A26C  03E00008   JR RA
2468:                }
2469:                
2470:                /*
2471:                ** $Log: nes6502.c,v $
2472:                ** Revision 1.2  2001/04/27 14:37:11  neil
2473:                ** wheeee
2474:                **
2475:                ** Revision 1.1  2001/04/27 12:54:39  neil
2476:                ** blah
2477:                **
2478:                ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
2479:                ** initial
2480:                **
2481:                ** Revision 1.34  2000/11/27 19:33:07  matt
2482:                ** concise interrupts
2483:                **
2484:                ** Revision 1.33  2000/11/26 15:39:54  matt
2485:                ** timing fixes
2486:                **
2487:                ** Revision 1.32  2000/11/20 13:22:51  matt
2488:                ** added note about word fetches across page boundaries
2489:                **
2490:                ** Revision 1.31  2000/11/13 00:57:39  matt
2491:                ** trying to add 1-instruction interrupt latency... and failing.
2492:                **
2493:                ** Revision 1.30  2000/10/10 13:58:14  matt
2494:                ** stroustrup squeezing his way in the door
2495:                **
2496:                ** Revision 1.29  2000/10/10 13:05:05  matt
2497:                ** Mr. Clean makes a guest appearance
2498:                **
2499:                ** Revision 1.28  2000/10/08 17:55:41  matt
2500:                ** check burn cycles before ints
2501:                **
2502:                ** Revision 1.27  2000/09/15 03:42:32  matt
2503:                ** nes6502_release to release current timeslice
2504:                **
2505:                ** Revision 1.26  2000/09/15 03:16:17  matt
2506:                ** optimized C flag handling, and ADC/SBC/ROL/ROR macros
2507:                **
2508:                ** Revision 1.25  2000/09/14 02:12:03  matt
2509:                ** disassembling now works with goto table, and removed memcpy from context get/set
2510:                **
2511:                ** Revision 1.24  2000/09/11 03:55:57  matt
2512:                ** cosmetics
2513:                **
2514:                ** Revision 1.23  2000/09/11 01:45:45  matt
2515:                ** flag optimizations.  this thing is fast!
2516:                **
2517:                ** Revision 1.22  2000/09/08 13:29:25  matt
2518:                ** added switch()-less execution for gcc
2519:                **
2520:                ** Revision 1.21  2000/09/08 11:54:48  matt
2521:                ** optimize
2522:                **
2523:                ** Revision 1.20  2000/09/07 21:58:18  matt
2524:                ** api change for nes6502_burn, optimized core
2525:                **
2526:                ** Revision 1.19  2000/09/07 13:39:01  matt
2527:                ** resolved a few conflicts
2528:                **
2529:                ** Revision 1.18  2000/09/07 01:34:55  matt
2530:                ** nes6502_init deprecated, moved flag regs to separate vars
2531:                **
2532:                ** Revision 1.17  2000/08/31 13:26:35  matt
2533:                ** added DISASM flag, to sync with asm version
2534:                **
2535:                ** Revision 1.16  2000/08/29 05:38:00  matt
2536:                ** removed faulty failure note
2537:                **
2538:                ** Revision 1.15  2000/08/28 12:53:44  matt
2539:                ** fixes for disassembler
2540:                **
2541:                ** Revision 1.14  2000/08/28 04:32:28  matt
2542:                ** naming convention changes
2543:                **
2544:                ** Revision 1.13  2000/08/28 01:46:15  matt
2545:                ** moved some of them defines around, cleaned up jamming code
2546:                **
2547:                ** Revision 1.12  2000/08/16 04:56:37  matt
2548:                ** accurate CPU jamming, added dead page emulation
2549:                **
2550:                ** Revision 1.11  2000/07/30 04:32:00  matt
2551:                ** now emulates the NES frame IRQ
2552:                **
2553:                ** Revision 1.10  2000/07/17 01:52:28  matt
2554:                ** made sure last line of all source files is a newline
2555:                **
2556:                ** Revision 1.9  2000/07/11 04:27:18  matt
2557:                ** new disassembler calling convention
2558:                **
2559:                ** Revision 1.8  2000/07/10 05:26:38  matt
2560:                ** cosmetic
2561:                **
2562:                ** Revision 1.7  2000/07/06 17:10:51  matt
2563:                ** minor (er, spelling) error fixed
2564:                **
2565:                ** Revision 1.6  2000/07/04 04:50:07  matt
2566:                ** minor change to includes
2567:                **
2568:                ** Revision 1.5  2000/07/03 02:18:16  matt
2569:                ** added a few notes about potential failure cases
2570:                **
2571:                ** Revision 1.4  2000/06/09 15:12:25  matt
2572:                ** initial revision
2573:                **
2574:                */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/config.c  ----------------------------------
1:                   /* Nofrendo Configuration Braindead Sample Implementation
2:                   **
3:                   ** $Id: config.c,v 1.2 2001/04/27 14:37:11 neil Exp $
4:                   */
5:                   
6:                   #include <ctype.h>
7:                   #include <string.h>
8:                   #include <stdlib.h>
9:                   #include <stdio.h>
10:                  
11:                  #include <noftypes.h>
12:                  #include <log.h>
13:                  #include <osd.h>
14:                  #include <nofconfig.h>
15:                  #include <version.h>
16:                  
17:                  typedef struct myvar_s
18:                  {
19:                     struct myvar_s *less, *greater;
20:                     char *group, *key, *value;
21:                  } myvar_t;
22:                  
23:                  static myvar_t *myVars = NULL;
24:                  static bool mySaveNeeded = false;
25:                  
26:                  
27:                  static void my_destroy(myvar_t **var)
28:                  {
9D02A79C  27BDFFE8   ADDIU SP, SP, -24
9D02A7A0  AFBF0014   SW RA, 20(SP)
9D02A7A4  AFB00010   SW S0, 16(SP)
9D02A7A8  00808021   ADDU S0, A0, ZERO
29:                     ASSERT(*var);
30:                  
31:                     if ((*var)->group) 
9D02A7AC  8C840000   LW A0, 0(A0)
9D02A7B0  8C820008   LW V0, 8(A0)
9D02A7B4  50400004   BEQL V0, ZERO, 0x9D02A7C8
9D02A7B8  8E040000   LW A0, 0(S0)
32:                        free((*var)->group);
9D02A7BC  0F40DDCA   JAL _my_free
9D02A7C0  24840008   ADDIU A0, A0, 8
33:                     if ((*var)->key)
9D02A7C4  8E040000   LW A0, 0(S0)
9D02A7C8  8C82000C   LW V0, 12(A0)
9D02A7CC  50400004   BEQL V0, ZERO, 0x9D02A7E0
9D02A7D0  8E040000   LW A0, 0(S0)
34:                        free((*var)->key);
9D02A7D4  0F40DDCA   JAL _my_free
9D02A7D8  2484000C   ADDIU A0, A0, 12
35:                     if ((*var)->value)
9D02A7DC  8E040000   LW A0, 0(S0)
9D02A7E0  8C820010   LW V0, 16(A0)
9D02A7E4  10400003   BEQ V0, ZERO, .LVL4
9D02A7E8  00000000   NOP
36:                        free((*var)->value);
9D02A7EC  0F40DDCA   JAL _my_free
9D02A7F0  24840010   ADDIU A0, A0, 16
37:                     free(*var);
9D02A7F4  0F40DDCA   JAL _my_free
9D02A7F8  02002021   ADDU A0, S0, ZERO
38:                  }
9D02A7FC  8FBF0014   LW RA, 20(SP)
9D02A800  8FB00010   LW S0, 16(SP)
9D02A804  03E00008   JR RA
9D02A808  27BD0018   ADDIU SP, SP, 24
39:                  
40:                  static myvar_t *my_create(const char *group, const char *key, const char *value)
41:                  {
9D02A80C  27BDFFD0   ADDIU SP, SP, -48
9D02A810  AFBF002C   SW RA, 44(SP)
9D02A814  AFB30028   SW S3, 40(SP)
9D02A818  AFB20024   SW S2, 36(SP)
9D02A81C  AFB10020   SW S1, 32(SP)
9D02A820  AFB0001C   SW S0, 28(SP)
9D02A824  00808821   ADDU S1, A0, ZERO
9D02A828  00A09021   ADDU S2, A1, ZERO
9D02A82C  00C09821   ADDU S3, A2, ZERO
42:                     myvar_t *var;
43:                  
44:                     var = malloc(sizeof(*var));
9D02A830  0F40DDB7   JAL _my_malloc
9D02A834  24040014   ADDIU A0, ZERO, 20
45:                     if (NULL == var)
9D02A838  1040002D   BEQ V0, ZERO, 0x9D02A8F0
9D02A83C  AFA20010   SW V0, 16(SP)
46:                     {
47:                        return 0;
9D02A8F0  00001021   ADDU V0, ZERO, ZERO
48:                     }
49:                  
50:                     var->less = var->greater = NULL;
9D02A840  AC400004   SW ZERO, 4(V0)
9D02A844  AC400000   SW ZERO, 0(V0)
51:                     var->group = var->key = var->value = NULL;
9D02A848  8FB00010   LW S0, 16(SP)
9D02A84C  AE000010   SW ZERO, 16(S0)
9D02A850  AE00000C   SW ZERO, 12(S0)
9D02A854  AE000008   SW ZERO, 8(S0)
52:                  
53:                     if ((var->group = malloc(strlen(group) + 1))
9D02A858  0F40DBFE   JAL strlen
9D02A85C  02202021   ADDU A0, S1, ZERO
9D02A860  0F40DDB7   JAL _my_malloc
9D02A864  24440001   ADDIU A0, V0, 1
9D02A868  1040001D   BEQ V0, ZERO, 0x9D02A8E0
9D02A86C  AE020008   SW V0, 8(S0)
54:                         && (var->key = malloc(strlen(key) + 1))
9D02A870  8FB00010   LW S0, 16(SP)
9D02A874  0F40DBFE   JAL strlen
9D02A878  02402021   ADDU A0, S2, ZERO
9D02A87C  0F40DDB7   JAL _my_malloc
9D02A880  24440001   ADDIU A0, V0, 1
9D02A884  10400016   BEQ V0, ZERO, 0x9D02A8E0
9D02A888  AE02000C   SW V0, 12(S0)
55:                         && (var->value = malloc(strlen(value) + 1)))
9D02A88C  8FB00010   LW S0, 16(SP)
9D02A890  0F40DBFE   JAL strlen
9D02A894  02602021   ADDU A0, S3, ZERO
9D02A898  0F40DDB7   JAL _my_malloc
9D02A89C  24440001   ADDIU A0, V0, 1
9D02A8A0  1040000F   BEQ V0, ZERO, 0x9D02A8E0
9D02A8A4  AE020010   SW V0, 16(S0)
56:                     {
57:                        strcpy(var->group, group);
9D02A8A8  8FA20010   LW V0, 16(SP)
9D02A8AC  8C440008   LW A0, 8(V0)
9D02A8B0  0F40D947   JAL .LFE23, strcpy
9D02A8B4  02202821   ADDU A1, S1, ZERO
58:                        strcpy(var->key, key);
9D02A8B8  8FA20010   LW V0, 16(SP)
9D02A8BC  8C44000C   LW A0, 12(V0)
9D02A8C0  0F40D947   JAL .LFE23, strcpy
9D02A8C4  02402821   ADDU A1, S2, ZERO
59:                        strcpy(var->value, value);
9D02A8C8  8FA20010   LW V0, 16(SP)
9D02A8CC  8C440010   LW A0, 16(V0)
9D02A8D0  0F40D947   JAL .LFE23, strcpy
9D02A8D4  02602821   ADDU A1, S3, ZERO
60:                        return var;
9D02A8D8  0B40AA3D   J 0x9D02A8F4
9D02A8DC  8FA20010   LW V0, 16(SP)
61:                     }
62:                  
63:                     my_destroy(&var);
9D02A8E0  0F40A9E7   JAL .LFB8, my_destroy, .Ltext0
9D02A8E4  27A40010   ADDIU A0, SP, 16
64:                     return NULL;
9D02A8E8  0B40AA3D   J 0x9D02A8F4
9D02A8EC  00001021   ADDU V0, ZERO, ZERO
65:                  }
9D02A8F4  8FBF002C   LW RA, 44(SP)
9D02A8F8  8FB30028   LW S3, 40(SP)
9D02A8FC  8FB20024   LW S2, 36(SP)
9D02A900  8FB10020   LW S1, 32(SP)
9D02A904  8FB0001C   LW S0, 28(SP)
9D02A908  03E00008   JR RA
9D02A90C  27BD0030   ADDIU SP, SP, 48
66:                  
67:                  static myvar_t *my_lookup(const char *group, const char *key) 
68:                  {
9D02AA30  27BDFFE0   ADDIU SP, SP, -32
9D02AA34  AFBF001C   SW RA, 28(SP)
9D02AA38  AFB20018   SW S2, 24(SP)
9D02AA3C  AFB10014   SW S1, 20(SP)
9D02AA40  AFB00010   SW S0, 16(SP)
9D02AA44  00808821   ADDU S1, A0, ZERO
69:                     int cmp;
70:                     myvar_t *current = myVars;
9D02AA48  8F908168   LW S0, -32408(GP)
71:                  
72:                     while (current
9D02AA4C  16000008   BNE S0, ZERO, 0x9D02AA70
9D02AA50  00A09021   ADDU S2, A1, ZERO
9D02AA68  1200000B   BEQ S0, ZERO, 0x9D02AA98
9D02AA6C  02001021   ADDU V0, S0, ZERO
73:                            && ((cmp = stricmp(group, current->group))
9D02AA70  02202021   ADDU A0, S1, ZERO
9D02AA74  0F40F05E   JAL .LFE5, strcasecmp
9D02AA78  8E050008   LW A1, 8(S0)
9D02AA7C  1440FFF7   BNE V0, ZERO, 0x9D02AA5C
9D02AA80  02402021   ADDU A0, S2, ZERO
74:                                || (cmp = stricmp(key, current->key))))
9D02AA84  0F40F05E   JAL .LFE5, strcasecmp
9D02AA88  8E05000C   LW A1, 12(S0)
9D02AA8C  1440FFF3   BNE V0, ZERO, 0x9D02AA5C
9D02AA90  00000000   NOP
75:                     {
76:                        if (cmp < 0)
9D02AA5C  04430002   BGEZL V0, 0x9D02AA68
9D02AA60  8E100004   LW S0, 4(S0)
9D02AA64  8E100000   LW S0, 0(S0)
77:                           current = current->less;
78:                        else
79:                           current = current->greater;
80:                     }
81:                  
82:                     return current;
83:                  }
9D02AA54  0B40AAA6   J 0x9D02AA98
9D02AA58  02001021   ADDU V0, S0, ZERO
9D02AA94  02001021   ADDU V0, S0, ZERO
9D02AA98  8FBF001C   LW RA, 28(SP)
9D02AA9C  8FB20018   LW S2, 24(SP)
9D02AAA0  8FB10014   LW S1, 20(SP)
9D02AAA4  8FB00010   LW S0, 16(SP)
9D02AAA8  03E00008   JR RA
9D02AAAC  27BD0020   ADDIU SP, SP, 32
84:                  
85:                  static void my_insert(myvar_t *var)
86:                  {
9D02A948  27BDFFE0   ADDIU SP, SP, -32
9D02A94C  AFBF001C   SW RA, 28(SP)
9D02A950  AFB20018   SW S2, 24(SP)
9D02A954  AFB10014   SW S1, 20(SP)
9D02A958  AFB00010   SW S0, 16(SP)
9D02A95C  00809021   ADDU S2, A0, ZERO
87:                     int cmp;
88:                     myvar_t **current = &myVars;
89:                  
90:                     while (*current
9D02A960  0B40AA5D   J 0x9D02A974
9D02A964  27918168   ADDIU S1, GP, -32408
9D02A974  8E300000   LW S0, 0(S1)
9D02A978  52000014   BEQL S0, ZERO, 0x9D02A9CC
9D02A97C  AE400004   SW ZERO, 4(S2)
91:                            && ((cmp = stricmp(var->group, (*current)->group))
9D02A980  8E440008   LW A0, 8(S2)
9D02A984  0F40F05E   JAL .LFE5, strcasecmp
9D02A988  8E050008   LW A1, 8(S0)
9D02A98C  1440FFF6   BNE V0, ZERO, 0x9D02A968
9D02A990  26030004   ADDIU V1, S0, 4
92:                                || (cmp = stricmp(var->key, (*current)->key))))
9D02A994  8E44000C   LW A0, 12(S2)
9D02A998  0F40F05E   JAL .LFE5, strcasecmp
9D02A99C  8E05000C   LW A1, 12(S0)
9D02A9A0  1440FFF1   BNE V0, ZERO, 0x9D02A968
9D02A9A4  26030004   ADDIU V1, S0, 4
93:                     {
94:                        current = (cmp < 0) ? &(*current)->less : &(*current)->greater;
9D02A968  28420000   SLTI V0, V0, 0
9D02A96C  00608821   ADDU S1, V1, ZERO
9D02A970  0202880B   MOVN S1, S0, V0
95:                     }
96:                  
97:                     if (*current)
98:                     {
99:                        var->less = (*current)->less;
9D02A9A8  8E020000   LW V0, 0(S0)
9D02A9AC  AE420000   SW V0, 0(S2)
100:                       var->greater = (*current)->greater;
9D02A9B0  8E220000   LW V0, 0(S1)
9D02A9B4  8C420004   LW V0, 4(V0)
9D02A9B8  AE420004   SW V0, 4(S2)
101:                       my_destroy(current);
9D02A9BC  0F40A9E7   JAL .LFB8, my_destroy, .Ltext0
9D02A9C0  02202021   ADDU A0, S1, ZERO
9D02A9C4  0B40AA75   J 0x9D02A9D4
9D02A9C8  AE320000   SW S2, 0(S1)
102:                    }
103:                    else
104:                    {
105:                       var->less = var->greater = NULL;
9D02A9CC  AE400000   SW ZERO, 0(S2)
106:                    }
107:                 
108:                    *current = var;
9D02A9D0  AE320000   SW S2, 0(S1)
109:                 }
9D02A9D4  8FBF001C   LW RA, 28(SP)
9D02A9D8  8FB20018   LW S2, 24(SP)
9D02A9DC  8FB10014   LW S1, 20(SP)
9D02A9E0  8FB00010   LW S0, 16(SP)
9D02A9E4  03E00008   JR RA
9D02A9E8  27BD0020   ADDIU SP, SP, 32
110:                 
111:                 static void my_save(FILE *stream, myvar_t *var, char **group)
112:                 {
9D02ABF4  27BDFFD8   ADDIU SP, SP, -40
9D02ABF8  AFBF0024   SW RA, 36(SP)
9D02ABFC  AFB30020   SW S3, 32(SP)
9D02AC00  AFB2001C   SW S2, 28(SP)
9D02AC04  AFB10018   SW S1, 24(SP)
9D02AC08  AFB00014   SW S0, 20(SP)
113:                    if (NULL == var)
9D02AC0C  10A0001B   BEQ A1, ZERO, .LVL85
9D02AC10  00A08021   ADDU S0, A1, ZERO
9D02AC14  00809021   ADDU S2, A0, ZERO
9D02AC18  00C08821   ADDU S1, A2, ZERO
114:                       return;
115:                 
116:                    my_save(stream, var->less, group);
9D02AC1C  0F40AAFD   JAL .LFB12, my_save, .LFE20
9D02AC20  8CA50000   LW A1, 0(A1)
117:                    
118:                    if (stricmp(*group, var->group))
9D02AC24  8E130008   LW S3, 8(S0)
9D02AC28  8E240000   LW A0, 0(S1)
9D02AC2C  0F40F05E   JAL .LFE5, strcasecmp
9D02AC30  02602821   ADDU A1, S3, ZERO
9D02AC34  10400008   BEQ V0, ZERO, 0x9D02AC58
9D02AC38  02402021   ADDU A0, S2, ZERO
119:                    {
120:                       fprintf(stream, "\n[%s]\n", var->group);
9D02AC3C  3C059D04   LUI A1, -25340
9D02AC40  24A58418   ADDIU A1, A1, -31720
9D02AC44  0F40F174   JAL _fprintf_s, _fprintf_0
9D02AC48  02603021   ADDU A2, S3, ZERO
121:                       *group = var->group;
9D02AC4C  8E020008   LW V0, 8(S0)
9D02AC50  AE220000   SW V0, 0(S1)
122:                    }
123:                    
124:                    fprintf(stream, "%s=%s\n", var->key, var->value);
9D02AC54  02402021   ADDU A0, S2, ZERO
9D02AC58  3C059D04   LUI A1, -25340
9D02AC5C  24A58420   ADDIU A1, A1, -31712
9D02AC60  8E06000C   LW A2, 12(S0)
9D02AC64  0F40F174   JAL _fprintf_s, _fprintf_0
9D02AC68  8E070010   LW A3, 16(S0)
125:                    
126:                    my_save(stream, var->greater, group);
9D02AC6C  02402021   ADDU A0, S2, ZERO
9D02AC70  8E050004   LW A1, 4(S0)
9D02AC74  0F40AAFD   JAL .LFB12, my_save, .LFE20
9D02AC78  02203021   ADDU A2, S1, ZERO
127:                 }
9D02AC7C  8FBF0024   LW RA, 36(SP)
9D02AC80  8FB30020   LW S3, 32(SP)
9D02AC84  8FB2001C   LW S2, 28(SP)
9D02AC88  8FB10018   LW S1, 24(SP)
9D02AC8C  8FB00014   LW S0, 20(SP)
9D02AC90  03E00008   JR RA
9D02AC94  27BD0028   ADDIU SP, SP, 40
128:                 
129:                 static void my_cleanup(myvar_t *var)
130:                 {
9D02A910  27BDFFE8   ADDIU SP, SP, -24
9D02A914  AFBF0014   SW RA, 20(SP)
131:                    if (NULL == var)
9D02A918  10800008   BEQ A0, ZERO, .LVL27
9D02A91C  AFA40018   SW A0, 24(SP)
132:                       return;
133:                 
134:                    my_cleanup(var->less);
9D02A920  0F40AA44   JAL .LFB13, my_cleanup, .LFE9
9D02A924  8C840000   LW A0, 0(A0)
135:                    my_cleanup(var->greater);
9D02A928  8FA20018   LW V0, 24(SP)
9D02A92C  0F40AA44   JAL .LFB13, my_cleanup, .LFE9
9D02A930  8C440004   LW A0, 4(V0)
136:                    my_destroy(&var);
9D02A934  0F40A9E7   JAL .LFB8, my_destroy, .Ltext0
9D02A938  27A40018   ADDIU A0, SP, 24
137:                 }
9D02A93C  8FBF0014   LW RA, 20(SP)
9D02A940  03E00008   JR RA
9D02A944  27BD0018   ADDIU SP, SP, 24
138:                 
139:                 static char *my_getline(FILE *stream)
140:                 {
9D02AD4C  27BDFBD8   ADDIU SP, SP, -1064
9D02AD50  AFBF0424   SW RA, 1060(SP)
9D02AD54  AFB20420   SW S2, 1056(SP)
9D02AD58  AFB1041C   SW S1, 1052(SP)
9D02AD5C  AFB00418   SW S0, 1048(SP)
9D02AD60  00808821   ADDU S1, A0, ZERO
141:                    char buf[1024];
142:                    char *dynamic = NULL;
9D02AD64  AFA00410   SW ZERO, 1040(SP)
143:                 
144:                    do
145:                    {
146:                       if (NULL == (fgets(buf, sizeof(buf), stream)))
9D02AD6C  27A40010   ADDIU A0, SP, 16
9D02AD70  24050400   ADDIU A1, ZERO, 1024
9D02AD74  0F40E635   JAL fgets
9D02AD78  02203021   ADDU A2, S1, ZERO
9D02AD7C  14400008   BNE V0, ZERO, 0x9D02ADA0
9D02AD80  00408021   ADDU S0, V0, ZERO
147:                       {
148:                          if (dynamic)
9D02AD84  8FA20410   LW V0, 1040(SP)
9D02AD88  50400039   BEQL V0, ZERO, 0x9D02AE70
9D02AD8C  02001021   ADDU V0, S0, ZERO
149:                             free(dynamic);
9D02AD90  0F40DDCA   JAL _my_free
9D02AD94  27A40410   ADDIU A0, SP, 1040
150:                          return 0;
151:                       }
152:                 
153:                       if (NULL == dynamic)
9D02ADA0  8FA40410   LW A0, 1040(SP)
9D02ADA4  1480000C   BNE A0, ZERO, 0x9D02ADD8
9D02ADA8  00000000   NOP
154:                       {
155:                          dynamic = malloc(strlen(buf) + 1);
9D02ADAC  0F40DBFE   JAL strlen
9D02ADB0  27A40010   ADDIU A0, SP, 16
9D02ADB4  0F40DDB7   JAL _my_malloc
9D02ADB8  24440001   ADDIU A0, V0, 1
156:                          if (NULL == dynamic)
9D02ADBC  10400028   BEQ V0, ZERO, 0x9D02AE60
9D02ADC0  AFA20410   SW V0, 1040(SP)
157:                          {
158:                             return 0;
9D02AE60  0B40AB9B   J 0x9D02AE6C
9D02AE64  00008021   ADDU S0, ZERO, ZERO
159:                          }
160:                          strcpy(dynamic, buf);
9D02ADC4  00402021   ADDU A0, V0, ZERO
9D02ADC8  0F40D947   JAL .LFE23, strcpy
9D02ADCC  27A50010   ADDIU A1, SP, 16
9D02ADD0  0B40AB8A   J 0x9D02AE28
9D02ADD4  96220010   LHU V0, 16(S1)
161:                       }
162:                       else
163:                       {
164:                          /* a mini-version of realloc that works with our memory manager */
165:                          char *temp = NULL;
166:                          temp = malloc(strlen(dynamic) + strlen(buf) + 1);
9D02ADD8  0F40DBFE   JAL strlen
9D02ADDC  00000000   NOP
9D02ADE0  00408021   ADDU S0, V0, ZERO
9D02ADE4  0F40DBFE   JAL strlen
9D02ADE8  27A40010   ADDIU A0, SP, 16
9D02ADEC  02021021   ADDU V0, S0, V0
9D02ADF0  0F40DDB7   JAL _my_malloc
9D02ADF4  24440001   ADDIU A0, V0, 1
167:                          if (NULL == temp)
9D02ADF8  1040001B   BEQ V0, ZERO, 0x9D02AE68
9D02ADFC  00408021   ADDU S0, V0, ZERO
168:                             return 0;
9D02AE68  00008021   ADDU S0, ZERO, ZERO
169:                 
170:                          strcpy(temp, dynamic);
9D02AE00  00402021   ADDU A0, V0, ZERO
9D02AE04  0F40D947   JAL .LFE23, strcpy
9D02AE08  8FA50410   LW A1, 1040(SP)
171:                          free(dynamic);
9D02AE0C  0F40DDCA   JAL _my_free
9D02AE10  27A40410   ADDIU A0, SP, 1040
172:                          dynamic = temp;
9D02AE14  AFB00410   SW S0, 1040(SP)
173:                 
174:                          strcat(dynamic, buf);
9D02AE18  02002021   ADDU A0, S0, ZERO
9D02AE1C  0F40EAA1   JAL strcat
9D02AE20  27A50010   ADDIU A1, SP, 16
175:                       }
176:                 
177:                       if (feof(stream))
9D02AE24  96220010   LHU V0, 16(S1)
9D02AE28  30420020   ANDI V0, V0, 32
9D02AE2C  3042FFFF   ANDI V0, V0, -1
9D02AE30  10400003   BEQ V0, ZERO, 0x9D02AE40
9D02AE34  8FB00410   LW S0, 1040(SP)
178:                       {
179:                          return dynamic;
9D02AE38  0B40AB9C   J 0x9D02AE70
9D02AE3C  02001021   ADDU V0, S0, ZERO
180:                       }
181:                    } 
182:                    while (dynamic[strlen(dynamic) - 1] != '\n');
9D02AD68  2412000A   ADDIU S2, ZERO, 10
9D02AE40  0F40DBFE   JAL strlen
9D02AE44  02002021   ADDU A0, S0, ZERO
9D02AE48  02021021   ADDU V0, S0, V0
9D02AE4C  8042FFFF   LB V0, -1(V0)
9D02AE50  5452FFC7   BNEL V0, S2, 0x9D02AD70
9D02AE54  27A40010   ADDIU A0, SP, 16
9D02AE58  0B40AB9C   J 0x9D02AE70
9D02AE5C  02001021   ADDU V0, S0, ZERO
183:                 
184:                    return dynamic;
185:                 }
9D02AD98  0B40AB9C   J 0x9D02AE70
9D02AD9C  02001021   ADDU V0, S0, ZERO
9D02AE6C  02001021   ADDU V0, S0, ZERO
9D02AE70  8FBF0424   LW RA, 1060(SP)
9D02AE74  8FB20420   LW S2, 1056(SP)
9D02AE78  8FB1041C   LW S1, 1052(SP)
9D02AE7C  8FB00418   LW S0, 1048(SP)
9D02AE80  03E00008   JR RA
9D02AE84  27BD0428   ADDIU SP, SP, 1064
186:                 
187:                 /* load_config loads from the disk the saved configuration. */
188:                 static int load_config(char *filename)
189:                 {
190:                    FILE *config_file;
191:                 
192:                    if ((config_file = fopen(filename, "r")))
9D02AEB0  3C02A001   LUI V0, -24575
9D02AEB4  8C44B848   LW A0, -18360(V0)
9D02AEB8  3C059D04   LUI A1, -25340
9D02AEBC  0F40DCB1   JAL .Letext0, .LFE3, fopen
9D02AEC0  24A58480   ADDIU A1, A1, -31616
9D02AEC4  104000A9   BEQ V0, ZERO, 0x9D02B16C
9D02AEC8  0040A821   ADDU S5, V0, ZERO
193:                    {
194:                       char *line;
195:                       char *group = NULL, *key = NULL, *value = NULL;
9D02AECC  AFA00010   SW ZERO, 16(SP)
196:                 
197:                       mySaveNeeded = true;
9D02AED0  24020001   ADDIU V0, ZERO, 1
9D02AED4  AF828164   SW V0, -32412(GP)
198:                       while ((line = my_getline(config_file)))
9D02B134  0F40AB53   JAL .LFB14, my_getline, .LFE18
9D02B138  02A02021   ADDU A0, S5, ZERO
9D02B13C  00408021   ADDU S0, V0, ZERO
9D02B140  1440FF6D   BNE V0, ZERO, 0x9D02AEF8
9D02B144  AFA20014   SW V0, 20(SP)
199:                       {
200:                          char *s;
201:                          
202:                          if ('\n' == line[strlen(line) - 1])
9D02AEF8  0F40DBFE   JAL strlen
9D02AEFC  02002021   ADDU A0, S0, ZERO
9D02AF00  2442FFFF   ADDIU V0, V0, -1
9D02AF04  02028021   ADDU S0, S0, V0
9D02AF08  82030000   LB V1, 0(S0)
9D02AF0C  2402000A   ADDIU V0, ZERO, 10
9D02AF10  50620001   BEQL V1, V0, 0x9D02AF18
9D02AF14  A2000000   SB ZERO, 0(S0)
203:                             line[strlen(line) - 1] = '\0';
204:                          
205:                          s = line;
9D02AF18  8FB10014   LW S1, 20(SP)
9D02AF1C  24130023   ADDIU S3, ZERO, 35
206:                 
207:                          do 
208:                          {
209:                             /* eat up whitespace */
210:                             while (isspace(*s))
9D02AED8  3C129D04   LUI S2, -25340
9D02AEDC  26528A4D   ADDIU S2, S2, -30131
9D02AF20  82220000   LB V0, 0(S1)
9D02AF24  00521821   ADDU V1, V0, S2
9D02AF28  80630000   LB V1, 0(V1)
9D02AF2C  30630088   ANDI V1, V1, 136
9D02AF30  5460FFFB   BNEL V1, ZERO, 0x9D02AF20
9D02AF34  26310001   ADDIU S1, S1, 1
211:                                s++;
212:                 
213:                             switch (*s) 
9D02AF38  1053000D   BEQ V0, S3, 0x9D02AF70
9D02AF3C  28430024   SLTI V1, V0, 36
9D02AF40  10600005   BEQ V1, ZERO, 0x9D02AF58
9D02AF44  2403003B   ADDIU V1, ZERO, 59
9D02AF48  14400028   BNE V0, ZERO, 0x9D02AFEC
9D02AF4C  02202021   ADDU A0, S1, ZERO
9D02AF58  10430005   BEQ V0, V1, 0x9D02AF70
9D02AF5C  2403005B   ADDIU V1, ZERO, 91
9D02AF60  10430005   BEQ V0, V1, 0x9D02AF78
9D02AF64  8FA20010   LW V0, 16(SP)
214:                             {
215:                             case ';':
216:                             case '#':
217:                             case '\0':
218:                                *s = '\0';
9D02AF50  0B40AC4B   J 0x9D02B12C
9D02AF54  A2200000   SB ZERO, 0(S1)
9D02AF70  0B40AC4B   J 0x9D02B12C
9D02AF74  A2200000   SB ZERO, 0(S1)
219:                                break;
220:                 
221:                             case '[':
222:                                if (group)
9D02AF78  10400004   BEQ V0, ZERO, 0x9D02AF8C
9D02AF7C  26240001   ADDIU A0, S1, 1
223:                                   free(group);
9D02AF80  0F40DDCA   JAL _my_free
9D02AF84  27A40010   ADDIU A0, SP, 16
224:                 
225:                                group = ++s;
9D02AF88  26240001   ADDIU A0, S1, 1
9D02AF8C  AFA40010   SW A0, 16(SP)
226:                 
227:                                s = strchr(s, ']');
9D02AF90  0F40E513   JAL strchr
9D02AF94  2405005D   ADDIU A1, ZERO, 93
228:                                if (NULL == s)
9D02AF98  54400008   BNEL V0, ZERO, 0x9D02AFBC
9D02AF9C  24510001   ADDIU S1, V0, 1
229:                                {
230:                                   log_printf("load_config: missing ']' after group\n");
9D02AEEC  3C169D04   LUI S6, -25340
9D02AEF0  0B40AC4D   J .LVL147
9D02AEF4  26D68484   ADDIU S6, S6, -31612
9D02AFA0  0F40F11B   JAL log_printf
9D02AFA4  02C02021   ADDU A0, S6, ZERO
231:                                   s = group + strlen(group);
9D02AFA8  8FB10010   LW S1, 16(SP)
9D02AFAC  0F40DBFE   JAL strlen
9D02AFB0  02202021   ADDU A0, S1, ZERO
9D02AFB4  0B40ABF0   J 0x9D02AFC0
9D02AFB8  02228821   ADDU S1, S1, V0
232:                                }
233:                                else
234:                                {
235:                                   *s++ = '\0';
9D02AFBC  A0400000   SB ZERO, 0(V0)
236:                                }
237:                 
238:                                if ((value = malloc(strlen(group) + 1)))
9D02AFC0  0F40DBFE   JAL strlen
9D02AFC4  8FA40010   LW A0, 16(SP)
9D02AFC8  0F40DDB7   JAL _my_malloc
9D02AFCC  24440001   ADDIU A0, V0, 1
9D02AFD0  10400004   BEQ V0, ZERO, .LVL130
9D02AFD4  00408021   ADDU S0, V0, ZERO
239:                                {
240:                                   strcpy(value, group);
9D02AFD8  00402021   ADDU A0, V0, ZERO
9D02AFDC  0F40D947   JAL .LFE23, strcpy
9D02AFE0  8FA50010   LW A1, 16(SP)
241:                                }
242:                                group = value;
9D02AFE4  0B40AC48   J 0x9D02B120
9D02AFE8  AFB00010   SW S0, 16(SP)
243:                                break;
244:                 
245:                             default:
246:                                key = s;
247:                                s = strchr(s, '=');
9D02AF68  0B40ABFB   J 0x9D02AFEC
9D02AF6C  02202021   ADDU A0, S1, ZERO
9D02AFEC  0F40E513   JAL strchr
9D02AFF0  2405003D   ADDIU A1, ZERO, 61
248:                                if (NULL == s)
9D02AFF4  1440000B   BNE V0, ZERO, 0x9D02B024
9D02AFF8  24500001   ADDIU S0, V0, 1
249:                                {
250:                                   log_printf("load_config: missing '=' after key\n");
9D02AEE4  3C179D04   LUI S7, -25340
9D02AEE8  26F784AC   ADDIU S7, S7, -31572
9D02AFFC  0F40F11B   JAL log_printf
9D02B000  02E02021   ADDU A0, S7, ZERO
251:                                   s = key + strlen(key);
9D02B004  0F40DBFE   JAL strlen
9D02B008  02202021   ADDU A0, S1, ZERO
9D02B00C  02228021   ADDU S0, S1, V0
252:                                }
253:                                else
254:                                {
255:                                   *s++ = '\0';
9D02B024  0B40AC04   J 0x9D02B010
9D02B028  A0400000   SB ZERO, 0(V0)
256:                                }
257:                 
258:                                while (strlen(key) && isspace(key[strlen(key) - 1])) 
9D02B010  82220000   LB V0, 0(S1)
9D02B014  50400013   BEQL V0, ZERO, 0x9D02B064
9D02B018  82020000   LB V0, 0(S0)
9D02B01C  0B40AC0E   J 0x9D02B038
9D02B020  00000000   NOP
9D02B02C  82220000   LB V0, 0(S1)
9D02B030  5040000C   BEQL V0, ZERO, 0x9D02B064
9D02B034  82020000   LB V0, 0(S0)
9D02B038  0F40DBFE   JAL strlen
9D02B03C  02202021   ADDU A0, S1, ZERO
9D02B040  2442FFFF   ADDIU V0, V0, -1
9D02B044  02221021   ADDU V0, S1, V0
9D02B048  80430000   LB V1, 0(V0)
9D02B04C  00721821   ADDU V1, V1, S2
9D02B050  80630000   LB V1, 0(V1)
9D02B054  30630088   ANDI V1, V1, 136
9D02B058  5460FFF4   BNEL V1, ZERO, 0x9D02B02C
9D02B05C  A0400000   SB ZERO, 0(V0)
259:                                   key[strlen(key) - 1] = '\0';
260:                 
261:                                while (isspace(*s)) 
9D02B060  82020000   LB V0, 0(S0)
9D02B064  00521021   ADDU V0, V0, S2
9D02B068  80420000   LB V0, 0(V0)
9D02B06C  30420088   ANDI V0, V0, 136
9D02B070  50400009   BEQL V0, ZERO, 0x9D02B098
9D02B074  82020000   LB V0, 0(S0)
9D02B07C  82020000   LB V0, 0(S0)
9D02B080  00521021   ADDU V0, V0, S2
9D02B084  80420000   LB V0, 0(V0)
9D02B088  30420088   ANDI V0, V0, 136
9D02B08C  5440FFFB   BNEL V0, ZERO, 0x9D02B07C
9D02B090  26100001   ADDIU S0, S0, 1
262:                                   s++;
9D02B078  26100001   ADDIU S0, S0, 1
263:                                
264:                                while (strlen(s) && isspace(s[strlen(s) - 1])) 
9D02B094  82020000   LB V0, 0(S0)
9D02B098  10400011   BEQ V0, ZERO, 0x9D02B0E0
9D02B09C  8FA20010   LW V0, 16(SP)
9D02B0A0  0B40AC2D   J 0x9D02B0B4
9D02B0A4  00000000   NOP
9D02B0A8  82020000   LB V0, 0(S0)
9D02B0AC  1040000C   BEQ V0, ZERO, 0x9D02B0E0
9D02B0B0  8FA20010   LW V0, 16(SP)
9D02B0B4  0F40DBFE   JAL strlen
9D02B0B8  02002021   ADDU A0, S0, ZERO
9D02B0BC  2442FFFF   ADDIU V0, V0, -1
9D02B0C0  02021821   ADDU V1, S0, V0
9D02B0C4  80620000   LB V0, 0(V1)
9D02B0C8  00521021   ADDU V0, V0, S2
9D02B0CC  80420000   LB V0, 0(V0)
9D02B0D0  30420088   ANDI V0, V0, 136
9D02B0D4  5440FFF4   BNEL V0, ZERO, 0x9D02B0A8
9D02B0D8  A0600000   SB ZERO, 0(V1)
265:                                   s[strlen(s) - 1]='\0';
266:                 
267:                                {
268:                                   myvar_t *var = my_create(group ? group : "", key, s);
9D02AEE0  3C149D04   LUI S4, -25340
9D02B0DC  8FA20010   LW V0, 16(SP)
9D02B0E0  26848428   ADDIU A0, S4, -31704
9D02B0E4  0042200B   MOVN A0, V0, V0
9D02B0E8  02202821   ADDU A1, S1, ZERO
9D02B0EC  0F40AA03   JAL .LFB9, my_create, .LFE8
9D02B0F0  02003021   ADDU A2, S0, ZERO
269:                                   if (NULL == var)
9D02B0F4  14400005   BNE V0, ZERO, 0x9D02B10C
9D02B0F8  3C049D04   LUI A0, -25340
270:                                   {
271:                                      log_printf("load_config: my_create failed\n");
9D02B0FC  0F40F11B   JAL log_printf
9D02B100  248484D0   ADDIU A0, A0, -31536
272:                                      return -1;
9D02B104  0B40AC5C   J 0x9D02B170
9D02B108  2402FFFF   ADDIU V0, ZERO, -1
273:                                   }
274:                 
275:                                   my_insert(var);
9D02B10C  0F40AA52   JAL .LFB11, my_insert, .LFE13
9D02B110  00402021   ADDU A0, V0, ZERO
276:                                }
277:                                s += strlen(s);
9D02B114  0F40DBFE   JAL strlen
9D02B118  02002021   ADDU A0, S0, ZERO
9D02B11C  02028821   ADDU S1, S0, V0
278:                             }
279:                          } while (*s);
9D02B120  82220000   LB V0, 0(S1)
9D02B124  1440FF80   BNE V0, ZERO, 0x9D02AF28
9D02B128  00521821   ADDU V1, V0, S2
280:                 
281:                          free(line);
9D02B12C  0F40DDCA   JAL _my_free
9D02B130  27A40014   ADDIU A0, SP, 20
282:                       }
283:                 
284:                       if (group) 
9D02B148  8FA20010   LW V0, 16(SP)
9D02B14C  10400003   BEQ V0, ZERO, .LVL149
9D02B150  00000000   NOP
285:                          free(group);
9D02B154  0F40DDCA   JAL _my_free
9D02B158  27A40010   ADDIU A0, SP, 16
286:                 
287:                       fclose(config_file);
9D02B15C  0F40EBD5   JAL .Letext0, .LFE1, fclose
9D02B160  02A02021   ADDU A0, S5, ZERO
288:                    }
289:                 
290:                    return 0;
9D02B164  0B40AC5C   J 0x9D02B170
9D02B168  00001021   ADDU V0, ZERO, ZERO
9D02B16C  00001021   ADDU V0, ZERO, ZERO
291:                 }
292:                 
293:                 /* save_config saves the current configuration to disk.*/
294:                 static int save_config(char *filename)
295:                 {
296:                    FILE *config_file;
297:                    char *group = "";
9D02ACB8  3C029D04   LUI V0, -25340
298:                 
299:                    config_file = fopen(filename, "w");
9D02ACC4  3C059D04   LUI A1, -25340
300:                    if (NULL == config_file)
9D02ACD0  14400006   BNE V0, ZERO, 0x9D02ACEC
301:                    {
302:                       log_printf("save_config failed\n");
9D02ACD8  3C049D04   LUI A0, -25340
303:                       return -1;
304:                    }
305:                 
306:                    fprintf(config_file, ";; " APP_STRING " " APP_VERSION "\n");
9D02ACEC  3C049D04   LUI A0, -25340
307:                    fprintf(config_file, ";; NOTE: comments are not preserved.\n");
9D02AD04  3C049D04   LUI A0, -25340
308:                    my_save(config_file, myVars, &group);
9D02AD1C  02002021   ADDU A0, S0, ZERO
309:                    fclose(config_file);
9D02AD2C  0F40EBD5   JAL .Letext0, .LFE1, fclose
9D02AD30  02002021   ADDU A0, S0, ZERO
310:                 
311:                    return 0;
312:                 }
313:                 
314:                 static bool open_config(void)
315:                 {
9D02AE88  27BDFFC0   ADDIU SP, SP, -64
9D02AE8C  AFBF003C   SW RA, 60(SP)
9D02AE90  AFB70038   SW S7, 56(SP)
9D02AE94  AFB60034   SW S6, 52(SP)
9D02AE98  AFB50030   SW S5, 48(SP)
9D02AE9C  AFB4002C   SW S4, 44(SP)
9D02AEA0  AFB30028   SW S3, 40(SP)
9D02AEA4  AFB20024   SW S2, 36(SP)
9D02AEA8  AFB10020   SW S1, 32(SP)
9D02AEAC  AFB0001C   SW S0, 28(SP)
316:                    return load_config(config.filename);
317:                 }
9D02B170  8FBF003C   LW RA, 60(SP)
9D02B174  8FB70038   LW S7, 56(SP)
9D02B178  8FB60034   LW S6, 52(SP)
9D02B17C  8FB50030   LW S5, 48(SP)
9D02B180  8FB4002C   LW S4, 44(SP)
9D02B184  8FB30028   LW S3, 40(SP)
9D02B188  8FB20024   LW S2, 36(SP)
9D02B18C  8FB10020   LW S1, 32(SP)
9D02B190  8FB0001C   LW S0, 28(SP)
9D02B194  03E00008   JR RA
9D02B198  27BD0040   ADDIU SP, SP, 64
318:                 
319:                 static void close_config(void)
320:                 {
9D02AC98  27BDFFE0   ADDIU SP, SP, -32
9D02AC9C  AFBF001C   SW RA, 28(SP)
9D02ACA0  AFB00018   SW S0, 24(SP)
321:                    if (true == mySaveNeeded) 
9D02ACA4  24020001   ADDIU V0, ZERO, 1
9D02ACA8  8F838164   LW V1, -32412(GP)
9D02ACAC  14620021   BNE V1, V0, .LVL94, .LBE5, .LBE4
9D02ACB0  3C02A001   LUI V0, -24575
322:                    {
323:                       save_config(config.filename);
9D02ACB4  8C44B848   LW A0, -18360(V0)
324:                    }
325:                 
326:                    my_cleanup(myVars);
9D02AD34  0F40AA44   JAL .LFB13, my_cleanup, .LFE9
9D02AD38  8F848168   LW A0, -32408(GP)
327:                 }
9D02AD3C  8FBF001C   LW RA, 28(SP)
9D02AD40  8FB00018   LW S0, 24(SP)
9D02AD44  03E00008   JR RA
9D02AD48  27BD0020   ADDIU SP, SP, 32
328:                 
329:                 static void write_int(const char *group, const char *key, int value)
330:                 {
9D02AB14  27BDFFC8   ADDIU SP, SP, -56
9D02AB18  AFBF0034   SW RA, 52(SP)
9D02AB1C  AFB10030   SW S1, 48(SP)
9D02AB20  AFB0002C   SW S0, 44(SP)
9D02AB24  00808821   ADDU S1, A0, ZERO
9D02AB28  00A08021   ADDU S0, A1, ZERO
331:                    char buf[24];
332:                    static myvar_t *var;
333:                 
334:                    sprintf(buf, "%d", value);
9D02AB2C  27A40010   ADDIU A0, SP, 16
9D02AB30  3C059D04   LUI A1, -25340
9D02AB34  0F40EDE4   JAL _sprintf_cdnopuxX, _sprintf_cdnopsuxX
9D02AB38  24A58400   ADDIU A1, A1, -31744
335:                    buf[sizeof(buf) - 1] = '\0';
9D02AB3C  A3A00027   SB ZERO, 39(SP)
336:                 
337:                    var = my_create(group, key, buf);
9D02AB40  02202021   ADDU A0, S1, ZERO
9D02AB44  02002821   ADDU A1, S0, ZERO
9D02AB48  0F40AA03   JAL .LFB9, my_create, .LFE8
9D02AB4C  27A60010   ADDIU A2, SP, 16
338:                    if (NULL == var)
9D02AB50  14400005   BNE V0, ZERO, 0x9D02AB68
9D02AB54  3C049D04   LUI A0, -25340
339:                    {
340:                       log_printf("write_int failed\n");
9D02AB58  0F40F11B   JAL log_printf
9D02AB5C  24848404   ADDIU A0, A0, -31740
341:                       return;
342:                    }
343:                 
344:                    my_insert(var);
9D02AB68  0F40AA52   JAL .LFB11, my_insert, .LFE13
9D02AB6C  00402021   ADDU A0, V0, ZERO
345:                    mySaveNeeded = true;
9D02AB70  24020001   ADDIU V0, ZERO, 1
9D02AB74  AF828164   SW V0, -32412(GP)
346:                 }
9D02AB60  0B40AADF   J 0x9D02AB7C
9D02AB64  8FBF0034   LW RA, 52(SP)
9D02AB78  8FBF0034   LW RA, 52(SP)
9D02AB7C  8FB10030   LW S1, 48(SP)
9D02AB80  8FB0002C   LW S0, 44(SP)
9D02AB84  03E00008   JR RA
9D02AB88  27BD0038   ADDIU SP, SP, 56
347:                 
348:                 /* read_int loads an integer from the configuration into "value"
349:                 **
350:                 ** If the specified "key" does not exist, the "def"ault is returned
351:                 */
352:                 static int read_int(const char *group, const char *key, int def)
353:                 {
9D02AB8C  27BDFFE0   ADDIU SP, SP, -32
9D02AB90  AFBF001C   SW RA, 28(SP)
9D02AB94  AFB20018   SW S2, 24(SP)
9D02AB98  AFB10014   SW S1, 20(SP)
9D02AB9C  AFB00010   SW S0, 16(SP)
9D02ABA0  00809021   ADDU S2, A0, ZERO
9D02ABA4  00A08821   ADDU S1, A1, ZERO
354:                    static myvar_t *var;
355:                 
356:                    var = my_lookup(group, key);
9D02ABA8  0F40AA8C   JAL .LFB10, my_lookup, .LFE21
9D02ABAC  00C08021   ADDU S0, A2, ZERO
357:                    if (NULL == var)
9D02ABB0  54400007   BNEL V0, ZERO, 0x9D02ABD0
9D02ABB4  8C440010   LW A0, 16(V0)
358:                    {
359:                       write_int(group, key, def);
9D02ABB8  02402021   ADDU A0, S2, ZERO
9D02ABBC  02202821   ADDU A1, S1, ZERO
9D02ABC0  0F40AAC5   JAL .LFB19, write_int, .LFE22
9D02ABC4  02003021   ADDU A2, S0, ZERO
360:                       
361:                       return def;
9D02ABC8  0B40AAF7   J .LVL75
9D02ABCC  02001021   ADDU V0, S0, ZERO
362:                    }
363:                 
364:                    return strtoul(var->value, 0, 0);
9D02ABD0  00002821   ADDU A1, ZERO, ZERO
9D02ABD4  0F40D04D   JAL strtoul
9D02ABD8  00003021   ADDU A2, ZERO, ZERO
365:                 }
9D02ABDC  8FBF001C   LW RA, 28(SP)
9D02ABE0  8FB20018   LW S2, 24(SP)
9D02ABE4  8FB10014   LW S1, 20(SP)
9D02ABE8  8FB00010   LW S0, 16(SP)
9D02ABEC  03E00008   JR RA
9D02ABF0  27BD0020   ADDIU SP, SP, 32
366:                 
367:                 static void write_string(const char *group, const char *key, const char *value)
368:                 {
9D02A9EC  27BDFFE8   ADDIU SP, SP, -24
9D02A9F0  AFBF0014   SW RA, 20(SP)
369:                    static myvar_t *var;
370:                 
371:                    var = my_create(group, key, value);
9D02A9F4  0F40AA03   JAL .LFB9, my_create, .LFE8
9D02A9F8  00000000   NOP
372:                    if (NULL == var)
9D02A9FC  14400005   BNE V0, ZERO, 0x9D02AA14
9D02AA00  3C049D04   LUI A0, -25340
373:                    {
374:                       log_printf("write_string failed\n");
9D02AA04  0F40F11B   JAL log_printf
9D02AA08  248483E8   ADDIU A0, A0, -31768
375:                       return;
9D02AA0C  0B40AA8A   J 0x9D02AA28
9D02AA10  8FBF0014   LW RA, 20(SP)
376:                    }
377:                 
378:                    my_insert(var);
9D02AA14  0F40AA52   JAL .LFB11, my_insert, .LFE13
9D02AA18  00402021   ADDU A0, V0, ZERO
379:                    mySaveNeeded = true;
9D02AA1C  24020001   ADDIU V0, ZERO, 1
9D02AA20  AF828164   SW V0, -32412(GP)
380:                 }
9D02AA24  8FBF0014   LW RA, 20(SP)
9D02AA28  03E00008   JR RA
9D02AA2C  27BD0018   ADDIU SP, SP, 24
381:                 
382:                 /* read_string copies a string from the configuration into "value"
383:                 **
384:                 ** If the specified "key" does not exist, the "def"ault is returned
385:                 */
386:                 static const char *read_string(const char *group, const char *key, const char *def)
387:                 {
9D02AAB0  27BDFFE0   ADDIU SP, SP, -32
9D02AAB4  AFBF001C   SW RA, 28(SP)
9D02AAB8  AFB20018   SW S2, 24(SP)
9D02AABC  AFB10014   SW S1, 20(SP)
9D02AAC0  AFB00010   SW S0, 16(SP)
9D02AAC4  00809021   ADDU S2, A0, ZERO
9D02AAC8  00A08821   ADDU S1, A1, ZERO
388:                    static myvar_t *var;
389:                 
390:                    var = my_lookup(group, key);
9D02AACC  0F40AA8C   JAL .LFB10, my_lookup, .LFE21
9D02AAD0  00C08021   ADDU S0, A2, ZERO
391:                    if (NULL == var)
9D02AAD4  54400009   BNEL V0, ZERO, 0x9D02AAFC
9D02AAD8  8C420010   LW V0, 16(V0)
392:                    {
393:                       if (def != NULL)
9D02AADC  12000006   BEQ S0, ZERO, 0x9D02AAF8
9D02AAE0  02402021   ADDU A0, S2, ZERO
394:                          write_string(group, key, def);
9D02AAE4  02202821   ADDU A1, S1, ZERO
9D02AAE8  0F40AA7B   JAL .LFB21, write_string, .LFE11
9D02AAEC  02003021   ADDU A2, S0, ZERO
395:                 
396:                       return def;
9D02AAF0  0B40AABF   J 0x9D02AAFC
9D02AAF4  02001021   ADDU V0, S0, ZERO
9D02AAF8  02001021   ADDU V0, S0, ZERO
397:                    }
398:                 
399:                    return var->value;
400:                 }
9D02AAFC  8FBF001C   LW RA, 28(SP)
9D02AB00  8FB20018   LW S2, 24(SP)
9D02AB04  8FB10014   LW S1, 20(SP)
9D02AB08  8FB00010   LW S0, 16(SP)
9D02AB0C  03E00008   JR RA
9D02AB10  27BD0020   ADDIU SP, SP, 32
401:                 
402:                 /* interface */
403:                 config_t config =
404:                 {
405:                    open_config,
406:                    close_config,
407:                    read_int,
408:                    read_string,
409:                    write_int,
410:                    write_string,
411:                    CONFIG_FILE
412:                 };
413:                 
414:                 /*
415:                 ** $Log: config.c,v $
416:                 ** Revision 1.2  2001/04/27 14:37:11  neil
417:                 ** wheeee
418:                 **
419:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
420:                 ** initial
421:                 **
422:                 ** Revision 1.14  2000/11/05 06:23:10  matt
423:                 ** realloc was incompatible with memguard
424:                 **
425:                 ** Revision 1.13  2000/10/10 13:58:13  matt
426:                 ** stroustrup squeezing his way in the door
427:                 **
428:                 ** Revision 1.12  2000/09/20 01:13:28  matt
429:                 ** damn tabs
430:                 **
431:                 ** Revision 1.11  2000/08/04 12:41:04  neil
432:                 ** current not a bug
433:                 **
434:                 ** Revision 1.10  2000/07/31 04:28:46  matt
435:                 ** one million cleanups
436:                 **
437:                 ** Revision 1.9  2000/07/24 04:30:42  matt
438:                 ** slight cleanup
439:                 **
440:                 ** Revision 1.8  2000/07/23 15:16:08  matt
441:                 ** changed strcasecmp to stricmp
442:                 **
443:                 ** Revision 1.7  2000/07/19 15:58:55  neil
444:                 ** config file now configurable (ha)
445:                 **
446:                 ** Revision 1.6  2000/07/18 03:28:32  matt
447:                 ** help me!  I'm a complete mess!
448:                 **
449:                 ** Revision 1.5  2000/07/12 11:03:08  neil
450:                 ** Always write a config, even if no defaults are changed
451:                 **
452:                 ** Revision 1.4  2000/07/11 15:09:30  matt
453:                 ** suppressed all warnings
454:                 **
455:                 ** Revision 1.3  2000/07/11 14:59:27  matt
456:                 ** minor cosmetics.. =)
457:                 **
458:                 ** Revision 1.2  2000/07/11 13:35:38  bsittler
459:                 ** Changed the config API, implemented config file "nofrendo.cfg". The
460:                 ** GGI drivers use the group [GGI]. Visual= and Mode= keys are understood.
461:                 **
462:                 ** Revision 1.1  2000/07/11 09:21:10  bsittler
463:                 ** This is a skeletal configuration system.
464:                 **
465:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/bitmap.c  ----------------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** bitmap.c
21:                  **
22:                  ** Bitmap object manipulation routines
23:                  ** $Id: bitmap.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <stdio.h>
27:                  #include <string.h>
28:                  #include <noftypes.h>
29:                  #include <bitmap.h>
30:                  
31:                  void bmp_clear(const bitmap_t *bitmap, uint8 color)
32:                  {
9D03571C  27BDFFE8   ADDIU SP, SP, -24
9D035720  AFBF0014   SW RA, 20(SP)
33:                     memset(bitmap->data, color, bitmap->pitch * bitmap->height);
9D035724  8C860008   LW A2, 8(A0)
9D035728  8C820004   LW V0, 4(A0)
9D03572C  8C840010   LW A0, 16(A0)
9D035730  0F40E9FC   JAL .Letext0, .LFE0, memset
9D035734  70C23002   MUL A2, A2, V0
34:                  }
9D035738  8FBF0014   LW RA, 20(SP)
9D03573C  03E00008   JR RA
9D035740  27BD0018   ADDIU SP, SP, 24
35:                  
36:                  static bitmap_t *_make_bitmap(uint8 *data_addr, bool hw, int width, 
37:                                                int height, int pitch, int overdraw)
38:                  {
9D03562C  27BDFFD8   ADDIU SP, SP, -40
9D035630  AFBF0024   SW RA, 36(SP)
9D035634  AFB40020   SW S4, 32(SP)
9D035638  AFB3001C   SW S3, 28(SP)
9D03563C  AFB20018   SW S2, 24(SP)
9D035640  AFB10014   SW S1, 20(SP)
9D035644  AFB00010   SW S0, 16(SP)
9D035648  00808821   ADDU S1, A0, ZERO
39:                     bitmap_t *bitmap;
40:                     int i;
41:                  
42:                     /* quick safety check */
43:                     if (NULL == data_addr)
9D03564C  10800028   BEQ A0, ZERO, 0x9D0356F0
9D035650  8FB2003C   LW S2, 60(SP)
9D035654  00A09821   ADDU S3, A1, ZERO
9D035658  00C0A021   ADDU S4, A2, ZERO
9D03565C  00E08021   ADDU S0, A3, ZERO
44:                        return NULL;
9D0356F0  0B40D5BF   J 0x9D0356FC
9D0356F4  00001021   ADDU V0, ZERO, ZERO
45:                  
46:                     /* Make sure to add in space for line pointers */
47:                     bitmap = malloc(sizeof(bitmap_t) + (sizeof(uint8 *) * height));
9D035660  24E40005   ADDIU A0, A3, 5
9D035664  0F40DDB7   JAL _my_malloc
9D035668  00042080   SLL A0, A0, 2
48:                     if (NULL == bitmap)
9D03566C  10400022   BEQ V0, ZERO, 0x9D0356F8
9D035670  00122040   SLL A0, S2, 1
49:                        return NULL;
9D0356F8  00001021   ADDU V0, ZERO, ZERO
50:                  
51:                     bitmap->hardware = hw;
9D035674  AC53000C   SW S3, 12(V0)
52:                     bitmap->height = height;
9D035678  AC500004   SW S0, 4(V0)
53:                     bitmap->width = width;
9D03567C  AC540000   SW S4, 0(V0)
54:                     bitmap->data = data_addr;
9D035680  AC510010   SW S1, 16(V0)
55:                     bitmap->pitch = pitch + (overdraw * 2);
9D035684  8FA30038   LW V1, 56(SP)
9D035688  00831821   ADDU V1, A0, V1
56:                  
57:                     /* Set up line pointers */
58:                     /* we want to make some 32-bit aligned adjustment
59:                     ** if we haven't been given a hardware bitmap
60:                     */
61:                     if (false == bitmap->hardware)
9D03568C  16600009   BNE S3, ZERO, 0x9D0356B4
9D035690  AC430008   SW V1, 8(V0)
62:                     {
63:                        bitmap->pitch = (bitmap->pitch + 3) & ~3;
9D035694  24630003   ADDIU V1, V1, 3
9D035698  7C030804   INS V1, ZERO, 0, 2
9D03569C  AC430008   SW V1, 8(V0)
64:                        bitmap->line[0] = (uint8 *) (((uint32) bitmap->data + overdraw + 3) & ~3);
9D0356A0  26520003   ADDIU S2, S2, 3
9D0356A4  02328821   ADDU S1, S1, S2
9D0356A8  7C110804   INS S1, ZERO, 0, 2
9D0356AC  0B40D5AF   J 0x9D0356BC
9D0356B0  AC510014   SW S1, 20(V0)
65:                     }
66:                     else
67:                     { 
68:                        bitmap->line[0] = bitmap->data + overdraw;
9D0356B4  02328821   ADDU S1, S1, S2
9D0356B8  AC510014   SW S1, 20(V0)
69:                     }
70:                  
71:                     for (i = 1; i < height; i++)
9D0356BC  2A030002   SLTI V1, S0, 2
9D0356C0  1460000E   BNE V1, ZERO, 0x9D0356FC
9D0356C4  00401821   ADDU V1, V0, ZERO
9D0356DC  24840001   ADDIU A0, A0, 1
9D0356E0  1490FFFB   BNE A0, S0, 0x9D0356D0
9D0356E4  24630004   ADDIU V1, V1, 4
9D0356E8  0B40D5C0   J 0x9D035700
9D0356EC  8FBF0024   LW RA, 36(SP)
72:                        bitmap->line[i] = bitmap->line[i - 1] + bitmap->pitch;
9D0356C8  8C460008   LW A2, 8(V0)
9D0356CC  24040001   ADDIU A0, ZERO, 1
9D0356D0  8C650014   LW A1, 20(V1)
9D0356D4  00A62821   ADDU A1, A1, A2
9D0356D8  AC650018   SW A1, 24(V1)
73:                  
74:                     return bitmap;
75:                  }
9D0356FC  8FBF0024   LW RA, 36(SP)
9D035700  8FB40020   LW S4, 32(SP)
9D035704  8FB3001C   LW S3, 28(SP)
9D035708  8FB20018   LW S2, 24(SP)
9D03570C  8FB10014   LW S1, 20(SP)
9D035710  8FB00010   LW S0, 16(SP)
9D035714  03E00008   JR RA
9D035718  27BD0028   ADDIU SP, SP, 40
76:                  
77:                  /* Allocate and initialize a bitmap structure */
78:                  bitmap_t *bmp_create(int width, int height, int overdraw)
79:                  {
9D035744  27BDFFD8   ADDIU SP, SP, -40
9D035748  AFBF0024   SW RA, 36(SP)
9D03574C  AFB20020   SW S2, 32(SP)
9D035750  AFB1001C   SW S1, 28(SP)
9D035754  AFB00018   SW S0, 24(SP)
9D035758  00808021   ADDU S0, A0, ZERO
9D03575C  00A08821   ADDU S1, A1, ZERO
9D035760  00C09021   ADDU S2, A2, ZERO
80:                     uint8 *addr;
81:                     int pitch;
82:                  
83:                     pitch = width + (overdraw * 2); /* left and right */
9D035764  00062040   SLL A0, A2, 1
9D035768  00902021   ADDU A0, A0, S0
84:                     addr = malloc((pitch * height) + 3); /* add max 32-bit aligned adjustment */
9D03576C  70852002   MUL A0, A0, A1
9D035770  0F40DDB7   JAL _my_malloc
9D035774  24840003   ADDIU A0, A0, 3
85:                     if (NULL == addr)
9D035778  10400009   BEQ V0, ZERO, 0x9D0357A0
9D03577C  00402021   ADDU A0, V0, ZERO
86:                        return NULL;
9D0357A0  00001021   ADDU V0, ZERO, ZERO
87:                  
88:                     return _make_bitmap(addr, false, width, height, width, overdraw);
9D035780  AFB00010   SW S0, 16(SP)
9D035784  AFB20014   SW S2, 20(SP)
9D035788  00002821   ADDU A1, ZERO, ZERO
9D03578C  02003021   ADDU A2, S0, ZERO
9D035790  0F40D58B   JAL .Letext0, .LFE1, .LFB6, _make_bitmap, .Ltext0
9D035794  02203821   ADDU A3, S1, ZERO
9D035798  0B40D5EA   J 0x9D0357A8
9D03579C  8FBF0024   LW RA, 36(SP)
89:                  }
9D0357A4  8FBF0024   LW RA, 36(SP)
9D0357A8  8FB20020   LW S2, 32(SP)
9D0357AC  8FB1001C   LW S1, 28(SP)
9D0357B0  8FB00018   LW S0, 24(SP)
9D0357B4  03E00008   JR RA
9D0357B8  27BD0028   ADDIU SP, SP, 40
90:                  
91:                  /* allocate and initialize a hardware bitmap */
92:                  bitmap_t *bmp_createhw(uint8 *addr, int width, int height, int pitch)
93:                  {
9D0357BC  27BDFFE0   ADDIU SP, SP, -32
9D0357C0  AFBF001C   SW RA, 28(SP)
9D0357C4  00A01821   ADDU V1, A1, ZERO
9D0357C8  00C01021   ADDU V0, A2, ZERO
94:                     return _make_bitmap(addr, true, width, height, pitch, 0); /* zero overdraw */
9D0357CC  AFA70010   SW A3, 16(SP)
9D0357D0  AFA00014   SW ZERO, 20(SP)
9D0357D4  24050001   ADDIU A1, ZERO, 1
9D0357D8  00603021   ADDU A2, V1, ZERO
9D0357DC  0F40D58B   JAL .Letext0, .LFE1, .LFB6, _make_bitmap, .Ltext0
9D0357E0  00403821   ADDU A3, V0, ZERO
95:                  }
9D0357E4  8FBF001C   LW RA, 28(SP)
9D0357E8  03E00008   JR RA
9D0357EC  27BD0020   ADDIU SP, SP, 32
96:                  
97:                  /* Deallocate space for a bitmap structure */
98:                  void bmp_destroy(bitmap_t **bitmap)
99:                  {
9D0357F0  27BDFFE8   ADDIU SP, SP, -24
9D0357F4  AFBF0014   SW RA, 20(SP)
9D0357F8  AFB00010   SW S0, 16(SP)
9D0357FC  00808021   ADDU S0, A0, ZERO
100:                    if (*bitmap)
9D035800  8C840000   LW A0, 0(A0)
9D035804  5080000D   BEQL A0, ZERO, 0x9D03583C
9D035808  8FBF0014   LW RA, 20(SP)
101:                    {
102:                       if ((*bitmap)->data && false == (*bitmap)->hardware)
9D03580C  8C830010   LW V1, 16(A0)
9D035810  10600006   BEQ V1, ZERO, .LVL34
9D035814  00000000   NOP
9D035818  8C83000C   LW V1, 12(A0)
9D03581C  14600003   BNE V1, ZERO, .LVL34
9D035820  00000000   NOP
103:                          free((*bitmap)->data);
9D035824  0F40DDCA   JAL _my_free
9D035828  24840010   ADDIU A0, A0, 16
104:                       free(*bitmap);
9D03582C  0F40DDCA   JAL _my_free
9D035830  02002021   ADDU A0, S0, ZERO
105:                       *bitmap = NULL;
9D035834  AE000000   SW ZERO, 0(S0)
106:                    }
107:                 }
9D035838  8FBF0014   LW RA, 20(SP)
9D03583C  8FB00010   LW S0, 16(SP)
9D035840  03E00008   JR RA
9D035844  27BD0018   ADDIU SP, SP, 24
108:                 
109:                 /*
110:                 ** $Log: bitmap.c,v $
111:                 ** Revision 1.2  2001/04/27 14:37:11  neil
112:                 ** wheeee
113:                 **
114:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
115:                 ** initial
116:                 **
117:                 ** Revision 1.16  2000/11/05 16:37:18  matt
118:                 ** rolled rgb.h into bitmap.h
119:                 **
120:                 ** Revision 1.15  2000/10/10 13:58:13  matt
121:                 ** stroustrup squeezing his way in the door
122:                 **
123:                 ** Revision 1.14  2000/09/18 02:06:48  matt
124:                 ** -pedantic is your friend
125:                 **
126:                 ** Revision 1.13  2000/08/13 13:16:30  matt
127:                 ** bugfix for alignment adjustment
128:                 **
129:                 ** Revision 1.12  2000/07/24 04:31:43  matt
130:                 ** pitch/data area on non-hw bitmaps get padded to 32-bit boundaries
131:                 **
132:                 ** Revision 1.11  2000/07/17 01:52:27  matt
133:                 ** made sure last line of all source files is a newline
134:                 **
135:                 ** Revision 1.10  2000/07/09 14:43:01  matt
136:                 ** pitch is now configurable for bmp_createhw()
137:                 **
138:                 ** Revision 1.9  2000/07/06 17:55:57  matt
139:                 ** two big bugs fixed
140:                 **
141:                 ** Revision 1.8  2000/07/06 17:38:11  matt
142:                 ** replaced missing string.h include
143:                 **
144:                 ** Revision 1.7  2000/07/06 16:46:57  matt
145:                 ** added bmp_clear() routine
146:                 **
147:                 ** Revision 1.6  2000/06/26 04:56:24  matt
148:                 ** minor cleanup
149:                 **
150:                 ** Revision 1.5  2000/06/09 15:12:25  matt
151:                 ** initial revision
152:                 **
153:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/main.c  ---------------------------------------------
1:                   #include <xc.h>
2:                   #include "badge_settings.h"
3:                   #include "badge.h"
4:                   #include "hw.h"
5:                   #include "post.h"
6:                   #include "nofrendo/nofrendo.h"
7:                   
8:                   int16_t main(void)
9:                   {
9D03C690  27BDFFE8   ADDIU SP, SP, -24
9D03C694  AFBF0014   SW RA, 20(SP)
10:                      int i;
11:                  	hw_init();
9D03C698  0F407BDB   JAL hw_init
9D03C69C  00000000   NOP
12:                  	badge_init();
9D03C6A0  0F407019   JAL badge_init
9D03C6A4  00000000   NOP
13:                      nofrendo_main(0, NULL);
9D03C6A8  00002021   ADDU A0, ZERO, ZERO
9D03C6AC  0F40CE52   JAL nofrendo_main
9D03C6B0  00002821   ADDU A1, ZERO, ZERO
9D03C6B4  0B40F1AD   J .LVL2
9D03C6B8  00000000   NOP
14:                  	//if (KEY_BRK==0) post();
15:                  	//if ((SHOW_SPLASH)&(K_SHIFTR==1)) boot_animation();
16:                  	//badge_menu();
17:                  	while (1)
18:                      {
19:                          //tft_fill_area(0,0,320,240,CIPHER_BACKGROUND);
20:                          //wait_ms(1000);
21:                          //tft_fill_area(0,0,320,240,CIPHER_CURSOR);
22:                          //wait_ms(1000);
23:                      }
24:                  }
25:                  
26:                  
27:                  
28:                  
29:                  
30:                  /*
31:                   * Interesting places to take look at, in MPLABX use CtrlCtrl+Shift+F to search in all files
32:                   * for those "bookmarks"
33:                   * 
34:                   * ----------------badge stuff----------------
35:                   * After reset, badge checks whether BRK key is pressed. In case it is, test routine starts, see
36:                   * B_BDG001
37:                   * If not, B_BDG002 is the place to jump. Welcome screen is painstakingly drawn via lot of setxy
38:                   * and print commands. Then it waits for user input. All interaction with user is done mainly via
39:                   * stdio functions, that can be redirected either to local screen or serial port, available on pins
40:                   * C13 and C14 of expansion port. There is also stdio buffer that can be written from software, 
41:                   * for specific purposes
42:                   * The four stdio functions are under B_BDG003
43:                   *
44:                   * For this badge, I opted to refresh display from interrupt handler linked to timer5, set to fire
45:                   * every 12ms - B_BDG003. This is heartbeat of badge, where both partial display refresh (two 
46:                   * lines at once) and keyboard scanning tasks do take place. Notice, one can disable refreshing 
47:                   * the display if needed via function B_BDG004 or manipulating the variable handle_display 
48:                   * directly. Timer 1 runs with 1ms period, and increments variable ticks, available via function
49:                   * millis().
50:                   * 
51:                   * User can write its own programs to be incorporated within "big firmware" of badge, see B_BDG006
52:                   * and B_BDG007 and B_BDG008. Badge can be turned on or off via power button. This erases display.
53:                   * Since badge doesn't have graphic framebuffer (it has terminal text buffer though), the user should 
54:                   * refresh the display in appropriate function, set up via function pointer, see B_BDG005 and B_BDG009
55:                   * Currently, there is about 16kB of RAM and 45kB of FLASH free to use for user
56:                   * If some CP/M features are disabled, see B_BDG010, user can gain additional quarter of megabyte of 
57:                   * FLASH space and about 22kB of RAM.
58:                   * 
59:                   * Other than that, simple firmware skeleton will be provided too, so user doesn't need to use
60:                   * software infrastructure of badge firmware, with all its dependencies; uncovering full hardware 
61:                   * potential of badge.
62:                   * 
63:                   * 
64:                   * ----------------BASIC interpreter----------------
65:                   * 
66:                   * B_BAS001: This is where BASIC tokens are defined, have you want to add your word, add one
67:                   * into this list, then go to B_BAS002 to define appropriate action. Of course, don't forget
68:                   * to add the token number into list in B_BAS003
69:                   * This way you can make words like LED, invoked as LED 2,1
70:                   * If you want to add word returning value like RND in form of LET A = RND 10, take a look how it's
71:                   * made in B_BAS004
72:                   * 
73:                   * A lot of things around BASIC happens outside the interpreter itself. After invoking BASIC, the first
74:                   * function to be called is B_BAS005 where everything is set to run BASIC loop in B_BAS006
75:                   * It basically (no pun intended) collects users input and once buffer si full, it is sent to decide what 
76:                   * it is - B_BAS007
77:                   * If it appears to be valid line of BASIC program, including line number, it goes to be added to
78:                   * current program B_BAS008
79:                   * If not, program flows through series of comparisons to determine whether the thing that user wrote is 
80:                   * something from a few commands that command interpreter can execute. One of them is RUN that sets up 
81:                   * interpreter in B_BAS009 and runs main loop in B_BAS010.
82:                   * Program buffer is set to 16kB, so you can't have programs longer than that. You may redefine buffer 
83:                   * length (see badge_settings.h), you may want to check save/load routines, see B_BAS011
84:                   * 
85:                   * 
86:                   * 
87:                   * ----------------CP/M machine----------------
88:                   * 
89:                   * This one runs on Z80 interpreter, written by Udo Munk. It is directory /Z80, along with two other files,
90:                   * defining memory and hardware configuration of this virtual machine, files hwz.c and iosim.c
91:                   * 
92:                   * iosim.c defines the memory map. I wrote the BIOS for CP/M machine to be extremely simple, with more 
93:                   * automation and intelligence on software side, not achievable with classic hardware means. For example,
94:                   * writing to address 0xFF triggers CP/M system reload. so BIOS hook can be as simple as writing single byte 
95:                   * into this address. Classic BIOS needed a lot of more Z80 instructions to achieve th same.
96:                   * On address 0x68 (+0x6D) is implemented simple UART, linked to UART3 of badge (available on C13 and C14 of
97:                   * expansion port). This UART is utilized in XMODEM program (available at drive B:), so user can transfer 
98:                   * CP/M binaries from PC via any compatible Xmodem terminal. I used moserial and cutecom in linux, or teraterm
99:                   * in windows.
100:                  * CP/M machine is setup to use six different drives:
101:                  * A: - 22kB in size, RAM disk. Fast, no wearout, ideal for temporary storage. Trashed on reboot.
102:                  * B: - 128kB ROM disk, contains a lot of goodies. You could pack a lot of software into 128kB then.
103:                  * C: - 128kB ROM dosk, contains Zork and Sargon. You know, games.
104:                  * D: - 512kB FLASH disk, free for your use
105:                  * hwz.c contains all stuff to access disks and devices of CP/M machine, like disk byte read and write
106:                  * functions, called directly by BIOS via addresses 0x07 and 0x08, with 0x05 and 0x06 setting track and
107:                  * sector of drive selected via 0x04.
108:                  *
109:                  * CP/M defines some standard IO devices - reader, puncher for your punch cards and list device to print 
110:                  * out your program listings. Those are not implemented in badge hardware iosim.c, see B_CPM001 and B_CPM002
111:                  * If defined, you can - for example - list files directly from CP/M via virtual printer, or make virtual
112:                  * punch card reader/puncher to EEPROM, thumb drive, PC, FTP server via ESP32 or anything you can connect 
113:                  * to bitbanged interface on badge expansion port.
114:                  * 
115:                  */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/hw.c  -----------------------------------------------
1:                   #include <xc.h>
2:                   #include "hw.h"
3:                   #include "Z80/hwz.h"
4:                   #include <plib.h>
5:                   #include <peripheral/pps.h>
6:                   #include <stdint.h>
7:                   
8:                   // DEVCFG3
9:                   // USERID = No Setting
10:                  #pragma config FSRSSEL = PRIORITY_7     // Shadow Register Set Priority Select (SRS Priority 7)
11:                  #pragma config PMDL1WAY = OFF           // Peripheral Module Disable Configuration (Allow multiple reconfigurations)
12:                  #pragma config IOL1WAY = OFF            // Peripheral Pin Select Configuration (Allow multiple reconfigurations)
13:                  
14:                  // DEVCFG2
15:                  #pragma config FPLLIDIV = DIV_1//DIV_2         // PLL Input Divider (2x Divider)
16:                  #pragma config FPLLMUL = MUL_15//MUL_24         // PLL Multiplier (24x Multiplier)
17:                  #pragma config FPLLODIV = DIV_1//DIV_2         // System PLL Output Clock Divider (PLL Divide by 2)
18:                  
19:                  // DEVCFG1
20:                  #pragma config FNOSC = FRCPLL           // Oscillator Selection Bits (Fast RC Osc with PLL)
21:                  #pragma config FSOSCEN = OFF            // Secondary Oscillator Enable (Disabled)
22:                  #pragma config IESO = ON                // Internal/External Switch Over (Enabled)
23:                  #pragma config POSCMOD = OFF            // Primary Oscillator Configuration (Primary osc disabled)
24:                  #pragma config OSCIOFNC = OFF           // CLKO Output Signal Active on the OSCO Pin (Disabled)
25:                  #pragma config FPBDIV = DIV_1           // Peripheral Clock Divisor (Pb_Clk is Sys_Clk/1)
26:                  #pragma config FCKSM = CSDCMD           // Clock Switching and Monitor Selection (Clock Switch Disable, FSCM Disabled)
27:                  #pragma config WDTPS = PS1048576        // Watchdog Timer Postscaler (1:1048576)
28:                  #pragma config WINDIS = OFF             // Watchdog Timer Window Enable (Watchdog Timer is in Non-Window Mode)
29:                  #pragma config FWDTEN = OFF             // Watchdog Timer Enable (WDT Disabled (SWDTEN Bit Controls))
30:                  #pragma config FWDTWINSZ = WINSZ_25     // Watchdog Timer Window Size (Window Size is 25%)
31:                  
32:                  // DEVCFG0
33:                  #pragma config DEBUG = OFF              // Background Debugger Enable (Debugger is Disabled)
34:                  #pragma config JTAGEN = OFF             // JTAG Enable (JTAG Disabled)
35:                  #pragma config ICESEL = ICS_PGx1        // ICE/ICD Comm Channel Select (Communicate on PGEC1/PGED1)
36:                  #pragma config PWP = OFF                // Program Flash Write Protect (Disable)
37:                  #pragma config BWP = OFF                // Boot Flash Write Protect bit (Protection Disabled)
38:                  #pragma config CP = OFF                 // Code Protect (Protection Disabled)
39:                  
40:                  uint8_t key_state=0,key_last,key,led_state=0;
41:                  uint16_t rnd_var1,rnd_var2,rnd_var3;
42:                  
43:                  const int8_t keys_normal[50] = 
44:                  	{
45:                  	'3','4','2','5','1','9','6','7','0','8',
46:                  	'e','r','w','t','q','o','y','u','p','i',
47:                  	's','d','a','f','/','k','g','h','l','j',
48:                  	'x','c','z','v',' ',0x2c,'b','n','.','m',
49:                  	K_DN,K_RT,K_LT,';',K_UP,K_DEL,'=',K_ENT,BACKSPACE,'-',
50:                  	};
51:                  
52:                  const int8_t keys_shift_l[50] = 
53:                  	{
54:                  	'#','$','@','%','!','(',' ','&',')','*',
55:                  	'E','R','W','T','Q','O','Y','U','P','I',
56:                  	'S','D','A','F','?','K','G','H','L','J',
57:                  	'X','C','Z','V',' ','<','B','N','>','M',
58:                  	K_DN,K_RT,K_LT,':',K_UP,K_DEL,'+',K_ECR,BACKSPACE,'"',
59:                  	};
60:                  const int8_t keys_shift_r[50] = 
61:                  	{
62:                  	'#','$','@','%','!','(',' ','&',')','*',
63:                  	'E','R','W','T','Q','O','Y','U','P','I',
64:                  	'S','D','A','F','?','K','G','H','L','J',
65:                  	'X','C','Z','V',' ','<','B','N','>','M',
66:                  	K_DN,K_RT,K_LT,':',K_UP,K_DEL,'+',K_ECR,BACKSPACE,'_',
67:                  	};
68:                  
69:                  int8_t key_char;
70:                  
71:                  
72:                  const uint16_t tone_pr_table[128] = 
73:                  	{
74:                  	0, //No Note
75:                  	/* Sacrifice this for 0 to be 'no note' 366927, // 0 | C-1 | 8.176Hz */
76:                  	/* Lowest notes have timer values too big for uint16_t so setting to 0 as workaround*/
77:                  	0, //346340, // 1 | C?/D?-1 | 8.662Hz
78:                  	0, //326904, // 2 | D-1 | 9.177Hz
79:                  	0, //308546, // 3 | E?/D?-1 | 9.723Hz
80:                  	0, //291233, // 4 | E-1 | 10.301Hz
81:                  	0, //274876, // 5 | F-1 | 10.914Hz
82:                  	0, //259448, // 6 | F?/G?-1 | 11.563Hz
83:                  	0, //244897, // 7 | G-1 | 12.25Hz
84:                  	0, //231142, // 8 | A?/G?-1 | 12.979Hz
85:                  	0, //218181, // 9 | A-1 | 13.75Hz
86:                  	0, //205930, // 10 | B?/A?-1 | 14.568Hz
87:                  	0, //194376, // 11 | B-1 | 15.434Hz
88:                  	0, //183463, // 12 | C0 | 16.352Hz
89:                  	0, //173170, // 13 | C?/D?0 | 17.324Hz
90:                  	0, //163452, // 14 | D0 | 18.354Hz
91:                  	0, //154281, // 15 | E?/D?0 | 19.445Hz
92:                  	0, //145616, // 16 | E0 | 20.602Hz
93:                  	0, //137444, // 17 | F0 | 21.827Hz
94:                  	0, //129729, // 18 | F?/G?0 | 23.125Hz
95:                  	0, //122448, // 19 | G0 | 24.5Hz
96:                  	0, //115575, // 20 | A?/G?0 | 25.957Hz
97:                  	0, //109090, // 21 | A0 | 27.5Hz
98:                  	0, //102968, // 22 | B?/A?0 | 29.135Hz
99:                  	0, //97188, // 23 | B0 | 30.868Hz
100:                 	0, //91734, // 24 | C1 | 32.703Hz
101:                 	0, //86585, // 25 | C?/D?1 | 34.648Hz
102:                 	0, //81726, // 26 | D1 | 36.708Hz
103:                 	0, //77138, // 27 | E?/D?1 | 38.891Hz
104:                 	0, //72810, // 28 | E1 | 41.203Hz
105:                 	0, //68722, // 29 | F1 | 43.654Hz
106:                 	64866, // 30 | F?/G?1 | 46.249Hz
107:                 	61225, // 31 | G1 | 48.999Hz
108:                 	57788, // 32 | A?/G?1 | 51.913Hz
109:                 	54545, // 33 | A1 | 55.0Hz
110:                 	51484, // 34 | B?/A?1 | 58.27Hz
111:                 	48594, // 35 | B1 | 61.735Hz
112:                 	45867, // 36 | C2 | 65.406Hz
113:                 	43292, // 37 | C?/D?2 | 69.296Hz
114:                 	40863, // 38 | D2 | 73.416Hz
115:                 	38569, // 39 | E?/D?2 | 77.782Hz
116:                 	36404, // 40 | E2 | 82.407Hz
117:                 	34361, // 41 | F2 | 87.307Hz
118:                 	32432, // 42 | F?/G?2 | 92.499Hz
119:                 	30612, // 43 | G2 | 97.999Hz
120:                 	28893, // 44 | A?/G?2 | 103.83Hz
121:                 	27272, // 45 | A2 | 110.0Hz
122:                 	25742, // 46 | B?/A?2 | 116.54Hz
123:                 	24297, // 47 | B2 | 123.47Hz
124:                 	22934, // 48 | C3 | 130.81Hz
125:                 	21646, // 49 | C?/D?3 | 138.59Hz
126:                 	20431, // 50 | D3 | 146.83Hz
127:                 	19285, // 51 | E?/D?3 | 155.56Hz
128:                 	18202, // 52 | E3 | 164.81Hz
129:                 	17181, // 53 | F3 | 174.61Hz
130:                 	16216, // 54 | F?/G?3 | 185.0Hz
131:                 	15306, // 55 | G3 | 196.0Hz
132:                 	14447, // 56 | A?/G?3 | 207.65Hz
133:                 	13636, // 57 | A3 | 220.0Hz
134:                 	12871, // 58 | B?/A?3 | 233.08Hz
135:                 	12148, // 59 | B3 | 246.94Hz
136:                 	11466, // 60 | C4 | 261.63Hz
137:                 	10823, // 61 | C?/D?4 | 277.18Hz
138:                 	10215, // 62 | D4 | 293.66Hz
139:                 	9642, // 63 | E?/D?4 | 311.13Hz
140:                 	9101, // 64 | E4 | 329.63Hz
141:                 	8590, // 65 | F4 | 349.23Hz
142:                 	8108, // 66 | F?/G?4 | 369.99Hz
143:                 	7653, // 67 | G4 | 392.0Hz
144:                 	7223, // 68 | A?/G?4 | 415.3Hz
145:                 	6818, // 69 | A4 | 440.0Hz
146:                 	6435, // 70 | B?/A?4 | 466.16Hz
147:                 	6074, // 71 | B4 | 493.88Hz
148:                 	5733, // 72 | C5 | 523.25Hz
149:                 	5411, // 73 | C?/D?5 | 554.37Hz
150:                 	5107, // 74 | D5 | 587.33Hz
151:                 	4821, // 75 | E?/D?5 | 622.25Hz
152:                 	4550, // 76 | E5 | 659.26Hz
153:                 	4295, // 77 | F5 | 698.46Hz
154:                 	4054, // 78 | F?/G?5 | 739.99Hz
155:                 	3826, // 79 | G5 | 783.99Hz
156:                 	3611, // 80 | A?/G?5 | 830.61Hz
157:                 	3409, // 81 | A5 | 880.0Hz
158:                 	3217, // 82 | B?/A?5 | 932.33Hz
159:                 	3037, // 83 | B5 | 987.77Hz
160:                 	2866, // 84 | C6 | 1046.5Hz
161:                 	2705, // 85 | C?/D?6 | 1108.7Hz
162:                 	2553, // 86 | D6 | 1174.7Hz
163:                 	2410, // 87 | E?/D?6 | 1244.5Hz
164:                 	2275, // 88 | E6 | 1318.5Hz
165:                 	2147, // 89 | F6 | 1396.9Hz
166:                 	2027, // 90 | F?/G?6 | 1480.0Hz
167:                 	1913, // 91 | G6 | 1568.0Hz
168:                 	1805, // 92 | A?/G?6 | 1661.2Hz
169:                 	1704, // 93 | A6 | 1760.0Hz
170:                 	1608, // 94 | B?/A?6 | 1864.7Hz
171:                 	1518, // 95 | B6 | 1975.5Hz
172:                 	1433, // 96 | C7 | 2093.0Hz
173:                 	1352, // 97 | C?/D?7 | 2217.5Hz
174:                 	1276, // 98 | D7 | 2349.3Hz
175:                 	1205, // 99 | E?/D?7 | 2489.0Hz
176:                 	1137, // 100 | E7 | 2637.0Hz
177:                 	1073, // 101 | F7 | 2793.8Hz
178:                 	1013, // 102 | F?/G?7 | 2960.0Hz
179:                 	956, // 103 | G7 | 3136.0Hz
180:                 	902, // 104 | A?/G?7 | 3322.4Hz
181:                 	852, // 105 | A7 | 3520.0Hz
182:                 	804, // 106 | B?/A?7 | 3729.3Hz
183:                 	759, // 107 | B7 | 3951.1Hz
184:                 	716, // 108 | C8 | 4186.0Hz
185:                 	676, // 109 | C?/D?8 | 4434.9Hz
186:                 	638, // 110 | D8 | 4698.6Hz
187:                 	602, // 111 | E?/D?8 | 4978.0Hz
188:                 	568, // 112 | E8 | 5274.0Hz
189:                 	536, // 113 | F8 | 5587.7Hz
190:                 	506, // 114 | F?/G?8 | 5919.9Hz
191:                 	478, // 115 | G8 | 6271.9Hz
192:                 	451, // 116 | A?/G?8 | 6644.9Hz
193:                 	426, // 117 | A8 | 7040.0Hz
194:                 	402, // 118 | B?/A?8 | 7458.6Hz
195:                 	379, // 119 | B8 | 7902.1Hz
196:                 	358, // 120 | C9 | 8372.0Hz
197:                 	338, // 121 | C?/D?9 | 8869.8Hz
198:                 	319, // 122 | D9 | 9397.3Hz
199:                 	301, // 123 | E?/D?9 | 9956.1Hz
200:                 	284, // 124 | E9 | 10548.1Hz
201:                 	268, // 125 | F9 | 11175.3Hz
202:                 	253, // 126 | F?/G?9 | 11839.8Hz
203:                 	239, // 127 | G9 | 12543.9Hz
204:                 	};
205:                 
206:                 uint8_t get_led_word(void)
207:                 	{
208:                 	uint8_t retval = 0;
9D01ECE8  7C420180   EXT V0, V0, 6, 1
209:                 	if (LED_R) retval = retval | 0x01;
9D01ECE0  3C02BF88   LUI V0, -16504
9D01ECE4  8C426330   LW V0, 25392(V0)
210:                 	if (LED_G) retval = retval | 0x02;
9D01ECEC  3C03BF88   LUI V1, -16504
9D01ECF0  8C636530   LW V1, 25904(V1)
9D01ECF4  30630002   ANDI V1, V1, 2
9D01ECF8  10600003   BEQ V1, ZERO, 0x9D01ED08
9D01ECFC  3C03BF88   LUI V1, -16504
9D01ED00  34420002   ORI V0, V0, 2
9D01ED04  304200FF   ANDI V0, V0, 255
211:                 	if (LED_B) retval = retval | 0x04;
9D01ED08  8C646330   LW A0, 25392(V1)
9D01ED0C  30840080   ANDI A0, A0, 128
9D01ED10  34430004   ORI V1, V0, 4
212:                 	return retval;
213:                 	}
9D01ED14  03E00008   JR RA
9D01ED18  0064100B   MOVN V0, V1, A0
214:                 
215:                 void set_led_word (uint8_t val)
216:                 	{
217:                 	if (val&0x01) LED_R = 1;
9D01ED1C  30820001   ANDI V0, A0, 1
9D01ED20  10400007   BEQ V0, ZERO, 0x9D01ED40
9D01ED24  3C02BF88   LUI V0, -16504
9D01ED28  94436330   LHU V1, 25392(V0)
9D01ED2C  24050001   ADDIU A1, ZERO, 1
9D01ED30  7CA33184   INS V1, A1, 6, 1
9D01ED34  A4436330   SH V1, 25392(V0)
9D01ED38  0B407B54   J 0x9D01ED50
9D01ED3C  30820002   ANDI V0, A0, 2
218:                 		else LED_R = 0;
9D01ED40  94436330   LHU V1, 25392(V0)
9D01ED44  7C033184   INS V1, ZERO, 6, 1
9D01ED48  A4436330   SH V1, 25392(V0)
219:                 	if (val&0x02) LED_G = 1;
9D01ED4C  30820002   ANDI V0, A0, 2
9D01ED50  304200FF   ANDI V0, V0, 255
9D01ED54  10400007   BEQ V0, ZERO, 0x9D01ED74
9D01ED58  3C02BF88   LUI V0, -16504
9D01ED5C  90436530   LBU V1, 25904(V0)
9D01ED60  24050001   ADDIU A1, ZERO, 1
9D01ED64  7CA30844   INS V1, A1, 1, 1
9D01ED68  A0436530   SB V1, 25904(V0)
9D01ED6C  0B407B61   J 0x9D01ED84
9D01ED70  30840004   ANDI A0, A0, 4
220:                 		else LED_G = 0;
9D01ED74  90436530   LBU V1, 25904(V0)
9D01ED78  7C030844   INS V1, ZERO, 1, 1
9D01ED7C  A0436530   SB V1, 25904(V0)
221:                 	if (val&0x04) LED_B = 1;
9D01ED80  30840004   ANDI A0, A0, 4
9D01ED84  308400FF   ANDI A0, A0, 255
9D01ED88  10800007   BEQ A0, ZERO, 0x9D01EDA8
9D01ED8C  3C02BF88   LUI V0, -16504
9D01ED90  94436330   LHU V1, 25392(V0)
9D01ED94  24040001   ADDIU A0, ZERO, 1
9D01ED98  7C8339C4   INS V1, A0, 7, 1
9D01ED9C  A4436330   SH V1, 25392(V0)
9D01EDA0  03E00008   JR RA
9D01EDA4  00000000   NOP
222:                 		else LED_B = 0;
9D01EDA8  94436330   LHU V1, 25392(V0)
9D01EDAC  7C0339C4   INS V1, ZERO, 7, 1
9D01EDB0  A4436330   SH V1, 25392(V0)
9D01EDB4  03E00008   JR RA
9D01EDB8  00000000   NOP
223:                 	}
224:                 
225:                 void set_led (uint8_t led_n, uint8_t led_v)
226:                 	{
227:                 	if (led_n==0)
9D01EDBC  14800007   BNE A0, ZERO, 0x9D01EDDC
9D01EDC0  24020001   ADDIU V0, ZERO, 1
228:                 		LED_R = led_v;
9D01EDC4  3C02BF88   LUI V0, -16504
9D01EDC8  94436330   LHU V1, 25392(V0)
9D01EDCC  7CA33184   INS V1, A1, 6, 1
9D01EDD0  A4436330   SH V1, 25392(V0)
9D01EDD4  03E00008   JR RA
9D01EDD8  00000000   NOP
229:                 	if (led_n==1)
9D01EDDC  14820006   BNE A0, V0, 0x9D01EDF8
9D01EDE0  3C02BF88   LUI V0, -16504
230:                 		LED_G = led_v;	
9D01EDE4  90436530   LBU V1, 25904(V0)
9D01EDE8  7CA30844   INS V1, A1, 1, 1
9D01EDEC  A0436530   SB V1, 25904(V0)
9D01EDF0  03E00008   JR RA
9D01EDF4  00000000   NOP
231:                 	if (led_n==2)
9D01EDF8  24020002   ADDIU V0, ZERO, 2
9D01EDFC  1482FFF5   BNE A0, V0, 0x9D01EDD4
9D01EE00  3C02BF88   LUI V0, -16504
232:                 		LED_B = led_v;	
9D01EE04  94436330   LHU V1, 25392(V0)
9D01EE08  7CA339C4   INS V1, A1, 7, 1
9D01EE0C  A4436330   SH V1, 25392(V0)
9D01EE10  03E00008   JR RA
9D01EE14  00000000   NOP
233:                 	}
234:                 
235:                 void sound_play_notes (uint8_t note1, uint8_t note2, uint8_t note3, uint16_t wait)
236:                 	{
9D01FB10  27BDFFD8   ADDIU SP, SP, -40
9D01FB14  AFBF0024   SW RA, 36(SP)
9D01FB18  AFB30020   SW S3, 32(SP)
9D01FB1C  AFB2001C   SW S2, 28(SP)
9D01FB20  AFB10018   SW S1, 24(SP)
9D01FB24  AFB00014   SW S0, 20(SP)
9D01FB28  00A09821   ADDU S3, A1, ZERO
9D01FB2C  00C09021   ADDU S2, A2, ZERO
9D01FB30  00E08821   ADDU S1, A3, ZERO
237:                 	IEC0bits.T5IE = 0;		//sound is a bit shaky without this
9D01FB34  3C10BF88   LUI S0, -16504
9D01FB38  8E021060   LW V0, 4192(S0)
9D01FB3C  7C02C604   INS V0, ZERO, 24, 1
9D01FB40  AE021060   SW V0, 4192(S0)
238:                 							//quick hack, needs more debugging
239:                 	sound_set_note(note1,0);
9D01FB44  0F407BD0   JAL sound_set_note
9D01FB48  00002821   ADDU A1, ZERO, ZERO
240:                 	sound_set_note(note2,1);
9D01FB4C  02602021   ADDU A0, S3, ZERO
9D01FB50  0F407BD0   JAL sound_set_note
9D01FB54  24050001   ADDIU A1, ZERO, 1
241:                 	sound_set_note(note3,2);
9D01FB58  02402021   ADDU A0, S2, ZERO
9D01FB5C  0F407BD0   JAL sound_set_note
9D01FB60  24050002   ADDIU A1, ZERO, 2
242:                 	wait_ms(wait);
9D01FB64  0F407EB3   JAL wait_ms
9D01FB68  02202021   ADDU A0, S1, ZERO
243:                 	sound_set_note(0,0);
9D01FB6C  00002021   ADDU A0, ZERO, ZERO
9D01FB70  0F407BD0   JAL sound_set_note
9D01FB74  00002821   ADDU A1, ZERO, ZERO
244:                 	sound_set_note(0,1);
9D01FB78  00002021   ADDU A0, ZERO, ZERO
9D01FB7C  0F407BD0   JAL sound_set_note
9D01FB80  24050001   ADDIU A1, ZERO, 1
245:                 	sound_set_note(0,2);
9D01FB84  00002021   ADDU A0, ZERO, ZERO
9D01FB88  0F407BD0   JAL sound_set_note
9D01FB8C  24050002   ADDIU A1, ZERO, 2
246:                 	IEC0bits.T5IE = 1;
9D01FB90  8E021060   LW V0, 4192(S0)
9D01FB94  24030001   ADDIU V1, ZERO, 1
9D01FB98  7C62C604   INS V0, V1, 24, 1
9D01FB9C  AE021060   SW V0, 4192(S0)
247:                 	}
9D01FBA0  8FBF0024   LW RA, 36(SP)
9D01FBA4  8FB30020   LW S3, 32(SP)
9D01FBA8  8FB2001C   LW S2, 28(SP)
9D01FBAC  8FB10018   LW S1, 24(SP)
9D01FBB0  8FB00014   LW S0, 20(SP)
9D01FBB4  03E00008   JR RA
9D01FBB8  27BD0028   ADDIU SP, SP, 40
248:                 
249:                 void sound_set_note (uint8_t note, uint8_t generator)
250:                 	{
9D01EF40  27BDFFE8   ADDIU SP, SP, -24
9D01EF44  AFBF0014   SW RA, 20(SP)
251:                 	sound_set_generator(tone_pr_table[note],generator);
9D01EF48  00042040   SLL A0, A0, 1
9D01EF4C  3C029D03   LUI V0, -25341
9D01EF50  244266BC   ADDIU V0, V0, 26300
9D01EF54  00822021   ADDU A0, A0, V0
9D01EF58  0F407B86   JAL sound_set_generator
9D01EF5C  94840000   LHU A0, 0(A0)
252:                 	}
9D01EF60  8FBF0014   LW RA, 20(SP)
9D01EF64  03E00008   JR RA
9D01EF68  27BD0018   ADDIU SP, SP, 24
253:                 
254:                 void sound_set_generator (uint16_t period, uint8_t generator)
255:                 	{
256:                 	if (generator==0)
9D01EE18  14A00018   BNE A1, ZERO, 0x9D01EE7C
9D01EE1C  24020001   ADDIU V0, ZERO, 1
257:                 		{
258:                 		T2CONbits.TON = 0;
9D01EE20  3C02BF80   LUI V0, -16512
9D01EE24  94430800   LHU V1, 2048(V0)
9D01EE28  7C037BC4   INS V1, ZERO, 15, 1
9D01EE2C  A4430800   SH V1, 2048(V0)
259:                 		PR2 = period;
9D01EE30  3C03BF80   LUI V1, -16512
9D01EE34  AC640820   SW A0, 2080(V1)
260:                 		T2CONbits.TCKPS = 0b011;
9D01EE38  94430800   LHU V1, 2048(V0)
9D01EE3C  24050003   ADDIU A1, ZERO, 3
9D01EE40  7CA33104   INS V1, A1, 4, 3
9D01EE44  A4430800   SH V1, 2048(V0)
261:                 		if (period!=0)
9D01EE48  50800007   BEQL A0, ZERO, 0x9D01EE68
9D01EE4C  3C02BF88   LUI V0, -16504
262:                 			T2CONbits.TON = 1;
9D01EE50  94430800   LHU V1, 2048(V0)
9D01EE54  24040001   ADDIU A0, ZERO, 1
9D01EE58  7C837BC4   INS V1, A0, 15, 1
9D01EE5C  A4430800   SH V1, 2048(V0)
9D01EE60  03E00008   JR RA
9D01EE64  00000000   NOP
263:                 		else
264:                 			GEN_0_PIN = 0;
9D01EE68  94436330   LHU V1, 25392(V0)
9D01EE6C  7C030844   INS V1, ZERO, 1, 1
9D01EE70  A4436330   SH V1, 25392(V0)
9D01EE74  03E00008   JR RA
9D01EE78  00000000   NOP
265:                 		}
266:                 	if (generator==1)
9D01EE7C  14A20017   BNE A1, V0, 0x9D01EEDC
9D01EE80  3C02BF80   LUI V0, -16512
267:                 		{
268:                 		T3CONbits.TON = 0;
9D01EE84  94430A00   LHU V1, 2560(V0)
9D01EE88  7C037BC4   INS V1, ZERO, 15, 1
9D01EE8C  A4430A00   SH V1, 2560(V0)
269:                 		PR3 = period;
9D01EE90  3C03BF80   LUI V1, -16512
9D01EE94  AC640A20   SW A0, 2592(V1)
270:                 		T3CONbits.TCKPS = 0b011;
9D01EE98  94430A00   LHU V1, 2560(V0)
9D01EE9C  24050003   ADDIU A1, ZERO, 3
9D01EEA0  7CA33104   INS V1, A1, 4, 3
9D01EEA4  A4430A00   SH V1, 2560(V0)
271:                 		if (period!=0)
9D01EEA8  50800007   BEQL A0, ZERO, 0x9D01EEC8
9D01EEAC  3C02BF88   LUI V0, -16504
272:                 			T3CONbits.TON = 1;
9D01EEB0  94430A00   LHU V1, 2560(V0)
9D01EEB4  24040001   ADDIU A0, ZERO, 1
9D01EEB8  7C837BC4   INS V1, A0, 15, 1
9D01EEBC  A4430A00   SH V1, 2560(V0)
9D01EEC0  03E00008   JR RA
9D01EEC4  00000000   NOP
273:                 		else
274:                 			GEN_1_PIN = 0;
9D01EEC8  94436330   LHU V1, 25392(V0)
9D01EECC  7C031084   INS V1, ZERO, 2, 1
9D01EED0  A4436330   SH V1, 25392(V0)
9D01EED4  03E00008   JR RA
9D01EED8  00000000   NOP
275:                 		}
276:                 	if (generator==2)
9D01EEDC  24020002   ADDIU V0, ZERO, 2
9D01EEE0  14A2FFDF   BNE A1, V0, 0x9D01EE60
9D01EEE4  3C02BF80   LUI V0, -16512
277:                 		{
278:                 		T4CONbits.TON = 0;
9D01EEE8  94430C00   LHU V1, 3072(V0)
9D01EEEC  7C037BC4   INS V1, ZERO, 15, 1
9D01EEF0  A4430C00   SH V1, 3072(V0)
279:                 		PR4 = period;
9D01EEF4  3C03BF80   LUI V1, -16512
9D01EEF8  AC640C20   SW A0, 3104(V1)
280:                 		T4CONbits.TCKPS = 0b011;
9D01EEFC  94430C00   LHU V1, 3072(V0)
9D01EF00  24050003   ADDIU A1, ZERO, 3
9D01EF04  7CA33104   INS V1, A1, 4, 3
9D01EF08  A4430C00   SH V1, 3072(V0)
281:                 		if (period!=0)
9D01EF0C  50800007   BEQL A0, ZERO, 0x9D01EF2C
9D01EF10  3C02BF88   LUI V0, -16504
282:                 			T4CONbits.TON = 1;
9D01EF14  94430C00   LHU V1, 3072(V0)
9D01EF18  24040001   ADDIU A0, ZERO, 1
9D01EF1C  7C837BC4   INS V1, A0, 15, 1
9D01EF20  A4430C00   SH V1, 3072(V0)
9D01EF24  03E00008   JR RA
9D01EF28  00000000   NOP
283:                 		else
284:                 			GEN_2_PIN = 0;
9D01EF2C  94436330   LHU V1, 25392(V0)
9D01EF30  7C0318C4   INS V1, ZERO, 3, 1
9D01EF34  A4436330   SH V1, 25392(V0)
9D01EF38  03E00008   JR RA
9D01EF3C  00000000   NOP
285:                 		}
286:                 	}
287:                 
288:                 void hw_sleep (void)
289:                 	{
9D01F48C  27BDFFE8   ADDIU SP, SP, -24
9D01F490  AFBF0014   SW RA, 20(SP)
290:                 	led_state = get_led_word();
9D01F494  0F407B38   JAL get_led_word
9D01F498  00000000   NOP
9D01F49C  A3828178   SB V0, -32392(GP)
291:                 	set_led_word(0);
9D01F4A0  0F407B47   JAL set_led_word
9D01F4A4  00002021   ADDU A0, ZERO, ZERO
292:                 	T1CONbits.TON = 0;
9D01F4A8  3C02BF80   LUI V0, -16512
9D01F4AC  94430600   LHU V1, 1536(V0)
9D01F4B0  7C037BC4   INS V1, ZERO, 15, 1
9D01F4B4  A4430600   SH V1, 1536(V0)
293:                 	T2CONbits.TON = 0;
9D01F4B8  3C02BF80   LUI V0, -16512
9D01F4BC  94430800   LHU V1, 2048(V0)
9D01F4C0  7C037BC4   INS V1, ZERO, 15, 1
9D01F4C4  A4430800   SH V1, 2048(V0)
294:                 	T3CONbits.TON = 0;
9D01F4C8  3C02BF80   LUI V0, -16512
9D01F4CC  94430A00   LHU V1, 2560(V0)
9D01F4D0  7C037BC4   INS V1, ZERO, 15, 1
9D01F4D4  A4430A00   SH V1, 2560(V0)
295:                 	T4CONbits.TON = 0;
9D01F4D8  3C02BF80   LUI V0, -16512
9D01F4DC  94430C00   LHU V1, 3072(V0)
9D01F4E0  7C037BC4   INS V1, ZERO, 15, 1
9D01F4E4  A4430C00   SH V1, 3072(V0)
296:                 	T5CONbits.TON = 0;
9D01F4E8  3C02BF80   LUI V0, -16512
9D01F4EC  94430E00   LHU V1, 3584(V0)
9D01F4F0  7C037BC4   INS V1, ZERO, 15, 1
9D01F4F4  A4430E00   SH V1, 3584(V0)
297:                 	SPI1CONbits.ON = 0;
9D01F4F8  3C02BF80   LUI V0, -16512
9D01F4FC  8C435800   LW V1, 22528(V0)
9D01F500  7C037BC4   INS V1, ZERO, 15, 1
9D01F504  AC435800   SW V1, 22528(V0)
298:                 	U3MODEbits.ON = 0;
9D01F508  3C02BF80   LUI V0, -16512
9D01F50C  94436400   LHU V1, 25600(V0)
9D01F510  7C037BC4   INS V1, ZERO, 15, 1
9D01F514  A4436400   SH V1, 25600(V0)
299:                 	LCD_PWR = 1;
9D01F518  3C03BF88   LUI V1, -16504
9D01F51C  94646230   LHU A0, 25136(V1)
9D01F520  24020001   ADDIU V0, ZERO, 1
9D01F524  7C447BC4   INS A0, V0, 15, 1
9D01F528  A4646230   SH A0, 25136(V1)
300:                 	LCD_BKLT = 1;
9D01F52C  3C04BF88   LUI A0, -16504
9D01F530  90836530   LBU V1, 25904(A0)
9D01F534  7C430004   INS V1, V0, 0, 1
9D01F538  A0836530   SB V1, 25904(A0)
301:                 	LCD_PORT = 0;
9D01F53C  3C06BF88   LUI A2, -16504
9D01F540  ACC06430   SW ZERO, 25648(A2)
302:                 	LCD_DC = 0;
9D01F544  3C05BF88   LUI A1, -16504
9D01F548  94A36630   LHU V1, 26160(A1)
9D01F54C  7C034204   INS V1, ZERO, 8, 1
9D01F550  A4A36630   SH V1, 26160(A1)
303:                 	LCD_RD = 0;
9D01F554  3C03BF88   LUI V1, -16504
9D01F558  94676330   LHU A3, 25392(V1)
9D01F55C  7C072944   INS A3, ZERO, 5, 1
9D01F560  A4676330   SH A3, 25392(V1)
304:                 	LCD_RES = 0;
9D01F564  94A76630   LHU A3, 26160(A1)
9D01F568  7C0739C4   INS A3, ZERO, 7, 1
9D01F56C  A4A76630   SH A3, 26160(A1)
305:                 	LCD_WR = 0;
9D01F570  94656330   LHU A1, 25392(V1)
9D01F574  7C052104   INS A1, ZERO, 4, 1
9D01F578  A4656330   SH A1, 25392(V1)
306:                 	GEN_0_PIN = 0;
9D01F57C  94656330   LHU A1, 25392(V1)
9D01F580  7C050844   INS A1, ZERO, 1, 1
9D01F584  A4656330   SH A1, 25392(V1)
307:                 	GEN_1_PIN = 0;
9D01F588  94656330   LHU A1, 25392(V1)
9D01F58C  7C051084   INS A1, ZERO, 2, 1
9D01F590  A4656330   SH A1, 25392(V1)
308:                 	GEN_2_PIN = 0;
9D01F594  94656330   LHU A1, 25392(V1)
9D01F598  7C0518C4   INS A1, ZERO, 3, 1
9D01F59C  A4656330   SH A1, 25392(V1)
309:                 	TRISBbits.TRISB0 = 0;
9D01F5A0  3C03BF88   LUI V1, -16504
9D01F5A4  94656110   LHU A1, 24848(V1)
9D01F5A8  7C050004   INS A1, ZERO, 0, 1
9D01F5AC  A4656110   SH A1, 24848(V1)
310:                 	TRISBbits.TRISB1 = 0;
9D01F5B0  94656110   LHU A1, 24848(V1)
9D01F5B4  7C050844   INS A1, ZERO, 1, 1
9D01F5B8  A4656110   SH A1, 24848(V1)
311:                 	TRISG = 0;
9D01F5BC  3C03BF88   LUI V1, -16504
9D01F5C0  AC606610   SW ZERO, 26128(V1)
312:                 	TRISGbits.TRISG9 = 1;
9D01F5C4  3C03BF88   LUI V1, -16504
9D01F5C8  94656610   LHU A1, 26128(V1)
9D01F5CC  7C454A44   INS A1, V0, 9, 1
9D01F5D0  A4656610   SH A1, 26128(V1)
313:                 	TRISGbits.TRISG6 = 1;
9D01F5D4  94656610   LHU A1, 26128(V1)
9D01F5D8  7C453184   INS A1, V0, 6, 1
9D01F5DC  A4656610   SH A1, 26128(V1)
314:                 	TRISC = 0;
9D01F5E0  3C03BF88   LUI V1, -16504
9D01F5E4  AC606210   SW ZERO, 25104(V1)
315:                 	LATC = 0x8000;
9D01F5E8  34058000   ORI A1, ZERO, -32768
9D01F5EC  3C03BF88   LUI V1, -16504
9D01F5F0  AC656230   SW A1, 25136(V1)
316:                 	TRISD = 0X0;
9D01F5F4  3C03BF88   LUI V1, -16504
9D01F5F8  AC606310   SW ZERO, 25360(V1)
317:                 	LATD = 0;
9D01F5FC  3C03BF88   LUI V1, -16504
9D01F600  AC606330   SW ZERO, 25392(V1)
318:                 	TRISDbits.TRISD9 = 1;
9D01F604  3C03BF88   LUI V1, -16504
9D01F608  94656310   LHU A1, 25360(V1)
9D01F60C  7C454A44   INS A1, V0, 9, 1
9D01F610  A4656310   SH A1, 25360(V1)
319:                 	TRISDbits.TRISD10 = 1;
9D01F614  94656310   LHU A1, 25360(V1)
9D01F618  7C455284   INS A1, V0, 10, 1
9D01F61C  A4656310   SH A1, 25360(V1)
320:                     CNPUDbits.CNPUD10 = 1;
9D01F620  3C03BF88   LUI V1, -16504
9D01F624  94656350   LHU A1, 25424(V1)
9D01F628  7C455284   INS A1, V0, 10, 1
9D01F62C  A4656350   SH A1, 25424(V1)
321:                     CNPUDbits.CNPUD9 = 1;
9D01F630  94656350   LHU A1, 25424(V1)
9D01F634  7C454A44   INS A1, V0, 9, 1
9D01F638  A4656350   SH A1, 25424(V1)
322:                 	TRISE = 0;
9D01F63C  3C03BF88   LUI V1, -16504
9D01F640  AC606410   SW ZERO, 25616(V1)
323:                 	LATE = 0;	
9D01F644  ACC06430   SW ZERO, 25648(A2)
324:                 	TRISF = 0;
9D01F648  3C03BF88   LUI V1, -16504
9D01F64C  AC606510   SW ZERO, 25872(V1)
325:                 	K_R1 = 1;
9D01F650  3C03BF88   LUI V1, -16504
9D01F654  94656130   LHU A1, 24880(V1)
9D01F658  7C456304   INS A1, V0, 12, 1
9D01F65C  A4656130   SH A1, 24880(V1)
326:                 	K_R2 = 1;
9D01F660  94656130   LHU A1, 24880(V1)
9D01F664  7C456B44   INS A1, V0, 13, 1
9D01F668  A4656130   SH A1, 24880(V1)
327:                 	K_R3 = 1;
9D01F66C  94656130   LHU A1, 24880(V1)
9D01F670  7C457384   INS A1, V0, 14, 1
9D01F674  A4656130   SH A1, 24880(V1)
328:                 	K_R4 = 1;
9D01F678  94656130   LHU A1, 24880(V1)
9D01F67C  7C457BC4   INS A1, V0, 15, 1
9D01F680  A4656130   SH A1, 24880(V1)
329:                 	K_R5 = 1;
9D01F684  90836530   LBU V1, 25904(A0)
9D01F688  7C432104   INS V1, V0, 4, 1
9D01F68C  A0836530   SB V1, 25904(A0)
330:                 	PMD1 = 0xFFFFFFFF;
9D01F690  3C09BF81   LUI T1, -16511
9D01F694  2403FFFF   ADDIU V1, ZERO, -1
9D01F698  AD23F240   SW V1, -3520(T1)
331:                 	PMD2 = 0xFFFFFFFF;
9D01F69C  3C08BF81   LUI T0, -16511
9D01F6A0  AD03F250   SW V1, -3504(T0)
332:                 	PMD3 = 0xFFFFFFFF;
9D01F6A4  3C07BF81   LUI A3, -16511
9D01F6A8  ACE3F260   SW V1, -3488(A3)
333:                 	PMD4 = 0xFFFFFFFF;
9D01F6AC  3C06BF81   LUI A2, -16511
9D01F6B0  ACC3F270   SW V1, -3472(A2)
334:                 	PMD5 = 0xFFFFFFFF;
9D01F6B4  3C05BF81   LUI A1, -16511
9D01F6B8  ACA3F280   SW V1, -3456(A1)
335:                 	PMD6 = 0xFFFFFFFF;
9D01F6BC  3C04BF81   LUI A0, -16511
9D01F6C0  AC83F290   SW V1, -3440(A0)
336:                 	SYSKEY = 0x0;            // Write invalid key to force lock
9D01F6C4  3C03BF81   LUI V1, -16511
9D01F6C8  AC60F230   SW ZERO, -3536(V1)
337:                 	SYSKEY = 0xAA996655;     // Write Key1 to SYSKEY
9D01F6CC  3C0AAA99   LUI T2, -21863
9D01F6D0  254A6655   ADDIU T2, T2, 26197
9D01F6D4  AC6AF230   SW T2, -3536(V1)
338:                 	SYSKEY = 0x556699AA;     // Write Key2 to SYSKEY
9D01F6D8  3C0A5566   LUI T2, 21862
9D01F6DC  354A99AA   ORI T2, T2, -26198
9D01F6E0  AC6AF230   SW T2, -3536(V1)
339:                 	OSCCONSET = 0x10; // set Power-Saving mode to Slee
9D01F6E4  240B0010   ADDIU T3, ZERO, 16
9D01F6E8  3C0ABF81   LUI T2, -16511
9D01F6EC  AD4BF008   SW T3, -4088(T2)
340:                 	SYSKEY = 0x0; // Write invalid key to force lock
9D01F6F0  AC60F230   SW ZERO, -3536(V1)
341:                 
342:                 	IFS0bits.INT2IF = 0;
9D01F6F4  3C03BF88   LUI V1, -16504
9D01F6F8  8C6A1030   LW T2, 4144(V1)
9D01F6FC  7C0A6B44   INS T2, ZERO, 13, 1
9D01F700  AC6A1030   SW T2, 4144(V1)
343:                 	IEC0bits.INT2IE = 1;
9D01F704  3C03BF88   LUI V1, -16504
9D01F708  8C6A1060   LW T2, 4192(V1)
9D01F70C  7C4A6B44   INS T2, V0, 13, 1
9D01F710  AC6A1060   SW T2, 4192(V1)
344:                 	IPC2bits.INT2IP = 4;
9D01F714  3C02BF88   LUI V0, -16504
9D01F718  8C4A10B0   LW T2, 4272(V0)
9D01F71C  240B0004   ADDIU T3, ZERO, 4
9D01F720  7D6AE684   INS T2, T3, 26, 3
9D01F724  AC4A10B0   SW T2, 4272(V0)
345:                 	//asm volatile("wait"); 
346:                 	IEC0bits.INT2IE = 0;
9D01F728  8C621060   LW V0, 4192(V1)
9D01F72C  7C026B44   INS V0, ZERO, 13, 1
9D01F730  AC621060   SW V0, 4192(V1)
347:                 	PMD1 = 0;
9D01F734  AD20F240   SW ZERO, -3520(T1)
348:                 	PMD2 = 0;
9D01F738  AD00F250   SW ZERO, -3504(T0)
349:                 	PMD3 = 0;
9D01F73C  ACE0F260   SW ZERO, -3488(A3)
350:                 	PMD4 = 0;
9D01F740  ACC0F270   SW ZERO, -3472(A2)
351:                 	PMD5 = 0;
9D01F744  ACA0F280   SW ZERO, -3456(A1)
352:                 	PMD6 = 0;
9D01F748  AC80F290   SW ZERO, -3440(A0)
353:                 	hw_init();
9D01F74C  0F407BDB   JAL hw_init
9D01F750  00000000   NOP
354:                 	start_after_wake();
9D01F754  8F8281A4   LW V0, -32348(GP)
9D01F758  0040F809   JALR V0
9D01F75C  00000000   NOP
355:                 	}
9D01F760  8FBF0014   LW RA, 20(SP)
9D01F764  03E00008   JR RA
9D01F768  27BD0018   ADDIU SP, SP, 24
356:                 
357:                 
358:                 
359:                 void hw_init (void)
360:                 	{
9D01EF6C  27BDFFE0   ADDIU SP, SP, -32
9D01EF70  AFBF001C   SW RA, 28(SP)
9D01EF74  AFB20018   SW S2, 24(SP)
9D01EF78  AFB10014   SW S1, 20(SP)
361:                     SYSTEMConfigPerformance(SYS_CLK);
362:                     OSCCONbits.FRCDIV = 0b000;
9D01F02C  3C02BF81   LUI V0, -16511
9D01F030  8C43F000   LW V1, -4096(V0)
9D01F034  7C03D604   INS V1, ZERO, 24, 3
9D01F038  AC43F000   SW V1, -4096(V0)
363:                 	ANSELB = 0;
9D01F03C  3C02BF88   LUI V0, -16504
9D01F040  AC406100   SW ZERO, 24832(V0)
364:                 	ANSELC = 0;
9D01F044  3C02BF88   LUI V0, -16504
9D01F048  AC406200   SW ZERO, 25088(V0)
365:                 	ANSELD = 0;
9D01F04C  3C02BF88   LUI V0, -16504
9D01F050  AC406300   SW ZERO, 25344(V0)
366:                 	ANSELE = 0;
9D01F054  3C02BF88   LUI V0, -16504
9D01F058  AC406400   SW ZERO, 25600(V0)
367:                 	ANSELF = 0;
9D01F05C  3C02BF88   LUI V0, -16504
9D01F060  AC406500   SW ZERO, 25856(V0)
368:                 	ANSELG = 0;
9D01F064  3C02BF88   LUI V0, -16504
9D01F068  AC406600   SW ZERO, 26112(V0)
369:                 	TRISD = 0;
9D01F06C  3C02BF88   LUI V0, -16504
9D01F070  AC406310   SW ZERO, 25360(V0)
370:                 	TRISDbits.TRISD9 = 1;
9D01F074  3C02BF88   LUI V0, -16504
9D01F078  94436310   LHU V1, 25360(V0)
9D01F07C  7E034A44   INS V1, S0, 9, 1
9D01F080  A4436310   SH V1, 25360(V0)
371:                 	TRISDbits.TRISD10 = 1;
9D01F084  94436310   LHU V1, 25360(V0)
9D01F088  7E035284   INS V1, S0, 10, 1
9D01F08C  A4436310   SH V1, 25360(V0)
372:                     TRISE = 0;
9D01F090  3C03BF88   LUI V1, -16504
9D01F094  AC606410   SW ZERO, 25616(V1)
373:                     TRISG = 0;
9D01F098  3C03BF88   LUI V1, -16504
9D01F09C  AC606610   SW ZERO, 26128(V1)
374:                 	TRISGbits.TRISG6 = 1;
9D01F0A0  3C03BF88   LUI V1, -16504
9D01F0A4  94646610   LHU A0, 26128(V1)
9D01F0A8  7E043184   INS A0, S0, 6, 1
9D01F0AC  A4646610   SH A0, 26128(V1)
375:                 	TRISGbits.TRISG9 = 1;
9D01F0B0  94646610   LHU A0, 26128(V1)
9D01F0B4  7E044A44   INS A0, S0, 9, 1
9D01F0B8  A4646610   SH A0, 26128(V1)
376:                     TRISF = 0;
9D01F0BC  3C03BF88   LUI V1, -16504
9D01F0C0  AC606510   SW ZERO, 25872(V1)
377:                 	TRISFbits.TRISF5 = 1;
9D01F0C4  3C03BF88   LUI V1, -16504
9D01F0C8  90646510   LBU A0, 25872(V1)
9D01F0CC  7E042944   INS A0, S0, 5, 1
9D01F0D0  A0646510   SB A0, 25872(V1)
378:                     TRISB = 0x0FFF; 
9D01F0D4  24030FFF   ADDIU V1, ZERO, 4095
9D01F0D8  3C04BF88   LUI A0, -16504
9D01F0DC  AC836110   SW V1, 24848(A0)
379:                     CNPUB = 0x0FFF;
9D01F0E0  3C04BF88   LUI A0, -16504
9D01F0E4  AC836150   SW V1, 24912(A0)
380:                     CNPUDbits.CNPUD10 = 1;
9D01F0E8  3C03BF88   LUI V1, -16504
9D01F0EC  94646350   LHU A0, 25424(V1)
9D01F0F0  7E045284   INS A0, S0, 10, 1
9D01F0F4  A4646350   SH A0, 25424(V1)
381:                     CNPUDbits.CNPUD9 = 1;
9D01F0F8  94646350   LHU A0, 25424(V1)
9D01F0FC  7E044A44   INS A0, S0, 9, 1
9D01F100  A4646350   SH A0, 25424(V1)
382:                 	TRISCbits.TRISC12 = 0;
9D01F104  3C03BF88   LUI V1, -16504
9D01F108  94646210   LHU A0, 25104(V1)
9D01F10C  7C046304   INS A0, ZERO, 12, 1
9D01F110  A4646210   SH A0, 25104(V1)
383:                 	TRISDbits.TRISD8 = 0;
9D01F114  94446310   LHU A0, 25360(V0)
9D01F118  7C044204   INS A0, ZERO, 8, 1
9D01F11C  A4446310   SH A0, 25360(V0)
384:                 	FLASH_WP = 1;
9D01F120  3C12BF88   LUI S2, -16504
9D01F124  96426330   LHU V0, 25392(S2)
9D01F128  7E024204   INS V0, S0, 8, 1
9D01F12C  A6426330   SH V0, 25392(S2)
385:                 	FLASH_HOLD = 1;
9D01F130  3C04BF88   LUI A0, -16504
9D01F134  94826230   LHU V0, 25136(A0)
9D01F138  7E026304   INS V0, S0, 12, 1
9D01F13C  A4826230   SH V0, 25136(A0)
386:                 	CS_FLASH = 1;
9D01F140  3C11BF88   LUI S1, -16504
9D01F144  92226530   LBU V0, 25904(S1)
9D01F148  7E021084   INS V0, S0, 2, 1
9D01F14C  A2226530   SB V0, 25904(S1)
387:                     /*
388:                     MOSI	F3	
389:                     MISO	F5	
390:                     SCK		F6	
391:                 			C13	
392:                 			C14	
393:                      */
394:                     PPSUnLock;
395:                     PPSOutput(4, RPF3, SDO1);	//MOSI for FLASH
9D01F150  3C02BF81   LUI V0, -16511
9D01F154  9045FC4C   LBU A1, -948(V0)
9D01F158  24060008   ADDIU A2, ZERO, 8
9D01F15C  7CC51804   INS A1, A2, 0, 4
9D01F160  A045FC4C   SB A1, -948(V0)
396:                 	PPSInput(1, SDI1, RPF5);	//MISO for FLASH
9D01F164  3C02BF81   LUI V0, -16511
9D01F168  9046FA84   LBU A2, -1404(V0)
9D01F16C  24050002   ADDIU A1, ZERO, 2
9D01F170  7CA61804   INS A2, A1, 0, 4
9D01F174  A046FA84   SB A2, -1404(V0)
397:                 								//SCK is fixed
398:                 	PPSInput(1, U3RX, RPC13);	//RX pin
9D01F178  3C02BF81   LUI V0, -16511
9D01F17C  9046FA60   LBU A2, -1440(V0)
9D01F180  24070007   ADDIU A3, ZERO, 7
9D01F184  7CE61804   INS A2, A3, 0, 4
9D01F188  A046FA60   SB A2, -1440(V0)
399:                 	PPSOutput(1, RPC14, U3TX);	//TX pin
9D01F18C  3C02BF81   LUI V0, -16511
9D01F190  9046FBB8   LBU A2, -1096(V0)
9D01F194  7E061804   INS A2, S0, 0, 4
9D01F198  A046FBB8   SB A2, -1096(V0)
400:                 	PPSInput(3, INT2, RPG6);	//power on/off, tie to external interrupt2
9D01F19C  3C02BF81   LUI V0, -16511
9D01F1A0  9046FA08   LBU A2, -1528(V0)
9D01F1A4  7E061804   INS A2, S0, 0, 4
9D01F1A8  A046FA08   SB A2, -1528(V0)
401:                     PPSLock;
402:                 
403:                 	U3MODEbits.ON = 1;
9D01F1AC  3C02BF80   LUI V0, -16512
9D01F1B0  94466400   LHU A2, 25600(V0)
9D01F1B4  7E067BC4   INS A2, S0, 15, 1
9D01F1B8  A4466400   SH A2, 25600(V0)
404:                 //	U1MODEbits.STSEL = 1;
405:                     U3STAbits.URXEN = 1;
9D01F1BC  3C02BF80   LUI V0, -16512
9D01F1C0  8C466410   LW A2, 25616(V0)
9D01F1C4  7E066304   INS A2, S0, 12, 1
9D01F1C8  AC466410   SW A2, 25616(V0)
406:                     U3STAbits.UTXEN = 1;
9D01F1CC  8C466410   LW A2, 25616(V0)
9D01F1D0  7E065284   INS A2, S0, 10, 1
9D01F1D4  AC466410   SW A2, 25616(V0)
407:                     U3BRG = ((PB_CLK)/(16*19200)) - 1;
9D01F1D8  2407009B   ADDIU A3, ZERO, 155
9D01F1DC  3C06BF80   LUI A2, -16512
9D01F1E0  ACC76440   SW A3, 25664(A2)
408:                 //    INTEnable(INT_SOURCE_UART_RX(UART3), INT_ENABLED);
409:                 //    IPC7bits.U3IP = 6;
410:                     U3STAbits.OERR=0;
9D01F1E4  8C466410   LW A2, 25616(V0)
9D01F1E8  7C060844   INS A2, ZERO, 1, 1
9D01F1EC  AC466410   SW A2, 25616(V0)
411:                 
412:                 	SPI1CONbits.MSTEN = 1;
9D01F1F0  3C02BF80   LUI V0, -16512
9D01F1F4  8C465800   LW A2, 22528(V0)
9D01F1F8  7E062944   INS A2, S0, 5, 1
9D01F1FC  AC465800   SW A2, 22528(V0)
413:                     SPI1CONbits.CKP = 0;
9D01F200  8C465800   LW A2, 22528(V0)
9D01F204  7C063184   INS A2, ZERO, 6, 1
9D01F208  AC465800   SW A2, 22528(V0)
414:                     SPI1CONbits.SMP = 0;
9D01F20C  8C465800   LW A2, 22528(V0)
9D01F210  7C064A44   INS A2, ZERO, 9, 1
9D01F214  AC465800   SW A2, 22528(V0)
415:                     SPI1CONbits.CKE = 1;
9D01F218  8C465800   LW A2, 22528(V0)
9D01F21C  7E064204   INS A2, S0, 8, 1
9D01F220  AC465800   SW A2, 22528(V0)
416:                     SPI1BRG = 1;
9D01F224  3C06BF80   LUI A2, -16512
9D01F228  ACD05830   SW S0, 22576(A2)
417:                     SPI1CONbits.ON = 1;
9D01F22C  8C465800   LW A2, 22528(V0)
9D01F230  7E067BC4   INS A2, S0, 15, 1
9D01F234  AC465800   SW A2, 22528(V0)
418:                     
419:                 //    TRISBbits.TRISB13 = 0;
420:                     LCD_BKLT = 1;
9D01F238  92226530   LBU V0, 25904(S1)
9D01F23C  7E020004   INS V0, S0, 0, 1
9D01F240  A2226530   SB V0, 25904(S1)
421:                     LCD_PWR = 0;
9D01F244  94826230   LHU V0, 25136(A0)
9D01F248  7C027BC4   INS V0, ZERO, 15, 1
9D01F24C  A4826230   SH V0, 25136(A0)
422:                 	TRISCbits.TRISC15 = 0;
9D01F250  94626210   LHU V0, 25104(V1)
9D01F254  7C027BC4   INS V0, ZERO, 15, 1
9D01F258  A4626210   SH V0, 25104(V1)
423:                 	
424:                     PR5 = 12 *(FPB / 64 / 1000);
9D01F25C  24032328   ADDIU V1, ZERO, 9000
9D01F260  3C02BF80   LUI V0, -16512
9D01F264  AC430E20   SW V1, 3616(V0)
425:                     T5CONbits.TCKPS = 0b110;
9D01F268  3C02BF80   LUI V0, -16512
9D01F26C  94440E00   LHU A0, 3584(V0)
9D01F270  24030006   ADDIU V1, ZERO, 6
9D01F274  7C643104   INS A0, V1, 4, 3
9D01F278  A4440E00   SH A0, 3584(V0)
426:                     T5CONbits.TON = 1;
9D01F27C  94440E00   LHU A0, 3584(V0)
9D01F280  7E047BC4   INS A0, S0, 15, 1
9D01F284  A4440E00   SH A0, 3584(V0)
427:                     IEC0bits.T5IE = 1;	
9D01F288  3C02BF88   LUI V0, -16504
9D01F28C  8C441060   LW A0, 4192(V0)
9D01F290  7E04C604   INS A0, S0, 24, 1
9D01F294  AC441060   SW A0, 4192(V0)
428:                     IPC5bits.T5IP = 3;
9D01F298  3C04BF88   LUI A0, -16504
9D01F29C  8C8610E0   LW A2, 4320(A0)
9D01F2A0  24070003   ADDIU A3, ZERO, 3
9D01F2A4  7CE62084   INS A2, A3, 2, 3
9D01F2A8  AC8610E0   SW A2, 4320(A0)
429:                 
430:                     IEC0bits.T2IE = 1;	
9D01F2AC  8C441060   LW A0, 4192(V0)
9D01F2B0  7E044A44   INS A0, S0, 9, 1
9D01F2B4  AC441060   SW A0, 4192(V0)
431:                     IPC2bits.T2IP = 6;
9D01F2B8  3C04BF88   LUI A0, -16504
9D01F2BC  8C8610B0   LW A2, 4272(A0)
9D01F2C0  7C662084   INS A2, V1, 2, 3
9D01F2C4  AC8610B0   SW A2, 4272(A0)
432:                     IEC0bits.T3IE = 1;	
9D01F2C8  8C441060   LW A0, 4192(V0)
9D01F2CC  7E047384   INS A0, S0, 14, 1
9D01F2D0  AC441060   SW A0, 4192(V0)
433:                     IPC3bits.T3IP = 6;
9D01F2D4  3C04BF88   LUI A0, -16504
9D01F2D8  8C8610C0   LW A2, 4288(A0)
9D01F2DC  7C662084   INS A2, V1, 2, 3
9D01F2E0  AC8610C0   SW A2, 4288(A0)
434:                     IEC0bits.T4IE = 1;	
9D01F2E4  8C441060   LW A0, 4192(V0)
9D01F2E8  7E049CC4   INS A0, S0, 19, 1
9D01F2EC  AC441060   SW A0, 4192(V0)
435:                     IPC4bits.T4IP = 6;
9D01F2F0  3C04BF88   LUI A0, -16504
9D01F2F4  8C8610D0   LW A2, 4304(A0)
9D01F2F8  7C662084   INS A2, V1, 2, 3
9D01F2FC  AC8610D0   SW A2, 4304(A0)
436:                 
437:                     PR1 = (1*(FPB / 64 / 1000)) - 1;
9D01F300  240402ED   ADDIU A0, ZERO, 749
9D01F304  3C03BF80   LUI V1, -16512
9D01F308  AC640620   SW A0, 1568(V1)
438:                     T1CONbits.TCKPS = 0b10;	//Prescale 64 makes 1ms = 750 ticks at 48 MHz
9D01F30C  3C03BF80   LUI V1, -16512
9D01F310  94640600   LHU A0, 1536(V1)
9D01F314  7CA42904   INS A0, A1, 4, 2
9D01F318  A4640600   SH A0, 1536(V1)
439:                     T1CONbits.TON = 1;
9D01F31C  94640600   LHU A0, 1536(V1)
9D01F320  7E047BC4   INS A0, S0, 15, 1
9D01F324  A4640600   SH A0, 1536(V1)
440:                     IEC0bits.T1IE = 1;
9D01F328  8C431060   LW V1, 4192(V0)
9D01F32C  7E032104   INS V1, S0, 4, 1
9D01F330  AC431060   SW V1, 4192(V0)
441:                     IPC1bits.T1IP = 4;
9D01F334  3C02BF88   LUI V0, -16504
9D01F338  8C4310A0   LW V1, 4256(V0)
9D01F33C  24040004   ADDIU A0, ZERO, 4
9D01F340  7C832084   INS V1, A0, 2, 3
9D01F344  AC4310A0   SW V1, 4256(V0)
442:                 
443:                 	sound_set_generator(0,0);
9D01F348  00002021   ADDU A0, ZERO, ZERO
9D01F34C  0F407B86   JAL sound_set_generator
9D01F350  00002821   ADDU A1, ZERO, ZERO
444:                 	sound_set_generator(0,1);
9D01F354  00002021   ADDU A0, ZERO, ZERO
9D01F358  0F407B86   JAL sound_set_generator
9D01F35C  24050001   ADDIU A1, ZERO, 1
445:                 	sound_set_generator(0,2);
9D01F360  00002021   ADDU A0, ZERO, ZERO
9D01F364  0F407B86   JAL sound_set_generator
9D01F368  24050002   ADDIU A1, ZERO, 2
446:                 	GEN_ENABLE = 1;
9D01F36C  96426330   LHU V0, 25392(S2)
9D01F370  7E025AC4   INS V0, S0, 11, 1
9D01F374  A6426330   SH V0, 25392(S2)
447:                     INTEnableSystemMultiVectoredInt();
9D01F378  0F40F141   JAL INTEnableSystemMultiVectoredInt
9D01F37C  00000000   NOP
448:                 	
449:                 	//wait_ms(50);
450:                     //TFT_24_7789_Init();
451:                 	//tft_fill_area(0,0,320,240,0xFFFFFF);	//fill with black color
452:                 	//wait_ms(80);					//wait a moment to avoid flicker
453:                 	LCD_BKLT = 0;					//turn backlight on
9D01F380  92226530   LBU V0, 25904(S1)
9D01F384  7C020004   INS V0, ZERO, 0, 1
9D01F388  A2226530   SB V0, 25904(S1)
454:                 	//fl_rst_pb();
455:                 
456:                 	//if reset is after POR or manual reset, forget LED state
457:                 	if ((RCONbits.BOR)|(RCONbits.EXTR)|(RCONbits.POR))
9D01F38C  3C02BF81   LUI V0, -16511
9D01F390  8C44F600   LW A0, -2560(V0)
9D01F394  7C840040   EXT A0, A0, 1, 1
9D01F398  8C45F600   LW A1, -2560(V0)
9D01F39C  7CA501C0   EXT A1, A1, 7, 1
9D01F3A0  8C43F600   LW V1, -2560(V0)
9D01F3A4  30630001   ANDI V1, V1, 1
9D01F3A8  00A41025   OR V0, A1, A0
9D01F3AC  00621025   OR V0, V1, V0
9D01F3B0  10400003   BEQ V0, ZERO, 0x9D01F3C0
9D01F3B4  3C02BF81   LUI V0, -16511
458:                 		{
459:                 		RCON = 0;
9D01F3B8  AC40F600   SW ZERO, -2560(V0)
460:                 		led_state = 0;
9D01F3BC  A3808178   SB ZERO, -32392(GP)
461:                 		}
462:                 	set_led_word(led_state);	
9D01F3C0  0F407B47   JAL set_led_word
9D01F3C4  93848178   LBU A0, -32392(GP)
463:                 	
464:                   	}
9D01F3C8  0B407D1E   J 0x9D01F478
9D01F3CC  8FBF001C   LW RA, 28(SP)
9D01F478  8FB20018   LW S2, 24(SP)
9D01F47C  8FB10014   LW S1, 20(SP)
9D01F480  8FB00010   LW S0, 16(SP)
9D01F484  03E00008   JR RA
9D01F488  27BD0020   ADDIU SP, SP, 32
465:                 
466:                 
467:                 uint8_t keyb_tasks (void)
468:                 	{
9D01F76C  27BDFFE8   ADDIU SP, SP, -24
9D01F770  AFBF0014   SW RA, 20(SP)
469:                 	static int8_t shift=0;
470:                 	uint8_t retval = 0;
9D01FABC  00001021   ADDU V0, ZERO, ZERO
471:                 	rnd_var3 = rnd_var3 + 12345;
9D01F774  978281B2   LHU V0, -32334(GP)
9D01F778  24423039   ADDIU V0, V0, 12345
472:                 	rnd_var2 = rnd_var2 + millis();
9D01F77C  0F407077   JAL millis
9D01F780  A78281B2   SH V0, -32334(GP)
9D01F784  978381AE   LHU V1, -32338(GP)
9D01F788  00431021   ADDU V0, V0, V1
9D01F78C  A78281AE   SH V0, -32338(GP)
473:                 	K_R1 = 1;
9D01F790  3C02BF88   LUI V0, -16504
9D01F794  94446130   LHU A0, 24880(V0)
9D01F798  24030001   ADDIU V1, ZERO, 1
9D01F79C  7C646304   INS A0, V1, 12, 1
9D01F7A0  A4446130   SH A0, 24880(V0)
474:                 	K_R2 = 1;
9D01F7A4  94446130   LHU A0, 24880(V0)
9D01F7A8  7C646B44   INS A0, V1, 13, 1
9D01F7AC  A4446130   SH A0, 24880(V0)
475:                 	K_R3 = 1;
9D01F7B0  94446130   LHU A0, 24880(V0)
9D01F7B4  7C647384   INS A0, V1, 14, 1
9D01F7B8  A4446130   SH A0, 24880(V0)
476:                 	K_R4 = 1;
9D01F7BC  94446130   LHU A0, 24880(V0)
9D01F7C0  7C647BC4   INS A0, V1, 15, 1
9D01F7C4  A4446130   SH A0, 24880(V0)
477:                 	K_R5 = 1;
9D01F7C8  3C02BF88   LUI V0, -16504
9D01F7CC  90446530   LBU A0, 25904(V0)
9D01F7D0  7C642104   INS A0, V1, 4, 1
9D01F7D4  A0446530   SB A0, 25904(V0)
478:                 	if (key_state==0) key = 255;
9D01F7D8  93828179   LBU V0, -32391(GP)
9D01F7DC  54400009   BNEL V0, ZERO, 0x9D01F804
9D01F7E0  24030001   ADDIU V1, ZERO, 1
9D01F7E4  2403FFFF   ADDIU V1, ZERO, -1
9D01F7E8  A38381B1   SB V1, -32335(GP)
479:                 	
480:                 	if (key_state==0) K_R1 = 0;
9D01F7EC  3C03BF88   LUI V1, -16504
9D01F7F0  94646130   LHU A0, 24880(V1)
9D01F7F4  7C046304   INS A0, ZERO, 12, 1
9D01F7F8  A4646130   SH A0, 24880(V1)
481:                 	if (key_state==1) K_R2 = 0;
9D01F804  14430006   BNE V0, V1, 0x9D01F820
9D01F808  3C03BF88   LUI V1, -16504
9D01F80C  94646130   LHU A0, 24880(V1)
9D01F810  7C046B44   INS A0, ZERO, 13, 1
9D01F814  A4646130   SH A0, 24880(V1)
482:                 	if (key_state==2) K_R3 = 0;
9D01F820  24030002   ADDIU V1, ZERO, 2
9D01F824  14430006   BNE V0, V1, 0x9D01F840
9D01F828  3C03BF88   LUI V1, -16504
9D01F82C  94646130   LHU A0, 24880(V1)
9D01F830  7C047384   INS A0, ZERO, 14, 1
9D01F834  A4646130   SH A0, 24880(V1)
483:                 	if (key_state==3) K_R4 = 0;
9D01F7FC  0B407E11   J 0x9D01F844
9D01F800  24030003   ADDIU V1, ZERO, 3
9D01F840  24030003   ADDIU V1, ZERO, 3
9D01F844  14430006   BNE V0, V1, 0x9D01F860
9D01F848  3C03BF88   LUI V1, -16504
9D01F84C  94646130   LHU A0, 24880(V1)
9D01F850  7C047BC4   INS A0, ZERO, 15, 1
9D01F854  A4646130   SH A0, 24880(V1)
484:                 	if (key_state==4) K_R5 = 0;
9D01F818  0B407E19   J 0x9D01F864
9D01F81C  24030004   ADDIU V1, ZERO, 4
9D01F860  24030004   ADDIU V1, ZERO, 4
9D01F864  14430006   BNE V0, V1, 0x9D01F880
9D01F868  3C03BF88   LUI V1, -16504
9D01F86C  90646530   LBU A0, 25904(V1)
9D01F870  7C042104   INS A0, ZERO, 4, 1
9D01F874  A0646530   SB A0, 25904(V1)
485:                 
486:                 	if (key_state==5)
9D01F838  0B407E21   J 0x9D01F884
9D01F83C  24030005   ADDIU V1, ZERO, 5
9D01F880  24030005   ADDIU V1, ZERO, 5
9D01F884  14430024   BNE V0, V1, 0x9D01F918
9D01F888  938381B1   LBU V1, -32335(GP)
487:                 		{
488:                 		if ((key<255)&(key_last!=key))
9D01F88C  938281B6   LBU V0, -32330(GP)
9D01F890  1043001E   BEQ V0, V1, 0x9D01F90C
9D01F894  00001021   ADDU V0, ZERO, ZERO
9D01F898  386200FF   XORI V0, V1, 255
9D01F89C  1040001B   BEQ V0, ZERO, 0x9D01F90C
9D01F8A0  00001021   ADDU V0, ZERO, ZERO
489:                 			{
490:                 			if (K_SHIFTL==0) key_char = keys_shift_l[key];
9D01F8A4  3C02BF88   LUI V0, -16504
9D01F8A8  8C426320   LW V0, 25376(V0)
9D01F8AC  30420400   ANDI V0, V0, 1024
9D01F8B0  54400007   BNEL V0, ZERO, 0x9D01F8D0
9D01F8B4  3C02BF88   LUI V0, -16504
9D01F8B8  3C029D03   LUI V0, -25341
9D01F8BC  244267F0   ADDIU V0, V0, 26608
9D01F8C0  00621021   ADDU V0, V1, V0
9D01F8C4  90420000   LBU V0, 0(V0)
9D01F8C8  0B407E42   J 0x9D01F908
9D01F8CC  A38281B0   SB V0, -32336(GP)
491:                 			else if (K_SHIFTR==0) key_char = keys_shift_r[key];
9D01F8D0  8C426320   LW V0, 25376(V0)
9D01F8D4  30420200   ANDI V0, V0, 512
9D01F8D8  54400007   BNEL V0, ZERO, 0x9D01F8F8
9D01F8DC  3C029D03   LUI V0, -25341
9D01F8E0  3C029D03   LUI V0, -25341
9D01F8E4  244267BC   ADDIU V0, V0, 26556
9D01F8E8  00621021   ADDU V0, V1, V0
9D01F8EC  90420000   LBU V0, 0(V0)
9D01F8F0  0B407E42   J 0x9D01F908
9D01F8F4  A38281B0   SB V0, -32336(GP)
492:                 			else key_char = keys_normal[key];
9D01F8F8  24426824   ADDIU V0, V0, 26660
9D01F8FC  00621021   ADDU V0, V1, V0
9D01F900  90420000   LBU V0, 0(V0)
9D01F904  A38281B0   SB V0, -32336(GP)
9D01F908  938281B0   LBU V0, -32336(GP)
493:                 			retval = key_char;
494:                 			}
495:                 		key_last = key;
9D01F90C  A38381B6   SB V1, -32330(GP)
9D01F910  0B407EB0   J 0x9D01FAC0
9D01F914  A3808179   SB ZERO, -32391(GP)
496:                 		key_state = 0;
497:                 		}
498:                 	else
499:                 		{
500:                 		if (K_C1==0)	key = 0 + (key_state*10);
9D01F858  0B407E47   J 0x9D01F91C
9D01F85C  3C03BF88   LUI V1, -16504
9D01F878  0B407E47   J 0x9D01F91C
9D01F87C  3C03BF88   LUI V1, -16504
9D01F918  3C03BF88   LUI V1, -16504
9D01F91C  8C636120   LW V1, 24864(V1)
9D01F920  30630800   ANDI V1, V1, 2048
9D01F924  14600006   BNE V1, ZERO, 0x9D01F940
9D01F928  3C03BF88   LUI V1, -16504
9D01F92C  00021840   SLL V1, V0, 1
9D01F930  00032080   SLL A0, V1, 2
9D01F934  00641821   ADDU V1, V1, A0
9D01F938  A38381B1   SB V1, -32335(GP)
501:                 		if (K_C2==0)	key = 1 + (key_state*10);
9D01F93C  3C03BF88   LUI V1, -16504
9D01F940  8C636120   LW V1, 24864(V1)
9D01F944  30630400   ANDI V1, V1, 1024
9D01F948  14600007   BNE V1, ZERO, 0x9D01F968
9D01F94C  3C03BF88   LUI V1, -16504
9D01F950  00021840   SLL V1, V0, 1
9D01F954  00032080   SLL A0, V1, 2
9D01F958  00641821   ADDU V1, V1, A0
9D01F95C  24630001   ADDIU V1, V1, 1
9D01F960  A38381B1   SB V1, -32335(GP)
502:                 		if (K_C3==0)	key = 2 + (key_state*10);
9D01F964  3C03BF88   LUI V1, -16504
9D01F968  8C636120   LW V1, 24864(V1)
9D01F96C  30630200   ANDI V1, V1, 512
9D01F970  14600007   BNE V1, ZERO, 0x9D01F990
9D01F974  3C03BF88   LUI V1, -16504
9D01F978  00021840   SLL V1, V0, 1
9D01F97C  00032080   SLL A0, V1, 2
9D01F980  00641821   ADDU V1, V1, A0
9D01F984  24630002   ADDIU V1, V1, 2
9D01F988  A38381B1   SB V1, -32335(GP)
503:                 		if (K_C4==0)	key = 3 + (key_state*10);
9D01F98C  3C03BF88   LUI V1, -16504
9D01F990  8C636120   LW V1, 24864(V1)
9D01F994  30630100   ANDI V1, V1, 256
9D01F998  14600007   BNE V1, ZERO, 0x9D01F9B8
9D01F99C  3C03BF88   LUI V1, -16504
9D01F9A0  00021840   SLL V1, V0, 1
9D01F9A4  00032080   SLL A0, V1, 2
9D01F9A8  00641821   ADDU V1, V1, A0
9D01F9AC  24630003   ADDIU V1, V1, 3
9D01F9B0  A38381B1   SB V1, -32335(GP)
504:                 		if (K_C5==0)	key = 4 + (key_state*10);
9D01F9B4  3C03BF88   LUI V1, -16504
9D01F9B8  8C636120   LW V1, 24864(V1)
9D01F9BC  30630080   ANDI V1, V1, 128
9D01F9C0  14600007   BNE V1, ZERO, 0x9D01F9E0
9D01F9C4  3C03BF88   LUI V1, -16504
9D01F9C8  00021840   SLL V1, V0, 1
9D01F9CC  00032080   SLL A0, V1, 2
9D01F9D0  00641821   ADDU V1, V1, A0
9D01F9D4  24630004   ADDIU V1, V1, 4
9D01F9D8  A38381B1   SB V1, -32335(GP)
505:                 		if (K_C6==0)	key = 5 + (key_state*10);
9D01F9DC  3C03BF88   LUI V1, -16504
9D01F9E0  8C636120   LW V1, 24864(V1)
9D01F9E4  30630040   ANDI V1, V1, 64
9D01F9E8  14600007   BNE V1, ZERO, 0x9D01FA08
9D01F9EC  3C03BF88   LUI V1, -16504
9D01F9F0  00021840   SLL V1, V0, 1
9D01F9F4  00032080   SLL A0, V1, 2
9D01F9F8  00641821   ADDU V1, V1, A0
9D01F9FC  24630005   ADDIU V1, V1, 5
9D01FA00  A38381B1   SB V1, -32335(GP)
506:                 		if (K_C7==0)	key = 6 + (key_state*10);
9D01FA04  3C03BF88   LUI V1, -16504
9D01FA08  8C636120   LW V1, 24864(V1)
9D01FA0C  30630020   ANDI V1, V1, 32
9D01FA10  14600007   BNE V1, ZERO, 0x9D01FA30
9D01FA14  3C03BF88   LUI V1, -16504
9D01FA18  00021840   SLL V1, V0, 1
9D01FA1C  00032080   SLL A0, V1, 2
9D01FA20  00641821   ADDU V1, V1, A0
9D01FA24  24630006   ADDIU V1, V1, 6
9D01FA28  A38381B1   SB V1, -32335(GP)
507:                 		if (K_C8==0)	key = 7 + (key_state*10);
9D01FA2C  3C03BF88   LUI V1, -16504
9D01FA30  8C636120   LW V1, 24864(V1)
9D01FA34  30630010   ANDI V1, V1, 16
9D01FA38  14600007   BNE V1, ZERO, 0x9D01FA58
9D01FA3C  3C03BF88   LUI V1, -16504
9D01FA40  00021840   SLL V1, V0, 1
9D01FA44  00032080   SLL A0, V1, 2
9D01FA48  00641821   ADDU V1, V1, A0
9D01FA4C  24630007   ADDIU V1, V1, 7
9D01FA50  A38381B1   SB V1, -32335(GP)
508:                 		if (K_C9==0)	key = 8 + (key_state*10);
9D01FA54  3C03BF88   LUI V1, -16504
9D01FA58  8C636120   LW V1, 24864(V1)
9D01FA5C  30630008   ANDI V1, V1, 8
9D01FA60  14600007   BNE V1, ZERO, 0x9D01FA80
9D01FA64  3C03BF88   LUI V1, -16504
9D01FA68  00021840   SLL V1, V0, 1
9D01FA6C  00032080   SLL A0, V1, 2
9D01FA70  00641821   ADDU V1, V1, A0
9D01FA74  24630008   ADDIU V1, V1, 8
9D01FA78  A38381B1   SB V1, -32335(GP)
509:                 		if (K_C10==0)	key = 9 + (key_state*10);
9D01FA7C  3C03BF88   LUI V1, -16504
9D01FA80  8C636120   LW V1, 24864(V1)
9D01FA84  30630004   ANDI V1, V1, 4
9D01FA88  14600007   BNE V1, ZERO, 0x9D01FAA8
9D01FA8C  938481B1   LBU A0, -32335(GP)
9D01FA90  00021840   SLL V1, V0, 1
9D01FA94  00032080   SLL A0, V1, 2
9D01FA98  00641821   ADDU V1, V1, A0
9D01FA9C  24630009   ADDIU V1, V1, 9
9D01FAA0  A38381B1   SB V1, -32335(GP)
510:                 		rnd_var1 = rnd_var1  + key;
9D01FAA4  938481B1   LBU A0, -32335(GP)
9D01FAA8  978381B4   LHU V1, -32332(GP)
9D01FAAC  00831821   ADDU V1, A0, V1
9D01FAB0  A78381B4   SH V1, -32332(GP)
511:                 		key_state++;
9D01FAB4  24420001   ADDIU V0, V0, 1
9D01FAB8  A3828179   SB V0, -32391(GP)
512:                 		}
513:                 	return retval;
514:                 	}
9D01FAC0  8FBF0014   LW RA, 20(SP)
9D01FAC4  03E00008   JR RA
9D01FAC8  27BD0018   ADDIU SP, SP, 24
515:                 
516:                 
517:                 
518:                 void wait_ms (uint32_t count)
519:                 	{
9D01FACC  27BDFFE8   ADDIU SP, SP, -24
9D01FAD0  AFBF0014   SW RA, 20(SP)
9D01FAD4  AFB00010   SW S0, 16(SP)
520:                 	uint32_t ticks_wait;
521:                 	ticks_wait = millis() + count;
9D01FAD8  0F407077   JAL millis
9D01FADC  00808021   ADDU S0, A0, ZERO
9D01FAE0  00508021   ADDU S0, V0, S0
522:                 	rnd_var2 = rnd_var2  + ticks_wait;
9D01FAE4  978281AE   LHU V0, -32338(GP)
9D01FAE8  02021021   ADDU V0, S0, V0
9D01FAEC  A78281AE   SH V0, -32338(GP)
523:                 	while (millis()<= ticks_wait);
9D01FAF0  0F407077   JAL millis
9D01FAF4  00000000   NOP
9D01FAF8  0202102B   SLTU V0, S0, V0
9D01FAFC  1040FFFC   BEQ V0, ZERO, 0x9D01FAF0
9D01FB00  8FBF0014   LW RA, 20(SP)
524:                 	}
9D01FB04  8FB00010   LW S0, 16(SP)
9D01FB08  03E00008   JR RA
9D01FB0C  27BD0018   ADDIU SP, SP, 24
525:                 
526:                 unsigned char	SPI_dat (uint8_t data)
527:                 	{
528:                 	SPI1BUF = data;
9D01FBBC  3C02BF80   LUI V0, -16512
9D01FBC0  AC445820   SW A0, 22560(V0)
529:                 	while (SPI1STATbits.SPIRBF==0);
9D01FBC4  3C03BF80   LUI V1, -16512
9D01FBC8  8C625810   LW V0, 22544(V1)
9D01FBCC  30420001   ANDI V0, V0, 1
9D01FBD0  1040FFFD   BEQ V0, ZERO, 0x9D01FBC8
9D01FBD4  3C02BF80   LUI V0, -16512
530:                 	return (SPI1BUF);
9D01FBD8  8C425820   LW V0, 22560(V0)
531:                 	}
9D01FBDC  03E00008   JR RA
9D01FBE0  304200FF   ANDI V0, V0, 255
532:                 
533:                 
534:                 uint16_t get_rnd (void)
535:                 	{
536:                 	uint32_t  var;
537:                 	static uint32_t  var_prev;
538:                 	var = rnd_var1 + rnd_var2 + rnd_var3 + (var_prev*1103515245) + 12345;
9D01FBE4  3C0341C6   LUI V1, 16838
9D01FBE8  24634E6D   ADDIU V1, V1, 20077
9D01FBEC  8F828174   LW V0, -32396(GP)
9D01FBF0  70431802   MUL V1, V0, V1
9D01FBF4  24633039   ADDIU V1, V1, 12345
9D01FBF8  978481B4   LHU A0, -32332(GP)
9D01FBFC  978281AE   LHU V0, -32338(GP)
9D01FC00  00821021   ADDU V0, A0, V0
9D01FC04  978481B2   LHU A0, -32334(GP)
9D01FC08  00441021   ADDU V0, V0, A0
9D01FC0C  00621021   ADDU V0, V1, V0
539:                 	var = var & 0xFFFF;
9D01FC10  3042FFFF   ANDI V0, V0, -1
540:                 	var_prev = var;
541:                 	return var;
542:                 	}
9D01FC14  03E00008   JR RA
9D01FC18  AF828174   SW V0, -32396(GP)
543:                 
544:                 void __ISR(_TIMER_2_VECTOR, IPL6AUTO) Timer2Handler(void)
545:                 //void __ISR(_TIMER_2_VECTOR, ipl6) Timer2Handler(void)
546:                 	{
9D01FC1C  415DE800   RDPGPR SP, SP
9D01FC20  401B7000   MFC0 K1, EPC
9D01FC24  401A6002   MFC0 K0, SRSCtl
9D01FC28  27BDFFE0   ADDIU SP, SP, -32
9D01FC2C  AFBB001C   SW K1, 28(SP)
9D01FC30  401B6000   MFC0 K1, Status
9D01FC34  AFBA0014   SW K0, 20(SP)
9D01FC38  AFBB0018   SW K1, 24(SP)
9D01FC3C  7C1B7844   INS K1, ZERO, 1, 15
9D01FC40  377B1800   ORI K1, K1, 6144
9D01FC44  409B6000   MTC0 K1, Status
9D01FC48  AFA30008   SW V1, 8(SP)
9D01FC4C  AFA20004   SW V0, 4(SP)
9D01FC50  AFA4000C   SW A0, 12(SP)
547:                     IFS0bits.T2IF = 0;
9D01FC54  3C02BF88   LUI V0, -16504
9D01FC58  8C431030   LW V1, 4144(V0)
9D01FC5C  7C034A44   INS V1, ZERO, 9, 1
9D01FC60  AC431030   SW V1, 4144(V0)
548:                 	GEN_0_PIN = ~ GEN_0_PIN;
9D01FC64  3C02BF88   LUI V0, -16504
9D01FC68  8C446330   LW A0, 25392(V0)
9D01FC6C  7C840040   EXT A0, A0, 1, 1
9D01FC70  38840001   XORI A0, A0, 1
9D01FC74  94436330   LHU V1, 25392(V0)
9D01FC78  7C830844   INS V1, A0, 1, 1
9D01FC7C  A4436330   SH V1, 25392(V0)
549:                 	rnd_var3++;
9D01FC80  978281B2   LHU V0, -32334(GP)
9D01FC84  24420001   ADDIU V0, V0, 1
9D01FC88  A78281B2   SH V0, -32334(GP)
550:                 	}
9D01FC8C  8FA20014   LW V0, 20(SP)
9D01FC90  3042000F   ANDI V0, V0, 15
9D01FC94  14400004   BNE V0, ZERO, 0x9D01FCA8
9D01FC98  00000000   NOP
9D01FC9C  8FA4000C   LW A0, 12(SP)
9D01FCA0  8FA30008   LW V1, 8(SP)
9D01FCA4  8FA20004   LW V0, 4(SP)
9D01FCA8  41606000   DI ZERO
9D01FCAC  000000C0   EHB
9D01FCB0  8FBA001C   LW K0, 28(SP)
9D01FCB4  8FBB0018   LW K1, 24(SP)
9D01FCB8  409A7000   MTC0 K0, EPC
9D01FCBC  8FBA0014   LW K0, 20(SP)
9D01FCC0  27BD0020   ADDIU SP, SP, 32
9D01FCC4  409A6002   MTC0 K0, SRSCtl
9D01FCC8  41DDE800   WRPGPR SP, SP
9D01FCCC  409B6000   MTC0 K1, Status
9D01FCD0  42000018   ERET
551:                 void __ISR(_TIMER_3_VECTOR, IPL6AUTO) Timer3Handler(void)
552:                 //void __ISR(_TIMER_3_VECTOR, ipl6) Timer3Handler(void)
553:                 	{
9D01FCD4  415DE800   RDPGPR SP, SP
9D01FCD8  401B7000   MFC0 K1, EPC
9D01FCDC  401A6002   MFC0 K0, SRSCtl
9D01FCE0  27BDFFE0   ADDIU SP, SP, -32
9D01FCE4  AFBB001C   SW K1, 28(SP)
9D01FCE8  401B6000   MFC0 K1, Status
9D01FCEC  AFBA0014   SW K0, 20(SP)
9D01FCF0  AFBB0018   SW K1, 24(SP)
9D01FCF4  7C1B7844   INS K1, ZERO, 1, 15
9D01FCF8  377B1800   ORI K1, K1, 6144
9D01FCFC  409B6000   MTC0 K1, Status
9D01FD00  AFA30008   SW V1, 8(SP)
9D01FD04  AFA20004   SW V0, 4(SP)
9D01FD08  AFA4000C   SW A0, 12(SP)
554:                     IFS0bits.T3IF = 0;
9D01FD0C  3C02BF88   LUI V0, -16504
9D01FD10  8C431030   LW V1, 4144(V0)
9D01FD14  7C037384   INS V1, ZERO, 14, 1
9D01FD18  AC431030   SW V1, 4144(V0)
555:                 	GEN_1_PIN = ~ GEN_1_PIN;
9D01FD1C  3C02BF88   LUI V0, -16504
9D01FD20  8C446330   LW A0, 25392(V0)
9D01FD24  7C840080   EXT A0, A0, 2, 1
9D01FD28  38840001   XORI A0, A0, 1
9D01FD2C  94436330   LHU V1, 25392(V0)
9D01FD30  7C831084   INS V1, A0, 2, 1
9D01FD34  A4436330   SH V1, 25392(V0)
556:                 	rnd_var3++;
9D01FD38  978281B2   LHU V0, -32334(GP)
9D01FD3C  24420001   ADDIU V0, V0, 1
9D01FD40  A78281B2   SH V0, -32334(GP)
557:                 	}
9D01FD44  8FA20014   LW V0, 20(SP)
9D01FD48  3042000F   ANDI V0, V0, 15
9D01FD4C  14400004   BNE V0, ZERO, 0x9D01FD60
9D01FD50  00000000   NOP
9D01FD54  8FA4000C   LW A0, 12(SP)
9D01FD58  8FA30008   LW V1, 8(SP)
9D01FD5C  8FA20004   LW V0, 4(SP)
9D01FD60  41606000   DI ZERO
9D01FD64  000000C0   EHB
9D01FD68  8FBA001C   LW K0, 28(SP)
9D01FD6C  8FBB0018   LW K1, 24(SP)
9D01FD70  409A7000   MTC0 K0, EPC
9D01FD74  8FBA0014   LW K0, 20(SP)
9D01FD78  27BD0020   ADDIU SP, SP, 32
9D01FD7C  409A6002   MTC0 K0, SRSCtl
9D01FD80  41DDE800   WRPGPR SP, SP
9D01FD84  409B6000   MTC0 K1, Status
9D01FD88  42000018   ERET
558:                 void __ISR(_TIMER_4_VECTOR, IPL6AUTO) Timer4Handler(void)
559:                 //void __ISR(_TIMER_4_VECTOR, ipl6) Timer4Handler(void)
560:                 	{
9D01FD8C  415DE800   RDPGPR SP, SP
9D01FD90  401B7000   MFC0 K1, EPC
9D01FD94  401A6002   MFC0 K0, SRSCtl
9D01FD98  27BDFFE0   ADDIU SP, SP, -32
9D01FD9C  AFBB001C   SW K1, 28(SP)
9D01FDA0  401B6000   MFC0 K1, Status
9D01FDA4  AFBA0014   SW K0, 20(SP)
9D01FDA8  AFBB0018   SW K1, 24(SP)
9D01FDAC  7C1B7844   INS K1, ZERO, 1, 15
9D01FDB0  377B1800   ORI K1, K1, 6144
9D01FDB4  409B6000   MTC0 K1, Status
9D01FDB8  AFA30008   SW V1, 8(SP)
9D01FDBC  AFA20004   SW V0, 4(SP)
9D01FDC0  AFA4000C   SW A0, 12(SP)
561:                     IFS0bits.T4IF = 0;
9D01FDC4  3C02BF88   LUI V0, -16504
9D01FDC8  8C431030   LW V1, 4144(V0)
9D01FDCC  7C039CC4   INS V1, ZERO, 19, 1
9D01FDD0  AC431030   SW V1, 4144(V0)
562:                 	GEN_2_PIN = ~ GEN_2_PIN;
9D01FDD4  3C02BF88   LUI V0, -16504
9D01FDD8  8C446330   LW A0, 25392(V0)
9D01FDDC  7C8400C0   EXT A0, A0, 3, 1
9D01FDE0  38840001   XORI A0, A0, 1
9D01FDE4  94436330   LHU V1, 25392(V0)
9D01FDE8  7C8318C4   INS V1, A0, 3, 1
9D01FDEC  A4436330   SH V1, 25392(V0)
563:                 	rnd_var3++;
9D01FDF0  978281B2   LHU V0, -32334(GP)
9D01FDF4  24420001   ADDIU V0, V0, 1
9D01FDF8  A78281B2   SH V0, -32334(GP)
564:                 	}
9D01FDFC  8FA20014   LW V0, 20(SP)
9D01FE00  3042000F   ANDI V0, V0, 15
9D01FE04  14400004   BNE V0, ZERO, 0x9D01FE18
9D01FE08  00000000   NOP
9D01FE0C  8FA4000C   LW A0, 12(SP)
9D01FE10  8FA30008   LW V1, 8(SP)
9D01FE14  8FA20004   LW V0, 4(SP)
9D01FE18  41606000   DI ZERO
9D01FE1C  000000C0   EHB
9D01FE20  8FBA001C   LW K0, 28(SP)
9D01FE24  8FBB0018   LW K1, 24(SP)
9D01FE28  409A7000   MTC0 K0, EPC
9D01FE2C  8FBA0014   LW K0, 20(SP)
9D01FE30  27BD0020   ADDIU SP, SP, 32
9D01FE34  409A6002   MTC0 K0, SRSCtl
9D01FE38  41DDE800   WRPGPR SP, SP
9D01FE3C  409B6000   MTC0 K1, Status
9D01FE40  42000018   ERET
565:                 
566:                 void exp_set(uint8_t pos, uint8_t val)
567:                 	{
568:                 	if (pos==0) EXP_0_OUT = val;
9D01FE44  54800007   BNEL A0, ZERO, 0x9D01FE64
9D01FE48  24020001   ADDIU V0, ZERO, 1
9D01FE4C  3C02BF88   LUI V0, -16504
9D01FE50  94436630   LHU V1, 26160(V0)
9D01FE54  7CA31084   INS V1, A1, 2, 1
9D01FE58  A4436630   SH V1, 26160(V0)
569:                 	if (pos==1) EXP_1_OUT = val;
9D01FE64  14820006   BNE A0, V0, 0x9D01FE80
9D01FE68  3C02BF88   LUI V0, -16504
9D01FE6C  94436630   LHU V1, 26160(V0)
9D01FE70  7CA318C4   INS V1, A1, 3, 1
9D01FE74  A4436630   SH V1, 26160(V0)
9D01FE78  03E00008   JR RA
9D01FE7C  00000000   NOP
570:                 	if (pos==2) EXP_2_OUT = val;
9D01FE80  24020002   ADDIU V0, ZERO, 2
9D01FE84  14820006   BNE A0, V0, 0x9D01FEA0
9D01FE88  3C02BF88   LUI V0, -16504
9D01FE8C  94436130   LHU V1, 24880(V0)
9D01FE90  7CA30004   INS V1, A1, 0, 1
9D01FE94  A4436130   SH V1, 24880(V0)
9D01FE98  03E00008   JR RA
9D01FE9C  00000000   NOP
571:                 	if (pos==3) EXP_3_OUT = val;
9D01FE5C  0B407FA9   J 0x9D01FEA4
9D01FE60  24020003   ADDIU V0, ZERO, 3
9D01FEA0  24020003   ADDIU V0, ZERO, 3
9D01FEA4  14820005   BNE A0, V0, 0x9D01FEBC
9D01FEA8  00000000   NOP
9D01FEAC  3C02BF88   LUI V0, -16504
9D01FEB0  94436130   LHU V1, 24880(V0)
9D01FEB4  7CA30844   INS V1, A1, 1, 1
9D01FEB8  A4436130   SH V1, 24880(V0)
9D01FEBC  03E00008   JR RA
9D01FEC0  00000000   NOP
572:                 	}
573:                 
574:                 void exp_ddr(uint8_t pos, uint8_t val)
575:                 	{
576:                 	if (pos==0) EXP_0_T = val;
9D01FEC4  54800007   BNEL A0, ZERO, 0x9D01FEE4
9D01FEC8  24020001   ADDIU V0, ZERO, 1
9D01FECC  3C02BF88   LUI V0, -16504
9D01FED0  94436610   LHU V1, 26128(V0)
9D01FED4  7CA31084   INS V1, A1, 2, 1
9D01FED8  A4436610   SH V1, 26128(V0)
577:                 	if (pos==1) EXP_1_T = val;
9D01FEE4  14820006   BNE A0, V0, 0x9D01FF00
9D01FEE8  3C02BF88   LUI V0, -16504
9D01FEEC  94436610   LHU V1, 26128(V0)
9D01FEF0  7CA318C4   INS V1, A1, 3, 1
9D01FEF4  A4436610   SH V1, 26128(V0)
9D01FEF8  03E00008   JR RA
9D01FEFC  00000000   NOP
578:                 	if (pos==2) EXP_2_T = val;
9D01FF00  24020002   ADDIU V0, ZERO, 2
9D01FF04  14820006   BNE A0, V0, 0x9D01FF20
9D01FF08  3C02BF88   LUI V0, -16504
9D01FF0C  94436110   LHU V1, 24848(V0)
9D01FF10  7CA30004   INS V1, A1, 0, 1
9D01FF14  A4436110   SH V1, 24848(V0)
9D01FF18  03E00008   JR RA
9D01FF1C  00000000   NOP
579:                 	if (pos==3) EXP_3_T = val;
9D01FEDC  0B407FC9   J 0x9D01FF24
9D01FEE0  24020003   ADDIU V0, ZERO, 3
9D01FF20  24020003   ADDIU V0, ZERO, 3
9D01FF24  14820005   BNE A0, V0, 0x9D01FF3C
9D01FF28  00000000   NOP
9D01FF2C  3C02BF88   LUI V0, -16504
9D01FF30  94436110   LHU V1, 24848(V0)
9D01FF34  7CA30844   INS V1, A1, 1, 1
9D01FF38  A4436110   SH V1, 24848(V0)
9D01FF3C  03E00008   JR RA
9D01FF40  00000000   NOP
580:                 	}
581:                 
582:                 uint8_t exp_get (uint8_t pos)
583:                 	{
584:                 	if (pos==0) return EXP_0_IN;
9D01FF44  54800005   BNEL A0, ZERO, 0x9D01FF5C
9D01FF48  24020001   ADDIU V0, ZERO, 1
9D01FF4C  3C02BF88   LUI V0, -16504
9D01FF50  8C426620   LW V0, 26144(V0)
9D01FF54  03E00008   JR RA
9D01FF58  7C420080   EXT V0, V0, 2, 1
585:                 	if (pos==1) return EXP_1_IN;
9D01FF5C  54820005   BNEL A0, V0, 0x9D01FF74
9D01FF60  24020002   ADDIU V0, ZERO, 2
9D01FF64  3C02BF88   LUI V0, -16504
9D01FF68  8C426620   LW V0, 26144(V0)
9D01FF6C  03E00008   JR RA
9D01FF70  7C4200C0   EXT V0, V0, 3, 1
586:                 	if (pos==2) return EXP_2_IN;
9D01FF74  14820005   BNE A0, V0, 0x9D01FF8C
9D01FF78  24030003   ADDIU V1, ZERO, 3
9D01FF7C  3C02BF88   LUI V0, -16504
9D01FF80  8C426120   LW V0, 24864(V0)
9D01FF84  03E00008   JR RA
9D01FF88  30420001   ANDI V0, V0, 1
587:                 	if (pos==3) return EXP_3_IN;
9D01FF8C  14830004   BNE A0, V1, 0x9D01FFA0
9D01FF90  00001021   ADDU V0, ZERO, ZERO
9D01FF94  3C02BF88   LUI V0, -16504
9D01FF98  8C426120   LW V0, 24864(V0)
9D01FF9C  7C420040   EXT V0, V0, 1, 1
588:                 	return 0;
589:                 	}
9D01FFA0  03E00008   JR RA
9D01FFA4  00000000   NOP
590:                 
591:                 void serial_flush (void)
592:                 	{
9D01FFC0  27BDFFE8   ADDIU SP, SP, -24
9D01FFC4  AFBF0014   SW RA, 20(SP)
9D01FFC8  AFB00010   SW S0, 16(SP)
593:                 	while (rx_sta()) rx_read();
9D01FFCC  0B407FF6   J .LBE95, .LBE94
9D01FFD0  3C10BF80   LUI S0, -16512
9D01FFD8  0F407FEA   JAL rx_sta
9D01FFDC  00000000   NOP
9D01FFE0  1440FFFC   BNE V0, ZERO, .LBB94, .LBB95
9D01FFE4  3C02BF80   LUI V0, -16512
594:                 	if (U3STAbits.OERR) U3STAbits.OERR = 0;
9D01FFE8  8C426410   LW V0, 25616(V0)
9D01FFEC  30420002   ANDI V0, V0, 2
9D01FFF0  50400008   BEQL V0, ZERO, .LBE97, .LBE96
9D01FFF4  3C10BF80   LUI S0, -16512
9D01FFF8  3C02BF80   LUI V0, -16512
9D01FFFC  8C436410   LW V1, 25616(V0)
9D020000  7C030844   INS V1, ZERO, 1, 1
9D020004  AC436410   SW V1, 25616(V0)
595:                 	while (rx_sta()) rx_read();
9D020014  0F407FEA   JAL rx_sta
9D020018  00000000   NOP
9D02001C  1440FFFC   BNE V0, ZERO, .LBB96, .LBB97
9D020020  8FBF0014   LW RA, 20(SP)
596:                 	}
9D020024  8FB00010   LW S0, 16(SP)
9D020028  03E00008   JR RA
9D02002C  27BD0018   ADDIU SP, SP, 24
597:                 
598:                 uint8_t rx_sta (void)
599:                 	{
600:                 	if (U3STAbits.URXDA==1) return 0xFF;
9D01FFA8  3C02BF80   LUI V0, -16512
9D01FFAC  8C426410   LW V0, 25616(V0)
9D01FFB0  30420001   ANDI V0, V0, 1
9D01FFB4  00021023   SUBU V0, ZERO, V0
601:                 	else return 0x00;
602:                 	}
9D01FFB8  03E00008   JR RA
9D01FFBC  304200FF   ANDI V0, V0, 255
603:                 
604:                 uint8_t rx_read (void)
605:                 	{
606:                 	uint8_t data;
607:                 	data = U3RXREG;
9D01FFD4  8E026430   LW V0, 25648(S0)
9D020008  0B408005   J .LBE97, .LBE96
9D02000C  3C10BF80   LUI S0, -16512
9D020010  8E026430   LW V0, 25648(S0)
9D020030  3C02BF80   LUI V0, -16512
9D020034  8C426430   LW V0, 25648(V0)
608:                 	return data;
609:                 	}
9D020038  03E00008   JR RA
9D02003C  304200FF   ANDI V0, V0, 255
610:                 void tx_write (uint8_t data)
611:                 	{   
612:                 	U3TXREG = data;
9D020040  3C02BF80   LUI V0, -16512
9D020044  AC446420   SW A0, 25632(V0)
613:                 	while (U3STAbits.UTXBF==1); 
9D020048  3C03BF80   LUI V1, -16512
9D02004C  8C626410   LW V0, 25616(V1)
9D020050  30420200   ANDI V0, V0, 512
9D020054  1440FFFD   BNE V0, ZERO, 0x9D02004C
9D020058  00000000   NOP
614:                 	}
9D02005C  03E00008   JR RA
9D020060  00000000   NOP
615:                 
---  /Users/nitro/basic-badge/firmware/badge1.X/src/disp.c  ---------------------------------------------
1:                   #include <xc.h>
2:                   #include "hw.h"
3:                   #include "disp.h"
4:                   #include "vt100.h"
5:                   #include <stdint.h>
6:                   
7:                   
8:                   const int8_t font[(96+128)*12] = 
9:                   {
10:                  0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000,   
11:                  0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0000000, 0b0001000, 0b0000000, 0b0000000,   
12:                  0b0101000, 0b0101000, 0b0101000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000,   
13:                  0b0010100, 0b0010100, 0b0010100, 0b1111111, 0b0010100, 0b0010100, 0b1111111, 0b0010100, 0b0010100, 0b0010100, 0b0000000, 0b0000000,   
14:                  0b0010100, 0b0111110, 0b1010101, 0b1010100, 0b0111110, 0b0010101, 0b0010101, 0b1010101, 0b0111110, 0b0010100, 0b0000000, 0b0000000,   
15:                  0b0000000, 0b1110000, 0b1010001, 0b1110010, 0b0000100, 0b0001000, 0b0010000, 0b0100111, 0b1000101, 0b0000111, 0b0000000, 0b0000000,   
16:                  0b0111000, 0b1000100, 0b1000100, 0b1001000, 0b0110000, 0b0110000, 0b1001000, 0b1000101, 0b1000010, 0b0111101, 0b0000000, 0b0000000,   
17:                  0b0011000, 0b0011000, 0b0010000, 0b0100000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000,   
18:                  0b0000010, 0b0000100, 0b0001000, 0b0010000, 0b0010000, 0b0010000, 0b0010000, 0b0001000, 0b0000100, 0b0000010, 0b0000000, 0b0000000,   
19:                  0b0100000, 0b0010000, 0b0001000, 0b0000100, 0b0000100, 0b0000100, 0b0000100, 0b0001000, 0b0010000, 0b0100000, 0b0000000, 0b0000000,   
20:                  0b0000000, 0b0001000, 0b1001001, 0b0101010, 0b0011100, 0b1111111, 0b0011100, 0b0101010, 0b1001001, 0b0001000, 0b0000000, 0b0000000,   
21:                  0b0000000, 0b0000000, 0b0001000, 0b0001000, 0b0001000, 0b1111111, 0b0001000, 0b0001000, 0b0001000, 0b0000000, 0b0000000, 0b0000000,   
22:                  0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0011000, 0b0011000, 0b0010000, 0b0100000, 0b0000000, 0b0000000,   
23:                  0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b1111111, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000,   
24:                  0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0110000, 0b0110000, 0b0000000, 0b0000000,   
25:                  0b0000000, 0b0000000, 0b0000001, 0b0000010, 0b0000100, 0b0001000, 0b0010000, 0b0100000, 0b1000000, 0b0000000, 0b0000000, 0b0000000,   
26:                  0b0011100, 0b0100010, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b0100010, 0b0011100, 0b0000000, 0b0000000,   
27:                  0b0001000, 0b0011000, 0b0101000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0111110, 0b0000000, 0b0000000,   
28:                  0b0111110, 0b1000001, 0b1000001, 0b0000001, 0b0000010, 0b0000100, 0b0001000, 0b0010000, 0b0100000, 0b1111111, 0b0000000, 0b0000000,   
29:                  0b0111110, 0b1000001, 0b0000001, 0b0000010, 0b0001100, 0b0000010, 0b0000001, 0b0000001, 0b1000001, 0b0111110, 0b0000000, 0b0000000,   
30:                  0b0000010, 0b0000110, 0b0001010, 0b0010010, 0b0100010, 0b1000010, 0b1000010, 0b1111111, 0b0000010, 0b0000010, 0b0000000, 0b0000000,   
31:                  0b1111111, 0b1000000, 0b1000000, 0b1111100, 0b0000010, 0b0000001, 0b0000001, 0b0000001, 0b1000010, 0b0111100, 0b0000000, 0b0000000,   
32:                  0b0001110, 0b0010000, 0b0100000, 0b1000000, 0b1111110, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b0111110, 0b0000000, 0b0000000,   
33:                  0b1111111, 0b0000001, 0b0000001, 0b0000010, 0b0000100, 0b0001000, 0b0010000, 0b0100000, 0b0100000, 0b0100000, 0b0000000, 0b0000000,   
34:                  0b0111110, 0b1000001, 0b1000001, 0b0100010, 0b0011100, 0b0100010, 0b1000001, 0b1000001, 0b1000001, 0b0111110, 0b0000000, 0b0000000,   
35:                  0b0111110, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b0111111, 0b0000001, 0b0000010, 0b0000100, 0b0111000, 0b0000000, 0b0000000,   
36:                  0b0000000, 0b0011000, 0b0011000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0011000, 0b0011000, 0b0000000, 0b0000000, 0b0000000,   
37:                  0b0000000, 0b0011000, 0b0011000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0011000, 0b0011000, 0b0010000, 0b0000000, 0b0000000,   
38:                  0b0000000, 0b0000010, 0b0000100, 0b0001000, 0b0010000, 0b0100000, 0b0010000, 0b0001000, 0b0000100, 0b0000010, 0b0000000, 0b0000000,   
39:                  0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b1111111, 0b0000000, 0b1111111, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000,   
40:                  0b0000000, 0b0100000, 0b0010000, 0b0001000, 0b0000100, 0b0000010, 0b0000100, 0b0001000, 0b0010000, 0b0100000, 0b0000000, 0b0000000,   
41:                  0b0111110, 0b1000001, 0b0000001, 0b0000010, 0b0000100, 0b0001000, 0b0010000, 0b0010000, 0b0000000, 0b0010000, 0b0000000, 0b0000000,   
42:                  0b0011100, 0b0100010, 0b1000001, 0b1001001, 0b1010101, 0b1010110, 0b1001000, 0b1000000, 0b0100001, 0b0011110, 0b0000000, 0b0000000,   
43:                  0b0001000, 0b0010100, 0b0100010, 0b1000001, 0b1000001, 0b1000001, 0b1111111, 0b1000001, 0b1000001, 0b1000001, 0b0000000, 0b0000000,   
44:                  0b1111110, 0b1000001, 0b1000001, 0b1000010, 0b1111100, 0b1000010, 0b1000001, 0b1000001, 0b1000001, 0b1111110, 0b0000000, 0b0000000,   
45:                  0b0111110, 0b1000001, 0b1000000, 0b1000000, 0b1000000, 0b1000000, 0b1000000, 0b1000000, 0b1000001, 0b0111110, 0b0000000, 0b0000000,   
46:                  0b1111100, 0b1000010, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000010, 0b1111100, 0b0000000, 0b0000000,  
47:                  0b1111111, 0b1000000, 0b1000000, 0b1000000, 0b1000000, 0b1111110, 0b1000000, 0b1000000, 0b1000000, 0b1111111, 0b0000000, 0b0000000,   
48:                  0b1111111, 0b1000000, 0b1000000, 0b1000000, 0b1000000, 0b1111110, 0b1000000, 0b1000000, 0b1000000, 0b1000000, 0b0000000, 0b0000000,   
49:                  0b0111110, 0b1000001, 0b1000000, 0b1000000, 0b1000000, 0b1001111, 0b1000001, 0b1000001, 0b1000001, 0b0111110, 0b0000000, 0b0000000,   
50:                  0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1111111, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b0000000, 0b0000000,   
51:                  0b0011100, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0011100, 0b0000000, 0b0000000,   
52:                  0b0000001, 0b0000001, 0b0000001, 0b0000001, 0b0000001, 0b0000001, 0b1000001, 0b1000001, 0b0100010, 0b0011100, 0b0000000, 0b0000000,   
53:                  0b1000001, 0b1000010, 0b1000100, 0b1001000, 0b1110000, 0b1010000, 0b1001000, 0b1000100, 0b1000010, 0b1000001, 0b0000000, 0b0000000,   
54:                  0b1000000, 0b1000000, 0b1000000, 0b1000000, 0b1000000, 0b1000000, 0b1000000, 0b1000000, 0b1000000, 0b1111111, 0b0000000, 0b0000000,   
55:                  0b1000001, 0b1100011, 0b1010101, 0b1001001, 0b1001001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b0000000, 0b0000000,   
56:                  0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1100001, 0b1010001, 0b1001001, 0b1000101, 0b1000011, 0b1000001, 0b0000000, 0b0000000,   
57:                  0b0111110, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b0111110, 0b0000000, 0b0000000,   
58:                  0b1111110, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1111110, 0b1000000, 0b1000000, 0b1000000, 0b1000000, 0b0000000, 0b0000000,   
59:                  0b0111110, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000101, 0b1000010, 0b0111101, 0b0000000, 0b0000000,   
60:                  0b1111110, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1111110, 0b1001000, 0b1000100, 0b1000010, 0b1000001, 0b0000000, 0b0000000,   
61:                  0b0111110, 0b1000001, 0b1000000, 0b0100000, 0b0011100, 0b0000010, 0b0000001, 0b0000001, 0b1000001, 0b0111110, 0b0000000, 0b0000000,   
62:                  0b1111111, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0000000, 0b0000000,   
63:                  0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b0111110, 0b0000000, 0b0000000,   
64:                  0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b0100010, 0b0010100, 0b0001000, 0b0000000, 0b0000000,   
65:                  0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1001001, 0b1010101, 0b1100011, 0b1000001, 0b0000000, 0b0000000,   
66:                  0b1000001, 0b1000001, 0b1000001, 0b0100010, 0b0010100, 0b0001000, 0b0010100, 0b0100010, 0b1000001, 0b1000001, 0b0000000, 0b0000000,   
67:                  0b1000001, 0b1000001, 0b1000001, 0b0100010, 0b0010100, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0000000, 0b0000000,   
68:                  0b1111111, 0b0000001, 0b0000001, 0b0000010, 0b0000100, 0b0001000, 0b0010000, 0b0100000, 0b1000000, 0b1111111, 0b0000000, 0b0000000,   
69:                  0b0011100, 0b0010000, 0b0010000, 0b0010000, 0b0010000, 0b0010000, 0b0010000, 0b0010000, 0b0010000, 0b0011100, 0b0000000, 0b0000000,   
70:                  0b0000000, 0b0000000, 0b1000000, 0b0100000, 0b0010000, 0b0001000, 0b0000100, 0b0000010, 0b0000001, 0b0000000, 0b0000000, 0b0000000,   
71:                  0b0011100, 0b0000100, 0b0000100, 0b0000100, 0b0000100, 0b0000100, 0b0000100, 0b0000100, 0b0000100, 0b0011100, 0b0000000, 0b0000000,   
72:                  0b0001000, 0b0010100, 0b0100010, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000,   
73:                  0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b1111111, 0b0000000, 0b0000000,   
74:                  0b0010000, 0b0001000, 0b0000100, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000,   
75:                  0b0000000, 0b0000000, 0b0000000, 0b0111100, 0b0000010, 0b0000001, 0b0111111, 0b1000001, 0b1000011, 0b0111101, 0b0000000, 0b0000000,   
76:                  0b1000000, 0b1000000, 0b1000000, 0b1111100, 0b1000010, 0b1000001, 0b1000001, 0b1000001, 0b1000010, 0b1111100, 0b0000000, 0b0000000,   
77:                  0b0000000, 0b0000000, 0b0000000, 0b0011111, 0b0100000, 0b1000000, 0b1000000, 0b1000000, 0b0100000, 0b0011111, 0b0000000, 0b0000000,   
78:                  0b0000001, 0b0000001, 0b0000001, 0b0011111, 0b0100001, 0b1000001, 0b1000001, 0b1000001, 0b0100001, 0b0011111, 0b0000000, 0b0000000,   
79:                  0b0000000, 0b0000000, 0b0000000, 0b0111110, 0b1000001, 0b1000001, 0b1111111, 0b1000000, 0b1000000, 0b0111111, 0b0000000, 0b0000000,   
80:                  0b0000110, 0b0001000, 0b0001000, 0b0001000, 0b0011110, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0011100, 0b0000000, 0b0000000,   
81:                  0b0000000, 0b0000000, 0b0000000, 0b0011100, 0b0100010, 0b1000001, 0b1000001, 0b0100001, 0b0011111, 0b0000001, 0b0000001, 0b0011110,   
82:                  0b1000000, 0b1000000, 0b1000000, 0b1000000, 0b1011100, 0b1100010, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b0000000, 0b0000000,   
83:                  0b0000000, 0b0001000, 0b0000000, 0b0011000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0011100, 0b0000000, 0b0000000,   
84:                  0b0000000, 0b0000100, 0b0000000, 0b0001100, 0b0000100, 0b0000100, 0b0000100, 0b0000100, 0b0000100, 0b0000100, 0b0100100, 0b0011000,   
85:                  0b1000000, 0b1000000, 0b1000000, 0b1000011, 0b1000100, 0b1001000, 0b1011000, 0b1100100, 0b1000010, 0b1000001, 0b0000000, 0b0000000,   
86:                  0b0011000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0011100, 0b0000000, 0b0000000,   
87:                  0b0000000, 0b0000000, 0b0000000, 0b1010110, 0b1101001, 0b1001001, 0b1001001, 0b1001001, 0b1001001, 0b1001001, 0b0000000, 0b0000000,   
88:                  0b0000000, 0b0000000, 0b0000000, 0b1011100, 0b1100010, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b0000000, 0b0000000,   
89:                  0b0000000, 0b0000000, 0b0000000, 0b0011100, 0b0100010, 0b1000001, 0b1000001, 0b1000001, 0b0100010, 0b0011100, 0b0000000, 0b0000000,   
90:                  0b0000000, 0b0000000, 0b0000000, 0b1111100, 0b1000010, 0b1000001, 0b1000001, 0b1000010, 0b1111100, 0b1000000, 0b1000000, 0b1000000,   
91:                  0b0000000, 0b0000000, 0b0000000, 0b0011111, 0b0100001, 0b1000001, 0b1000001, 0b0100001, 0b0011111, 0b0000001, 0b0000001, 0b0000001,   
92:                  0b0000000, 0b0000000, 0b0000000, 0b1011110, 0b1100001, 0b1000000, 0b1000000, 0b1000000, 0b1000000, 0b1000000, 0b0000000, 0b0000000,   
93:                  0b0000000, 0b0000000, 0b0000000, 0b0111111, 0b1000000, 0b1000000, 0b0111110, 0b0000001, 0b0000001, 0b1111110, 0b0000000, 0b0000000,   
94:                  0b0010000, 0b0010000, 0b0010000, 0b0111100, 0b0010000, 0b0010000, 0b0010000, 0b0010000, 0b0010010, 0b0001100, 0b0000000, 0b0000000,   
95:                  0b0000000, 0b0000000, 0b0000000, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000011, 0b0111101, 0b0000000, 0b0000000,   
96:                  0b0000000, 0b0000000, 0b0000000, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b0100010, 0b0010100, 0b0001000, 0b0000000, 0b0000000,   
97:                  0b0000000, 0b0000000, 0b0000000, 0b1000001, 0b1000001, 0b1000001, 0b1001001, 0b1010101, 0b1100011, 0b1000001, 0b0000000, 0b0000000,   
98:                  0b0000000, 0b0000000, 0b0000000, 0b1000001, 0b0100010, 0b0010100, 0b0001000, 0b0010100, 0b0100010, 0b1000001, 0b0000000, 0b0000000,   
99:                  0b0000000, 0b0000000, 0b0000000, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b0100001, 0b0011111, 0b0000001, 0b0000010, 0b0111100,   
100:                 0b0000000, 0b0000000, 0b0000000, 0b1111111, 0b0000010, 0b0000100, 0b0001000, 0b0010000, 0b0100000, 0b1111111, 0b0000000, 0b0000000,   
101:                 0b0000110, 0b0001000, 0b0001000, 0b0001000, 0b0010000, 0b0100000, 0b0010000, 0b0001000, 0b0001000, 0b0001000, 0b0000110, 0b0000000,   
102:                 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0000000, 0b0000000,   
103:                 0b0110000, 0b0001000, 0b0001000, 0b0001000, 0b0000100, 0b0000010, 0b0000100, 0b0001000, 0b0001000, 0b0001000, 0b0110000, 0b0000000,   
104:                 0b0000000, 0b0000000, 0b0000000, 0b0110000, 0b1001000, 0b0001001, 0b0000110, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000,   
105:                 0b1111111, 0b1111111, 0b1111111, 0b1111111, 0b1111111, 0b1111111, 0b1111111, 0b1111111, 0b1111111, 0b1111111, 0b0000000, 0b0000000,
106:                 
107:                 0b0011100, 0b0100010, 0b1000001, 0b1000000, 0b1000000, 0b1000000, 0b1000000, 0b1000001, 0b0100010, 0b0011100, 0b0001000, 0b0111000, 
108:                 0b0000000, 0b0100010, 0b0000000, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000011, 0b0111101, 0b0000000, 0b0000000, 
109:                 0b0000100, 0b0001000, 0b0000000, 0b0111110, 0b1000001, 0b1000001, 0b1111111, 0b1000000, 0b1000000, 0b0111111, 0b0000000, 0b0000000, 
110:                 0b0001000, 0b0010100, 0b0000000, 0b0111100, 0b0000010, 0b0000001, 0b0111111, 0b1000001, 0b1000011, 0b0111101, 0b0000000, 0b0000000, 
111:                 0b0000000, 0b0100010, 0b0000000, 0b0111100, 0b0000010, 0b0000001, 0b0111111, 0b1000001, 0b1000011, 0b0111101, 0b0000000, 0b0000000, 
112:                 0b0010000, 0b0001000, 0b0000000, 0b0111100, 0b0000010, 0b0000001, 0b0111111, 0b1000001, 0b1000011, 0b0111101, 0b0000000, 0b0000000, 
113:                 0b0001000, 0b0010100, 0b0001000, 0b0111100, 0b0000010, 0b0000001, 0b0111111, 0b1000001, 0b1000011, 0b0111101, 0b0000000, 0b0000000, 
114:                 0b0000000, 0b0000000, 0b0000000, 0b0011111, 0b0100000, 0b1000000, 0b1000000, 0b1000000, 0b0100000, 0b0011111, 0b0000100, 0b0011100, 
115:                 0b0001000, 0b0010100, 0b0000000, 0b0111110, 0b1000001, 0b1000001, 0b1111111, 0b1000000, 0b1000000, 0b0111111, 0b0000000, 0b0000000, 
116:                 0b0000000, 0b0100010, 0b0000000, 0b0111110, 0b1000001, 0b1000001, 0b1111111, 0b1000000, 0b1000000, 0b0111111, 0b0000000, 0b0000000, 
117:                 0b0001000, 0b0000100, 0b0000000, 0b0111110, 0b1000001, 0b1000001, 0b1111111, 0b1000000, 0b1000000, 0b0111111, 0b0000000, 0b0000000, 
118:                 0b0000000, 0b0100100, 0b0000000, 0b0011000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0011100, 0b0000000, 0b0000000, 
119:                 0b0001000, 0b0010100, 0b0000000, 0b0011000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0011100, 0b0000000, 0b0000000, 
120:                 0b0001000, 0b0000100, 0b0000000, 0b0011000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0011100, 0b0000000, 0b0000000, 
121:                 0b0100010, 0b0001000, 0b0010100, 0b0100010, 0b1000001, 0b1000001, 0b1111111, 0b1000001, 0b1000001, 0b1000001, 0b0000000, 0b0000000, 
122:                 0b0001000, 0b0010100, 0b0001000, 0b0010100, 0b0100010, 0b1000001, 0b1000001, 0b1111111, 0b1000001, 0b1000001, 0b0000000, 0b0000000, 
123:                 0b0001000, 0b0010000, 0b1111111, 0b1000000, 0b1000000, 0b1000000, 0b1111110, 0b1000000, 0b1000000, 0b1111111, 0b0000000, 0b0000000, 
124:                 0b0000000, 0b0000000, 0b0000000, 0b0110110, 0b0001001, 0b0001001, 0b0111111, 0b1001000, 0b1001000, 0b0111111, 0b0000000, 0b0000000, 
125:                 0b0011111, 0b0101000, 0b1001000, 0b1001000, 0b1001111, 0b1111000, 0b1001000, 0b1001000, 0b1001000, 0b1001111, 0b0000000, 0b0000000, 
126:                 0b0001000, 0b0010100, 0b0000000, 0b0011100, 0b0100010, 0b1000001, 0b1000001, 0b1000001, 0b0100010, 0b0011100, 0b0000000, 0b0000000, 
127:                 0b0000000, 0b0100010, 0b0000000, 0b0011100, 0b0100010, 0b1000001, 0b1000001, 0b1000001, 0b0100010, 0b0011100, 0b0000000, 0b0000000, 
128:                 0b0010000, 0b0001000, 0b0000000, 0b0011100, 0b0100010, 0b1000001, 0b1000001, 0b1000001, 0b0100010, 0b0011100, 0b0000000, 0b0000000, 
129:                 0b0001000, 0b0010100, 0b0000000, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000011, 0b0111101, 0b0000000, 0b0000000, 
130:                 0b0010000, 0b0001000, 0b0000000, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000011, 0b0111101, 0b0000000, 0b0000000, 
131:                 0b0000000, 0b0100010, 0b0000000, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b0100001, 0b0011111, 0b0000001, 0b0000010, 0b0111100, 
132:                 0b0100010, 0b0000000, 0b0111110, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b0111110, 0b0000000, 0b0000000, 
133:                 0b0100010, 0b0000000, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b0111110, 0b0000000, 0b0000000, 
134:                 0b0000000, 0b0000100, 0b0000100, 0b0011111, 0b0100100, 0b1000100, 0b1000100, 0b1000100, 0b0100100, 0b0011111, 0b0000100, 0b0000100, 
135:                 0b0111100, 0b1000010, 0b1000001, 0b0100000, 0b0100000, 0b1111000, 0b0100000, 0b0100000, 0b1000000, 0b1111111, 0b0000000, 0b0000000, 
136:                 0b1000001, 0b1000001, 0b0100010, 0b0010100, 0b0001000, 0b0001000, 0b0111110, 0b0001000, 0b0111110, 0b0001000, 0b0000000, 0b0000000, 
137:                 0b1111100, 0b1000010, 0b1000001, 0b1000010, 0b1111100, 0b1000011, 0b1010010, 0b1111101, 0b1010001, 0b1011011, 0b0000000, 0b0000000, 
138:                 0b0000000, 0b0000000, 0b0000011, 0b0000100, 0b0001000, 0b0111110, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0010000, 0b1100000, 
139:                 0b0000100, 0b0001000, 0b0000000, 0b0111100, 0b0000010, 0b0000001, 0b0111111, 0b1000001, 0b1000011, 0b0111101, 0b0000000, 0b0000000, 
140:                 0b0000100, 0b0001000, 0b0000000, 0b0011000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0011100, 0b0000000, 0b0000000, 
141:                 0b0000100, 0b0001000, 0b0000000, 0b0011100, 0b0100010, 0b1000001, 0b1000001, 0b1000001, 0b0100010, 0b0011100, 0b0000000, 0b0000000, 
142:                 0b0000100, 0b0001000, 0b0000000, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000011, 0b0111101, 0b0000000, 0b0000000, 
143:                 0b0010000, 0b0101010, 0b0000100, 0b1011100, 0b1100010, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b0000000, 0b0000000, 
144:                 0b0010000, 0b0101010, 0b0000100, 0b1000001, 0b1100001, 0b1010001, 0b1001001, 0b1000101, 0b1000011, 0b1000001, 0b0000000, 0b0000000, 
145:                 0b0011100, 0b0000010, 0b0011110, 0b0100010, 0b0011110, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 
146:                 0b0011000, 0b0100100, 0b0100100, 0b0011000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 
147:                 0b0000000, 0b0001000, 0b0000000, 0b0001000, 0b0001000, 0b0010000, 0b0100000, 0b1000000, 0b1000001, 0b0100010, 0b0011100, 0b0000000, 
148:                 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b1111111, 0b1000000, 0b1000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 
149:                 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b1111111, 0b0000001, 0b0000001, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 
150:                 0b0000000, 0b0000000, 0b0100000, 0b0100001, 0b0100010, 0b0000100, 0b0001000, 0b0010111, 0b0100001, 0b1000111, 0b0000100, 0b0000111, 
151:                 0b0000000, 0b0100000, 0b0100000, 0b0100001, 0b0000010, 0b0000100, 0b0001000, 0b0010101, 0b0100101, 0b1000111, 0b0000001, 0b0000001, 
152:                 0b0000000, 0b0001000, 0b0000000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0000000, 0b0000000, 
153:                 0b0000000, 0b0000000, 0b0001001, 0b0010010, 0b0100100, 0b1001000, 0b0100100, 0b0010010, 0b0001001, 0b0000000, 0b0000000, 0b0000000, 
154:                 0b0000000, 0b0000000, 0b1001000, 0b0100100, 0b0010010, 0b0001001, 0b0010010, 0b0100100, 0b1001000, 0b0000000, 0b0000000, 0b0000000, 
155:                 0b10001000, 0b00100010, 0b10001000, 0b00100010, 0b10001000, 0b00100010, 0b10001000, 0b00100010, 0b10001000, 0b00100010, 0b10001000, 
156:                 0b00100010, 0b10101010, 0b01010101, 0b10101010, 0b01010101, 0b10101010, 0b01010101, 0b10101010, 0b01010101, 0b10101010, 0b01010101, 
157:                 0b10101010, 0b01010101, 0b01110111, 0b11011101, 0b01110111, 0b11011101, 0b01110111, 0b11011101, 0b01110111, 0b11011101, 0b01110111, 
158:                 0b11011101, 0b01110111, 0b11011101, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 
159:                 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b11111000, 0b00001000, 
160:                 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b11111000, 0b00001000, 
161:                 0b00001000, 0b11111000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 
162:                 0b11100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 
163:                 0b00000000, 0b11111100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00000000, 0b00000000, 0b00000000, 
164:                 0b00000000, 0b11111000, 0b00001000, 0b00001000, 0b11111000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00100100, 0b00100100, 
165:                 0b00100100, 0b00100100, 0b11100100, 0b00000100, 0b00000100, 0b11100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 
166:                 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 
167:                 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b11111100, 0b00000100, 0b00000100, 0b11100100, 0b00100100, 0b00100100, 0b00100100, 
168:                 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b11100100, 0b00000100, 0b00000100, 0b11111100, 0b00000000, 0b00000000, 
169:                 0b00000000, 0b00000000, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b11111100, 0b00000000, 0b00000000, 0b00000000, 
170:                 0b00000000, 0b00000000, 0b00000000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b11111000, 0b00001000, 0b00001000, 0b11111000, 
171:                 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b11111000, 0b00001000, 
172:                 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001111, 
173:                 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 
174:                 0b11111111, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 
175:                 0b00000000, 0b11111111, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 
176:                 0b00001000, 0b00001000, 0b00001111, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00000000, 0b00000000, 
177:                 0b00000000, 0b00000000, 0b00000000, 0b11111111, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00001000, 
178:                 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b11111111, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 
179:                 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001111, 0b00001000, 0b00001000, 0b00001111, 0b00001000, 0b00001000, 0b00001000, 
180:                 0b00001000, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100111, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 
181:                 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100111, 0b00100000, 0b00100000, 0b00111111, 0b00000000, 
182:                 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00111111, 0b00100000, 0b00100000, 0b00100111, 
183:                 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b11100111, 0b00000000, 0b00000000, 
184:                 0b11111111, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b11111111, 0b00000000, 
185:                 0b00000000, 0b11100111, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100111, 
186:                 0b00100000, 0b00100000, 0b00100111, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 
187:                 0b11111111, 0b00000000, 0b00000000, 0b11111111, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00100100, 0b00100100, 0b00100100, 
188:                 0b00100100, 0b11100111, 0b00000000, 0b00000000, 0b11100111, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00001000, 0b00001000, 
189:                 0b00001000, 0b00001000, 0b11111111, 0b00000000, 0b00000000, 0b11111111, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00100100, 
190:                 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b11111111, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 
191:                 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b11111111, 0b00000000, 0b00000000, 0b11111111, 0b00001000, 0b00001000, 0b00001000, 
192:                 0b00001000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b11111111, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 
193:                 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00111111, 0b00000000, 0b00000000, 0b00000000, 
194:                 0b00000000, 0b00000000, 0b00000000, 0b00010000, 0b00010000, 0b00010000, 0b00010000, 0b00011111, 0b00010000, 0b00010000, 0b00011111, 
195:                 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00011111, 0b00010000, 0b00010000, 
196:                 0b00011111, 0b00010000, 0b00010000, 0b00010000, 0b00010000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00111111, 
197:                 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 
198:                 0b11111111, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 
199:                 0b11111111, 0b00001000, 0b00001000, 0b11111111, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 
200:                 0b00001000, 0b00001000, 0b11111000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 
201:                 0b00000000, 0b00000000, 0b00000000, 0b00001111, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b11111111, 
202:                 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 
203:                 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 
204:                 0b11111111, 0b11110000, 0b11110000, 0b11110000, 0b11110000, 0b11110000, 0b11110000, 0b11110000, 0b11110000, 0b11110000, 0b11110000, 
205:                 0b11110000, 0b11110000, 0b00001111, 0b00001111, 0b00001111, 0b00001111, 0b00001111, 0b00001111, 0b00001111, 0b00001111, 0b00001111, 
206:                 0b00001111, 0b00001111, 0b00001111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b00000000, 0b00000000, 
207:                 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b0000000, 0b0000000, 0b0000000, 0b0111001, 0b1000110, 0b1000010, 0b1000010, 
208:                 0b1000010, 0b1000110, 0b0111001, 0b0000000, 0b0000000, 0b0001110, 0b0010001, 0b0100001, 0b0100010, 0b0111100, 0b0100010, 
209:                 0b0100001, 0b0100001, 0b0110001, 0b0101110, 0b1000000, 0b0000000, 0b0111111, 0b0100001, 0b0100000, 0b0100000, 0b0100000, 
210:                 0b0100000, 0b0100000, 0b0100000, 0b0100000, 0b0100000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b1111111, 
211:                 0b0100010, 0b0100010, 0b0100010, 0b0100010, 0b0100010, 0b0100010, 0b0000000, 0b0000000, 0b1111111, 0b1000001, 0b0100000, 
212:                 0b0010000, 0b0001000, 0b0010000, 0b0100000, 0b1000000, 0b1000001, 0b1111111, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 
213:                 0b0000000, 0b0111111, 0b1000100, 0b1000010, 0b1000001, 0b1000001, 0b1000001, 0b0111110, 0b0000000, 0b0000000, 0b0000000, 
214:                 0b0000000, 0b0000000, 0b1000010, 0b1000010, 0b1000010, 0b1000010, 0b1000010, 0b1100010, 0b1011101, 0b1000000, 0b1000000, 
215:                 0b0000000, 0b0000000, 0b0000000, 0b1111111, 0b0010000, 0b0010000, 0b0010000, 0b0010000, 0b0010000, 0b0001110, 0b0000000, 
216:                 0b0000000, 0b0011100, 0b0001000, 0b0111110, 0b1001001, 0b1001001, 0b1001001, 0b1001001, 0b0111110, 0b0001000, 0b0011100, 
217:                 0b0000000, 0b0000000, 0b0011100, 0b0100010, 0b1000001, 0b1000001, 0b1011101, 0b1000001, 0b1000001, 0b1000001, 0b0100010, 
218:                 0b0011100, 0b0000000, 0b0000000, 0b0111110, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b0100010, 
219:                 0b0100010, 0b1100011, 0b0000000, 0b0000000, 0b0000000, 0b1111111, 0b0100000, 0b0010000, 0b0011000, 0b0100100, 0b1000010, 
220:                 0b1000001, 0b1000001, 0b0111110, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0100000, 0b1010110, 0b1001001, 
221:                 0b0110101, 0b0000010, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0100000, 0b1000110, 0b1001001, 0b1001001, 
222:                 0b1001001, 0b0111110, 0b0001000, 0b0001000, 0b0001000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0111111, 
223:                 0b1000000, 0b1000000, 0b0111000, 0b1000000, 0b1000001, 0b0111110, 0b0000000, 0b0000000, 0b0011100, 0b0100010, 0b1000001, 
224:                 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 
225:                 0b0000000, 0b1111111, 0b0000000, 0b1111111, 0b0000000, 0b1111111, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0001000, 
226:                 0b0001000, 0b0001000, 0b1111111, 0b0001000, 0b0001000, 0b0001000, 0b0000000, 0b1111111, 0b0000000, 0b0000000, 0b0000000, 
227:                 0b0000000, 0b1000000, 0b0110000, 0b0001100, 0b0000011, 0b0001100, 0b0110000, 0b1000000, 0b0000000, 0b1111111, 0b0000000, 
228:                 0b0000000, 0b0000000, 0b0000001, 0b0000110, 0b0011000, 0b1100000, 0b0011000, 0b0000110, 0b0000001, 0b0000000, 0b1111111, 
229:                 0b0000000, 0b0000000, 0b0001100, 0b0010000, 0b0010000, 0b0010000, 0b0010000, 0b0010000, 0b0010000, 0b0010000, 0b0010000, 
230:                 0b0010000, 0b0010000, 0b0010000, 0b0000100, 0b0000100, 0b0000100, 0b0000100, 0b0000100, 0b0000100, 0b0000100, 0b0000100, 
231:                 0b0000100, 0b0000100, 0b0000100, 0b0011000, 0b0000000, 0b0000000, 0b0000000, 0b0001000, 0b0000000, 0b1111111, 0b0000000, 
232:                 0b0001000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0110000, 0b1001001, 0b0000110, 0b0000000, 
233:                 0b0110000, 0b1001001, 0b0000110, 0b0000000, 0b0000000, 0b0000000, 0b0011000, 0b0100100, 0b0100100, 0b0011000, 0b0000000, 
234:                 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 
235:                 0b0011000, 0b0111100, 0b0111100, 0b0011000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 
236:                 0b0000000, 0b0000000, 0b0001000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000111, 0b0000100, 
237:                 0b1100100, 0b0100100, 0b0100100, 0b0100100, 0b0100100, 0b0100100, 0b0010100, 0b0001000, 0b0000000, 0b0000000, 0b0101100, 
238:                 0b0110010, 0b0100010, 0b0100010, 0b0100010, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 
239:                 0b0111000, 0b0000100, 0b0011000, 0b0100000, 0b0111100, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 
240:                 0b0000000, 0b0000000, 0b0000000, 0b1111111, 0b1111111, 0b1111111, 0b1111111, 0b1111111, 0b1111111, 0b1111111, 0b0000000, 
241:                 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 
242:                 0b0000000, 0b0000000, 0b0000000,
243:                 
244:                 
245:                 	};
246:                 
247:                 
248:                 uint32_t color_table[16] = {
249:                 	0x000000,	//0
250:                 	0x0000AA,	//1
251:                 	0x00AA00,	//2
252:                 	0x00AAAA,	//3
253:                 	0xAA0000,	//4
254:                 	0xAA00AA,	//5
255:                 	0xAA5500,	//6
256:                 	0xAAAAAA,	//7
257:                 	0x555555,	//8
258:                 	0x5555FF,	//9
259:                 	0x55FF55,	//10
260:                 	0x55FFFF,	//11
261:                 	0xFF5555,	//12
262:                 	0xFF55FF,	//13
263:                 	0xFFFF55,	//14
264:                 	0xFFFFFF,	//15	
265:                 	
266:                 	};
267:                 
268:                 uint16_t cursor_blink_cnt;
269:                 uint8_t cursor_blink_state, cursor_visible;
270:                 
271:                 
272:                 void set_cursor_state (uint8_t state)
273:                 	{
274:                 	if (state==0)
9D014284  14800003   BNE A0, ZERO, 0x9D014294
9D014288  24020001   ADDIU V0, ZERO, 1
9D01428C  03E00008   JR RA
9D014290  A38081AC   SB ZERO, -32340(GP)
275:                 		cursor_visible = 0;
276:                 	else
277:                 		cursor_visible = 1;
9D014294  03E00008   JR RA
9D014298  A38281AC   SB V0, -32340(GP)
278:                 	}
279:                 
280:                 void disp_tasks (void)
281:                 	{
282:                 	cursor_blink_cnt++;
9D01429C  978281AA   LHU V0, -32342(GP)
9D0142A0  24420001   ADDIU V0, V0, 1
9D0142A4  3042FFFF   ANDI V0, V0, -1
9D0142B4  03E00008   JR RA
9D0142B8  A78281AA   SH V0, -32342(GP)
283:                 	if (cursor_blink_cnt> 40)
9D0142A8  2C430029   SLTIU V1, V0, 41
9D0142AC  50600003   BEQL V1, ZERO, 0x9D0142BC
9D0142B0  A78081AA   SH ZERO, -32342(GP)
284:                 		{
285:                 		cursor_blink_cnt = 0;
286:                 		if (cursor_blink_state)
9D0142BC  938281AD   LBU V0, -32339(GP)
9D0142C0  10400003   BEQ V0, ZERO, 0x9D0142D0
9D0142C4  24020001   ADDIU V0, ZERO, 1
9D0142C8  03E00008   JR RA
9D0142CC  A38081AD   SB ZERO, -32339(GP)
287:                 			cursor_blink_state = 0;
288:                 		else
289:                 			cursor_blink_state = 1;
9D0142D0  03E00008   JR RA
9D0142D4  A38281AD   SB V0, -32339(GP)
290:                 		}
291:                 	}
292:                 
293:                 void tft_disp_buffer_refresh(uint8_t * buff, uint8_t * color_buff)
294:                 	{
9D0158A4  27BDFF88   ADDIU SP, SP, -120
9D0158A8  AFBF0074   SW RA, 116(SP)
9D0158AC  AFBE0070   SW FP, 112(SP)
9D0158B0  AFB7006C   SW S7, 108(SP)
9D0158B4  AFB60068   SW S6, 104(SP)
9D0158B8  AFB50064   SW S5, 100(SP)
9D0158BC  AFB40060   SW S4, 96(SP)
9D0158C0  AFB3005C   SW S3, 92(SP)
9D0158C4  AFB20058   SW S2, 88(SP)
9D0158C8  AFB10054   SW S1, 84(SP)
9D0158CC  AFB00050   SW S0, 80(SP)
9D0158D0  AFA40078   SW A0, 120(SP)
295:                 	uint16_t i,j,ad,col,back,cur_x,cur_y;
296:                 	cur_x = video_getx();
9D0158D4  0F406C51   JAL video_getx
9D0158D8  AFA5007C   SW A1, 124(SP)
9D0158DC  3042FFFF   ANDI V0, V0, -1
297:                 	cur_y = video_gety();
9D0158E0  0F406C53   JAL .LFB47, .LFE46, video_gety
9D0158E4  AFA20038   SW V0, 56(SP)
9D0158E8  3042FFFF   ANDI V0, V0, -1
9D0158EC  AFA2004C   SW V0, 76(SP)
9D0158F0  AFA00020   SW ZERO, 32(SP)
9D0158F4  2402000B   ADDIU V0, ZERO, 11
9D0158F8  AFA20044   SW V0, 68(SP)
298:                 	for (i=0;i<20;i++)
9D0158FC  AFA00048   SW ZERO, 72(SP)
9D016328  8FA30048   LW V1, 72(SP)
9D01632C  24620001   ADDIU V0, V1, 1
9D016330  3042FFFF   ANDI V0, V0, -1
9D016334  AFA20048   SW V0, 72(SP)
9D016338  8FA40044   LW A0, 68(SP)
9D01633C  2484000C   ADDIU A0, A0, 12
9D016340  AFA40044   SW A0, 68(SP)
9D016344  8FA60020   LW A2, 32(SP)
9D016348  24C60028   ADDIU A2, A2, 40
9D01634C  AFA60020   SW A2, 32(SP)
9D016350  24020014   ADDIU V0, ZERO, 20
9D016354  8FA30048   LW V1, 72(SP)
9D016358  10620016   BEQ V1, V0, 0x9D0163B4
9D01635C  8FBF0074   LW RA, 116(SP)
9D016360  8FA40044   LW A0, 68(SP)
9D016364  3082FFFF   ANDI V0, A0, -1
9D016368  2443FFF5   ADDIU V1, V0, -11
9D01636C  3063FFFF   ANDI V1, V1, -1
299:                 		for (j=0;j<40;j++)	
9D01631C  24020028   ADDIU V0, ZERO, 40
9D016320  1482FD83   BNE A0, V0, 0x9D015930
9D016324  AFA60014   SW A2, 20(SP)
300:                 			{
301:                 			col = color_buff[j+(i*40)]&0xF;
9D015944  90420000   LBU V0, 0(V0)
9D015948  3073FFFF   ANDI S3, V1, -1
302:                 			back = (color_buff[j+(i*40)]>>4)&0xF;
303:                 			if ((cur_x==j)&(cur_y==i)&(cursor_blink_state==1)&(cursor_visible!=0))
9D01594C  938481AC   LBU A0, -32340(GP)
9D015950  0004202B   SLTU A0, ZERO, A0
9D015954  938381AD   LBU V1, -32339(GP)
9D015958  38630001   XORI V1, V1, 1
9D01595C  2C630001   SLTIU V1, V1, 1
9D015960  00831824   AND V1, A0, V1
9D015964  8FA40024   LW A0, 36(SP)
9D015968  00831824   AND V1, A0, V1
9D01596C  10600106   BEQ V1, ZERO, 0x9D015D88
9D015970  00022902   SRL A1, V0, 4
9D015974  8FA60038   LW A2, 56(SP)
9D015978  54D30104   BNEL A2, S3, 0x9D015D8C
9D01597C  8FA40078   LW A0, 120(SP)
9D015980  001398C0   SLL S3, S3, 3
9D015984  3273FFFF   ANDI S3, S3, -1
9D015988  AFB30018   SW S3, 24(SP)
9D01639C  8FA6004C   LW A2, 76(SP)
9D0163A0  8FA30048   LW V1, 72(SP)
9D0163A4  00C31026   XOR V0, A2, V1
9D0163A8  2C420001   SLTIU V0, V0, 1
9D0163AC  0B40564C   J 0x9D015930
9D0163B0  AFA20024   SW V0, 36(SP)
304:                 				tft_print_char(219,j*8,i*12,color_table[15],color_table[back]);
9D01598C  8FA2001C   LW V0, 28(SP)
9D015990  8C51003C   LW S1, 60(V0)
9D015994  00052880   SLL A1, A1, 2
9D015998  00A22821   ADDU A1, A1, V0
9D01599C  8CA20000   LW V0, 0(A1)
305:                 			else
306:                 				tft_print_char(buff[j+(i*40)],j*8,i*12,color_table[col],color_table[back]);
9D015900  3C02A001   LUI V0, -24575
9D015904  2442B650   ADDIU V0, V0, -18864
9D015908  AFA2001C   SW V0, 28(SP)
9D015D9C  90630000   LBU V1, 0(V1)
9D015DA0  AFA30018   SW V1, 24(SP)
9D015DA4  001398C0   SLL S3, S3, 3
9D015DA8  3273FFFF   ANDI S3, S3, -1
9D015DAC  3042000F   ANDI V0, V0, 15
9D015DB0  00021080   SLL V0, V0, 2
9D015DB4  8FA6001C   LW A2, 28(SP)
9D015DB8  00461021   ADDU V0, V0, A2
9D015DBC  8C550000   LW S5, 0(V0)
9D015DC0  00052880   SLL A1, A1, 2
9D015DC4  00A62821   ADDU A1, A1, A2
9D015DC8  8CB10000   LW S1, 0(A1)
307:                 			}
308:                 	}
9D0163B4  8FBE0070   LW FP, 112(SP)
9D0163B8  8FB7006C   LW S7, 108(SP)
9D0163BC  8FB60068   LW S6, 104(SP)
9D0163C0  8FB50064   LW S5, 100(SP)
9D0163C4  8FB40060   LW S4, 96(SP)
9D0163C8  8FB3005C   LW S3, 92(SP)
9D0163CC  8FB20058   LW S2, 88(SP)
9D0163D0  8FB10054   LW S1, 84(SP)
9D0163D4  8FB00050   LW S0, 80(SP)
9D0163D8  03E00008   JR RA
9D0163DC  27BD0078   ADDIU SP, SP, 120
309:                 
310:                 void tft_disp_buffer_refresh_part(uint8_t * buff, uint8_t * color_buff)
311:                 	{
9D014D28  27BDFF90   ADDIU SP, SP, -112
9D014D2C  AFBF006C   SW RA, 108(SP)
9D014D30  AFBE0068   SW FP, 104(SP)
9D014D34  AFB70064   SW S7, 100(SP)
9D014D38  AFB60060   SW S6, 96(SP)
9D014D3C  AFB5005C   SW S5, 92(SP)
9D014D40  AFB40058   SW S4, 88(SP)
9D014D44  AFB30054   SW S3, 84(SP)
9D014D48  AFB20050   SW S2, 80(SP)
9D014D4C  AFB1004C   SW S1, 76(SP)
9D014D50  AFB00048   SW S0, 72(SP)
9D014D54  AFA40070   SW A0, 112(SP)
312:                     static uint8_t dr_cnt=0,col,back,cur_x,cur_y;
313:                 	uint16_t i,j,ad;
314:                 	cur_x = video_getx();
9D014D58  0F406C51   JAL video_getx
9D014D5C  AFA50074   SW A1, 116(SP)
315:                 	cur_y = video_gety();
9D014D60  0F406C53   JAL .LFB47, .LFE46, video_gety
9D014D64  A3828172   SB V0, -32398(GP)
9D014D68  A3828171   SB V0, -32399(GP)
316:                 	for (i=(dr_cnt);i<(dr_cnt+2);i++)
9D014D6C  93828170   LBU V0, -32400(GP)
9D014D70  24440002   ADDIU A0, V0, 2
9D014D74  0044202A   SLT A0, V0, A0
9D014D78  108002B8   BEQ A0, ZERO, 0x9D01585C
9D014D7C  AFA20024   SW V0, 36(SP)
9D014D80  00401821   ADDU V1, V0, ZERO
9D014D84  00021080   SLL V0, V0, 2
9D014D88  00022080   SLL A0, V0, 2
9D014D8C  00821023   SUBU V0, A0, V0
9D014D90  3042FFFF   ANDI V0, V0, -1
9D014D94  AFA20044   SW V0, 68(SP)
9D0157C8  8FA30024   LW V1, 36(SP)
9D0157CC  24620001   ADDIU V0, V1, 1
9D0157D0  3042FFFF   ANDI V0, V0, -1
9D0157D4  AFA20024   SW V0, 36(SP)
9D0157D8  00401821   ADDU V1, V0, ZERO
9D0157DC  93828170   LBU V0, -32400(GP)
9D0157E0  8FA50044   LW A1, 68(SP)
9D0157E4  24A4000C   ADDIU A0, A1, 12
9D0157E8  3084FFFF   ANDI A0, A0, -1
9D0157EC  AFA40044   SW A0, 68(SP)
9D0157F0  24440002   ADDIU A0, V0, 2
9D0157F4  0064202A   SLT A0, V1, A0
9D0157F8  10800019   BEQ A0, ZERO, 0x9D015860
9D0157FC  24420002   ADDIU V0, V0, 2
317:                 		for (j=0;j<40;j++)	
9D0157BC  24020028   ADDIU V0, ZERO, 40
9D0157C0  1482FD81   BNE A0, V0, 0x9D014DC8
9D0157C4  AFA60014   SW A2, 20(SP)
318:                 			{
319:                 			col = color_buff[j+(i*40)]&0xF;
9D014DD0  8FA40018   LW A0, 24(SP)
9D014DD4  90820000   LBU V0, 0(A0)
9D015830  000310C0   SLL V0, V1, 3
9D015834  00031940   SLL V1, V1, 5
9D015838  00431821   ADDU V1, V0, V1
9D01583C  AFA30038   SW V1, 56(SP)
9D015840  8FA60074   LW A2, 116(SP)
9D015844  00C33021   ADDU A2, A2, V1
9D015848  AFA60018   SW A2, 24(SP)
320:                 			back = (color_buff[j+(i*40)]>>4)&0xF;
321:                 			if ((cur_x==j)&(cur_y==i)&(cursor_blink_state==1)&(cursor_visible!=0))
9D014DD8  938481AC   LBU A0, -32340(GP)
9D014DDC  0004202B   SLTU A0, ZERO, A0
9D014DE0  938381AD   LBU V1, -32339(GP)
9D014DE4  38630001   XORI V1, V1, 1
9D014DE8  2C630001   SLTIU V1, V1, 1
9D014DEC  00832024   AND A0, A0, V1
9D014DF0  93838171   LBU V1, -32399(GP)
9D014DF4  8FA60024   LW A2, 36(SP)
9D014DF8  00661826   XOR V1, V1, A2
9D014DFC  2C630001   SLTIU V1, V1, 1
9D014E00  00641824   AND V1, V1, A0
9D014E04  10600105   BEQ V1, ZERO, 0x9D01521C
9D014E08  00022902   SRL A1, V0, 4
9D014E0C  93838172   LBU V1, -32398(GP)
9D014E10  14730103   BNE V1, S3, 0x9D015220
9D014E14  8FA60070   LW A2, 112(SP)
9D014E18  001398C0   SLL S3, S3, 3
9D014E1C  3273FFFF   ANDI S3, S3, -1
9D014E20  AFB3001C   SW S3, 28(SP)
322:                 				tft_print_char(219,j*8,i*12,color_table[15],color_table[back]);
9D014E24  8FA20020   LW V0, 32(SP)
9D014E28  8C51003C   LW S1, 60(V0)
9D014E2C  00052880   SLL A1, A1, 2
9D014E30  00A22821   ADDU A1, A1, V0
9D014E34  8CA20000   LW V0, 0(A1)
323:                 			else
324:                 				tft_print_char(buff[j+(i*40)],j*8,i*12,color_table[col],color_table[back]);
9D014D98  3C02A001   LUI V0, -24575
9D014D9C  2442B650   ADDIU V0, V0, -18864
9D014DA0  AFA20020   SW V0, 32(SP)
9D015230  90630000   LBU V1, 0(V1)
9D015234  AFA3001C   SW V1, 28(SP)
9D015238  001398C0   SLL S3, S3, 3
9D01523C  3273FFFF   ANDI S3, S3, -1
9D015240  3042000F   ANDI V0, V0, 15
9D015244  00021080   SLL V0, V0, 2
9D015248  8FA30020   LW V1, 32(SP)
9D01524C  00431021   ADDU V0, V0, V1
9D015250  8C550000   LW S5, 0(V0)
9D015254  00052880   SLL A1, A1, 2
9D015258  00A32821   ADDU A1, A1, V1
9D01525C  8CB10000   LW S1, 0(A1)
325:                 			}
326:                     dr_cnt = dr_cnt + 2;
9D01585C  24420002   ADDIU V0, V0, 2
9D015860  304200FF   ANDI V0, V0, 255
327:                     if (dr_cnt == 20)
9D015864  24030014   ADDIU V1, ZERO, 20
9D015868  50430002   BEQL V0, V1, 0x9D015874
9D01586C  A3808170   SB ZERO, -32400(GP)
9D015870  A3828170   SB V0, -32400(GP)
328:                         dr_cnt = 0;
329:                 
330:                     }
9D015874  8FBF006C   LW RA, 108(SP)
9D015878  8FBE0068   LW FP, 104(SP)
9D01587C  8FB70064   LW S7, 100(SP)
9D015880  8FB60060   LW S6, 96(SP)
9D015884  8FB5005C   LW S5, 92(SP)
9D015888  8FB40058   LW S4, 88(SP)
9D01588C  8FB30054   LW S3, 84(SP)
9D015890  8FB20050   LW S2, 80(SP)
9D015894  8FB1004C   LW S1, 76(SP)
9D015898  8FB00048   LW S0, 72(SP)
9D01589C  03E00008   JR RA
9D0158A0  27BD0070   ADDIU SP, SP, 112
331:                 
332:                 
333:                 
334:                 inline void tft_print_char (uint8_t val, uint16_t x, uint16_t y, uint32_t col, uint32_t back)
335:                 	{
9D0145B8  27BDFFC8   ADDIU SP, SP, -56
9D0145BC  AFBF0034   SW RA, 52(SP)
9D0145C0  AFBE0030   SW FP, 48(SP)
9D0145C4  AFB7002C   SW S7, 44(SP)
9D0145C8  AFB60028   SW S6, 40(SP)
9D0145CC  AFB50024   SW S5, 36(SP)
9D0145D0  AFB40020   SW S4, 32(SP)
9D0145D4  AFB3001C   SW S3, 28(SP)
9D0145D8  AFB20018   SW S2, 24(SP)
9D0145DC  AFB10014   SW S1, 20(SP)
9D0145E0  AFB00010   SW S0, 16(SP)
9D0145E4  AFA40038   SW A0, 56(SP)
9D0145E8  00A0F021   ADDU FP, A1, ZERO
9D0145EC  00C0B821   ADDU S7, A2, ZERO
9D0145F0  AFA70044   SW A3, 68(SP)
9D0145F4  8FB20048   LW S2, 72(SP)
336:                 	uint16_t fl,i,j;
337:                 	uint16_t c1,c2,c3,b1,b2,b3;
338:                 	c1 = (col>>16)&0xFF;
9D014810  7C4A3C00   EXT T2, V0, 16, 8
9D014E38  7E333C00   EXT S3, S1, 16, 8
9D0159A0  7E333C00   EXT S3, S1, 16, 8
339:                 	c2 = (col>>8)&0xFF;
9D014814  7C493A00   EXT T1, V0, 8, 8
9D014E3C  7E323A00   EXT S2, S1, 8, 8
9D01545C  7EA53A00   EXT A1, S5, 8, 8
9D0159A4  7E323A00   EXT S2, S1, 8, 8
9D015FC8  7EA53A00   EXT A1, S5, 8, 8
340:                 	c3 = (col>>0)&0xFF;
9D014818  304800FF   ANDI T0, V0, 255
9D014E40  323100FF   ANDI S1, S1, 255
9D015460  32B500FF   ANDI S5, S5, 255
9D0159A8  323100FF   ANDI S1, S1, 255
9D015FCC  32B500FF   ANDI S5, S5, 255
341:                 	b1 = (back>>16)&0xFF;
9D0145F8  7E503C00   EXT S0, S2, 16, 8
9D014E44  7C503C00   EXT S0, V0, 16, 8
9D015260  7E343C00   EXT S4, S1, 16, 8
9D0159AC  7C503C00   EXT S0, V0, 16, 8
9D015DCC  7E343C00   EXT S4, S1, 16, 8
342:                 	b2 = (back>>8)&0xFF;
9D0145FC  7E513A00   EXT S1, S2, 8, 8
9D014E48  7C543A00   EXT S4, V0, 8, 8
9D015264  7E303A00   EXT S0, S1, 8, 8
9D0159B0  7C543A00   EXT S4, V0, 8, 8
9D015DD0  7E303A00   EXT S0, S1, 8, 8
343:                 	b3 = (back>>0)&0xFF;
9D014600  325200FF   ANDI S2, S2, 255
9D014E4C  305500FF   ANDI S5, V0, 255
9D015268  323100FF   ANDI S1, S1, 255
9D0159B4  305500FF   ANDI S5, V0, 255
9D015DD4  323100FF   ANDI S1, S1, 255
344:                 	tft_set_write_area(x,y,7,11);
345:                 	TFT_24_7789_Write_Command(0x2C);
9D0146AC  0F4050B6   JAL TFT_24_7789_Write_Command
9D0146B0  2404002C   ADDIU A0, ZERO, 44
9D014EF0  0F4050B6   JAL TFT_24_7789_Write_Command
9D014EF4  2404002C   ADDIU A0, ZERO, 44
9D014EF8  3C049D03   LUI A0, -25341
9D014EFC  2484910C   ADDIU A0, A0, -28404
9D015304  0F4050B6   JAL TFT_24_7789_Write_Command
9D015308  2404002C   ADDIU A0, ZERO, 44
9D015A5C  0F4050B6   JAL TFT_24_7789_Write_Command
9D015A60  2404002C   ADDIU A0, ZERO, 44
9D015A64  3C049D03   LUI A0, -25341
9D015A68  2484910C   ADDIU A0, A0, -28404
9D015E70  0F4050B6   JAL TFT_24_7789_Write_Command
9D015E74  2404002C   ADDIU A0, ZERO, 44
346:                 	if (val<' ')
9D0146B4  8FA30038   LW V1, 56(SP)
9D0146B8  2C620020   SLTIU V0, V1, 32
9D0146BC  10400054   BEQ V0, ZERO, 0x9D014810
9D0146C0  8FA20044   LW V0, 68(SP)
9D0146C4  2406000C   ADDIU A2, ZERO, 12
9D01530C  8FA4001C   LW A0, 28(SP)
9D015310  2C820020   SLTIU V0, A0, 32
9D015314  10400051   BEQ V0, ZERO, 0x9D01545C
9D015318  7EA63C00   EXT A2, S5, 16, 8
9D01531C  2403000C   ADDIU V1, ZERO, 12
9D015E78  8FA40018   LW A0, 24(SP)
9D015E7C  2C820020   SLTIU V0, A0, 32
9D015E80  10400051   BEQ V0, ZERO, 0x9D015FC8
9D015E84  7EA63C00   EXT A2, S5, 16, 8
9D015E88  2403000C   ADDIU V1, ZERO, 12
347:                 		{
348:                 		for (i=0;i<12;i++)
9D014800  14C0FFB5   BNE A2, ZERO, 0x9D0146D8
9D014804  8FBF0034   LW RA, 52(SP)
9D014808  0B4052DB   J 0x9D014B6C
9D01480C  8FBE0030   LW FP, 48(SP)
9D01544C  1460FFB5   BNE V1, ZERO, 0x9D015324
9D015450  8FA40010   LW A0, 16(SP)
9D015454  0B4055E9   J 0x9D0157A4
9D015458  24840001   ADDIU A0, A0, 1
9D015FB8  1460FFB5   BNE V1, ZERO, 0x9D015E90
9D015FBC  8FA40010   LW A0, 16(SP)
9D015FC0  0B4058C4   J 0x9D016310
9D015FC4  24840001   ADDIU A0, A0, 1
349:                 			{
350:                 			TFT_24_7789_Write_Data3(b1,b2,b3);
351:                 			TFT_24_7789_Write_Data3(b1,b2,b3);
352:                 			TFT_24_7789_Write_Data3(b1,b2,b3);
353:                 			TFT_24_7789_Write_Data3(b1,b2,b3);
354:                 			TFT_24_7789_Write_Data3(b1,b2,b3);
355:                 			TFT_24_7789_Write_Data3(b1,b2,b3);
356:                 			TFT_24_7789_Write_Data3(b1,b2,b3);
357:                 			TFT_24_7789_Write_Data3(b1,b2,b3);
358:                 			}
359:                 				
360:                 		}
361:                 	else
362:                 		{
363:                 		for (i=0;i<12;i++)
9D014850  240C000C   ADDIU T4, ZERO, 12
9D014854  01A73021   ADDU A2, T5, A3
9D014B5C  14ECFF3E   BNE A3, T4, 0x9D014858
9D014B60  01A73021   ADDU A2, T5, A3
9D01520C  5486FF3F   BNEL A0, A2, 0x9D014F0C
9D015210  80830000   LB V1, 0(A0)
9D015214  0B4055E8   J 0x9D0157A0
9D015218  8FA40010   LW A0, 16(SP)
9D01521C  8FA60070   LW A2, 112(SP)
9D015220  8FA40038   LW A0, 56(SP)
9D015224  00C41821   ADDU V1, A2, A0
9D015228  8FA60010   LW A2, 16(SP)
9D01522C  00661821   ADDU V1, V1, A2
9D015488  2408000C   ADDIU T0, ZERO, 12
9D01548C  01241821   ADDU V1, T1, A0
9D015794  1488FF3E   BNE A0, T0, 0x9D015490
9D015798  01241821   ADDU V1, T1, A0
9D01579C  8FA40010   LW A0, 16(SP)
9D0157A0  24840001   ADDIU A0, A0, 1
9D0157A4  AFA40010   SW A0, 16(SP)
9D0157A8  8FA50018   LW A1, 24(SP)
9D0157AC  24A50001   ADDIU A1, A1, 1
9D0157B0  AFA50018   SW A1, 24(SP)
9D0157B4  8FA60014   LW A2, 20(SP)
9D0157B8  24C60008   ADDIU A2, A2, 8
9D015D78  5486FF3F   BNEL A0, A2, 0x9D015A78
9D015D7C  80830000   LB V1, 0(A0)
9D015D80  0B4058C3   J 0x9D01630C
9D015D84  8FA40010   LW A0, 16(SP)
9D015D88  8FA40078   LW A0, 120(SP)
9D015D8C  8FA60020   LW A2, 32(SP)
9D015D90  00861821   ADDU V1, A0, A2
9D015D94  8FA40010   LW A0, 16(SP)
9D015D98  00641821   ADDU V1, V1, A0
9D015FF4  2408000C   ADDIU T0, ZERO, 12
9D015FF8  01241821   ADDU V1, T1, A0
9D016300  1488FF3E   BNE A0, T0, 0x9D015FFC
9D016304  01241821   ADDU V1, T1, A0
9D016308  8FA40010   LW A0, 16(SP)
9D01630C  24840001   ADDIU A0, A0, 1
9D016310  AFA40010   SW A0, 16(SP)
9D016314  8FA60014   LW A2, 20(SP)
9D016318  24C60008   ADDIU A2, A2, 8
364:                 			{
365:                 			fl = font[i+12*(val-' ')];
9D01481C  8FA30038   LW V1, 56(SP)
9D014820  2462FFE0   ADDIU V0, V1, -32
9D014824  00021880   SLL V1, V0, 2
9D014828  00021100   SLL V0, V0, 4
9D01482C  00431023   SUBU V0, V0, V1
9D014830  00003821   ADDU A3, ZERO, ZERO
9D014834  3C0D9D03   LUI T5, -25341
9D014838  25AD8848   ADDIU T5, T5, -30648
9D01483C  01A26821   ADDU T5, T5, V0
9D014858  80C60000   LB A2, 0(A2)
9D014F08  80830000   LB V1, 0(A0)
9D015464  8FA2001C   LW V0, 28(SP)
9D015468  2443FFE0   ADDIU V1, V0, -32
9D01546C  00031080   SLL V0, V1, 2
9D015470  00034900   SLL T1, V1, 4
9D015474  01224823   SUBU T1, T1, V0
9D015478  00002021   ADDU A0, ZERO, ZERO
9D01547C  8FA30040   LW V1, 64(SP)
9D015480  00694821   ADDU T1, V1, T1
9D015490  80630000   LB V1, 0(V1)
9D015A74  80830000   LB V1, 0(A0)
9D015FD0  8FA20018   LW V0, 24(SP)
9D015FD4  2443FFE0   ADDIU V1, V0, -32
9D015FD8  00031080   SLL V0, V1, 2
9D015FDC  00034900   SLL T1, V1, 4
9D015FE0  01224823   SUBU T1, T1, V0
9D015FE4  00002021   ADDU A0, ZERO, ZERO
9D015FE8  8FA30040   LW V1, 64(SP)
9D015FEC  00694821   ADDU T1, V1, T1
9D015FFC  80630000   LB V1, 0(V1)
366:                 			if (fl&0x80)
9D01485C  30CB0080   ANDI T3, A2, 128
9D014860  316BFFFF   ANDI T3, T3, -1
9D014864  1160000C   BEQ T3, ZERO, 0x9D014898
9D014868  00000000   NOP
9D014F0C  30650080   ANDI A1, V1, 128
9D014F10  30A5FFFF   ANDI A1, A1, -1
9D014F14  10A0000C   BEQ A1, ZERO, 0x9D014F48
9D014F18  00000000   NOP
9D015494  30670080   ANDI A3, V1, 128
9D015498  30E7FFFF   ANDI A3, A3, -1
9D01549C  10E0000C   BEQ A3, ZERO, 0x9D0154D0
9D0154A0  00000000   NOP
9D015A78  30650080   ANDI A1, V1, 128
9D015A7C  30A5FFFF   ANDI A1, A1, -1
9D015A80  10A0000C   BEQ A1, ZERO, 0x9D015AB4
9D015A84  00000000   NOP
9D016000  30670080   ANDI A3, V1, 128
9D016004  30E7FFFF   ANDI A3, A3, -1
9D016008  10E0000C   BEQ A3, ZERO, 0x9D01603C
9D01600C  00000000   NOP
367:                 				TFT_24_7789_Write_Data3(c1,c2,c3);
368:                 			else
369:                 				TFT_24_7789_Write_Data3(b1,b2,b3);
370:                 			if (fl&0x40)
9D014890  0B405230   J 0x9D0148C0
9D014894  30CB0040   ANDI T3, A2, 64
9D0148BC  30CB0040   ANDI T3, A2, 64
9D0148C0  7C0B5C20   SEB T3, T3
9D0148C4  1160000C   BEQ T3, ZERO, .LBB418
9D0148C8  00000000   NOP
9D014F40  0B4053DC   J 0x9D014F70
9D014F44  30650040   ANDI A1, V1, 64
9D014F6C  30650040   ANDI A1, V1, 64
9D014F70  7C052C20   SEB A1, A1
9D014F74  10A0000C   BEQ A1, ZERO, .LBB744
9D014F78  00000000   NOP
9D0154C8  0B40553E   J 0x9D0154F8
9D0154CC  30670040   ANDI A3, V1, 64
9D0154F4  30670040   ANDI A3, V1, 64
9D0154F8  7C073C20   SEB A3, A3
9D0154FC  10E0000C   BEQ A3, ZERO, .LBB670
9D015500  00000000   NOP
9D015AAC  0B4056B7   J 0x9D015ADC
9D015AB0  30650040   ANDI A1, V1, 64
9D015AD8  30650040   ANDI A1, V1, 64
9D015ADC  7C052C20   SEB A1, A1
9D015AE0  10A0000C   BEQ A1, ZERO, .LBB1053
9D015AE4  00000000   NOP
9D016034  0B405819   J 0x9D016064
9D016038  30670040   ANDI A3, V1, 64
9D016060  30670040   ANDI A3, V1, 64
9D016064  7C073C20   SEB A3, A3
9D016068  10E0000C   BEQ A3, ZERO, .LBB982
9D01606C  00000000   NOP
371:                 				TFT_24_7789_Write_Data3(c1,c2,c3);
372:                 			else
373:                 				TFT_24_7789_Write_Data3(b1,b2,b3);
374:                 			if (fl&0x20)
9D0148F0  0B405248   J 0x9D014920
9D0148F4  30CB0020   ANDI T3, A2, 32
9D01491C  30CB0020   ANDI T3, A2, 32
9D014920  7C0B5C20   SEB T3, T3
9D014924  1160000C   BEQ T3, ZERO, .LBB422
9D014928  00000000   NOP
9D014FA0  0B4053F4   J 0x9D014FD0
9D014FA4  30650020   ANDI A1, V1, 32
9D014FCC  30650020   ANDI A1, V1, 32
9D014FD0  7C052C20   SEB A1, A1
9D014FD4  10A0000C   BEQ A1, ZERO, .LBB748
9D014FD8  00000000   NOP
9D015528  0B405556   J 0x9D015558
9D01552C  30670020   ANDI A3, V1, 32
9D015554  30670020   ANDI A3, V1, 32
9D015558  7C073C20   SEB A3, A3
9D01555C  10E0000C   BEQ A3, ZERO, .LBB674
9D015560  00000000   NOP
9D015B0C  0B4056CF   J 0x9D015B3C
9D015B10  30650020   ANDI A1, V1, 32
9D015B38  30650020   ANDI A1, V1, 32
9D015B3C  7C052C20   SEB A1, A1
9D015B40  10A0000C   BEQ A1, ZERO, .LBB1057
9D015B44  00000000   NOP
9D016094  0B405831   J 0x9D0160C4
9D016098  30670020   ANDI A3, V1, 32
9D0160C0  30670020   ANDI A3, V1, 32
9D0160C4  7C073C20   SEB A3, A3
9D0160C8  10E0000C   BEQ A3, ZERO, .LBB986
9D0160CC  00000000   NOP
375:                 				TFT_24_7789_Write_Data3(c1,c2,c3);
376:                 			else
377:                 				TFT_24_7789_Write_Data3(b1,b2,b3);
378:                 			if (fl&0x10)
9D014950  0B405260   J 0x9D014980
9D014954  30CB0010   ANDI T3, A2, 16
9D01497C  30CB0010   ANDI T3, A2, 16
9D014980  7C0B5C20   SEB T3, T3
9D014984  1160000C   BEQ T3, ZERO, .LBB426
9D014988  00000000   NOP
9D015000  0B40540C   J 0x9D015030
9D015004  30650010   ANDI A1, V1, 16
9D01502C  30650010   ANDI A1, V1, 16
9D015030  7C052C20   SEB A1, A1
9D015034  10A0000C   BEQ A1, ZERO, .LBB752
9D015038  00000000   NOP
9D015588  0B40556E   J 0x9D0155B8
9D01558C  30670010   ANDI A3, V1, 16
9D0155B4  30670010   ANDI A3, V1, 16
9D0155B8  7C073C20   SEB A3, A3
9D0155BC  10E0000C   BEQ A3, ZERO, .LBB678
9D0155C0  00000000   NOP
9D015B6C  0B4056E7   J 0x9D015B9C
9D015B70  30650010   ANDI A1, V1, 16
9D015B98  30650010   ANDI A1, V1, 16
9D015B9C  7C052C20   SEB A1, A1
9D015BA0  10A0000C   BEQ A1, ZERO, .LBB1061
9D015BA4  00000000   NOP
9D0160F4  0B405849   J 0x9D016124
9D0160F8  30670010   ANDI A3, V1, 16
9D016120  30670010   ANDI A3, V1, 16
9D016124  7C073C20   SEB A3, A3
9D016128  10E0000C   BEQ A3, ZERO, .LBB990
9D01612C  00000000   NOP
379:                 				TFT_24_7789_Write_Data3(c1,c2,c3);
380:                 			else
381:                 				TFT_24_7789_Write_Data3(b1,b2,b3);
382:                 			if (fl&0x08)
9D0149B0  0B405278   J 0x9D0149E0
9D0149B4  30CB0008   ANDI T3, A2, 8
9D0149DC  30CB0008   ANDI T3, A2, 8
9D0149E0  7C0B5C20   SEB T3, T3
9D0149E4  1160000C   BEQ T3, ZERO, .LBB430
9D0149E8  00000000   NOP
9D015060  0B405424   J 0x9D015090
9D015064  30650008   ANDI A1, V1, 8
9D01508C  30650008   ANDI A1, V1, 8
9D015090  7C052C20   SEB A1, A1
9D015094  10A0000C   BEQ A1, ZERO, .LBB756
9D015098  00000000   NOP
9D0155E8  0B405586   J 0x9D015618
9D0155EC  30670008   ANDI A3, V1, 8
9D015614  30670008   ANDI A3, V1, 8
9D015618  7C073C20   SEB A3, A3
9D01561C  10E0000C   BEQ A3, ZERO, .LBB682
9D015620  00000000   NOP
9D015BCC  0B4056FF   J 0x9D015BFC
9D015BD0  30650008   ANDI A1, V1, 8
9D015BF8  30650008   ANDI A1, V1, 8
9D015BFC  7C052C20   SEB A1, A1
9D015C00  10A0000C   BEQ A1, ZERO, .LBB1065
9D015C04  00000000   NOP
9D016154  0B405861   J 0x9D016184
9D016158  30670008   ANDI A3, V1, 8
9D016180  30670008   ANDI A3, V1, 8
9D016184  7C073C20   SEB A3, A3
9D016188  10E0000C   BEQ A3, ZERO, .LBB994
9D01618C  00000000   NOP
383:                 				TFT_24_7789_Write_Data3(c1,c2,c3);
384:                 			else
385:                 				TFT_24_7789_Write_Data3(b1,b2,b3);
386:                 			if (fl&0x04)
9D014A10  0B405290   J 0x9D014A40
9D014A14  30CB0004   ANDI T3, A2, 4
9D014A3C  30CB0004   ANDI T3, A2, 4
9D014A40  7C0B5C20   SEB T3, T3
9D014A44  1160000C   BEQ T3, ZERO, .LBB434
9D014A48  00000000   NOP
9D0150C0  0B40543C   J 0x9D0150F0
9D0150C4  30650004   ANDI A1, V1, 4
9D0150EC  30650004   ANDI A1, V1, 4
9D0150F0  7C052C20   SEB A1, A1
9D0150F4  10A0000C   BEQ A1, ZERO, .LBB760
9D0150F8  00000000   NOP
9D015648  0B40559E   J 0x9D015678
9D01564C  30670004   ANDI A3, V1, 4
9D015674  30670004   ANDI A3, V1, 4
9D015678  7C073C20   SEB A3, A3
9D01567C  10E0000C   BEQ A3, ZERO, .LBB686
9D015680  00000000   NOP
9D015C2C  0B405717   J 0x9D015C5C
9D015C30  30650004   ANDI A1, V1, 4
9D015C58  30650004   ANDI A1, V1, 4
9D015C5C  7C052C20   SEB A1, A1
9D015C60  10A0000C   BEQ A1, ZERO, .LBB1069
9D015C64  00000000   NOP
9D0161B4  0B405879   J 0x9D0161E4
9D0161B8  30670004   ANDI A3, V1, 4
9D0161E0  30670004   ANDI A3, V1, 4
9D0161E4  7C073C20   SEB A3, A3
9D0161E8  10E0000C   BEQ A3, ZERO, .LBB998
9D0161EC  00000000   NOP
387:                 				TFT_24_7789_Write_Data3(c1,c2,c3);
388:                 			else
389:                 				TFT_24_7789_Write_Data3(b1,b2,b3);				
390:                 			if (fl&0x02)
9D014A70  0B4052A8   J 0x9D014AA0
9D014A74  30CB0002   ANDI T3, A2, 2
9D014A9C  30CB0002   ANDI T3, A2, 2
9D014AA0  7C0B5C20   SEB T3, T3
9D014AA4  1160000C   BEQ T3, ZERO, .LBB438
9D014AA8  00000000   NOP
9D015120  0B405454   J 0x9D015150
9D015124  30650002   ANDI A1, V1, 2
9D01514C  30650002   ANDI A1, V1, 2
9D015150  7C052C20   SEB A1, A1
9D015154  10A0000C   BEQ A1, ZERO, .LBB764
9D015158  00000000   NOP
9D0156A8  0B4055B6   J 0x9D0156D8
9D0156AC  30670002   ANDI A3, V1, 2
9D0156D4  30670002   ANDI A3, V1, 2
9D0156D8  7C073C20   SEB A3, A3
9D0156DC  10E0000C   BEQ A3, ZERO, .LBB690
9D0156E0  00000000   NOP
9D015C8C  0B40572F   J 0x9D015CBC
9D015C90  30650002   ANDI A1, V1, 2
9D015CB8  30650002   ANDI A1, V1, 2
9D015CBC  7C052C20   SEB A1, A1
9D015CC0  10A0000C   BEQ A1, ZERO, .LBB1073
9D015CC4  00000000   NOP
9D016214  0B405891   J 0x9D016244
9D016218  30670002   ANDI A3, V1, 2
9D016240  30670002   ANDI A3, V1, 2
9D016244  7C073C20   SEB A3, A3
9D016248  10E0000C   BEQ A3, ZERO, .LBB1002
9D01624C  00000000   NOP
391:                 				TFT_24_7789_Write_Data3(c1,c2,c3);
392:                 			else
393:                 				TFT_24_7789_Write_Data3(b1,b2,b3);
394:                 			if (fl&0x01)
9D014AD0  0B4052C0   J 0x9D014B00
9D014AD4  30C60001   ANDI A2, A2, 1
9D014AFC  30C60001   ANDI A2, A2, 1
9D014B00  10C0000C   BEQ A2, ZERO, .LBE440, .LBB442
9D014B04  00000000   NOP
9D015180  0B40546C   J 0x9D0151B0
9D015184  30630001   ANDI V1, V1, 1
9D0151AC  30630001   ANDI V1, V1, 1
9D0151B0  1060000C   BEQ V1, ZERO, .LBE766, .LBB768
9D0151B4  00000000   NOP
9D015708  0B4055CE   J 0x9D015738
9D01570C  30630001   ANDI V1, V1, 1
9D015734  30630001   ANDI V1, V1, 1
9D015738  1060000C   BEQ V1, ZERO, .LBE692, .LBB694
9D01573C  00000000   NOP
9D015CEC  0B405747   J 0x9D015D1C
9D015CF0  30630001   ANDI V1, V1, 1
9D015D18  30630001   ANDI V1, V1, 1
9D015D1C  1060000C   BEQ V1, ZERO, .LBE1075, .LBB1077
9D015D20  00000000   NOP
9D016274  0B4058A9   J 0x9D0162A4
9D016278  30630001   ANDI V1, V1, 1
9D0162A0  30630001   ANDI V1, V1, 1
9D0162A4  1060000C   BEQ V1, ZERO, .LBE1004, .LBB1006
9D0162A8  00000000   NOP
395:                 				TFT_24_7789_Write_Data3(c1,c2,c3);
396:                 			else
397:                 				TFT_24_7789_Write_Data3(b1,b2,b3);	
398:                 			}
399:                 		}
400:                 	}
9D014B64  8FBF0034   LW RA, 52(SP)
9D014B68  8FBE0030   LW FP, 48(SP)
9D014B6C  8FB7002C   LW S7, 44(SP)
9D014B70  8FB60028   LW S6, 40(SP)
9D014B74  8FB50024   LW S5, 36(SP)
9D014B78  8FB40020   LW S4, 32(SP)
9D014B7C  8FB3001C   LW S3, 28(SP)
9D014B80  8FB20018   LW S2, 24(SP)
9D014B84  8FB10014   LW S1, 20(SP)
9D014B88  8FB00010   LW S0, 16(SP)
9D014B8C  03E00008   JR RA
9D014B90  27BD0038   ADDIU SP, SP, 56
401:                 
402:                 
403:                 void tft_fill_area (uint16_t x, uint16_t y, uint16_t xlen, uint16_t ylen, uint32_t back)
404:                 {
9D014438  27BDFFC8   ADDIU SP, SP, -56
9D01443C  AFBF0034   SW RA, 52(SP)
9D014440  AFBE0030   SW FP, 48(SP)
9D014444  AFB7002C   SW S7, 44(SP)
9D014448  AFB60028   SW S6, 40(SP)
9D01444C  AFB50024   SW S5, 36(SP)
9D014450  AFB40020   SW S4, 32(SP)
9D014454  AFB3001C   SW S3, 28(SP)
9D014458  AFB20018   SW S2, 24(SP)
9D01445C  AFB10014   SW S1, 20(SP)
9D014460  AFB00010   SW S0, 16(SP)
9D014464  0080B021   ADDU S6, A0, ZERO
9D014468  00A0A821   ADDU S5, A1, ZERO
9D01446C  00C0F021   ADDU FP, A2, ZERO
9D014470  00E0B821   ADDU S7, A3, ZERO
9D014474  8FB10048   LW S1, 72(SP)
405:                     uint32_t i,j;
406:                     tft_set_write_area(x,y,xlen,ylen);
407:                     TFT_24_7789_Write_Command(0x2C);
9D014520  0F4050B6   JAL TFT_24_7789_Write_Command
9D014524  2404002C   ADDIU A0, ZERO, 44
408:                     //FIXME: Why do I need these +1 adjustments. Off-by-one in tft_set_write_area?
409:                     for (i=0; i<((xlen+1)*(ylen+1)); i++)
9D014528  27C70001   ADDIU A3, FP, 1
9D01452C  26F70001   ADDIU S7, S7, 1
9D014530  70F73802   MUL A3, A3, S7
9D014534  10E00015   BEQ A3, ZERO, 0x9D01458C
9D014538  8FBF0034   LW RA, 52(SP)
9D014544  00003021   ADDU A2, ZERO, ZERO
9D014580  24C60001   ADDIU A2, A2, 1
9D014584  14C7FFF5   BNE A2, A3, 0x9D01455C
9D014588  8FBF0034   LW RA, 52(SP)
410:                     {
411:                         TFT_24_7789_Write_Data3((back>>16)&0xFF,(back>>8)&0xFF,(back>>0)&0xFF);
412:                     }
413:                 }
9D01458C  8FBE0030   LW FP, 48(SP)
9D014590  8FB7002C   LW S7, 44(SP)
9D014594  8FB60028   LW S6, 40(SP)
9D014598  8FB50024   LW S5, 36(SP)
9D01459C  8FB40020   LW S4, 32(SP)
9D0145A0  8FB3001C   LW S3, 28(SP)
9D0145A4  8FB20018   LW S2, 24(SP)
9D0145A8  8FB10014   LW S1, 20(SP)
9D0145AC  8FB00010   LW S0, 16(SP)
9D0145B0  03E00008   JR RA
9D0145B4  27BD0038   ADDIU SP, SP, 56
414:                 
415:                 extern uint16_t myPalette[256];
416:                 
417:                 inline void tft_writebuf (const uint8_t *buf[], uint16_t xlen, uint16_t ylen)
418:                 {
9D014B94  27BDFFC8   ADDIU SP, SP, -56
9D014B98  AFBF0034   SW RA, 52(SP)
9D014B9C  AFBE0030   SW FP, 48(SP)
9D014BA0  AFB7002C   SW S7, 44(SP)
9D014BA4  AFB60028   SW S6, 40(SP)
9D014BA8  AFB50024   SW S5, 36(SP)
9D014BAC  AFB40020   SW S4, 32(SP)
9D014BB0  AFB3001C   SW S3, 28(SP)
9D014BB4  AFB20018   SW S2, 24(SP)
9D014BB8  AFB10014   SW S1, 20(SP)
9D014BBC  AFB00010   SW S0, 16(SP)
9D014BC0  0080B821   ADDU S7, A0, ZERO
9D014BC4  00A08021   ADDU S0, A1, ZERO
9D014BC8  00C0A821   ADDU S5, A2, ZERO
419:                     uint32_t i,j;
420:                     tft_set_write_area(0,0,xlen-1,ylen-1);
9D014BCC  24BEFFFF   ADDIU FP, A1, -1
9D014BD0  33DEFFFF   ANDI FP, FP, -1
9D014BD4  24D6FFFF   ADDIU S6, A2, -1
9D014BD8  32D6FFFF   ANDI S6, S6, -1
421:                     TFT_24_7789_Write_Command(0x2C);
9D014C6C  0F4050B6   JAL TFT_24_7789_Write_Command
9D014C70  2404002C   ADDIU A0, ZERO, 44
422:                     //FIXME: Why do I need these +1 adjustments. Off-by-one in tft_set_write_area?
423:                 //    for (i=0; i<((xlen)*(ylen)); i++)
424:                 //    {
425:                 //        //TFT_24_7789_Write_Data3(buf[(3*i)+2],buf[(3*i)+1],buf[3*i]);
426:                 //        //TFT_24_7789_Write_Data33(buf[i], buf[i], buf[i]); 
427:                 //        TFT_24_7789_Write_Data33(buf[i], buf[i], buf[i]);
428:                 //    }
429:                     
430:                     int x,y;
431:                     uint8_t a;
432:                     for (y=0; y<ylen; y++) {
9D014C74  1AA00020   BLEZ S5, 0x9D014CF8
9D014C78  02A03021   ADDU A2, S5, ZERO
9D014C7C  02E02021   ADDU A0, S7, ZERO
9D014C80  00005821   ADDU T3, ZERO, ZERO
9D014CD8  256B0001   ADDIU T3, T3, 1
9D014CDC  0166182A   SLT V1, T3, A2
9D014CE0  10600005   BEQ V1, ZERO, 0x9D014CF8
9D014CE4  24840004   ADDIU A0, A0, 4
433:                         for (x=0; x<xlen; x++) {
9D014C84  02002821   ADDU A1, S0, ZERO
9D014CC8  24630001   ADDIU V1, V1, 1
9D014CCC  0065382A   SLT A3, V1, A1
9D014CD0  54E0FFF2   BNEL A3, ZERO, 0x9D014C9C
9D014CD4  8C870000   LW A3, 0(A0)
9D014CE8  1A00FFFB   BLEZ S0, 0x9D014CD8
9D014CEC  00001821   ADDU V1, ZERO, ZERO
434:                             a = buf[y][x];
9D014C9C  00E33821   ADDU A3, A3, V1
9D014CA0  90E70000   LBU A3, 0(A3)
9D014CF0  0B405327   J 0x9D014C9C
9D014CF4  8C870000   LW A3, 0(A0)
435:                             TFT_24_7789_Write_Data33(a, a, a);
436:                         }
437:                     }
438:                 }
9D014CF8  8FBF0034   LW RA, 52(SP)
9D014CFC  8FBE0030   LW FP, 48(SP)
9D014D00  8FB7002C   LW S7, 44(SP)
9D014D04  8FB60028   LW S6, 40(SP)
9D014D08  8FB50024   LW S5, 36(SP)
9D014D0C  8FB40020   LW S4, 32(SP)
9D014D10  8FB3001C   LW S3, 28(SP)
9D014D14  8FB20018   LW S2, 24(SP)
9D014D18  8FB10014   LW S1, 20(SP)
9D014D1C  8FB00010   LW S0, 16(SP)
9D014D20  03E00008   JR RA
9D014D24  27BD0038   ADDIU SP, SP, 56
439:                 
440:                 inline void tft_set_write_area (uint16_t x, uint16_t y, uint16_t xlen, uint16_t ylen)
441:                 	{
9D01432C  27BDFFC8   ADDIU SP, SP, -56
9D014330  AFBF0034   SW RA, 52(SP)
9D014334  AFB70030   SW S7, 48(SP)
9D014338  AFB6002C   SW S6, 44(SP)
9D01433C  AFB50028   SW S5, 40(SP)
9D014340  AFB40024   SW S4, 36(SP)
9D014344  AFB30020   SW S3, 32(SP)
9D014348  AFB2001C   SW S2, 28(SP)
9D01434C  AFB10018   SW S1, 24(SP)
9D014350  AFB00014   SW S0, 20(SP)
9D014354  0080A821   ADDU S5, A0, ZERO
9D014358  00A0A021   ADDU S4, A1, ZERO
9D01435C  00C0B821   ADDU S7, A2, ZERO
9D014360  00E0B021   ADDU S6, A3, ZERO
442:                 	TFT_24_7789_Write_Command(0x002A);
9D014364  0F4050B6   JAL TFT_24_7789_Write_Command
9D014368  2404002A   ADDIU A0, ZERO, 42
9D014478  0F4050B6   JAL TFT_24_7789_Write_Command
9D014604  0F4050B6   JAL TFT_24_7789_Write_Command
9D014BDC  0F4050B6   JAL TFT_24_7789_Write_Command
9D014E50  0F4050B6   JAL TFT_24_7789_Write_Command
9D014E54  2404002A   ADDIU A0, ZERO, 42
9D01526C  0F4050B6   JAL TFT_24_7789_Write_Command
9D015270  2404002A   ADDIU A0, ZERO, 42
9D0159B8  0F4050B6   JAL TFT_24_7789_Write_Command
9D0159BC  2404002A   ADDIU A0, ZERO, 42
9D015DD8  0F4050B6   JAL TFT_24_7789_Write_Command
9D015DDC  2404002A   ADDIU A0, ZERO, 42
443:                 	TFT_24_7789_Write_Data((x>>8)&0xFF);
444:                 	TFT_24_7789_Write_Data((x>>0)&0xFF);
445:                 	TFT_24_7789_Write_Data(((x+xlen)>>8)&0xFF);
9D0143A0  02B7A821   ADDU S5, S5, S7
9D0144B4  02DEB021   ADDU S6, S6, FP
9D014640  27DE0007   ADDIU FP, FP, 7
446:                 	TFT_24_7789_Write_Data(((x+xlen)>>0)&0xFF);
447:                 	TFT_24_7789_Write_Command(0x2B);
9D0143C0  0F4050B6   JAL TFT_24_7789_Write_Command
9D0143C4  2404002B   ADDIU A0, ZERO, 43
9D0144D4  0F4050B6   JAL TFT_24_7789_Write_Command
9D014660  0F4050B6   JAL TFT_24_7789_Write_Command
9D014C2C  0F4050B6   JAL TFT_24_7789_Write_Command
9D014EA4  0F4050B6   JAL TFT_24_7789_Write_Command
9D014EA8  2404002B   ADDIU A0, ZERO, 43
9D0152BC  0F4050B6   JAL TFT_24_7789_Write_Command
9D0152C0  2404002B   ADDIU A0, ZERO, 43
9D015A0C  0F4050B6   JAL TFT_24_7789_Write_Command
9D015A10  2404002B   ADDIU A0, ZERO, 43
9D015E28  0F4050B6   JAL TFT_24_7789_Write_Command
9D015E2C  2404002B   ADDIU A0, ZERO, 43
448:                 	TFT_24_7789_Write_Data((y>>8)&0xFF);
449:                 	TFT_24_7789_Write_Data((y>>0)&0xFF);
450:                 	TFT_24_7789_Write_Data(((y+ylen)>>8)&0xFF);
9D0143EC  0296A021   ADDU S4, S4, S6
9D014500  02B7A821   ADDU S5, S5, S7
9D01468C  26F7000B   ADDIU S7, S7, 11
9D015818  8FA40044   LW A0, 68(SP)
9D01581C  2482000B   ADDIU V0, A0, 11
451:                 	TFT_24_7789_Write_Data(((y+ylen)>>0)&0xFF);
452:                 	}
9D01440C  8FBF0034   LW RA, 52(SP)
9D014410  8FB70030   LW S7, 48(SP)
9D014414  8FB6002C   LW S6, 44(SP)
9D014418  8FB50028   LW S5, 40(SP)
9D01441C  8FB40024   LW S4, 36(SP)
9D014420  8FB30020   LW S3, 32(SP)
9D014424  8FB2001C   LW S2, 28(SP)
9D014428  8FB10018   LW S1, 24(SP)
9D01442C  8FB00014   LW S0, 20(SP)
9D014430  03E00008   JR RA
9D014434  27BD0038   ADDIU SP, SP, 56
453:                 
454:                 
455:                 
456:                 /*******************************************************************************/
457:                 void TFT_24_7789_Write_Command(uint16_t command)
458:                 	{
459:                 	LCD_RD = 1;
9D0142D8  3C02BF88   LUI V0, -16504
9D0142DC  94436330   LHU V1, 25392(V0)
9D0142E0  24050001   ADDIU A1, ZERO, 1
9D0142E4  7CA32944   INS V1, A1, 5, 1
9D0142E8  A4436330   SH V1, 25392(V0)
460:                 	LCD_DC = 0;
9D0142EC  3C02BF88   LUI V0, -16504
9D0142F0  94436630   LHU V1, 26160(V0)
9D0142F4  7C034204   INS V1, ZERO, 8, 1
9D0142F8  A4436630   SH V1, 26160(V0)
461:                 	LCD_WR_CLR;
9D0142FC  24030010   ADDIU V1, ZERO, 16
9D014300  3C06BF88   LUI A2, -16504
9D014304  ACC36324   SW V1, 25380(A2)
462:                 	LCD_PORT = command;
9D014308  3C06BF88   LUI A2, -16504
9D01430C  ACC46430   SW A0, 25648(A2)
463:                 	LCD_WR_SET;
9D014310  3C04BF88   LUI A0, -16504
9D014314  AC836328   SW V1, 25384(A0)
464:                 	LCD_DC = 1;
9D014318  94436630   LHU V1, 26160(V0)
9D01431C  7CA34204   INS V1, A1, 8, 1
9D014320  A4436630   SH V1, 26160(V0)
9D014324  03E00008   JR RA
9D014328  00000000   NOP
465:                 	}
466:                 /*******************************************************************************/
467:                 inline void TFT_24_7789_Write_Data(uint16_t data1)
468:                 	{
469:                 	LCD_WR_CLR;
9D01436C  3C13BF88   LUI S3, -16504
9D01438C  AE706324   SW S0, 25380(S3)
9D01439C  AE706324   SW S0, 25380(S3)
9D0143B0  AE706324   SW S0, 25380(S3)
9D0143C8  AE706324   SW S0, 25380(S3)
9D0143D8  AE706324   SW S0, 25380(S3)
9D0143E8  AE706324   SW S0, 25380(S3)
9D0143FC  AE706324   SW S0, 25380(S3)
9D014480  3C14BF88   LUI S4, -16504
9D0144A0  AE906324   SW S0, 25380(S4)
9D0144B0  AE906324   SW S0, 25380(S4)
9D0144C4  AE906324   SW S0, 25380(S4)
9D0144DC  AE906324   SW S0, 25380(S4)
9D0144EC  AE906324   SW S0, 25380(S4)
9D0144FC  AE906324   SW S0, 25380(S4)
9D014510  AE906324   SW S0, 25380(S4)
9D01460C  3C16BF88   LUI S6, -16504
9D01462C  AED36324   SW S3, 25380(S6)
9D01463C  AED36324   SW S3, 25380(S6)
9D014650  AED36324   SW S3, 25380(S6)
9D014668  AED36324   SW S3, 25380(S6)
9D014678  AED36324   SW S3, 25380(S6)
9D014688  AED36324   SW S3, 25380(S6)
9D01469C  AED36324   SW S3, 25380(S6)
9D014BE4  3C14BF88   LUI S4, -16504
9D014C00  AE916324   SW S1, 25380(S4)
9D014C0C  AE916324   SW S1, 25380(S4)
9D014C1C  AE916324   SW S1, 25380(S4)
9D014C34  AE916324   SW S1, 25380(S4)
9D014C40  AE916324   SW S1, 25380(S4)
9D014C4C  AE916324   SW S1, 25380(S4)
9D014C5C  AE916324   SW S1, 25380(S4)
9D014DA4  3C16BF88   LUI S6, -16504
9D014E58  24030010   ADDIU V1, ZERO, 16
9D014E5C  AEC36324   SW V1, 25380(S6)
9D014E70  AEC36324   SW V1, 25380(S6)
9D014E80  AEC36324   SW V1, 25380(S6)
9D014E94  AEC36324   SW V1, 25380(S6)
9D014EAC  24060010   ADDIU A2, ZERO, 16
9D014EB0  AEC66324   SW A2, 25380(S6)
9D014EC0  AEC66324   SW A2, 25380(S6)
9D014ED0  AEC66324   SW A2, 25380(S6)
9D014EE0  AEC66324   SW A2, 25380(S6)
9D015274  24120010   ADDIU S2, ZERO, 16
9D015278  AED26324   SW S2, 25380(S6)
9D015288  AED26324   SW S2, 25380(S6)
9D015298  AED26324   SW S2, 25380(S6)
9D0152AC  AED26324   SW S2, 25380(S6)
9D0152C4  AED26324   SW S2, 25380(S6)
9D0152D4  AED26324   SW S2, 25380(S6)
9D0152E4  AED26324   SW S2, 25380(S6)
9D0152F4  AED26324   SW S2, 25380(S6)
9D01590C  3C16BF88   LUI S6, -16504
9D0159C0  24030010   ADDIU V1, ZERO, 16
9D0159C4  AEC36324   SW V1, 25380(S6)
9D0159D8  AEC36324   SW V1, 25380(S6)
9D0159E8  AEC36324   SW V1, 25380(S6)
9D0159FC  AEC36324   SW V1, 25380(S6)
9D015A14  24020010   ADDIU V0, ZERO, 16
9D015A18  AEC26324   SW V0, 25380(S6)
9D015A28  AEC26324   SW V0, 25380(S6)
9D015A38  AEC26324   SW V0, 25380(S6)
9D015A48  AEC26324   SW V0, 25380(S6)
9D015DE0  24120010   ADDIU S2, ZERO, 16
9D015DE4  AED26324   SW S2, 25380(S6)
9D015DF4  AED26324   SW S2, 25380(S6)
9D015E04  AED26324   SW S2, 25380(S6)
9D015E18  AED26324   SW S2, 25380(S6)
9D015E30  AED26324   SW S2, 25380(S6)
9D015E40  AED26324   SW S2, 25380(S6)
9D015E50  AED26324   SW S2, 25380(S6)
9D015E60  AED26324   SW S2, 25380(S6)
9D0163E0  24020010   ADDIU V0, ZERO, 16
9D0163E4  3C03BF88   LUI V1, -16504
9D0163E8  AC626324   SW V0, 25380(V1)
9D016504  3C13BF88   LUI S3, -16504
9D01652C  AE706324   SW S0, 25380(S3)
9D016544  AE706324   SW S0, 25380(S3)
9D016554  AE706324   SW S0, 25380(S3)
9D016560  AE706324   SW S0, 25380(S3)
9D01656C  AE706324   SW S0, 25380(S3)
9D01657C  AE706324   SW S0, 25380(S3)
9D016590  AE706324   SW S0, 25380(S3)
9D0165A8  AE706324   SW S0, 25380(S3)
9D0165C0  AE706324   SW S0, 25380(S3)
9D0165D8  AE706324   SW S0, 25380(S3)
9D0165E4  AE706324   SW S0, 25380(S3)
9D0165FC  AE706324   SW S0, 25380(S3)
9D016614  AE706324   SW S0, 25380(S3)
9D01662C  AE706324   SW S0, 25380(S3)
9D016644  AE706324   SW S0, 25380(S3)
9D016654  AE706324   SW S0, 25380(S3)
9D01666C  AE706324   SW S0, 25380(S3)
9D01667C  AE706324   SW S0, 25380(S3)
9D016688  AE706324   SW S0, 25380(S3)
9D016698  AE706324   SW S0, 25380(S3)
9D0166A8  AE706324   SW S0, 25380(S3)
9D0166B8  AE706324   SW S0, 25380(S3)
9D0166C8  AE706324   SW S0, 25380(S3)
9D0166D8  AE706324   SW S0, 25380(S3)
9D0166E8  AE706324   SW S0, 25380(S3)
9D0166F8  AE706324   SW S0, 25380(S3)
9D016708  AE706324   SW S0, 25380(S3)
9D016714  AE706324   SW S0, 25380(S3)
9D016724  AE706324   SW S0, 25380(S3)
9D016734  AE706324   SW S0, 25380(S3)
9D01674C  AE706324   SW S0, 25380(S3)
9D016758  AE706324   SW S0, 25380(S3)
9D016764  AE706324   SW S0, 25380(S3)
9D016770  AE706324   SW S0, 25380(S3)
9D01677C  AE706324   SW S0, 25380(S3)
9D016788  AE706324   SW S0, 25380(S3)
9D016798  AE706324   SW S0, 25380(S3)
9D0167A8  AE706324   SW S0, 25380(S3)
9D0167B8  AE706324   SW S0, 25380(S3)
9D0167C8  AE706324   SW S0, 25380(S3)
9D0167D8  AE706324   SW S0, 25380(S3)
9D0167E8  AE706324   SW S0, 25380(S3)
9D0167F8  AE706324   SW S0, 25380(S3)
9D016808  AE706324   SW S0, 25380(S3)
9D016820  AE706324   SW S0, 25380(S3)
9D01682C  AE706324   SW S0, 25380(S3)
9D016838  AE706324   SW S0, 25380(S3)
9D016844  AE706324   SW S0, 25380(S3)
9D01685C  AE706324   SW S0, 25380(S3)
9D016868  AE706324   SW S0, 25380(S3)
9D016874  AE706324   SW S0, 25380(S3)
9D016880  AE706324   SW S0, 25380(S3)
470:                 	LCD_PORT = data1;
9D014378  00151202   SRL V0, S5, 8
9D014390  32A200FF   ANDI V0, S5, 255
9D0143A4  7EA23A00   EXT V0, S5, 8, 8
9D0143A8  AE426430   SW V0, 25648(S2)
9D0143B4  32B500FF   ANDI S5, S5, 255
9D0143CC  00141202   SRL V0, S4, 8
9D0143DC  328200FF   ANDI V0, S4, 255
9D0143F0  7E823A00   EXT V0, S4, 8, 8
9D0143F4  AE426430   SW V0, 25648(S2)
9D014400  329400FF   ANDI S4, S4, 255
9D01448C  00161202   SRL V0, S6, 8
9D0144A4  32C200FF   ANDI V0, S6, 255
9D0144B8  7EC23A00   EXT V0, S6, 8, 8
9D0144C8  32D600FF   ANDI S6, S6, 255
9D0144E0  00151202   SRL V0, S5, 8
9D0144F0  32A200FF   ANDI V0, S5, 255
9D014504  7EA23A00   EXT V0, S5, 8, 8
9D014514  32B500FF   ANDI S5, S5, 255
9D014618  001E1202   SRL V0, FP, 8
9D014630  33C200FF   ANDI V0, FP, 255
9D014644  7FC23A00   EXT V0, FP, 8, 8
9D014654  33DE00FF   ANDI FP, FP, 255
9D01466C  00171202   SRL V0, S7, 8
9D01467C  32E200FF   ANDI V0, S7, 255
9D014690  7EE23A00   EXT V0, S7, 8, 8
9D0146A0  32F700FF   ANDI S7, S7, 255
9D014BF0  3C13BF88   LUI S3, -16504
9D014C04  AE606430   SW ZERO, 25648(S3)
9D014C10  001E1202   SRL V0, FP, 8
9D014C20  33DE00FF   ANDI FP, FP, 255
9D014C38  AE606430   SW ZERO, 25648(S3)
9D014C44  AE606430   SW ZERO, 25648(S3)
9D014C50  00161202   SRL V0, S6, 8
9D014C60  32D600FF   ANDI S6, S6, 255
9D014DA8  3C1EBF88   LUI FP, -16504
9D014E60  8FA4001C   LW A0, 28(SP)
9D014E64  00041202   SRL V0, A0, 8
9D014E68  AFC26430   SW V0, 25648(FP)
9D014E74  308200F8   ANDI V0, A0, 248
9D014E78  AFC26430   SW V0, 25648(FP)
9D014E84  8FA50014   LW A1, 20(SP)
9D014E88  7CA23A00   EXT V0, A1, 8, 8
9D014E8C  AFC26430   SW V0, 25648(FP)
9D014E98  30A200FF   ANDI V0, A1, 255
9D014E9C  AFC26430   SW V0, 25648(FP)
9D014EB4  8FA20028   LW V0, 40(SP)
9D014EB8  AFC26430   SW V0, 25648(FP)
9D014EC4  8FA3002C   LW V1, 44(SP)
9D014EC8  AFC36430   SW V1, 25648(FP)
9D014ED4  8FA40030   LW A0, 48(SP)
9D014ED8  AFC46430   SW A0, 25648(FP)
9D014EE4  8FA50034   LW A1, 52(SP)
9D014EE8  AFC56430   SW A1, 25648(FP)
9D01527C  00131202   SRL V0, S3, 8
9D015280  AFC26430   SW V0, 25648(FP)
9D01528C  327300F8   ANDI S3, S3, 248
9D01529C  8FA40014   LW A0, 20(SP)
9D0152B0  308200FF   ANDI V0, A0, 255
9D0152C8  8FA50028   LW A1, 40(SP)
9D0152D8  8FA6002C   LW A2, 44(SP)
9D0152E8  8FA20030   LW V0, 48(SP)
9D0152F8  8FA30034   LW V1, 52(SP)
9D0152FC  AFC36430   SW V1, 25648(FP)
9D015800  8FA60044   LW A2, 68(SP)
9D015804  00063202   SRL A2, A2, 8
9D015808  AFA60028   SW A2, 40(SP)
9D01580C  8FA20044   LW V0, 68(SP)
9D015810  304200FF   ANDI V0, V0, 255
9D015814  AFA2002C   SW V0, 44(SP)
9D015820  7C453A00   EXT A1, V0, 8, 8
9D015824  AFA50030   SW A1, 48(SP)
9D015828  304200FF   ANDI V0, V0, 255
9D01582C  AFA20034   SW V0, 52(SP)
9D01584C  24020007   ADDIU V0, ZERO, 7
9D015850  AFA20014   SW V0, 20(SP)
9D015854  0B405372   J 0x9D014DC8
9D015858  AFA00010   SW ZERO, 16(SP)
9D015910  3C17BF88   LUI S7, -16504
9D015914  3C029D03   LUI V0, -25341
9D015918  24428848   ADDIU V0, V0, -30648
9D01591C  AFA20040   SW V0, 64(SP)
9D015920  244308D0   ADDIU V1, V0, 2256
9D015924  AFA3003C   SW V1, 60(SP)
9D0159C8  8FA40018   LW A0, 24(SP)
9D0159CC  00041202   SRL V0, A0, 8
9D0159D0  AEE26430   SW V0, 25648(S7)
9D0159DC  308200F8   ANDI V0, A0, 248
9D0159E0  AEE26430   SW V0, 25648(S7)
9D0159EC  8FA60014   LW A2, 20(SP)
9D0159F0  7CC23A00   EXT V0, A2, 8, 8
9D0159F4  AEE26430   SW V0, 25648(S7)
9D015A00  30C200FF   ANDI V0, A2, 255
9D015A04  AEE26430   SW V0, 25648(S7)
9D015A1C  8FA30028   LW V1, 40(SP)
9D015A20  AEE36430   SW V1, 25648(S7)
9D015A2C  8FA4002C   LW A0, 44(SP)
9D015A30  AEE46430   SW A0, 25648(S7)
9D015A3C  8FA60030   LW A2, 48(SP)
9D015A40  AEE66430   SW A2, 25648(S7)
9D015A4C  8FA20034   LW V0, 52(SP)
9D015A50  AEE26430   SW V0, 25648(S7)
9D015DE8  00131202   SRL V0, S3, 8
9D015DEC  AEE26430   SW V0, 25648(S7)
9D015DF8  327300F8   ANDI S3, S3, 248
9D015E08  8FA30014   LW V1, 20(SP)
9D015E1C  306200FF   ANDI V0, V1, 255
9D015E34  8FA40028   LW A0, 40(SP)
9D015E44  8FA6002C   LW A2, 44(SP)
9D015E54  8FA20030   LW V0, 48(SP)
9D015E64  8FA30034   LW V1, 52(SP)
9D015E68  AEE36430   SW V1, 25648(S7)
9D016370  00033202   SRL A2, V1, 8
9D016374  AFA60028   SW A2, 40(SP)
9D016378  306300FF   ANDI V1, V1, 255
9D01637C  AFA3002C   SW V1, 44(SP)
9D016380  7C833A00   EXT V1, A0, 8, 8
9D016384  AFA30030   SW V1, 48(SP)
9D016388  304200FF   ANDI V0, V0, 255
9D01638C  AFA20034   SW V0, 52(SP)
9D016390  24040007   ADDIU A0, ZERO, 7
9D016394  AFA40014   SW A0, 20(SP)
9D016398  AFA00010   SW ZERO, 16(SP)
9D0163EC  3C03BF88   LUI V1, -16504
9D0163F0  AC646430   SW A0, 25648(V1)
9D016510  3C12BF88   LUI S2, -16504
9D016530  24020066   ADDIU V0, ZERO, 102
9D016548  2415000C   ADDIU S5, ZERO, 12
9D016558  AE556430   SW S5, 25648(S2)
9D016564  AE406430   SW ZERO, 25648(S2)
9D016570  24020033   ADDIU V0, ZERO, 51
9D016580  AE426430   SW V0, 25648(S2)
9D016594  24020035   ADDIU V0, ZERO, 53
9D016598  AE426430   SW V0, 25648(S2)
9D0165AC  2402002B   ADDIU V0, ZERO, 43
9D0165B0  AE426430   SW V0, 25648(S2)
9D0165C4  2402002C   ADDIU V0, ZERO, 44
9D0165C8  AE426430   SW V0, 25648(S2)
9D0165DC  AE546430   SW S4, 25648(S2)
9D0165E8  240200FF   ADDIU V0, ZERO, 255
9D0165EC  AE426430   SW V0, 25648(S2)
9D016600  24020011   ADDIU V0, ZERO, 17
9D016604  AE426430   SW V0, 25648(S2)
9D016618  24020020   ADDIU V0, ZERO, 32
9D01661C  AE426430   SW V0, 25648(S2)
9D016630  2402000F   ADDIU V0, ZERO, 15
9D016634  AE426430   SW V0, 25648(S2)
9D016648  240200A4   ADDIU V0, ZERO, 164
9D01664C  AE426430   SW V0, 25648(S2)
9D016658  240200A1   ADDIU V0, ZERO, 161
9D01665C  AE426430   SW V0, 25648(S2)
9D016670  241E00D0   ADDIU FP, ZERO, 208
9D016674  AE5E6430   SW FP, 25648(S2)
9D016680  AE406430   SW ZERO, 25648(S2)
9D01668C  24170005   ADDIU S7, ZERO, 5
9D016690  AE576430   SW S7, 25648(S2)
9D01669C  2402000E   ADDIU V0, ZERO, 14
9D0166A0  AE426430   SW V0, 25648(S2)
9D0166AC  24020015   ADDIU V0, ZERO, 21
9D0166B0  AE426430   SW V0, 25648(S2)
9D0166BC  2416000D   ADDIU S6, ZERO, 13
9D0166C0  AE566430   SW S6, 25648(S2)
9D0166CC  24030037   ADDIU V1, ZERO, 55
9D0166D0  AE436430   SW V1, 25648(S2)
9D0166DC  24030043   ADDIU V1, ZERO, 67
9D0166E0  AE436430   SW V1, 25648(S2)
9D0166EC  24030047   ADDIU V1, ZERO, 71
9D0166F0  AE436430   SW V1, 25648(S2)
9D0166FC  24030009   ADDIU V1, ZERO, 9
9D016700  AE436430   SW V1, 25648(S2)
9D01670C  AE426430   SW V0, 25648(S2)
9D016718  24020012   ADDIU V0, ZERO, 18
9D01671C  AE426430   SW V0, 25648(S2)
9D016728  24020016   ADDIU V0, ZERO, 22
9D01672C  AE426430   SW V0, 25648(S2)
9D016738  24020019   ADDIU V0, ZERO, 25
9D01673C  AE426430   SW V0, 25648(S2)
9D016750  AE5E6430   SW FP, 25648(S2)
9D01675C  AE406430   SW ZERO, 25648(S2)
9D016768  AE576430   SW S7, 25648(S2)
9D016774  AE566430   SW S6, 25648(S2)
9D016780  AE556430   SW S5, 25648(S2)
9D01678C  24020006   ADDIU V0, ZERO, 6
9D016790  AE426430   SW V0, 25648(S2)
9D01679C  2402002D   ADDIU V0, ZERO, 45
9D0167A0  AE426430   SW V0, 25648(S2)
9D0167AC  24020044   ADDIU V0, ZERO, 68
9D0167B0  AE426430   SW V0, 25648(S2)
9D0167BC  24020040   ADDIU V0, ZERO, 64
9D0167C0  AE426430   SW V0, 25648(S2)
9D0167CC  2402000E   ADDIU V0, ZERO, 14
9D0167D0  AE426430   SW V0, 25648(S2)
9D0167DC  2402001C   ADDIU V0, ZERO, 28
9D0167E0  AE426430   SW V0, 25648(S2)
9D0167EC  24020018   ADDIU V0, ZERO, 24
9D0167F0  AE426430   SW V0, 25648(S2)
9D0167FC  24020016   ADDIU V0, ZERO, 22
9D016800  AE426430   SW V0, 25648(S2)
9D01680C  24020019   ADDIU V0, ZERO, 25
9D016810  AE426430   SW V0, 25648(S2)
9D016824  AE406430   SW ZERO, 25648(S2)
9D016830  AE406430   SW ZERO, 25648(S2)
9D01683C  AE546430   SW S4, 25648(S2)
9D016848  2402003F   ADDIU V0, ZERO, 63
9D01684C  AE426430   SW V0, 25648(S2)
9D016860  AE406430   SW ZERO, 25648(S2)
9D01686C  AE406430   SW ZERO, 25648(S2)
9D016878  AE406430   SW ZERO, 25648(S2)
9D016884  240200EF   ADDIU V0, ZERO, 239
9D016888  AE426430   SW V0, 25648(S2)
471:                 	LCD_WR_SET;
9D014384  3C11BF88   LUI S1, -16504
9D014398  AE306328   SW S0, 25384(S1)
9D0143AC  AE306328   SW S0, 25384(S1)
9D0143BC  AE306328   SW S0, 25384(S1)
9D0143D4  AE306328   SW S0, 25384(S1)
9D0143E4  AE306328   SW S0, 25384(S1)
9D0143F8  AE306328   SW S0, 25384(S1)
9D014408  AE306328   SW S0, 25384(S1)
9D014498  3C12BF88   LUI S2, -16504
9D0144AC  AE506328   SW S0, 25384(S2)
9D0144C0  AE506328   SW S0, 25384(S2)
9D0144D0  AE506328   SW S0, 25384(S2)
9D0144E8  AE506328   SW S0, 25384(S2)
9D0144F8  AE506328   SW S0, 25384(S2)
9D01450C  AE506328   SW S0, 25384(S2)
9D01451C  AE506328   SW S0, 25384(S2)
9D014624  3C14BF88   LUI S4, -16504
9D014638  AE936328   SW S3, 25384(S4)
9D01464C  AE936328   SW S3, 25384(S4)
9D01465C  AE936328   SW S3, 25384(S4)
9D014674  AE936328   SW S3, 25384(S4)
9D014684  AE936328   SW S3, 25384(S4)
9D014698  AE936328   SW S3, 25384(S4)
9D0146A8  AE936328   SW S3, 25384(S4)
9D014BF8  3C12BF88   LUI S2, -16504
9D014C08  AE516328   SW S1, 25384(S2)
9D014C18  AE516328   SW S1, 25384(S2)
9D014C28  AE516328   SW S1, 25384(S2)
9D014C3C  AE516328   SW S1, 25384(S2)
9D014C48  AE516328   SW S1, 25384(S2)
9D014C58  AE516328   SW S1, 25384(S2)
9D014C68  AE516328   SW S1, 25384(S2)
9D014DAC  3C17BF88   LUI S7, -16504
9D014DB0  3C029D03   LUI V0, -25341
9D014DB4  24428848   ADDIU V0, V0, -30648
9D014DB8  AFA20040   SW V0, 64(SP)
9D014DBC  244208D0   ADDIU V0, V0, 2256
9D014DC0  0B405600   J 0x9D015800
9D014DC4  AFA2003C   SW V0, 60(SP)
9D014DC8  8FA30010   LW V1, 16(SP)
9D014DCC  3073FFFF   ANDI S3, V1, -1
9D014E6C  AEE36328   SW V1, 25384(S7)
9D014E7C  AEE36328   SW V1, 25384(S7)
9D014E90  AEE36328   SW V1, 25384(S7)
9D014EA0  AEE36328   SW V1, 25384(S7)
9D014EBC  AEE66328   SW A2, 25384(S7)
9D014ECC  AEE66328   SW A2, 25384(S7)
9D014EDC  AEE66328   SW A2, 25384(S7)
9D014EEC  AEE66328   SW A2, 25384(S7)
9D015284  AEF26328   SW S2, 25384(S7)
9D015294  AEF26328   SW S2, 25384(S7)
9D0152A8  AEF26328   SW S2, 25384(S7)
9D0152B8  AEF26328   SW S2, 25384(S7)
9D0152D0  AEF26328   SW S2, 25384(S7)
9D0152E0  AEF26328   SW S2, 25384(S7)
9D0152F0  AEF26328   SW S2, 25384(S7)
9D015300  AEF26328   SW S2, 25384(S7)
9D015928  0B4058D8   J 0x9D016360
9D01592C  3C1EBF88   LUI FP, -16504
9D015930  8FA4007C   LW A0, 124(SP)
9D015934  8FA60020   LW A2, 32(SP)
9D015938  00861021   ADDU V0, A0, A2
9D01593C  8FA30010   LW V1, 16(SP)
9D015940  00431021   ADDU V0, V0, V1
9D0159D4  AFC36328   SW V1, 25384(FP)
9D0159E4  AFC36328   SW V1, 25384(FP)
9D0159F8  AFC36328   SW V1, 25384(FP)
9D015A08  AFC36328   SW V1, 25384(FP)
9D015A24  AFC26328   SW V0, 25384(FP)
9D015A34  AFC26328   SW V0, 25384(FP)
9D015A44  AFC26328   SW V0, 25384(FP)
9D015A54  24030010   ADDIU V1, ZERO, 16
9D015A58  AFC36328   SW V1, 25384(FP)
9D015DF0  AFD26328   SW S2, 25384(FP)
9D015E00  AFD26328   SW S2, 25384(FP)
9D015E14  AFD26328   SW S2, 25384(FP)
9D015E24  AFD26328   SW S2, 25384(FP)
9D015E3C  AFD26328   SW S2, 25384(FP)
9D015E4C  AFD26328   SW S2, 25384(FP)
9D015E5C  AFD26328   SW S2, 25384(FP)
9D015E6C  AFD26328   SW S2, 25384(FP)
9D0163F4  3C03BF88   LUI V1, -16504
9D0163F8  AC626328   SW V0, 25384(V1)
9D0163FC  03E00008   JR RA
9D016400  00000000   NOP
9D01651C  3C11BF88   LUI S1, -16504
9D016538  AE306328   SW S0, 25384(S1)
9D016550  AE306328   SW S0, 25384(S1)
9D01655C  AE306328   SW S0, 25384(S1)
9D016568  AE306328   SW S0, 25384(S1)
9D016578  AE306328   SW S0, 25384(S1)
9D016584  AE306328   SW S0, 25384(S1)
9D01659C  AE306328   SW S0, 25384(S1)
9D0165B4  AE306328   SW S0, 25384(S1)
9D0165CC  AE306328   SW S0, 25384(S1)
9D0165E0  AE306328   SW S0, 25384(S1)
9D0165F0  AE306328   SW S0, 25384(S1)
9D016608  AE306328   SW S0, 25384(S1)
9D016620  AE306328   SW S0, 25384(S1)
9D016638  AE306328   SW S0, 25384(S1)
9D016650  AE306328   SW S0, 25384(S1)
9D016660  AE306328   SW S0, 25384(S1)
9D016678  AE306328   SW S0, 25384(S1)
9D016684  AE306328   SW S0, 25384(S1)
9D016694  AE306328   SW S0, 25384(S1)
9D0166A4  AE306328   SW S0, 25384(S1)
9D0166B4  AE306328   SW S0, 25384(S1)
9D0166C4  AE306328   SW S0, 25384(S1)
9D0166D4  AE306328   SW S0, 25384(S1)
9D0166E4  AE306328   SW S0, 25384(S1)
9D0166F4  AE306328   SW S0, 25384(S1)
9D016704  AE306328   SW S0, 25384(S1)
9D016710  AE306328   SW S0, 25384(S1)
9D016720  AE306328   SW S0, 25384(S1)
9D016730  AE306328   SW S0, 25384(S1)
9D016740  AE306328   SW S0, 25384(S1)
9D016754  AE306328   SW S0, 25384(S1)
9D016760  AE306328   SW S0, 25384(S1)
9D01676C  AE306328   SW S0, 25384(S1)
9D016778  AE306328   SW S0, 25384(S1)
9D016784  AE306328   SW S0, 25384(S1)
9D016794  AE306328   SW S0, 25384(S1)
9D0167A4  AE306328   SW S0, 25384(S1)
9D0167B4  AE306328   SW S0, 25384(S1)
9D0167C4  AE306328   SW S0, 25384(S1)
9D0167D4  AE306328   SW S0, 25384(S1)
9D0167E4  AE306328   SW S0, 25384(S1)
9D0167F4  AE306328   SW S0, 25384(S1)
9D016804  AE306328   SW S0, 25384(S1)
9D016814  AE306328   SW S0, 25384(S1)
9D016828  AE306328   SW S0, 25384(S1)
9D016834  AE306328   SW S0, 25384(S1)
9D016840  AE306328   SW S0, 25384(S1)
9D016850  AE306328   SW S0, 25384(S1)
9D016864  AE306328   SW S0, 25384(S1)
9D016870  AE306328   SW S0, 25384(S1)
9D01687C  AE306328   SW S0, 25384(S1)
9D01688C  AE306328   SW S0, 25384(S1)
472:                 	}
473:                 
474:                 inline void TFT_24_7789_Write_Data3(uint16_t data1,uint16_t data2, uint16_t data3)
475:                 	{
476:                 	LCD_WR_CLR;
9D014548  02802821   ADDU A1, S4, ZERO
9D01454C  24020010   ADDIU V0, ZERO, 16
9D01455C  ACA26324   SW V0, 25380(A1)
9D0146C8  02C02821   ADDU A1, S6, ZERO
9D0146CC  24020010   ADDIU V0, ZERO, 16
9D0146D8  ACA26324   SW V0, 25380(A1)
9D0146FC  ACA26324   SW V0, 25380(A1)
9D014720  ACA26324   SW V0, 25380(A1)
9D014744  ACA26324   SW V0, 25380(A1)
9D014768  ACA26324   SW V0, 25380(A1)
9D01478C  ACA26324   SW V0, 25380(A1)
9D0147B0  ACA26324   SW V0, 25380(A1)
9D0147D4  ACA26324   SW V0, 25380(A1)
9D014840  3C05BF88   LUI A1, -16504
9D014844  24020010   ADDIU V0, ZERO, 16
9D01486C  ACA26324   SW V0, 25380(A1)
9D014898  ACA26324   SW V0, 25380(A1)
9D0148CC  ACA26324   SW V0, 25380(A1)
9D0148F8  ACA26324   SW V0, 25380(A1)
9D01492C  ACA26324   SW V0, 25380(A1)
9D014958  ACA26324   SW V0, 25380(A1)
9D01498C  ACA26324   SW V0, 25380(A1)
9D0149B8  ACA26324   SW V0, 25380(A1)
9D0149EC  ACA26324   SW V0, 25380(A1)
9D014A18  ACA26324   SW V0, 25380(A1)
9D014A4C  ACA26324   SW V0, 25380(A1)
9D014A78  ACA26324   SW V0, 25380(A1)
9D014AAC  ACA26324   SW V0, 25380(A1)
9D014AD8  ACA26324   SW V0, 25380(A1)
9D014B08  ACA26324   SW V0, 25380(A1)
9D014B34  ACA26324   SW V0, 25380(A1)
9D014F00  24020010   ADDIU V0, ZERO, 16
9D014F04  8FA6003C   LW A2, 60(SP)
9D014F1C  AEC26324   SW V0, 25380(S6)
9D014F48  AEC26324   SW V0, 25380(S6)
9D014F7C  AEC26324   SW V0, 25380(S6)
9D014FA8  AEC26324   SW V0, 25380(S6)
9D014FDC  AEC26324   SW V0, 25380(S6)
9D015008  AEC26324   SW V0, 25380(S6)
9D01503C  AEC26324   SW V0, 25380(S6)
9D015068  AEC26324   SW V0, 25380(S6)
9D01509C  AEC26324   SW V0, 25380(S6)
9D0150C8  AEC26324   SW V0, 25380(S6)
9D0150FC  AEC26324   SW V0, 25380(S6)
9D015128  AEC26324   SW V0, 25380(S6)
9D01515C  AEC26324   SW V0, 25380(S6)
9D015188  AEC26324   SW V0, 25380(S6)
9D0151B8  AEC26324   SW V0, 25380(S6)
9D0151E4  AEC26324   SW V0, 25380(S6)
9D015320  24020010   ADDIU V0, ZERO, 16
9D015324  AEC26324   SW V0, 25380(S6)
9D015348  AEC26324   SW V0, 25380(S6)
9D01536C  AEC26324   SW V0, 25380(S6)
9D015390  AEC26324   SW V0, 25380(S6)
9D0153B4  AEC26324   SW V0, 25380(S6)
9D0153D8  AEC26324   SW V0, 25380(S6)
9D0153FC  AEC26324   SW V0, 25380(S6)
9D015420  AEC26324   SW V0, 25380(S6)
9D015484  24020010   ADDIU V0, ZERO, 16
9D0154A4  AEC26324   SW V0, 25380(S6)
9D0154D0  AEC26324   SW V0, 25380(S6)
9D015504  AEC26324   SW V0, 25380(S6)
9D015530  AEC26324   SW V0, 25380(S6)
9D015564  AEC26324   SW V0, 25380(S6)
9D015590  AEC26324   SW V0, 25380(S6)
9D0155C4  AEC26324   SW V0, 25380(S6)
9D0155F0  AEC26324   SW V0, 25380(S6)
9D015624  AEC26324   SW V0, 25380(S6)
9D015650  AEC26324   SW V0, 25380(S6)
9D015684  AEC26324   SW V0, 25380(S6)
9D0156B0  AEC26324   SW V0, 25380(S6)
9D0156E4  AEC26324   SW V0, 25380(S6)
9D015710  AEC26324   SW V0, 25380(S6)
9D015740  AEC26324   SW V0, 25380(S6)
9D01576C  AEC26324   SW V0, 25380(S6)
9D015A6C  24020010   ADDIU V0, ZERO, 16
9D015A70  8FA6003C   LW A2, 60(SP)
9D015A88  AEC26324   SW V0, 25380(S6)
9D015AB4  AEC26324   SW V0, 25380(S6)
9D015AE8  AEC26324   SW V0, 25380(S6)
9D015B14  AEC26324   SW V0, 25380(S6)
9D015B48  AEC26324   SW V0, 25380(S6)
9D015B74  AEC26324   SW V0, 25380(S6)
9D015BA8  AEC26324   SW V0, 25380(S6)
9D015BD4  AEC26324   SW V0, 25380(S6)
9D015C08  AEC26324   SW V0, 25380(S6)
9D015C34  AEC26324   SW V0, 25380(S6)
9D015C68  AEC26324   SW V0, 25380(S6)
9D015C94  AEC26324   SW V0, 25380(S6)
9D015CC8  AEC26324   SW V0, 25380(S6)
9D015CF4  AEC26324   SW V0, 25380(S6)
9D015D24  AEC26324   SW V0, 25380(S6)
9D015D50  AEC26324   SW V0, 25380(S6)
9D015E8C  24020010   ADDIU V0, ZERO, 16
9D015E90  AEC26324   SW V0, 25380(S6)
9D015EB4  AEC26324   SW V0, 25380(S6)
9D015ED8  AEC26324   SW V0, 25380(S6)
9D015EFC  AEC26324   SW V0, 25380(S6)
9D015F20  AEC26324   SW V0, 25380(S6)
9D015F44  AEC26324   SW V0, 25380(S6)
9D015F68  AEC26324   SW V0, 25380(S6)
9D015F8C  AEC26324   SW V0, 25380(S6)
9D015FF0  24020010   ADDIU V0, ZERO, 16
9D016010  AEC26324   SW V0, 25380(S6)
9D01603C  AEC26324   SW V0, 25380(S6)
9D016070  AEC26324   SW V0, 25380(S6)
9D01609C  AEC26324   SW V0, 25380(S6)
9D0160D0  AEC26324   SW V0, 25380(S6)
9D0160FC  AEC26324   SW V0, 25380(S6)
9D016130  AEC26324   SW V0, 25380(S6)
9D01615C  AEC26324   SW V0, 25380(S6)
9D016190  AEC26324   SW V0, 25380(S6)
9D0161BC  AEC26324   SW V0, 25380(S6)
9D0161F0  AEC26324   SW V0, 25380(S6)
9D01621C  AEC26324   SW V0, 25380(S6)
9D016250  AEC26324   SW V0, 25380(S6)
9D01627C  AEC26324   SW V0, 25380(S6)
9D0162AC  AEC26324   SW V0, 25380(S6)
9D0162D8  AEC26324   SW V0, 25380(S6)
9D016404  3C08BF88   LUI T0, -16504
9D016408  24020010   ADDIU V0, ZERO, 16
9D01640C  AD026324   SW V0, 25380(T0)
477:                 	LCD_PORT = data1;
9D01453C  7E2A3C00   EXT T2, S1, 16, 8
9D014550  02602021   ADDU A0, S3, ZERO
9D014560  AC8A6430   SW T2, 25648(A0)
9D0146D0  02A02021   ADDU A0, S5, ZERO
9D0146DC  AC906430   SW S0, 25648(A0)
9D014700  AC906430   SW S0, 25648(A0)
9D014724  AC906430   SW S0, 25648(A0)
9D014748  AC906430   SW S0, 25648(A0)
9D01476C  AC906430   SW S0, 25648(A0)
9D014790  AC906430   SW S0, 25648(A0)
9D0147B4  AC906430   SW S0, 25648(A0)
9D0147D8  AC906430   SW S0, 25648(A0)
9D014848  3C04BF88   LUI A0, -16504
9D014870  AC8A6430   SW T2, 25648(A0)
9D01489C  AC906430   SW S0, 25648(A0)
9D0148D0  AC8A6430   SW T2, 25648(A0)
9D0148FC  AC906430   SW S0, 25648(A0)
9D014930  AC8A6430   SW T2, 25648(A0)
9D01495C  AC906430   SW S0, 25648(A0)
9D014990  AC8A6430   SW T2, 25648(A0)
9D0149BC  AC906430   SW S0, 25648(A0)
9D0149F0  AC8A6430   SW T2, 25648(A0)
9D014A1C  AC906430   SW S0, 25648(A0)
9D014A50  AC8A6430   SW T2, 25648(A0)
9D014A7C  AC906430   SW S0, 25648(A0)
9D014AB0  AC8A6430   SW T2, 25648(A0)
9D014ADC  AC906430   SW S0, 25648(A0)
9D014B0C  AC8A6430   SW T2, 25648(A0)
9D014B38  AC906430   SW S0, 25648(A0)
9D014F20  AFD36430   SW S3, 25648(FP)
9D014F4C  AFD06430   SW S0, 25648(FP)
9D014F80  AFD36430   SW S3, 25648(FP)
9D014FAC  AFD06430   SW S0, 25648(FP)
9D014FE0  AFD36430   SW S3, 25648(FP)
9D01500C  AFD06430   SW S0, 25648(FP)
9D015040  AFD36430   SW S3, 25648(FP)
9D01506C  AFD06430   SW S0, 25648(FP)
9D0150A0  AFD36430   SW S3, 25648(FP)
9D0150CC  AFD06430   SW S0, 25648(FP)
9D015100  AFD36430   SW S3, 25648(FP)
9D01512C  AFD06430   SW S0, 25648(FP)
9D015160  AFD36430   SW S3, 25648(FP)
9D01518C  AFD06430   SW S0, 25648(FP)
9D0151BC  AFD36430   SW S3, 25648(FP)
9D0151E8  AFD06430   SW S0, 25648(FP)
9D015328  AFD46430   SW S4, 25648(FP)
9D01534C  AFD46430   SW S4, 25648(FP)
9D015370  AFD46430   SW S4, 25648(FP)
9D015394  AFD46430   SW S4, 25648(FP)
9D0153B8  AFD46430   SW S4, 25648(FP)
9D0153DC  AFD46430   SW S4, 25648(FP)
9D015400  AFD46430   SW S4, 25648(FP)
9D015424  AFD46430   SW S4, 25648(FP)
9D0154A8  AFC66430   SW A2, 25648(FP)
9D0154D4  AFD46430   SW S4, 25648(FP)
9D015508  AFC66430   SW A2, 25648(FP)
9D015534  AFD46430   SW S4, 25648(FP)
9D015568  AFC66430   SW A2, 25648(FP)
9D015594  AFD46430   SW S4, 25648(FP)
9D0155C8  AFC66430   SW A2, 25648(FP)
9D0155F4  AFD46430   SW S4, 25648(FP)
9D015628  AFC66430   SW A2, 25648(FP)
9D015654  AFD46430   SW S4, 25648(FP)
9D015688  AFC66430   SW A2, 25648(FP)
9D0156B4  AFD46430   SW S4, 25648(FP)
9D0156E8  AFC66430   SW A2, 25648(FP)
9D015714  AFD46430   SW S4, 25648(FP)
9D015744  AFC66430   SW A2, 25648(FP)
9D015770  AFD46430   SW S4, 25648(FP)
9D015A8C  AEF36430   SW S3, 25648(S7)
9D015AB8  AEF06430   SW S0, 25648(S7)
9D015AEC  AEF36430   SW S3, 25648(S7)
9D015B18  AEF06430   SW S0, 25648(S7)
9D015B4C  AEF36430   SW S3, 25648(S7)
9D015B78  AEF06430   SW S0, 25648(S7)
9D015BAC  AEF36430   SW S3, 25648(S7)
9D015BD8  AEF06430   SW S0, 25648(S7)
9D015C0C  AEF36430   SW S3, 25648(S7)
9D015C38  AEF06430   SW S0, 25648(S7)
9D015C6C  AEF36430   SW S3, 25648(S7)
9D015C98  AEF06430   SW S0, 25648(S7)
9D015CCC  AEF36430   SW S3, 25648(S7)
9D015CF8  AEF06430   SW S0, 25648(S7)
9D015D28  AEF36430   SW S3, 25648(S7)
9D015D54  AEF06430   SW S0, 25648(S7)
9D015E94  AEF46430   SW S4, 25648(S7)
9D015EB8  AEF46430   SW S4, 25648(S7)
9D015EDC  AEF46430   SW S4, 25648(S7)
9D015F00  AEF46430   SW S4, 25648(S7)
9D015F24  AEF46430   SW S4, 25648(S7)
9D015F48  AEF46430   SW S4, 25648(S7)
9D015F6C  AEF46430   SW S4, 25648(S7)
9D015F90  AEF46430   SW S4, 25648(S7)
9D016014  AEE66430   SW A2, 25648(S7)
9D016040  AEF46430   SW S4, 25648(S7)
9D016074  AEE66430   SW A2, 25648(S7)
9D0160A0  AEF46430   SW S4, 25648(S7)
9D0160D4  AEE66430   SW A2, 25648(S7)
9D016100  AEF46430   SW S4, 25648(S7)
9D016134  AEE66430   SW A2, 25648(S7)
9D016160  AEF46430   SW S4, 25648(S7)
9D016194  AEE66430   SW A2, 25648(S7)
9D0161C0  AEF46430   SW S4, 25648(S7)
9D0161F4  AEE66430   SW A2, 25648(S7)
9D016220  AEF46430   SW S4, 25648(S7)
9D016254  AEE66430   SW A2, 25648(S7)
9D016280  AEF46430   SW S4, 25648(S7)
9D0162B0  AEE66430   SW A2, 25648(S7)
9D0162DC  AEF46430   SW S4, 25648(S7)
9D016410  3C07BF88   LUI A3, -16504
9D016414  ACE46430   SW A0, 25648(A3)
478:                 	LCD_WR_SET;
9D014554  02401821   ADDU V1, S2, ZERO
9D014564  AC626328   SW V0, 25384(V1)
9D0146D4  02801821   ADDU V1, S4, ZERO
9D0146E0  AC626328   SW V0, 25384(V1)
9D014704  AC626328   SW V0, 25384(V1)
9D014728  AC626328   SW V0, 25384(V1)
9D01474C  AC626328   SW V0, 25384(V1)
9D014770  AC626328   SW V0, 25384(V1)
9D014794  AC626328   SW V0, 25384(V1)
9D0147B8  AC626328   SW V0, 25384(V1)
9D0147DC  AC626328   SW V0, 25384(V1)
9D01484C  3C03BF88   LUI V1, -16504
9D014874  AC626328   SW V0, 25384(V1)
9D0148A0  AC626328   SW V0, 25384(V1)
9D0148D4  AC626328   SW V0, 25384(V1)
9D014900  AC626328   SW V0, 25384(V1)
9D014934  AC626328   SW V0, 25384(V1)
9D014960  AC626328   SW V0, 25384(V1)
9D014994  AC626328   SW V0, 25384(V1)
9D0149C0  AC626328   SW V0, 25384(V1)
9D0149F4  AC626328   SW V0, 25384(V1)
9D014A20  AC626328   SW V0, 25384(V1)
9D014A54  AC626328   SW V0, 25384(V1)
9D014A80  AC626328   SW V0, 25384(V1)
9D014AB4  AC626328   SW V0, 25384(V1)
9D014AE0  AC626328   SW V0, 25384(V1)
9D014B10  AC626328   SW V0, 25384(V1)
9D014B3C  AC626328   SW V0, 25384(V1)
9D014F24  AEE26328   SW V0, 25384(S7)
9D014F50  AEE26328   SW V0, 25384(S7)
9D014F84  AEE26328   SW V0, 25384(S7)
9D014FB0  AEE26328   SW V0, 25384(S7)
9D014FE4  AEE26328   SW V0, 25384(S7)
9D015010  AEE26328   SW V0, 25384(S7)
9D015044  AEE26328   SW V0, 25384(S7)
9D015070  AEE26328   SW V0, 25384(S7)
9D0150A4  AEE26328   SW V0, 25384(S7)
9D0150D0  AEE26328   SW V0, 25384(S7)
9D015104  AEE26328   SW V0, 25384(S7)
9D015130  AEE26328   SW V0, 25384(S7)
9D015164  AEE26328   SW V0, 25384(S7)
9D015190  AEE26328   SW V0, 25384(S7)
9D0151C0  AEE26328   SW V0, 25384(S7)
9D0151EC  AEE26328   SW V0, 25384(S7)
9D01532C  AEE26328   SW V0, 25384(S7)
9D015350  AEE26328   SW V0, 25384(S7)
9D015374  AEE26328   SW V0, 25384(S7)
9D015398  AEE26328   SW V0, 25384(S7)
9D0153BC  AEE26328   SW V0, 25384(S7)
9D0153E0  AEE26328   SW V0, 25384(S7)
9D015404  AEE26328   SW V0, 25384(S7)
9D015428  AEE26328   SW V0, 25384(S7)
9D0154AC  AEE26328   SW V0, 25384(S7)
9D0154D8  AEE26328   SW V0, 25384(S7)
9D01550C  AEE26328   SW V0, 25384(S7)
9D015538  AEE26328   SW V0, 25384(S7)
9D01556C  AEE26328   SW V0, 25384(S7)
9D015598  AEE26328   SW V0, 25384(S7)
9D0155CC  AEE26328   SW V0, 25384(S7)
9D0155F8  AEE26328   SW V0, 25384(S7)
9D01562C  AEE26328   SW V0, 25384(S7)
9D015658  AEE26328   SW V0, 25384(S7)
9D01568C  AEE26328   SW V0, 25384(S7)
9D0156B8  AEE26328   SW V0, 25384(S7)
9D0156EC  AEE26328   SW V0, 25384(S7)
9D015718  AEE26328   SW V0, 25384(S7)
9D015748  AEE26328   SW V0, 25384(S7)
9D015774  AEE26328   SW V0, 25384(S7)
9D015A90  AFC26328   SW V0, 25384(FP)
9D015ABC  AFC26328   SW V0, 25384(FP)
9D015AF0  AFC26328   SW V0, 25384(FP)
9D015B1C  AFC26328   SW V0, 25384(FP)
9D015B50  AFC26328   SW V0, 25384(FP)
9D015B7C  AFC26328   SW V0, 25384(FP)
9D015BB0  AFC26328   SW V0, 25384(FP)
9D015BDC  AFC26328   SW V0, 25384(FP)
9D015C10  AFC26328   SW V0, 25384(FP)
9D015C3C  AFC26328   SW V0, 25384(FP)
9D015C70  AFC26328   SW V0, 25384(FP)
9D015C9C  AFC26328   SW V0, 25384(FP)
9D015CD0  AFC26328   SW V0, 25384(FP)
9D015CFC  AFC26328   SW V0, 25384(FP)
9D015D2C  AFC26328   SW V0, 25384(FP)
9D015D58  AFC26328   SW V0, 25384(FP)
9D015E98  AFC26328   SW V0, 25384(FP)
9D015EBC  AFC26328   SW V0, 25384(FP)
9D015EE0  AFC26328   SW V0, 25384(FP)
9D015F04  AFC26328   SW V0, 25384(FP)
9D015F28  AFC26328   SW V0, 25384(FP)
9D015F4C  AFC26328   SW V0, 25384(FP)
9D015F70  AFC26328   SW V0, 25384(FP)
9D015F94  AFC26328   SW V0, 25384(FP)
9D016018  AFC26328   SW V0, 25384(FP)
9D016044  AFC26328   SW V0, 25384(FP)
9D016078  AFC26328   SW V0, 25384(FP)
9D0160A4  AFC26328   SW V0, 25384(FP)
9D0160D8  AFC26328   SW V0, 25384(FP)
9D016104  AFC26328   SW V0, 25384(FP)
9D016138  AFC26328   SW V0, 25384(FP)
9D016164  AFC26328   SW V0, 25384(FP)
9D016198  AFC26328   SW V0, 25384(FP)
9D0161C4  AFC26328   SW V0, 25384(FP)
9D0161F8  AFC26328   SW V0, 25384(FP)
9D016224  AFC26328   SW V0, 25384(FP)
9D016258  AFC26328   SW V0, 25384(FP)
9D016284  AFC26328   SW V0, 25384(FP)
9D0162B4  AFC26328   SW V0, 25384(FP)
9D0162E0  AFC26328   SW V0, 25384(FP)
9D016418  3C03BF88   LUI V1, -16504
9D01641C  AC626328   SW V0, 25384(V1)
479:                 	LCD_WR_CLR;
9D014568  ACA26324   SW V0, 25380(A1)
9D0146E4  ACA26324   SW V0, 25380(A1)
9D014708  ACA26324   SW V0, 25380(A1)
9D01472C  ACA26324   SW V0, 25380(A1)
9D014750  ACA26324   SW V0, 25380(A1)
9D014774  ACA26324   SW V0, 25380(A1)
9D014798  ACA26324   SW V0, 25380(A1)
9D0147BC  ACA26324   SW V0, 25380(A1)
9D0147E0  ACA26324   SW V0, 25380(A1)
9D014878  ACA26324   SW V0, 25380(A1)
9D0148A4  ACA26324   SW V0, 25380(A1)
9D0148D8  ACA26324   SW V0, 25380(A1)
9D014904  ACA26324   SW V0, 25380(A1)
9D014938  ACA26324   SW V0, 25380(A1)
9D014964  ACA26324   SW V0, 25380(A1)
9D014998  ACA26324   SW V0, 25380(A1)
9D0149C4  ACA26324   SW V0, 25380(A1)
9D0149F8  ACA26324   SW V0, 25380(A1)
9D014A24  ACA26324   SW V0, 25380(A1)
9D014A58  ACA26324   SW V0, 25380(A1)
9D014A84  ACA26324   SW V0, 25380(A1)
9D014AB8  ACA26324   SW V0, 25380(A1)
9D014AE4  ACA26324   SW V0, 25380(A1)
9D014B14  ACA26324   SW V0, 25380(A1)
9D014B40  ACA26324   SW V0, 25380(A1)
9D014F28  AEC26324   SW V0, 25380(S6)
9D014F54  AEC26324   SW V0, 25380(S6)
9D014F88  AEC26324   SW V0, 25380(S6)
9D014FB4  AEC26324   SW V0, 25380(S6)
9D014FE8  AEC26324   SW V0, 25380(S6)
9D015014  AEC26324   SW V0, 25380(S6)
9D015048  AEC26324   SW V0, 25380(S6)
9D015074  AEC26324   SW V0, 25380(S6)
9D0150A8  AEC26324   SW V0, 25380(S6)
9D0150D4  AEC26324   SW V0, 25380(S6)
9D015108  AEC26324   SW V0, 25380(S6)
9D015134  AEC26324   SW V0, 25380(S6)
9D015168  AEC26324   SW V0, 25380(S6)
9D015194  AEC26324   SW V0, 25380(S6)
9D0151C4  AEC26324   SW V0, 25380(S6)
9D0151F0  AEC26324   SW V0, 25380(S6)
9D015330  AEC26324   SW V0, 25380(S6)
9D015354  AEC26324   SW V0, 25380(S6)
9D015378  AEC26324   SW V0, 25380(S6)
9D01539C  AEC26324   SW V0, 25380(S6)
9D0153C0  AEC26324   SW V0, 25380(S6)
9D0153E4  AEC26324   SW V0, 25380(S6)
9D015408  AEC26324   SW V0, 25380(S6)
9D01542C  AEC26324   SW V0, 25380(S6)
9D0154B0  AEC26324   SW V0, 25380(S6)
9D0154DC  AEC26324   SW V0, 25380(S6)
9D015510  AEC26324   SW V0, 25380(S6)
9D01553C  AEC26324   SW V0, 25380(S6)
9D015570  AEC26324   SW V0, 25380(S6)
9D01559C  AEC26324   SW V0, 25380(S6)
9D0155D0  AEC26324   SW V0, 25380(S6)
9D0155FC  AEC26324   SW V0, 25380(S6)
9D015630  AEC26324   SW V0, 25380(S6)
9D01565C  AEC26324   SW V0, 25380(S6)
9D015690  AEC26324   SW V0, 25380(S6)
9D0156BC  AEC26324   SW V0, 25380(S6)
9D0156F0  AEC26324   SW V0, 25380(S6)
9D01571C  AEC26324   SW V0, 25380(S6)
9D01574C  AEC26324   SW V0, 25380(S6)
9D015778  AEC26324   SW V0, 25380(S6)
9D015A94  AEC26324   SW V0, 25380(S6)
9D015AC0  AEC26324   SW V0, 25380(S6)
9D015AF4  AEC26324   SW V0, 25380(S6)
9D015B20  AEC26324   SW V0, 25380(S6)
9D015B54  AEC26324   SW V0, 25380(S6)
9D015B80  AEC26324   SW V0, 25380(S6)
9D015BB4  AEC26324   SW V0, 25380(S6)
9D015BE0  AEC26324   SW V0, 25380(S6)
9D015C14  AEC26324   SW V0, 25380(S6)
9D015C40  AEC26324   SW V0, 25380(S6)
9D015C74  AEC26324   SW V0, 25380(S6)
9D015CA0  AEC26324   SW V0, 25380(S6)
9D015CD4  AEC26324   SW V0, 25380(S6)
9D015D00  AEC26324   SW V0, 25380(S6)
9D015D30  AEC26324   SW V0, 25380(S6)
9D015D5C  AEC26324   SW V0, 25380(S6)
9D015E9C  AEC26324   SW V0, 25380(S6)
9D015EC0  AEC26324   SW V0, 25380(S6)
9D015EE4  AEC26324   SW V0, 25380(S6)
9D015F08  AEC26324   SW V0, 25380(S6)
9D015F2C  AEC26324   SW V0, 25380(S6)
9D015F50  AEC26324   SW V0, 25380(S6)
9D015F74  AEC26324   SW V0, 25380(S6)
9D015F98  AEC26324   SW V0, 25380(S6)
9D01601C  AEC26324   SW V0, 25380(S6)
9D016048  AEC26324   SW V0, 25380(S6)
9D01607C  AEC26324   SW V0, 25380(S6)
9D0160A8  AEC26324   SW V0, 25380(S6)
9D0160DC  AEC26324   SW V0, 25380(S6)
9D016108  AEC26324   SW V0, 25380(S6)
9D01613C  AEC26324   SW V0, 25380(S6)
9D016168  AEC26324   SW V0, 25380(S6)
9D01619C  AEC26324   SW V0, 25380(S6)
9D0161C8  AEC26324   SW V0, 25380(S6)
9D0161FC  AEC26324   SW V0, 25380(S6)
9D016228  AEC26324   SW V0, 25380(S6)
9D01625C  AEC26324   SW V0, 25380(S6)
9D016288  AEC26324   SW V0, 25380(S6)
9D0162B8  AEC26324   SW V0, 25380(S6)
9D0162E4  AEC26324   SW V0, 25380(S6)
9D016420  AD026324   SW V0, 25380(T0)
480:                 	LCD_PORT = data2;
9D014540  7E293A00   EXT T1, S1, 8, 8
9D01456C  AC896430   SW T1, 25648(A0)
9D0146E8  AC916430   SW S1, 25648(A0)
9D01470C  AC916430   SW S1, 25648(A0)
9D014730  AC916430   SW S1, 25648(A0)
9D014754  AC916430   SW S1, 25648(A0)
9D014778  AC916430   SW S1, 25648(A0)
9D01479C  AC916430   SW S1, 25648(A0)
9D0147C0  AC916430   SW S1, 25648(A0)
9D0147E4  AC916430   SW S1, 25648(A0)
9D01487C  AC896430   SW T1, 25648(A0)
9D0148A8  AC916430   SW S1, 25648(A0)
9D0148DC  AC896430   SW T1, 25648(A0)
9D014908  AC916430   SW S1, 25648(A0)
9D01493C  AC896430   SW T1, 25648(A0)
9D014968  AC916430   SW S1, 25648(A0)
9D01499C  AC896430   SW T1, 25648(A0)
9D0149C8  AC916430   SW S1, 25648(A0)
9D0149FC  AC896430   SW T1, 25648(A0)
9D014A28  AC916430   SW S1, 25648(A0)
9D014A5C  AC896430   SW T1, 25648(A0)
9D014A88  AC916430   SW S1, 25648(A0)
9D014ABC  AC896430   SW T1, 25648(A0)
9D014AE8  AC916430   SW S1, 25648(A0)
9D014B18  AC896430   SW T1, 25648(A0)
9D014B44  AC916430   SW S1, 25648(A0)
9D014F2C  AFD26430   SW S2, 25648(FP)
9D014F58  AFD46430   SW S4, 25648(FP)
9D014F8C  AFD26430   SW S2, 25648(FP)
9D014FB8  AFD46430   SW S4, 25648(FP)
9D014FEC  AFD26430   SW S2, 25648(FP)
9D015018  AFD46430   SW S4, 25648(FP)
9D01504C  AFD26430   SW S2, 25648(FP)
9D015078  AFD46430   SW S4, 25648(FP)
9D0150AC  AFD26430   SW S2, 25648(FP)
9D0150D8  AFD46430   SW S4, 25648(FP)
9D01510C  AFD26430   SW S2, 25648(FP)
9D015138  AFD46430   SW S4, 25648(FP)
9D01516C  AFD26430   SW S2, 25648(FP)
9D015198  AFD46430   SW S4, 25648(FP)
9D0151C8  AFD26430   SW S2, 25648(FP)
9D0151F4  AFD46430   SW S4, 25648(FP)
9D015334  AFD06430   SW S0, 25648(FP)
9D015358  AFD06430   SW S0, 25648(FP)
9D01537C  AFD06430   SW S0, 25648(FP)
9D0153A0  AFD06430   SW S0, 25648(FP)
9D0153C4  AFD06430   SW S0, 25648(FP)
9D0153E8  AFD06430   SW S0, 25648(FP)
9D01540C  AFD06430   SW S0, 25648(FP)
9D015430  AFD06430   SW S0, 25648(FP)
9D0154B4  AFC56430   SW A1, 25648(FP)
9D0154E0  AFD06430   SW S0, 25648(FP)
9D015514  AFC56430   SW A1, 25648(FP)
9D015540  AFD06430   SW S0, 25648(FP)
9D015574  AFC56430   SW A1, 25648(FP)
9D0155A0  AFD06430   SW S0, 25648(FP)
9D0155D4  AFC56430   SW A1, 25648(FP)
9D015600  AFD06430   SW S0, 25648(FP)
9D015634  AFC56430   SW A1, 25648(FP)
9D015660  AFD06430   SW S0, 25648(FP)
9D015694  AFC56430   SW A1, 25648(FP)
9D0156C0  AFD06430   SW S0, 25648(FP)
9D0156F4  AFC56430   SW A1, 25648(FP)
9D015720  AFD06430   SW S0, 25648(FP)
9D015750  AFC56430   SW A1, 25648(FP)
9D01577C  AFD06430   SW S0, 25648(FP)
9D015A98  AEF26430   SW S2, 25648(S7)
9D015AC4  AEF46430   SW S4, 25648(S7)
9D015AF8  AEF26430   SW S2, 25648(S7)
9D015B24  AEF46430   SW S4, 25648(S7)
9D015B58  AEF26430   SW S2, 25648(S7)
9D015B84  AEF46430   SW S4, 25648(S7)
9D015BB8  AEF26430   SW S2, 25648(S7)
9D015BE4  AEF46430   SW S4, 25648(S7)
9D015C18  AEF26430   SW S2, 25648(S7)
9D015C44  AEF46430   SW S4, 25648(S7)
9D015C78  AEF26430   SW S2, 25648(S7)
9D015CA4  AEF46430   SW S4, 25648(S7)
9D015CD8  AEF26430   SW S2, 25648(S7)
9D015D04  AEF46430   SW S4, 25648(S7)
9D015D34  AEF26430   SW S2, 25648(S7)
9D015D60  AEF46430   SW S4, 25648(S7)
9D015EA0  AEF06430   SW S0, 25648(S7)
9D015EC4  AEF06430   SW S0, 25648(S7)
9D015EE8  AEF06430   SW S0, 25648(S7)
9D015F0C  AEF06430   SW S0, 25648(S7)
9D015F30  AEF06430   SW S0, 25648(S7)
9D015F54  AEF06430   SW S0, 25648(S7)
9D015F78  AEF06430   SW S0, 25648(S7)
9D015F9C  AEF06430   SW S0, 25648(S7)
9D016020  AEE56430   SW A1, 25648(S7)
9D01604C  AEF06430   SW S0, 25648(S7)
9D016080  AEE56430   SW A1, 25648(S7)
9D0160AC  AEF06430   SW S0, 25648(S7)
9D0160E0  AEE56430   SW A1, 25648(S7)
9D01610C  AEF06430   SW S0, 25648(S7)
9D016140  AEE56430   SW A1, 25648(S7)
9D01616C  AEF06430   SW S0, 25648(S7)
9D0161A0  AEE56430   SW A1, 25648(S7)
9D0161CC  AEF06430   SW S0, 25648(S7)
9D016200  AEE56430   SW A1, 25648(S7)
9D01622C  AEF06430   SW S0, 25648(S7)
9D016260  AEE56430   SW A1, 25648(S7)
9D01628C  AEF06430   SW S0, 25648(S7)
9D0162BC  AEE56430   SW A1, 25648(S7)
9D0162E8  AEF06430   SW S0, 25648(S7)
9D016424  ACE56430   SW A1, 25648(A3)
481:                 	LCD_WR_SET;
9D014570  AC626328   SW V0, 25384(V1)
9D0146EC  AC626328   SW V0, 25384(V1)
9D014710  AC626328   SW V0, 25384(V1)
9D014734  AC626328   SW V0, 25384(V1)
9D014758  AC626328   SW V0, 25384(V1)
9D01477C  AC626328   SW V0, 25384(V1)
9D0147A0  AC626328   SW V0, 25384(V1)
9D0147C4  AC626328   SW V0, 25384(V1)
9D0147E8  AC626328   SW V0, 25384(V1)
9D014880  AC626328   SW V0, 25384(V1)
9D0148AC  AC626328   SW V0, 25384(V1)
9D0148E0  AC626328   SW V0, 25384(V1)
9D01490C  AC626328   SW V0, 25384(V1)
9D014940  AC626328   SW V0, 25384(V1)
9D01496C  AC626328   SW V0, 25384(V1)
9D0149A0  AC626328   SW V0, 25384(V1)
9D0149CC  AC626328   SW V0, 25384(V1)
9D014A00  AC626328   SW V0, 25384(V1)
9D014A2C  AC626328   SW V0, 25384(V1)
9D014A60  AC626328   SW V0, 25384(V1)
9D014A8C  AC626328   SW V0, 25384(V1)
9D014AC0  AC626328   SW V0, 25384(V1)
9D014AEC  AC626328   SW V0, 25384(V1)
9D014B1C  AC626328   SW V0, 25384(V1)
9D014B48  AC626328   SW V0, 25384(V1)
9D014F30  AEE26328   SW V0, 25384(S7)
9D014F5C  AEE26328   SW V0, 25384(S7)
9D014F90  AEE26328   SW V0, 25384(S7)
9D014FBC  AEE26328   SW V0, 25384(S7)
9D014FF0  AEE26328   SW V0, 25384(S7)
9D01501C  AEE26328   SW V0, 25384(S7)
9D015050  AEE26328   SW V0, 25384(S7)
9D01507C  AEE26328   SW V0, 25384(S7)
9D0150B0  AEE26328   SW V0, 25384(S7)
9D0150DC  AEE26328   SW V0, 25384(S7)
9D015110  AEE26328   SW V0, 25384(S7)
9D01513C  AEE26328   SW V0, 25384(S7)
9D015170  AEE26328   SW V0, 25384(S7)
9D01519C  AEE26328   SW V0, 25384(S7)
9D0151CC  AEE26328   SW V0, 25384(S7)
9D0151F8  AEE26328   SW V0, 25384(S7)
9D015338  AEE26328   SW V0, 25384(S7)
9D01535C  AEE26328   SW V0, 25384(S7)
9D015380  AEE26328   SW V0, 25384(S7)
9D0153A4  AEE26328   SW V0, 25384(S7)
9D0153C8  AEE26328   SW V0, 25384(S7)
9D0153EC  AEE26328   SW V0, 25384(S7)
9D015410  AEE26328   SW V0, 25384(S7)
9D015434  AEE26328   SW V0, 25384(S7)
9D0154B8  AEE26328   SW V0, 25384(S7)
9D0154E4  AEE26328   SW V0, 25384(S7)
9D015518  AEE26328   SW V0, 25384(S7)
9D015544  AEE26328   SW V0, 25384(S7)
9D015578  AEE26328   SW V0, 25384(S7)
9D0155A4  AEE26328   SW V0, 25384(S7)
9D0155D8  AEE26328   SW V0, 25384(S7)
9D015604  AEE26328   SW V0, 25384(S7)
9D015638  AEE26328   SW V0, 25384(S7)
9D015664  AEE26328   SW V0, 25384(S7)
9D015698  AEE26328   SW V0, 25384(S7)
9D0156C4  AEE26328   SW V0, 25384(S7)
9D0156F8  AEE26328   SW V0, 25384(S7)
9D015724  AEE26328   SW V0, 25384(S7)
9D015754  AEE26328   SW V0, 25384(S7)
9D015780  AEE26328   SW V0, 25384(S7)
9D015A9C  AFC26328   SW V0, 25384(FP)
9D015AC8  AFC26328   SW V0, 25384(FP)
9D015AFC  AFC26328   SW V0, 25384(FP)
9D015B28  AFC26328   SW V0, 25384(FP)
9D015B5C  AFC26328   SW V0, 25384(FP)
9D015B88  AFC26328   SW V0, 25384(FP)
9D015BBC  AFC26328   SW V0, 25384(FP)
9D015BE8  AFC26328   SW V0, 25384(FP)
9D015C1C  AFC26328   SW V0, 25384(FP)
9D015C48  AFC26328   SW V0, 25384(FP)
9D015C7C  AFC26328   SW V0, 25384(FP)
9D015CA8  AFC26328   SW V0, 25384(FP)
9D015CDC  AFC26328   SW V0, 25384(FP)
9D015D08  AFC26328   SW V0, 25384(FP)
9D015D38  AFC26328   SW V0, 25384(FP)
9D015D64  AFC26328   SW V0, 25384(FP)
9D015EA4  AFC26328   SW V0, 25384(FP)
9D015EC8  AFC26328   SW V0, 25384(FP)
9D015EEC  AFC26328   SW V0, 25384(FP)
9D015F10  AFC26328   SW V0, 25384(FP)
9D015F34  AFC26328   SW V0, 25384(FP)
9D015F58  AFC26328   SW V0, 25384(FP)
9D015F7C  AFC26328   SW V0, 25384(FP)
9D015FA0  AFC26328   SW V0, 25384(FP)
9D016024  AFC26328   SW V0, 25384(FP)
9D016050  AFC26328   SW V0, 25384(FP)
9D016084  AFC26328   SW V0, 25384(FP)
9D0160B0  AFC26328   SW V0, 25384(FP)
9D0160E4  AFC26328   SW V0, 25384(FP)
9D016110  AFC26328   SW V0, 25384(FP)
9D016144  AFC26328   SW V0, 25384(FP)
9D016170  AFC26328   SW V0, 25384(FP)
9D0161A4  AFC26328   SW V0, 25384(FP)
9D0161D0  AFC26328   SW V0, 25384(FP)
9D016204  AFC26328   SW V0, 25384(FP)
9D016230  AFC26328   SW V0, 25384(FP)
9D016264  AFC26328   SW V0, 25384(FP)
9D016290  AFC26328   SW V0, 25384(FP)
9D0162C0  AFC26328   SW V0, 25384(FP)
9D0162EC  AFC26328   SW V0, 25384(FP)
9D016428  AC626328   SW V0, 25384(V1)
482:                 	LCD_WR_CLR;
9D014574  ACA26324   SW V0, 25380(A1)
9D0146F0  ACA26324   SW V0, 25380(A1)
9D014714  ACA26324   SW V0, 25380(A1)
9D014738  ACA26324   SW V0, 25380(A1)
9D01475C  ACA26324   SW V0, 25380(A1)
9D014780  ACA26324   SW V0, 25380(A1)
9D0147A4  ACA26324   SW V0, 25380(A1)
9D0147C8  ACA26324   SW V0, 25380(A1)
9D0147EC  ACA26324   SW V0, 25380(A1)
9D014884  ACA26324   SW V0, 25380(A1)
9D0148B0  ACA26324   SW V0, 25380(A1)
9D0148E4  ACA26324   SW V0, 25380(A1)
9D014910  ACA26324   SW V0, 25380(A1)
9D014944  ACA26324   SW V0, 25380(A1)
9D014970  ACA26324   SW V0, 25380(A1)
9D0149A4  ACA26324   SW V0, 25380(A1)
9D0149D0  ACA26324   SW V0, 25380(A1)
9D014A04  ACA26324   SW V0, 25380(A1)
9D014A30  ACA26324   SW V0, 25380(A1)
9D014A64  ACA26324   SW V0, 25380(A1)
9D014A90  ACA26324   SW V0, 25380(A1)
9D014AC4  ACA26324   SW V0, 25380(A1)
9D014AF0  ACA26324   SW V0, 25380(A1)
9D014B20  ACA26324   SW V0, 25380(A1)
9D014B4C  ACA26324   SW V0, 25380(A1)
9D014F34  AEC26324   SW V0, 25380(S6)
9D014F60  AEC26324   SW V0, 25380(S6)
9D014F94  AEC26324   SW V0, 25380(S6)
9D014FC0  AEC26324   SW V0, 25380(S6)
9D014FF4  AEC26324   SW V0, 25380(S6)
9D015020  AEC26324   SW V0, 25380(S6)
9D015054  AEC26324   SW V0, 25380(S6)
9D015080  AEC26324   SW V0, 25380(S6)
9D0150B4  AEC26324   SW V0, 25380(S6)
9D0150E0  AEC26324   SW V0, 25380(S6)
9D015114  AEC26324   SW V0, 25380(S6)
9D015140  AEC26324   SW V0, 25380(S6)
9D015174  AEC26324   SW V0, 25380(S6)
9D0151A0  AEC26324   SW V0, 25380(S6)
9D0151D0  AEC26324   SW V0, 25380(S6)
9D0151FC  AEC26324   SW V0, 25380(S6)
9D01533C  AEC26324   SW V0, 25380(S6)
9D015360  AEC26324   SW V0, 25380(S6)
9D015384  AEC26324   SW V0, 25380(S6)
9D0153A8  AEC26324   SW V0, 25380(S6)
9D0153CC  AEC26324   SW V0, 25380(S6)
9D0153F0  AEC26324   SW V0, 25380(S6)
9D015414  AEC26324   SW V0, 25380(S6)
9D015438  AEC26324   SW V0, 25380(S6)
9D0154BC  AEC26324   SW V0, 25380(S6)
9D0154E8  AEC26324   SW V0, 25380(S6)
9D01551C  AEC26324   SW V0, 25380(S6)
9D015548  AEC26324   SW V0, 25380(S6)
9D01557C  AEC26324   SW V0, 25380(S6)
9D0155A8  AEC26324   SW V0, 25380(S6)
9D0155DC  AEC26324   SW V0, 25380(S6)
9D015608  AEC26324   SW V0, 25380(S6)
9D01563C  AEC26324   SW V0, 25380(S6)
9D015668  AEC26324   SW V0, 25380(S6)
9D01569C  AEC26324   SW V0, 25380(S6)
9D0156C8  AEC26324   SW V0, 25380(S6)
9D0156FC  AEC26324   SW V0, 25380(S6)
9D015728  AEC26324   SW V0, 25380(S6)
9D015758  AEC26324   SW V0, 25380(S6)
9D015784  AEC26324   SW V0, 25380(S6)
9D015AA0  AEC26324   SW V0, 25380(S6)
9D015ACC  AEC26324   SW V0, 25380(S6)
9D015B00  AEC26324   SW V0, 25380(S6)
9D015B2C  AEC26324   SW V0, 25380(S6)
9D015B60  AEC26324   SW V0, 25380(S6)
9D015B8C  AEC26324   SW V0, 25380(S6)
9D015BC0  AEC26324   SW V0, 25380(S6)
9D015BEC  AEC26324   SW V0, 25380(S6)
9D015C20  AEC26324   SW V0, 25380(S6)
9D015C4C  AEC26324   SW V0, 25380(S6)
9D015C80  AEC26324   SW V0, 25380(S6)
9D015CAC  AEC26324   SW V0, 25380(S6)
9D015CE0  AEC26324   SW V0, 25380(S6)
9D015D0C  AEC26324   SW V0, 25380(S6)
9D015D3C  AEC26324   SW V0, 25380(S6)
9D015D68  AEC26324   SW V0, 25380(S6)
9D015EA8  AEC26324   SW V0, 25380(S6)
9D015ECC  AEC26324   SW V0, 25380(S6)
9D015EF0  AEC26324   SW V0, 25380(S6)
9D015F14  AEC26324   SW V0, 25380(S6)
9D015F38  AEC26324   SW V0, 25380(S6)
9D015F5C  AEC26324   SW V0, 25380(S6)
9D015F80  AEC26324   SW V0, 25380(S6)
9D015FA4  AEC26324   SW V0, 25380(S6)
9D016028  AEC26324   SW V0, 25380(S6)
9D016054  AEC26324   SW V0, 25380(S6)
9D016088  AEC26324   SW V0, 25380(S6)
9D0160B4  AEC26324   SW V0, 25380(S6)
9D0160E8  AEC26324   SW V0, 25380(S6)
9D016114  AEC26324   SW V0, 25380(S6)
9D016148  AEC26324   SW V0, 25380(S6)
9D016174  AEC26324   SW V0, 25380(S6)
9D0161A8  AEC26324   SW V0, 25380(S6)
9D0161D4  AEC26324   SW V0, 25380(S6)
9D016208  AEC26324   SW V0, 25380(S6)
9D016234  AEC26324   SW V0, 25380(S6)
9D016268  AEC26324   SW V0, 25380(S6)
9D016294  AEC26324   SW V0, 25380(S6)
9D0162C4  AEC26324   SW V0, 25380(S6)
9D0162F0  AEC26324   SW V0, 25380(S6)
9D01642C  AD026324   SW V0, 25380(T0)
483:                 	LCD_PORT = data3;
9D014558  322800FF   ANDI T0, S1, 255
9D014578  AC886430   SW T0, 25648(A0)
9D0146F4  AC926430   SW S2, 25648(A0)
9D014718  AC926430   SW S2, 25648(A0)
9D01473C  AC926430   SW S2, 25648(A0)
9D014760  AC926430   SW S2, 25648(A0)
9D014784  AC926430   SW S2, 25648(A0)
9D0147A8  AC926430   SW S2, 25648(A0)
9D0147CC  AC926430   SW S2, 25648(A0)
9D0147F0  AC926430   SW S2, 25648(A0)
9D014888  AC886430   SW T0, 25648(A0)
9D0148B4  AC926430   SW S2, 25648(A0)
9D0148E8  AC886430   SW T0, 25648(A0)
9D014914  AC926430   SW S2, 25648(A0)
9D014948  AC886430   SW T0, 25648(A0)
9D014974  AC926430   SW S2, 25648(A0)
9D0149A8  AC886430   SW T0, 25648(A0)
9D0149D4  AC926430   SW S2, 25648(A0)
9D014A08  AC886430   SW T0, 25648(A0)
9D014A34  AC926430   SW S2, 25648(A0)
9D014A68  AC886430   SW T0, 25648(A0)
9D014A94  AC926430   SW S2, 25648(A0)
9D014AC8  AC886430   SW T0, 25648(A0)
9D014AF4  AC926430   SW S2, 25648(A0)
9D014B24  AC886430   SW T0, 25648(A0)
9D014B50  AC926430   SW S2, 25648(A0)
9D014F38  AFD16430   SW S1, 25648(FP)
9D014F64  AFD56430   SW S5, 25648(FP)
9D014F98  AFD16430   SW S1, 25648(FP)
9D014FC4  AFD56430   SW S5, 25648(FP)
9D014FF8  AFD16430   SW S1, 25648(FP)
9D015024  AFD56430   SW S5, 25648(FP)
9D015058  AFD16430   SW S1, 25648(FP)
9D015084  AFD56430   SW S5, 25648(FP)
9D0150B8  AFD16430   SW S1, 25648(FP)
9D0150E4  AFD56430   SW S5, 25648(FP)
9D015118  AFD16430   SW S1, 25648(FP)
9D015144  AFD56430   SW S5, 25648(FP)
9D015178  AFD16430   SW S1, 25648(FP)
9D0151A4  AFD56430   SW S5, 25648(FP)
9D0151D4  AFD16430   SW S1, 25648(FP)
9D015200  AFD56430   SW S5, 25648(FP)
9D015340  AFD16430   SW S1, 25648(FP)
9D015364  AFD16430   SW S1, 25648(FP)
9D015388  AFD16430   SW S1, 25648(FP)
9D0153AC  AFD16430   SW S1, 25648(FP)
9D0153D0  AFD16430   SW S1, 25648(FP)
9D0153F4  AFD16430   SW S1, 25648(FP)
9D015418  AFD16430   SW S1, 25648(FP)
9D01543C  AFD16430   SW S1, 25648(FP)
9D0154C0  AFD56430   SW S5, 25648(FP)
9D0154EC  AFD16430   SW S1, 25648(FP)
9D015520  AFD56430   SW S5, 25648(FP)
9D01554C  AFD16430   SW S1, 25648(FP)
9D015580  AFD56430   SW S5, 25648(FP)
9D0155AC  AFD16430   SW S1, 25648(FP)
9D0155E0  AFD56430   SW S5, 25648(FP)
9D01560C  AFD16430   SW S1, 25648(FP)
9D015640  AFD56430   SW S5, 25648(FP)
9D01566C  AFD16430   SW S1, 25648(FP)
9D0156A0  AFD56430   SW S5, 25648(FP)
9D0156CC  AFD16430   SW S1, 25648(FP)
9D015700  AFD56430   SW S5, 25648(FP)
9D01572C  AFD16430   SW S1, 25648(FP)
9D01575C  AFD56430   SW S5, 25648(FP)
9D015788  AFD16430   SW S1, 25648(FP)
9D015AA4  AEF16430   SW S1, 25648(S7)
9D015AD0  AEF56430   SW S5, 25648(S7)
9D015B04  AEF16430   SW S1, 25648(S7)
9D015B30  AEF56430   SW S5, 25648(S7)
9D015B64  AEF16430   SW S1, 25648(S7)
9D015B90  AEF56430   SW S5, 25648(S7)
9D015BC4  AEF16430   SW S1, 25648(S7)
9D015BF0  AEF56430   SW S5, 25648(S7)
9D015C24  AEF16430   SW S1, 25648(S7)
9D015C50  AEF56430   SW S5, 25648(S7)
9D015C84  AEF16430   SW S1, 25648(S7)
9D015CB0  AEF56430   SW S5, 25648(S7)
9D015CE4  AEF16430   SW S1, 25648(S7)
9D015D10  AEF56430   SW S5, 25648(S7)
9D015D40  AEF16430   SW S1, 25648(S7)
9D015D6C  AEF56430   SW S5, 25648(S7)
9D015EAC  AEF16430   SW S1, 25648(S7)
9D015ED0  AEF16430   SW S1, 25648(S7)
9D015EF4  AEF16430   SW S1, 25648(S7)
9D015F18  AEF16430   SW S1, 25648(S7)
9D015F3C  AEF16430   SW S1, 25648(S7)
9D015F60  AEF16430   SW S1, 25648(S7)
9D015F84  AEF16430   SW S1, 25648(S7)
9D015FA8  AEF16430   SW S1, 25648(S7)
9D01602C  AEF56430   SW S5, 25648(S7)
9D016058  AEF16430   SW S1, 25648(S7)
9D01608C  AEF56430   SW S5, 25648(S7)
9D0160B8  AEF16430   SW S1, 25648(S7)
9D0160EC  AEF56430   SW S5, 25648(S7)
9D016118  AEF16430   SW S1, 25648(S7)
9D01614C  AEF56430   SW S5, 25648(S7)
9D016178  AEF16430   SW S1, 25648(S7)
9D0161AC  AEF56430   SW S5, 25648(S7)
9D0161D8  AEF16430   SW S1, 25648(S7)
9D01620C  AEF56430   SW S5, 25648(S7)
9D016238  AEF16430   SW S1, 25648(S7)
9D01626C  AEF56430   SW S5, 25648(S7)
9D016298  AEF16430   SW S1, 25648(S7)
9D0162C8  AEF56430   SW S5, 25648(S7)
9D0162F4  AEF16430   SW S1, 25648(S7)
9D016430  ACE66430   SW A2, 25648(A3)
484:                 	LCD_WR_SET;
9D01457C  AC626328   SW V0, 25384(V1)
9D0146F8  AC626328   SW V0, 25384(V1)
9D01471C  AC626328   SW V0, 25384(V1)
9D014740  AC626328   SW V0, 25384(V1)
9D014764  AC626328   SW V0, 25384(V1)
9D014788  AC626328   SW V0, 25384(V1)
9D0147AC  AC626328   SW V0, 25384(V1)
9D0147D0  AC626328   SW V0, 25384(V1)
9D0147F4  AC626328   SW V0, 25384(V1)
9D0147F8  24C6FFFF   ADDIU A2, A2, -1
9D0147FC  30C6FFFF   ANDI A2, A2, -1
9D01488C  AC626328   SW V0, 25384(V1)
9D0148B8  AC626328   SW V0, 25384(V1)
9D0148EC  AC626328   SW V0, 25384(V1)
9D014918  AC626328   SW V0, 25384(V1)
9D01494C  AC626328   SW V0, 25384(V1)
9D014978  AC626328   SW V0, 25384(V1)
9D0149AC  AC626328   SW V0, 25384(V1)
9D0149D8  AC626328   SW V0, 25384(V1)
9D014A0C  AC626328   SW V0, 25384(V1)
9D014A38  AC626328   SW V0, 25384(V1)
9D014A6C  AC626328   SW V0, 25384(V1)
9D014A98  AC626328   SW V0, 25384(V1)
9D014ACC  AC626328   SW V0, 25384(V1)
9D014AF8  AC626328   SW V0, 25384(V1)
9D014B28  AC626328   SW V0, 25384(V1)
9D014B2C  0B4052D7   J .LBE442
9D014B30  24E70001   ADDIU A3, A3, 1
9D014B54  AC626328   SW V0, 25384(V1)
9D014B58  24E70001   ADDIU A3, A3, 1
9D014F3C  AEE26328   SW V0, 25384(S7)
9D014F68  AEE26328   SW V0, 25384(S7)
9D014F9C  AEE26328   SW V0, 25384(S7)
9D014FC8  AEE26328   SW V0, 25384(S7)
9D014FFC  AEE26328   SW V0, 25384(S7)
9D015028  AEE26328   SW V0, 25384(S7)
9D01505C  AEE26328   SW V0, 25384(S7)
9D015088  AEE26328   SW V0, 25384(S7)
9D0150BC  AEE26328   SW V0, 25384(S7)
9D0150E8  AEE26328   SW V0, 25384(S7)
9D01511C  AEE26328   SW V0, 25384(S7)
9D015148  AEE26328   SW V0, 25384(S7)
9D01517C  AEE26328   SW V0, 25384(S7)
9D0151A8  AEE26328   SW V0, 25384(S7)
9D0151D8  AEE26328   SW V0, 25384(S7)
9D0151DC  0B405483   J .LBE768
9D0151E0  24840001   ADDIU A0, A0, 1
9D015204  AEE26328   SW V0, 25384(S7)
9D015208  24840001   ADDIU A0, A0, 1
9D015344  AEE26328   SW V0, 25384(S7)
9D015368  AEE26328   SW V0, 25384(S7)
9D01538C  AEE26328   SW V0, 25384(S7)
9D0153B0  AEE26328   SW V0, 25384(S7)
9D0153D4  AEE26328   SW V0, 25384(S7)
9D0153F8  AEE26328   SW V0, 25384(S7)
9D01541C  AEE26328   SW V0, 25384(S7)
9D015440  AEE26328   SW V0, 25384(S7)
9D015444  2463FFFF   ADDIU V1, V1, -1
9D015448  3063FFFF   ANDI V1, V1, -1
9D0154C4  AEE26328   SW V0, 25384(S7)
9D0154F0  AEE26328   SW V0, 25384(S7)
9D015524  AEE26328   SW V0, 25384(S7)
9D015550  AEE26328   SW V0, 25384(S7)
9D015584  AEE26328   SW V0, 25384(S7)
9D0155B0  AEE26328   SW V0, 25384(S7)
9D0155E4  AEE26328   SW V0, 25384(S7)
9D015610  AEE26328   SW V0, 25384(S7)
9D015644  AEE26328   SW V0, 25384(S7)
9D015670  AEE26328   SW V0, 25384(S7)
9D0156A4  AEE26328   SW V0, 25384(S7)
9D0156D0  AEE26328   SW V0, 25384(S7)
9D015704  AEE26328   SW V0, 25384(S7)
9D015730  AEE26328   SW V0, 25384(S7)
9D015760  AEE26328   SW V0, 25384(S7)
9D015764  0B4055E5   J .LBE694
9D015768  24840001   ADDIU A0, A0, 1
9D01578C  AEE26328   SW V0, 25384(S7)
9D015790  24840001   ADDIU A0, A0, 1
9D015AA8  AFC26328   SW V0, 25384(FP)
9D015AD4  AFC26328   SW V0, 25384(FP)
9D015B08  AFC26328   SW V0, 25384(FP)
9D015B34  AFC26328   SW V0, 25384(FP)
9D015B68  AFC26328   SW V0, 25384(FP)
9D015B94  AFC26328   SW V0, 25384(FP)
9D015BC8  AFC26328   SW V0, 25384(FP)
9D015BF4  AFC26328   SW V0, 25384(FP)
9D015C28  AFC26328   SW V0, 25384(FP)
9D015C54  AFC26328   SW V0, 25384(FP)
9D015C88  AFC26328   SW V0, 25384(FP)
9D015CB4  AFC26328   SW V0, 25384(FP)
9D015CE8  AFC26328   SW V0, 25384(FP)
9D015D14  AFC26328   SW V0, 25384(FP)
9D015D44  AFC26328   SW V0, 25384(FP)
9D015D48  0B40575E   J .LBE1077
9D015D4C  24840001   ADDIU A0, A0, 1
9D015D70  AFC26328   SW V0, 25384(FP)
9D015D74  24840001   ADDIU A0, A0, 1
9D015EB0  AFC26328   SW V0, 25384(FP)
9D015ED4  AFC26328   SW V0, 25384(FP)
9D015EF8  AFC26328   SW V0, 25384(FP)
9D015F1C  AFC26328   SW V0, 25384(FP)
9D015F40  AFC26328   SW V0, 25384(FP)
9D015F64  AFC26328   SW V0, 25384(FP)
9D015F88  AFC26328   SW V0, 25384(FP)
9D015FAC  AFC26328   SW V0, 25384(FP)
9D015FB0  2463FFFF   ADDIU V1, V1, -1
9D015FB4  3063FFFF   ANDI V1, V1, -1
9D016030  AFC26328   SW V0, 25384(FP)
9D01605C  AFC26328   SW V0, 25384(FP)
9D016090  AFC26328   SW V0, 25384(FP)
9D0160BC  AFC26328   SW V0, 25384(FP)
9D0160F0  AFC26328   SW V0, 25384(FP)
9D01611C  AFC26328   SW V0, 25384(FP)
9D016150  AFC26328   SW V0, 25384(FP)
9D01617C  AFC26328   SW V0, 25384(FP)
9D0161B0  AFC26328   SW V0, 25384(FP)
9D0161DC  AFC26328   SW V0, 25384(FP)
9D016210  AFC26328   SW V0, 25384(FP)
9D01623C  AFC26328   SW V0, 25384(FP)
9D016270  AFC26328   SW V0, 25384(FP)
9D01629C  AFC26328   SW V0, 25384(FP)
9D0162CC  AFC26328   SW V0, 25384(FP)
9D0162D0  0B4058C0   J .LBE1006
9D0162D4  24840001   ADDIU A0, A0, 1
9D0162F8  AFC26328   SW V0, 25384(FP)
9D0162FC  24840001   ADDIU A0, A0, 1
9D016434  AC626328   SW V0, 25384(V1)
9D016438  03E00008   JR RA
9D01643C  00000000   NOP
485:                 	}
486:                 
487:                 inline void TFT_24_7789_Write_Data33(uint8_t data1,uint8_t data2, uint8_t data3)
488:                 	{
489:                 	LCD_WR_CLR;
9D014C88  02805021   ADDU T2, S4, ZERO
9D014C94  0B40533A   J 0x9D014CE8
9D014C98  24020010   ADDIU V0, ZERO, 16
9D014CA4  AD426324   SW V0, 25380(T2)
9D016440  3C08BF88   LUI T0, -16504
9D016444  24020010   ADDIU V0, ZERO, 16
9D016448  AD026324   SW V0, 25380(T0)
490:                 	LCD_PORT = data1;
9D014C8C  02604821   ADDU T1, S3, ZERO
9D014CA8  AD276430   SW A3, 25648(T1)
9D01644C  3C07BF88   LUI A3, -16504
9D016450  ACE46430   SW A0, 25648(A3)
491:                 	LCD_WR_SET;
9D014C90  02404021   ADDU T0, S2, ZERO
9D014CAC  AD026328   SW V0, 25384(T0)
9D016454  3C03BF88   LUI V1, -16504
9D016458  AC626328   SW V0, 25384(V1)
492:                 	LCD_WR_CLR;
9D014CB0  AD426324   SW V0, 25380(T2)
9D01645C  AD026324   SW V0, 25380(T0)
493:                 	LCD_PORT = data2;
9D014CB4  AD276430   SW A3, 25648(T1)
9D016460  ACE56430   SW A1, 25648(A3)
494:                 	LCD_WR_SET;
9D014CB8  AD026328   SW V0, 25384(T0)
9D016464  AC626328   SW V0, 25384(V1)
495:                 	LCD_WR_CLR;
9D014CBC  AD426324   SW V0, 25380(T2)
9D016468  AD026324   SW V0, 25380(T0)
496:                 	LCD_PORT = data3;
9D014CC0  AD276430   SW A3, 25648(T1)
9D01646C  ACE66430   SW A2, 25648(A3)
497:                 	LCD_WR_SET;
9D014CC4  AD026328   SW V0, 25384(T0)
9D016470  AC626328   SW V0, 25384(V1)
9D016474  03E00008   JR RA
9D016478  00000000   NOP
498:                 	}
499:                 
500:                 /*******************************************************************************/
501:                 void TFT_24_7789_Init(void)
502:                 	{
9D01647C  27BDFFC8   ADDIU SP, SP, -56
9D016480  AFBF0034   SW RA, 52(SP)
9D016484  AFBE0030   SW FP, 48(SP)
9D016488  AFB7002C   SW S7, 44(SP)
9D01648C  AFB60028   SW S6, 40(SP)
9D016490  AFB50024   SW S5, 36(SP)
9D016494  AFB40020   SW S4, 32(SP)
9D016498  AFB3001C   SW S3, 28(SP)
9D01649C  AFB20018   SW S2, 24(SP)
9D0164A0  AFB10014   SW S1, 20(SP)
9D0164A4  AFB00010   SW S0, 16(SP)
503:                 	LCD_RES = 0;
9D0164A8  3C02BF88   LUI V0, -16504
9D0164AC  94436630   LHU V1, 26160(V0)
9D0164B0  7C0339C4   INS V1, ZERO, 7, 1
9D0164B4  A4436630   SH V1, 26160(V0)
504:                 	LCD_RD = 1;
9D0164B8  3C03BF88   LUI V1, -16504
9D0164BC  94646330   LHU A0, 25392(V1)
9D0164C0  24140001   ADDIU S4, ZERO, 1
9D0164C4  7E842944   INS A0, S4, 5, 1
9D0164C8  A4646330   SH A0, 25392(V1)
505:                 	LCD_WR = 1;
9D0164CC  94646330   LHU A0, 25392(V1)
9D0164D0  7E842104   INS A0, S4, 4, 1
9D0164D4  A4646330   SH A0, 25392(V1)
506:                 	//wait_ms(2);
507:                 	LCD_RES = 1;
9D0164D8  94436630   LHU V1, 26160(V0)
9D0164DC  7E8339C4   INS V1, S4, 7, 1
9D0164E0  A4436630   SH V1, 26160(V0)
508:                 	wait_ms(2);
9D0164E4  0F407EB3   JAL wait_ms
9D0164E8  24040002   ADDIU A0, ZERO, 2
509:                 	TFT_24_7789_Write_Command(0x0029);//exit SLEEP mode
9D0164EC  0F4050B6   JAL TFT_24_7789_Write_Command
9D0164F0  24040029   ADDIU A0, ZERO, 41
510:                 	wait_ms(2);
9D0164F4  0F407EB3   JAL wait_ms
9D0164F8  24040002   ADDIU A0, ZERO, 2
511:                 	TFT_24_7789_Write_Command(0x0036);
9D0164FC  0F4050B6   JAL TFT_24_7789_Write_Command
9D016500  24040036   ADDIU A0, ZERO, 54
512:                 	TFT_24_7789_Write_Data(0x70);//MADCTL: memory data access control
513:                 	TFT_24_7789_Write_Command(0x003A);
9D016524  0F4050B6   JAL TFT_24_7789_Write_Command
9D016528  2404003A   ADDIU A0, ZERO, 58
514:                 	TFT_24_7789_Write_Data(0x0066);//COLMOD: Interface Pixel format
515:                 	TFT_24_7789_Write_Command(0x00B2);
9D01653C  0F4050B6   JAL TFT_24_7789_Write_Command
9D016540  240400B2   ADDIU A0, ZERO, 178
516:                 	TFT_24_7789_Write_Data(0x0C);
517:                 	TFT_24_7789_Write_Data(0x0C);
518:                 	TFT_24_7789_Write_Data(0x00);
519:                 	TFT_24_7789_Write_Data(0x33);
520:                 	TFT_24_7789_Write_Data(0x33);//PORCTRK: Porch setting
521:                 	TFT_24_7789_Write_Command(0x00B7);
9D016588  0F4050B6   JAL TFT_24_7789_Write_Command
9D01658C  240400B7   ADDIU A0, ZERO, 183
522:                 	TFT_24_7789_Write_Data(0x0035);//GCTRL: Gate Control
523:                 	TFT_24_7789_Write_Command(0x00BB);
9D0165A0  0F4050B6   JAL TFT_24_7789_Write_Command
9D0165A4  240400BB   ADDIU A0, ZERO, 187
524:                 	TFT_24_7789_Write_Data(0x002B);//VCOMS: VCOM setting
525:                 	TFT_24_7789_Write_Command(0x00C0);
9D0165B8  0F4050B6   JAL TFT_24_7789_Write_Command
9D0165BC  240400C0   ADDIU A0, ZERO, 192
526:                 	TFT_24_7789_Write_Data(0x002C);//LCMCTRL: LCM Control
527:                 	TFT_24_7789_Write_Command(0x00C2);
9D0165D0  0F4050B6   JAL TFT_24_7789_Write_Command
9D0165D4  240400C2   ADDIU A0, ZERO, 194
528:                 	TFT_24_7789_Write_Data(0x0001);
529:                 	TFT_24_7789_Write_Data(0xFF);//VDVVRHEN: VDV and VRH Command Enable
530:                 	TFT_24_7789_Write_Command(0x00C3);
9D0165F4  0F4050B6   JAL TFT_24_7789_Write_Command
9D0165F8  240400C3   ADDIU A0, ZERO, 195
531:                 	TFT_24_7789_Write_Data(0x0011);//VRHS: VRH Set
532:                 	TFT_24_7789_Write_Command(0x00C4);
9D01660C  0F4050B6   JAL TFT_24_7789_Write_Command
9D016610  240400C4   ADDIU A0, ZERO, 196
533:                 	TFT_24_7789_Write_Data(0x0020);//VDVS: VDV Set[10]
534:                 	TFT_24_7789_Write_Command(0x00C6);
9D016624  0F4050B6   JAL TFT_24_7789_Write_Command
9D016628  240400C6   ADDIU A0, ZERO, 198
535:                 	TFT_24_7789_Write_Data(0x000F);//FRCTRL2: Frame Rate control in normal mode
536:                 	TFT_24_7789_Write_Command(0x00D0);
9D01663C  0F4050B6   JAL TFT_24_7789_Write_Command
9D016640  240400D0   ADDIU A0, ZERO, 208
537:                 	TFT_24_7789_Write_Data(0x00A4);
538:                 	TFT_24_7789_Write_Data(0xA1);//PWCTRL1: Power Control 1
539:                 	TFT_24_7789_Write_Command(0x00E0);
9D016664  0F4050B6   JAL TFT_24_7789_Write_Command
9D016668  240400E0   ADDIU A0, ZERO, 224
540:                 	TFT_24_7789_Write_Data(0x00D0);
541:                 	TFT_24_7789_Write_Data(0x0000);
542:                 	TFT_24_7789_Write_Data(0x0005);
543:                 	TFT_24_7789_Write_Data(0x000E);
544:                 	TFT_24_7789_Write_Data(0x0015);
545:                 	TFT_24_7789_Write_Data(0x000D);
546:                 	TFT_24_7789_Write_Data(0x0037);
547:                 	TFT_24_7789_Write_Data(0x0043);
548:                 	TFT_24_7789_Write_Data(0x0047);
549:                 	TFT_24_7789_Write_Data(0x0009);
550:                 	TFT_24_7789_Write_Data(0x0015);
551:                 	TFT_24_7789_Write_Data(0x0012);
552:                 	TFT_24_7789_Write_Data(0x0016);
553:                 	TFT_24_7789_Write_Data(0x0019);//PVGAMCTRL: Positive Voltage Gamma control
554:                 	TFT_24_7789_Write_Command(0x00E1);
9D016744  0F4050B6   JAL TFT_24_7789_Write_Command
9D016748  240400E1   ADDIU A0, ZERO, 225
555:                 	TFT_24_7789_Write_Data(0x00D0);
556:                 	TFT_24_7789_Write_Data(0x0000);
557:                 	TFT_24_7789_Write_Data(0x0005);
558:                 	TFT_24_7789_Write_Data(0x000D);
559:                 	TFT_24_7789_Write_Data(0x000C);
560:                 	TFT_24_7789_Write_Data(0x0006);
561:                 	TFT_24_7789_Write_Data(0x002D);
562:                 	TFT_24_7789_Write_Data(0x0044);
563:                 	TFT_24_7789_Write_Data(0x0040);
564:                 	TFT_24_7789_Write_Data(0x000E);
565:                 	TFT_24_7789_Write_Data(0x001C);
566:                 	TFT_24_7789_Write_Data(0x0018);
567:                 	TFT_24_7789_Write_Data(0x0016);
568:                 	TFT_24_7789_Write_Data(0x0019);//NVGAMCTRL: Negative Voltage Gamma control
569:                 	TFT_24_7789_Write_Command(0x002A);
9D016818  0F4050B6   JAL TFT_24_7789_Write_Command
9D01681C  2404002A   ADDIU A0, ZERO, 42
570:                 	TFT_24_7789_Write_Data(0x0000);
571:                 	TFT_24_7789_Write_Data(0x0000);
572:                 	TFT_24_7789_Write_Data(0x0001);
573:                 	TFT_24_7789_Write_Data(0x003F);//X address set
574:                 	TFT_24_7789_Write_Command(0x002B);
9D016854  0F4050B6   JAL TFT_24_7789_Write_Command
9D016858  2404002B   ADDIU A0, ZERO, 43
575:                 	TFT_24_7789_Write_Data(0x0000);
576:                 	TFT_24_7789_Write_Data(0x0000);
577:                 	TFT_24_7789_Write_Data(0x0000);
578:                 	TFT_24_7789_Write_Data(0x00EF);//Y address set
579:                 	TFT_24_7789_Write_Command(0x11);
9D016890  0F4050B6   JAL TFT_24_7789_Write_Command
9D016894  24040011   ADDIU A0, ZERO, 17
580:                 	TFT_24_7789_Write_Command(0x38);
9D016898  0F4050B6   JAL TFT_24_7789_Write_Command
9D01689C  24040038   ADDIU A0, ZERO, 56
581:                 	TFT_24_7789_Write_Command(0x13);
9D0168A0  0F4050B6   JAL TFT_24_7789_Write_Command
9D0168A4  24040013   ADDIU A0, ZERO, 19
582:                 
583:                 	}
9D0168A8  8FBF0034   LW RA, 52(SP)
9D0168AC  8FBE0030   LW FP, 48(SP)
9D0168B0  8FB7002C   LW S7, 44(SP)
9D0168B4  8FB60028   LW S6, 40(SP)
9D0168B8  8FB50024   LW S5, 36(SP)
9D0168BC  8FB40020   LW S4, 32(SP)
9D0168C0  8FB3001C   LW S3, 28(SP)
9D0168C4  8FB20018   LW S2, 24(SP)
9D0168C8  8FB10014   LW S1, 20(SP)
9D0168CC  8FB00010   LW S0, 16(SP)
9D0168D0  03E00008   JR RA
9D0168D4  27BD0038   ADDIU SP, SP, 56
584:                 /*******************************************************************************/
585:                 
---  /Users/nitro/basic-badge/firmware/badge1.X/src/badge.c  --------------------------------------------
1:                   #include <xc.h>
2:                   #include "badge.h"
3:                   #include "basic/ubasic.h"
4:                   #include "basic/tokenizer.h"
5:                   #include <plib.h>
6:                   #include <stdlib.h>
7:                   #include <string.h>
8:                   #include <stdio.h>
9:                   #include <ctype.h>
10:                  #include <stdint.h>
11:                  #include <setjmp.h>
12:                  #include "Z80/sim.h"
13:                  #include "Z80/simglb.h"
14:                  
15:                  
16:                  
17:                  uint16_t basic_loads (int8_t * data, uint16_t maxlen);
18:                  uint16_t basic_saves (int8_t * data, uint16_t maxlen);
19:                  void init_z80_cpm (void);
20:                  void init_basic (void);
21:                  void init_userprog(void);
22:                  void loop_z80_cpm (void);
23:                  void loop_basic (void);
24:                  void loop_userprog(void);
25:                  void boot_animation(void);
26:                  void init_8080_basic (void);
27:                  void loop_8080_basic (void);
28:                  uint8_t cmd_exec (int8_t * cmd);
29:                  uint8_t basic_save_program (uint8_t * data, uint8_t slot);
30:                  uint8_t basic_load_program (uint8_t * data, uint8_t slot);
31:                  uint16_t get_free_mem(uint8_t * prog, uint16_t max_mem);
32:                  uint8_t add_prog_line (int8_t * line, int8_t * prog, int16_t linenum);
33:                  void list_more (void);
34:                  void menu(void);
35:                  void show_help(void);
36:                  uint32_t hash(int8_t *);
37:                  uint8_t get_command_index(uint32_t );
38:                  uint8_t wisecrack(int8_t *, uint16_t , unsigned char, uint8_t);
39:                  void clear_crack(void);
40:                  uint8_t random_crack(void);
41:                  void showmenu(void);
42:                  void show_version(void);
43:                  void fancyframe(void);
44:                  void clear_prompt(void);
45:                  void show_wrencher(void);
46:                  uint8_t playriff(unsigned char);
47:                  
48:                  /************ Defines ****************************/
49:                  #define STDIO_LOCAL_BUFF_SIZE	25
50:                  
51:                  //Prompt handling defines
52:                  #define COMMAND_MAX 32
53:                  #define TEXT_LEFT	4
54:                  #define PROMPT_Y	15
55:                  #define CRACK_Y		17
56:                  #define VERSION_X	33
57:                  #define VERSION_Y	18
58:                  #define CRACK_TIMEOUT 4000
59:                  //Menu color values
60:                  #define MENU_FRAME_FG	12
61:                  #define MENU_FRAME_BG	0
62:                  #define MENU_BANNER_FG	0
63:                  #define MENU_BANNER_BG	15
64:                  #define MENU_HEADER_FG	15
65:                  #define MENU_HEADER_BG	8
66:                  #define MENU_ENTRY_FG	15
67:                  #define MENU_ENTRY_BG	9
68:                  #define MENU_DEFAULT_FG 15
69:                  #define MENU_DEFAULT_BG 0
70:                  #define MENU_VERSION_FG	8
71:                  #define MENU_SECRET_COLOR 10
72:                  #define MENU_CRACK_COLOR 14
73:                  /********** End Defines **************************/
74:                  
75:                  /************* Function Prototypes ***************/
76:                  /*** End Function Prototypes **********************88*/
77:                  
78:                  int8_t bprog[BPROG_LEN+1];
79:                  int8_t bprog_init[700] =
80:                  "10 c = 1 + rnd 4\n\
81:                  20 color c,c+8\n\
82:                  30 for i=1 to 800\n\
83:                  40 chr 200 + (rnd 6)\n\
84:                  50 next i\n\
85:                  60 wait 100\n\
86:                  70 tune 60,64,67,800\n\
87:                  80 tune 57,62,66,800\n\
88:                  90 tune 59,64,47,800\n\
89:                  100 tune 59,62,67,800\n\
90:                  110 for i=60 to 72\n\
91:                  120 led (rnd 2),1\n\
92:                  130 led (rnd 2),0\n\
93:                  140 tune 0,0,i,20\n\
94:                  150 next i\n\
95:                  160 tune 67,71,74,1600\n\
96:                  170 for i=0 to 2\n\
97:                  180 led i,0\n\
98:                  190 next i\n\
99:                  200 color 15,0\n\
100:                 210 println \"Type more to see code\"\n\
101:                 220 println \" \"\n\
102:                 230 println \"Find documentation: hac.io/Mz3r \" \n";
103:                 
104:                 //a lot of magic numbers here, should be done properly
105:                 int8_t tprog[100],stdio_buff[50],key_buffer[10],char_out, stdio_local_buff[STDIO_LOCAL_BUFF_SIZE];
106:                 
107:                 uint8_t get_stat,key_buffer_ptr =0,cmd_line_buff[30], cmd_line_pointer,cmd_line_key_stat_old,prompt;
108:                 uint8_t stdio_local_len=0;
109:                 uint16_t term_pointer,vertical_shift;
110:                 int16_t prog_ptr;
111:                 int32_t i,j,len;
112:                 jmp_buf jbuf;
113:                 volatile uint8_t handle_display = 0;
114:                 volatile int8_t brk_key,stdio_src;
115:                 extern volatile uint16_t bufsize;
116:                 volatile uint32_t ticks;			// millisecond timer incremented in ISR
117:                 
118:                 extern const uint8_t ram_image[65536];
119:                 extern const uint8_t b2_rom[2048];
120:                 extern const uint8_t ram_init [30];
121:                 extern uint8_t ram_disk[RAMDISK_SIZE];
122:                 
123:                 
124:                 int8_t disp_buffer[DISP_BUFFER_HIGH+1][DISP_BUFFER_WIDE];
125:                 int8_t color_buffer[DISP_BUFFER_HIGH+1][DISP_BUFFER_WIDE];
126:                 
127:                 #define HASH_TABLE_LENGTH	13
128:                 const uint32_t  hashtable[HASH_TABLE_LENGTH] =
129:                 	{
130:                 	0,				//0
131:                 	0,				//1
132:                 	4080429,		//2
133:                 	3914880981u,	//3
134:                 	1670,			//4
135:                 	121730,			//5
136:                 	4108351,		//6
137:                 	138097304,		//7
138:                 	110149,			//8
139:                 	3174374908u,	//9
140:                 	132593272,		//10
141:                 	2802956003u,	//11
142:                 	3638929			//12
143:                 	};
144:                 
145:                 const uint8_t wrencher[18][41] = {
146:                 "    +mmy/                      /ymm+    ",
147:                 "      sMMh                    hMMs      ",
148:                 "h/  .hMMMM.                  -MMMMh.  /h",
149:                 "sMmyMMMMMMNo`              `oNMMMMMMymMs",
150:                 " :hNMMMMMMMMMo`:shmNNmhs:`oMMMMMMMMMNh: ",
151:                 "       :hMMN+sNMMMMMMMMMMNo+NMMh:       ",
152:                 "         -s:mMMMMMMMMMMMMMMm:s.         ",
153:                 "          `mMMMMMMMMMMMMMMMMm`          ",
154:                 "          +MMh.  -mMMd-  .hMM/          ",
155:                 "          oMM.  -+NMMN+-  .MMo          ",
156:                 "          -MMd/NMMMmmMMMN/dMM-          ",
157:                 "         -/sMMMMMMM::MMMMMMMs/-         ",
158:                 "       /dMMsoMMMMMMNNMMMMMNosMMd/       ",
159:                 " :hNMMMMMMMMd-hMMMMMMMMMMh-dMMMMMMMMNy: ",
160:                 "sMmyMMMMMMm+` /mNsoNm+sNm/ `omMMMMMNymMo",
161:                 "h:  .yMMMM.                  .MMMMy.  :h",
162:                 "      sMMh                    hMMs      ",
163:                 "   `ommh/                      /hmm+    "};
164:                 
165:                 const uint8_t rand_crack00[] = "Have you been into Branko's rakija?";
166:                 const uint8_t rand_crack01[] = "Prove you're human: 0b101010";
167:                 const uint8_t rand_crack02[] = "I don't think that mean what you think it means.";
168:                 const uint8_t rand_crack03[] = "Want to play a game?";
169:                 const uint8_t rand_crack04[] = "How do I get 30 extra live?";
170:                 const uint8_t rand_crack05[] = "Maybe you should RTFM: https://hac.io/Mz3r";
171:                 const uint8_t rand_crack06[] = "Erm... It's supposed to do that";
172:                 const uint8_t rand_crack07[] = "Too many errors on one line (make fewer)";
173:                 const uint8_t rand_crack08[] = "You are in a maze of twisty compiler features, all different";
174:                 const uint8_t rand_crack09[] = "Parse error: unexpected idoiot at the keyboard";
175:                 const uint8_t rand_crack10[] = "Program Lost -- Sorry.";
176:                 const uint8_t rand_crack11[] = "I find your lack of faith disturbing";
177:                 const uint8_t rand_crack12[] = "There are people who know what they're doing, then there's you";
178:                 const uint8_t rand_crack13[] = "My brain just exploded.";
179:                 const uint8_t rand_crack14[] = "You can't just start making up commands";
180:                 const uint8_t rand_crack15[] = "Try restarting shockwave";
181:                 const uint8_t rand_crack16[] = "That really grinds my ALU";
182:                 const uint8_t rand_crack17[] = "Erq ureevat";
183:                 const uint8_t rand_crack18[] = "I'm drawing a blank";
184:                 const uint8_t blanks[] = "                                      ";
185:                 
186:                 #define CRACKCOUNT 19
187:                 const uint8_t * cracks[CRACKCOUNT] =
188:                 	{
189:                 	rand_crack00,
190:                 	rand_crack01,
191:                 	rand_crack02,
192:                 	rand_crack03,
193:                 	rand_crack04,
194:                 	rand_crack05,
195:                 	rand_crack06,
196:                 	rand_crack07,
197:                 	rand_crack08,
198:                 	rand_crack09,
199:                 	rand_crack10,
200:                 	rand_crack11,
201:                 	rand_crack12,
202:                 	rand_crack13,
203:                 	rand_crack14,
204:                 	rand_crack15,
205:                 	rand_crack16,
206:                 	rand_crack17,
207:                 	rand_crack18
208:                 	};
209:                 
210:                 void show_help(void)
211:                 	{
9D01C714  27BDFFE8   ADDIU SP, SP, -24
9D01C718  AFBF0014   SW RA, 20(SP)
212:                 	clr_buffer();
9D01C71C  0F40707A   JAL clr_buffer
9D01C720  00000000   NOP
213:                 	set_cursor_state(0);
9D01C724  0F4050A1   JAL set_cursor_state
9D01C728  00002021   ADDU A0, ZERO, ZERO
214:                 	video_gotoxy(0,0);
9D01C72C  00002021   ADDU A0, ZERO, ZERO
9D01C730  0F406BAF   JAL video_gotoxy
9D01C734  00002821   ADDU A1, ZERO, ZERO
215:                 	video_set_color(3,1);
9D01C738  24040003   ADDIU A0, ZERO, 3
9D01C73C  0F406B12   JAL .LFB8, .LFE58, video_set_color
9D01C740  24050001   ADDIU A1, ZERO, 1
216:                 	stdio_write("Badge keyboard shortcuts:\n");
9D01C744  3C049D03   LUI A0, -25341
9D01C748  0F407196   JAL stdio_write
9D01C74C  24849D54   ADDIU A0, A0, -25260
217:                 	video_set_color(15,0);
9D01C750  2404000F   ADDIU A0, ZERO, 15
9D01C754  0F406B12   JAL .LFB8, .LFE58, video_set_color
9D01C758  00002821   ADDU A1, ZERO, ZERO
218:                 	stdio_write("  Reset badge : shift-RESET\n");
9D01C75C  3C049D03   LUI A0, -25341
9D01C760  0F407196   JAL stdio_write
9D01C764  24849D70   ADDIU A0, A0, -25232
219:                 	stdio_write("  Type underscore: Rshift-dash\n");
9D01C768  3C049D03   LUI A0, -25341
9D01C76C  0F407196   JAL stdio_write
9D01C770  24849D90   ADDIU A0, A0, -25200
220:                 	stdio_write("  Fast reset: Lshift-Rshift-RESET\n");
9D01C774  3C049D03   LUI A0, -25341
9D01C778  0F407196   JAL stdio_write
9D01C77C  24849DB0   ADDIU A0, A0, -25168
221:                 	stdio_write("  Serial console: Lshift-Rshift-BRK\n");
9D01C780  3C049D03   LUI A0, -25341
9D01C784  0F407196   JAL stdio_write
9D01C788  24849DD4   ADDIU A0, A0, -25132
222:                 	video_set_color(1,11);
9D01C78C  24040001   ADDIU A0, ZERO, 1
9D01C790  0F406B12   JAL .LFB8, .LFE58, video_set_color
9D01C794  2405000B   ADDIU A1, ZERO, 11
223:                 	stdio_write("Badge Documentation:\n");
9D01C798  3C049D03   LUI A0, -25341
9D01C79C  0F407196   JAL stdio_write
9D01C7A0  24849DFC   ADDIU A0, A0, -25092
224:                 	video_set_color(15,0);
9D01C7A4  2404000F   ADDIU A0, ZERO, 15
9D01C7A8  0F406B12   JAL .LFB8, .LFE58, video_set_color
9D01C7AC  00002821   ADDU A1, ZERO, ZERO
225:                 	stdio_write("  hac.io/Mz3r");
9D01C7B0  3C049D03   LUI A0, -25341
9D01C7B4  0F407196   JAL stdio_write
9D01C7B8  24849E14   ADDIU A0, A0, -25068
226:                 	}
9D01C7BC  8FBF0014   LW RA, 20(SP)
9D01C7C0  03E00008   JR RA
9D01C7C4  27BD0018   ADDIU SP, SP, 24
227:                 
228:                 //B_BDG005
229:                 void wake_return(void)
230:                 	{
9D01C05C  03E00008   JR RA
9D01C060  00000000   NOP
231:                 	//By default, this will be called after waking from sleep. It should do
232:                 	//noting. This is a placeholder for user programs to set the function pointer.
233:                 	return;
234:                 	}
235:                 
236:                 void badge_init (void)
237:                 	{
238:                 	//B_BDG009
239:                 //	start_after_wake = &wake_return; //Function pointer for waking from sleep
240:                 	ticks = 0;
9D01C064  AF8081DC   SW ZERO, -32292(GP)
241:                 	stdio_src = STDIO_LOCAL;
9D01C068  A38081CD   SB ZERO, -32307(GP)
242:                 //	stdio_src = STDIO_TTY1;
243:                 //	term_init();
244:                 //	strcpy(bprog,bprog_init);
245:                 //	set_cursor_state(1);
246:                     handle_display = 0;
9D01C06C  A3808195   SB ZERO, -32363(GP)
9D01C070  03E00008   JR RA
9D01C074  00000000   NOP
247:                 	}
248:                 
249:                 ////B_BDG002
250:                 //void badge_menu(void)
251:                 //	{
252:                 //	showmenu();
253:                 //	
254:                 //	int8_t char_out;
255:                 //	uint8_t menu_buff[COMMAND_MAX], menu_pointer;
256:                 //	menu_pointer=0;
257:                 //	int16_t len, i;
258:                 //	uint8_t clear_flag = 0;
259:                 //	uint32_t  wait_to_clear = 0;
260:                 //	
261:                 //	uint8_t random_has_been_seeded = 0;
262:                 //	
263:                 //	while (1)
264:                 //		{
265:                 //		if (clear_flag)
266:                 //			{
267:                 //			if (millis() > wait_to_clear)
268:                 //				{
269:                 //				clear_flag = 0;
270:                 //				clear_crack();
271:                 //				}
272:                 //			}
273:                 //		uint8_t get_stat = stdio_get(&char_out);
274:                 //		if (get_stat!=0)
275:                 //			{
276:                 //			
277:                 //			//Seed random number if we haven't already
278:                 //			if (random_has_been_seeded == 0)
279:                 //				{
280:                 //				//Pull seed directly from TIMER1 register
281:                 //				srand(*(char*)0xBF800610);
282:                 //				++random_has_been_seeded;
283:                 //				}
284:                 //			if (char_out==K_UP) char_out='U';
285:                 //			if (char_out==K_DN) char_out='D';
286:                 //			if (char_out==K_LT) char_out='L';
287:                 //			if (char_out==K_RT) char_out='R';
288:                 //			stdio_c(char_out);
289:                 //			if (char_out==BACKSPACE)
290:                 //				{
291:                 //				if (menu_pointer)
292:                 //					{
293:                 //					//We only need to do this if we're not at position 0
294:                 //					--menu_pointer;
295:                 //					menu_buff[menu_pointer] = 0;
296:                 //					int16_t cursorx, cursory;
297:                 //					cursorx = video_getx();
298:                 //					cursory = video_gety();
299:                 //					stdio_write(" ");
300:                 //					video_gotoxy(cursorx, cursory);
301:                 //					}
302:                 //				else
303:                 //					{
304:                 //					//Don't let backspace key move left of input position
305:                 //					video_gotoxy(TEXT_LEFT+2,PROMPT_Y);
306:                 //					}
307:                 //				}
308:                 //			else if (char_out==NEWLINE)
309:                 //				{
310:                 //				//Erase where the funny messages are written
311:                 //				clear_crack();
312:                 //							
313:                 //				menu_buff[menu_pointer] = 0;	//add zero terminator
314:                 //				//Check entry and react
315:                 //				
316:                 //				if (menu_buff[0] == 0)
317:                 //					{
318:                 //					//No characters were input, this stops user from just
319:                 //					//hitting enter to display all funny messages
320:                 //					clear_prompt();
321:                 //					menu_pointer = 0;
322:                 //					continue;
323:                 //					}
324:                 //				if (strcmp(menu_buff,"1")==0)
325:                 //					{
326:                 //					video_clrscr();
327:                 //					init_basic();
328:                 //					while (1) loop_basic();
329:                 //					}
330:                 //				else if (strcmp(menu_buff,"2")==0)
331:                 //					{
332:                 //					video_clrscr();
333:                 //					init_z80_cpm();
334:                 //					while (1) loop_z80_cpm();
335:                 //					}			
336:                 //				else if (strcmp(menu_buff,"3")==0)
337:                 //					{
338:                 //					init_8080_basic();
339:                 //					while (1) loop_8080_basic();
340:                 //					}
341:                 //				else if (strcmp(menu_buff,"4")==0)
342:                 //					{
343:                 //					enable_display_scanning(0); //Shut off auto-scanning of character buffer
344:                 //					tetrapuzz();
345:                 //					}
346:                 //				//B_BDG006		
347:                 //				else if (strcmp(menu_buff,"5")==0)
348:                 //					{
349:                 //					stdio_local_buffer_puts("c:\nzork1\n");
350:                 //					video_clrscr();
351:                 //					video_set_color(0,14);
352:                 //					stdio_write("\n\n\n\n\n\nPROTIP:\n\tUse Shift-Enter when playing ZORK!\n\n");
353:                 //					video_set_color(15,0);
354:                 //					wait_ms(2000);
355:                 //					init_z80_cpm();
356:                 //					while (1) loop_z80_cpm();
357:                 //					}
358:                 //				else if (strcmp(menu_buff,"6")==0)
359:                 //					{
360:                 //					init_userprog();
361:                 //					while (1) loop_userprog();
362:                 //					}	
363:                 //				else
364:                 //					{
365:                 //					switch (get_command_index(hash(menu_buff)))
366:                 //						{
367:                 //						//case 0: break;
368:                 //						case 2: clear_flag = wisecrack("Make your own sandwich",TEXT_LEFT,CRACK_Y, 0); break;
369:                 //						case 3: clear_flag = wisecrack("Existence itself is not a hack", TEXT_LEFT,CRACK_Y, 0); break;
370:                 //						case 4: clear_flag = wisecrack("101010 *IS* the answer", TEXT_LEFT,CRACK_Y, 0); break;
371:                 //						case 5: clear_flag = wisecrack("Hackers don't need manuals", TEXT_LEFT,CRACK_Y, 0); break;
372:                 //						case 6: clear_flag = wisecrack("Han shot first", TEXT_LEFT,CRACK_Y, 0); break;
373:                 //						case 7: clear_flag = wisecrack("You're in a room filled with hackers", TEXT_LEFT,CRACK_Y, 0); break;
374:                 //						case 8: clear_flag = wisecrack("I am afraid I can't do that Dave", TEXT_LEFT,CRACK_Y, 0); break;
375:                 //						case 9: show_wrencher(); break;
376:                 //						case 10: play_mario_tune(); break;
377:                 //						case 11: 
378:                 //							handle_display = 0;
379:                 //							play_snake();
380:                 //							break;
381:                 //						case 12: show_help(); while(1) { ;; };
382:                 //						default: clear_flag = random_crack(); break;
383:                 //						}
384:                 //					}
385:                 //
386:                 //				
387:                 //				clear_prompt();
388:                 //				menu_pointer = 0;
389:                 //				menu_buff[menu_pointer] = 0;
390:                 //				}
391:                 //				
392:                 //			else
393:                 //				{
394:                 //				menu_buff[menu_pointer++] = char_out;
395:                 //				if (menu_pointer >= COMMAND_MAX-1) 
396:                 //					{
397:                 //					menu_pointer = 0;
398:                 //					menu_buff[menu_pointer] = 0;
399:                 //					clear_flag = wisecrack("Boo, too big.",TEXT_LEFT,CRACK_Y,1);
400:                 //					clear_prompt();
401:                 //					}
402:                 //				}
403:                 //			if (clear_flag)
404:                 //				{
405:                 //				wait_to_clear = millis() + CRACK_TIMEOUT;
406:                 //				}
407:                 //			}
408:                 //		}
409:                 //	}
410:                 
411:                 uint32_t  hash(int8_t *command)
412:                 	{
9D01C078  24860066   ADDIU A2, A0, 102
413:                 	uint32_t  hash = 0;
414:                 	uint8_t infinite_loop_breaker = 0;
415:                 	uint8_t c;
416:                 	while (c = *command++)
9D01C07C  0B407024   J 0x9D01C090
9D01C080  00001021   ADDU V0, ZERO, ZERO
9D01C090  24840001   ADDIU A0, A0, 1
9D01C094  9083FFFF   LBU V1, -1(A0)
9D01C098  1460FFFA   BNE V1, ZERO, 0x9D01C084
9D01C09C  00022940   SLL A1, V0, 5
9D01C0A0  03E00008   JR RA
9D01C0A4  00000000   NOP
417:                 		{
418:                 		hash = (hash*33)^c;
9D01C084  00A21021   ADDU V0, A1, V0
419:                 		if (infinite_loop_breaker++ > 100) return 0;	//In case we get stuck
9D01C088  10860007   BEQ A0, A2, 0x9D01C0A8
9D01C08C  00431026   XOR V0, V0, V1
420:                 		}
421:                 	//sprintf(stdio_buff, "has %d\n", hash);
422:                 	return hash;
423:                 	}
9D01C0A8  03E00008   JR RA
9D01C0AC  00001021   ADDU V0, ZERO, ZERO
424:                 
425:                 uint8_t get_command_index(uint32_t  hash_value)
426:                 	{
427:                 	uint8_t i;
428:                 	for (i=0; i<HASH_TABLE_LENGTH; i++)
9D01C0BC  24020001   ADDIU V0, ZERO, 1
9D01C0C0  2406000D   ADDIU A2, ZERO, 13
9D01C0D0  24420001   ADDIU V0, V0, 1
9D01C0D4  304200FF   ANDI V0, V0, 255
9D01C0D8  1446FFFA   BNE V0, A2, 0x9D01C0C4
9D01C0DC  24630004   ADDIU V1, V1, 4
9D01C0E0  03E00008   JR RA
9D01C0E4  00001021   ADDU V0, ZERO, ZERO
9D01C0E8  03E00008   JR RA
9D01C0EC  00001021   ADDU V0, ZERO, ZERO
429:                 		{
430:                 		if (hashtable[i] == hash_value) return i;
9D01C0B0  1080000D   BEQ A0, ZERO, 0x9D01C0E8
9D01C0B4  3C039D03   LUI V1, -25341
9D01C0B8  2463A53C   ADDIU V1, V1, -23236
9D01C0C4  8C650000   LW A1, 0(V1)
9D01C0C8  10A40009   BEQ A1, A0, 0x9D01C0F0
9D01C0CC  00000000   NOP
431:                 		}
432:                 	return 0;
433:                 	}
9D01C0F0  03E00008   JR RA
9D01C0F4  00000000   NOP
434:                 
435:                 uint8_t random_crack(void)
436:                 	{
9D01C8D0  27BDFFE8   ADDIU SP, SP, -24
9D01C8D4  AFBF0014   SW RA, 20(SP)
437:                 	uint8_t i = (uint8_t)rand()%CRACKCOUNT;
9D01C8D8  0F40EF88   JAL .Letext0, .LFE0, rand
9D01C8DC  00000000   NOP
9D01C8E0  304200FF   ANDI V0, V0, 255
9D01C8E4  3C04AF28   LUI A0, -20696
9D01C8E8  24846BCB   ADDIU A0, A0, 27595
9D01C8EC  00440019   MULTU 0, V0, A0
9D01C8F0  00002010   MFHI A0
9D01C8F4  00441823   SUBU V1, V0, A0
9D01C8F8  00031842   SRL V1, V1, 1
9D01C8FC  00831821   ADDU V1, A0, V1
9D01C900  00031902   SRL V1, V1, 4
9D01C904  00032880   SLL A1, V1, 2
9D01C908  00032100   SLL A0, V1, 4
9D01C90C  00A42021   ADDU A0, A1, A0
9D01C910  00831823   SUBU V1, A0, V1
9D01C914  00431023   SUBU V0, V0, V1
438:                 	return wisecrack((uint8_t *)cracks[i],TEXT_LEFT, CRACK_Y,1);
9D01C918  304200FF   ANDI V0, V0, 255
9D01C91C  00021080   SLL V0, V0, 2
9D01C920  3C04A001   LUI A0, -24575
9D01C924  24849B9C   ADDIU A0, A0, -25700
9D01C928  00441021   ADDU V0, V0, A0
9D01C92C  8C440000   LW A0, 0(V0)
9D01C930  24050004   ADDIU A1, ZERO, 4
9D01C934  24060011   ADDIU A2, ZERO, 17
9D01C938  0F4071F2   JAL wisecrack
9D01C93C  24070001   ADDIU A3, ZERO, 1
439:                 	}
9D01C940  8FBF0014   LW RA, 20(SP)
9D01C944  03E00008   JR RA
9D01C948  27BD0018   ADDIU SP, SP, 24
440:                 
441:                 uint8_t wisecrack(int8_t * quip, uint16_t x, uint8_t y, uint8_t type)
442:                 	{
9D01C7C8  27BDFF98   ADDIU SP, SP, -104
9D01C7CC  AFBF0064   SW RA, 100(SP)
9D01C7D0  AFB10060   SW S1, 96(SP)
9D01C7D4  AFB0005C   SW S0, 92(SP)
9D01C7D8  00A08821   ADDU S1, A1, ZERO
9D01C7DC  00C08021   ADDU S0, A2, ZERO
443:                 	uint8_t index, line1index, line2index;
444:                 	uint8_t line1[33];
445:                 	uint8_t line2[33];
446:                 	index = 0;
447:                 	line1index = 0;
9D01C7E8  00005021   ADDU T2, ZERO, ZERO
448:                 	line2index = 0;
9D01C7E4  00005821   ADDU T3, ZERO, ZERO
449:                 	while (quip[index] != 0)
9D01C7E0  00001021   ADDU V0, ZERO, ZERO
9D01C7EC  0B407210   J 0x9D01C840
9D01C7F0  24050040   ADDIU A1, ZERO, 64
9D01C844  80630000   LB V1, 0(V1)
9D01C848  1460FFEA   BNE V1, ZERO, 0x9D01C7F4
9D01C84C  304800FF   ANDI T0, V0, 255
450:                 		{
451:                 		if (index < 32)
9D01C7F4  2D090020   SLTIU T1, T0, 32
9D01C7F8  11200007   BEQ T1, ZERO, 0x9D01C818
9D01C7FC  2D080040   SLTIU T0, T0, 64
452:                 			{
453:                 			line1[line1index++] = quip[index];
9D01C800  25460001   ADDIU A2, T2, 1
9D01C804  27A80010   ADDIU T0, SP, 16
9D01C808  010A5021   ADDU T2, T0, T2
9D01C80C  A1430000   SB V1, 0(T2)
9D01C810  0B40720D   J 0x9D01C834
9D01C814  30CA00FF   ANDI T2, A2, 255
454:                 			}
455:                 		else if (index < 64)
9D01C818  51000007   BEQL T0, ZERO, 0x9D01C838
9D01C81C  24420001   ADDIU V0, V0, 1
456:                 			{
457:                 			line2[line2index++] = quip[index];
9D01C820  25660001   ADDIU A2, T3, 1
9D01C824  27A80010   ADDIU T0, SP, 16
9D01C828  010B5821   ADDU T3, T0, T3
9D01C82C  A1630024   SB V1, 36(T3)
9D01C830  30CB00FF   ANDI T3, A2, 255
9D01C834  24420001   ADDIU V0, V0, 1
458:                 			}
459:                 		if (++index >= 64) break;
9D01C838  50450006   BEQL V0, A1, 0x9D01C854
9D01C83C  27A20010   ADDIU V0, SP, 16
9D01C840  00821821   ADDU V1, A0, V0
460:                 		}
461:                 	line1[line1index] = 0;
9D01C850  27A20010   ADDIU V0, SP, 16
9D01C854  004A5021   ADDU T2, V0, T2
9D01C858  A1400000   SB ZERO, 0(T2)
462:                 	line2[line2index] = 0;
9D01C85C  004B5821   ADDU T3, V0, T3
463:                 	
464:                 	if (type == 0)
9D01C860  14E00006   BNE A3, ZERO, 0x9D01C87C
9D01C864  A1600024   SB ZERO, 36(T3)
465:                 		{
466:                 		video_set_color(MENU_SECRET_COLOR, MENU_DEFAULT_BG);
9D01C868  2404000A   ADDIU A0, ZERO, 10
9D01C86C  0F406B12   JAL .LFB8, .LFE58, video_set_color
9D01C870  00002821   ADDU A1, ZERO, ZERO
9D01C874  0B407223   J 0x9D01C88C
9D01C878  7C118C20   SEB S1, S1
467:                 		}
468:                 	else video_set_color(MENU_CRACK_COLOR, MENU_DEFAULT_BG);
9D01C87C  2404000E   ADDIU A0, ZERO, 14
9D01C880  0F406B12   JAL .LFB8, .LFE58, video_set_color
9D01C884  00002821   ADDU A1, ZERO, ZERO
469:                 	video_gotoxy(x,y);
9D01C888  7C118C20   SEB S1, S1
9D01C88C  02202021   ADDU A0, S1, ZERO
9D01C890  0F406BAF   JAL video_gotoxy
9D01C894  7C102C20   SEB A1, S0
470:                 	stdio_write(line1);
9D01C898  0F407196   JAL stdio_write
9D01C89C  27A40010   ADDIU A0, SP, 16
471:                 	video_gotoxy(x,y+1);
9D01C8A0  26050001   ADDIU A1, S0, 1
9D01C8A4  02202021   ADDU A0, S1, ZERO
9D01C8A8  0F406BAF   JAL video_gotoxy
9D01C8AC  7C052C20   SEB A1, A1
472:                 	stdio_write(line2);
9D01C8B0  0F407196   JAL stdio_write
9D01C8B4  27A40034   ADDIU A0, SP, 52
473:                 	return 1;
474:                 	}
9D01C8B8  24020001   ADDIU V0, ZERO, 1
9D01C8BC  8FBF0064   LW RA, 100(SP)
9D01C8C0  8FB10060   LW S1, 96(SP)
9D01C8C4  8FB0005C   LW S0, 92(SP)
9D01C8C8  03E00008   JR RA
9D01C8CC  27BD0068   ADDIU SP, SP, 104
475:                 
476:                 void clear_crack(void)
477:                 	{
9D01C94C  27BDFFE0   ADDIU SP, SP, -32
9D01C950  AFBF001C   SW RA, 28(SP)
9D01C954  AFB20018   SW S2, 24(SP)
9D01C958  AFB10014   SW S1, 20(SP)
478:                 	int16_t cursorx, cursory;
479:                 	cursorx = video_getx();
9D01C95C  0F406C51   JAL video_getx
9D01C960  AFB00010   SW S0, 16(SP)
480:                 	cursory = video_gety();
9D01C964  0F406C53   JAL .LFB47, .LFE46, video_gety
9D01C968  00409021   ADDU S2, V0, ZERO
9D01C96C  00408821   ADDU S1, V0, ZERO
481:                 	video_gotoxy(1,CRACK_Y);
9D01C970  24040001   ADDIU A0, ZERO, 1
9D01C974  0F406BAF   JAL video_gotoxy
9D01C978  24050011   ADDIU A1, ZERO, 17
482:                 	stdio_write((uint8_t *)blanks);
9D01C97C  3C109D03   LUI S0, -25341
9D01C980  0F407196   JAL stdio_write
9D01C984  26049F80   ADDIU A0, S0, -24704
483:                 	video_gotoxy(1,CRACK_Y+1);
9D01C988  24040001   ADDIU A0, ZERO, 1
9D01C98C  0F406BAF   JAL video_gotoxy
9D01C990  24050012   ADDIU A1, ZERO, 18
484:                 	stdio_write((uint8_t *)blanks);
9D01C994  0F407196   JAL stdio_write
9D01C998  26049F80   ADDIU A0, S0, -24704
485:                 	video_gotoxy(cursorx,cursory);
9D01C99C  02402021   ADDU A0, S2, ZERO
9D01C9A0  0F406BAF   JAL video_gotoxy
9D01C9A4  02202821   ADDU A1, S1, ZERO
486:                 	}
9D01C9A8  8FBF001C   LW RA, 28(SP)
9D01C9AC  8FB20018   LW S2, 24(SP)
9D01C9B0  8FB10014   LW S1, 20(SP)
9D01C9B4  8FB00010   LW S0, 16(SP)
9D01C9B8  03E00008   JR RA
9D01C9BC  27BD0020   ADDIU SP, SP, 32
487:                 
488:                 void showmenu(void)
489:                 	{
9D01CBD8  27BDFFE8   ADDIU SP, SP, -24
9D01CBDC  AFBF0014   SW RA, 20(SP)
490:                 	//Set some background boxes
491:                 	video_clrscr();
9D01CBE0  0F406C60   JAL video_clrscr
9D01CBE4  AFB00010   SW S0, 16(SP)
492:                 	video_set_color(MENU_BANNER_FG,MENU_BANNER_BG);
9D01CBE8  00002021   ADDU A0, ZERO, ZERO
9D01CBEC  0F406B12   JAL .LFB8, .LFE58, video_set_color
9D01CBF0  2405000F   ADDIU A1, ZERO, 15
493:                 	video_gotoxy(1,1);
9D01CBF4  24040001   ADDIU A0, ZERO, 1
9D01CBF8  0F406BAF   JAL video_gotoxy
9D01CBFC  24050001   ADDIU A1, ZERO, 1
494:                 	stdio_write((uint8_t *)blanks);
9D01CC00  3C109D03   LUI S0, -25341
9D01CC04  0F407196   JAL stdio_write
9D01CC08  26049F80   ADDIU A0, S0, -24704
495:                 	video_gotoxy(1,2);
9D01CC0C  24040001   ADDIU A0, ZERO, 1
9D01CC10  0F406BAF   JAL video_gotoxy
9D01CC14  24050002   ADDIU A1, ZERO, 2
496:                 	stdio_write((uint8_t *)blanks);
9D01CC18  0F407196   JAL stdio_write
9D01CC1C  26049F80   ADDIU A0, S0, -24704
497:                 	video_gotoxy(1,3);
9D01CC20  24040001   ADDIU A0, ZERO, 1
9D01CC24  0F406BAF   JAL video_gotoxy
9D01CC28  24050003   ADDIU A1, ZERO, 3
498:                 	stdio_write((uint8_t *)blanks);
9D01CC2C  0F407196   JAL stdio_write
9D01CC30  26049F80   ADDIU A0, S0, -24704
499:                 	
500:                 	video_set_color(MENU_HEADER_FG,MENU_HEADER_BG);
9D01CC34  2404000F   ADDIU A0, ZERO, 15
9D01CC38  0F406B12   JAL .LFB8, .LFE58, video_set_color
9D01CC3C  24050008   ADDIU A1, ZERO, 8
501:                 	video_gotoxy(3,5);
9D01CC40  24040003   ADDIU A0, ZERO, 3
9D01CC44  0F406BAF   JAL video_gotoxy
9D01CC48  24050005   ADDIU A1, ZERO, 5
502:                 	stdio_write("                                  ");
9D01CC4C  3C109D03   LUI S0, -25341
9D01CC50  0F407196   JAL stdio_write
9D01CC54  26049E30   ADDIU A0, S0, -25040
503:                 	video_set_color(MENU_ENTRY_FG,MENU_ENTRY_BG);
9D01CC58  2404000F   ADDIU A0, ZERO, 15
9D01CC5C  0F406B12   JAL .LFB8, .LFE58, video_set_color
9D01CC60  24050009   ADDIU A1, ZERO, 9
504:                 	video_gotoxy(3,6);
9D01CC64  24040003   ADDIU A0, ZERO, 3
9D01CC68  0F406BAF   JAL video_gotoxy
9D01CC6C  24050006   ADDIU A1, ZERO, 6
505:                 	stdio_write("                                  ");
9D01CC70  0F407196   JAL stdio_write
9D01CC74  26049E30   ADDIU A0, S0, -25040
506:                 	video_gotoxy(3,7);
9D01CC78  24040003   ADDIU A0, ZERO, 3
9D01CC7C  0F406BAF   JAL video_gotoxy
9D01CC80  24050007   ADDIU A1, ZERO, 7
507:                 	stdio_write("                                  ");
9D01CC84  0F407196   JAL stdio_write
9D01CC88  26049E30   ADDIU A0, S0, -25040
508:                 	video_gotoxy(3,8);
9D01CC8C  24040003   ADDIU A0, ZERO, 3
9D01CC90  0F406BAF   JAL video_gotoxy
9D01CC94  24050008   ADDIU A1, ZERO, 8
509:                 	stdio_write("                                  ");
9D01CC98  0F407196   JAL stdio_write
9D01CC9C  26049E30   ADDIU A0, S0, -25040
510:                 	video_gotoxy(3,9);
9D01CCA0  24040003   ADDIU A0, ZERO, 3
9D01CCA4  0F406BAF   JAL video_gotoxy
9D01CCA8  24050009   ADDIU A1, ZERO, 9
511:                 	stdio_write("                                  ");
9D01CCAC  0F407196   JAL stdio_write
9D01CCB0  26049E30   ADDIU A0, S0, -25040
512:                 	video_gotoxy(3,10);
9D01CCB4  24040003   ADDIU A0, ZERO, 3
9D01CCB8  0F406BAF   JAL video_gotoxy
9D01CCBC  2405000A   ADDIU A1, ZERO, 10
513:                 	stdio_write("                                  ");
9D01CCC0  0F407196   JAL stdio_write
9D01CCC4  26049E30   ADDIU A0, S0, -25040
514:                 	video_gotoxy(3,11);
9D01CCC8  24040003   ADDIU A0, ZERO, 3
9D01CCCC  0F406BAF   JAL video_gotoxy
9D01CCD0  2405000B   ADDIU A1, ZERO, 11
515:                 	stdio_write("                                  ");
9D01CCD4  0F407196   JAL stdio_write
9D01CCD8  26049E30   ADDIU A0, S0, -25040
516:                 	
517:                 	//Draw frame
518:                 	video_set_color(MENU_FRAME_FG,MENU_FRAME_BG);
9D01CCDC  2404000C   ADDIU A0, ZERO, 12
9D01CCE0  0F406B12   JAL .LFB8, .LFE58, video_set_color
9D01CCE4  00002821   ADDU A1, ZERO, ZERO
519:                 	fancyframe();
9D01CCE8  0F4072BE   JAL fancyframe
9D01CCEC  00000000   NOP
520:                 	
521:                 	//Print menu text
522:                 	video_set_color(MENU_BANNER_FG,MENU_BANNER_BG);
9D01CCF0  00002021   ADDU A0, ZERO, ZERO
9D01CCF4  0F406B12   JAL .LFB8, .LFE58, video_set_color
9D01CCF8  2405000F   ADDIU A1, ZERO, 15
523:                 	video_gotoxy(TEXT_LEFT,2);
9D01CCFC  24040004   ADDIU A0, ZERO, 4
9D01CD00  0F406BAF   JAL video_gotoxy
9D01CD04  24050002   ADDIU A1, ZERO, 2
524:                 	stdio_write("Hackaday Belgrade Conference");
9D01CD08  3C049D03   LUI A0, -25341
9D01CD0C  0F407196   JAL stdio_write
9D01CD10  24849E54   ADDIU A0, A0, -25004
525:                 	video_gotoxy(TEXT_LEFT,5);
9D01CD14  24040004   ADDIU A0, ZERO, 4
9D01CD18  0F406BAF   JAL video_gotoxy
9D01CD1C  24050005   ADDIU A1, ZERO, 5
526:                 	video_set_color(MENU_HEADER_FG,MENU_HEADER_BG);
9D01CD20  2404000F   ADDIU A0, ZERO, 15
9D01CD24  0F406B12   JAL .LFB8, .LFE58, video_set_color
9D01CD28  24050008   ADDIU A1, ZERO, 8
527:                 	stdio_write("Type a command and hit ENTER");
9D01CD2C  3C049D03   LUI A0, -25341
9D01CD30  0F407196   JAL stdio_write
9D01CD34  24849E74   ADDIU A0, A0, -24972
528:                 	video_gotoxy(TEXT_LEFT,6);
9D01CD38  24040004   ADDIU A0, ZERO, 4
9D01CD3C  0F406BAF   JAL video_gotoxy
9D01CD40  24050006   ADDIU A1, ZERO, 6
529:                 	video_set_color(MENU_ENTRY_FG,MENU_ENTRY_BG);
9D01CD44  2404000F   ADDIU A0, ZERO, 15
9D01CD48  0F406B12   JAL .LFB8, .LFE58, video_set_color
9D01CD4C  24050009   ADDIU A1, ZERO, 9
530:                 	stdio_write("1 - Hackaday BASIC");
9D01CD50  3C049D03   LUI A0, -25341
9D01CD54  0F407196   JAL stdio_write
9D01CD58  24849E94   ADDIU A0, A0, -24940
531:                 	video_gotoxy(TEXT_LEFT,7);
9D01CD5C  24040004   ADDIU A0, ZERO, 4
9D01CD60  0F406BAF   JAL video_gotoxy
9D01CD64  24050007   ADDIU A1, ZERO, 7
532:                 	stdio_write("2 - CP/M @ Z80");
9D01CD68  3C049D03   LUI A0, -25341
9D01CD6C  0F407196   JAL stdio_write
9D01CD70  24849EA8   ADDIU A0, A0, -24920
533:                 	video_gotoxy(TEXT_LEFT,8);
9D01CD74  24040004   ADDIU A0, ZERO, 4
9D01CD78  0F406BAF   JAL video_gotoxy
9D01CD7C  24050008   ADDIU A1, ZERO, 8
534:                 	stdio_write("3 - Tiny Basic @ 8080");
9D01CD80  3C049D03   LUI A0, -25341
9D01CD84  0F407196   JAL stdio_write
9D01CD88  24849EB8   ADDIU A0, A0, -24904
535:                 	video_gotoxy(TEXT_LEFT,9);
9D01CD8C  24040004   ADDIU A0, ZERO, 4
9D01CD90  0F406BAF   JAL video_gotoxy
9D01CD94  24050009   ADDIU A1, ZERO, 9
536:                 	stdio_write("4 - Play Badgetris!");
9D01CD98  3C049D03   LUI A0, -25341
9D01CD9C  0F407196   JAL stdio_write
9D01CDA0  24849ED0   ADDIU A0, A0, -24880
537:                 	video_gotoxy(TEXT_LEFT,10);
9D01CDA4  24040004   ADDIU A0, ZERO, 4
9D01CDA8  0F406BAF   JAL video_gotoxy
9D01CDAC  2405000A   ADDIU A1, ZERO, 10
538:                 	stdio_write("5 - Zork @ CP/M @ Z80");
9D01CDB0  3C049D03   LUI A0, -25341
9D01CDB4  0F407196   JAL stdio_write
9D01CDB8  24849EE4   ADDIU A0, A0, -24860
539:                 	video_gotoxy(TEXT_LEFT,11);
9D01CDBC  24040004   ADDIU A0, ZERO, 4
9D01CDC0  0F406BAF   JAL video_gotoxy
9D01CDC4  2405000B   ADDIU A1, ZERO, 11
540:                 	stdio_write("6 - User Program");
9D01CDC8  3C049D03   LUI A0, -25341
9D01CDCC  0F407196   JAL stdio_write
9D01CDD0  24849EFC   ADDIU A0, A0, -24836
541:                 	
542:                 	show_version();
9D01CDD4  0F407270   JAL show_version
9D01CDD8  00000000   NOP
543:                 	clear_prompt();
9D01CDDC  0F407281   JAL clear_prompt
9D01CDE0  00000000   NOP
544:                 	}
9D01CDE4  8FBF0014   LW RA, 20(SP)
9D01CDE8  8FB00010   LW S0, 16(SP)
9D01CDEC  03E00008   JR RA
9D01CDF0  27BD0018   ADDIU SP, SP, 24
545:                 
546:                 void show_version(void)
547:                 	{
9D01C9C0  27BDFFE8   ADDIU SP, SP, -24
9D01C9C4  AFBF0014   SW RA, 20(SP)
548:                 	video_set_color(MENU_VERSION_FG,MENU_DEFAULT_BG);
9D01C9C8  24040008   ADDIU A0, ZERO, 8
9D01C9CC  0F406B12   JAL .LFB8, .LFE58, video_set_color
9D01C9D0  00002821   ADDU A1, ZERO, ZERO
549:                 	video_gotoxy(VERSION_X,VERSION_Y);
9D01C9D4  24040021   ADDIU A0, ZERO, 33
9D01C9D8  0F406BAF   JAL video_gotoxy
9D01C9DC  24050012   ADDIU A1, ZERO, 18
550:                 	stdio_write("v");
9D01C9E0  3C049D03   LUI A0, -25341
9D01C9E4  0F407196   JAL stdio_write
9D01C9E8  24849E24   ADDIU A0, A0, -25052
551:                 	stdio_write((int8_t *)get_firmware_string());
9D01C9EC  3C049D03   LUI A0, -25341
9D01C9F0  0F407196   JAL stdio_write
9D01C9F4  24849D38   ADDIU A0, A0, -25288
552:                 	}
9D01C9F8  8FBF0014   LW RA, 20(SP)
9D01C9FC  03E00008   JR RA
9D01CA00  27BD0018   ADDIU SP, SP, 24
553:                 
554:                 void fancyframe(void)
555:                 	{
9D01CAF8  27BDFFE0   ADDIU SP, SP, -32
9D01CAFC  AFBF001C   SW RA, 28(SP)
9D01CB00  AFB20018   SW S2, 24(SP)
9D01CB04  AFB10014   SW S1, 20(SP)
9D01CB08  AFB00010   SW S0, 16(SP)
556:                 	uint16_t i;
557:                 	video_gotoxy(0,0);
9D01CB0C  00002021   ADDU A0, ZERO, ZERO
9D01CB10  0F406BAF   JAL video_gotoxy
9D01CB14  00002821   ADDU A1, ZERO, ZERO
558:                 	stdio_c(201);
9D01CB18  0F40729E   JAL stdio_c
9D01CB1C  240400C9   ADDIU A0, ZERO, 201
9D01CB20  24100026   ADDIU S0, ZERO, 38
559:                 	for (i=0; i<38; i++) stdio_c(205);
9D01CB24  0F40729E   JAL stdio_c
9D01CB28  240400CD   ADDIU A0, ZERO, 205
9D01CB2C  2610FFFF   ADDIU S0, S0, -1
9D01CB30  3210FFFF   ANDI S0, S0, -1
9D01CB34  1600FFFB   BNE S0, ZERO, 0x9D01CB24
9D01CB38  00000000   NOP
560:                 	stdio_c(187);
9D01CB3C  0F40729E   JAL stdio_c
9D01CB40  240400BB   ADDIU A0, ZERO, 187
561:                 	video_gotoxy(0,39);
9D01CB44  00002021   ADDU A0, ZERO, ZERO
9D01CB48  0F406BAF   JAL video_gotoxy
9D01CB4C  24050027   ADDIU A1, ZERO, 39
562:                 	stdio_c(200);
9D01CB50  0F40729E   JAL stdio_c
9D01CB54  240400C8   ADDIU A0, ZERO, 200
9D01CB58  24100026   ADDIU S0, ZERO, 38
563:                 	for (i=0; i<38; i++) stdio_c(205);
9D01CB5C  0F40729E   JAL stdio_c
9D01CB60  240400CD   ADDIU A0, ZERO, 205
9D01CB64  2610FFFF   ADDIU S0, S0, -1
9D01CB68  3210FFFF   ANDI S0, S0, -1
9D01CB6C  1600FFFB   BNE S0, ZERO, 0x9D01CB5C
9D01CB70  00000000   NOP
564:                 	stdio_c(188);
9D01CB74  0F40729E   JAL stdio_c
9D01CB78  240400BC   ADDIU A0, ZERO, 188
565:                 	for (i=1; i<19; i++)
9D01CB7C  24100001   ADDIU S0, ZERO, 1
9D01CB80  24120013   ADDIU S2, ZERO, 19
9D01CBB0  26100001   ADDIU S0, S0, 1
9D01CBB4  3210FFFF   ANDI S0, S0, -1
9D01CBB8  1612FFF3   BNE S0, S2, 0x9D01CB88
9D01CBBC  7C108C20   SEB S1, S0
566:                 		{
567:                 		video_gotoxy(0,i);
9D01CB84  7C108C20   SEB S1, S0
9D01CB88  00002021   ADDU A0, ZERO, ZERO
9D01CB8C  0F406BAF   JAL video_gotoxy
9D01CB90  02202821   ADDU A1, S1, ZERO
568:                 		stdio_c(186);
9D01CB94  0F40729E   JAL stdio_c
9D01CB98  240400BA   ADDIU A0, ZERO, 186
569:                 		video_gotoxy(39,i);
9D01CB9C  24040027   ADDIU A0, ZERO, 39
9D01CBA0  0F406BAF   JAL video_gotoxy
9D01CBA4  02202821   ADDU A1, S1, ZERO
570:                 		stdio_c(186);
9D01CBA8  0F40729E   JAL stdio_c
9D01CBAC  240400BA   ADDIU A0, ZERO, 186
571:                 		}
572:                 	}
9D01CBC0  8FBF001C   LW RA, 28(SP)
9D01CBC4  8FB20018   LW S2, 24(SP)
9D01CBC8  8FB10014   LW S1, 20(SP)
9D01CBCC  8FB00010   LW S0, 16(SP)
9D01CBD0  03E00008   JR RA
9D01CBD4  27BD0020   ADDIU SP, SP, 32
573:                 
574:                 void clear_prompt(void)
575:                 	{
9D01CA04  27BDFFE0   ADDIU SP, SP, -32
9D01CA08  AFBF001C   SW RA, 28(SP)
9D01CA0C  AFB10018   SW S1, 24(SP)
9D01CA10  AFB00014   SW S0, 20(SP)
576:                 	//Clear prompt area
577:                 	video_gotoxy(TEXT_LEFT,PROMPT_Y);
9D01CA14  24040004   ADDIU A0, ZERO, 4
9D01CA18  0F406BAF   JAL video_gotoxy
9D01CA1C  2405000F   ADDIU A1, ZERO, 15
9D01CA20  24100023   ADDIU S0, ZERO, 35
578:                 	int16_t i;
579:                 	for (i=TEXT_LEFT; i<39; i++) stdio_write(" ");
9D01CA24  3C119D03   LUI S1, -25341
9D01CA28  26319E28   ADDIU S1, S1, -25048
9D01CA2C  0F407196   JAL stdio_write
9D01CA30  02202021   ADDU A0, S1, ZERO
9D01CA34  2610FFFF   ADDIU S0, S0, -1
9D01CA38  3210FFFF   ANDI S0, S0, -1
9D01CA3C  1600FFFB   BNE S0, ZERO, 0x9D01CA2C
9D01CA40  2404000F   ADDIU A0, ZERO, 15
580:                 	
581:                 	video_set_color(MENU_DEFAULT_FG, MENU_DEFAULT_BG);
9D01CA44  0F406B12   JAL .LFB8, .LFE58, video_set_color
9D01CA48  00002821   ADDU A1, ZERO, ZERO
582:                 	video_gotoxy(TEXT_LEFT,PROMPT_Y);
9D01CA4C  24040004   ADDIU A0, ZERO, 4
9D01CA50  0F406BAF   JAL video_gotoxy
9D01CA54  2405000F   ADDIU A1, ZERO, 15
583:                 	stdio_write("> ");
9D01CA58  3C049D03   LUI A0, -25341
9D01CA5C  0F407196   JAL stdio_write
9D01CA60  24849E2C   ADDIU A0, A0, -25044
584:                 	}
9D01CA64  8FBF001C   LW RA, 28(SP)
9D01CA68  8FB10018   LW S1, 24(SP)
9D01CA6C  8FB00014   LW S0, 20(SP)
9D01CA70  03E00008   JR RA
9D01CA74  27BD0020   ADDIU SP, SP, 32
585:                 
586:                 void show_wrencher(void)
587:                 	{
9D01D0FC  27BDFFE0   ADDIU SP, SP, -32
9D01D100  AFBF001C   SW RA, 28(SP)
9D01D104  AFB10018   SW S1, 24(SP)
588:                 	int8_t i;
589:                 	video_clrscr();
9D01D108  0F406C60   JAL video_clrscr
9D01D10C  AFB00014   SW S0, 20(SP)
590:                 	video_set_color(2,0);
9D01D110  24040002   ADDIU A0, ZERO, 2
9D01D114  0F406B12   JAL .LFB8, .LFE58, video_set_color
9D01D118  00002821   ADDU A1, ZERO, ZERO
591:                 	video_gotoxy(0,1);
9D01D11C  00002021   ADDU A0, ZERO, ZERO
9D01D120  0F406BAF   JAL video_gotoxy
9D01D124  24050001   ADDIU A1, ZERO, 1
9D01D128  3C109D03   LUI S0, -25341
9D01D12C  2610A254   ADDIU S0, S0, -23980
9D01D130  261102E2   ADDIU S1, S0, 738
592:                 	for (i=0; i<18; i++)
9D01D140  1611FFFC   BNE S0, S1, 0x9D01D134
9D01D144  00000000   NOP
593:                 		{
594:                 		stdio_write((int8_t *)wrencher[i]);
9D01D134  0F407196   JAL stdio_write
9D01D138  02002021   ADDU A0, S0, ZERO
9D01D13C  26100029   ADDIU S0, S0, 41
595:                 		}
596:                 	wait_ms(200);
9D01D148  0F407EB3   JAL wait_ms
9D01D14C  240400C8   ADDIU A0, ZERO, 200
597:                 	i = 0;
9D01D150  00002021   ADDU A0, ZERO, ZERO
598:                 	uint8_t loopbreak = 0;
599:                 	while(1)
600:                 		{
601:                 		loopbreak = playriff(i++);
9D01D154  24900001   ADDIU S0, A0, 1
9D01D158  7C108420   SEB S0, S0
9D01D15C  0F4073F9   JAL playriff
9D01D160  308400FF   ANDI A0, A0, 255
9D01D16C  0004800A   MOVZ S0, ZERO, A0
9D01D170  0B407455   J 0x9D01D154
9D01D174  02002021   ADDU A0, S0, ZERO
602:                 		if (loopbreak) break;
9D01D164  14400004   BNE V0, ZERO, 0x9D01D178
9D01D168  2A040004   SLTI A0, S0, 4
603:                 		if (i > 3) i = 0;
604:                 		}
605:                 	showmenu();
9D01D178  0F4072F6   JAL showmenu
9D01D17C  00000000   NOP
606:                 	}
9D01D180  8FBF001C   LW RA, 28(SP)
9D01D184  8FB10018   LW S1, 24(SP)
9D01D188  8FB00014   LW S0, 20(SP)
9D01D18C  03E00008   JR RA
9D01D190  27BD0020   ADDIU SP, SP, 32
607:                 
608:                 uint8_t playriff(uint8_t raisetop)
609:                 	{
9D01CFE4  27BDFFA0   ADDIU SP, SP, -96
9D01CFE8  AFBF005C   SW RA, 92(SP)
9D01CFEC  AFB00058   SW S0, 88(SP)
9D01CFF0  00808021   ADDU S0, A0, ZERO
610:                 	const uint16_t riffdelays[3] = {78,236,393};
9D01CFF4  3C029D03   LUI V0, -25341
9D01CFF8  24439F10   ADDIU V1, V0, -24816
9D01CFFC  88640003   LWL A0, 3(V1)
9D01D000  98449F10   LWR A0, -24816(V0)
9D01D004  AFA40010   SW A0, 16(SP)
9D01D008  94620004   LHU V0, 4(V1)
9D01D00C  A7A20014   SH V0, 20(SP)
611:                 	const uint8_t riff[14][4] =
9D01D010  3C029D03   LUI V0, -25341
9D01D014  24429F18   ADDIU V0, V0, -24808
9D01D018  27A30018   ADDIU V1, SP, 24
9D01D01C  24440030   ADDIU A0, V0, 48
9D01D020  88480003   LWL T0, 3(V0)
9D01D024  98480000   LWR T0, 0(V0)
9D01D028  88470007   LWL A3, 7(V0)
9D01D02C  98470004   LWR A3, 4(V0)
9D01D030  8846000B   LWL A2, 11(V0)
9D01D034  98460008   LWR A2, 8(V0)
9D01D038  8845000F   LWL A1, 15(V0)
9D01D03C  9845000C   LWR A1, 12(V0)
9D01D040  AC680000   SW T0, 0(V1)
9D01D044  AC670004   SW A3, 4(V1)
9D01D048  AC660008   SW A2, 8(V1)
9D01D04C  AC65000C   SW A1, 12(V1)
9D01D050  24420010   ADDIU V0, V0, 16
9D01D054  1444FFF2   BNE V0, A0, 0x9D01D020
9D01D058  24630010   ADDIU V1, V1, 16
9D01D05C  88440003   LWL A0, 3(V0)
9D01D060  98440000   LWR A0, 0(V0)
9D01D064  88450007   LWL A1, 7(V0)
9D01D068  98450004   LWR A1, 4(V0)
9D01D06C  AC640000   SW A0, 0(V1)
9D01D070  AC650004   SW A1, 4(V1)
612:                 		{
613:                 			{0,62,69,0},
614:                 			{0,0,0,0},
615:                 			{0,62,69,0},
616:                 			{0,0,0,0},
617:                 			{0,62,69,1},
618:                 			{0,0,0,2},
619:                 			{0,62,69,0},
620:                 			{0,0,0,0},
621:                 			{0,62,69,0},
622:                 			{0,0,0,0},
623:                 			{0,62,69,1},
624:                 			{0,0,0,0},
625:                 			{50,0,0,1},
626:                 			{0,0,0,0}
627:                 		};
628:                 	uint8_t i;
629:                 	for (i=0; i<14; i++)
9D01D074  A3A00050   SB ZERO, 80(SP)
9D01D078  00001021   ADDU V0, ZERO, ZERO
9D01D0C8  93A20050   LBU V0, 80(SP)
9D01D0CC  24420001   ADDIU V0, V0, 1
9D01D0D0  304200FF   ANDI V0, V0, 255
9D01D0D4  2C43000E   SLTIU V1, V0, 14
9D01D0D8  1460FFE8   BNE V1, ZERO, .LBB4
9D01D0DC  A3A20050   SB V0, 80(SP)
630:                 		{
631:                 		uint8_t top = 0;
632:                 		if (riff[i][2] != 0)
9D01D07C  00402021   ADDU A0, V0, ZERO
9D01D080  00021080   SLL V0, V0, 2
9D01D084  27A30010   ADDIU V1, SP, 16
9D01D088  00621021   ADDU V0, V1, V0
9D01D08C  9043000A   LBU V1, 10(V0)
9D01D090  10600003   BEQ V1, ZERO, 0x9D01D0A0
9D01D094  00003021   ADDU A2, ZERO, ZERO
633:                 			{
634:                 			top = riff[i][2] + raisetop;
9D01D098  02033021   ADDU A2, S0, V1
9D01D09C  30C600FF   ANDI A2, A2, 255
635:                 			}
636:                 		sound_play_notes(riff[i][0],riff[i][1],top,riffdelays[riff[i][3]]);	
9D01D0A0  00041080   SLL V0, A0, 2
9D01D0A4  27A40010   ADDIU A0, SP, 16
9D01D0A8  00821021   ADDU V0, A0, V0
9D01D0AC  9043000B   LBU V1, 11(V0)
9D01D0B0  00031840   SLL V1, V1, 1
9D01D0B4  00831821   ADDU V1, A0, V1
9D01D0B8  90440008   LBU A0, 8(V0)
9D01D0BC  90450009   LBU A1, 9(V0)
9D01D0C0  0F407EC4   JAL sound_play_notes
9D01D0C4  94670000   LHU A3, 0(V1)
637:                 		}
638:                 		if (stdio_get(&i) != 0) { return 1; }
9D01D0E0  0F4073D3   JAL stdio_get
9D01D0E4  27A40050   ADDIU A0, SP, 80
639:                 	return 0;
640:                 	}
9D01D0E8  0002102B   SLTU V0, ZERO, V0
9D01D0EC  8FBF005C   LW RA, 92(SP)
9D01D0F0  8FB00058   LW S0, 88(SP)
9D01D0F4  03E00008   JR RA
9D01D0F8  27BD0060   ADDIU SP, SP, 96
641:                 
642:                 
643:                 //housekeeping stuff. call this function often
644:                 void loop_badge(void)
645:                 	{
9D01C0F8  27BDFFE0   ADDIU SP, SP, -32
9D01C0FC  AFBF001C   SW RA, 28(SP)
646:                 	volatile uint16_t dbg;
647:                 	static uint8_t brk_is_pressed;
648:                 	dbg = PORTD;
9D01C100  3C02BF88   LUI V0, -16504
9D01C104  8C426320   LW V0, 25376(V0)
9D01C108  3042FFFF   ANDI V0, V0, -1
9D01C10C  A7A20010   SH V0, 16(SP)
649:                 	if (K_PWR==0)
9D01C110  3C02BF88   LUI V0, -16504
9D01C114  8C436620   LW V1, 26144(V0)
650:                 		{
651:                 //		while (K_PWR==0);
652:                 //		wait_ms(100);
653:                 //		hw_sleep();
654:                 //		wait_ms(30);
655:                 //		while (K_PWR==0);
656:                 //		wait_ms(300);
657:                 		}
658:                 	if (KEY_BRK==0)
9D01C118  8C426620   LW V0, 26144(V0)
9D01C11C  30420200   ANDI V0, V0, 512
9D01C120  54400023   BNEL V0, ZERO, 0x9D01C1B0
9D01C124  A3808194   SB ZERO, -32364(GP)
659:                 		{
660:                 		if ((K_SHIFTL==0)&(K_SHIFTR==0)&(brk_is_pressed==9))
9D01C128  3C02BF88   LUI V0, -16504
9D01C12C  8C436320   LW V1, 25376(V0)
9D01C130  8C426320   LW V0, 25376(V0)
9D01C134  38630400   XORI V1, V1, 1024
9D01C138  7C630280   EXT V1, V1, 10, 1
9D01C13C  38420200   XORI V0, V0, 512
9D01C140  7C420240   EXT V0, V0, 9, 1
9D01C144  00621024   AND V0, V1, V0
9D01C148  10400012   BEQ V0, ZERO, 0x9D01C194
9D01C14C  24020001   ADDIU V0, ZERO, 1
9D01C150  93828194   LBU V0, -32364(GP)
9D01C154  38420009   XORI V0, V0, 9
9D01C158  1440000E   BNE V0, ZERO, 0x9D01C194
9D01C15C  24020001   ADDIU V0, ZERO, 1
661:                 			{
662:                 			serial_flush();
9D01C160  0F407FF0   JAL serial_flush
9D01C164  00000000   NOP
663:                 			if (stdio_src == STDIO_TTY1)
9D01C168  938381CD   LBU V1, -32307(GP)
9D01C16C  7C031C20   SEB V1, V1
9D01C170  24020001   ADDIU V0, ZERO, 1
9D01C174  54620004   BNEL V1, V0, 0x9D01C188
9D01C178  24020001   ADDIU V0, ZERO, 1
664:                 				stdio_src = STDIO_LOCAL;
9D01C17C  A38081CD   SB ZERO, -32307(GP)
9D01C180  0B407067   J 0x9D01C19C
9D01C184  93828194   LBU V0, -32364(GP)
665:                 			else
666:                 				stdio_src = STDIO_TTY1;
9D01C188  A38281CD   SB V0, -32307(GP)
667:                 			}
668:                 		else
669:                 			brk_key = 1;
9D01C194  A38281D9   SB V0, -32295(GP)
670:                 		if (brk_is_pressed<10) brk_is_pressed++;
9D01C18C  0B407067   J 0x9D01C19C
9D01C190  93828194   LBU V0, -32364(GP)
9D01C198  93828194   LBU V0, -32364(GP)
9D01C19C  2C43000A   SLTIU V1, V0, 10
9D01C1A0  10600004   BEQ V1, ZERO, 0x9D01C1B4
9D01C1A4  8FBF001C   LW RA, 28(SP)
9D01C1A8  24420001   ADDIU V0, V0, 1
9D01C1AC  A3828194   SB V0, -32364(GP)
671:                 		}
672:                 	else
673:                 		brk_is_pressed = 0;
674:                 	}
9D01C1B0  8FBF001C   LW RA, 28(SP)
9D01C1B4  03E00008   JR RA
9D01C1B8  27BD0020   ADDIU SP, SP, 32
675:                 
676:                 //B_BDG004
677:                 void enable_display_scanning(uint8_t onoff)
678:                 	{
679:                 	//Turns vt100 scanning on or off
680:                 	if (onoff) handle_display = 1;
9D01C1BC  10800004   BEQ A0, ZERO, 0x9D01C1D0
9D01C1C0  24020001   ADDIU V0, ZERO, 1
9D01C1C4  A3828195   SB V0, -32363(GP)
9D01C1C8  03E00008   JR RA
9D01C1CC  00000000   NOP
681:                 	else handle_display = 0;
9D01C1D0  A3808195   SB ZERO, -32363(GP)
9D01C1D4  03E00008   JR RA
9D01C1D8  00000000   NOP
682:                 	}
683:                 
684:                 uint32_t millis(void)
685:                 	{
686:                 	return ticks;
9D01C1DC  8F8281DC   LW V0, -32292(GP)
687:                 	}
9D01C1E0  03E00008   JR RA
9D01C1E4  00000000   NOP
688:                 
689:                 //void init_8080_basic (void)
690:                 //	{
691:                 //	video_set_color(15,0);
692:                 //	for (i=0;i<2048;i++) ram[i] = b2_rom[i];
693:                 //	for (i=0;i<30;i++) ram[i+0x1000] = ram_init[i];
694:                 //	wrk_ram	= PC = STACK = ram;
695:                 //	init_io(IO_BASIC_MODE);
696:                 //	}
697:                 //
698:                 //void loop_8080_basic (void)
699:                 //	{
700:                 //	cpu_error = NONE;
701:                 //	cpu();	
702:                 //	}
703:                 
704:                 //void init_z80_cpm (void)
705:                 //	{
706:                 //	video_set_color(15,0);
707:                 //#ifdef	USE_RAM_IMAGE	
708:                 //	for (i=0;i<65536;i++) ram[i] = ram_image[i];
709:                 //#endif	
710:                 //#ifdef	USE_RAMDISK
711:                 //	for (i=0;i<RAMDISK_SIZE;i++) ram_disk[i] = 0xE5;
712:                 //#endif
713:                 //	wrk_ram	= PC = STACK = ram;
714:                 //	init_io(IO_CPM_MODE);
715:                 //	}
716:                 
717:                 //void loop_z80_cpm (void)
718:                 //	{
719:                 //	cpu_error = NONE;
720:                 //	cpu();	
721:                 //	}
722:                 
723:                 //B_BAS005
724:                 //void init_basic (void)
725:                 //	{
726:                 //	stdio_write("BASIC interpreter\n");
727:                 //	prompt = 1;
728:                 //	brk_key = 0;
729:                 //	cmd_line_pointer=0;
730:                 //	cmd_line_buff[0] = 0;
731:                 //	video_set_color(15,0);
732:                 //	}
733:                 ////B_BAS006
734:                 //void loop_basic (void)
735:                 //	{
736:                 //	if (prompt==1)
737:                 //	    {
738:                 //	    stdio_write(">");	
739:                 //	    prompt = 0;
740:                 //	    }
741:                 //	get_stat = stdio_get(&char_out);
742:                 //	if (get_stat!=0)
743:                 //	    {
744:                 //	    stdio_c(char_out);	
745:                 //	    if (char_out==NEWLINE) 
746:                 //			{
747:                 //			cmd_line_buff[cmd_line_pointer] = 0;
748:                 //			cmd_exec (cmd_line_buff);
749:                 //			cmd_line_pointer=0;
750:                 //			cmd_line_buff[0] = 0;
751:                 //			prompt = 1;			
752:                 //			}
753:                 //	    else
754:                 //			{
755:                 //			if ((char_out>=' ')&(char_out<0x7F)) cmd_line_buff[cmd_line_pointer++] = char_out;
756:                 //			else if (char_out==BACKSPACE)
757:                 //				{
758:                 //				if (cmd_line_pointer>0) 
759:                 //					cmd_line_buff[--cmd_line_pointer]=0;
760:                 //				}
761:                 //
762:                 //			}
763:                 //	    }	
764:                 //	}
765:                 
766:                 ////B_BDG007
767:                 //void init_userprog (void)
768:                 //{
769:                 //	user_program_init();
770:                 //}
771:                 //
772:                 ////B_BDG008
773:                 //void loop_userprog (void)
774:                 //{
775:                 //	user_program_loop();
776:                 //}
777:                 
778:                 void clr_buffer (void)
779:                 	{
780:                 	for (i=0; i<DISP_BUFFER_HIGH+1; i++)
9D01C1E8  00004021   ADDU T0, ZERO, ZERO
9D01C1EC  3C0BA000   LUI T3, -24576
9D01C1F0  256B1E5C   ADDIU T3, T3, 7772
9D01C1F4  3C0AA000   LUI T2, -24576
9D01C1F8  254A1B14   ADDIU T2, T2, 6932
9D01C204  24090348   ADDIU T1, ZERO, 840
9D01C208  00001021   ADDU V0, ZERO, ZERO
9D01C20C  01682821   ADDU A1, T3, T0
9D01C210  01482021   ADDU A0, T2, T0
9D01C214  00A21821   ADDU V1, A1, V0
9D01C230  1509FFF6   BNE T0, T1, 0x9D01C20C
9D01C234  00001021   ADDU V0, ZERO, ZERO
9D01C238  24020028   ADDIU V0, ZERO, 40
9D01C23C  AF8281C8   SW V0, -32312(GP)
9D01C240  24020015   ADDIU V0, ZERO, 21
9D01C244  03E00008   JR RA
9D01C248  AF8281D4   SW V0, -32300(GP)
781:                 		{
782:                 		for (j=0; j<DISP_BUFFER_WIDE; j++) 
9D01C200  24060028   ADDIU A2, ZERO, 40
9D01C224  1446FFFB   BNE V0, A2, 0x9D01C214
9D01C228  A0670000   SB A3, 0(V1)
9D01C22C  25080028   ADDIU T0, T0, 40
783:                 			{
784:                 			disp_buffer[i][j] = 0;		//Blank the buffer
9D01C218  A0600000   SB ZERO, 0(V1)
9D01C21C  00821821   ADDU V1, A0, V0
9D01C220  24420001   ADDIU V0, V0, 1
785:                 			color_buffer[i][j] = 0x0F;	//White text on black background
9D01C1FC  2407000F   ADDIU A3, ZERO, 15
9D01C200  24060028   ADDIU A2, ZERO, 40
9D01C204  24090348   ADDIU T1, ZERO, 840
9D01C208  00001021   ADDU V0, ZERO, ZERO
9D01C20C  01682821   ADDU A1, T3, T0
9D01C210  01482021   ADDU A0, T2, T0
9D01C214  00A21821   ADDU V1, A1, V0
9D01C218  A0600000   SB ZERO, 0(V1)
9D01C21C  00821821   ADDU V1, A0, V0
9D01C220  24420001   ADDIU V0, V0, 1
9D01C224  1446FFFB   BNE V0, A2, 0x9D01C214
9D01C228  A0670000   SB A3, 0(V1)
9D01C22C  25080028   ADDIU T0, T0, 40
9D01C230  1509FFF6   BNE T0, T1, 0x9D01C20C
9D01C234  00001021   ADDU V0, ZERO, ZERO
9D01C238  24020028   ADDIU V0, ZERO, 40
9D01C23C  AF8281C8   SW V0, -32312(GP)
9D01C240  24020015   ADDIU V0, ZERO, 21
9D01C244  03E00008   JR RA
9D01C248  AF8281D4   SW V0, -32300(GP)
786:                 			}
787:                 		}
788:                 	}
789:                 
790:                 const char* get_firmware_string(void) {
791:                 	return FIRMWARE_VERSION;
792:                 	}
9D01C24C  3C029D03   LUI V0, -25341
9D01C250  03E00008   JR RA
9D01C254  24429D38   ADDIU V0, V0, -25288
793:                 
794:                 uint16_t get_free_mem(uint8_t * prog, uint16_t max_mem)
795:                 	{
9D01C258  27BDFFE8   ADDIU SP, SP, -24
9D01C25C  AFBF0014   SW RA, 20(SP)
9D01C260  AFB00010   SW S0, 16(SP)
796:                 	uint16_t prog_len;
797:                 	prog_len = strlen(prog);
9D01C264  0F40DBFE   JAL strlen
9D01C268  00A08021   ADDU S0, A1, ZERO
798:                 	return (max_mem-prog_len);
9D01C26C  02021023   SUBU V0, S0, V0
799:                 	}
9D01C270  3042FFFF   ANDI V0, V0, -1
9D01C274  8FBF0014   LW RA, 20(SP)
9D01C278  8FB00010   LW S0, 16(SP)
9D01C27C  03E00008   JR RA
9D01C280  27BD0018   ADDIU SP, SP, 24
800:                 
801:                 //B_BAS008
802:                 uint8_t add_prog_line (int8_t * line, int8_t * prog, int16_t linenum)
803:                     {
9D01C284  27BDFF58   ADDIU SP, SP, -168
9D01C288  AFBF00A4   SW RA, 164(SP)
9D01C28C  AFBE00A0   SW FP, 160(SP)
9D01C290  AFB7009C   SW S7, 156(SP)
9D01C294  AFB60098   SW S6, 152(SP)
9D01C298  AFB50094   SW S5, 148(SP)
9D01C29C  AFB40090   SW S4, 144(SP)
9D01C2A0  AFB3008C   SW S3, 140(SP)
9D01C2A4  AFB20088   SW S2, 136(SP)
9D01C2A8  AFB10084   SW S1, 132(SP)
9D01C2AC  AFB00080   SW S0, 128(SP)
9D01C2B0  0080F021   ADDU FP, A0, ZERO
9D01C2B4  00A0B021   ADDU S6, A1, ZERO
9D01C2B8  00C0A821   ADDU S5, A2, ZERO
804:                     uint8_t * prog_ptr=prog, * prog_ptr_prev, * prog_ptr_dest;
805:                     int16_t linenum_now,linenum_prev=0,line_exp_len,cnt, prog_len;
806:                     int8_t line_rest[50],line_exp[50],ret;
807:                     sprintf(line_exp,"%d %s\n",linenum,line);
9D01C2BC  27A40048   ADDIU A0, SP, 72
9D01C2C0  3C059D03   LUI A1, -25341
9D01C2C4  24A59D40   ADDIU A1, A1, -25280
9D01C2C8  0F40EDE4   JAL _sprintf_cdnopuxX, _sprintf_cdnopsuxX
9D01C2CC  03C03821   ADDU A3, FP, ZERO
808:                     line_exp_len = strlen(line_exp);
9D01C2D0  0F40DBFE   JAL strlen
9D01C2D4  27A40048   ADDIU A0, SP, 72
9D01C2D8  7C02BE20   SEH S7, V0
809:                 	prog_len = strlen(prog);
9D01C2DC  0F40DBFE   JAL strlen
9D01C2E0  02C02021   ADDU A0, S6, ZERO
810:                 	if ((prog_len + line_exp_len)>BPROG_LEN) return 1;
9D01C2E4  7C021620   SEH V0, V0
9D01C2E8  00571821   ADDU V1, V0, S7
9D01C2EC  28634001   SLTI V1, V1, 16385
9D01C2F0  1060004D   BEQ V1, ZERO, 0x9D01C428
9D01C2F4  24020001   ADDIU V0, ZERO, 1
9D01C2F8  02C08021   ADDU S0, S6, ZERO
9D01C2FC  00009821   ADDU S3, ZERO, ZERO
811:                     while (1)
812:                 	{
813:                 	ret = sscanf(prog_ptr,"%d %[^\n]s",&linenum_now,line_rest);
9D01C300  3C129D03   LUI S2, -25341
9D01C304  26529D48   ADDIU S2, S2, -25272
9D01C310  02002021   ADDU A0, S0, ZERO
9D01C314  02402821   ADDU A1, S2, ZERO
9D01C318  27A60010   ADDIU A2, SP, 16
9D01C31C  0F40ED8F   JAL .Letext0, .LFE1, _sscanf_cdnopuxX
9D01C320  27A70014   ADDIU A3, SP, 20
9D01C324  7C021420   SEB V0, V0
814:                 	if (ret==2)
9D01C308  24110002   ADDIU S1, ZERO, 2
9D01C328  14510033   BNE V0, S1, 0x9D01C3F8
9D01C32C  00000000   NOP
815:                 	    {
816:                 	    if ((linenum>linenum_prev)&(linenum<linenum_now))
9D01C330  87A20010   LH V0, 16(SP)
9D01C334  02A2182A   SLT V1, S5, V0
9D01C338  10600010   BEQ V1, ZERO, 0x9D01C37C
9D01C33C  0275982A   SLT S3, S3, S5
9D01C340  1260000E   BEQ S3, ZERO, 0x9D01C37C
9D01C344  00000000   NOP
817:                 			{
818:                 			cnt = strlen(prog_ptr) +1;
9D01C348  0F40DBFE   JAL strlen
9D01C34C  02002021   ADDU A0, S0, ZERO
9D01C350  24420001   ADDIU V0, V0, 1
819:                 			prog_ptr_dest = prog_ptr + line_exp_len;
820:                 			memmove(prog_ptr_dest,prog_ptr,cnt);
9D01C354  02172021   ADDU A0, S0, S7
9D01C358  02002821   ADDU A1, S0, ZERO
9D01C35C  0F40EE34   JAL .Letext0, .LFE0, memmove
9D01C360  7C023620   SEH A2, V0
821:                 			memcpy(prog_ptr,line_exp,line_exp_len);
9D01C364  02002021   ADDU A0, S0, ZERO
9D01C368  27A50048   ADDIU A1, SP, 72
9D01C36C  0F40DBA4   JAL .Letext0, .LFE1, memcpy
9D01C370  02E03021   ADDU A2, S7, ZERO
822:                 			return 0;
9D01C374  0B40710A   J 0x9D01C428
9D01C378  00001021   ADDU V0, ZERO, ZERO
823:                 			}
824:                 	    if (linenum==linenum_now)
9D01C37C  16A20025   BNE S5, V0, 0x9D01C414
9D01C380  87B30010   LH S3, 16(SP)
825:                 			{
826:                 			prog_ptr_prev = prog_ptr;
827:                 			prog_ptr = strchr(prog_ptr,'\n')+1;
9D01C384  02002021   ADDU A0, S0, ZERO
9D01C388  0F40E513   JAL strchr
9D01C38C  2405000A   ADDIU A1, ZERO, 10
9D01C390  24510001   ADDIU S1, V0, 1
828:                 			cnt = strlen(prog_ptr)+1;
9D01C394  0F40DBFE   JAL strlen
9D01C398  02202021   ADDU A0, S1, ZERO
9D01C39C  24420001   ADDIU V0, V0, 1
829:                 			memmove(prog_ptr_prev,prog_ptr,cnt);
9D01C3A0  02002021   ADDU A0, S0, ZERO
9D01C3A4  02202821   ADDU A1, S1, ZERO
9D01C3A8  0F40EE34   JAL .Letext0, .LFE0, memmove
9D01C3AC  7C023620   SEH A2, V0
830:                 			if (strlen(line)>1)
9D01C3B0  0F40DBFE   JAL strlen
9D01C3B4  03C02021   ADDU A0, FP, ZERO
9D01C3B8  2C430002   SLTIU V1, V0, 2
9D01C3BC  1460001A   BNE V1, ZERO, 0x9D01C428
9D01C3C0  00001021   ADDU V0, ZERO, ZERO
831:                 				{
832:                 				prog_ptr = prog_ptr_prev;
833:                 				cnt = strlen(prog_ptr);
9D01C3C4  0F40DBFE   JAL strlen
9D01C3C8  02002021   ADDU A0, S0, ZERO
834:                 				prog_ptr_dest = prog_ptr + line_exp_len;
835:                 				memmove(prog_ptr_dest,prog_ptr,cnt+1);
9D01C3CC  7C021620   SEH V0, V0
9D01C3D0  02172021   ADDU A0, S0, S7
9D01C3D4  02002821   ADDU A1, S0, ZERO
9D01C3D8  0F40EE34   JAL .Letext0, .LFE0, memmove
9D01C3DC  24460001   ADDIU A2, V0, 1
836:                 				memcpy(prog_ptr,line_exp,line_exp_len);		
9D01C3E0  02002021   ADDU A0, S0, ZERO
9D01C3E4  27A50048   ADDIU A1, SP, 72
9D01C3E8  0F40DBA4   JAL .Letext0, .LFE1, memcpy
9D01C3EC  02E03021   ADDU A2, S7, ZERO
837:                 				}
838:                 			return 0;
9D01C3F0  0B40710A   J 0x9D01C428
9D01C3F4  00001021   ADDU V0, ZERO, ZERO
839:                 			}
840:                 	    }
841:                 	if (ret==-1)
9D01C30C  2414FFFF   ADDIU S4, ZERO, -1
9D01C3F8  14540006   BNE V0, S4, 0x9D01C414
9D01C3FC  87B30010   LH S3, 16(SP)
842:                 	    {
843:                 	    strcat(prog,line_exp);
9D01C400  02C02021   ADDU A0, S6, ZERO
9D01C404  0F40EAA1   JAL strcat
9D01C408  27A50048   ADDIU A1, SP, 72
844:                 	    return 0;
9D01C40C  0B40710A   J 0x9D01C428
9D01C410  00001021   ADDU V0, ZERO, ZERO
845:                 	    }
846:                 	linenum_prev = linenum_now;
847:                 	prog_ptr_prev = prog_ptr;
848:                 	prog_ptr = strchr(prog_ptr,'\n')+1;
9D01C414  02002021   ADDU A0, S0, ZERO
9D01C418  0F40E513   JAL strchr
9D01C41C  2405000A   ADDIU A1, ZERO, 10
849:                 	}
9D01C420  0B4070C4   J 0x9D01C310
9D01C424  24500001   ADDIU S0, V0, 1
850:                     }
9D01C428  8FBF00A4   LW RA, 164(SP)
9D01C42C  8FBE00A0   LW FP, 160(SP)
9D01C430  8FB7009C   LW S7, 156(SP)
9D01C434  8FB60098   LW S6, 152(SP)
9D01C438  8FB50094   LW S5, 148(SP)
9D01C43C  8FB40090   LW S4, 144(SP)
9D01C440  8FB3008C   LW S3, 140(SP)
9D01C444  8FB20088   LW S2, 136(SP)
9D01C448  8FB10084   LW S1, 132(SP)
9D01C44C  8FB00080   LW S0, 128(SP)
9D01C450  03E00008   JR RA
9D01C454  27BD00A8   ADDIU SP, SP, 168
851:                 
852:                 ////B_BAS007
853:                 //uint8_t cmd_exec (int8_t * cmd)
854:                 //    {
855:                 //    int8_t cmd_clean[25];
856:                 //    int32_t linenum,prognum;
857:                 //    if (isdigit(cmd[0]))
858:                 //		{
859:                 //		sscanf(cmd,"%d %[^\n]s",&linenum,cmd_clean);
860:                 //		add_prog_line (cmd_clean,bprog, linenum);
861:                 //		}
862:                 //    else
863:                 //		{
864:                 //		if (strcmp("list",cmd)==0) stdio_write(bprog);
865:                 //		else if (strcmp("memclr",cmd)==0) bprog[0]=0;
866:                 //		else if (strcmp("free",cmd)==0)
867:                 //			{
868:                 //			sprintf(stdio_buff,"%d B of memory free\n",get_free_mem(bprog,BPROG_LEN));
869:                 //			stdio_write(stdio_buff);
870:                 //			}	
871:                 //		else if (strcmp("more",cmd)==0) list_more();
872:                 //		else if (strcmp("help",cmd)==0) 
873:                 //			{
874:                 //			stdio_write("Basic BASIC help:\n");
875:                 //			stdio_write("Type more to list the program in buffer, ");
876:                 //			stdio_write("or run to run it.\n");
877:                 //			stdio_write(" For more documentation see hac.io/Mz3r\n");
878:                 //			}
879:                 //		else if (strncmp("load",cmd,4)==0)
880:                 //			{
881:                 //			sscanf (cmd+4,"%d",&prognum);
882:                 //			if ((prognum>=0)&(prognum<BASIC_SAVNUM))
883:                 //				{
884:                 //				stdio_write("loading...");
885:                 //				basic_load_program(bprog,prognum);
886:                 //				stdio_write("OK\n");
887:                 //				}
888:                 //			}
889:                 //		else if (strncmp("save",cmd,4)==0)
890:                 //			{
891:                 //			sscanf (cmd+4,"%d",&prognum);
892:                 //			if ((prognum>=0)&(prognum<BASIC_SAVNUM))
893:                 //				{
894:                 //				stdio_write("saving...");
895:                 //				basic_save_program(bprog,prognum);
896:                 //				stdio_write("OK\n");
897:                 //				}
898:                 //			}	
899:                 //		else if (strncmp("ssave",cmd,5)==0)
900:                 //			{
901:                 //			stdio_write("Transmitting via serial port...\n");
902:                 //			i = basic_saves(bprog,BPROG_LEN);
903:                 //			sprintf(stdio_buff,"\nOK, transmitted %d bytes.\n",i);
904:                 //			stdio_write(stdio_buff);
905:                 //			}	
906:                 //		else if (strncmp("sload",cmd,5)==0)
907:                 //			{
908:                 //			stdio_write("Loading new program from serial port\n");
909:                 //			stdio_write("Press BRK to exit...\n");
910:                 //			serial_flush();
911:                 //			handle_display = 0;
912:                 //			display_refresh_force();
913:                 //			i = basic_loads(bprog,BPROG_LEN);
914:                 //			handle_display = 1;
915:                 //			sprintf(stdio_buff,"\nOK, received %d bytes.\n",i);
916:                 //			stdio_write(stdio_buff);
917:                 //			}	
918:                 //		else if (strcmp("run",cmd)==0)
919:                 //			{
920:                 //			ubasic_init(bprog,0);
921:                 //			brk_key = 0;
922:                 //			do 
923:                 //				{
924:                 //				if (brk_key) 
925:                 //					{
926:                 //					brk_key = 0;
927:                 //					stdio_write("\nBRK pressed\n");
928:                 //					break;
929:                 //					}
930:                 //				if (!setjmp(jbuf)) ubasic_run();
931:                 //				else
932:                 //					{
933:                 //					stdio_write("\nBASIC error\n");
934:                 //					break;
935:                 //					}
936:                 //				} 	while(!ubasic_finished());
937:                 //			handle_display = 1;
938:                 //			stdio_write("\n");
939:                 //			}
940:                 //		else 
941:                 //			{
942:                 //			if (strlen(cmd)>0)
943:                 //				{
944:                 //				sprintf(tprog,"0 %s\n",cmd);
945:                 //				ubasic_init(tprog,1);
946:                 //				do 
947:                 //					{
948:                 //					if (!setjmp(jbuf)) ubasic_run();
949:                 //					else
950:                 //						{
951:                 //						stdio_write("BASIC error\n");
952:                 //						break;
953:                 //						}
954:                 //					} 	while(!ubasic_finished());	
955:                 //				}		
956:                 //			}
957:                 //		}
958:                 //    }
959:                 
960:                 
961:                 uint16_t basic_loads (int8_t * data, uint16_t maxlen)
962:                 	{
9D01C458  27BDFFE0   ADDIU SP, SP, -32
9D01C45C  AFBF001C   SW RA, 28(SP)
9D01C460  AFB20018   SW S2, 24(SP)
9D01C464  AFB10014   SW S1, 20(SP)
9D01C468  AFB00010   SW S0, 16(SP)
9D01C46C  00809021   ADDU S2, A0, ZERO
9D01C470  00A08821   ADDU S1, A1, ZERO
963:                 	uint8_t rx_char;
964:                 	uint16_t len=0;
9D01C474  00008021   ADDU S0, ZERO, ZERO
965:                 	while (1)
966:                 		{
967:                 		if (rx_sta())
9D01C478  0F407FEA   JAL rx_sta
9D01C47C  00000000   NOP
9D01C480  10400012   BEQ V0, ZERO, 0x9D01C4CC
9D01C484  00000000   NOP
968:                 			{
969:                 			rx_char = rx_read();
9D01C488  0F40800C   JAL .LFB100, .LFE98, rx_read
9D01C48C  00000000   NOP
970:                 			if ((rx_char>=' ')|(rx_char==NEWLINE)|(rx_char==0))
9D01C490  2443FFFF   ADDIU V1, V0, -1
9D01C494  306300FF   ANDI V1, V1, 255
9D01C498  2C63001F   SLTIU V1, V1, 31
9D01C49C  10600004   BEQ V1, ZERO, 0x9D01C4B0
9D01C4A0  26030001   ADDIU V1, S0, 1
9D01C4A4  3843000A   XORI V1, V0, 10
9D01C4A8  14600004   BNE V1, ZERO, 0x9D01C4BC
9D01C4AC  26030001   ADDIU V1, S0, 1
971:                 				data[len++] = rx_char;
9D01C4B0  02508021   ADDU S0, S2, S0
9D01C4B4  A2020000   SB V0, 0(S0)
9D01C4B8  3070FFFF   ANDI S0, V1, -1
972:                 			if (rx_char==0) return len;
9D01C4BC  1040000C   BEQ V0, ZERO, 0x9D01C4F0
9D01C4C0  02001021   ADDU V0, S0, ZERO
973:                 			if (len==maxlen) return len;
9D01C4C4  1211000B   BEQ S0, S1, 0x9D01C4F4
9D01C4C8  8FBF001C   LW RA, 28(SP)
974:                 			}
975:                 		if (brk_key) 
9D01C4CC  938381D9   LBU V1, -32295(GP)
9D01C4D0  7C031C20   SEB V1, V1
9D01C4D4  1060FFE8   BEQ V1, ZERO, 0x9D01C478
9D01C4D8  00000000   NOP
976:                 			{
977:                 			if (len>0) data[len] = 0;
9D01C4DC  12000002   BEQ S0, ZERO, 0x9D01C4E8
9D01C4E0  02509021   ADDU S2, S2, S0
9D01C4E4  A2400000   SB ZERO, 0(S2)
978:                 			brk_key = 0;
9D01C4E8  A38081D9   SB ZERO, -32295(GP)
979:                 			return len;
980:                 			}
981:                 		}
982:                 	return 0;
983:                 	}
9D01C4EC  02001021   ADDU V0, S0, ZERO
9D01C4F0  8FBF001C   LW RA, 28(SP)
9D01C4F4  8FB20018   LW S2, 24(SP)
9D01C4F8  8FB10014   LW S1, 20(SP)
9D01C4FC  8FB00010   LW S0, 16(SP)
9D01C500  03E00008   JR RA
9D01C504  27BD0020   ADDIU SP, SP, 32
984:                 
985:                 uint16_t basic_saves (int8_t * data, uint16_t maxlen)
986:                 	{
9D01C508  27BDFFD8   ADDIU SP, SP, -40
9D01C50C  AFBF0024   SW RA, 36(SP)
9D01C510  AFB30020   SW S3, 32(SP)
9D01C514  AFB2001C   SW S2, 28(SP)
9D01C518  AFB10018   SW S1, 24(SP)
9D01C51C  AFB00014   SW S0, 20(SP)
9D01C520  00809021   ADDU S2, A0, ZERO
9D01C524  00A09821   ADDU S3, A1, ZERO
987:                 	uint16_t len=0;
9D01C528  00008021   ADDU S0, ZERO, ZERO
988:                 	while (1)
989:                 		{
990:                 		tx_write(data[len]);
9D01C52C  02508821   ADDU S1, S2, S0
9D01C530  0F408010   JAL tx_write
9D01C534  92240000   LBU A0, 0(S1)
991:                 		if (data[len]==0) return len;
9D01C538  82220000   LB V0, 0(S1)
9D01C53C  10400006   BEQ V0, ZERO, 0x9D01C558
9D01C540  02001021   ADDU V0, S0, ZERO
992:                 		if (len==maxlen) return len;
9D01C544  12130005   BEQ S0, S3, 0x9D01C55C
9D01C548  8FBF0024   LW RA, 36(SP)
993:                 		len++;
9D01C54C  26100001   ADDIU S0, S0, 1
994:                 		}
9D01C550  0B40714B   J 0x9D01C52C
9D01C554  3210FFFF   ANDI S0, S0, -1
995:                 	return 0;
996:                 	}
9D01C558  8FBF0024   LW RA, 36(SP)
9D01C55C  8FB30020   LW S3, 32(SP)
9D01C560  8FB2001C   LW S2, 28(SP)
9D01C564  8FB10018   LW S1, 24(SP)
9D01C568  8FB00014   LW S0, 20(SP)
9D01C56C  03E00008   JR RA
9D01C570  27BD0028   ADDIU SP, SP, 40
997:                 
998:                 //B_BAS011
999:                 uint8_t basic_save_program (uint8_t * data, uint8_t slot)
1000:                	{
9D01C574  27BDFFD8   ADDIU SP, SP, -40
9D01C578  AFBF0024   SW RA, 36(SP)
9D01C57C  AFB40020   SW S4, 32(SP)
9D01C580  AFB3001C   SW S3, 28(SP)
9D01C584  AFB20018   SW S2, 24(SP)
9D01C588  AFB10014   SW S1, 20(SP)
9D01C58C  AFB00010   SW S0, 16(SP)
9D01C590  0080A021   ADDU S4, A0, ZERO
1001:                	uint32_t  addr;
1002:                	uint16_t  cnt;
1003:                	addr = slot;
1004:                	addr = addr * BPROG_SECSIZ * BPROG_SECNUM;
9D01C594  00059B80   SLL S3, A1, 14
9D01C598  00008021   ADDU S0, ZERO, ZERO
1005:                	addr = addr + BASIC_BASEADDR;
1006:                	for (cnt = 0;cnt<BPROG_SECNUM;cnt++)
9D01C59C  24124000   ADDIU S2, ZERO, 16384
9D01C5A0  02138821   ADDU S1, S0, S3
9D01C5BC  1612FFF9   BNE S0, S2, 0x9D01C5A4
9D01C5C0  02138821   ADDU S1, S0, S3
1007:                		{
1008:                		fl_erase_4k(addr + cnt*BPROG_SECSIZ);
9D01C5A4  0F40B311   JAL fl_erase_4k
9D01C5A8  02202021   ADDU A0, S1, ZERO
1009:                		fl_write_4k(addr + cnt*BPROG_SECSIZ,data + cnt*BPROG_SECSIZ);	
9D01C5AC  02202021   ADDU A0, S1, ZERO
9D01C5B0  0F40B364   JAL fl_write_4k
9D01C5B4  02902821   ADDU A1, S4, S0
9D01C5B8  26101000   ADDIU S0, S0, 4096
1010:                		}
1011:                	return 1;
1012:                	}
9D01C5C4  24020001   ADDIU V0, ZERO, 1
9D01C5C8  8FBF0024   LW RA, 36(SP)
9D01C5CC  8FB40020   LW S4, 32(SP)
9D01C5D0  8FB3001C   LW S3, 28(SP)
9D01C5D4  8FB20018   LW S2, 24(SP)
9D01C5D8  8FB10014   LW S1, 20(SP)
9D01C5DC  8FB00010   LW S0, 16(SP)
9D01C5E0  03E00008   JR RA
9D01C5E4  27BD0028   ADDIU SP, SP, 40
1013:                
1014:                
1015:                //B_BAS012
1016:                uint8_t basic_load_program (uint8_t * data, uint8_t slot)
1017:                	{
9D01C5E8  27BDFFD8   ADDIU SP, SP, -40
9D01C5EC  AFBF0024   SW RA, 36(SP)
9D01C5F0  AFB30020   SW S3, 32(SP)
9D01C5F4  AFB2001C   SW S2, 28(SP)
9D01C5F8  AFB10018   SW S1, 24(SP)
9D01C5FC  AFB00014   SW S0, 20(SP)
9D01C600  00808821   ADDU S1, A0, ZERO
1018:                	uint32_t  addr;
1019:                	uint16_t  cnt;
1020:                	addr = slot;
1021:                	addr = addr * BPROG_SECSIZ * BPROG_SECNUM;
9D01C604  00059B80   SLL S3, A1, 14
9D01C608  00008021   ADDU S0, ZERO, ZERO
1022:                	addr = addr + BASIC_BASEADDR;
1023:                	for (cnt = 0;cnt<BPROG_SECNUM;cnt++)
9D01C60C  24124000   ADDIU S2, ZERO, 16384
9D01C620  1612FFFC   BNE S0, S2, 0x9D01C614
9D01C624  02132021   ADDU A0, S0, S3
1024:                		fl_read_4k(addr + cnt*BPROG_SECSIZ,data + cnt*BPROG_SECSIZ);	
9D01C610  02132021   ADDU A0, S0, S3
9D01C614  0F40B2B5   JAL fl_read_4k
9D01C618  02302821   ADDU A1, S1, S0
9D01C61C  26101000   ADDIU S0, S0, 4096
1025:                	if (data[0] == 0xFF) data[0] = 0;
9D01C628  92230000   LBU V1, 0(S1)
9D01C62C  240200FF   ADDIU V0, ZERO, 255
9D01C630  50620001   BEQL V1, V0, 0x9D01C638
9D01C634  A2200000   SB ZERO, 0(S1)
1026:                	return 1;
1027:                	}
9D01C638  24020001   ADDIU V0, ZERO, 1
9D01C63C  8FBF0024   LW RA, 36(SP)
9D01C640  8FB30020   LW S3, 32(SP)
9D01C644  8FB2001C   LW S2, 28(SP)
9D01C648  8FB10018   LW S1, 24(SP)
9D01C64C  8FB00014   LW S0, 20(SP)
9D01C650  03E00008   JR RA
9D01C654  27BD0028   ADDIU SP, SP, 40
1028:                
1029:                void list_more (void)
1030:                	{
9D01D1A4  27BDFFD0   ADDIU SP, SP, -48
9D01D1A8  AFBF002C   SW RA, 44(SP)
9D01D1AC  AFB40028   SW S4, 40(SP)
9D01D1B0  AFB30024   SW S3, 36(SP)
9D01D1B4  AFB20020   SW S2, 32(SP)
9D01D1B8  AFB1001C   SW S1, 28(SP)
9D01D1BC  AFB00018   SW S0, 24(SP)
1031:                	uint8_t retval;
1032:                	uint16_t list_cnt=0,list_nl_cnt=0;
9D01D1C4  00009821   ADDU S3, ZERO, ZERO
9D01D1C8  00008021   ADDU S0, ZERO, ZERO
1033:                	while (bprog[list_cnt]!=0)
9D01D194  3C02A000   LUI V0, -24576
9D01D198  804221E0   LB V0, 8672(V0)
9D01D19C  10400036   BEQ V0, ZERO, 0x9D01D278
9D01D1A0  00000000   NOP
9D01D1C0  00009021   ADDU S2, ZERO, ZERO
9D01D24C  02111021   ADDU V0, S0, S1
9D01D250  80420000   LB V0, 0(V0)
9D01D254  1440FFE1   BNE V0, ZERO, 0x9D01D1DC
9D01D258  02009021   ADDU S2, S0, ZERO
1034:                		{
1035:                		if (bprog[list_cnt]==NEWLINE)
9D01D1DC  2403000A   ADDIU V1, ZERO, 10
9D01D1E0  14430003   BNE V0, V1, 0x9D01D1F0
9D01D1E4  24020013   ADDIU V0, ZERO, 19
1036:                			list_nl_cnt++;
9D01D1E8  26730001   ADDIU S3, S3, 1
9D01D1EC  3273FFFF   ANDI S3, S3, -1
1037:                		if (list_nl_cnt==(DISP_BUFFER_HIGH-1))
9D01D1F0  56620012   BNEL S3, V0, 0x9D01D23C
9D01D1F4  26100001   ADDIU S0, S0, 1
1038:                			{
1039:                			stdio_c(NEWLINE);
9D01D1F8  0F40729E   JAL stdio_c
9D01D1FC  2404000A   ADDIU A0, ZERO, 10
1040:                			stdio_write("---hit any key for more, q to quit---");
9D01D1CC  3C149D03   LUI S4, -25341
9D01D1D0  26949F50   ADDIU S4, S4, -24752
9D01D200  0F407196   JAL stdio_write
9D01D204  02802021   ADDU A0, S4, ZERO
1041:                			while (stdio_get(&retval)==0);
9D01D208  0F4073D3   JAL stdio_get
9D01D20C  27A40010   ADDIU A0, SP, 16
9D01D210  1040FFFD   BEQ V0, ZERO, .LVL280
9D01D214  00000000   NOP
1042:                			stdio_c(NEWLINE);
9D01D218  0F40729E   JAL stdio_c
9D01D21C  2404000A   ADDIU A0, ZERO, 10
1043:                			if (retval == 'q') return;
9D01D220  93A30010   LBU V1, 16(SP)
9D01D224  24020071   ADDIU V0, ZERO, 113
9D01D228  1062000D   BEQ V1, V0, 0x9D01D260
9D01D22C  8FBF002C   LW RA, 44(SP)
1044:                			list_nl_cnt = 0;
1045:                			video_clrscr();
9D01D230  0F406C60   JAL video_clrscr
9D01D234  00009821   ADDU S3, ZERO, ZERO
1046:                			}
1047:                		stdio_c(bprog[list_cnt++]);
9D01D1D4  3C11A000   LUI S1, -24576
9D01D1D8  263121E0   ADDIU S1, S1, 8672
9D01D238  26100001   ADDIU S0, S0, 1
9D01D23C  3210FFFF   ANDI S0, S0, -1
9D01D240  02519021   ADDU S2, S2, S1
9D01D244  0F40729E   JAL stdio_c
9D01D248  92440000   LBU A0, 0(S2)
1048:                		}	
1049:                	}
9D01D25C  8FBF002C   LW RA, 44(SP)
9D01D260  8FB40028   LW S4, 40(SP)
9D01D264  8FB30024   LW S3, 36(SP)
9D01D268  8FB20020   LW S2, 32(SP)
9D01D26C  8FB1001C   LW S1, 28(SP)
9D01D270  8FB00018   LW S0, 24(SP)
9D01D274  27BD0030   ADDIU SP, SP, 48
9D01D278  03E00008   JR RA
9D01D27C  00000000   NOP
1050:                
1051:                //B_BDG003
1052:                
1053:                //write null-terminated string to standard output
1054:                uint8_t stdio_write (int8_t * data)
1055:                	{
9D01C658  27BDFFE8   ADDIU SP, SP, -24
9D01C65C  AFBF0014   SW RA, 20(SP)
9D01C660  AFB00010   SW S0, 16(SP)
9D01C664  00808021   ADDU S0, A0, ZERO
1056:                	if (stdio_src==STDIO_LOCAL)
9D01C668  938281CD   LBU V0, -32307(GP)
9D01C66C  7C021420   SEB V0, V0
9D01C670  14400016   BNE V0, ZERO, 0x9D01C6CC
9D01C674  00000000   NOP
9D01C678  0B4071AF   J 0x9D01C6BC
9D01C67C  82040000   LB A0, 0(S0)
1057:                		{
1058:                		while (*data!=0x00)
9D01C6B8  82040000   LB A0, 0(S0)
9D01C6BC  1480FFF0   BNE A0, ZERO, 0x9D01C680
9D01C6C0  26100001   ADDIU S0, S0, 1
9D01C6C4  0B4071C2   J 0x9D01C708
9D01C6C8  8FBF0014   LW RA, 20(SP)
1059:                			{
1060:                			buf_enqueue (*data++);
9D01C680  0F406B17   JAL buf_enqueue
9D01C684  308400FF   ANDI A0, A0, 255
1061:                			while (bufsize)
9D01C688  978281B8   LHU V0, -32328(GP)
9D01C68C  3042FFFF   ANDI V0, V0, -1
9D01C690  5040000A   BEQL V0, ZERO, 0x9D01C6BC
9D01C694  82040000   LB A0, 0(S0)
9D01C6A8  978281B8   LHU V0, -32328(GP)
9D01C6AC  3042FFFF   ANDI V0, V0, -1
9D01C6B0  1440FFF9   BNE V0, ZERO, 0x9D01C698
9D01C6B4  00000000   NOP
1062:                				receive_char(buf_dequeue());	
9D01C698  0F406B2F   JAL buf_dequeue
9D01C69C  00000000   NOP
9D01C6A0  0F406F3C   JAL receive_char
9D01C6A4  00402021   ADDU A0, V0, ZERO
1063:                			}
1064:                		}
1065:                	else if (stdio_src==STDIO_TTY1)
9D01C6CC  938381CD   LBU V1, -32307(GP)
9D01C6D0  7C031C20   SEB V1, V1
9D01C6D4  24020001   ADDIU V0, ZERO, 1
9D01C6D8  1462000B   BNE V1, V0, 0x9D01C708
9D01C6DC  8FBF0014   LW RA, 20(SP)
1066:                		{
1067:                		while (*data!=0x00)
9D01C6E0  80840000   LB A0, 0(A0)
9D01C6E4  50800009   BEQL A0, ZERO, 0x9D01C70C
9D01C6E8  8FB00010   LW S0, 16(SP)
9D01C6F8  82040000   LB A0, 0(S0)
9D01C6FC  1480FFFC   BNE A0, ZERO, 0x9D01C6F0
9D01C700  26100001   ADDIU S0, S0, 1
1068:                		tx_write(*data++);
9D01C6EC  26100001   ADDIU S0, S0, 1
9D01C6F0  0F408010   JAL tx_write
9D01C6F4  308400FF   ANDI A0, A0, 255
1069:                		}
1070:                	}
9D01C704  8FBF0014   LW RA, 20(SP)
9D01C708  8FB00010   LW S0, 16(SP)
9D01C70C  03E00008   JR RA
9D01C710  27BD0018   ADDIU SP, SP, 24
1071:                
1072:                //write one character to standard output
1073:                uint8_t stdio_c (uint8_t data)
1074:                	{
9D01CA78  27BDFFE8   ADDIU SP, SP, -24
9D01CA7C  AFBF0014   SW RA, 20(SP)
1075:                	int8_t tmp[3];
1076:                	if (stdio_src==STDIO_LOCAL)
9D01CA80  938281CD   LBU V0, -32307(GP)
9D01CA84  7C021420   SEB V0, V0
9D01CA88  14400011   BNE V0, ZERO, 0x9D01CAD0
9D01CA8C  00000000   NOP
1077:                		{
1078:                		tmp[0] = data;
1079:                		tmp[1] = 0;
1080:                		buf_enqueue (data);
9D01CA90  0F406B17   JAL buf_enqueue
9D01CA94  00000000   NOP
1081:                		while (bufsize)
9D01CA98  978281B8   LHU V0, -32328(GP)
9D01CA9C  3042FFFF   ANDI V0, V0, -1
9D01CAA0  10400013   BEQ V0, ZERO, 0x9D01CAF0
9D01CAA4  8FBF0014   LW RA, 20(SP)
9D01CAB8  978281B8   LHU V0, -32328(GP)
9D01CABC  3042FFFF   ANDI V0, V0, -1
9D01CAC0  1440FFF9   BNE V0, ZERO, 0x9D01CAA8
9D01CAC4  8FBF0014   LW RA, 20(SP)
9D01CAC8  0B4072BC   J 0x9D01CAF0
9D01CACC  00000000   NOP
1082:                			receive_char(buf_dequeue());
9D01CAA8  0F406B2F   JAL buf_dequeue
9D01CAAC  00000000   NOP
9D01CAB0  0F406F3C   JAL receive_char
9D01CAB4  00402021   ADDU A0, V0, ZERO
1083:                		}
1084:                	else if (stdio_src==STDIO_TTY1)
9D01CAD0  938381CD   LBU V1, -32307(GP)
9D01CAD4  7C031C20   SEB V1, V1
9D01CAD8  24020001   ADDIU V0, ZERO, 1
9D01CADC  14620004   BNE V1, V0, 0x9D01CAF0
9D01CAE0  8FBF0014   LW RA, 20(SP)
1085:                		tx_write(data);
9D01CAE4  0F408010   JAL tx_write
9D01CAE8  00000000   NOP
1086:                	}
9D01CAEC  8FBF0014   LW RA, 20(SP)
9D01CAF0  03E00008   JR RA
9D01CAF4  27BD0018   ADDIU SP, SP, 24
1087:                
1088:                //check, whether is there something to read from standard input
1089:                //zero is returned when empty, nonzero when character is available
1090:                int8_t stdio_get_state (void)
1091:                	{
9D01CE90  27BDFFE8   ADDIU SP, SP, -24
9D01CE94  AFBF0014   SW RA, 20(SP)
1092:                	if (stdio_local_buffer_state()!=0)
9D01CE98  0F4073A1   JAL stdio_local_buffer_state
9D01CE9C  00000000   NOP
9D01CEA0  14400011   BNE V0, ZERO, 0x9D01CEE8
9D01CEA4  24020001   ADDIU V0, ZERO, 1
1093:                		return 1;
1094:                	if (stdio_src==STDIO_LOCAL)
9D01CEA8  938281CD   LBU V0, -32307(GP)
9D01CEAC  7C021420   SEB V0, V0
9D01CEB0  14400005   BNE V0, ZERO, 0x9D01CEC8
9D01CEB4  00000000   NOP
1095:                		return term_k_stat();
9D01CEB8  0F40737D   JAL term_k_stat
9D01CEBC  00000000   NOP
9D01CEC0  0B4073BB   J 0x9D01CEEC
9D01CEC4  8FBF0014   LW RA, 20(SP)
1096:                	else if (stdio_src==STDIO_TTY1)
9D01CEC8  938381CD   LBU V1, -32307(GP)
9D01CECC  7C031C20   SEB V1, V1
9D01CED0  24020001   ADDIU V0, ZERO, 1
9D01CED4  14620005   BNE V1, V0, 0x9D01CEEC
9D01CED8  8FBF0014   LW RA, 20(SP)
1097:                		return rx_sta();
9D01CEDC  0F407FEA   JAL rx_sta
9D01CEE0  00000000   NOP
9D01CEE4  7C021420   SEB V0, V0
1098:                	}
9D01CEE8  8FBF0014   LW RA, 20(SP)
9D01CEEC  03E00008   JR RA
9D01CEF0  27BD0018   ADDIU SP, SP, 24
1099:                //get character from stdio
1100:                //zero when there is nothing to read
1101:                int8_t stdio_get (int8_t * dat)
1102:                	{
9D01CF4C  27BDFFE8   ADDIU SP, SP, -24
9D01CF50  AFBF0014   SW RA, 20(SP)
9D01CF54  AFB00010   SW S0, 16(SP)
1103:                	if (stdio_local_buffer_state()!=0)
9D01CF58  0F4073A1   JAL stdio_local_buffer_state
9D01CF5C  00808021   ADDU S0, A0, ZERO
9D01CF60  10400006   BEQ V0, ZERO, 0x9D01CF7C
9D01CF64  00000000   NOP
1104:                		{
1105:                		*dat = stdio_local_buffer_get();
9D01CF68  0F4073BD   JAL stdio_local_buffer_get
9D01CF6C  00000000   NOP
9D01CF70  A2020000   SB V0, 0(S0)
1106:                		return 1;
9D01CF74  0B4073F4   J 0x9D01CFD0
9D01CF78  24030001   ADDIU V1, ZERO, 1
1107:                		}
1108:                	if (stdio_src==STDIO_LOCAL)
9D01CF7C  938281CD   LBU V0, -32307(GP)
9D01CF80  7C021420   SEB V0, V0
9D01CF84  14400005   BNE V0, ZERO, 0x9D01CF9C
9D01CF88  00000000   NOP
1109:                		{
1110:                		return term_k_char(dat);
9D01CF8C  0F407388   JAL term_k_char
9D01CF90  02002021   ADDU A0, S0, ZERO
9D01CF94  0B4073F4   J 0x9D01CFD0
9D01CF98  00401821   ADDU V1, V0, ZERO
1111:                		}
1112:                	else if (stdio_src==STDIO_TTY1)
9D01CF9C  938481CD   LBU A0, -32307(GP)
9D01CFA0  7C042420   SEB A0, A0
9D01CFA4  24020001   ADDIU V0, ZERO, 1
9D01CFA8  14820009   BNE A0, V0, 0x9D01CFD0
9D01CFAC  00001821   ADDU V1, ZERO, ZERO
1113:                		{
1114:                		if (rx_sta()!=0)
9D01CFB0  0F407FEA   JAL rx_sta
9D01CFB4  00000000   NOP
9D01CFB8  10400005   BEQ V0, ZERO, 0x9D01CFD0
9D01CFBC  00001821   ADDU V1, ZERO, ZERO
1115:                			{
1116:                			*dat=rx_read();
9D01CFC0  0F40800C   JAL .LFB100, .LFE98, rx_read
9D01CFC4  00000000   NOP
9D01CFC8  A2020000   SB V0, 0(S0)
1117:                			return 1;
9D01CFCC  24030001   ADDIU V1, ZERO, 1
1118:                			}
1119:                		else
1120:                			return 0;
1121:                		}
1122:                	return 0;
1123:                	}
9D01CFD0  00601021   ADDU V0, V1, ZERO
9D01CFD4  8FBF0014   LW RA, 20(SP)
9D01CFD8  8FB00010   LW S0, 16(SP)
9D01CFDC  03E00008   JR RA
9D01CFE0  27BD0018   ADDIU SP, SP, 24
1124:                
1125:                
1126:                int8_t term_k_stat (void)
1127:                	{
1128:                	uint8_t key_len;
1129:                	IEC0bits.T2IE = 0;
9D01CDF4  3C03BF88   LUI V1, -16504
9D01CDF8  8C621060   LW V0, 4192(V1)
9D01CDFC  7C024A44   INS V0, ZERO, 9, 1
9D01CE00  AC621060   SW V0, 4192(V1)
1130:                	key_len = key_buffer_ptr;
9D01CE04  93828197   LBU V0, -32361(GP)
1131:                	IEC0bits.T2IE = 1;
9D01CE08  8C641060   LW A0, 4192(V1)
9D01CE0C  24050001   ADDIU A1, ZERO, 1
9D01CE10  7CA44A44   INS A0, A1, 9, 1
9D01CE14  AC641060   SW A0, 4192(V1)
1132:                	if (key_len == 0)
1133:                		return 0;
1134:                	else 
1135:                		return 1;
1136:                	}
9D01CE18  03E00008   JR RA
9D01CE1C  0002102B   SLTU V0, ZERO, V0
1137:                
1138:                int8_t term_k_char (int8_t * out)
1139:                	{
9D01CE20  27BDFFE8   ADDIU SP, SP, -24
9D01CE24  AFBF0014   SW RA, 20(SP)
9D01CE28  AFB00010   SW S0, 16(SP)
1140:                	uint8_t retval;
1141:                	IEC0bits.T2IE = 0;
9D01CE2C  3C02BF88   LUI V0, -16504
9D01CE30  8C431060   LW V1, 4192(V0)
9D01CE34  7C034A44   INS V1, ZERO, 9, 1
9D01CE38  AC431060   SW V1, 4192(V0)
1142:                	retval = key_buffer_ptr;
9D01CE3C  93908197   LBU S0, -32361(GP)
1143:                	if (key_buffer_ptr>0)
9D01CE40  12000007   BEQ S0, ZERO, 0x9D01CE60
9D01CE44  3C02BF88   LUI V0, -16504
1144:                		{
1145:                		strncpy(out,key_buffer,key_buffer_ptr);
9D01CE48  3C05A000   LUI A1, -24576
9D01CE4C  24A519E0   ADDIU A1, A1, 6624
9D01CE50  0F40E397   JAL .LFE23, strncpy
9D01CE54  02003021   ADDU A2, S0, ZERO
1146:                		key_buffer_ptr = 0;
9D01CE58  A3808197   SB ZERO, -32361(GP)
1147:                		}
1148:                	IEC0bits.T2IE = 1;
9D01CE5C  3C02BF88   LUI V0, -16504
9D01CE60  8C431060   LW V1, 4192(V0)
9D01CE64  24040001   ADDIU A0, ZERO, 1
9D01CE68  7C834A44   INS V1, A0, 9, 1
9D01CE6C  AC431060   SW V1, 4192(V0)
1149:                	return retval;
1150:                	}
9D01CE70  7C101420   SEB V0, S0
9D01CE74  8FBF0014   LW RA, 20(SP)
9D01CE78  8FB00010   LW S0, 16(SP)
9D01CE7C  03E00008   JR RA
9D01CE80  27BD0018   ADDIU SP, SP, 24
1151:                
1152:                
1153:                //void boot_animation(void)
1154:                //	{
1155:                //	handle_display = 0; //Shut off auto-scanning of character buffer
1156:                //	animate_splash();
1157:                //	uint16_t waitfor = ticks+1000;	//Wait for 1 second
1158:                //	while (ticks<waitfor) { ;; }
1159:                //	tft_fill_area(0,0,320,240,0x000000);    //Make display black
1160:                //	handle_display = 1; //Go back to character display
1161:                //}
1162:                
1163:                uint8_t stdio_local_buffer_state (void)
1164:                	{
1165:                	if (stdio_local_len>0) return 1;
9D01CE84  93828196   LBU V0, -32362(GP)
1166:                	else return 0;
1167:                	}
9D01CE88  03E00008   JR RA
9D01CE8C  0002102B   SLTU V0, ZERO, V0
1168:                
1169:                int8_t stdio_local_buffer_get (void)
1170:                	{
1171:                	int8_t retval=0;
1172:                	if (stdio_local_len>0)
9D01CEF4  93868196   LBU A2, -32362(GP)
9D01CEF8  10C00012   BEQ A2, ZERO, 0x9D01CF44
9D01CEFC  00001021   ADDU V0, ZERO, ZERO
1173:                		{
1174:                		retval = stdio_local_buff[0];
9D01CF00  3C05A000   LUI A1, -24576
9D01CF04  80A221A4   LB V0, 8612(A1)
9D01CF08  3C03A000   LUI V1, -24576
9D01CF0C  246321A5   ADDIU V1, V1, 8613
9D01CF10  24A521A4   ADDIU A1, A1, 8612
9D01CF14  24A50019   ADDIU A1, A1, 25
1175:                		for (i=1;i<STDIO_LOCAL_BUFF_SIZE;i++) stdio_local_buff[i-1] = stdio_local_buff[i];
9D01CF18  90640000   LBU A0, 0(V1)
9D01CF1C  A064FFFF   SB A0, -1(V1)
9D01CF20  24630001   ADDIU V1, V1, 1
9D01CF24  5465FFFD   BNEL V1, A1, 0x9D01CF1C
9D01CF28  90640000   LBU A0, 0(V1)
9D01CF2C  24030019   ADDIU V1, ZERO, 25
9D01CF30  AF8381D4   SW V1, -32300(GP)
1176:                		stdio_local_buff[STDIO_LOCAL_BUFF_SIZE-1]=0;
9D01CF34  3C03A000   LUI V1, -24576
9D01CF38  A06021BC   SB ZERO, 8636(V1)
1177:                		stdio_local_len--;
9D01CF3C  24C6FFFF   ADDIU A2, A2, -1
9D01CF40  A3868196   SB A2, -32362(GP)
1178:                		}
1179:                	return retval;
1180:                	}
9D01CF44  03E00008   JR RA
9D01CF48  00000000   NOP
1181:                
1182:                void stdio_local_buffer_put (int8_t data)
1183:                	{
1184:                	if (stdio_local_len<(STDIO_LOCAL_BUFF_SIZE-1))
9D01D280  93828196   LBU V0, -32362(GP)
9D01D284  2C430018   SLTIU V1, V0, 24
9D01D288  10600006   BEQ V1, ZERO, 0x9D01D2A4
9D01D28C  24430001   ADDIU V1, V0, 1
1185:                		stdio_local_buff[stdio_local_len++] = data;
9D01D290  A3838196   SB V1, -32362(GP)
9D01D294  3C03A000   LUI V1, -24576
9D01D298  246321A4   ADDIU V1, V1, 8612
9D01D29C  00431021   ADDU V0, V0, V1
9D01D2A0  A0440000   SB A0, 0(V0)
9D01D2A4  03E00008   JR RA
9D01D2A8  00000000   NOP
1186:                	}
1187:                
1188:                void stdio_local_buffer_puts (int8_t * data)
1189:                	{
9D01D2AC  27BDFFE8   ADDIU SP, SP, -24
9D01D2B0  AFBF0014   SW RA, 20(SP)
9D01D2B4  AFB00010   SW S0, 16(SP)
9D01D2B8  00808021   ADDU S0, A0, ZERO
1190:                	while (*data!=0) stdio_local_buffer_put(*data++);
9D01D2BC  80840000   LB A0, 0(A0)
9D01D2C0  10800006   BEQ A0, ZERO, 0x9D01D2DC
9D01D2C4  8FBF0014   LW RA, 20(SP)
9D01D2C8  0F4074A0   JAL stdio_local_buffer_put
9D01D2CC  26100001   ADDIU S0, S0, 1
9D01D2D0  82040000   LB A0, 0(S0)
9D01D2D4  1480FFFC   BNE A0, ZERO, 0x9D01D2C8
9D01D2D8  8FBF0014   LW RA, 20(SP)
1191:                	}
9D01D2DC  8FB00010   LW S0, 16(SP)
9D01D2E0  03E00008   JR RA
9D01D2E4  27BD0018   ADDIU SP, SP, 24
1192:                
1193:                //************************************************************************
1194:                //some hardware stuff
1195:                
1196:                
1197:                //B_BDG003
1198:                void __ISR(_TIMER_5_VECTOR, IPL3AUTO) Timer5Handler(void)
1199:                {
9D01D2E8  415DE800   RDPGPR SP, SP
9D01D2EC  401B7000   MFC0 K1, EPC
9D01D2F0  401A6002   MFC0 K0, SRSCtl
9D01D2F4  27BDFF90   ADDIU SP, SP, -112
9D01D2F8  AFBB006C   SW K1, 108(SP)
9D01D2FC  401B6000   MFC0 K1, Status
9D01D300  AFBA0064   SW K0, 100(SP)
9D01D304  AFBB0068   SW K1, 104(SP)
9D01D308  7C1B7844   INS K1, ZERO, 1, 15
9D01D30C  377B0C00   ORI K1, K1, 3072
9D01D310  409B6000   MTC0 K1, Status
9D01D314  AFA30018   SW V1, 24(SP)
9D01D318  AFA20014   SW V0, 20(SP)
9D01D31C  8FA30064   LW V1, 100(SP)
9D01D320  3063000F   ANDI V1, V1, 15
9D01D324  14600011   BNE V1, ZERO, 0x9D01D36C
9D01D328  00000000   NOP
9D01D32C  AFBF0054   SW RA, 84(SP)
9D01D330  AFB90050   SW T9, 80(SP)
9D01D334  AFB8004C   SW T8, 76(SP)
9D01D338  AFAF0048   SW T7, 72(SP)
9D01D33C  AFAE0044   SW T6, 68(SP)
9D01D340  AFAD0040   SW T5, 64(SP)
9D01D344  AFAC003C   SW T4, 60(SP)
9D01D348  AFAB0038   SW T3, 56(SP)
9D01D34C  AFAA0034   SW T2, 52(SP)
9D01D350  AFA90030   SW T1, 48(SP)
9D01D354  AFA8002C   SW T0, 44(SP)
9D01D358  AFA70028   SW A3, 40(SP)
9D01D35C  AFA60024   SW A2, 36(SP)
9D01D360  AFA50020   SW A1, 32(SP)
9D01D364  AFA4001C   SW A0, 28(SP)
9D01D368  AFA10010   SW AT, 16(SP)
9D01D36C  00001012   MFLO V0
9D01D370  AFA2005C   SW V0, 92(SP)
9D01D374  00001810   MFHI V1
9D01D378  AFA30058   SW V1, 88(SP)
1200:                    uint8_t key_temp;
1201:                    IFS0bits.T5IF = 0;
9D01D37C  3C02BF88   LUI V0, -16504
9D01D380  8C431030   LW V1, 4144(V0)
9D01D384  7C03C604   INS V1, ZERO, 24, 1
9D01D388  AC431030   SW V1, 4144(V0)
1202:                	disp_tasks();
9D01D38C  0F4050A7   JAL disp_tasks
9D01D390  00000000   NOP
1203:                	loop_badge();
9D01D394  0F40703E   JAL loop_badge
9D01D398  00000000   NOP
1204:                    if (handle_display)
9D01D39C  93828195   LBU V0, -32363(GP)
9D01D3A0  304200FF   ANDI V0, V0, 255
9D01D3A4  10400005   BEQ V0, ZERO, .LVL297
9D01D3A8  3C04A000   LUI A0, -24576
1205:                		tft_disp_buffer_refresh_part((uint8_t *)(disp_buffer),(uint8_t *)color_buffer);
9D01D3AC  24841E5C   ADDIU A0, A0, 7772
9D01D3B0  3C05A000   LUI A1, -24576
9D01D3B4  0F40534A   JAL tft_disp_buffer_refresh_part
9D01D3B8  24A51B14   ADDIU A1, A1, 6932
1206:                    key_temp = keyb_tasks();
9D01D3BC  0F407DDB   JAL keyb_tasks
9D01D3C0  00000000   NOP
1207:                    if (key_temp>0)
9D01D3C4  10400007   BEQ V0, ZERO, 0x9D01D3E4
9D01D3C8  93838197   LBU V1, -32361(GP)
1208:                		key_buffer[key_buffer_ptr++] = key_temp;
9D01D3CC  24640001   ADDIU A0, V1, 1
9D01D3D0  A3848197   SB A0, -32361(GP)
9D01D3D4  3C04A000   LUI A0, -24576
9D01D3D8  248419E0   ADDIU A0, A0, 6624
9D01D3DC  00641821   ADDU V1, V1, A0
9D01D3E0  A0620000   SB V0, 0(V1)
1209:                }
9D01D3E4  8FA2005C   LW V0, 92(SP)
9D01D3E8  00400013   MTLO V0
9D01D3EC  8FA30058   LW V1, 88(SP)
9D01D3F0  00600011   MTHI V1
9D01D3F4  8FA20064   LW V0, 100(SP)
9D01D3F8  3042000F   ANDI V0, V0, 15
9D01D3FC  14400013   BNE V0, ZERO, 0x9D01D44C
9D01D400  00000000   NOP
9D01D404  8FBF0054   LW RA, 84(SP)
9D01D408  8FB90050   LW T9, 80(SP)
9D01D40C  8FB8004C   LW T8, 76(SP)
9D01D410  8FAF0048   LW T7, 72(SP)
9D01D414  8FAE0044   LW T6, 68(SP)
9D01D418  8FAD0040   LW T5, 64(SP)
9D01D41C  8FAC003C   LW T4, 60(SP)
9D01D420  8FAB0038   LW T3, 56(SP)
9D01D424  8FAA0034   LW T2, 52(SP)
9D01D428  8FA90030   LW T1, 48(SP)
9D01D42C  8FA8002C   LW T0, 44(SP)
9D01D430  8FA70028   LW A3, 40(SP)
9D01D434  8FA60024   LW A2, 36(SP)
9D01D438  8FA50020   LW A1, 32(SP)
9D01D43C  8FA4001C   LW A0, 28(SP)
9D01D440  8FA30018   LW V1, 24(SP)
9D01D444  8FA20014   LW V0, 20(SP)
9D01D448  8FA10010   LW AT, 16(SP)
9D01D44C  41606000   DI ZERO
9D01D450  000000C0   EHB
9D01D454  8FBA006C   LW K0, 108(SP)
9D01D458  8FBB0068   LW K1, 104(SP)
9D01D45C  409A7000   MTC0 K0, EPC
9D01D460  8FBA0064   LW K0, 100(SP)
9D01D464  27BD0070   ADDIU SP, SP, 112
9D01D468  409A6002   MTC0 K0, SRSCtl
9D01D46C  41DDE800   WRPGPR SP, SP
9D01D470  409B6000   MTC0 K1, Status
9D01D474  42000018   ERET
1210:                
1211:                extern volatile int nofrendo_ticks;
1212:                
1213:                void __ISR(_TIMER_1_VECTOR, IPL4AUTO) Timer1Handler(void)
1214:                	{
9D01D478  415DE800   RDPGPR SP, SP
9D01D47C  401B7000   MFC0 K1, EPC
9D01D480  401A6002   MFC0 K0, SRSCtl
9D01D484  27BDFFE8   ADDIU SP, SP, -24
9D01D488  AFBB0014   SW K1, 20(SP)
9D01D48C  401B6000   MFC0 K1, Status
9D01D490  AFBA000C   SW K0, 12(SP)
9D01D494  AFBB0010   SW K1, 16(SP)
9D01D498  7C1B7844   INS K1, ZERO, 1, 15
9D01D49C  377B1000   ORI K1, K1, 4096
9D01D4A0  409B6000   MTC0 K1, Status
9D01D4A4  AFA30004   SW V1, 4(SP)
9D01D4A8  AFA20000   SW V0, 0(SP)
1215:                    IFS0bits.T1IF = 0;
9D01D4AC  3C02BF88   LUI V0, -16504
9D01D4B0  8C431030   LW V1, 4144(V0)
9D01D4B4  7C032104   INS V1, ZERO, 4, 1
9D01D4B8  AC431030   SW V1, 4144(V0)
1216:                    ++ticks;
9D01D4BC  8F8281DC   LW V0, -32292(GP)
9D01D4C0  24420001   ADDIU V0, V0, 1
9D01D4C4  AF8281DC   SW V0, -32292(GP)
1217:                    //if (ticks % 16 == 0)
1218:                        nofrendo_ticks++;
9D01D4C8  8F82816C   LW V0, -32404(GP)
9D01D4CC  24420001   ADDIU V0, V0, 1
9D01D4D0  AF82816C   SW V0, -32404(GP)
1219:                	}
9D01D4D4  8FA2000C   LW V0, 12(SP)
9D01D4D8  3042000F   ANDI V0, V0, 15
9D01D4DC  14400003   BNE V0, ZERO, 0x9D01D4EC
9D01D4E0  00000000   NOP
9D01D4E4  8FA30004   LW V1, 4(SP)
9D01D4E8  8FA20000   LW V0, 0(SP)
9D01D4EC  41606000   DI ZERO
9D01D4F0  000000C0   EHB
9D01D4F4  8FBA0014   LW K0, 20(SP)
9D01D4F8  8FBB0010   LW K1, 16(SP)
9D01D4FC  409A7000   MTC0 K0, EPC
9D01D500  8FBA000C   LW K0, 12(SP)
9D01D504  27BD0018   ADDIU SP, SP, 24
9D01D508  409A6002   MTC0 K0, SRSCtl
9D01D50C  41DDE800   WRPGPR SP, SP
9D01D510  409B6000   MTC0 K1, Status
9D01D514  42000018   ERET
1220:                void __ISR(_EXTERNAL_2_VECTOR, IPL4AUTO) Int2Handler(void)
1221:                	{
9D01D518  415DE800   RDPGPR SP, SP
9D01D51C  401B7000   MFC0 K1, EPC
9D01D520  401A6002   MFC0 K0, SRSCtl
9D01D524  27BDFFE8   ADDIU SP, SP, -24
9D01D528  AFBB0014   SW K1, 20(SP)
9D01D52C  401B6000   MFC0 K1, Status
9D01D530  AFBA000C   SW K0, 12(SP)
9D01D534  AFBB0010   SW K1, 16(SP)
9D01D538  7C1B7844   INS K1, ZERO, 1, 15
9D01D53C  377B1000   ORI K1, K1, 4096
9D01D540  409B6000   MTC0 K1, Status
9D01D544  AFA30004   SW V1, 4(SP)
9D01D548  AFA20000   SW V0, 0(SP)
1222:                	IEC0bits.INT2IE = 0;
9D01D54C  3C02BF88   LUI V0, -16504
9D01D550  8C431060   LW V1, 4192(V0)
9D01D554  7C036B44   INS V1, ZERO, 13, 1
9D01D558  AC431060   SW V1, 4192(V0)
1223:                	}
9D01D55C  8FA2000C   LW V0, 12(SP)
9D01D560  3042000F   ANDI V0, V0, 15
9D01D564  14400003   BNE V0, ZERO, 0x9D01D574
9D01D568  00000000   NOP
9D01D56C  8FA30004   LW V1, 4(SP)
9D01D570  8FA20000   LW V0, 0(SP)
9D01D574  41606000   DI ZERO
9D01D578  000000C0   EHB
9D01D57C  8FBA0014   LW K0, 20(SP)
9D01D580  8FBB0010   LW K1, 16(SP)
9D01D584  409A7000   MTC0 K0, EPC
9D01D588  8FBA000C   LW K0, 12(SP)
9D01D58C  27BD0018   ADDIU SP, SP, 24
9D01D590  409A6002   MTC0 K0, SRSCtl
9D01D594  41DDE800   WRPGPR SP, SP
9D01D598  409B6000   MTC0 K1, Status
9D01D59C  42000018   ERET
1224:                
1225:                uint16_t get_user_value (void)
1226:                	{
9D01D5A0  27BDFFC0   ADDIU SP, SP, -64
9D01D5A4  AFBF003C   SW RA, 60(SP)
9D01D5A8  AFB20038   SW S2, 56(SP)
9D01D5AC  AFB10034   SW S1, 52(SP)
9D01D5B0  AFB00030   SW S0, 48(SP)
1227:                	int8_t temp_arr[20];
1228:                	uint8_t temp_arr_p=0,char_val,stat;
9D01D5C0  00008821   ADDU S1, ZERO, ZERO
1229:                	uint32_t retval;
1230:                	stdio_write(" :");
9D01D5B4  3C049D03   LUI A0, -25341
9D01D5B8  0F407196   JAL stdio_write
9D01D5BC  24849F78   ADDIU A0, A0, -24712
1231:                	while (1)
1232:                		{
1233:                		stat = stdio_get(&char_val);
9D01D5C8  0F4073D3   JAL stdio_get
9D01D5CC  27A40024   ADDIU A0, SP, 36
1234:                		if ((char_val!=NEWLINE)&(stat!=0))
9D01D5D0  0002802B   SLTU S0, ZERO, V0
9D01D5D4  12000017   BEQ S0, ZERO, 0x9D01D634
9D01D5D8  93A40024   LBU A0, 36(SP)
9D01D5DC  3882000A   XORI V0, A0, 10
9D01D5E0  10400014   BEQ V0, ZERO, 0x9D01D634
9D01D5E4  00000000   NOP
1235:                			{
1236:                			stdio_c(char_val);
9D01D5E8  0F40729E   JAL stdio_c
9D01D5EC  00000000   NOP
1237:                			if (char_val>=' ') temp_arr[temp_arr_p++] = char_val;
9D01D5F0  93A20024   LBU V0, 36(SP)
9D01D5F4  2C430020   SLTIU V1, V0, 32
9D01D5F8  14600006   BNE V1, ZERO, 0x9D01D614
9D01D5FC  26230001   ADDIU V1, S1, 1
9D01D600  27A40010   ADDIU A0, SP, 16
9D01D604  00918821   ADDU S1, A0, S1
9D01D608  A2220000   SB V0, 0(S1)
9D01D60C  0B40758D   J 0x9D01D634
9D01D610  307100FF   ANDI S1, V1, 255
1238:                			else if (char_val==BACKSPACE)
9D01D5C4  24120008   ADDIU S2, ZERO, 8
9D01D614  14520007   BNE V0, S2, 0x9D01D634
9D01D618  00000000   NOP
1239:                				{
1240:                				if (temp_arr_p>0) temp_arr[--temp_arr_p]=0;
9D01D61C  12200014   BEQ S1, ZERO, 0x9D01D670
9D01D620  27A30010   ADDIU V1, SP, 16
9D01D624  2631FFFF   ADDIU S1, S1, -1
9D01D628  323100FF   ANDI S1, S1, 255
9D01D62C  00711021   ADDU V0, V1, S1
9D01D630  A0400000   SB ZERO, 0(V0)
1241:                				}
1242:                			}
1243:                	    if ((char_val==NEWLINE)&(stat!=0))
9D01D634  1200000E   BEQ S0, ZERO, 0x9D01D670
9D01D638  93A20024   LBU V0, 36(SP)
9D01D63C  3842000A   XORI V0, V0, 10
9D01D640  1440000B   BNE V0, ZERO, 0x9D01D670
9D01D644  27A40010   ADDIU A0, SP, 16
1244:                			{
1245:                			temp_arr[temp_arr_p] = 0;
9D01D648  00918821   ADDU S1, A0, S1
9D01D64C  A2200000   SB ZERO, 0(S1)
1246:                			sscanf(temp_arr,"%d",&retval);
9D01D650  3C059D03   LUI A1, -25341
9D01D654  24A59F7C   ADDIU A1, A1, -24708
9D01D658  0F40ED8F   JAL .Letext0, .LFE1, _sscanf_cdnopuxX
9D01D65C  27A60028   ADDIU A2, SP, 40
1247:                			stdio_c('\n');
9D01D660  0F40729E   JAL stdio_c
9D01D664  2404000A   ADDIU A0, ZERO, 10
1248:                			return retval;
9D01D668  0B4075A0   J 0x9D01D680
9D01D66C  97A20028   LHU V0, 40(SP)
1249:                			}
1250:                		if (brk_key) return 0;
9D01D670  938281D9   LBU V0, -32295(GP)
9D01D674  7C021420   SEB V0, V0
9D01D678  1040FFD3   BEQ V0, ZERO, 0x9D01D5C8
9D01D67C  00001021   ADDU V0, ZERO, ZERO
1251:                		}
1252:                	}
9D01D680  8FBF003C   LW RA, 60(SP)
9D01D684  8FB20038   LW S2, 56(SP)
9D01D688  8FB10034   LW S1, 52(SP)
9D01D68C  8FB00030   LW S0, 48(SP)
9D01D690  03E00008   JR RA
9D01D694  27BD0040   ADDIU SP, SP, 64
1253:                
1254:                
1255:                void display_refresh_force (void)
1256:                	{
9D01D698  27BDFFE8   ADDIU SP, SP, -24
9D01D69C  AFBF0014   SW RA, 20(SP)
1257:                	tft_disp_buffer_refresh((uint8_t *)disp_buffer,(uint8_t *)color_buffer);
9D01D6A0  3C04A000   LUI A0, -24576
9D01D6A4  24841E5C   ADDIU A0, A0, 7772
9D01D6A8  3C05A000   LUI A1, -24576
9D01D6AC  0F405629   JAL tft_disp_buffer_refresh
9D01D6B0  24A51B14   ADDIU A1, A1, 6932
1258:                	}
9D01D6B4  8FBF0014   LW RA, 20(SP)
9D01D6B8  03E00008   JR RA
9D01D6BC  27BD0018   ADDIU SP, SP, 24
---  /Users/nitro/basic-badge/firmware/badge1.X/src/Z80/hwz.c  ------------------------------------------
1:                   #include "hwz.h"
2:                   #include <xc.h>
3:                   #include <plib.h>
4:                   #include <stdio.h>
5:                   #include <fcntl.h>
6:                   #include <sys/appio.h>
7:                   
8:                   #include "sim.h"
9:                   #include "simglb.h"
10:                  #include "../hw.h"
11:                  
12:                  extern const uint8_t rom_image[65536];
13:                  extern const uint8_t rd_image[131072];
14:                  extern const uint8_t rd_image2[ROMDISK2_SIZE];
15:                  uint8_t drive, sector, track,disk_temp_pointer;
16:                  uint8_t disk_temp[128],flash_buff[4096], conin_buffer[30], conin_buffer_pointer;
17:                  
18:                  uint32_t last_addr = 0xFFFFF000;
19:                  uint8_t unwritten;
20:                  
21:                  uint8_t fl_rdsr(void);
22:                  uint32_t fl_rdid(void);
23:                  
24:                  #ifdef	USE_RAM_IMAGE
25:                  extern const uint8_t ram_image[65536];
26:                  #endif
27:                  
28:                  #ifdef	USE_RAMDISK
29:                  uint8_t ram_disk[RAMDISK_SIZE];
30:                  #endif
31:                  
32:                  //void reload_cpm_warm (void)
33:                  //{
34:                  //uint16_t i;
35:                  //#ifdef	USE_RAM_IMAGE	
36:                  //	for (i=0xD400;i<(0xD400+0x1EFF);i++) ram[i] = ram_image[i];
37:                  //#endif
38:                  //}
39:                  
40:                  //-------------------device at 0x68-----------------
41:                  uint8_t rxm_sta (void)
42:                  {
43:                  /*
44:                  if (U3BSTAbits.URXDA==1) return 0xFF;
45:                  	else return 0x00;
46:                   */
47:                  }
9D02C9BC  03E00008   JR RA
9D02C9C0  00000000   NOP
48:                  uint8_t rxm_read (void)
49:                  {
50:                  /*
51:                  return U3BRXREG;
52:                   */
53:                  }
9D02C9C4  03E00008   JR RA
9D02C9C8  00000000   NOP
54:                  void txm_write (uint8_t data)
55:                  {
9D02C9CC  03E00008   JR RA
9D02C9D0  00000000   NOP
56:                  /*
57:                  U3BTXREG = data;
58:                  while (U3BSTAbits.UTXBF==1);
59:                   */
60:                  }
61:                  
62:                  void set_drive (uint8_t dat)
63:                  {
64:                  drive = dat;
9D02C9D4  A38481A0   SB A0, -32352(GP)
65:                  disk_temp_pointer = 0;
9D02C9D8  03E00008   JR RA
9D02C9DC  A380819F   SB ZERO, -32353(GP)
66:                  }
67:                  void set_sector (uint8_t dat)
68:                  {
69:                  sector = dat;
9D02C9E0  A384819E   SB A0, -32354(GP)
70:                  disk_temp_pointer = 0;
9D02C9E4  03E00008   JR RA
9D02C9E8  A380819F   SB ZERO, -32353(GP)
71:                  }
72:                  void set_track (uint8_t dat)
73:                  {
74:                  track = dat;
9D02C9EC  A38481A8   SB A0, -32344(GP)
75:                  disk_temp_pointer = 0;
9D02C9F0  03E00008   JR RA
9D02C9F4  A380819F   SB ZERO, -32353(GP)
76:                  }
77:                  
78:                  //uint8_t read_disk_byte (void)
79:                  //{
80:                  //uint8_t temp;
81:                  //uint32_t  base,ptr;
82:                  //base = (((uint32_t )(track))*16) + sector;
83:                  //if (drive==0)
84:                  //	{
85:                  //	base = base*128;
86:                  //#ifdef USE_RAMDISK
87:                  //	ptr = base + disk_temp_pointer;
88:                  //	if (ptr<RAMDISK_SIZE)
89:                  //		temp = ram_disk[ptr];
90:                  //#endif
91:                  //#ifndef	USE_RAMDISK
92:                  //	temp = 0xA5;
93:                  //#endif
94:                  //	}
95:                  //if (drive==1)
96:                  //	{
97:                  //	base = base*128;
98:                  //#ifdef	USE_ROMDISK
99:                  //	temp = rd_image[base + disk_temp_pointer];
100:                 //#endif
101:                 //	}
102:                 //if (drive==2)
103:                 //	{
104:                 //#ifdef USE_EEPROM
105:                 //	if (disk_temp_pointer==0) read_sector(disk_temp,base);
106:                 //	temp = disk_temp[disk_temp_pointer];
107:                 //#endif
108:                 //	base = base*128;
109:                 //#ifdef	USE_ROMDISK2
110:                 //	temp = rd_image2[base + disk_temp_pointer];
111:                 //#endif
112:                 //	}
113:                 //
114:                 //if (drive==3)
115:                 //	{
116:                 //	if (disk_temp_pointer==0) fl_read_128(base+(CPM1_DISK1_OFFSET),disk_temp);
117:                 //	temp = disk_temp[disk_temp_pointer];
118:                 //	}
119:                 //if (drive==4)
120:                 //	{
121:                 //	}
122:                 //if (drive==5)
123:                 //	{
124:                 //	}
125:                 //if (drive==6)
126:                 //	{
127:                 //	}
128:                 //
129:                 //disk_temp_pointer++;
130:                 //return temp;
131:                 //}
132:                 //
133:                 //void write_disk_byte (uint8_t dat)
134:                 //{
135:                 //uint8_t temp;
136:                 //uint32_t base;
137:                 //uint32_t  ptr;
138:                 //base = (((unsigned int)(track))*16) + sector;
139:                 //if (drive==0)
140:                 //	{
141:                 //#ifdef	USE_RAMDISK
142:                 //	base = base*128;
143:                 //	ptr = base + disk_temp_pointer;
144:                 //	if (ptr<RAMDISK_SIZE)
145:                 //		ram_disk[ptr] = dat;
146:                 //#endif
147:                 //	}
148:                 //if (drive==1)
149:                 //	{
150:                 //	//rom disk, no writes allowed
151:                 //	}
152:                 //if (drive==2)
153:                 //	{
154:                 //#ifdef USE_EEPROM
155:                 //	disk_temp[disk_temp_pointer] = dat;
156:                 //	if (disk_temp_pointer==127) 
157:                 //		{
158:                 //		ee_wren();
159:                 //		write_sector(disk_temp,base);
160:                 //		}
161:                 //#endif
162:                 //	}
163:                 //if (drive==3)
164:                 //	{
165:                 //	disk_temp[disk_temp_pointer] = dat;
166:                 //	if (disk_temp_pointer==127) 
167:                 //		{
168:                 //		fl_write_128(base+(CPM1_DISK1_OFFSET),disk_temp);
169:                 //		}
170:                 //	}
171:                 //if (drive==4)
172:                 //	{
173:                 //	}
174:                 //if (drive==5)
175:                 //	{
176:                 //	}
177:                 //if (drive==6)
178:                 //	{
179:                 //	}
180:                 //disk_temp_pointer++;
181:                 //}
182:                 
183:                 uint8_t fl_rdsr(void)
184:                 {
9D02C9F8  27BDFFE0   ADDIU SP, SP, -32
9D02C9FC  AFBF001C   SW RA, 28(SP)
9D02CA00  AFB00018   SW S0, 24(SP)
185:                 volatile uint8_t temp;
186:                 CS_FLASH = 0;
9D02CA04  3C10BF88   LUI S0, -16504
9D02CA08  92026530   LBU V0, 25904(S0)
9D02CA0C  7C021084   INS V0, ZERO, 2, 1
9D02CA10  A2026530   SB V0, 25904(S0)
187:                 SPI_dat(0x05);
9D02CA14  0F407EEF   JAL SPI_dat
9D02CA18  24040005   ADDIU A0, ZERO, 5
188:                 temp = SPI_dat(0xFF);
9D02CA1C  0F407EEF   JAL SPI_dat
9D02CA20  240400FF   ADDIU A0, ZERO, 255
9D02CA24  A3A20010   SB V0, 16(SP)
189:                 CS_FLASH = 1;
9D02CA28  92026530   LBU V0, 25904(S0)
9D02CA2C  24030001   ADDIU V1, ZERO, 1
9D02CA30  7C621084   INS V0, V1, 2, 1
9D02CA34  A2026530   SB V0, 25904(S0)
190:                 return temp;
9D02CA38  93A20010   LBU V0, 16(SP)
191:                 }
9D02CA3C  304200FF   ANDI V0, V0, 255
9D02CA40  8FBF001C   LW RA, 28(SP)
9D02CA44  8FB00018   LW S0, 24(SP)
9D02CA48  03E00008   JR RA
9D02CA4C  27BD0020   ADDIU SP, SP, 32
192:                 
193:                 
194:                 uint32_t fl_rdid(void)
195:                 {
9D02CA50  27BDFFE0   ADDIU SP, SP, -32
9D02CA54  AFBF001C   SW RA, 28(SP)
9D02CA58  AFB20018   SW S2, 24(SP)
9D02CA5C  AFB10014   SW S1, 20(SP)
9D02CA60  AFB00010   SW S0, 16(SP)
196:                 uint8_t temp1,temp2,temp3;
197:                 uint32_t retval;
198:                 CS_FLASH = 0;
9D02CA64  3C10BF88   LUI S0, -16504
9D02CA68  92026530   LBU V0, 25904(S0)
9D02CA6C  7C021084   INS V0, ZERO, 2, 1
9D02CA70  A2026530   SB V0, 25904(S0)
199:                 SPI_dat(0x9F);
9D02CA74  0F407EEF   JAL SPI_dat
9D02CA78  2404009F   ADDIU A0, ZERO, 159
200:                 temp3 = SPI_dat(0xFF);
9D02CA7C  0F407EEF   JAL SPI_dat
9D02CA80  240400FF   ADDIU A0, ZERO, 255
9D02CA84  00409021   ADDU S2, V0, ZERO
201:                 temp2 = SPI_dat(0x55);
9D02CA88  0F407EEF   JAL SPI_dat
9D02CA8C  24040055   ADDIU A0, ZERO, 85
9D02CA90  00408821   ADDU S1, V0, ZERO
202:                 temp1 = SPI_dat(0xAA);
9D02CA94  0F407EEF   JAL SPI_dat
9D02CA98  240400AA   ADDIU A0, ZERO, 170
203:                 CS_FLASH = 1;
9D02CA9C  92036530   LBU V1, 25904(S0)
9D02CAA0  24040001   ADDIU A0, ZERO, 1
9D02CAA4  7C831084   INS V1, A0, 2, 1
9D02CAA8  A2036530   SB V1, 25904(S0)
204:                 retval = (((uint32_t)(temp3))<<16)|(((uint32_t)(temp2))<<8)|(((uint32_t)(temp1))<<0);
9D02CAAC  00129400   SLL S2, S2, 16
9D02CAB0  00118A00   SLL S1, S1, 8
9D02CAB4  02518825   OR S1, S2, S1
205:                 return retval;
206:                 }
9D02CAB8  02221025   OR V0, S1, V0
9D02CABC  8FBF001C   LW RA, 28(SP)
9D02CAC0  8FB20018   LW S2, 24(SP)
9D02CAC4  8FB10014   LW S1, 20(SP)
9D02CAC8  8FB00010   LW S0, 16(SP)
9D02CACC  03E00008   JR RA
9D02CAD0  27BD0020   ADDIU SP, SP, 32
207:                 
208:                 void fl_read_4k(uint32_t  addr, uint8_t * data)
209:                 {
9D02CAD4  27BDFFE0   ADDIU SP, SP, -32
9D02CAD8  AFBF001C   SW RA, 28(SP)
9D02CADC  AFB10018   SW S1, 24(SP)
9D02CAE0  AFB00014   SW S0, 20(SP)
9D02CAE4  00808821   ADDU S1, A0, ZERO
9D02CAE8  00A08021   ADDU S0, A1, ZERO
210:                 uint16_t i;
211:                 CS_FLASH = 0;
9D02CAEC  3C02BF88   LUI V0, -16504
9D02CAF0  90436530   LBU V1, 25904(V0)
9D02CAF4  7C031084   INS V1, ZERO, 2, 1
9D02CAF8  A0436530   SB V1, 25904(V0)
212:                 SPI_dat(0x03);
9D02CAFC  0F407EEF   JAL SPI_dat
9D02CB00  24040003   ADDIU A0, ZERO, 3
213:                 SPI_dat((addr>>16)&0xFF);
9D02CB04  0F407EEF   JAL SPI_dat
9D02CB08  7E243C00   EXT A0, S1, 16, 8
214:                 SPI_dat((addr>>8)&0xFF);
9D02CB0C  0F407EEF   JAL SPI_dat
9D02CB10  7E243A00   EXT A0, S1, 8, 8
215:                 SPI_dat((addr>>0)&0xFF);
9D02CB14  0F407EEF   JAL SPI_dat
9D02CB18  322400FF   ANDI A0, S1, 255
9D02CB1C  26111000   ADDIU S1, S0, 4096
216:                 for (i=0;i<4096;i++) *data++ = SPI_dat(0xFF);
9D02CB20  26100001   ADDIU S0, S0, 1
9D02CB24  0F407EEF   JAL SPI_dat
9D02CB28  240400FF   ADDIU A0, ZERO, 255
9D02CB2C  1611FFFC   BNE S0, S1, 0x9D02CB20
9D02CB30  A202FFFF   SB V0, -1(S0)
217:                 CS_FLASH = 1;
9D02CB34  3C02BF88   LUI V0, -16504
9D02CB38  90436530   LBU V1, 25904(V0)
9D02CB3C  24040001   ADDIU A0, ZERO, 1
9D02CB40  7C831084   INS V1, A0, 2, 1
9D02CB44  A0436530   SB V1, 25904(V0)
218:                 }
9D02CB48  8FBF001C   LW RA, 28(SP)
9D02CB4C  8FB10018   LW S1, 24(SP)
9D02CB50  8FB00014   LW S0, 20(SP)
9D02CB54  03E00008   JR RA
9D02CB58  27BD0020   ADDIU SP, SP, 32
219:                 
220:                 void fl_read_nk(uint32_t  addr, uint8_t * data, uint16_t n)
221:                 {
9D02CB5C  27BDFFE0   ADDIU SP, SP, -32
9D02CB60  AFBF001C   SW RA, 28(SP)
9D02CB64  AFB20018   SW S2, 24(SP)
9D02CB68  AFB10014   SW S1, 20(SP)
9D02CB6C  AFB00010   SW S0, 16(SP)
9D02CB70  00808821   ADDU S1, A0, ZERO
9D02CB74  00A08021   ADDU S0, A1, ZERO
9D02CB78  00C09021   ADDU S2, A2, ZERO
222:                 uint16_t i;
223:                 CS_FLASH = 0;
9D02CB7C  3C02BF88   LUI V0, -16504
9D02CB80  90436530   LBU V1, 25904(V0)
9D02CB84  7C031084   INS V1, ZERO, 2, 1
9D02CB88  A0436530   SB V1, 25904(V0)
224:                 SPI_dat(0x03);
9D02CB8C  0F407EEF   JAL SPI_dat
9D02CB90  24040003   ADDIU A0, ZERO, 3
225:                 SPI_dat((addr>>16)&0xFF);
9D02CB94  0F407EEF   JAL SPI_dat
9D02CB98  7E243C00   EXT A0, S1, 16, 8
226:                 SPI_dat((addr>>8)&0xFF);
9D02CB9C  0F407EEF   JAL SPI_dat
9D02CBA0  7E243A00   EXT A0, S1, 8, 8
227:                 SPI_dat((addr>>0)&0xFF);
9D02CBA4  0F407EEF   JAL SPI_dat
9D02CBA8  322400FF   ANDI A0, S1, 255
228:                 for (i=0;i<n;i++) *data++ = SPI_dat(0xFF);
9D02CBAC  12400009   BEQ S2, ZERO, 0x9D02CBD4
9D02CBB0  2651FFFF   ADDIU S1, S2, -1
9D02CBB4  3231FFFF   ANDI S1, S1, -1
9D02CBB8  26310001   ADDIU S1, S1, 1
9D02CBBC  02118821   ADDU S1, S0, S1
9D02CBC0  26100001   ADDIU S0, S0, 1
9D02CBC4  0F407EEF   JAL SPI_dat
9D02CBC8  240400FF   ADDIU A0, ZERO, 255
9D02CBCC  1611FFFC   BNE S0, S1, 0x9D02CBC0
9D02CBD0  A202FFFF   SB V0, -1(S0)
229:                 CS_FLASH = 1;
9D02CBD4  3C02BF88   LUI V0, -16504
9D02CBD8  90436530   LBU V1, 25904(V0)
9D02CBDC  24040001   ADDIU A0, ZERO, 1
9D02CBE0  7C831084   INS V1, A0, 2, 1
9D02CBE4  A0436530   SB V1, 25904(V0)
230:                 }
9D02CBE8  8FBF001C   LW RA, 28(SP)
9D02CBEC  8FB20018   LW S2, 24(SP)
9D02CBF0  8FB10014   LW S1, 20(SP)
9D02CBF4  8FB00010   LW S0, 16(SP)
9D02CBF8  03E00008   JR RA
9D02CBFC  27BD0020   ADDIU SP, SP, 32
231:                 
232:                 
233:                 void fl_erase_4k(uint32_t  addr)
234:                 {
9D02CC44  27BDFFE0   ADDIU SP, SP, -32
9D02CC48  AFBF001C   SW RA, 28(SP)
9D02CC4C  AFB10018   SW S1, 24(SP)
9D02CC50  AFB00014   SW S0, 20(SP)
235:                 uint16_t i;
236:                 fl_wren();
9D02CC54  0F40B300   JAL fl_wren
9D02CC58  00808821   ADDU S1, A0, ZERO
237:                 CS_FLASH = 0;
9D02CC5C  3C10BF88   LUI S0, -16504
9D02CC60  92026530   LBU V0, 25904(S0)
9D02CC64  7C021084   INS V0, ZERO, 2, 1
9D02CC68  A2026530   SB V0, 25904(S0)
238:                 SPI_dat(0x20);
9D02CC6C  0F407EEF   JAL SPI_dat
9D02CC70  24040020   ADDIU A0, ZERO, 32
239:                 SPI_dat((addr>>16)&0xFF);
9D02CC74  0F407EEF   JAL SPI_dat
9D02CC78  7E243C00   EXT A0, S1, 16, 8
240:                 SPI_dat((addr>>8)&0xFF);
9D02CC7C  0F407EEF   JAL SPI_dat
9D02CC80  7E243A00   EXT A0, S1, 8, 8
241:                 SPI_dat((addr>>0)&0xFF);
9D02CC84  0F407EEF   JAL SPI_dat
9D02CC88  322400FF   ANDI A0, S1, 255
242:                 CS_FLASH = 1;
9D02CC8C  92026530   LBU V0, 25904(S0)
9D02CC90  24030001   ADDIU V1, ZERO, 1
9D02CC94  7C621084   INS V0, V1, 2, 1
9D02CC98  A2026530   SB V0, 25904(S0)
243:                 while ((fl_rdsr())&0x01);
9D02CC9C  0F40B27E   JAL fl_rdsr
9D02CCA0  00000000   NOP
9D02CCA4  30420001   ANDI V0, V0, 1
9D02CCA8  1440FFFC   BNE V0, ZERO, 0x9D02CC9C
9D02CCAC  8FBF001C   LW RA, 28(SP)
244:                 }
9D02CCB0  8FB10018   LW S1, 24(SP)
9D02CCB4  8FB00014   LW S0, 20(SP)
9D02CCB8  03E00008   JR RA
9D02CCBC  27BD0020   ADDIU SP, SP, 32
245:                 
246:                 
247:                 void fl_write(uint32_t  addr,uint8_t data)
248:                 {
9D02CCC0  27BDFFE0   ADDIU SP, SP, -32
9D02CCC4  AFBF001C   SW RA, 28(SP)
9D02CCC8  AFB20018   SW S2, 24(SP)
9D02CCCC  AFB10014   SW S1, 20(SP)
9D02CCD0  AFB00010   SW S0, 16(SP)
9D02CCD4  00808821   ADDU S1, A0, ZERO
249:                 uint16_t i;
250:                 fl_wren();
9D02CCD8  0F40B300   JAL fl_wren
9D02CCDC  00A09021   ADDU S2, A1, ZERO
251:                 CS_FLASH = 0;
9D02CCE0  3C10BF88   LUI S0, -16504
9D02CCE4  92026530   LBU V0, 25904(S0)
9D02CCE8  7C021084   INS V0, ZERO, 2, 1
9D02CCEC  A2026530   SB V0, 25904(S0)
252:                 SPI_dat(0x02);
9D02CCF0  0F407EEF   JAL SPI_dat
9D02CCF4  24040002   ADDIU A0, ZERO, 2
253:                 SPI_dat((addr>>16)&0xFF);
9D02CCF8  0F407EEF   JAL SPI_dat
9D02CCFC  7E243C00   EXT A0, S1, 16, 8
254:                 SPI_dat((addr>>8)&0xFF);
9D02CD00  0F407EEF   JAL SPI_dat
9D02CD04  7E243A00   EXT A0, S1, 8, 8
255:                 SPI_dat((addr>>0)&0xFF);
9D02CD08  0F407EEF   JAL SPI_dat
9D02CD0C  322400FF   ANDI A0, S1, 255
256:                 SPI_dat(data);
9D02CD10  0F407EEF   JAL SPI_dat
9D02CD14  02402021   ADDU A0, S2, ZERO
257:                 CS_FLASH = 1;
9D02CD18  92026530   LBU V0, 25904(S0)
9D02CD1C  24030001   ADDIU V1, ZERO, 1
9D02CD20  7C621084   INS V0, V1, 2, 1
9D02CD24  A2026530   SB V0, 25904(S0)
258:                 }
9D02CD28  8FBF001C   LW RA, 28(SP)
9D02CD2C  8FB20018   LW S2, 24(SP)
9D02CD30  8FB10014   LW S1, 20(SP)
9D02CD34  8FB00010   LW S0, 16(SP)
9D02CD38  03E00008   JR RA
9D02CD3C  27BD0020   ADDIU SP, SP, 32
259:                 
260:                 void fl_rst_pb(void)
261:                 {
9D02CD40  27BDFFE8   ADDIU SP, SP, -24
9D02CD44  AFBF0014   SW RA, 20(SP)
262:                 /*
263:                 CS_FLASH = 0;
264:                 SPI_dat(0x50);
265:                 CS_FLASH = 1;
266:                 */
267:                 fl_wren();
9D02CD48  0F40B300   JAL fl_wren
9D02CD4C  AFB00010   SW S0, 16(SP)
268:                 CS_FLASH = 0;
9D02CD50  3C10BF88   LUI S0, -16504
9D02CD54  92026530   LBU V0, 25904(S0)
9D02CD58  7C021084   INS V0, ZERO, 2, 1
9D02CD5C  A2026530   SB V0, 25904(S0)
269:                 SPI_dat(0x01);
9D02CD60  0F407EEF   JAL SPI_dat
9D02CD64  24040001   ADDIU A0, ZERO, 1
270:                 SPI_dat(0x00);
9D02CD68  0F407EEF   JAL SPI_dat
9D02CD6C  00002021   ADDU A0, ZERO, ZERO
271:                 CS_FLASH = 1;
9D02CD70  92026530   LBU V0, 25904(S0)
9D02CD74  24030001   ADDIU V1, ZERO, 1
9D02CD78  7C621084   INS V0, V1, 2, 1
9D02CD7C  A2026530   SB V0, 25904(S0)
272:                 }
9D02CD80  8FBF0014   LW RA, 20(SP)
9D02CD84  8FB00010   LW S0, 16(SP)
9D02CD88  03E00008   JR RA
9D02CD8C  27BD0018   ADDIU SP, SP, 24
273:                 
274:                 void fl_wren(void)
275:                 {
9D02CC00  27BDFFE8   ADDIU SP, SP, -24
9D02CC04  AFBF0014   SW RA, 20(SP)
9D02CC08  AFB00010   SW S0, 16(SP)
276:                 CS_FLASH = 0;
9D02CC0C  3C10BF88   LUI S0, -16504
9D02CC10  92026530   LBU V0, 25904(S0)
9D02CC14  7C021084   INS V0, ZERO, 2, 1
9D02CC18  A2026530   SB V0, 25904(S0)
277:                 SPI_dat(0x06);
9D02CC1C  0F407EEF   JAL SPI_dat
9D02CC20  24040006   ADDIU A0, ZERO, 6
278:                 CS_FLASH = 1;
9D02CC24  92026530   LBU V0, 25904(S0)
9D02CC28  24030001   ADDIU V1, ZERO, 1
9D02CC2C  7C621084   INS V0, V1, 2, 1
9D02CC30  A2026530   SB V0, 25904(S0)
279:                 }
9D02CC34  8FBF0014   LW RA, 20(SP)
9D02CC38  8FB00010   LW S0, 16(SP)
9D02CC3C  03E00008   JR RA
9D02CC40  27BD0018   ADDIU SP, SP, 24
280:                 
281:                 
282:                 void fl_write_4k(uint32_t  addr, uint8_t * data)
283:                 {
9D02CD90  27BDFFE0   ADDIU SP, SP, -32
9D02CD94  AFBF001C   SW RA, 28(SP)
9D02CD98  AFB20018   SW S2, 24(SP)
9D02CD9C  AFB10014   SW S1, 20(SP)
9D02CDA0  AFB00010   SW S0, 16(SP)
9D02CDA4  24B21000   ADDIU S2, A1, 4096
9D02CDA8  00A08021   ADDU S0, A1, ZERO
9D02CDAC  00858823   SUBU S1, A0, A1
9D02CDB0  02112021   ADDU A0, S0, S1
284:                 uint16_t i;
285:                 for (i=0;i<4096;i++) 
9D02CDD4  1612FFF7   BNE S0, S2, 0x9D02CDB4
9D02CDD8  02112021   ADDU A0, S0, S1
286:                 	{
287:                 	fl_write(addr+i,*data++);
9D02CDB4  26100001   ADDIU S0, S0, 1
9D02CDB8  0F40B330   JAL fl_write
9D02CDBC  9205FFFF   LBU A1, -1(S0)
288:                 	while ((fl_rdsr())&0x01);
9D02CDC0  0F40B27E   JAL fl_rdsr
9D02CDC4  00000000   NOP
9D02CDC8  30420001   ANDI V0, V0, 1
9D02CDCC  1440FFFC   BNE V0, ZERO, .LVL62
9D02CDD0  00000000   NOP
289:                 	}
290:                 }
9D02CDDC  8FBF001C   LW RA, 28(SP)
9D02CDE0  8FB20018   LW S2, 24(SP)
9D02CDE4  8FB10014   LW S1, 20(SP)
9D02CDE8  8FB00010   LW S0, 16(SP)
9D02CDEC  03E00008   JR RA
9D02CDF0  27BD0020   ADDIU SP, SP, 32
291:                 
292:                 void fl_write_128(uint32_t sector,uint8_t * data)
293:                 {
9D02CDF4  27BDFFE0   ADDIU SP, SP, -32
9D02CDF8  AFBF001C   SW RA, 28(SP)
9D02CDFC  AFB20018   SW S2, 24(SP)
9D02CE00  AFB10014   SW S1, 20(SP)
9D02CE04  AFB00010   SW S0, 16(SP)
294:                 uint32_t  addr;
295:                 uint8_t i;
296:                 addr = ((uint32_t )(sector))*128UL;
9D02CE08  000491C0   SLL S2, A0, 7
297:                 addr = addr&0xFFFFF000;
9D02CE0C  2402F000   ADDIU V0, ZERO, -4096
9D02CE10  02428824   AND S1, S2, V0
298:                 #ifdef	FLASH_BUFFERING	
299:                 if (last_addr!=addr)
9D02CE14  8F848044   LW A0, -32700(GP)
9D02CE18  10910017   BEQ A0, S1, 0x9D02CE78
9D02CE1C  00A08021   ADDU S0, A1, ZERO
300:                 	{
301:                 	if (last_addr!=0xFFFFF000)
9D02CE20  50820008   BEQL A0, V0, 0x9D02CE44
9D02CE24  02202021   ADDU A0, S1, ZERO
302:                 		{
303:                 		fl_erase_4k(last_addr);
9D02CE28  0F40B311   JAL fl_erase_4k
9D02CE2C  00000000   NOP
304:                 		fl_write_4k(last_addr,flash_buff);
9D02CE30  8F848044   LW A0, -32700(GP)
9D02CE34  3C05A000   LUI A1, -24576
9D02CE38  0F40B364   JAL fl_write_4k
9D02CE3C  24A50978   ADDIU A1, A1, 2424
305:                 		}
306:                 	fl_read_4k(addr,flash_buff);
9D02CE40  02202021   ADDU A0, S1, ZERO
9D02CE44  3C05A000   LUI A1, -24576
9D02CE48  0F40B2B5   JAL fl_read_4k
9D02CE4C  24A50978   ADDIU A1, A1, 2424
307:                 	last_addr = addr;
9D02CE50  0B40B39E   J 0x9D02CE78
9D02CE54  AF918044   SW S1, -32700(GP)
9D02CE58  02021821   ADDU V1, S0, V0
308:                 	}
309:                 unwritten = 1;
9D02CE78  24020001   ADDIU V0, ZERO, 1
9D02CE7C  A382819D   SB V0, -32355(GP)
310:                 #endif
311:                 #ifndef	FLASH_BUFFERING	
312:                 fl_read_4k(addr,flash_buff);
313:                 #endif
314:                 addr = ((uint32_t )(sector))*128UL;
315:                 addr = addr&0x00000FFF;
9D02CE80  32520FFF   ANDI S2, S2, 4095
9D02CE84  00001021   ADDU V0, ZERO, ZERO
9D02CE88  3C06A000   LUI A2, -24576
9D02CE8C  24C60978   ADDIU A2, A2, 2424
9D02CE90  00D23021   ADDU A2, A2, S2
316:                 for (i=0;i<128;i++) flash_buff[addr+i] = data[i];
9D02CE5C  90640000   LBU A0, 0(V1)
9D02CE60  00C21821   ADDU V1, A2, V0
9D02CE64  24420001   ADDIU V0, V0, 1
9D02CE68  1445FFFB   BNE V0, A1, 0x9D02CE58
9D02CE6C  A0640000   SB A0, 0(V1)
9D02CE70  0B40B3A7   J 0x9D02CE9C
9D02CE74  8FBF001C   LW RA, 28(SP)
9D02CE94  0B40B396   J 0x9D02CE58
9D02CE98  24050080   ADDIU A1, ZERO, 128
317:                 addr = ((uint32_t )(sector))*128UL;
318:                 addr = addr&0xFFFFF000;
319:                 #ifndef	FLASH_BUFFERING	
320:                 fl_erase_4k(addr);
321:                 fl_write_4k(addr,flash_buff);
322:                 #endif
323:                 }
9D02CE9C  8FB20018   LW S2, 24(SP)
9D02CEA0  8FB10014   LW S1, 20(SP)
9D02CEA4  8FB00010   LW S0, 16(SP)
9D02CEA8  03E00008   JR RA
9D02CEAC  27BD0020   ADDIU SP, SP, 32
324:                 
325:                 void fl_read_128(uint32_t sector,uint8_t * data)
326:                 {
9D02CEB0  27BDFFE0   ADDIU SP, SP, -32
9D02CEB4  AFBF001C   SW RA, 28(SP)
9D02CEB8  AFB10018   SW S1, 24(SP)
9D02CEBC  AFB00014   SW S0, 20(SP)
9D02CEC0  00808821   ADDU S1, A0, ZERO
327:                 uint32_t  addr;
328:                 #ifdef	FLASH_BUFFERING	
329:                 if (unwritten == 1)
9D02CEC4  9383819D   LBU V1, -32355(GP)
9D02CEC8  24020001   ADDIU V0, ZERO, 1
9D02CECC  1462000A   BNE V1, V0, 0x9D02CEF8
9D02CED0  00A08021   ADDU S0, A1, ZERO
330:                 	{
331:                 	fl_erase_4k(last_addr);
9D02CED4  0F40B311   JAL fl_erase_4k
9D02CED8  8F848044   LW A0, -32700(GP)
332:                 	fl_write_4k(last_addr,flash_buff);
9D02CEDC  8F848044   LW A0, -32700(GP)
9D02CEE0  3C05A000   LUI A1, -24576
9D02CEE4  0F40B364   JAL fl_write_4k
9D02CEE8  24A50978   ADDIU A1, A1, 2424
333:                 	unwritten = 0;	
9D02CEEC  A380819D   SB ZERO, -32355(GP)
334:                 	last_addr = 0xFFFFF000;
9D02CEF0  2402F000   ADDIU V0, ZERO, -4096
9D02CEF4  AF828044   SW V0, -32700(GP)
335:                 	}
336:                 #endif
337:                 addr = ((uint32_t )(sector))*128UL;
338:                 fl_read_nk(addr,data,128);
9D02CEF8  001121C0   SLL A0, S1, 7
9D02CEFC  02002821   ADDU A1, S0, ZERO
9D02CF00  0F40B2D7   JAL fl_read_nk
9D02CF04  24060080   ADDIU A2, ZERO, 128
339:                 }
9D02CF08  8FBF001C   LW RA, 28(SP)
9D02CF0C  8FB10018   LW S1, 24(SP)
9D02CF10  8FB00014   LW S0, 20(SP)
9D02CF14  03E00008   JR RA
9D02CF18  27BD0020   ADDIU SP, SP, 32
340:                 
341:                 uint8_t init_first_x_sects (uint8_t i, uint8_t verify)			//format directory area
342:                 {
9D02CF1C  27BDFFD0   ADDIU SP, SP, -48
9D02CF20  AFBF002C   SW RA, 44(SP)
9D02CF24  AFB60028   SW S6, 40(SP)
9D02CF28  AFB50024   SW S5, 36(SP)
9D02CF2C  AFB40020   SW S4, 32(SP)
9D02CF30  AFB3001C   SW S3, 28(SP)
9D02CF34  AFB20018   SW S2, 24(SP)
9D02CF38  AFB10014   SW S1, 20(SP)
9D02CF3C  AFB00010   SW S0, 16(SP)
9D02CF40  0080A021   ADDU S4, A0, ZERO
9D02CF44  00A0A821   ADDU S5, A1, ZERO
9D02CF48  3C02A000   LUI V0, -24576
9D02CF4C  244208D8   ADDIU V0, V0, 2264
9D02CF50  24500080   ADDIU S0, V0, 128
343:                 uint32_t j,k;
344:                 for (j=0;j<128;j++) disk_temp[j]=0xE5;
9D02CF54  2403FFE5   ADDIU V1, ZERO, -27
9D02CF58  A0430000   SB V1, 0(V0)
9D02CF5C  24420001   ADDIU V0, V0, 1
9D02CF60  5450FFFE   BNEL V0, S0, 0x9D02CF5C
9D02CF64  A0430000   SB V1, 0(V0)
345:                 #ifdef USE_EEPROM
346:                 for (j=0;j<i;j++) 
347:                 	{
348:                 	ee_wren();
349:                 	write_sector(disk_temp,j);
350:                 	}
351:                 #endif
352:                 for (j=0;j<i;j++) 
9D02CF68  12800023   BEQ S4, ZERO, 0x9D02CFF8
9D02CF6C  26931000   ADDIU S3, S4, 4096
9D02CF70  24111000   ADDIU S1, ZERO, 4096
9D02CF8C  1633FFFC   BNE S1, S3, 0x9D02CF80
9D02CF90  02202021   ADDU A0, S1, ZERO
9D02CF94  0B40B402   J 0x9D02D008
9D02CF98  00000000   NOP
353:                 	{
354:                 	fl_write_128(j+(1*4096),disk_temp);
9D02CF74  3C12A000   LUI S2, -24576
9D02CF78  265208D8   ADDIU S2, S2, 2264
9D02CF7C  02202021   ADDU A0, S1, ZERO
9D02CF80  0F40B37D   JAL fl_write_128
9D02CF84  02402821   ADDU A1, S2, ZERO
9D02CF88  26310001   ADDIU S1, S1, 1
355:                 	}
356:                 
357:                 if (verify!=0)
9D02CF9C  24131000   ADDIU S3, ZERO, 4096
9D02D008  16A0FFE4   BNE S5, ZERO, 0x9D02CF9C
9D02D00C  26961000   ADDIU S6, S4, 4096
358:                 	{
359:                 	for (j=0;j<i;j++) 
9D02CFE8  1676FFF2   BNE S3, S6, 0x9D02CFB4
9D02CFEC  02602021   ADDU A0, S3, ZERO
9D02CFF0  0B40B400   J 0x9D02D000
9D02CFF4  00001021   ADDU V0, ZERO, ZERO
360:                 		{
361:                 		fl_read_128(j+(1*4096),disk_temp);
9D02CFA0  3C12A000   LUI S2, -24576
9D02CFA4  265508D8   ADDIU S5, S2, 2264
9D02CFB0  02602021   ADDU A0, S3, ZERO
9D02CFB4  0F40B3AC   JAL fl_read_128
9D02CFB8  02A02821   ADDU A1, S5, ZERO
362:                 		for (k=0;k<128;k++) 
9D02CFDC  5602FFFC   BNEL S0, V0, 0x9D02CFD0
9D02CFE0  90430000   LBU V1, 0(V0)
9D02CFE4  26730001   ADDIU S3, S3, 1
363:                 			{
364:                 			if (disk_temp[k]!=0xE5)
9D02CFA8  241100E5   ADDIU S1, ZERO, 229
9D02CFAC  3C14A000   LUI S4, -24576
9D02CFBC  924208D8   LBU V0, 2264(S2)
9D02CFC0  14510014   BNE V0, S1, 0x9D02D014
9D02CFC4  24020001   ADDIU V0, ZERO, 1
9D02CFC8  268208D9   ADDIU V0, S4, 2265
9D02CFCC  90430000   LBU V1, 0(V0)
9D02CFD0  54710010   BNEL V1, S1, 0x9D02D014
9D02CFD4  24020001   ADDIU V0, ZERO, 1
9D02CFD8  24420001   ADDIU V0, V0, 1
365:                 				{
366:                 				return 1;
367:                 				}
368:                 			}
369:                 		}
370:                 	}
371:                 return 0;
9D02CFF8  0B40B405   J 0x9D02D014
9D02CFFC  00001021   ADDU V0, ZERO, ZERO
9D02D010  00001021   ADDU V0, ZERO, ZERO
372:                 }
9D02D000  0B40B406   J 0x9D02D018
9D02D004  8FBF002C   LW RA, 44(SP)
9D02D014  8FBF002C   LW RA, 44(SP)
9D02D018  8FB60028   LW S6, 40(SP)
9D02D01C  8FB50024   LW S5, 36(SP)
9D02D020  8FB40020   LW S4, 32(SP)
9D02D024  8FB3001C   LW S3, 28(SP)
9D02D028  8FB20018   LW S2, 24(SP)
9D02D02C  8FB10014   LW S1, 20(SP)
9D02D030  8FB00010   LW S0, 16(SP)
9D02D034  03E00008   JR RA
9D02D038  27BD0030   ADDIU SP, SP, 48
373:                 
374:                 
375:                 
376:                 #ifdef USE_EEPROM
377:                 void write_sector (unsigned char *data, unsigned int addr)
378:                 {
379:                 unsigned char i,temp;
380:                 CS_MEM = 0;
381:                 SPI_dat(0x02);
382:                 temp = (addr>>9);
383:                 SPI_dat(temp);
384:                 temp = (addr>>1);
385:                 SPI_dat(temp);
386:                 temp = (addr<<7);
387:                 SPI_dat(temp);
388:                 
389:                 for (i=0;i<128;i++) 
390:                 	SPI_dat(data[i]);
391:                 
392:                 CS_MEM = 1;
393:                 temp = ee_rs();
394:                 temp = temp&0x01;
395:                 
396:                 while (temp>0)
397:                 	{
398:                 	temp = ee_rs();
399:                 	temp = temp&0x01;
400:                 	}
401:                 }
402:                 
403:                 void read_sector (unsigned char *data, unsigned int addr)
404:                 {
405:                 unsigned char i,temp;
406:                 CS_MEM = 0;
407:                 SPI_dat(0x03);
408:                 temp = (addr>>9);
409:                 SPI_dat(temp);
410:                 temp = (addr>>1);
411:                 SPI_dat(temp);
412:                 temp = (addr<<7);
413:                 SPI_dat(temp);
414:                 
415:                 
416:                 for (i=0;i<128;i++) 
417:                 	{
418:                 	*data = SPI_dat(0xFF);
419:                 	*data++;
420:                 	}
421:                 
422:                 CS_MEM = 1;
423:                 }
424:                 unsigned char ee_rs (void)
425:                 {
426:                 unsigned char temp;
427:                 CS_MEM = 0;
428:                 SPI_dat(0x05);
429:                 temp = SPI_dat(0xFF);
430:                 CS_MEM = 1;
431:                 return temp;
432:                 }
433:                 
434:                 void ee_wren (void)
435:                 {
436:                 CS_MEM = 0;
437:                 SPI_dat(0x06);
438:                 CS_MEM = 1;
439:                 }
440:                 
441:                 void ee_wrdi (void)
442:                 {
443:                 CS_MEM = 0;
444:                 SPI_dat(0x04);
445:                 CS_MEM = 1;
446:                 }
447:                 
448:                 #endif
---  /Users/bamboo/Applications/Bamboo-agent/build/bamboo-agent1/xml-data/build-dir/XC32-TBC-TY/builddir/pic32m-source/src48x/gcc/libgcc/libgcc2.c
9D03C3D4  10C00009   BEQ A2, ZERO, 0x9D03C3FC
9D03C3D8  00801021   ADDU V0, A0, ZERO
9D03C3DC  24020020   ADDIU V0, ZERO, 32
9D03C3E0  00461023   SUBU V0, V0, A2
9D03C3E4  18400007   BLEZ V0, 0x9D03C404
9D03C3E8  00C42006   SRLV A0, A0, A2
9D03C408  00001821   ADDU V1, ZERO, ZERO
9D03C404  00021023   SUBU V0, ZERO, V0
9D03C3EC  00451004   SLLV V0, A1, V0
9D03C3F0  00C51806   SRLV V1, A1, A2
9D03C3F4  03E00008   JR RA
9D03C3F8  00441025   OR V0, V0, A0
9D03C3FC  03E00008   JR RA
9D03C400  00A01821   ADDU V1, A1, ZERO
9D03C404  00021023   SUBU V0, ZERO, V0
9D03C408  00001821   ADDU V1, ZERO, ZERO
9D03C40C  03E00008   JR RA
9D03C410  00451006   SRLV V0, A1, V0
9D03C414  10C00009   BEQ A2, ZERO, 0x9D03C43C
9D03C418  00801021   ADDU V0, A0, ZERO
9D03C41C  24030020   ADDIU V1, ZERO, 32
9D03C420  00661823   SUBU V1, V1, A2
9D03C424  18600007   BLEZ V1, 0x9D03C444
9D03C428  00C52804   SLLV A1, A1, A2
9D03C448  00001021   ADDU V0, ZERO, ZERO
9D03C444  00031823   SUBU V1, ZERO, V1
9D03C42C  00641806   SRLV V1, A0, V1
9D03C430  00C41004   SLLV V0, A0, A2
9D03C434  03E00008   JR RA
9D03C438  00651825   OR V1, V1, A1
9D03C43C  03E00008   JR RA
9D03C440  00A01821   ADDU V1, A1, ZERO
9D03C444  00031823   SUBU V1, ZERO, V1
9D03C448  00001021   ADDU V0, ZERO, ZERO
9D03C44C  03E00008   JR RA
9D03C450  00641804   SLLV V1, A0, V1
9D02E6A0  00C04021   ADDU T0, A2, ZERO
9D02EFBC  00C04021   ADDU T0, A2, ZERO
9D02F420  00C04021   ADDU T0, A2, ZERO
9D02E6A4  00805021   ADDU T2, A0, ZERO
9D02EFC0  00804821   ADDU T1, A0, ZERO
9D02F424  00801021   ADDU V0, A0, ZERO
9D02E6A8  14E00046   BNE A3, ZERO, 0x9D02E7C4
9D02E6AC  00A01821   ADDU V1, A1, ZERO
9D02EFC4  14E0003B   BNE A3, ZERO, 0x9D02F0B4
9D02EFC8  00A01821   ADDU V1, A1, ZERO
9D02F428  14E0003F   BNE A3, ZERO, 0x9D02F528
9D02F42C  00A04821   ADDU T1, A1, ZERO
9D02E6B0  00A6102B   SLTU V0, A1, A2
9D02E6B4  1040005D   BEQ V0, ZERO, 0x9D02E82C
9D02E6B8  70C21020   CLZ V0, A2
9D02EFCC  00A6102B   SLTU V0, A1, A2
9D02EFD0  10400048   BEQ V0, ZERO, 0x9D02F0F4
9D02EFD4  70C21020   CLZ V0, A2
9D02F430  00A6182B   SLTU V1, A1, A2
9D02F434  10600047   BEQ V1, ZERO, 0x9D02F554
9D02F438  70C31820   CLZ V1, A2
9D02E6BC  50400008   BEQL V0, ZERO, 0x9D02E6E0
9D02E6C0  00082C02   SRL A1, T0, 16
9D02EFD8  50400008   BEQL V0, ZERO, 0x9D02EFFC
9D02EFDC  00083402   SRL A2, T0, 16
9D02F43C  50600008   BEQL V1, ZERO, 0x9D02F460
9D02F440  00081C02   SRL V1, T0, 16
9D02E6D0  00464004   SLLV T0, A2, V0
9D02EFEC  00464004   SLLV T0, A2, V0
9D02F450  00664004   SLLV T0, A2, V1
9D02E6C4  00022023   SUBU A0, ZERO, V0
9D02E6C8  008A2006   SRLV A0, T2, A0
9D02E6CC  00451804   SLLV V1, A1, V0
9D02E6D4  00831825   OR V1, A0, V1
9D02EFE0  00021823   SUBU V1, ZERO, V0
9D02EFE4  00452804   SLLV A1, A1, V0
9D02EFE8  00641806   SRLV V1, A0, V1
9D02EFF0  00651825   OR V1, V1, A1
9D02F444  00034823   SUBU T1, ZERO, V1
9D02F448  00652804   SLLV A1, A1, V1
9D02F44C  01244806   SRLV T1, A0, T1
9D02F454  01254825   OR T1, T1, A1
9D02E6D8  004A5004   SLLV T2, T2, V0
9D02EFF4  00444804   SLLV T1, A0, V0
9D02F458  00641004   SLLV V0, A0, V1
9D02E6DC  00082C02   SRL A1, T0, 16
9D02E6E0  0065001B   DIVU V1, A1
9D02E6E4  00A001F4   TEQ A1, ZERO
9D02E6E8  00006010   MFHI T4
9D02E6EC  00005812   MFLO T3
9D02E6F0  3107FFFF   ANDI A3, T0, -1
9D02E6F4  000A2402   SRL A0, T2, 16
9D02E6F8  00001012   MFLO V0
9D02E6FC  71673002   MUL A2, T3, A3
9D02E700  000C6400   SLL T4, T4, 16
9D02E704  01842025   OR A0, T4, A0
9D02E708  0086602B   SLTU T4, A0, A2
9D02E70C  0065001B   DIVU V1, A1
9D02E710  00A001F4   TEQ A1, ZERO
9D02E714  1180000B   BEQ T4, ZERO, 0x9D02E744
9D02E718  00861823   SUBU V1, A0, A2
9D02E71C  00882021   ADDU A0, A0, T0
9D02E720  0088182B   SLTU V1, A0, T0
9D02E724  14600006   BNE V1, ZERO, 0x9D02E740
9D02E728  2562FFFF   ADDIU V0, T3, -1
9D02E72C  0086182B   SLTU V1, A0, A2
9D02E730  10600004   BEQ V1, ZERO, 0x9D02E744
9D02E734  00861823   SUBU V1, A0, A2
9D02E738  2562FFFE   ADDIU V0, T3, -2
9D02E73C  00882021   ADDU A0, A0, T0
9D02E740  00861823   SUBU V1, A0, A2
9D02E744  314AFFFF   ANDI T2, T2, -1
9D02E748  0065001B   DIVU V1, A1
9D02E74C  00A001F4   TEQ A1, ZERO
9D02E750  00005810   MFHI T3
9D02E754  00003012   MFLO A2
9D02E758  00002012   MFLO A0
9D02E75C  70C73802   MUL A3, A2, A3
9D02E760  000B5C00   SLL T3, T3, 16
9D02E764  016A5025   OR T2, T3, T2
9D02E768  0147582B   SLTU T3, T2, A3
9D02E76C  0065001B   DIVU V1, A1
9D02E770  00A001F4   TEQ A1, ZERO
9D02E774  51600009   BEQL T3, ZERO, 0x9D02E79C
9D02E778  00021400   SLL V0, V0, 16
9D02E77C  01485021   ADDU T2, T2, T0
9D02E780  0148402B   SLTU T0, T2, T0
9D02E784  15000004   BNE T0, ZERO, 0x9D02E798
9D02E788  24C4FFFF   ADDIU A0, A2, -1
9D02E78C  0147382B   SLTU A3, T2, A3
9D02E790  24C6FFFE   ADDIU A2, A2, -2
9D02E794  00C7200B   MOVN A0, A2, A3
9D02E798  00021400   SLL V0, V0, 16
9D02E79C  00821025   OR V0, A0, V0
9D02E7A0  00001821   ADDU V1, ZERO, ZERO
9D02EFF8  00083402   SRL A2, T0, 16
9D02EFFC  0066001B   DIVU V1, A2
9D02F000  00C001F4   TEQ A2, ZERO
9D02F004  00002010   MFHI A0
9D02F008  00005812   MFLO T3
9D02F00C  310CFFFF   ANDI T4, T0, -1
9D02F010  00095402   SRL T2, T1, 16
9D02F014  716C5802   MUL T3, T3, T4
9D02F018  00042400   SLL A0, A0, 16
9D02F01C  008A5025   OR T2, A0, T2
9D02F020  014B682B   SLTU T5, T2, T3
9D02F024  0066001B   DIVU V1, A2
9D02F028  00C001F4   TEQ A2, ZERO
9D02F02C  51A00009   BEQL T5, ZERO, 0x9D02F054
9D02F030  014B5023   SUBU T2, T2, T3
9D02F034  01485021   ADDU T2, T2, T0
9D02F038  0148182B   SLTU V1, T2, T0
9D02F03C  54600005   BNEL V1, ZERO, 0x9D02F054
9D02F040  014B5023   SUBU T2, T2, T3
9D02F044  014B202B   SLTU A0, T2, T3
9D02F048  01481821   ADDU V1, T2, T0
9D02F04C  0064500B   MOVN T2, V1, A0
9D02F050  014B5023   SUBU T2, T2, T3
9D02F054  3123FFFF   ANDI V1, T1, -1
9D02F058  0146001B   DIVU T2, A2
9D02F05C  00C001F4   TEQ A2, ZERO
9D02F060  00004810   MFHI T1
9D02F064  00002012   MFLO A0
9D02F068  708C2002   MUL A0, A0, T4
9D02F06C  00094C00   SLL T1, T1, 16
9D02F070  01234825   OR T1, T1, V1
9D02F074  0124182B   SLTU V1, T1, A0
9D02F078  0146001B   DIVU T2, A2
9D02F07C  00C001F4   TEQ A2, ZERO
9D02F080  50600009   BEQL V1, ZERO, .LBE15
9D02F084  01244823   SUBU T1, T1, A0
9D02F088  01284821   ADDU T1, T1, T0
9D02F08C  0128182B   SLTU V1, T1, T0
9D02F090  54600005   BNEL V1, ZERO, .LBE15
9D02F094  01244823   SUBU T1, T1, A0
9D02F098  0124182B   SLTU V1, T1, A0
9D02F09C  01284021   ADDU T0, T1, T0
9D02F0A0  0103480B   MOVN T1, T0, V1
9D02F0A4  01244823   SUBU T1, T1, A0
9D02F45C  00081C02   SRL V1, T0, 16
9D02F460  0123001B   DIVU T1, V1
9D02F464  006001F4   TEQ V1, ZERO
9D02F468  00006010   MFHI T4
9D02F46C  00005812   MFLO T3
9D02F470  310AFFFF   ANDI T2, T0, -1
9D02F474  00022402   SRL A0, V0, 16
9D02F478  00003012   MFLO A2
9D02F47C  716A3802   MUL A3, T3, T2
9D02F480  000C6400   SLL T4, T4, 16
9D02F484  01842025   OR A0, T4, A0
9D02F488  0087602B   SLTU T4, A0, A3
9D02F48C  0123001B   DIVU T1, V1
9D02F490  006001F4   TEQ V1, ZERO
9D02F494  1180000B   BEQ T4, ZERO, 0x9D02F4C4
9D02F498  00872823   SUBU A1, A0, A3
9D02F49C  00882021   ADDU A0, A0, T0
9D02F4A0  0088282B   SLTU A1, A0, T0
9D02F4A4  14A00006   BNE A1, ZERO, 0x9D02F4C0
9D02F4A8  2566FFFF   ADDIU A2, T3, -1
9D02F4AC  0087282B   SLTU A1, A0, A3
9D02F4B0  10A00004   BEQ A1, ZERO, 0x9D02F4C4
9D02F4B4  00872823   SUBU A1, A0, A3
9D02F4B8  2566FFFE   ADDIU A2, T3, -2
9D02F4BC  00882021   ADDU A0, A0, T0
9D02F4C0  00872823   SUBU A1, A0, A3
9D02F4C4  3042FFFF   ANDI V0, V0, -1
9D02F4C8  00A3001B   DIVU A1, V1
9D02F4CC  006001F4   TEQ V1, ZERO
9D02F4D0  00004810   MFHI T1
9D02F4D4  00003812   MFLO A3
9D02F4D8  00002012   MFLO A0
9D02F4DC  70EA5002   MUL T2, A3, T2
9D02F4E0  00094C00   SLL T1, T1, 16
9D02F4E4  01221025   OR V0, T1, V0
9D02F4E8  004A482B   SLTU T1, V0, T2
9D02F4EC  00A3001B   DIVU A1, V1
9D02F4F0  006001F4   TEQ V1, ZERO
9D02F4F4  51200009   BEQL T1, ZERO, 0x9D02F51C
9D02F4F8  00061400   SLL V0, A2, 16
9D02F4FC  00481021   ADDU V0, V0, T0
9D02F500  0048402B   SLTU T0, V0, T0
9D02F504  15000004   BNE T0, ZERO, 0x9D02F518
9D02F508  24E4FFFF   ADDIU A0, A3, -1
9D02F50C  004A502B   SLTU T2, V0, T2
9D02F510  24E7FFFE   ADDIU A3, A3, -2
9D02F514  00EA200B   MOVN A0, A3, T2
9D02F518  00061400   SLL V0, A2, 16
9D02F51C  00821025   OR V0, A0, V0
9D02F520  03E00008   JR RA
9D02F524  00001821   ADDU V1, ZERO, ZERO
9D02E82C  14C00006   BNE A2, ZERO, 0x9D02E848
9D02E830  71021020   CLZ V0, T0
9D02F0F4  14C00006   BNE A2, ZERO, 0x9D02F110
9D02F0F8  71021020   CLZ V0, T0
9D02F554  14C00006   BNE A2, ZERO, 0x9D02F570
9D02F558  71031820   CLZ V1, T0
9D02E834  24080001   ADDIU T0, ZERO, 1
9D02E838  0107001B   DIVU T0, A3
9D02E83C  00E001F4   TEQ A3, ZERO
9D02E840  00004012   MFLO T0
9D02F0FC  24020001   ADDIU V0, ZERO, 1
9D02F100  0046001B   DIVU V0, A2
9D02F104  00C001F4   TEQ A2, ZERO
9D02F108  00004012   MFLO T0
9D02F55C  24030001   ADDIU V1, ZERO, 1
9D02F560  0066001B   DIVU V1, A2
9D02F564  00C001F4   TEQ A2, ZERO
9D02F568  00004012   MFLO T0
9D02E844  71021020   CLZ V0, T0
9D02F10C  71021020   CLZ V0, T0
9D02F56C  71031820   CLZ V1, T0
9D02E848  54400033   BNEL V0, ZERO, 0x9D02E918
9D02E84C  00484004   SLLV T0, T0, V0
9D02F110  5440007D   BNEL V0, ZERO, 0x9D02F308
9D02F114  00484004   SLLV T0, T0, V0
9D02F570  5460007B   BNEL V1, ZERO, 0x9D02F760
9D02F574  00684004   SLLV T0, T0, V1
9D02E850  00A82023   SUBU A0, A1, T0
9D02E854  00083C02   SRL A3, T0, 16
9D02E858  310CFFFF   ANDI T4, T0, -1
9D02E85C  24030001   ADDIU V1, ZERO, 1
9D02F118  00A82823   SUBU A1, A1, T0
9D02F11C  00081C02   SRL V1, T0, 16
9D02F120  3107FFFF   ANDI A3, T0, -1
9D02F578  00A82023   SUBU A0, A1, T0
9D02F57C  00083C02   SRL A3, T0, 16
9D02F580  310BFFFF   ANDI T3, T0, -1
9D02F584  24030001   ADDIU V1, ZERO, 1
9D02E918  24030020   ADDIU V1, ZERO, 32
9D02E91C  00621823   SUBU V1, V1, V0
9D02F308  24090020   ADDIU T1, ZERO, 32
9D02F30C  01224823   SUBU T1, T1, V0
9D02F760  24020020   ADDIU V0, ZERO, 32
9D02F764  00431023   SUBU V0, V0, V1
9D02E920  00653006   SRLV A2, A1, V1
9D02F310  01255006   SRLV T2, A1, T1
9D02F768  00454806   SRLV T1, A1, V0
9D02E93C  00452804   SLLV A1, A1, V0
9D02E940  00641806   SRLV V1, A0, V1
9D02E944  00652825   OR A1, V1, A1
9D02F32C  00452804   SLLV A1, A1, V0
9D02F330  01244806   SRLV T1, A0, T1
9D02F334  01252825   OR A1, T1, A1
9D02F784  00652804   SLLV A1, A1, V1
9D02F788  00441006   SRLV V0, A0, V0
9D02F78C  00452825   OR A1, V0, A1
9D02E94C  00445004   SLLV T2, A0, V0
9D02F33C  00444804   SLLV T1, A0, V0
9D02F794  00641004   SLLV V0, A0, V1
9D02E924  00083C02   SRL A3, T0, 16
9D02E928  00C7001B   DIVU A2, A3
9D02E92C  00E001F4   TEQ A3, ZERO
9D02E930  00007810   MFHI T7
9D02E934  00006812   MFLO T5
9D02E938  310CFFFF   ANDI T4, T0, -1
9D02E948  00057402   SRL T6, A1, 16
9D02E950  00001812   MFLO V1
9D02E954  71AC5802   MUL T3, T5, T4
9D02E958  000F1400   SLL V0, T7, 16
9D02E95C  01C21025   OR V0, T6, V0
9D02E960  004B202B   SLTU A0, V0, T3
9D02E964  00C7001B   DIVU A2, A3
9D02E968  00E001F4   TEQ A3, ZERO
9D02E96C  5080000B   BEQL A0, ZERO, 0x9D02E99C
9D02E970  004B1023   SUBU V0, V0, T3
9D02E974  00481021   ADDU V0, V0, T0
9D02E978  0048202B   SLTU A0, V0, T0
9D02E97C  14800006   BNE A0, ZERO, 0x9D02E998
9D02E980  25A3FFFF   ADDIU V1, T5, -1
9D02E984  004B202B   SLTU A0, V0, T3
9D02E988  50800004   BEQL A0, ZERO, 0x9D02E99C
9D02E98C  004B1023   SUBU V0, V0, T3
9D02E990  25A3FFFE   ADDIU V1, T5, -2
9D02E994  00481021   ADDU V0, V0, T0
9D02E998  004B1023   SUBU V0, V0, T3
9D02E99C  30ADFFFF   ANDI T5, A1, -1
9D02E9A0  0047001B   DIVU V0, A3
9D02E9A4  00E001F4   TEQ A3, ZERO
9D02E9A8  00002010   MFHI A0
9D02E9AC  00005812   MFLO T3
9D02E9B0  00003012   MFLO A2
9D02E9B4  716C2802   MUL A1, T3, T4
9D02E9B8  00042400   SLL A0, A0, 16
9D02E9BC  008D2025   OR A0, A0, T5
9D02E9C0  0085682B   SLTU T5, A0, A1
9D02E9C4  0047001B   DIVU V0, A3
9D02E9C8  00E001F4   TEQ A3, ZERO
9D02E9CC  51A0000B   BEQL T5, ZERO, 0x9D02E9FC
9D02E9D0  00031C00   SLL V1, V1, 16
9D02E9D4  00882021   ADDU A0, A0, T0
9D02E9D8  0088102B   SLTU V0, A0, T0
9D02E9DC  14400006   BNE V0, ZERO, 0x9D02E9F8
9D02E9E0  2566FFFF   ADDIU A2, T3, -1
9D02E9E4  0085102B   SLTU V0, A0, A1
9D02E9E8  50400004   BEQL V0, ZERO, 0x9D02E9FC
9D02E9EC  00031C00   SLL V1, V1, 16
9D02E9F0  2566FFFE   ADDIU A2, T3, -2
9D02E9F4  00882021   ADDU A0, A0, T0
9D02E9F8  00031C00   SLL V1, V1, 16
9D02E9FC  00852023   SUBU A0, A0, A1
9D02EA00  0B40BA18   J .LBB16
9D02EA04  00C31825   OR V1, A2, V1
9D02F314  00081C02   SRL V1, T0, 16
9D02F318  0143001B   DIVU T2, V1
9D02F31C  006001F4   TEQ V1, ZERO
9D02F320  00003010   MFHI A2
9D02F324  00005812   MFLO T3
9D02F328  3107FFFF   ANDI A3, T0, -1
9D02F338  00056402   SRL T4, A1, 16
9D02F340  71675802   MUL T3, T3, A3
9D02F344  00063400   SLL A2, A2, 16
9D02F348  01863025   OR A2, T4, A2
9D02F34C  00CB202B   SLTU A0, A2, T3
9D02F350  0143001B   DIVU T2, V1
9D02F354  006001F4   TEQ V1, ZERO
9D02F358  50800006   BEQL A0, ZERO, 0x9D02F374
9D02F35C  00CB3023   SUBU A2, A2, T3
9D02F360  00C83021   ADDU A2, A2, T0
9D02F364  00C8202B   SLTU A0, A2, T0
9D02F368  10800024   BEQ A0, ZERO, 0x9D02F3FC
9D02F36C  00CB502B   SLTU T2, A2, T3
9D02F370  00CB3023   SUBU A2, A2, T3
9D02F374  30AAFFFF   ANDI T2, A1, -1
9D02F378  00C3001B   DIVU A2, V1
9D02F37C  006001F4   TEQ V1, ZERO
9D02F380  00002010   MFHI A0
9D02F384  00002812   MFLO A1
9D02F388  70A72802   MUL A1, A1, A3
9D02F38C  00042400   SLL A0, A0, 16
9D02F390  008A2025   OR A0, A0, T2
9D02F394  0085502B   SLTU T2, A0, A1
9D02F398  00C3001B   DIVU A2, V1
9D02F39C  006001F4   TEQ V1, ZERO
9D02F3A0  5140FF60   BEQL T2, ZERO, .LBB17
9D02F3A4  00852823   SUBU A1, A0, A1
9D02F3A8  00882021   ADDU A0, A0, T0
9D02F3AC  0088302B   SLTU A2, A0, T0
9D02F3B0  54C0FF5C   BNEL A2, ZERO, .LBB17
9D02F3B4  00852823   SUBU A1, A0, A1
9D02F3B8  0085502B   SLTU T2, A0, A1
9D02F3BC  00883021   ADDU A2, A0, T0
9D02F3C0  00CA200B   MOVN A0, A2, T2
9D02F3C4  0B40BC49   J .LBB17
9D02F3C8  00852823   SUBU A1, A0, A1
9D02F3FC  00C82021   ADDU A0, A2, T0
9D02F400  0B40BCDC   J 0x9D02F370
9D02F404  008A300B   MOVN A2, A0, T2
9D02F76C  00083C02   SRL A3, T0, 16
9D02F770  0127001B   DIVU T1, A3
9D02F774  00E001F4   TEQ A3, ZERO
9D02F778  00003010   MFHI A2
9D02F77C  00006012   MFLO T4
9D02F780  310BFFFF   ANDI T3, T0, -1
9D02F790  00056C02   SRL T5, A1, 16
9D02F798  00001812   MFLO V1
9D02F79C  718B5002   MUL T2, T4, T3
9D02F7A0  00063400   SLL A2, A2, 16
9D02F7A4  01A63025   OR A2, T5, A2
9D02F7A8  00CA202B   SLTU A0, A2, T2
9D02F7AC  0127001B   DIVU T1, A3
9D02F7B0  00E001F4   TEQ A3, ZERO
9D02F7B4  5080000B   BEQL A0, ZERO, 0x9D02F7E4
9D02F7B8  00CA3023   SUBU A2, A2, T2
9D02F7BC  00C83021   ADDU A2, A2, T0
9D02F7C0  00C8202B   SLTU A0, A2, T0
9D02F7C4  14800006   BNE A0, ZERO, 0x9D02F7E0
9D02F7C8  2583FFFF   ADDIU V1, T4, -1
9D02F7CC  00CA202B   SLTU A0, A2, T2
9D02F7D0  50800004   BEQL A0, ZERO, 0x9D02F7E4
9D02F7D4  00CA3023   SUBU A2, A2, T2
9D02F7D8  2583FFFE   ADDIU V1, T4, -2
9D02F7DC  00C83021   ADDU A2, A2, T0
9D02F7E0  00CA3023   SUBU A2, A2, T2
9D02F7E4  30ACFFFF   ANDI T4, A1, -1
9D02F7E8  00C7001B   DIVU A2, A3
9D02F7EC  00E001F4   TEQ A3, ZERO
9D02F7F0  00002010   MFHI A0
9D02F7F4  00005012   MFLO T2
9D02F7F8  00004812   MFLO T1
9D02F7FC  714B2802   MUL A1, T2, T3
9D02F800  00042400   SLL A0, A0, 16
9D02F804  008C2025   OR A0, A0, T4
9D02F808  0085602B   SLTU T4, A0, A1
9D02F80C  00C7001B   DIVU A2, A3
9D02F810  00E001F4   TEQ A3, ZERO
9D02F814  5180000B   BEQL T4, ZERO, 0x9D02F844
9D02F818  00031C00   SLL V1, V1, 16
9D02F81C  00882021   ADDU A0, A0, T0
9D02F820  0088302B   SLTU A2, A0, T0
9D02F824  14C00006   BNE A2, ZERO, 0x9D02F840
9D02F828  2549FFFF   ADDIU T1, T2, -1
9D02F82C  0085302B   SLTU A2, A0, A1
9D02F830  50C00004   BEQL A2, ZERO, 0x9D02F844
9D02F834  00031C00   SLL V1, V1, 16
9D02F838  2549FFFE   ADDIU T1, T2, -2
9D02F83C  00882021   ADDU A0, A0, T0
9D02F840  00031C00   SLL V1, V1, 16
9D02F844  00852023   SUBU A0, A0, A1
9D02F848  0B40BD62   J .LBB16
9D02F84C  01231825   OR V1, T1, V1
9D02E860  000A3402   SRL A2, T2, 16
9D02E864  0087001B   DIVU A0, A3
9D02E868  00E001F4   TEQ A3, ZERO
9D02E86C  00007010   MFHI T6
9D02E870  00006812   MFLO T5
9D02E874  00001012   MFLO V0
9D02E878  71AC5802   MUL T3, T5, T4
9D02E87C  000E7400   SLL T6, T6, 16
9D02E880  01C63025   OR A2, T6, A2
9D02E884  00CB702B   SLTU T6, A2, T3
9D02E888  0087001B   DIVU A0, A3
9D02E88C  00E001F4   TEQ A3, ZERO
9D02E890  11C00009   BEQ T6, ZERO, 0x9D02E8B8
9D02E894  00CB2823   SUBU A1, A2, T3
9D02E898  00C83021   ADDU A2, A2, T0
9D02E89C  00C8202B   SLTU A0, A2, T0
9D02E8A0  14800004   BNE A0, ZERO, 0x9D02E8B4
9D02E8A4  25A2FFFF   ADDIU V0, T5, -1
9D02E8A8  00CB202B   SLTU A0, A2, T3
9D02E8AC  548000A3   BNEL A0, ZERO, 0x9D02EB3C
9D02E8B0  25A2FFFE   ADDIU V0, T5, -2
9D02E8B4  00CB2823   SUBU A1, A2, T3
9D02E8B8  314AFFFF   ANDI T2, T2, -1
9D02E8BC  00A7001B   DIVU A1, A3
9D02E8C0  00E001F4   TEQ A3, ZERO
9D02E8C4  00005810   MFHI T3
9D02E8C8  00003012   MFLO A2
9D02E8CC  00002012   MFLO A0
9D02E8D0  70CC6002   MUL T4, A2, T4
9D02E8D4  000B5C00   SLL T3, T3, 16
9D02E8D8  016A5025   OR T2, T3, T2
9D02E8DC  014C582B   SLTU T3, T2, T4
9D02E8E0  00A7001B   DIVU A1, A3
9D02E8E4  00E001F4   TEQ A3, ZERO
9D02E8E8  51600009   BEQL T3, ZERO, .LBE16
9D02E8EC  00021400   SLL V0, V0, 16
9D02E8F0  01485021   ADDU T2, T2, T0
9D02E8F4  0148402B   SLTU T0, T2, T0
9D02E8F8  15000004   BNE T0, ZERO, 0x9D02E90C
9D02E8FC  24C4FFFF   ADDIU A0, A2, -1
9D02E900  014C502B   SLTU T2, T2, T4
9D02E904  24C6FFFE   ADDIU A2, A2, -2
9D02E908  00CA200B   MOVN A0, A2, T2
9D02E90C  00021400   SLL V0, V0, 16
9D02E910  0B40B9E9   J .LBE15
9D02E914  00821025   OR V0, A0, V0
9D02EB3C  0B40BA2D   J 0x9D02E8B4
9D02F124  00092402   SRL A0, T1, 16
9D02F128  00A3001B   DIVU A1, V1
9D02F12C  006001F4   TEQ V1, ZERO
9D02F130  00005010   MFHI T2
9D02F134  00003012   MFLO A2
9D02F138  70C73002   MUL A2, A2, A3
9D02F13C  000A5400   SLL T2, T2, 16
9D02F140  01442025   OR A0, T2, A0
9D02F144  0086502B   SLTU T2, A0, A2
9D02F148  00A3001B   DIVU A1, V1
9D02F14C  006001F4   TEQ V1, ZERO
9D02F150  51400009   BEQL T2, ZERO, 0x9D02F178
9D02F154  00862023   SUBU A0, A0, A2
9D02F158  00882021   ADDU A0, A0, T0
9D02F15C  0088282B   SLTU A1, A0, T0
9D02F160  54A00005   BNEL A1, ZERO, 0x9D02F178
9D02F164  00862023   SUBU A0, A0, A2
9D02F168  0086502B   SLTU T2, A0, A2
9D02F16C  00882821   ADDU A1, A0, T0
9D02F170  00AA200B   MOVN A0, A1, T2
9D02F174  00862023   SUBU A0, A0, A2
9D02F178  3126FFFF   ANDI A2, T1, -1
9D02F17C  0083001B   DIVU A0, V1
9D02F180  006001F4   TEQ V1, ZERO
9D02F184  00004810   MFHI T1
9D02F188  00002812   MFLO A1
9D02F18C  70A72802   MUL A1, A1, A3
9D02F190  00094C00   SLL T1, T1, 16
9D02F194  01264825   OR T1, T1, A2
9D02F198  0125302B   SLTU A2, T1, A1
9D02F19C  0083001B   DIVU A0, V1
9D02F1A0  006001F4   TEQ V1, ZERO
9D02F1A4  50C00009   BEQL A2, ZERO, .LBE17
9D02F1A8  01254823   SUBU T1, T1, A1
9D02F1AC  01284821   ADDU T1, T1, T0
9D02F1B0  0128182B   SLTU V1, T1, T0
9D02F1B4  54600005   BNEL V1, ZERO, .LBE17
9D02F1B8  01254823   SUBU T1, T1, A1
9D02F1BC  0125182B   SLTU V1, T1, A1
9D02F1C0  01284021   ADDU T0, T1, T0
9D02F1C4  0103480B   MOVN T1, T0, V1
9D02F1C8  01254823   SUBU T1, T1, A1
9D02F588  00023402   SRL A2, V0, 16
9D02F58C  0087001B   DIVU A0, A3
9D02F590  00E001F4   TEQ A3, ZERO
9D02F594  00006810   MFHI T5
9D02F598  00006012   MFLO T4
9D02F59C  00004812   MFLO T1
9D02F5A0  718B5002   MUL T2, T4, T3
9D02F5A4  000D6C00   SLL T5, T5, 16
9D02F5A8  01A63025   OR A2, T5, A2
9D02F5AC  00CA682B   SLTU T5, A2, T2
9D02F5B0  0087001B   DIVU A0, A3
9D02F5B4  00E001F4   TEQ A3, ZERO
9D02F5B8  11A00009   BEQ T5, ZERO, 0x9D02F5E0
9D02F5BC  00CA2823   SUBU A1, A2, T2
9D02F5C0  00C83021   ADDU A2, A2, T0
9D02F5C4  00C8202B   SLTU A0, A2, T0
9D02F5C8  14800004   BNE A0, ZERO, 0x9D02F5DC
9D02F5CC  2589FFFF   ADDIU T1, T4, -1
9D02F5D0  00CA202B   SLTU A0, A2, T2
9D02F5D4  548000A6   BNEL A0, ZERO, 0x9D02F870
9D02F5D8  2589FFFE   ADDIU T1, T4, -2
9D02F5DC  00CA2823   SUBU A1, A2, T2
9D02F5E0  3042FFFF   ANDI V0, V0, -1
9D02F5E4  00A7001B   DIVU A1, A3
9D02F5E8  00E001F4   TEQ A3, ZERO
9D02F5EC  00005010   MFHI T2
9D02F5F0  00003012   MFLO A2
9D02F5F4  00002012   MFLO A0
9D02F5F8  70CB5802   MUL T3, A2, T3
9D02F5FC  000A5400   SLL T2, T2, 16
9D02F600  01421025   OR V0, T2, V0
9D02F604  004B502B   SLTU T2, V0, T3
9D02F608  00A7001B   DIVU A1, A3
9D02F60C  00E001F4   TEQ A3, ZERO
9D02F610  51400009   BEQL T2, ZERO, .LBE16
9D02F614  00091400   SLL V0, T1, 16
9D02F618  00481021   ADDU V0, V0, T0
9D02F61C  0048402B   SLTU T0, V0, T0
9D02F620  15000004   BNE T0, ZERO, 0x9D02F634
9D02F624  24C4FFFF   ADDIU A0, A2, -1
9D02F628  004B582B   SLTU T3, V0, T3
9D02F62C  24C6FFFE   ADDIU A2, A2, -2
9D02F630  00CB200B   MOVN A0, A2, T3
9D02F634  00091400   SLL V0, T1, 16
9D02F638  03E00008   JR RA
9D02F63C  00821025   OR V0, A0, V0
9D02F870  0B40BD77   J 0x9D02F5DC
9D02F0A8  00491006   SRLV V0, T1, V0
9D02F1CC  00491006   SRLV V0, T1, V0
9D02F0AC  03E00008   JR RA
9D02F0B0  00001821   ADDU V1, ZERO, ZERO
9D02F1D0  03E00008   JR RA
9D02F1D4  00001821   ADDU V1, ZERO, ZERO
9D02E7C4  00A7102B   SLTU V0, A1, A3
9D02E7C8  10400010   BEQ V0, ZERO, 0x9D02E80C
9D02E7CC  70E84020   CLZ T0, A3
9D02E7D0  00001821   ADDU V1, ZERO, ZERO
9D02E7D4  0B40B9E9   J .LBE15
9D02E7D8  00001021   ADDU V0, ZERO, ZERO
9D02F0B4  00A7102B   SLTU V0, A1, A3
9D02F0B8  14400047   BNE V0, ZERO, 0x9D02F1D8
9D02F0BC  70EA5020   CLZ T2, A3
9D02F528  00A7102B   SLTU V0, A1, A3
9D02F52C  14400044   BNE V0, ZERO, 0x9D02F640
9D02F530  70E84020   CLZ T0, A3
9D02F640  00001821   ADDU V1, ZERO, ZERO
9D02F644  03E00008   JR RA
9D02F648  00001021   ADDU V0, ZERO, ZERO
9D02F1D8  00801021   ADDU V0, A0, ZERO
9D02F1DC  03E00008   JR RA
9D02F1E0  00A01821   ADDU V1, A1, ZERO
9D02E80C  1500007E   BNE T0, ZERO, 0x9D02EA08
9D02E810  24020020   ADDIU V0, ZERO, 32
9D02F0C0  15400048   BNE T2, ZERO, 0x9D02F1E4
9D02F0C4  240B0020   ADDIU T3, ZERO, 32
9D02F534  55000045   BNEL T0, ZERO, 0x9D02F64C
9D02F538  24020020   ADDIU V0, ZERO, 32
9D02E814  00E5282B   SLTU A1, A3, A1
9D02E818  14A000C6   BNE A1, ZERO, 0x9D02EB34
9D02E81C  00001821   ADDU V1, ZERO, ZERO
9D02E820  0086102B   SLTU V0, A0, A2
9D02E824  0B40B9E9   J .LBE15
9D02E828  38420001   XORI V0, V0, 1
9D02EB34  0B40B9E9   J .LBE15
9D02EB38  24020001   ADDIU V0, ZERO, 1
9D02F0C8  00E5102B   SLTU V0, A3, A1
9D02F0CC  14400005   BNE V0, ZERO, 0x9D02F0E4
9D02F0D0  00861023   SUBU V0, A0, A2
9D02F0D4  0086402B   SLTU T0, A0, A2
9D02F0D8  15000089   BNE T0, ZERO, 0x9D02F300
9D02F0DC  00801021   ADDU V0, A0, ZERO
9D02F53C  00E5282B   SLTU A1, A3, A1
9D02F540  14A000C8   BNE A1, ZERO, 0x9D02F864
9D02F544  0086302B   SLTU A2, A0, A2
9D02F548  38C20001   XORI V0, A2, 1
9D02F54C  03E00008   JR RA
9D02F550  00001821   ADDU V1, ZERO, ZERO
9D02F864  00001821   ADDU V1, ZERO, ZERO
9D02F0E0  00861023   SUBU V0, A0, A2
9D02F0E4  00A72823   SUBU A1, A1, A3
9D02F0E8  0082202B   SLTU A0, A0, V0
9D02F0EC  03E00008   JR RA
9D02F0F0  00A41823   SUBU V1, A1, A0
9D02EA08  00481023   SUBU V0, V0, T0
9D02F1E4  016A5823   SUBU T3, T3, T2
9D02F64C  00481023   SUBU V0, V0, T0
9D02EA0C  01073804   SLLV A3, A3, T0
9D02EA10  00461806   SRLV V1, A2, V0
9D02EA14  00673825   OR A3, V1, A3
9D02F1E8  01473804   SLLV A3, A3, T2
9D02F1EC  01661006   SRLV V0, A2, T3
9D02F1F0  00473825   OR A3, V0, A3
9D02F650  01073804   SLLV A3, A3, T0
9D02F654  00461806   SRLV V1, A2, V0
9D02F658  00673825   OR A3, V1, A3
9D02F220  01463004   SLLV A2, A2, T2
9D02EA18  00455806   SRLV T3, A1, V0
9D02F1F4  01656806   SRLV T5, A1, T3
9D02F65C  00455006   SRLV T2, A1, V0
9D02EA34  01052804   SLLV A1, A1, T0
9D02EA38  00441006   SRLV V0, A0, V0
9D02EA3C  00452825   OR A1, V0, A1
9D02F210  01452804   SLLV A1, A1, T2
9D02F214  01641006   SRLV V0, A0, T3
9D02F218  00451025   OR V0, V0, A1
9D02F678  01052804   SLLV A1, A1, T0
9D02F67C  00441006   SRLV V0, A0, V0
9D02F680  00452825   OR A1, V0, A1
9D02EA1C  00071C02   SRL V1, A3, 16
9D02EA20  0163001B   DIVU T3, V1
9D02EA24  006001F4   TEQ V1, ZERO
9D02EA28  00005010   MFHI T2
9D02EA2C  00007012   MFLO T6
9D02EA30  30ECFFFF   ANDI T4, A3, -1
9D02EA40  00057C02   SRL T7, A1, 16
9D02EA44  00001012   MFLO V0
9D02EA48  71CC6802   MUL T5, T6, T4
9D02EA4C  000A5400   SLL T2, T2, 16
9D02EA50  014F5025   OR T2, T2, T7
9D02EA54  014D782B   SLTU T7, T2, T5
9D02EA58  0163001B   DIVU T3, V1
9D02EA5C  006001F4   TEQ V1, ZERO
9D02EA60  11E0000A   BEQ T7, ZERO, 0x9D02EA8C
9D02EA64  01063004   SLLV A2, A2, T0
9D02EA68  01475021   ADDU T2, T2, A3
9D02EA6C  0147582B   SLTU T3, T2, A3
9D02EA70  15600006   BNE T3, ZERO, 0x9D02EA8C
9D02EA74  25C2FFFF   ADDIU V0, T6, -1
9D02EA78  014D582B   SLTU T3, T2, T5
9D02EA7C  51600004   BEQL T3, ZERO, 0x9D02EA90
9D02EA80  014D5023   SUBU T2, T2, T5
9D02EA84  25C2FFFE   ADDIU V0, T6, -2
9D02EA88  01475021   ADDU T2, T2, A3
9D02EA8C  014D5023   SUBU T2, T2, T5
9D02EA90  30A5FFFF   ANDI A1, A1, -1
9D02EA94  0143001B   DIVU T2, V1
9D02EA98  006001F4   TEQ V1, ZERO
9D02EA9C  00007010   MFHI T6
9D02EAA0  00006812   MFLO T5
9D02EAA4  00005812   MFLO T3
9D02EAA8  71AC6002   MUL T4, T5, T4
9D02EAAC  000E7400   SLL T6, T6, 16
9D02EAB0  01C52825   OR A1, T6, A1
9D02EAB4  00AC702B   SLTU T6, A1, T4
9D02EAB8  0143001B   DIVU T2, V1
9D02EABC  006001F4   TEQ V1, ZERO
9D02EAC0  51C0000B   BEQL T6, ZERO, 0x9D02EAF0
9D02EAC4  00021400   SLL V0, V0, 16
9D02EAC8  00A72821   ADDU A1, A1, A3
9D02EACC  00A7182B   SLTU V1, A1, A3
9D02EAD0  14600006   BNE V1, ZERO, 0x9D02EAEC
9D02EAD4  25ABFFFF   ADDIU T3, T5, -1
9D02EAD8  00AC182B   SLTU V1, A1, T4
9D02EADC  50600004   BEQL V1, ZERO, 0x9D02EAF0
9D02EAE0  00021400   SLL V0, V0, 16
9D02EAE4  25ABFFFE   ADDIU T3, T5, -2
9D02EAE8  00A72821   ADDU A1, A1, A3
9D02EAEC  00021400   SLL V0, V0, 16
9D02EAF0  01621025   OR V0, T3, V0
9D02EAF4  00AC2823   SUBU A1, A1, T4
9D02F1F8  00074C02   SRL T1, A3, 16
9D02F1FC  01A9001B   DIVU T5, T1
9D02F200  012001F4   TEQ T1, ZERO
9D02F204  00006010   MFHI T4
9D02F208  00001812   MFLO V1
9D02F20C  30EEFFFF   ANDI T6, A3, -1
9D02F21C  00022C02   SRL A1, V0, 16
9D02F224  00004012   MFLO T0
9D02F228  706E7802   MUL T7, V1, T6
9D02F22C  000C6400   SLL T4, T4, 16
9D02F230  01856025   OR T4, T4, A1
9D02F234  018F282B   SLTU A1, T4, T7
9D02F238  01A9001B   DIVU T5, T1
9D02F23C  012001F4   TEQ T1, ZERO
9D02F240  10A0000A   BEQ A1, ZERO, 0x9D02F26C
9D02F244  01442004   SLLV A0, A0, T2
9D02F248  01876021   ADDU T4, T4, A3
9D02F24C  0187282B   SLTU A1, T4, A3
9D02F250  14A00006   BNE A1, ZERO, 0x9D02F26C
9D02F254  2468FFFF   ADDIU T0, V1, -1
9D02F258  018F282B   SLTU A1, T4, T7
9D02F25C  50A00004   BEQL A1, ZERO, 0x9D02F270
9D02F260  018F6023   SUBU T4, T4, T7
9D02F264  2468FFFE   ADDIU T0, V1, -2
9D02F268  01876021   ADDU T4, T4, A3
9D02F26C  018F6023   SUBU T4, T4, T7
9D02F270  3042FFFF   ANDI V0, V0, -1
9D02F274  0189001B   DIVU T4, T1
9D02F278  012001F4   TEQ T1, ZERO
9D02F27C  00002810   MFHI A1
9D02F280  00001812   MFLO V1
9D02F284  00006812   MFLO T5
9D02F288  706E7002   MUL T6, V1, T6
9D02F28C  00052C00   SLL A1, A1, 16
9D02F290  00A21025   OR V0, A1, V0
9D02F294  004E282B   SLTU A1, V0, T6
9D02F298  0189001B   DIVU T4, T1
9D02F29C  012001F4   TEQ T1, ZERO
9D02F2A0  50A00006   BEQL A1, ZERO, 0x9D02F2BC
9D02F2A4  00084400   SLL T0, T0, 16
9D02F2A8  00471021   ADDU V0, V0, A3
9D02F2AC  0047282B   SLTU A1, V0, A3
9D02F2B0  10A0004C   BEQ A1, ZERO, .LBE25
9D02F2B4  246DFFFF   ADDIU T5, V1, -1
9D02F2B8  00084400   SLL T0, T0, 16
9D02F2BC  01A84025   OR T0, T5, T0
9D02F2C0  004E1023   SUBU V0, V0, T6
9D02F3E4  004E282B   SLTU A1, V0, T6
9D02F3E8  50A0FFB4   BEQL A1, ZERO, 0x9D02F2BC
9D02F3EC  00084400   SLL T0, T0, 16
9D02F3F0  246DFFFE   ADDIU T5, V1, -2
9D02F3F4  0B40BCAE   J 0x9D02F2B8
9D02F3F8  00471021   ADDU V0, V0, A3
9D02F660  00071C02   SRL V1, A3, 16
9D02F664  0143001B   DIVU T2, V1
9D02F668  006001F4   TEQ V1, ZERO
9D02F66C  00004810   MFHI T1
9D02F670  00006812   MFLO T5
9D02F674  30EBFFFF   ANDI T3, A3, -1
9D02F684  00057402   SRL T6, A1, 16
9D02F688  00001012   MFLO V0
9D02F68C  71AB6002   MUL T4, T5, T3
9D02F690  00094C00   SLL T1, T1, 16
9D02F694  012E4825   OR T1, T1, T6
9D02F698  012C702B   SLTU T6, T1, T4
9D02F69C  0143001B   DIVU T2, V1
9D02F6A0  006001F4   TEQ V1, ZERO
9D02F6A4  11C0000A   BEQ T6, ZERO, 0x9D02F6D0
9D02F6A8  01063004   SLLV A2, A2, T0
9D02F6AC  01274821   ADDU T1, T1, A3
9D02F6B0  0127502B   SLTU T2, T1, A3
9D02F6B4  15400006   BNE T2, ZERO, 0x9D02F6D0
9D02F6B8  25A2FFFF   ADDIU V0, T5, -1
9D02F6BC  012C502B   SLTU T2, T1, T4
9D02F6C0  51400004   BEQL T2, ZERO, 0x9D02F6D4
9D02F6C4  012C4823   SUBU T1, T1, T4
9D02F6C8  25A2FFFE   ADDIU V0, T5, -2
9D02F6CC  01274821   ADDU T1, T1, A3
9D02F6D0  012C4823   SUBU T1, T1, T4
9D02F6D4  30A5FFFF   ANDI A1, A1, -1
9D02F6D8  0123001B   DIVU T1, V1
9D02F6DC  006001F4   TEQ V1, ZERO
9D02F6E0  00006810   MFHI T5
9D02F6E4  00006012   MFLO T4
9D02F6E8  00005012   MFLO T2
9D02F6EC  718B5802   MUL T3, T4, T3
9D02F6F0  000D6C00   SLL T5, T5, 16
9D02F6F4  01A52825   OR A1, T5, A1
9D02F6F8  00AB682B   SLTU T5, A1, T3
9D02F6FC  0123001B   DIVU T1, V1
9D02F700  006001F4   TEQ V1, ZERO
9D02F704  51A0000B   BEQL T5, ZERO, 0x9D02F734
9D02F708  00021400   SLL V0, V0, 16
9D02F70C  00A72821   ADDU A1, A1, A3
9D02F710  00A7182B   SLTU V1, A1, A3
9D02F714  14600006   BNE V1, ZERO, 0x9D02F730
9D02F718  258AFFFF   ADDIU T2, T4, -1
9D02F71C  00AB182B   SLTU V1, A1, T3
9D02F720  50600004   BEQL V1, ZERO, 0x9D02F734
9D02F724  00021400   SLL V0, V0, 16
9D02F728  258AFFFE   ADDIU T2, T4, -2
9D02F72C  00A72821   ADDU A1, A1, A3
9D02F730  00021400   SLL V0, V0, 16
9D02F734  01421025   OR V0, T2, V0
9D02F738  00AB2823   SUBU A1, A1, T3
9D02EAF8  00460019   MULTU 0, V0, A2
9D02EAFC  00003810   MFHI A3
9D02F2C4  01060019   MULTU 0, T0, A2
9D02F2C8  00004810   MFHI T1
9D02F2E0  00003012   MFLO A2
9D02F73C  00460019   MULTU 0, V0, A2
9D02F740  00003810   MFHI A3
9D02EB00  00A7182B   SLTU V1, A1, A3
9D02EB04  14600008   BNE V1, ZERO, 0x9D02EB28
9D02EB08  00003012   MFLO A2
9D02EB0C  50A70003   BEQL A1, A3, 0x9D02EB1C
9D02EB10  01042004   SLLV A0, A0, T0
9D02EB1C  0086302B   SLTU A2, A0, A2
9D02EB20  50C0FF20   BEQL A2, ZERO, .LBE15
9D02EB24  00001821   ADDU V1, ZERO, ZERO
9D02F2CC  0049182B   SLTU V1, V0, T1
9D02F2D0  1460003E   BNE V1, ZERO, .LBB25
9D02F2D4  00004012   MFLO T0
9D02F2D8  1049004B   BEQ V0, T1, 0x9D02F408
9D02F2DC  00491823   SUBU V1, V0, T1
9D02F408  0088182B   SLTU V1, A0, T0
9D02F744  00A7182B   SLTU V1, A1, A3
9D02F748  14600044   BNE V1, ZERO, 0x9D02F85C
9D02F74C  00003012   MFLO A2
9D02F750  10A7003F   BEQ A1, A3, 0x9D02F850
9D02F754  01042004   SLLV A0, A0, T0
9D02F850  0086302B   SLTU A2, A0, A2
9D02F854  10C0FFC0   BEQ A2, ZERO, 0x9D02F758
9D02F858  00000000   NOP
9D02EB14  0B40B9E9   J .LBE15
9D02EB18  00001821   ADDU V1, ZERO, ZERO
9D02EB28  2442FFFF   ADDIU V0, V0, -1
9D02EB2C  0B40B9E9   J .LBE15
9D02EB30  00001821   ADDU V1, ZERO, ZERO
9D02F758  03E00008   JR RA
9D02F75C  00001821   ADDU V1, ZERO, ZERO
9D02F85C  0B40BDD6   J 0x9D02F758
9D02F860  2442FFFF   ADDIU V0, V0, -1
9D02F3CC  01063023   SUBU A2, T0, A2
9D02F3D0  01271823   SUBU V1, T1, A3
9D02F3D4  0106402B   SLTU T0, T0, A2
9D02F3D8  00681823   SUBU V1, V1, T0
9D02F3DC  0B40BCB9   J .LBB24
9D02F3E0  00431823   SUBU V1, V0, V1
9D02F2E4  00863023   SUBU A2, A0, A2
9D02F2E8  0086202B   SLTU A0, A0, A2
9D02F2EC  00641823   SUBU V1, V1, A0
9D02F2F0  01631004   SLLV V0, V1, T3
9D02F2F4  01463006   SRLV A2, A2, T2
9D02F2F8  00461025   OR V0, V0, A2
9D02F2FC  01431806   SRLV V1, V1, T2
9D02E690  04A00052   BLTZ A1, 0x9D02E7DC
9D02E694  00004821   ADDU T1, ZERO, ZERO
9D02E7DC  00042023   SUBU A0, ZERO, A0
9D02E7E0  0004102B   SLTU V0, ZERO, A0
9D02E7E4  00052823   SUBU A1, ZERO, A1
9D02E7E8  00A22823   SUBU A1, A1, V0
9D02E698  04E20057   BLTZL A3, 0x9D02E7F8
9D02E69C  00063023   SUBU A2, ZERO, A2
9D02E7EC  04E1FFAC   BGEZ A3, .LBB13
9D02E7F0  2409FFFF   ADDIU T1, ZERO, -1
9D02E800  00094827   NOR T1, ZERO, T1
9D02E7F4  00063023   SUBU A2, ZERO, A2
9D02E7F8  0006102B   SLTU V0, ZERO, A2
9D02E7FC  00073823   SUBU A3, ZERO, A3
9D02E804  0B40B9A8   J .LBB13
9D02E808  00E23823   SUBU A3, A3, V0
9D02E7A4  11200005   BEQ T1, ZERO, 0x9D02E7BC
9D02E7A8  00000000   NOP
9D02E7AC  00021023   SUBU V0, ZERO, V0
9D02E7B0  0002202B   SLTU A0, ZERO, V0
9D02E7B4  00031823   SUBU V1, ZERO, V1
9D02E7B8  00641823   SUBU V1, V1, A0
9D02E7BC  03E00008   JR RA
9D02E7C0  00000000   NOP
9D02E7C4  00A7102B   SLTU V0, A1, A3
9D02E7C8  10400010   BEQ V0, ZERO, 0x9D02E80C
9D02E7CC  70E84020   CLZ T0, A3
9D02E7D0  00001821   ADDU V1, ZERO, ZERO
9D02E7D4  0B40B9E9   J .LBE15
9D02E7D8  00001021   ADDU V0, ZERO, ZERO
9D02E7DC  00042023   SUBU A0, ZERO, A0
9D02E7E0  0004102B   SLTU V0, ZERO, A0
9D02E7E4  00052823   SUBU A1, ZERO, A1
9D02E7E8  00A22823   SUBU A1, A1, V0
9D02E7EC  04E1FFAC   BGEZ A3, .LBB13
9D02E7F0  2409FFFF   ADDIU T1, ZERO, -1
9D02E7F4  00063023   SUBU A2, ZERO, A2
9D02E7F8  0006102B   SLTU V0, ZERO, A2
9D02E7FC  00073823   SUBU A3, ZERO, A3
9D02E800  00094827   NOR T1, ZERO, T1
9D02E804  0B40B9A8   J .LBB13
9D02E808  00E23823   SUBU A3, A3, V0
9D02E80C  1500007E   BNE T0, ZERO, 0x9D02EA08
9D02E810  24020020   ADDIU V0, ZERO, 32
9D02E814  00E5282B   SLTU A1, A3, A1
9D02E818  14A000C6   BNE A1, ZERO, 0x9D02EB34
9D02E81C  00001821   ADDU V1, ZERO, ZERO
9D02E820  0086102B   SLTU V0, A0, A2
9D02E824  0B40B9E9   J .LBE15
9D02E828  38420001   XORI V0, V0, 1
9D02E82C  14C00006   BNE A2, ZERO, 0x9D02E848
9D02E830  71021020   CLZ V0, T0
9D02E834  24080001   ADDIU T0, ZERO, 1
9D02E838  0107001B   DIVU T0, A3
9D02E83C  00E001F4   TEQ A3, ZERO
9D02E840  00004012   MFLO T0
9D02E844  71021020   CLZ V0, T0
9D02E848  54400033   BNEL V0, ZERO, 0x9D02E918
9D02E84C  00484004   SLLV T0, T0, V0
9D02E850  00A82023   SUBU A0, A1, T0
9D02E854  00083C02   SRL A3, T0, 16
9D02E858  310CFFFF   ANDI T4, T0, -1
9D02E85C  24030001   ADDIU V1, ZERO, 1
9D02E860  000A3402   SRL A2, T2, 16
9D02E864  0087001B   DIVU A0, A3
9D02E868  00E001F4   TEQ A3, ZERO
9D02E86C  00007010   MFHI T6
9D02E870  00006812   MFLO T5
9D02E874  00001012   MFLO V0
9D02E878  71AC5802   MUL T3, T5, T4
9D02E87C  000E7400   SLL T6, T6, 16
9D02E880  01C63025   OR A2, T6, A2
9D02E884  00CB702B   SLTU T6, A2, T3
9D02E888  0087001B   DIVU A0, A3
9D02E88C  00E001F4   TEQ A3, ZERO
9D02E890  11C00009   BEQ T6, ZERO, 0x9D02E8B8
9D02E894  00CB2823   SUBU A1, A2, T3
9D02E898  00C83021   ADDU A2, A2, T0
9D02E89C  00C8202B   SLTU A0, A2, T0
9D02E8A0  14800004   BNE A0, ZERO, 0x9D02E8B4
9D02E8A4  25A2FFFF   ADDIU V0, T5, -1
9D02E8A8  00CB202B   SLTU A0, A2, T3
9D02E8AC  548000A3   BNEL A0, ZERO, 0x9D02EB3C
9D02E8B0  25A2FFFE   ADDIU V0, T5, -2
9D02E8B4  00CB2823   SUBU A1, A2, T3
9D02E8B8  314AFFFF   ANDI T2, T2, -1
9D02E8BC  00A7001B   DIVU A1, A3
9D02E8C0  00E001F4   TEQ A3, ZERO
9D02E8C4  00005810   MFHI T3
9D02E8C8  00003012   MFLO A2
9D02E8CC  00002012   MFLO A0
9D02E8D0  70CC6002   MUL T4, A2, T4
9D02E8D4  000B5C00   SLL T3, T3, 16
9D02E8D8  016A5025   OR T2, T3, T2
9D02E8DC  014C582B   SLTU T3, T2, T4
9D02E8E0  00A7001B   DIVU A1, A3
9D02E8E4  00E001F4   TEQ A3, ZERO
9D02E8E8  51600009   BEQL T3, ZERO, .LBE16
9D02E8EC  00021400   SLL V0, V0, 16
9D02E8F0  01485021   ADDU T2, T2, T0
9D02E8F4  0148402B   SLTU T0, T2, T0
9D02E8F8  15000004   BNE T0, ZERO, 0x9D02E90C
9D02E8FC  24C4FFFF   ADDIU A0, A2, -1
9D02E900  014C502B   SLTU T2, T2, T4
9D02E904  24C6FFFE   ADDIU A2, A2, -2
9D02E908  00CA200B   MOVN A0, A2, T2
9D02E90C  00021400   SLL V0, V0, 16
9D02E910  0B40B9E9   J .LBE15
9D02E914  00821025   OR V0, A0, V0
9D02E918  24030020   ADDIU V1, ZERO, 32
9D02E91C  00621823   SUBU V1, V1, V0
9D02E920  00653006   SRLV A2, A1, V1
9D02E924  00083C02   SRL A3, T0, 16
9D02E928  00C7001B   DIVU A2, A3
9D02E92C  00E001F4   TEQ A3, ZERO
9D02E930  00007810   MFHI T7
9D02E934  00006812   MFLO T5
9D02E938  310CFFFF   ANDI T4, T0, -1
9D02E93C  00452804   SLLV A1, A1, V0
9D02E940  00641806   SRLV V1, A0, V1
9D02E944  00652825   OR A1, V1, A1
9D02E948  00057402   SRL T6, A1, 16
9D02E94C  00445004   SLLV T2, A0, V0
9D02E950  00001812   MFLO V1
9D02E954  71AC5802   MUL T3, T5, T4
9D02E958  000F1400   SLL V0, T7, 16
9D02E95C  01C21025   OR V0, T6, V0
9D02E960  004B202B   SLTU A0, V0, T3
9D02E964  00C7001B   DIVU A2, A3
9D02E968  00E001F4   TEQ A3, ZERO
9D02E96C  5080000B   BEQL A0, ZERO, 0x9D02E99C
9D02E970  004B1023   SUBU V0, V0, T3
9D02E974  00481021   ADDU V0, V0, T0
9D02E978  0048202B   SLTU A0, V0, T0
9D02E97C  14800006   BNE A0, ZERO, 0x9D02E998
9D02E980  25A3FFFF   ADDIU V1, T5, -1
9D02E984  004B202B   SLTU A0, V0, T3
9D02E988  50800004   BEQL A0, ZERO, 0x9D02E99C
9D02E98C  004B1023   SUBU V0, V0, T3
9D02E990  25A3FFFE   ADDIU V1, T5, -2
9D02E994  00481021   ADDU V0, V0, T0
9D02E998  004B1023   SUBU V0, V0, T3
9D02E99C  30ADFFFF   ANDI T5, A1, -1
9D02E9A0  0047001B   DIVU V0, A3
9D02E9A4  00E001F4   TEQ A3, ZERO
9D02E9A8  00002010   MFHI A0
9D02E9AC  00005812   MFLO T3
9D02E9B0  00003012   MFLO A2
9D02E9B4  716C2802   MUL A1, T3, T4
9D02E9B8  00042400   SLL A0, A0, 16
9D02E9BC  008D2025   OR A0, A0, T5
9D02E9C0  0085682B   SLTU T5, A0, A1
9D02E9C4  0047001B   DIVU V0, A3
9D02E9C8  00E001F4   TEQ A3, ZERO
9D02E9CC  51A0000B   BEQL T5, ZERO, 0x9D02E9FC
9D02E9D0  00031C00   SLL V1, V1, 16
9D02E9D4  00882021   ADDU A0, A0, T0
9D02E9D8  0088102B   SLTU V0, A0, T0
9D02E9DC  14400006   BNE V0, ZERO, 0x9D02E9F8
9D02E9E0  2566FFFF   ADDIU A2, T3, -1
9D02E9E4  0085102B   SLTU V0, A0, A1
9D02E9E8  50400004   BEQL V0, ZERO, 0x9D02E9FC
9D02E9EC  00031C00   SLL V1, V1, 16
9D02E9F0  2566FFFE   ADDIU A2, T3, -2
9D02E9F4  00882021   ADDU A0, A0, T0
9D02E9F8  00031C00   SLL V1, V1, 16
9D02E9FC  00852023   SUBU A0, A0, A1
9D02EA00  0B40BA18   J .LBB16
9D02EA04  00C31825   OR V1, A2, V1
9D02EA08  00481023   SUBU V0, V0, T0
9D02EA0C  01073804   SLLV A3, A3, T0
9D02EA10  00461806   SRLV V1, A2, V0
9D02EA14  00673825   OR A3, V1, A3
9D02EA18  00455806   SRLV T3, A1, V0
9D02EA1C  00071C02   SRL V1, A3, 16
9D02EA20  0163001B   DIVU T3, V1
9D02EA24  006001F4   TEQ V1, ZERO
9D02EA28  00005010   MFHI T2
9D02EA2C  00007012   MFLO T6
9D02EA30  30ECFFFF   ANDI T4, A3, -1
9D02EA34  01052804   SLLV A1, A1, T0
9D02EA38  00441006   SRLV V0, A0, V0
9D02EA3C  00452825   OR A1, V0, A1
9D02EA40  00057C02   SRL T7, A1, 16
9D02EA44  00001012   MFLO V0
9D02EA48  71CC6802   MUL T5, T6, T4
9D02EA4C  000A5400   SLL T2, T2, 16
9D02EA50  014F5025   OR T2, T2, T7
9D02EA54  014D782B   SLTU T7, T2, T5
9D02EA58  0163001B   DIVU T3, V1
9D02EA5C  006001F4   TEQ V1, ZERO
9D02EA60  11E0000A   BEQ T7, ZERO, 0x9D02EA8C
9D02EA64  01063004   SLLV A2, A2, T0
9D02EA68  01475021   ADDU T2, T2, A3
9D02EA6C  0147582B   SLTU T3, T2, A3
9D02EA70  15600006   BNE T3, ZERO, 0x9D02EA8C
9D02EA74  25C2FFFF   ADDIU V0, T6, -1
9D02EA78  014D582B   SLTU T3, T2, T5
9D02EA7C  51600004   BEQL T3, ZERO, 0x9D02EA90
9D02EA80  014D5023   SUBU T2, T2, T5
9D02EA84  25C2FFFE   ADDIU V0, T6, -2
9D02EA88  01475021   ADDU T2, T2, A3
9D02EA8C  014D5023   SUBU T2, T2, T5
9D02EA90  30A5FFFF   ANDI A1, A1, -1
9D02EA94  0143001B   DIVU T2, V1
9D02EA98  006001F4   TEQ V1, ZERO
9D02EA9C  00007010   MFHI T6
9D02EAA0  00006812   MFLO T5
9D02EAA4  00005812   MFLO T3
9D02EAA8  71AC6002   MUL T4, T5, T4
9D02EAAC  000E7400   SLL T6, T6, 16
9D02EAB0  01C52825   OR A1, T6, A1
9D02EAB4  00AC702B   SLTU T6, A1, T4
9D02EAB8  0143001B   DIVU T2, V1
9D02EABC  006001F4   TEQ V1, ZERO
9D02EAC0  51C0000B   BEQL T6, ZERO, 0x9D02EAF0
9D02EAC4  00021400   SLL V0, V0, 16
9D02EAC8  00A72821   ADDU A1, A1, A3
9D02EACC  00A7182B   SLTU V1, A1, A3
9D02EAD0  14600006   BNE V1, ZERO, 0x9D02EAEC
9D02EAD4  25ABFFFF   ADDIU T3, T5, -1
9D02EAD8  00AC182B   SLTU V1, A1, T4
9D02EADC  50600004   BEQL V1, ZERO, 0x9D02EAF0
9D02EAE0  00021400   SLL V0, V0, 16
9D02EAE4  25ABFFFE   ADDIU T3, T5, -2
9D02EAE8  00A72821   ADDU A1, A1, A3
9D02EAEC  00021400   SLL V0, V0, 16
9D02EAF0  01621025   OR V0, T3, V0
9D02EAF4  00AC2823   SUBU A1, A1, T4
9D02EAF8  00460019   MULTU 0, V0, A2
9D02EAFC  00003810   MFHI A3
9D02EB00  00A7182B   SLTU V1, A1, A3
9D02EB04  14600008   BNE V1, ZERO, 0x9D02EB28
9D02EB08  00003012   MFLO A2
9D02EB0C  50A70003   BEQL A1, A3, 0x9D02EB1C
9D02EB10  01042004   SLLV A0, A0, T0
9D02EB14  0B40B9E9   J .LBE15
9D02EB18  00001821   ADDU V1, ZERO, ZERO
9D02EB1C  0086302B   SLTU A2, A0, A2
9D02EB20  50C0FF20   BEQL A2, ZERO, .LBE15
9D02EB24  00001821   ADDU V1, ZERO, ZERO
9D02EB28  2442FFFF   ADDIU V0, V0, -1
9D02EB2C  0B40B9E9   J .LBE15
9D02EB30  00001821   ADDU V1, ZERO, ZERO
9D02EB34  0B40B9E9   J .LBE15
9D02EB38  24020001   ADDIU V0, ZERO, 1
9D02EB3C  0B40BA2D   J 0x9D02E8B4
9D02EB40  00C83021   ADDU A2, A2, T0
9D02F300  03E00008   JR RA
9D02F304  00000000   NOP
9D02F308  24090020   ADDIU T1, ZERO, 32
9D02F30C  01224823   SUBU T1, T1, V0
9D02F310  01255006   SRLV T2, A1, T1
9D02F314  00081C02   SRL V1, T0, 16
9D02F318  0143001B   DIVU T2, V1
9D02F31C  006001F4   TEQ V1, ZERO
9D02F320  00003010   MFHI A2
9D02F324  00005812   MFLO T3
9D02F328  3107FFFF   ANDI A3, T0, -1
9D02F32C  00452804   SLLV A1, A1, V0
9D02F330  01244806   SRLV T1, A0, T1
9D02F334  01252825   OR A1, T1, A1
9D02F338  00056402   SRL T4, A1, 16
9D02F33C  00444804   SLLV T1, A0, V0
9D02F340  71675802   MUL T3, T3, A3
9D02F344  00063400   SLL A2, A2, 16
9D02F348  01863025   OR A2, T4, A2
9D02F34C  00CB202B   SLTU A0, A2, T3
9D02F350  0143001B   DIVU T2, V1
9D02F354  006001F4   TEQ V1, ZERO
9D02F358  50800006   BEQL A0, ZERO, 0x9D02F374
9D02F35C  00CB3023   SUBU A2, A2, T3
9D02F360  00C83021   ADDU A2, A2, T0
9D02F364  00C8202B   SLTU A0, A2, T0
9D02F368  10800024   BEQ A0, ZERO, 0x9D02F3FC
9D02F36C  00CB502B   SLTU T2, A2, T3
9D02F370  00CB3023   SUBU A2, A2, T3
9D02F374  30AAFFFF   ANDI T2, A1, -1
9D02F378  00C3001B   DIVU A2, V1
9D02F37C  006001F4   TEQ V1, ZERO
9D02F380  00002010   MFHI A0
9D02F384  00002812   MFLO A1
9D02F388  70A72802   MUL A1, A1, A3
9D02F38C  00042400   SLL A0, A0, 16
9D02F390  008A2025   OR A0, A0, T2
9D02F394  0085502B   SLTU T2, A0, A1
9D02F398  00C3001B   DIVU A2, V1
9D02F39C  006001F4   TEQ V1, ZERO
9D02F3A0  5140FF60   BEQL T2, ZERO, .LBB17
9D02F3A4  00852823   SUBU A1, A0, A1
9D02F3A8  00882021   ADDU A0, A0, T0
9D02F3AC  0088302B   SLTU A2, A0, T0
9D02F3B0  54C0FF5C   BNEL A2, ZERO, .LBB17
9D02F3B4  00852823   SUBU A1, A0, A1
9D02F3B8  0085502B   SLTU T2, A0, A1
9D02F3BC  00883021   ADDU A2, A0, T0
9D02F3C0  00CA200B   MOVN A0, A2, T2
9D02F3C4  0B40BC49   J .LBB17
9D02F3C8  00852823   SUBU A1, A0, A1
9D02F3CC  01063023   SUBU A2, T0, A2
9D02F3D0  01271823   SUBU V1, T1, A3
9D02F3D4  0106402B   SLTU T0, T0, A2
9D02F3D8  00681823   SUBU V1, V1, T0
9D02F3DC  0B40BCB9   J .LBB24
9D02F3E0  00431823   SUBU V1, V0, V1
9D02F3E4  004E282B   SLTU A1, V0, T6
9D02F3E8  50A0FFB4   BEQL A1, ZERO, 0x9D02F2BC
9D02F3EC  00084400   SLL T0, T0, 16
9D02F3F0  246DFFFE   ADDIU T5, V1, -2
9D02F3F4  0B40BCAE   J 0x9D02F2B8
9D02F3F8  00471021   ADDU V0, V0, A3
9D02F3FC  00C82021   ADDU A0, A2, T0
9D02F400  0B40BCDC   J 0x9D02F370
9D02F404  008A300B   MOVN A2, A0, T2
9D02F408  0088182B   SLTU V1, A0, T0
9D02F40C  5460FFF0   BNEL V1, ZERO, 0x9D02F3D0
9D02F410  01063023   SUBU A2, T0, A2
9D02F414  00003012   MFLO A2
9D02F418  0B40BCB9   J .LBB24
9D02F41C  00001821   ADDU V1, ZERO, ZERO
9D02F868  03E00008   JR RA
9D02F86C  24020001   ADDIU V0, ZERO, 1
9D02F870  0B40BD77   J 0x9D02F5DC
9D02F874  00C83021   ADDU A2, A2, T0
---  /Applications/microchip/xc32/v2.05/pic32mx/include/lega-c/peripheral/system.h  ---------------------
1:                   /********************************************************************
2:                   
3:                   	System Library Interface Definition
4:                   	
5:                   	Summary:
6:                   		This file contains the interface definition for the System
7:                   		peripheral library.
8:                   		
9:                   	Description:
10:                  		This library provides functions for configuring the peripheral
11:                  		clock, cache settings, and wait states.  For details on the
12:                  		register and bit settings used by these functions, refer to the
13:                  		PIC32 Family Reference Manual.
14:                  
15:                  
16:                   ********************************************************************/
17:                  //DOM-IGNORE-BEGIN
18:                  /********************************************************************
19:                   * FileName:		System.h
20:                   * Dependencies:
21:                   * Processor:		PIC32
22:                   * Hardware:		N/A
23:                   * Assembler:		N/A
24:                   * Linker:		    N/A
25:                   * Company:		    Microchip Technology Inc.
26:                   *
27:                   * Software License Agreement:
28:                   * The software supplied herewith by Microchip Technology Incorporated
29:                   * (the Company) for its PICmicro Microcontroller is intended and
30:                   * supplied to you, the Companys customer, for use solely and
31:                   * exclusively on Microchip PICmicro Microcontroller products. The
32:                   * software is owned by the Company and/or its supplier, and is
33:                   * protected under applicable copyright laws. All rights are reserved.
34:                   * Any use in violation of the foregoing restrictions may subject the
35:                   * user to criminal sanctions under applicable laws, as well as to
36:                   * civil liability for the breach of the terms and conditions of this
37:                   * license.
38:                   *
39:                   * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
40:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
41:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
42:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
43:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
44:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
45:                   *
46:                   * $Id: CoreTimer.h,v 1.2 2006/11/03 15:07:21 C12923 Exp $
47:                   * $Name:  $
48:                   ********************************************************************/
49:                  //DOM-IGNORE-END
50:                   
51:                   
52:                  #ifndef _SYSTEM_HEADER_FILE
53:                  #define _SYSTEM_HEADER_FILE
54:                  
55:                  #include <xc.h>
56:                  #include <peripheral/int.h>
57:                  #include <peripheral/pcache.h>
58:                  #include <peripheral/osc.h>
59:                  #include <peripheral/dma.h>
60:                  #include <peripheral/bmx.h>
61:                  #include <peripheral/lock.h>
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  
67:                  /*
68:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
69:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
70:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
71:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
72:                  */
73:                  #ifndef _SUPPRESS_PLIB_WARNING
74:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
75:                  #endif
76:                  
77:                  
78:                  
79:                  #define FLASH_SPEED_HZ          30000000 //Max Flash speed
80:                  #define PB_BUS_MAX_FREQ_HZ      80000000 //Max Peripheral bus speed
81:                  
82:                  /*********************************************************************
83:                   * SYSTEMConfig Flags
84:                   *********************************************************************/
85:                  #define SYS_CFG_WAIT_STATES     0x00000001 //SYSTEMConfig wait states
86:                  #define SYS_CFG_PB_BUS          0x00000002 //SYSTEMConfig pb bus
87:                  #define SYS_CFG_PCACHE          0x00000004 //SYSTEMConfig cache
88:                  #define SYS_CFG_ALL             0xFFFFFFFF //SYSTEMConfig All
89:                  
90:                  /*********************************************************************
91:                   Function:       
92:                  	unsigned int SYSTEMConfigPB(unsigned int sys_clock)
93:                   
94:                   Description:
95:                  	The function sets the PB divider to the optimum value.
96:                   
97:                   PreCondition:    
98:                  	None
99:                   
100:                  Parameters:           
101:                 	sys_clock - system clock in Hz
102:                  
103:                  Returns:          
104:                 	the PB clock frequency in Hz
105:                  
106:                  Side Effects:
107:                 	The PB clock may be changed
108:                 	
109:                  Overview:	    
110:                 	The function sets the PB divider to the optimum value.
111:                  
112:                  Remarks:            
113:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
114:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
115:                  
116:                  Example:
117:                 	<code>
118:                 	SYSTEMConfigPB(72000000);
119:                 	</code>
120:                  ********************************************************************/
121:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPB(unsigned int sys_clock)
122:                 {
123:                     unsigned int pb_div;
124:                     unsigned int pb_clock;
125:                 
126:                     pb_clock = sys_clock;
127:                 
128:                     if(sys_clock > PB_BUS_MAX_FREQ_HZ)
129:                     {
130:                         pb_div=OSC_PB_DIV_2;
131:                         pb_clock >>= 1;
132:                     }
133:                     else
134:                     {
135:                         pb_div=OSC_PB_DIV_1;
136:                     }
137:                 
138:                     OSCSetPBDIV(pb_div);
139:                 
140:                     return pb_clock;
141:                 }
142:                 
143:                 
144:                 /*********************************************************************
145:                   Function:        
146:                 	void SYSTEMConfigWaitStates(unsigned int sys_clock)
147:                  
148:                   Description:
149:                 	The function sets the Flash Wait states to the optimum value.
150:                  
151:                   PreCondition:    
152:                 	None
153:                  
154:                   Parameters:           
155:                 	sys_clock - system clock in Hz
156:                  
157:                   Returns:          
158:                 	None
159:                  
160:                   Side Effects:    
161:                 	The Wait States may be changed  
162:                  
163:                   Remarks:         
164:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
165:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
166:                  
167:                   Example:
168:                 	<code>
169:                 	SYSTEMConfigWaitStates(72000000);
170:                 	</code>
171:                  ********************************************************************/
172:                 extern inline void __attribute__((always_inline)) SYSTEMConfigWaitStates(unsigned int sys_clock)
173:                 {
174:                 #ifdef _PCACHE
175:                     unsigned int wait_states;
176:                     unsigned int int_status;
177:                 #endif
178:                 
179:                 #ifdef _PCACHE
180:                     wait_states = 0;
181:                 
182:                     while(sys_clock > FLASH_SPEED_HZ)
183:                     {
184:                         wait_states++;
185:                         sys_clock -= FLASH_SPEED_HZ;
186:                     }
187:                 
188:                     int_status=INTDisableInterrupts();
189:                     mCheConfigure(wait_states);
190:                     INTRestoreInterrupts(int_status);
191:                 
192:                 #endif
193:                 }
194:                 
195:                 /*********************************************************************
196:                   Function:        
197:                 		unsigned int SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
198:                   
199:                   Description:
200:                 	The function sets the PB divider and the Flash Wait states to the optimum value.
201:                  
202:                   PreCondition:    
203:                 	None
204:                  
205:                   Parameters:           
206:                 	sys_clock - system clock in Hz
207:                  
208:                   Returns:          
209:                 	the PB clock frequency in Hz
210:                  
211:                   Side Effects:    
212:                 	The PB clock and wait states may be changed
213:                 
214:                   Remarks:            
215:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
216:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
217:                  
218:                   Example:
219:                 	<code>
220:                 	SYSTEMConfigWaitStatesAndPB(72000000);
221:                 	</code>
222:                  ********************************************************************/
223:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
224:                 {
225:                 #ifdef _PCACHE
226:                     unsigned int wait_states;
227:                 #endif
228:                     unsigned int pb_clock;
229:                     unsigned int int_status;
230:                 
231:                     pb_clock = SYSTEMConfigPB(sys_clock);
232:                 
233:                 
234:                     // set the flash wait states based on 1 wait state
235:                     // for every 20 MHz
236:                 #ifdef _PCACHE
237:                     wait_states = 0;
238:                 
239:                     while(sys_clock > FLASH_SPEED_HZ)
240:                     {
241:                         wait_states++;
242:                         sys_clock -= FLASH_SPEED_HZ;
243:                     }
244:                 
245:                     int_status=INTDisableInterrupts();
9D01EFE0  0F40F32E   JAL INTDisableInterrupts
9D01EFE4  3C11BF88   LUI S1, -16504
246:                     mCheConfigure(wait_states);
9D01EFE8  24100001   ADDIU S0, ZERO, 1
9D01EFEC  AE304000   SW S0, 16384(S1)
247:                     INTRestoreInterrupts(int_status);
9D01EFF0  0F40F225   JAL INTRestoreInterrupts
9D01EFF4  00402021   ADDU A0, V0, ZERO
248:                 
249:                 #endif
250:                 
251:                     return pb_clock;
252:                 }
253:                 /*********************************************************************
254:                   Function:       
255:                 	unsigned int SYSTEMConfigPerformance(unsigned int sys_clock)
256:                  
257:                   Description:
258:                 	The function sets the PB divider, the Flash Wait states and the DRM wait states to the optimum value.
259:                     It also enables the cacheability for the K0 segment.
260:                 	
261:                   PreCondition:    
262:                 	None
263:                  
264:                   Parameters:           
265:                 	sys_clock - system clock in Hz
266:                  
267:                   Output:          
268:                 	the PB clock frequency in Hz
269:                  
270:                   Side Effects:    
271:                 	Sets the PB and Flash Wait states
272:                  	
273:                   Remarks:            
274:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
275:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
276:                  
277:                   Example:
278:                 	<code>
279:                 	SYSTEMConfigPerformance(72000000);
280:                 	</code>
281:                  ********************************************************************/
282:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPerformance(unsigned int sys_clock)
283:                 {
284:                     // set up the wait states
285:                     unsigned int pb_clk;
286:                 #ifdef _PCACHE
287:                     unsigned int cache_status;
288:                 #endif
289:                     unsigned int int_status;
290:                 
291:                     pb_clk = SYSTEMConfigWaitStatesAndPB(sys_clock);
292:                 
293:                     int_status=INTDisableInterrupts();
9D01EFF8  0F40F32E   JAL INTDisableInterrupts
9D01EFFC  00000000   NOP
9D01F000  00409021   ADDU S2, V0, ZERO
294:                 
295:                     mBMXDisableDRMWaitState();
9D01F004  24030040   ADDIU V1, ZERO, 64
9D01F008  3C02BF88   LUI V0, -16504
9D01F00C  AC432004   SW V1, 8196(V0)
296:                 
297:                 #ifdef _PCACHE
298:                     cache_status = mCheGetCon();
9D01F010  8E224000   LW V0, 16384(S1)
299:                     cache_status |= CHE_CONF_PF_ALL;
9D01F014  34420030   ORI V0, V0, 48
300:                     mCheConfigure(cache_status);
9D01F018  AE224000   SW V0, 16384(S1)
301:                     CheKseg0CacheOn();
9D01F01C  0F40F276   JAL CheKseg0CacheOn
9D01F020  00000000   NOP
302:                 #endif
303:                 
304:                     INTRestoreInterrupts(int_status);
9D01F024  0F40F225   JAL INTRestoreInterrupts
9D01F028  02402021   ADDU A0, S2, ZERO
305:                 
306:                     return pb_clk;
307:                 
308:                 }
309:                 /*********************************************************************
310:                   Function:       
311:                 	unsigned int SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
312:                  
313:                   Description:
314:                 	The function sets the PB divider, the Flash Wait states or the DRM wait states to the optimum value, 
315:                 	based on the flags selected and on the frequency of the system clock.
316:                     It also enables the cacheability for the K0 segment.
317:                 				   
318:                   PreCondition:    
319:                 	None
320:                  
321:                   Parameters:           
322:                 	sys_clock - system clock frequency in Hz
323:                     flags -
324:                 		*    SYS_CFG_WAIT_STATES  - configure the flash wait states from the system clock
325:                         *    SYS_CFG_PB_BUS       - configure the PB bus from the system clock
326:                         *    SYS_CFG_PCACHE      - configure the pCache (if used)
327:                         *    SYS_CFG_ALL          - configure all based on system clock
328:                  
329:                   Returns:          
330:                 	the PB clock frequency in Hz
331:                  
332:                   Side Effects:    
333:                 	Could change the wait state, pb clock and turn on the pre-fetch buffer and cache. Sets the RAM
334:                     wait state to 0.
335:                   
336:                  
337:                   Remarks:
338:                 	The interrupts are disabled shortly, the DMA is suspended and the system is unlocked while performing the operation.
339:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
340:                  
341:                   Example:
342:                 	<code>
343:                 	SYSTEMConfig(72000000, SYS_CFG_ALL);
344:                 	</code>
345:                  ********************************************************************/
346:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
347:                 {
348:                     unsigned int pb_clk;
349:                     unsigned int int_status;
350:                 #ifdef _PCACHE
351:                     unsigned int cache_status;
352:                 #endif
353:                 
354:                     int_status=INTDisableInterrupts();
355:                 
356:                     mBMXDisableDRMWaitState();
357:                 
358:                     if(flags & SYS_CFG_WAIT_STATES)
359:                     {
360:                         SYSTEMConfigWaitStates(sys_clock);
361:                     }
362:                 
363:                     if(flags & SYS_CFG_PB_BUS)
364:                     {
365:                         SYSTEMConfigPB(sys_clock);
366:                     }
367:                 
368:                 
369:                 #ifdef _PCACHE
370:                     if(flags & SYS_CFG_PCACHE)
371:                     {
372:                         cache_status = mCheGetCon();
373:                         cache_status |= CHE_CONF_PF_ALL;
374:                         mCheConfigure(cache_status);
375:                         CheKseg0CacheOn();
376:                     }
377:                 #endif
378:                 
379:                     pb_clk = sys_clock;
380:                     pb_clk >>= OSCCONbits.PBDIV;
381:                 
382:                     INTRestoreInterrupts(int_status);
383:                 
384:                     return pb_clk;
385:                 
386:                 }
387:                 #ifdef __cplusplus
388:                   }
389:                 #endif
390:                 #endif
391:                 
---  /Applications/microchip/xc32/v2.05/pic32mx/include/lega-c/peripheral/osc.h  ------------------------
1:                   /*********************************************************************
2:                    *
3:                    *                  OSC API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        OSC.h
7:                    * Dependencies:
8:                    * Processor:       PIC32
9:                    *
10:                   *
11:                   * Compiler:        MPLAB XC32
12:                   *                  MPLAB IDE
13:                   * Company:         Microchip Technology Inc.
14:                   *
15:                   * Software License Agreement
16:                   *
17:                   * The software supplied herewith by Microchip Technology Incorporated
18:                   * (the Company) for its PIC Microcontroller is intended
19:                   * and supplied to you, the Companys customer, for use solely and
20:                   * exclusively on Microchip PIC Microcontroller products.
21:                   * The software is owned by the Company and/or its supplier, and is
22:                   * protected under applicable copyright laws. All rights are reserved.
23:                   * Any use in violation of the foregoing restrictions may subject the
24:                   * user to criminal sanctions under applicable laws, as well as to
25:                   * civil liability for the breach of the terms and conditions of this
26:                   * license.
27:                   *
28:                   * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
29:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
30:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
31:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
32:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
33:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
34:                   *
35:                   *
36:                   * $Id: OSC.h,v 1.6 2006/10/13 21:24:31 C12532 Exp $
37:                   * $Name:  $
38:                   ********************************************************************/
39:                  
40:                  #ifndef OSC_H_
41:                  #define OSC_H_
42:                  
43:                  #include <xc.h>
44:                  #include <peripheral/lock.h>
45:                  
46:                  /*
47:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
48:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
49:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
50:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
51:                  */
52:                  #ifndef _SUPPRESS_PLIB_WARNING
53:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
54:                  #endif
55:                  
56:                  
57:                  #define _OSC_
58:                  
59:                  /*********************************************************************
60:                   * Function:        OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div)
61:                   *
62:                   * Description:     Sets Osc options and clock source
63:                   *
64:                   * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
65:                   *
66:                   * Inputs:          Clock source, PLL multiplier, PLL postscaler, FRC divisor - see below
67:                   *
68:                   * Output:          None
69:                   *
70:                   * Example:         OSCConfig( OSC_POSC, OSC_PLL_MULT_24, OSC_PLL_POST_256, OSC_FRC_POST_64 )
71:                   *
72:                   * Note:            Forces cpu clock source to FRC(no divisor, no PLL), configures new clock
73:                   *                  source and then switches to the new clock source
74:                   *
75:                   *                  Unused parameters are set to zero/default values.
76:                   ********************************************************************/
77:                  void OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div);
78:                  
79:                      /******************************************************************************
80:                       * Available options for source parameter
81:                       *****************************************************************************/
82:                          // CPU Oscillator modes - values are mutually exclusive
83:                          #define OSC_FRC_DIV     (7 << _OSCCON_NOSC_POSITION)
84:                          #define OSC_FRC_DIV16   (6 << _OSCCON_NOSC_POSITION)
85:                          #define OSC_LPRC        (5 << _OSCCON_NOSC_POSITION)
86:                          #define OSC_SOSC        (4 << _OSCCON_NOSC_POSITION)
87:                          #define OSC_POSC_PLL    (3 << _OSCCON_NOSC_POSITION)
88:                          #define OSC_POSC        (2 << _OSCCON_NOSC_POSITION)
89:                          #define OSC_FRC_PLL     (1 << _OSCCON_NOSC_POSITION)
90:                          #define OSC_FRC         (0 << _OSCCON_NOSC_POSITION)
91:                  
92:                      /******************************************************************************
93:                       * Available options for mult parameter
94:                       *****************************************************************************/
95:                          // CPU PLL multiplier values - values are mutually exclusive
96:                          #define OSC_PLL_MULT_24 (7 << _OSCCON_PLLMULT_POSITION)
97:                          #define OSC_PLL_MULT_21 (6 << _OSCCON_PLLMULT_POSITION)
98:                          #define OSC_PLL_MULT_20 (5 << _OSCCON_PLLMULT_POSITION)
99:                          #define OSC_PLL_MULT_19 (4 << _OSCCON_PLLMULT_POSITION)
100:                         #define OSC_PLL_MULT_18 (3 << _OSCCON_PLLMULT_POSITION)
101:                         #define OSC_PLL_MULT_17 (2 << _OSCCON_PLLMULT_POSITION)
102:                         #define OSC_PLL_MULT_16 (1 << _OSCCON_PLLMULT_POSITION)
103:                         #define OSC_PLL_MULT_15 (0 << _OSCCON_PLLMULT_POSITION)
104:                 
105:                     /******************************************************************************
106:                      * Available options for post parameter
107:                      *****************************************************************************/
108:                         // CPU PLL output divisor values - values are mutuallye exclusive
109:                         #define OSC_PLL_POST_256 (7 << _OSCCON_PLLODIV_POSITION)
110:                         #define OSC_PLL_POST_64  (6 << _OSCCON_PLLODIV_POSITION)
111:                         #define OSC_PLL_POST_32  (5 << _OSCCON_PLLODIV_POSITION)
112:                         #define OSC_PLL_POST_16  (4 << _OSCCON_PLLODIV_POSITION)
113:                         #define OSC_PLL_POST_8   (3 << _OSCCON_PLLODIV_POSITION)
114:                         #define OSC_PLL_POST_4   (2 << _OSCCON_PLLODIV_POSITION)
115:                         #define OSC_PLL_POST_2   (1 << _OSCCON_PLLODIV_POSITION)
116:                         #define OSC_PLL_POST_1   (0 << _OSCCON_PLLODIV_POSITION)
117:                 
118:                     /******************************************************************************
119:                      * Available options for div parameter
120:                      *****************************************************************************/
121:                         // CPU FRC output divisor values - values are mutually exclusive
122:                         #define OSC_FRC_POST_256 (7 << _OSCCON_FRCDIV_POSITION)
123:                         #define OSC_FRC_POST_64  (6 << _OSCCON_FRCDIV_POSITION)
124:                         #define OSC_FRC_POST_32  (5 << _OSCCON_FRCDIV_POSITION)
125:                         #define OSC_FRC_POST_16  (4 << _OSCCON_FRCDIV_POSITION)
126:                         #define OSC_FRC_POST_8   (3 << _OSCCON_FRCDIV_POSITION)
127:                         #define OSC_FRC_POST_4   (2 << _OSCCON_FRCDIV_POSITION)
128:                         #define OSC_FRC_POST_2   (1 << _OSCCON_FRCDIV_POSITION)
129:                         #define OSC_FRC_POST_1   (0 << _OSCCON_FRCDIV_POSITION)
130:                     /***********************************
131:                      * End parameter values
132:                      ************************************/
133:                 
134:                 #if defined(__32MX120F064H__) || \
135:                     defined(__32MX130F128H__) || \
136:                     defined(__32MX130F128L__) || \
137:                     defined(__32MX150F256H__) || \
138:                     defined(__32MX150F256L__) || \
139:                     defined(__32MX170F512H__) || \
140:                     defined(__32MX170F512L__) || \
141:                     defined(__32MX230F128H__) || \
142:                     defined(__32MX230F128L__) || \
143:                     defined(__32MX250F256H__) || \
144:                     defined(__32MX250F256L__) || \
145:                     defined(__32MX270F512H__) || \
146:                     defined(__32MX270F512L__) || \
147:                     defined(__32MX530F128H__) || \
148:                     defined(__32MX530F128L__) || \
149:                     defined(__32MX550F256H__) || \
150:                     defined(__32MX550F256L__) || \
151:                     defined(__32MX570F512H__) || \
152:                     defined(__32MX570F512L__)
153:                   #define NEED_OSCREFCONFIG_FLAGS
154:                 #elif (__PIC32_FEATURE_SET__ >= 100) && (__PIC32_FEATURE_SET__ <= 299)
155:                   #define NEED_OSCREFCONFIG_FLAGS
156:                 #elif (__PIC32_FEATURE_SET__ == 330) || \
157:                       (__PIC32_FEATURE_SET__ == 350) || \
158:                       (__PIC32_FEATURE_SET__ == 370) || \
159:                       (__PIC32_FEATURE_SET__ == 430) || \
160:                       (__PIC32_FEATURE_SET__ == 450) || \
161:                       (__PIC32_FEATURE_SET__ == 470)
162:                   #define NEED_OSCREFCONFIG_FLAGS
163:                 #else
164:                   #undef  NEED_OSCREFCONFIG_FLAGS
165:                 #endif
166:                 
167:                 #if defined( NEED_OSCREFCONFIG_FLAGS )
168:                   // Reference Oscillator Source Select bits - values are mutually exclusive
169:                   #define OSC_REFOCON_REFCLKI     (7 << _REFOCON_ROSEL_POSITION )
170:                   #define OSC_REFOCON_SYSPLL      (7 << _REFOCON_ROSEL_POSITION )
171:                   #define OSC_REFOCON_USBPLL      (6 << _REFOCON_ROSEL_POSITION )
172:                   #define OSC_REFOCON_SOSC        (5 << _REFOCON_ROSEL_POSITION )
173:                   #define OSC_REFOCON_LPRC        (4 << _REFOCON_ROSEL_POSITION )
174:                   #define OSC_REFOCON_FRC         (3 << _REFOCON_ROSEL_POSITION )
175:                   #define OSC_REFOCON_POSC        (2 << _REFOCON_ROSEL_POSITION )
176:                   #define OSC_REFOCON_PBCLK       (1 << _REFOCON_ROSEL_POSITION )
177:                   #define OSC_REFOCON_SYSCLK      (0 << _REFOCON_ROSEL_POSITION )
178:                 
179:                   typedef enum
180:                   {
181:                       OSC_REFOCON_RLSPEN      =(1 << _REFOCON_RSLP_POSITION ) ,
182:                       OSC_REFOCON_OE          =(1 << _REFOCON_OE_POSITION ),
183:                       OSC_REFOCON_SIDLEN      =(1 << _REFOCON_SIDL_POSITION ),
184:                       OSC_REFOCON_ON          =(1 << _REFOCON_ON_POSITION )
185:                   } OSCREFConfigFlags;
186:                 
187:                   void OSCREFConfig(unsigned long int source, OSCREFConfigFlags config, unsigned long int div);
188:                 
189:                   #define mOSCREFOTRIMSet(trim)       (REFOTRIM = (trim << _REFOTRIM_ROTRIM_POSITION))
190:                 
191:                 #endif//defined( NEED_OSCREFCONFIG_FLAGS )
192:                 
193:                 #undef  NEED_OSCREFCONFIG_FLAGS
194:                 
195:                 
196:                 /*********************************************************************
197:                  * Function:    OSCSetPBDIV(unsigned int oscPbDiv)
198:                  *
199:                  * Description: Configures peripheral bus divisor
200:                  *
201:                  * PreCondition: oscPbDiv one of the OSC_PB_DIV_X valid values
202:                  *
203:                  * Inputs:    oscPbDiv - desired PB divider
204:                  *
205:                  * Output:      None
206:                  *
207:                  * Example:   OSCSetPBDIV(  OSC_PB_DIV_8 )
208:                  *
209:                  ********************************************************************/
210:                 extern inline void __attribute__((always_inline)) OSCSetPBDIV(unsigned int oscPbDiv)
211:                 {
212:                     unsigned int dma_status;
213:                     unsigned int int_status;
214:                     __OSCCONbits_t oscBits;
215:                 
216:                     mSYSTEMUnlock(int_status, dma_status);
9D01EF7C  0F40F32E   JAL INTDisableInterrupts
9D01EF80  AFB00010   SW S0, 16(SP)
9D01EFB8  0B407CF4   J 0x9D01F3D0
9D01EFBC  3C05BF81   LUI A1, -16511
9D01F3D0  ACA0F230   SW ZERO, -3536(A1)
9D01F3D4  3C03AA99   LUI V1, -21863
9D01F3D8  24636655   ADDIU V1, V1, 26197
9D01F3DC  ACA3F230   SW V1, -3536(A1)
9D01F3E0  3C035566   LUI V1, 21862
9D01F3E4  346399AA   ORI V1, V1, -26198
9D01F3E8  ACA3F230   SW V1, -3536(A1)
9D01F420  ACA0F230   SW ZERO, -3536(A1)
9D01F424  3C03AA99   LUI V1, -21863
9D01F428  24636655   ADDIU V1, V1, 26197
9D01F42C  ACA3F230   SW V1, -3536(A1)
9D01F430  3C035566   LUI V1, 21862
9D01F434  346399AA   ORI V1, V1, -26198
9D01F438  ACA3F230   SW V1, -3536(A1)
217:                 
218:                     oscBits.w=OSCCON;       // read to be in sync. flush any pending write
9D01F3EC  3C04BF81   LUI A0, -16511
9D01F3F0  8C83F000   LW V1, -4096(A0)
9D01F43C  3C04BF81   LUI A0, -16511
9D01F440  8C83F000   LW V1, -4096(A0)
219:                     oscBits.PBDIV=0;
9D01F3F4  7C03A4C4   INS V1, ZERO, 19, 2
9D01F444  7C03A4C4   INS V1, ZERO, 19, 2
220:                     oscBits.w|=oscPbDiv;
221:                     OSCCON=oscBits.w;       // write back
9D01F3F8  AC83F000   SW V1, -4096(A0)
9D01F448  AC83F000   SW V1, -4096(A0)
222:                     oscBits.w=OSCCON;       // make sure the write occurred before returning from this function
9D01F3FC  8C83F000   LW V1, -4096(A0)
9D01F44C  8C83F000   LW V1, -4096(A0)
223:                 
224:                     mSYSTEMLock(int_status, dma_status);
9D01EFD8  0F40F225   JAL INTRestoreInterrupts
9D01EFDC  00402021   ADDU A0, V0, ZERO
9D01F400  3C033333   LUI V1, 13107
9D01F404  24633333   ADDIU V1, V1, 13107
9D01F408  ACA3F230   SW V1, -3536(A1)
9D01F450  3C033333   LUI V1, 13107
9D01F454  24633333   ADDIU V1, V1, 13107
9D01F458  ACA3F230   SW V1, -3536(A1)
225:                 }
226:                 
227:                 #define     mOSCSetPBDIV        OSCSetPBDIV     // backward compatibility
228:                 
229:                 
230:                 
231:                     /******************************************************************************
232:                      * Available options for config parameter
233:                      *****************************************************************************/
234:                         // CPU Peripheral Bus divisor values - values are mutually exclusive
235:                         #define OSC_PB_DIV_8    (3 << _OSCCON_PBDIV_POSITION)
236:                         #define OSC_PB_DIV_4    (2 << _OSCCON_PBDIV_POSITION)
237:                         #define OSC_PB_DIV_2    (1 << _OSCCON_PBDIV_POSITION)
238:                         #define OSC_PB_DIV_1    (0 << _OSCCON_PBDIV_POSITION)
239:                     /***********************************
240:                      * End config parameter values
241:                      ************************************/
242:                 
243:                 
244:                 /*********************************************************************
245:                  * Function:    mOSCGetPBDIV()
246:                  *
247:                  * Description: Reads peripheral bus divisor
248:                  *
249:                  * PreCondition:None
250:                  *
251:                  * Inputs:      None
252:                  *
253:                  * Output:      None
254:                  *
255:                  * Example:     mOSCGetPBDIV()
256:                  *
257:                  ********************************************************************/
258:                 #define mOSCGetPBDIV() (OSCCONbits.PBDIV)
259:                 
260:                 
261:                 /*********************************************************************
262:                  * Function:    mOSCClockFailStatus()
263:                  *
264:                  * Description: Returns Clock Fail status. 1 = clock fail, 0 = no clock fail
265:                  *
266:                  * PreCondition: None
267:                  *
268:                  * Inputs:      None
269:                  *
270:                  * Output:      None
271:                  *
272:                  * Example:     mOSCClockFailStatus()
273:                  *
274:                  ********************************************************************/
275:                 #define mOSCClockFailStatus (OSCCONbits.CF)
276:                 
277:                 
278:                 /*********************************************************************
279:                  * Function:        mOSCEnableSOSC()
280:                  *
281:                  * Description:     Enables the LPRC
282:                  *
283:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
284:                  *
285:                  * Inputs:          None
286:                  *
287:                  * Output:          None
288:                  *
289:                  * Example:         mOSCEnableSOSC()
290:                  *
291:                  ********************************************************************/
292:                 #define mOSCEnableSOSC() mSysUnlockOpLock(OSCCONSET = _OSCCON_SOSCEN_MASK)
293:                 
294:                 
295:                 /*********************************************************************
296:                  * Function:        mOSCDisableSOSC(config)
297:                  *
298:                  * Description:     Disables SOSC
299:                  *
300:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
301:                  *
302:                  * Inputs:          None
303:                  *
304:                  * Output:          None
305:                  *
306:                  * Example:         mOSCDisableSOSC()
307:                  *
308:                  ********************************************************************/
309:                 #define mOSCDisableSOSC() mSysUnlockOpLock(OSCCONCLR = _OSCCON_SOSCEN_MASK)
310:                 
311:                 
312:                 
313:                 #endif
---  /Applications/microchip/xc32/v2.05/pic32mx/include/lega-c/peripheral/dma_1xx_2xx.h  ----------------
1:                   /*********************************************************************
2:                    *
3:                    *                  DMA API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        Dma.h
7:                    * Dependencies:    xc.h
8:                    *                  int.h
9:                    *
10:                   * Processor:       PIC32
11:                   *
12:                   * Compiler:        MPLAB XC32
13:                   *                  MPLAB IDE
14:                   * Company:         Microchip Technology Inc.
15:                   *
16:                   * Software License Agreement
17:                   *
18:                   * The software supplied herewith by Microchip Technology Incorporated
19:                   * (the Company) for its PIC32/PIC24F Microcontroller is intended
20:                   * and supplied to you, the Companys customer, for use solely and
21:                   * exclusively on Microchip PIC32/PIC24F Microcontroller products.
22:                   * The software is owned by the Company and/or its supplier, and is
23:                   * protected under applicable copyright laws. All rights are reserved.
24:                   * Any use in violation of the foregoing restrictions may subject the
25:                   * user to criminal sanctions under applicable laws, as well as to
26:                   * civil liability for the breach of the terms and conditions of this
27:                   * license.
28:                   *
29:                   * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
30:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
31:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
32:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
33:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
34:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
35:                   *
36:                   *
37:                   * $Id: Dma.h,v 1.9 2007/01/17 21:35:46 C12878 Exp $
38:                   * $Name:  $
39:                   *
40:                   ********************************************************************/
41:                  
42:                  #ifndef _DMA_1XX_2XX_H_
43:                  #define _DMA_1XX_2XX_H_
44:                  
45:                  #include <xc.h>
46:                  
47:                  /*
48:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
49:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
50:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
51:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
52:                  */
53:                  #ifndef _SUPPRESS_PLIB_WARNING
54:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
55:                  #endif
56:                  
57:                  
58:                  // DMA definitions
59:                  
60:                  #ifdef _DMAC0
61:                      #define _DMA_CHANNELS       // DMA channels exist
62:                  
63:                  
64:                  // existent DMA channels
65:                      typedef enum
66:                      {
67:                          DMA_CHANNEL0,
68:                      #ifdef _DMAC1
69:                          DMA_CHANNEL1,
70:                      # ifdef _DMAC2
71:                          DMA_CHANNEL2,
72:                      #  ifdef _DMAC3
73:                          DMA_CHANNEL3,
74:                      #  endif// _DMAC3
75:                      # endif // _DMAC2
76:                      #endif  // _DMAC1
77:                          //  add/remove DMA channel as needed here
78:                  
79:                          DMA_CHANNELS    // number of current available channels
80:                      }DmaChannel;
81:                  
82:                  
83:                      // Relative Dma channels priority, between each other
84:                      typedef enum
85:                      {
86:                          DMA_CHN_PRI0,
87:                          DMA_CHN_PRI1,
88:                          DMA_CHN_PRI2,
89:                          DMA_CHN_PRI3
90:                      }DmaChannelPri;
91:                  
92:                  
93:                  
94:                      // high level definitions for the API functions
95:                  
96:                      typedef enum
97:                      {
98:                          DMA_OPEN_DEFAULT = 0,                                   // DMA default operation
99:                          DMA_OPEN_AUTO   = _DCH0CON_CHAEN_MASK,                  // DMA channel is auto enabled
100:                         DMA_OPEN_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK),   // DMA channel is chained to lower channel
101:                         DMA_OPEN_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),             // DMA channel is chained to higher channel
102:                         DMA_OPEN_DET_EN = _DCH0CON_CHAED_MASK,                  // events detection enabled while channel off
103:                         DMA_OPEN_ENABLE = _DCH0CON_CHEN_MASK,                   // DMA channel is enabled after open
104:                         DMA_OPEN_MATCH  = 0x80000000,                           // DMA channel stops on match
105:                     }DmaOpenFlags;  // flags for the channel open
106:                 
107:                 
108:                     typedef enum
109:                     {
110:                         DMA_EV_ERR =            0x1,        // address error event
111:                         DMA_EV_ABORT =          0x2,        // transfer abort event
112:                         DMA_EV_CELL_DONE =      0x4,        // cell transfer complete event
113:                         DMA_EV_BLOCK_DONE =     0x8,        // block transfer complete event
114:                         DMA_EV_DST_HALF =       0x10,       // destination half event
115:                         DMA_EV_DST_FULL =       0x20,       // destination full event
116:                         DMA_EV_SRC_HALF =       0x40,       // source half event
117:                         DMA_EV_SRC_FULL =       0x80,       // source full event
118:                 
119:                         DMA_EV_ALL_EVNTS=       (DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_CELL_DONE|DMA_EV_BLOCK_DONE|DMA_EV_DST_HALF|
120:                                                     DMA_EV_DST_FULL|DMA_EV_SRC_HALF|DMA_EV_SRC_FULL)                // all available events
121:                     }DmaEvFlags;    // flags for controlling the DMA channel events; Bit fields from the processor header file.
122:                 
123:                 
124:                     typedef enum
125:                     {
126:                         DMA_TXFER_OK,           // the transfer was performed successfully
127:                         DMA_TXFER_ADD_ERR,      // address error while performing the transfer
128:                         DMA_TXFER_ABORT,        // the DMA transfer was aborted
129:                         DMA_TXFER_BC_ERR,       // block complete not set after the DMA transfer performed
130:                         DMA_TXFER_CC_ERR,       // cell complete not set after the DMA transfer performed
131:                         DMA_TXFER_TMO           // DMA transfer timeout
132:                     }DmaTxferRes;       // DMA transfer result
133:                 
134:                     typedef enum
135:                     {
136:                         DMA_WAIT_NOT,       // don't wait for the transfer to complete, return immediately
137:                         DMA_WAIT_CELL,      // wait for the cell transfer to complete, than return
138:                         DMA_WAIT_BLOCK      // wait for the block transfer to complete, than return
139:                     }DmaWaitMode;       // DMA transfer wait mode
140:                 
141:                     typedef enum
142:                     {
143:                         DMA_CHKSUM_CRC,     // LFSR CRC
144:                         DMA_CHKSUM_IP,      // IP Checksum
145:                     }DmaChksumType;     // DMA SFM supported checksum types
146:                 
147:                     typedef enum
148:                     {
149:                         DMA_BITO_MSb,       // MSb first (not reflected)
150:                         DMA_BITO_LSb,       // LSb first (reflected)
151:                     }DmaBitOrder;       // DMA SFM supported bit ordering
152:                 
153:                     typedef enum
154:                     {
155:                         DMA_REORDER_NOT,    // no reordering, destination matches the source
156:                         DMA_REORDER_ENDIAN, // change endianess on word (32 bit) boundaries: LE<->BE
157:                         DMA_REORDER_SWAP_HALF,  // swap half words (16 bit) within word (32 bit)
158:                         DMA_REORDER_SWAP_BYTE,  // swap bytes within half word (16 bit)
159:                     }DmaReorderMode;    // DMA SFM supported re-ordering modes
160:                 
161:                 
162:                     /*********************************************************************
163:                      * Function:        void DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags)
164:                      *
165:                      * PreCondition:    chPri  - valid channel priority, 0-3
166:                      *
167:                      * Input:           chn    - channel to be configured in the DMA controller
168:                      *                  chPri  - the priority given to the channel, 0-3
169:                      *                  oFlags - orred flags specifying the open mode:
170:                      *                           DMA_OPEN_DEFAULT: DMA default operation mode
171:                      *                           DMA_OPEN_AUTO: DMA channel is auto enabled
172:                      *                           DMA_OPEN_CHAIN_LOW: DMA channel is chained to lower channel
173:                      *                           DMA_OPEN_CHAIN_HI: DMA channel is chained to higher channel
174:                      *                           DMA_OPEN_DET_EN: events detection enabled while channel off
175:                      *                           DMA_OPEN_ENABLE: DMA channel is enabled when opened
176:                      *                           DMA_OPEN_MATCH:    DMA channel stops on match
177:                      *
178:                      *
179:                      *
180:                      * Output:          None
181:                      *
182:                      * Side Effects:    None
183:                      *
184:                      * Overview:        The function opens and configures the selected DMA channel using the supplied user flags and priority.
185:                      *
186:                      * Note:            - This is a high level access function that doesn't give access to all the settings possible for a DMA channel.
187:                      *                  Use the low level functions to address special settings.
188:                      *                  - The channel is turned off, the pending interrupts are cleared, interrupts are disabled.
189:                      *                  After that the channel is configured.
190:                      *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
191:                      *                  if DMA_OPEN_ENABLE flag was not specified.
192:                      *                  - If the CRC is attached to the submitted channel, the CRC append mode will be turned off.
193:                      *                  This way, the transfer will occur correctly together with CRC calculation.
194:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
195:                      *                  User has to call event channel functions to enable the event flags if needed.
196:                      *
197:                      * Example:         DmaChnOpen(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_OPEN_AUTO|DMA_OPEN_MATCH|DMA_OPEN_ENABLE);
198:                      ********************************************************************/
199:                      void           DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags);
200:                 
201:                     /*********************************************************************
202:                      * Function:        void DmaChnEnable(DmaChannel chn)
203:                      *
204:                      * PreCondition:    None
205:                      *
206:                      * Input:           chn     - channel to be enabled
207:                      *
208:                      * Output:          None
209:                      *
210:                      * Side Effects:    None
211:                      *
212:                      * Overview:        The function enables a previously configured DMA channel.
213:                      *
214:                      * Note:            DmaChnOpen()/DmaChnConfigure() should have been called before.
215:                      *
216:                      * Example:         DmaChnEnable(DMA_CHANNEL3);
217:                      ********************************************************************/
218:                      void           DmaChnEnable(DmaChannel chn);
219:                 
220:                     /*********************************************************************
221:                      * Function:        void DmaChnDisable(DmaChannel chn)
222:                      *
223:                      * PreCondition:    None
224:                      *
225:                      * Input:           chn     - selected channel in the DMA controller
226:                      *
227:                      * Output:          None
228:                      *
229:                      * Side Effects:    None
230:                      *
231:                      * Overview:        The function disables a DMA channel. The channel operation stops.
232:                      *
233:                      * Note:            None.
234:                      *
235:                      * Example:         DmaChnDisable(DMA_CHANNEL3);
236:                      ********************************************************************/
237:                      void           DmaChnDisable(DmaChannel chn);
238:                 
239:                     /*********************************************************************
240:                      * Function:        void DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize)
241:                      *
242:                      * PreCondition:    chn     - valid DMA channel
243:                      *              - vSrcAdd, vDstAdd  - valid pointers
244:                      *                              - 0 < srcSize <= DmaGetMaxTxferSize()
245:                      *                              - 0 < dstSize <= DmaGetMaxTxferSize()
246:                      *                              - 0 < cellSize <= DmaGetMaxTxferSize()
247:                      *
248:                      * Input:           chn         - DMA channel number
249:                      *                              - vSrcAdd: source of the DMA transfer
250:                      *                              - vDstAdd: destination of the DMA transfer
251:                      *                              - srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
252:                      *                              - dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
253:                      *                              - cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
254:                      *
255:                      * Output:          None
256:                      *
257:                      * Side Effects:    None
258:                      *
259:                      * Overview:        The function sets the transfer characteristics for a DMA channel transfer:
260:                      *                  the source and the destination addresses.
261:                      *                  the source and destination lengths
262:                      *                  and the number of bytes transferred per event.
263:                      *
264:                      * Note:            The function clears the existing DMA channel event flags.
265:                      *                  The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
266:                      *
267:                      * Example:         DmaChnSetTxfer(DMA_CHANNEL3, &U2RXREG, dstBuff, 1, 200, 1);
268:                      ********************************************************************/
269:                      void           DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize);
270:                 
271:                 
272:                     /*********************************************************************
273:                      * Function:        void DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd)
274:                      *
275:                      * PreCondition:    chn     - valid DMA channel
276:                      *
277:                      * Input:           chn     - DMA channel number
278:                      *              - vSrcAdd: source (virtual) of the DMA transfer
279:                      * Output:          None
280:                      *
281:                      * Side Effects:    None
282:                      *
283:                      * Overview:        The function is a helper to set directly the transfer source address.
284:                      *
285:                      * Note:            None.
286:                      *
287:                      * Example:         DmaChnSetSrcAdd(DMA_CHANNEL2, srcBuff+sizeof(srcBuff));
288:                      ********************************************************************/
289:                      void           DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd);
290:                 
291:                     /*********************************************************************
292:                      * Function:        void DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd)
293:                      *
294:                      * PreCondition:    chn     - valid DMA channel
295:                      *
296:                      * Input:           chn         - DMA channel number
297:                      *                              - vDstAdd: destination (virtual) of the DMA transfer
298:                      * Output:          None
299:                      *
300:                      * Side Effects:    None
301:                      *
302:                      * Overview:        The function is a helper to set directly the transfer destination address.
303:                      *
304:                      * Note:            None
305:                      *
306:                      * Example:         DmaChnSetDstAdd(DMA_CHANNEL2, dstBuff+sizeof(dstBuff));
307:                      ********************************************************************/
308:                      void           DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd);
309:                 
310:                     /*********************************************************************
311:                      * Function:        void DmaChnSetMatchPattern(DmaChannel chn, int pattern)
312:                      *
313:                      * PreCondition:    chn - valid DMA channel
314:                      *
315:                      * Input:           chn     - DMA channel number
316:                      *                  pattern -  the match pattern
317:                      *
318:                      * Output:          None
319:                      *
320:                      * Side Effects:    None
321:                      *
322:                      * Overview:        The function sets the curent match pattern for the selected DMA channel.
323:                      *
324:                      * Note:            None.
325:                      *
326:                      * Example:         DmaChnSetMatchPattern(DMA_CHANNEL3, '\r');
327:                      ********************************************************************/
328:                      void           DmaChnSetMatchPattern(DmaChannel chn, int pattern);
329:                 
330:                     /*********************************************************************
331:                      * Function:        int DmaChnGetMatchPattern(DmaChannel chn)
332:                      *
333:                      * PreCondition:    chn - valid DMA channel
334:                      *
335:                      * Input:           chn     - DMA channel number
336:                      *
337:                      * Output:          The channel match pattern.
338:                      *
339:                      * Side Effects:    None
340:                      *
341:                      * Overview:        The function retrieves the curent match pattern for the selected DMA channel.
342:                      *
343:                      * Note:            None.
344:                      *
345:                      * Example:         int pattern=DmaChnGetMatchPattern(DMA_CHANNEL3);
346:                      ********************************************************************/
347:                      int            DmaChnGetMatchPattern(DmaChannel chn);
348:                 
349:                     /*********************************************************************
350:                      * Function:        DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries)
351:                      *
352:                      * PreCondition:    chn - valid DMA channel
353:                      *
354:                      * Input:           chn     - DMA channel number
355:                      *                  wMode   - if DMA_WAIT_NOT, return immediately
356:                      *                          - if DMA_WAIT_CELL, return after the cell transfer complete
357:                      *                          - if DMA_WAIT_BLOCK, return after the whole transfer is done
358:                      *                  retries - retry counter: if transfer not complete after so many retries, return with tmo.
359:                      *                              If 0, wait forever.
360:                      *
361:                      * Output:          DMA_TXFER_OK if not waiting for the transfer completion or if the transfer ended normally,
362:                      *                  an DmaTxferRes error code  otherwise
363:                      *
364:                      * Side Effects:    None
365:                      *
366:                      * Overview:        The function initiates (forces) a DMA transfer for the selected DMA channel.
367:                      *                  The DMA channel is enabled.
368:                      *                  If waiting for the transfer completion needed (user doesn't use an ISR to catch
369:                      *                  this event) the function will periodically query the DMA controller for the
370:                      *                  transfer completion status.
371:                      *                  If DMA_WAIT_BLOCK is specified and multiple cell transfers are needed to complete
372:                      *                  the block transfer than the function will re-force the transfer for each cell.
373:                      *
374:                      * Note:            This function can not ne used when the DMA channel is triggerred
375:                      *                  by hardware interrupt requests.
376:                      *                  This is because the transfers are software forced, theere is no
377:                      *                  wait for the occurrence of the hardware trigger.
378:                      *
379:                      * Example:         DmaChnStartTxfer(DMA_CHANNEL2, DMA_WAIT_BLOCK, 0);
380:                      ********************************************************************/
381:                      DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries);
382:                 
383:                     /*********************************************************************
384:                      * Function:        void DmaChnForceTxfer(DmaChannel chn)
385:                      *
386:                      * PreCondition:    chn - valid DMA channel
387:                      *
388:                      * Input:           chn     - DMA channel number
389:                      *
390:                      * Output:          None
391:                      *
392:                      * Side Effects:    None
393:                      *
394:                      * Overview:        The function forces a DMA transfer to occur for the selected DMA channel.
395:                      *
396:                      * Note:            None.
397:                      *
398:                      * Example:         DmaChnForceTxfer(DMA_CHANNEL3);
399:                      ********************************************************************/
400:                      void           DmaChnForceTxfer(DmaChannel chn);
401:                 
402:                     /*********************************************************************
403:                      * Function:        void DmaChnAbortTxfer(DmaChannel chn)
404:                      *
405:                      * PreCondition:    chn - valid DMA channel
406:                      *
407:                      * Input:           chn     - DMA channel number
408:                      *
409:                      * Output:          None
410:                      *
411:                      * Side Effects:    None
412:                      *
413:                      * Overview:        The function aborts a current undergoing DMA transfer for the selected DMA channel.
414:                      *
415:                      * Note:            None.
416:                      *
417:                      * Example:         DmaChnAbortTxfer(DMA_CHANNEL3);
418:                      ********************************************************************/
419:                      void           DmaChnAbortTxfer(DmaChannel chn);
420:                 
421:                     // High level channel event and interrupt control functions
422:                 
423:                     /*********************************************************************
424:                      * Function:        void DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
425:                      *
426:                      * PreCondition:    chn - valid DMA channel
427:                      *
428:                      * Input:           chn     - DMA channel number
429:                      *                  eFlags  - event flags with the following significance:
430:                      *                              - DMA_EV_ERR: address error event
431:                      *                              - DMA_EV_ABORT: transfer abort event
432:                      *                              - DMA_EV_CELL_DONE: cell transfer complete event
433:                      *                              - DMA_EV_BLOCK_DONE: block transfer complete event
434:                      *                              - DMA_EV_DST_HALF: destination half event
435:                      *                              - DMA_EV_DST_FULL: destination full event
436:                      *                              - DMA_EV_SRC_HALF: source half event
437:                      *                              - DMA_EV_SRC_FULL: source full event
438:                      *                              - DMA_EV_ALL_EVNTS: all of the above flags
439:                      *
440:                      * Output:          None
441:                      *
442:                      * Side Effects:    None
443:                      *
444:                      * Overview:        The function sets the event enable flags for the selected DMA channel.
445:                      *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
446:                      *                  enabled for the selected channel, the other channel event flags won't be touched.
447:                      *
448:                      * Note:            None.
449:                      *
450:                      * Example:         DmaChnSetEvEnableFlags(DMA_CHANNEL3, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
451:                      ********************************************************************/
452:                      void           DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
453:                 
454:                     /*********************************************************************
455:                      * Function:        void DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
456:                      *
457:                      * PreCondition:    chn - valid DMA channel
458:                      *
459:                      * Input:           chn     - DMA channel number
460:                      *                  eFlags  - event flags with the following significance:
461:                      *                              - DMA_EV_ERR: address error event
462:                      *                              - DMA_EV_ABORT: transfer abort event
463:                      *                              - DMA_EV_CELL_DONE: cell transfer complete event
464:                      *                              - DMA_EV_BLOCK_DONE: block transfer complete event
465:                      *                              - DMA_EV_DST_HALF: destination half event
466:                      *                              - DMA_EV_DST_FULL: destination full event
467:                      *                              - DMA_EV_SRC_HALF: source half event
468:                      *                              - DMA_EV_SRC_FULL: source full event
469:                      *                              - DMA_EV_ALL_EVNTS: all of the above flags
470:                      *
471:                      * Output:          None
472:                      *
473:                      * Side Effects:    None
474:                      *
475:                      * Overview:        The function clears the event enable flags for the selected DMA channel.
476:                      *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
477:                      *                  disabled for the selected channel, the other channel event flags won't be touched.
478:                      *
479:                      * Note:            None.
480:                      *
481:                      * Example:         DmaChnClrEvEnableFlags(DMA_CHANNEL3, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
482:                      ********************************************************************/
483:                      void           DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
484:                 
485:                     /*********************************************************************
486:                      * Function:        void DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
487:                      *
488:                      * PreCondition:    chn - valid DMA channel
489:                      *
490:                      * Input:           chn     - DMA channel number
491:                      *                  eFlags  - event flags with the following significance:
492:                      *                              - DMA_EV_ERR: address error event
493:                      *                              - DMA_EV_ABORT: transfer abort event
494:                      *                              - DMA_EV_CELL_DONE: cell transfer complete event
495:                      *                              - DMA_EV_BLOCK_DONE: block transfer complete event
496:                      *                              - DMA_EV_DST_HALF: destination half event
497:                      *                              - DMA_EV_DST_FULL: destination full event
498:                      *                              - DMA_EV_SRC_HALF: source half event
499:                      *                              - DMA_EV_SRC_FULL: source full event
500:                      *                              - DMA_EV_ALL_EVNTS: all of the above flags
501:                      *
502:                      * Output:          None
503:                      *
504:                      * Side Effects:    None
505:                      *
506:                      * Overview:        The function sets the event enable flags for the selected DMA channel.
507:                      *                  The channel event flags are forced to the eFlags value.
508:                      *
509:                      * Note:            None.
510:                      *
511:                      * Example:         DmaChnWriteEvEnableFlags(DMA_CHANNEL3, DMA_EV_ALL_EVNTS);
512:                      ********************************************************************/
513:                      void           DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
514:                 
515:                     /*********************************************************************
516:                      * Function:        DmaEvFlags DmaChnGetEvEnableFlags(DmaChannel chn)
517:                      *
518:                      * PreCondition:    chn - valid DMA channel
519:                      *
520:                      * Input:           chn     - DMA channel number
521:                      *
522:                      * Output:          - event flags with the following significance:
523:                      *                      - DMA_EV_ERR: address error event
524:                      *                      - DMA_EV_ABORT: transfer abort event
525:                      *                      - DMA_EV_CELL_DONE: cell transfer complete event
526:                      *                      - DMA_EV_BLOCK_DONE: block transfer complete event
527:                      *                      - DMA_EV_DST_HALF: destination half event
528:                      *                      - DMA_EV_DST_FULL: destination full event
529:                      *                      - DMA_EV_SRC_HALF: source half event
530:                      *                      - DMA_EV_SRC_FULL: source full event
531:                      *                      - DMA_EV_ALL_EVNTS: all of the above flags
532:                      *
533:                      * Side Effects:    None
534:                      *
535:                      * Overview:        The function returns the event enabled flags for the selected DMA channel.
536:                      *
537:                      * Note:            None.
538:                      *
539:                      * Example:         DmaEvFlags enabledFlags=DmaChnGetEvEnableFlags(DMA_CHANNEL3);
540:                      ********************************************************************/
541:                      DmaEvFlags DmaChnGetEvEnableFlags(DmaChannel chn);
542:                 
543:                     /*********************************************************************
544:                      * Function:        void DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags)
545:                      *
546:                      * PreCondition:    chn - valid DMA channel
547:                      *
548:                      * Input:           chn     - DMA channel number
549:                      *                  eFlags  - event flags with the following significance:
550:                      *                              - DMA_EV_ERR: address error event
551:                      *                              - DMA_EV_ABORT: transfer abort event
552:                      *                              - DMA_EV_CELL_DONE: cell transfer complete event
553:                      *                              - DMA_EV_BLOCK_DONE: block transfer complete event
554:                      *                              - DMA_EV_DST_HALF: destination half event
555:                      *                              - DMA_EV_DST_FULL: destination full event
556:                      *                              - DMA_EV_SRC_HALF: source half event
557:                      *                              - DMA_EV_SRC_FULL: source full event
558:                      *                              - DMA_EV_ALL_EVNTS: all of the above flags
559:                      *
560:                      * Output:          None
561:                      *
562:                      * Side Effects:    None
563:                      *
564:                      * Overview:        The function clears the event flags for the selected DMA channel.
565:                      *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
566:                      *                  cleared for the selected channel, the other channel event flags won't be touched.
567:                      *
568:                      * Note:            None.
569:                      *
570:                      * Example:         DmaChnClrEvFlags(DMA_CHANNEL3, DMA_EV_ALL_EVNTS);
571:                      ********************************************************************/
572:                      void           DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags);
573:                 
574:                     /*********************************************************************
575:                      * Function:        DmaEvFlags DmaChnGetEvFlags(DmaChannel chn)
576:                      *
577:                      * PreCondition:    chn - valid DMA channel
578:                      *
579:                      * Input:           chn     - DMA channel number
580:                      *
581:                      * Output:          event flags with the following significance:
582:                      *                      - DMA_EV_ERR: address error event
583:                      *                      - DMA_EV_ABORT: transfer abort event
584:                      *                      - DMA_EV_CELL_DONE: cell transfer complete event
585:                      *                      - DMA_EV_BLOCK_DONE: block transfer complete event
586:                      *                      - DMA_EV_DST_HALF: destination half event
587:                      *                      - DMA_EV_DST_FULL: destination full event
588:                      *                      - DMA_EV_SRC_HALF: source half event
589:                      *                      - DMA_EV_SRC_FULL: source full event
590:                      *                      - DMA_EV_ALL_EVNTS: all of the above flags
591:                      *
592:                      * Side Effects:    None
593:                      *
594:                      * Overview:        The function returns the event flags for the selected DMA channel.
595:                      *
596:                      * Note:            None.
597:                      *
598:                      * Example:         DmaEvFlags intSetFlags=DmaChnGetEvFlags(DMA_CHANNEL3);
599:                      ********************************************************************/
600:                      DmaEvFlags DmaChnGetEvFlags(DmaChannel chn);
601:                 
602:                 
603:                     // high level helpers for fast strcpy/memcpy transfers
604:                 
605:                     /*********************************************************************
606:                      * Function:        DmaTxferRes DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri)
607:                      *
608:                      * PreCondition:    chn     - a valid DMA channel
609:                      *                  s1, s2  - valid memory pointers
610:                      *                  n>0, n<=DmaGetMaxTxferSize()
611:                      *
612:                      * Input:           s1      - destination pointer
613:                      *                  s2      - source pointer
614:                      *                  n       - number of bytes to transfer
615:                      *                  chn     - the DMA channel to perform the transfer
616:                      *                  chPri   - the desired channel priority
617:                      *
618:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
619:                      *                  an DmaTxferRes error code  otherwise
620:                      *
621:                      * Side Effects:    None
622:                      *
623:                      * Overview:        The function configures a DMA channel for a fast memory transfer.
624:                      *          Then it copies one block of memory from source to destination.
625:                      *
626:                      *
627:                      * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
628:                      *                    This way, the transfer will occur correctly together with checksum calculation.
629:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
630:                      *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
631:                      *                  - The function clears the suspend state and resumes the operation of the DMA controller.
632:                      *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
633:                      *
634:                      * Example:     res=DmaChnMemcpy(pDst, pSrc, buffSz, DMA_CHANNEL0, DMA_CHN_PRI3);
635:                      ********************************************************************/
636:                      DmaTxferRes    DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri);
637:                 
638:                     /*********************************************************************
639:                      * Function:        DmaTxferRes DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri)
640:                      *
641:                      * PreCondition:    chn     - a valid DMA channel
642:                      *                  s1, s2  - valid memory pointers
643:                      *
644:                      * Input:           s1      - destination pointer
645:                      *                  s2      - source pointer
646:                      *                  chn     - the DMA channel to perform the transfer
647:                      *                  chPri   - the desired channel priority
648:                      *
649:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
650:                      *                  an DmaTxferRes error code  otherwise
651:                      *
652:                      * Side Effects:    None
653:                      *
654:                      * Overview:        The function configures a DMA channel for a fast memory transfer.
655:                      *          Then it copies one zero terminated string from source to destination.
656:                      *
657:                      *
658:                      * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
659:                      *                    This way, the transfer will occur correctly together with checksum calculation.
660:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
661:                      *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
662:                      *                  - The function clears the suspend state and resumes the operation of the DMA controller.
663:                      *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
664:                      *
665:                      *
666:                      * Example:     res=DmaChnStrcpy(str1, str2, DMA_CHANNEL1, DMA_CHN_PRI3);
667:                      *********************************************************************/
668:                      DmaTxferRes    DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri);
669:                 
670:                     /*********************************************************************
671:                      * Function:        DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri)
672:                      *
673:                      * PreCondition:    chn     - a valid DMA channel
674:                      *              - s1, s2    - valid memory pointers
675:                      *                              - 0 < n <= DmaGetMaxTxferSize()
676:                      *
677:                      * Input:           s1      - destination pointer
678:                      *                  s2      - source pointer
679:                      *                  n   - max number of bytes to transfer
680:                      *                  chn     - the DMA channel to perform the transfer
681:                      *                  chPri   - the desired channel priority
682:                      *
683:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
684:                      *                  an DmaTxferRes error code  otherwise
685:                      *
686:                      * Side Effects:    None
687:                      *
688:                      * Overview:        The function configures a DMA channel for a fast memory transfer.
689:                      *          Then it copies one zero terminated string from source to destination.
690:                      *          It copies no more than n characters from s2.
691:                      *
692:                      *
693:                      * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
694:                      *                    This way, the transfer will occur correctly together with checksum calculation.
695:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
696:                      *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
697:                      *                  - The function clears the suspend state and resumes the operation of the DMA controller.
698:                      *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
699:                      *
700:                      *
701:                      * Example:     res=DmaChnStrncpy(str1, str2, MAX_STR_LEN, DMA_CHANNEL1, DMA_CHN_PRI3);
702:                      ********************************************************************/
703:                      DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri);
704:                 
705:                     /*********************************************************************
706:                      * Function:        DmaTxferRes DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri)
707:                      *
708:                      * PreCondition:    chn    - a valid DMA channel
709:                      *                  d, s   - valid memory pointer
710:                      *                  n>0, n<=DmaGetMaxTxferSize()
711:                      *
712:                      * Input:           d     - address where to deposit the result
713:                      *                  s     - source buffer pointer
714:                      *                  n     - number of bytes in the pointer
715:                      *                  chn   - the DMA channel to use
716:                      *                  chPri - the desired channel priority
717:                      *
718:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
719:                      *                  an DmaTxferRes error code  otherwise
720:                      *
721:                      * Side Effects:    None
722:                      *
723:                      * Overview:        The function is a helper that calculates the CRC of a memory block.
724:                      *                  The function configures the DMA channel for a fast memory transfer and calculates the CRC.
725:                      *
726:                      *
727:                      * Note:            - The CRC generator must have been previously configured using DmaSfmCrcConfigure()
728:                      *                  - No transfer is done, just the CRC is calculated.
729:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
730:                      *                  - Append mode is enabled and the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
731:                      *                  - The checksum type is switched to CRC.
732:                      *                  - The way the data is fed into the checksum calculation block is affected by DmaSfmConfigure().
733:                      *
734:                      * Example:          int myCrc; DmaChnMemCrc(&myCrc, srcBuff, sizeof(srcBuff), DMA_CHANNEL2, DMA_CHN_PRI3);
735:                      ********************************************************************/
736:                      DmaTxferRes    DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri);
737:                 
738:                     /*********************************************************************
739:                      * Function:        DmaTxferRes DmaChnMemChecksum(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri)
740:                      *
741:                      * PreCondition:    chn    - a valid DMA channel
742:                      *                  d, s   - valid memory pointer
743:                      *                  n>0, n<=DmaGetMaxTxferSize()
744:                      *
745:                      * Input:           d     - address where to deposit the result
746:                      *                  s     - source buffer pointer
747:                      *                  n     - number of bytes in the pointer
748:                      *                  chn   - the DMA channel to use
749:                      *                  chPri - the desired channel priority
750:                      *
751:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
752:                      *                  an DmaTxferRes error code  otherwise
753:                      *
754:                      * Side Effects:    None
755:                      *
756:                      * Overview:        The function is a helper that calculates the IP checksum of a memory block.
757:                      *                  The function configures the DMA channel for a fast memory transfer and calculates the IP checksum.
758:                      *
759:                      *
760:                      * Note:            - The checksum generator must have been previously seeded using DmaSfmSetSeed()
761:                      *                  - No transfer is done, just the checksum is calculated.
762:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
763:                      *                  - Append mode is enabled and the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
764:                      *                  - The checksum type is switched to IP checksum.
765:                      *                  - The way the data is fed into the checksum calculation block is affected by DmaSfmConfigure().
766:                      *
767:                      * Example:          int myChecksum; DmaChnMemChecksum(&myChecksum, srcBuff, sizeof(srcBuff), DMA_CHANNEL1, DMA_CHN_PRI3);
768:                      ********************************************************************/
769:                      DmaTxferRes    DmaChnMemChecksum(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri);
770:                 
771:                     // High level Special Function Module (SFM) functions
772:                 
773:                     /*********************************************************************
774:                      * Function:        void DmaSfmConfigure(DmaChksumType cType, DmaBitOrder bitO, DmaReorderMode rMode)
775:                      *
776:                      * PreCondition:    cType, bitO, rMode - valid values
777:                      *
778:                      * Input:           cType - checksum type to be calculated: CRC or IP Checksum
779:                      *                  bitO  - the bit order to be used MSb or LSb first
780:                      *                  rMode - the reordering mode of the bytes when calculating the checksum
781:                      *
782:                      * Output:          None
783:                      *
784:                      * Side Effects:    Whenever the Transfer re-ordering is enabled the rMode setting will influence the destination data layout
785:                      *
786:                      * Overview:        The function configures the SFM module by setting the parameters that define the behavior:
787:                      *                      - the type of the checksum to be calculated (either CRC or IP checksum are supported)
788:                      *                      - the bit ordering (how a specific byte is used in the checksum calculation: MSb or LSb first)
789:                      *                      - the data re-ordering (how bytes are re-ordered before calculating the checksum).
790:                      *                      All these values affect the way the checksum is calculated.
791:                      *
792:                      * Note:            None
793:                      *
794:                      * Example:         DmaSfmConfigure(DMA_CHKSUM_CRC, DMA_BITO_LSb, DMA_REORDER_ENDIAN);
795:                      ********************************************************************/
796:                     extern __inline__ void __attribute__((always_inline)) DmaSfmConfigure(DmaChksumType cType, DmaBitOrder bitO, DmaReorderMode rMode)
797:                     {
798:                         DCRCCONCLR=_DCRCCON_CRCTYP_MASK|_DCRCCON_BITO_MASK|_DCRCCON_BYTO_MASK;
799:                         DCRCCONSET=(cType<<_DCRCCON_CRCTYP_POSITION)|(bitO<<_DCRCCON_BITO_POSITION)|(rMode<<_DCRCCON_BYTO_POSITION);
800:                     }
801:                 
802:                     /*********************************************************************
803:                      * Function:        void DmaSfmTxferReorder(int enable)
804:                      *
805:                      * PreCondition:    None
806:                      *
807:                      * Input:           enable - boolean to enable/disable the re-ordering of the data transfer
808:                      *
809:                      * Output:          None
810:                      *
811:                      * Side Effects:    None
812:                      *
813:                      * Overview:        The function configures the data transfer re-ordering of the SFM module.
814:                      *                  If the re-ordering is enabled, the data is read from the source, re-ordered accordingly and then written to the destination.
815:                      *                  Otherwise the data is written to the destination un-modified.
816:                      *                  The re-ordering is the one specified by the DmaReorderMode parameter in the DmaSfmConfigure() call.
817:                      *
818:                      *
819:                      * Note:            - The data transfer re-ordering should be used only for normal (background mode) data transfers.
820:                      *                  - In append mode the data transfer re-ordering should not be enabled (undefined behavior)!
821:                      *                  - Whenever the data re-ordering is enabled, the transfer should be aligned at both ends (source and destination).
822:                      *                    Un-aligned transfers are not supported (undefined behavior)!
823:                      *
824:                      * Example:         DmaSfmTxferReorder();
825:                      ********************************************************************/
826:                     extern __inline__ void __attribute__((always_inline)) DmaSfmTxferReorder(int enable)
827:                     {
828:                         DCRCCONCLR=_DCRCCON_WBO_MASK;
829:                         DCRCCONSET=(enable<<_DCRCCON_WBO_POSITION);
830:                     }
831:                 
832:                 
833:                      /*********************************************************************
834:                      * Function:        void DmaSfmCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
835:                      *
836:                      * PreCondition:    pLen   - valid polynomial length within 1-32
837:                      *
838:                      * Input:           polynomial  - the layout of the CRC generator
839:                      *                  pLen        - the length of the CRC generator polynomial
840:                      *                  seed        - the initial seed of the CRC generator
841:                      *
842:                      * Output:          None
843:                      *
844:                      * Side Effects:    None
845:                      *
846:                      * Overview:        The function configures the SFM CRC module by setting the parameters that define the generator polynomial:
847:                      *                  - the length of the CRC generator polynomial, pLen;
848:                      *                  - the function sets the layout of the shift stages that take place in the CRC generation.
849:                      *                    Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
850:                      *                    If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
851:                      *                    Note that in a proper CRC polynomial, both the most significant bit (MSb) and least significant bit(LSb)
852:                      *                    are always a '1'. Considering the generator polynomial: X^16+X^15+X^2+1, the value to be written as
853:                      *                    feedback should be 0x8005, or 0x8004, but not 0x018005;
854:                      *                  - the function sets the seed of the CRC generator. This is the initial data present in the
855:                      *                   CRC shift register before the CRC calculation begins. A good initial value is usually 0xffffffff.
856:                      *
857:                      * Note:            - Bit 0 of the generator polynomial is always XOR'ed.
858:                      *                  - When the append mode is set, the attached DMA channel has to have destination size <=4.
859:                      *                    Upon the transfer completion the calculated CRC is stored at the destination address.
860:                      *                  - When append mode is cleared, the DMA transfer occurs normally, and the CRC value is available using
861:                      *                    the CrcResult() function.
862:                      *                  - The CRC module should be configured before enabled.
863:                      *                  - These settings are relevant only when the SFM is configured for the CRC type of checksum.
864:                      *                  - The checksum register is the same for CRC or IP checksum mode. Therefore, this function changes also the seed for the IP checksum.
865:                      *                  - The way the data is fed into the checksum calculation block and the type of the checksum performed is affected by DmaSfmConfigure().
866:                      *
867:                      * Example:         DmaSfmCrcConfigure(0x04c11db7, 32, 0xffffffff);
868:                      ********************************************************************/
869:                     extern __inline__ void __attribute__((always_inline)) DmaSfmCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
870:                     {
871:                         DCRCCONCLR=_DCRCCON_PLEN_MASK;
872:                         DCRCCONSET=(pLen-1)<<_DCRCCON_PLEN_POSITION;
873:                         DCRCDATA=seed;
874:                         DCRCXOR=polynomial;
875:                     }
876:                 
877:                     #define DmaCrcConfigure DmaSfmCrcConfigure  // PIC32_3xx backward compatibility name
878:                 
879:                 
880:                     /*********************************************************************
881:                      * Function:        void DmaSfmAttachChannel(DmaChannel chn, int appendMode)
882:                      *
883:                      * PreCondition:    chn    - valid DMA channel
884:                      *
885:                      * Input:           chn         - the DMA channel to be attached to the checksum module.
886:                      *                  appendMode  - if TRUE the data passed to the checksum generator is not transferred to destination
887:                      *                                but it's written to the destination address when the block transfer is complete.
888:                      *                              - if FALSE the data is transferred normally while the checksum is calculated.
889:                      *                                The checksum will be available using the DmaSfmChecksum function.
890:                      *
891:                      * Output:          None
892:                      *
893:                      * Side Effects:    None
894:                      *
895:                      * Overview:        The function attaches the SFM checksum module to a DMA channel and enables the checksum generator.
896:                      *                  From now on, all the DMA traffic is directed to the SFM checksum generator. Once the DMA block transfer
897:                      *                  is complete, the checksum result is available in the checksum data register.
898:                      *                  If append mode is enabled, no data transfer takes place but the checksum result will be deposited at the DMA destination address.
899:                 
900:                      *
901:                      * Note:            If append mode is enabled the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
902:                      *
903:                      * Example:         DmaSfmAttachChannel(DMA_CHANNEL0, TRUE);
904:                      ********************************************************************/
905:                     void            DmaSfmAttachChannel(DmaChannel chn, int appendMode);
906:                     #define         CrcAttachChannel    DmaSfmAttachChannel     // PIC32_3xx backward compatibility name
907:                 
908:                     /*********************************************************************
909:                      * Function:        unsigned int DmaSfmChecksum(void)
910:                      *
911:                      * PreCondition:    None
912:                      *
913:                      * Input:           None
914:                      *
915:                      * Output:          the current value of the checksum generator.
916:                      *
917:                      * Side Effects:    None
918:                      *
919:                      * Overview:        The function returns the calculated checksum value.
920:                      *
921:                      * Note:            - The function returns the valid checksum result. The masking out the unused MSbits in the checksum register is done by the hardware.
922:                      *                  - The way the data is fed into the checksum calculation block and the type of the checksum performed is affected by DmaSfmConfigure().
923:                      *
924:                      * Example:         unsigned int myChk=DmaSfmChecksum();
925:                      ********************************************************************/
926:                     extern __inline__ int __attribute__((always_inline)) DmaSfmChecksum(void)
927:                     {
928:                         return DCRCDATA;
929:                     }
930:                     #define     CrcResult   DmaSfmChecksum      // PIC32_3xx backward compatibility name
931:                     #define     DmaCrcGetValue  DmaSfmChecksum      // PIC32_3xx backward compatibility name
932:                 
933:                 
934:                     /*********************************************************************
935:                      * Function:        void DmaSfmSetSeed(unsigned int seed)
936:                      *
937:                      * PreCondition:    None
938:                      *
939:                      * Input:           seed    - the initial seed of the checksum generator
940:                      *
941:                      * Output:          None
942:                      *
943:                      * Side Effects:    None
944:                      *
945:                      * Overview:        The function sets the seed of the checksum generator. This is the initial data present in the
946:                      *                  CRC shift register or the IP checksum calculator before the actual transfer/calculation begins.
947:                      *
948:                      * Note:            When the SFM is configured for IP checksum mode, only the least significant 16 bits are relevant.
949:                      *
950:                      * Example:         DmaSfmSetSeed(0xffffffff);
951:                      ********************************************************************/
952:                     extern __inline__ void __attribute__((always_inline)) DmaSfmSetSeed(unsigned int seed)
953:                     {
954:                         DCRCDATA=seed;
955:                     }
956:                     #define     DmaCrcSetSeed   DmaSfmSetSeed       // PIC32_3xx backward compatibility name
957:                 
958:                 
959:                 /*********************  end of high level functions ****************************************/
960:                 
961:                     // low level definitions for the API functions
962:                 
963:                 
964:                     typedef struct
965:                     {
966:                         union
967:                         {
968:                             struct
969:                             {
970:                                 unsigned int chn:   3;      // last active DMA channel
971:                                 unsigned int rdOp:  1;      // last DMA operation, read if 1, write if 0
972:                             };
973:                             unsigned int    w;                      // word access
974:                         }lastAccess;
975:                         void*   lastAddress;        // most recent DMA address
976:                     }DmaStatus;         // DMA controller status
977:                 
978:                     typedef enum
979:                     {
980:                         DMA_GFLG_SUSPEND =  _DMACON_SUSPEND_MASK,   // suspend DMA controller operation
981:                         DMA_GFLG_ON =       _DMACON_ON_MASK,        // DMA module enabled/desabled
982:                         //
983:                         DMA_GFLG_ALL_FLAGS= DMA_GFLG_SUSPEND|DMA_GFLG_ON        // all flags
984:                     }DmaGlblFlags;  // flags for controlling global DMA controller behavior. From processor header file.
985:                 
986:                 
987:                 
988:                 
989:                     typedef enum
990:                     {
991:                         DMA_EV_ABORT_IRQ_EN =       _DCH0ECON_AIRQEN_MASK,
992:                         DMA_EV_START_IRQ_EN =       _DCH0ECON_SIRQEN_MASK,
993:                         // use DMA_EV_START_IRQ() and DMA_EV_ABORT_IRQ() below for selecting
994:                         // the start and abort IRQ signals
995:                         DMA_EV_MATCH_EN =           _DCH0ECON_PATEN_MASK,
996:                 
997:                 
998:                         // compiler use only field
999:                         _DMA_EV_MAX_MASK =     _DCH0ECON_CHAIRQ_MASK,
1000:                    }DmaEvCtrlFlags;    // DMA channel event control fields accessibile as flags
1001:                    // also part of DmaEvCtrlFlags:
1002:                    #define DMA_EV_START_IRQ(irq)   (DMA_EV_START_IRQ_EN | ((irq)<<_DCH0ECON_CHSIRQ_POSITION))  // NOTE: irq has to be a symbol from the processor header file
1003:                    #define DMA_EV_ABORT_IRQ(irq)   (DMA_EV_ABORT_IRQ_EN | ((irq)<<_DCH0ECON_CHAIRQ_POSITION))  // NOTE: irq has to be a symbol from the processor header file
1004:                
1005:                    // DMA channel event control as a structure:
1006:                    #define DmaEvCtrl   __DCH0ECONbits_t
1007:                
1008:                
1009:                
1010:                
1011:                    typedef enum
1012:                    {
1013:                        DMA_CTL_AUTO_EN =       _DCH0CON_CHAEN_MASK,
1014:                        DMA_CTL_CHAIN_EN =      _DCH0CON_CHCHN_MASK,
1015:                        DMA_CTL_DET_EN =        _DCH0CON_CHAED_MASK,
1016:                        DMA_CTL_CHN_EN =        _DCH0CON_CHEN_MASK,
1017:                        DMA_CTL_CHAIN_DIR =     _DCH0CON_CHCHNS_MASK,
1018:                        // use the DMA_CTL_PRI() below for selecting the DMA
1019:                        // channel priority
1020:                    }DmaChnCtrlFlags;   // controlling the DMA channel with flags
1021:                    // also part of DmaChnCtrlFlags:
1022:                    #define DMA_CTL_PRI(pri)    ((pri)&_DCH0CON_CHPRI_MASK) // DMA Control channel priority
1023:                
1024:                    // DMA channel control as a structure:
1025:                    #define DmaChnCtrl      __DCH0CONbits_t
1026:                
1027:                    typedef struct
1028:                    {
1029:                        void*   vSrcAdd;        // source of the DMA transfer, virtual
1030:                        void*   vDstAdd;        // destination of the DMA transfer, virtual
1031:                        int srcSize;        // source buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
1032:                        int dstSize;        // destination buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
1033:                        int cellSize;       // no of bytes txferred per event, 1 to DmaGetMaxTxferSize().
1034:                    }DmaTxferCtrl;      // transfer setting: the transfer source, destination addresses and size, cell size
1035:                
1036:                
1037:                    /********************** low level DMA channel functions *******************************/
1038:                
1039:                
1040:                
1041:                    // Global DMA controller functions
1042:                
1043:                    /*********************************************************************
1044:                     * Function:        void DmaEnable(int enable)
1045:                     *
1046:                     * PreCondition:    None
1047:                     *
1048:                     * Input:           enable - boolean to enable/disable the DMA controller
1049:                     *
1050:                     * Output:          None
1051:                     *
1052:                     * Side Effects:    None
1053:                     *
1054:                     * Overview:       The function enables/disables the DMA controller.
1055:                     *
1056:                     * Note:           None.
1057:                     *
1058:                     * Example:        DmaEnable(1);
1059:                     ********************************************************************/
1060:                    extern __inline__ void __attribute__((always_inline)) DmaEnable(int enable)
1061:                    {
1062:                        if(enable)
1063:                        {
1064:                            DMACONSET=_DMACON_ON_MASK;
1065:                        }
1066:                        else
1067:                        {
1068:                            DMACONCLR=_DMACON_ON_MASK;
1069:                            while(DMACONbits.ON);       // wait to take effect
1070:                        }
1071:                    }
1072:                
1073:                    /*********************************************************************
1074:                     * Function:        void DmaReset(void)
1075:                     *
1076:                     * PreCondition:    None
1077:                     *
1078:                     * Input:       None
1079:                     *
1080:                     * Output:          None
1081:                     *
1082:                     * Side Effects:    None
1083:                     *
1084:                     * Overview:        The function resets the DMA controller.
1085:                     *
1086:                     * Note:            None.
1087:                     *
1088:                     * Example:        DmaReset();
1089:                     ********************************************************************/
1090:                    #define            DmaReset()   DmaEnable(0)
1091:                
1092:                
1093:                    /*********************************************************************
1094:                     * Function:        int DmaSuspend(void)
1095:                     *
1096:                     * PreCondition:    None
1097:                     *
1098:                     * Input:       None
1099:                     *
1100:                     * Output:          true if the DMA was previously suspended, false otherwise
1101:                     *
1102:                     *
1103:                     * Side Effects:    None
1104:                     *
1105:                     * Overview:        The function suspends the DMA controller.
1106:                     *
1107:                     * Note:            After the execution of this function the DMA operation is supposed to be suspended.
1108:                     *                  I.e. the function has to wait for the suspension to take place!
1109:                     *
1110:                     * Example:         int susp=DmaSuspend();
1111:                     ********************************************************************/
1112:                        extern __inline__ int __attribute__((always_inline)) DmaSuspend(void)
1113:                    {
1114:                        int suspSt;
1115:                        if(!(suspSt=DMACONbits.SUSPEND))
9D01EF84  3C03BF88   LUI V1, -16504
9D01F45C  3C03BF88   LUI V1, -16504
9D01F460  8C633000   LW V1, 12288(V1)
9D01F464  7C630300   EXT V1, V1, 12, 1
9D01F468  1460FEDB   BNE V1, ZERO, 0x9D01EFD8
9D01F46C  24041000   ADDIU A0, ZERO, 4096
1116:                        {
1117:                            DMACONSET=_DMACON_SUSPEND_MASK;     // suspend
9D01EF98  24041000   ADDIU A0, ZERO, 4096
9D01EFC0  AC643008   SW A0, 12296(V1)
9D01F470  0B407BF0   J .LBB64, .LBB66
9D01F474  3C03BF88   LUI V1, -16504
1118:                            while((DMACONbits.DMABUSY));    // wait to be actually suspended
9D01EFA4  3C05BF88   LUI A1, -16504
9D01EFC4  3C05BF88   LUI A1, -16504
9D01EFC8  8CA33000   LW V1, 12288(A1)
9D01EFCC  30630800   ANDI V1, V1, 2048
9D01EFD0  1460FFFD   BNE V1, ZERO, 0x9D01EFC8
9D01EFD4  00000000   NOP
1119:                        }
1120:                        return suspSt;
1121:                    }
1122:                
1123:                
1124:                
1125:                    /*********************************************************************
1126:                     * Function:        void DmaResume(int susp)
1127:                     *
1128:                     * PreCondition:    None
1129:                     *
1130:                     * Input:       the desired DMA suspended state.
1131:                     *
1132:                     * Output:          None
1133:                     *
1134:                     * Side Effects:    None
1135:                     *
1136:                     * Overview:        The function restores the DMA controller activity to the old suspended mode.
1137:                     *
1138:                     * Note:            None.
1139:                     *
1140:                     * Example:         int isSusp=DmaSuspend(); {....}; DmaResume(isSusp);
1141:                     ********************************************************************/
1142:                        extern __inline__ void __attribute__((always_inline)) DmaResume(int susp)
1143:                    {
1144:                        if(susp)
1145:                        {
1146:                            DmaSuspend();
1147:                        }
1148:                        else
1149:                        {
1150:                            DMACONCLR=_DMACON_SUSPEND_MASK;     // resume DMA activity
9D01F40C  24041000   ADDIU A0, ZERO, 4096
9D01F410  3C03BF88   LUI V1, -16504
9D01F414  AC643004   SW A0, 12292(V1)
9D01F418  0B407BF6   J 0x9D01EFD8
9D01F41C  00000000   NOP
1151:                        }
1152:                    }
1153:                
1154:                    /*********************************************************************
1155:                     * Function:        void DmaGetStatus(DmaStatus* pStat)
1156:                     *
1157:                     * PreCondition:    pStat   - valid pointer
1158:                     *
1159:                     * Input:           pStat   - pointer to a DmaStatus structure to store the current DMA controller
1160:                     *                          status, carrying the following info:
1161:                     *                              - chn:  the last active DMA channel
1162:                     *                              - rdOp: the last DMA operation, read/write
1163:                     *                              - lastAddress: the most recent DMA address
1164:                     *
1165:                     * Output:          None
1166:                     *
1167:                     * Side Effects:    None
1168:                     *
1169:                     * Overview:        The function updates the info for the current DMA controller status.
1170:                     *                  It updates the last DMA: operation, channel used and address.
1171:                     *
1172:                     * Note:            None.
1173:                     *
1174:                     * Example:         DmaStatus stat; DmaGetStatus(&stat);
1175:                     ********************************************************************/
1176:                     void           DmaGetStatus(DmaStatus* pStat);
1177:                
1178:                    /*********************************************************************
1179:                     * Function:        void DmaSetGlobalFlags(DmaGlblFlags gFlags)
1180:                     *
1181:                     * PreCondition:    None
1182:                     *
1183:                     * Input:           gFlags - flags to be set, having the following fields:
1184:                     *          - DMA_GFLG_SUSPEND: DMA controller operation suspend
1185:                     *          - DMA_GFLG_ON: DMA controller enabled/desabled
1186:                     *          - DMA_GFLG_ALL_FLAGS: all flags
1187:                     *
1188:                     * Output:          None
1189:                     *
1190:                     * Side Effects:    None
1191:                     *
1192:                     * Overview:        The function affects the global behavior of the DMA controller.
1193:                     *                  It sets the specified flags. Any flag that is set in the gFlags will be
1194:                     *                  enabled, the other flags won't be touched.
1195:                     *
1196:                     * Note:            None.
1197:                     *
1198:                     * Example:         DmaSetGlobalFlags(DMA_GFLG_ON);
1199:                     ********************************************************************/
1200:                        extern __inline__ void __attribute__((always_inline)) DmaSetGlobalFlags(DmaGlblFlags gFlags)
1201:                    {
1202:                        DMACONSET=gFlags;
1203:                    }
1204:                
1205:                    /*********************************************************************
1206:                     * Function:        void DmaClrGlobalFlags(DmaGlblFlags gFlags)
1207:                     *
1208:                     * PreCondition:    None
1209:                     *
1210:                     * Input:           gFlags - flags to be cleared, having the following fields:
1211:                     *                               - DMA_GFLG_SUSPEND: DMA controller operation suspend
1212:                     *                               - DMA_GFLG_ON: DMA controller enabled/desabled
1213:                     *                               - DMA_GFLG_ALL_FLAGS: all flags
1214:                     *
1215:                     * Output:          None
1216:                     *
1217:                     * Side Effects:    None
1218:                     *
1219:                     * Overview:        The function affects the global behavior of the DMA controller.
1220:                     *                  It clears the specified flags. Any flag that is set in the gFlags will be
1221:                     *                  cleared, the other flags won't be touched.
1222:                     *
1223:                     * Note:            None.
1224:                     *
1225:                     * Example:         DmaClrGlobalFlags(DMA_GFLG_SUSPEND);
1226:                     ********************************************************************/
1227:                        extern __inline__ void __attribute__((always_inline)) DmaClrGlobalFlags(DmaGlblFlags gFlags)
1228:                    {
1229:                        DMACONCLR=gFlags;
1230:                    }
1231:                
1232:                
1233:                    /*********************************************************************
1234:                     * Function:        void DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1235:                     *
1236:                     * PreCondition:    None
1237:                     *
1238:                     * Input:           gFlags - flags to be set, having the following fields:
1239:                     *                                 - DMA_GFLG_SUSPEND: DMA controller operation suspend
1240:                     *                                 - DMA_GFLG_ON: DMA controller enabled/desabled
1241:                     *                                 - DMA_GFLG_ALL_FLAGS: all flags
1242:                     *
1243:                     * Output:          None
1244:                     *
1245:                     * Side Effects:    None
1246:                     *
1247:                     * Overview:        The function affects the global behavior of the DMA controller.
1248:                     *                  It forces the flags to have the specified gFlags value.
1249:                     *
1250:                     * Note:            None.
1251:                     *
1252:                     * Example:         DmaWriteGlobalFlags(DMA_GFLG_ALL_FLAGS);
1253:                     ********************************************************************/
1254:                        extern __inline__ void __attribute__((always_inline)) DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1255:                    {
1256:                        DMACON=gFlags;
1257:                    }
1258:                
1259:                    /*********************************************************************
1260:                     * Function:        DmaGlblFlags DmaGetGlobalFlags(void)
1261:                     *
1262:                     * PreCondition:    None
1263:                     *
1264:                     * Input:           None
1265:                     *
1266:                     * Output:          The current DMA controller flags settings.
1267:                     *                              - DMA_GFLG_SUSPEND: DMA controller operation suspend
1268:                     *                              - DMA_GFLG_ON: DMA controller enabled/desabled
1269:                     *
1270:                     * Side Effects:    None
1271:                     *
1272:                     * Overview:        The function returns the global flags of the DMA controller.
1273:                     *
1274:                     * Note:            None.
1275:                     *
1276:                     * Example:         DmaGlblFlags dmaFlags=DmaGetGlobalFlags();
1277:                     ********************************************************************/
1278:                        extern __inline__ DmaGlblFlags __attribute__((always_inline)) DmaGetGlobalFlags(void)
1279:                    {
1280:                        return (DmaGlblFlags)DMACON;
1281:                    }
1282:                
1283:                
1284:                    /*********************************************************************
1285:                     * Function:        int DmaGetMaxTxferSize(void)
1286:                     *
1287:                     * PreCondition:    None
1288:                     *
1289:                     * Input:           None
1290:                     *
1291:                     * Output:          The maximum transfer capacity for a DMA channel, in bytes.
1292:                     *
1293:                     * Side Effects:    None
1294:                     *
1295:                     * Overview:        The function returns the maximum number of bytes that can be transferred by a DMA channel.
1296:                     *
1297:                     * Note:            Revision dependant.
1298:                     *
1299:                     * Example:         int dmaMaxSz=DmaGetMaxTxferSize();
1300:                     ********************************************************************/
1301:                    extern __inline__ int __attribute__((always_inline)) DmaGetMaxTxferSize(void)
1302:                    {
1303:                        return 65536;
1304:                    }
1305:                
1306:                    // Direct Channel control functions
1307:                
1308:                    typedef enum
1309:                    {
1310:                        DMA_CONFIG_DEFAULT = 0,                             // DMA default operation
1311:                        DMA_CONFIG_AUTO = _DCH0CON_CHAEN_MASK,              // DMA channel is auto enabled
1312:                        DMA_CONFIG_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK), // DMA channel is chained to lower channel
1313:                        DMA_CONFIG_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),       // DMA channel is chained to higher channel
1314:                        DMA_CONFIG_DET_EN = _DCH0CON_CHAED_MASK,            // events detection enabled while channel off
1315:                        DMA_CONFIG_ENABLE = _DCH0CON_CHEN_MASK,             // DMA channel is enabled after open
1316:                        DMA_CONFIG_MATCH    = 0x80000000,                   // DMA channel stops on match
1317:                    }DmaConfigFlags;    // flags for the channel configuration
1318:                
1319:                
1320:                
1321:                    /*********************************************************************
1322:                     * Function:        void DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags)
1323:                     *
1324:                     * PreCondition:    chPri  - valid channel priority, 0-3
1325:                     *
1326:                     * Input:           chn    - channel to be configured in the DMA controller
1327:                     *                  chPri  - the priority given to the channel, 0-3
1328:                     *                  cFlags - orred flags specifying the configuration:
1329:                     *                           DMA_CONFIG_DEFAULT: DMA default operation mode
1330:                     *                           DMA_CONFIG_AUTO:   DMA channel is auto enabled
1331:                     *                           DMA_CONFIG_CHAIN_LOW: DMA channel is chained to lower channel
1332:                     *                           DMA_CONFIG_CHAIN_HI: DMA channel is chained to higher channel
1333:                     *                           DMA_CONFIG_DET_EN: events detection enabled while channel off
1334:                     *                           DMA_CONFIG_ENABLE: DMA channel is enabled when opened
1335:                     *                           DMA_CONFIG_MATCH:  DMA channel stops on match
1336:                     *
1337:                     *
1338:                     *
1339:                     * Output:          None
1340:                     *
1341:                     * Side Effects:    None
1342:                     *
1343:                     * Overview:        The function configures the selected DMA channel using the supplied user flags and priority.
1344:                     *
1345:                     * Note:            - The channel is NOT turned off. It should be turned off before calling this function.
1346:                     *                  The channel is just configured.
1347:                     *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
1348:                     *                  if DMA_CONFIG_ENABLE flag was not specified.
1349:                     *                  - The function does not touch the interrupt flags, interrupt enables, etc.
1350:                     *                  The interrupt flags should have been previously cleared and interrupts disabled before calling this function.
1351:                     *                  - The start and abort Irqs, the channel event enable flags are not touched/cleared by this function.
1352:                     *                  User has to call event channel functions to clear/enable the event flags if needed.
1353:                     *
1354:                     * Example:         DmaChnDisable(DMA_CHANNEL2); DmaChnConfigure(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_CONFIG_AUTO|DMA_CONFIG_MATCH|DMA_CONFIG_ENABLE);
1355:                     ********************************************************************/
1356:                    void            DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags);
1357:                
1358:                
1359:                    /*********************************************************************
1360:                     * Function:        int DmaChnGetSrcPnt(DmaChannel chn)
1361:                     *
1362:                     * PreCondition:    chn - valid DMA channel
1363:                     *
1364:                     * Input:           chn     - DMA channel number
1365:                     *
1366:                     * Output:          Current channel source pointer.
1367:                     *
1368:                     * Side Effects:    None
1369:                     *
1370:                     * Overview:        The function retrieves the current source pointer for the selected DMA channel.
1371:                     *                  It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the source transfer buffer.
1372:                     *
1373:                     * Note:            None
1374:                     *
1375:                     * Example:         int srcPnt=DmaChnGetSrcPnt(DMA_CHANNEL3);
1376:                     ********************************************************************/
1377:                     int            DmaChnGetSrcPnt(DmaChannel chn);
1378:                
1379:                    /*********************************************************************
1380:                     * Function:        int DmaChnGetDstPnt(DmaChannel chn)
1381:                     *
1382:                     * PreCondition:    chn - valid DMA channel
1383:                     *
1384:                     * Input:           chn     - DMA channel number
1385:                     *
1386:                     * Output:          Current channel destination pointer.
1387:                     *
1388:                     * Side Effects:    None
1389:                     *
1390:                     * Overview:        The function retrieves the current destination pointer for the selected DMA channel.
1391:                     *                  It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the destination transfer buffer.
1392:                     *
1393:                     * Note:            None
1394:                     *
1395:                     * Example:         int dstPnt=DmaChnGetDstPnt(DMA_CHANNEL3);
1396:                     ********************************************************************/
1397:                     int            DmaChnGetDstPnt(DmaChannel chn);
1398:                
1399:                    /*********************************************************************
1400:                     * Function:        int DmaChnGetCellPnt(DmaChannel chn)
1401:                     *
1402:                     * PreCondition:    chn - valid DMA channel
1403:                     *
1404:                     * Input:           chn     - DMA channel number
1405:                     *
1406:                     * Output:          Current channel transfer pointer.
1407:                     *
1408:                     * Side Effects:    None
1409:                     *
1410:                     * Overview:        The function retrieves the current transfer progress pointer for the selected DMA channel.
1411:                     *                  It ranges 0 to DmaGetMaxTxferSize()-1.
1412:                     *
1413:                     * Note:            None
1414:                     *
1415:                     * Example:         int cellPnt=DmaChnGetCellPnt(DMA_CHANNEL3);
1416:                     ********************************************************************/
1417:                     int            DmaChnGetCellPnt(DmaChannel chn);
1418:                
1419:                
1420:                
1421:                    /*********************************************************************
1422:                     * Function:        void DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1423:                     *
1424:                     * PreCondition:    chn - valid DMA channel
1425:                     *
1426:                     * Input:           chn         - DMA channel number
1427:                     *                  dmaEvCtrl   -   either a DmaEvCtrl structure field, carrying the following info:
1428:                     *                                      - AIRQEN: enable/disable the abort IRQ action
1429:                     *                                      - SIRQEN: enable/disable the start IRQ action
1430:                     *                                      - PATEN: enable/disable the pattern match and abort
1431:                     *                                  or any of the DmaEvCtrlFlags:
1432:                     *                                      DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1433:                     *
1434:                     *
1435:                     * Output:          None
1436:                     *
1437:                     * Side Effects:    None
1438:                     *
1439:                     * Overview:        The function sets the events that start and abort the transfer
1440:                     *                  for the selected DMA channel.
1441:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1442:                     *                  enabled for the selected channel, the other channel event flags won't be touched.
1443:                     *
1444:                     * Note:            None.
1445:                     *
1446:                     * Example:         either:
1447:                     *                      DmaChnSetEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN;
1448:                     *                  or:
1449:                     *                      DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.SIRQEN=1;
1450:                     *                      DmaChnSetEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1451:                     *
1452:                     ********************************************************************/
1453:                     void           DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1454:                
1455:                
1456:                    /*********************************************************************
1457:                     * Function:        void DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1458:                     *
1459:                     * PreCondition:    chn - valid DMA channel
1460:                     *
1461:                     * Input:           chn         - DMA channel number
1462:                     *                  dmaEvCtrl   -   either a DmaEvCtrl structure field, carrying the following info:
1463:                     *                                      - AIRQEN: enable/disable the abort IRQ action
1464:                     *                                      - SIRQEN: enable/disable the start IRQ action
1465:                     *                                      - PATEN: enable/disable the pattern match and abort
1466:                     *                                  or any of the DmaEvCtrlFlags:
1467:                     *                                      DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1468:                     *
1469:                     *
1470:                     * Output:          None
1471:                     *
1472:                     * Side Effects:    None
1473:                     *
1474:                     * Overview:        The function clears the events that start and abort the transfer
1475:                     *                  for the selected DMA channel.
1476:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1477:                     *                  disabled for the selected channel, the other channel event flags won't be touched.
1478:                     *
1479:                     * Note:            None.
1480:                     *
1481:                     * Example:         either:
1482:                     *                      DmaChnClrEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN);
1483:                     *                  or:
1484:                     *                      DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.AIRQEN=1;
1485:                     *                      DmaChnClrEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1486:                     *
1487:                     ********************************************************************/
1488:                     void           DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1489:                
1490:                
1491:                
1492:                    /*********************************************************************
1493:                     * Function:        void DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1494:                     *
1495:                     * PreCondition:    chn - valid DMA channel
1496:                     *
1497:                     * Input:           chn         - DMA channel number
1498:                     *                  dmaEvCtrl   -   either a DmaEvCtrl structure field, carrying the following info:
1499:                     *                                      - AIRQEN: enable/disable the abort IRQ action
1500:                     *                                      - SIRQEN: enable/disable the start IRQ action
1501:                     *                                      - PATEN: enable/disable the pattern match and abort
1502:                     *                                      - CHSIRQ: IRQ number to start the DMA channel transfer
1503:                     *                                      - CHAIRQ: IRQ number to abort the DMA channel transfer
1504:                     *                                  or any of the DmaEvCtrlFlags:
1505:                     *                                      DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1506:                     *
1507:                     *
1508:                     * Output:          None
1509:                     *
1510:                     * Side Effects:    None
1511:                     *
1512:                     * Overview:        The function writes the events that start and abort the transfer
1513:                     *                  for the selected DMA channel.
1514:                     *
1515:                     * Note:            None.
1516:                     *
1517:                     * Example:         either:
1518:                     *                      DmaChnWriteEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1519:                     *                  or:
1520:                     *                      DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1521:                     *                      DmaChnWriteEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1522:                     *
1523:                     ********************************************************************/
1524:                     void           DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1525:                
1526:                
1527:                
1528:                    /*********************************************************************
1529:                     * Function:        void DmaChnSetEventControl(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1530:                     *
1531:                     * PreCondition:    chn - valid DMA channel
1532:                     *
1533:                     * Input:           chn         - DMA channel number
1534:                     *                  dmaEvCtrl   -   either a DmaEvCtrl structure field, carrying the following info:
1535:                     *                                      - AIRQEN: enable/disable the abort IRQ action
1536:                     *                                      - SIRQEN: enable/disable the start IRQ action
1537:                     *                                      - PATEN: enable/disable the pattern match and abort
1538:                     *                                      - CHSIRQ: IRQ number to start the DMA channel transfer
1539:                     *                                      - CHAIRQ: IRQ number to abort the DMA channel transfer
1540:                     *                                  or any of the DmaEvCtrlFlags:
1541:                     *                                      DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1542:                     *
1543:                     *
1544:                     * Output:          None
1545:                     *
1546:                     * Side Effects:    None
1547:                     *
1548:                     * Overview:        The function sets the events that start and abort the transfer
1549:                     *                  for the selected DMA channel.
1550:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1551:                     *                  enabled for the selected channel, the other channel event flags won't be touched.
1552:                     *
1553:                     * Note:           A shorter name for DmaChnWriteEventControlFlags();
1554:                     *
1555:                     * Example:         either:
1556:                     *                      DmaChnSetEventControl(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1557:                     *                  or:
1558:                     *                      DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1559:                     *                      DmaChnSetEventControl(DMA_CHANNEL3, evCtrl.w);
1560:                     *
1561:                     ********************************************************************/
1562:                    #define         DmaChnSetEventControl(chn, dmaEvCtrl)   DmaChnWriteEventControlFlags(chn, dmaEvCtrl)
1563:                
1564:                
1565:                    /*********************************************************************
1566:                     * Function:        DmaEvCtrlFlags DmaChnGetEventControl(DmaChannel chn)
1567:                     *
1568:                     * PreCondition:    chn - valid DMA channel
1569:                     *
1570:                     * Input:           chn     - DMA channel number
1571:                     *
1572:                     * Output:          -   either a DmaEvCtrl structure field, carrying the following info:
1573:                     *                          - AIRQEN: enable/disable the abort IRQ action
1574:                     *                          - SIRQEN: enable/disable the start IRQ action
1575:                     *                          - PATEN: enable/disable the pattern match and abort
1576:                     *                          - CHSIRQ: IRQ number to start the DMA channel transfer
1577:                     *                          - CHAIRQ: IRQ number to abort the DMA channel transfer
1578:                     *                      or any of the DmaEvCtrlFlags:
1579:                     *                          DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1580:                     *
1581:                     *
1582:                     * Side Effects:    None
1583:                     *
1584:                     * Overview:        The function retrieves the events that start and abort the transfer
1585:                     *                  for the selected DMA channel.
1586:                     *
1587:                     * Note:            None.
1588:                     *
1589:                     * Example:         either:
1590:                     *                      DmaEvCtrlFlags evCtrlW=DmaChnGetEventControl(DMA_CHANNEL3); if(evCtrlW&DMA_EV_MATCH_EN) {...}
1591:                     *                  or:
1592:                     *                      DmaEvCtrl evCtrl; evCtrl.w=DmaChnGetEventControl(DMA_CHANNEL3); if(evCtrl.PATEN){...}
1593:                     *
1594:                     ********************************************************************/
1595:                     DmaEvCtrlFlags DmaChnGetEventControl(DmaChannel chn);
1596:                
1597:                
1598:                    /*********************************************************************
1599:                     * Function:        void DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1600:                     *
1601:                     * PreCondition:    chn - valid DMA channel
1602:                     *
1603:                     * Input:           chn         - DMA channel number
1604:                     *                  dmaChnCtrl  -   either a DmaChnCtrl structure field, carrying the following info:
1605:                     *                                      - autoEn: enable/disable the automatic mode
1606:                     *                                      - chainEn: enable/disable channel chaining
1607:                     *                                      - detectEn: enable/disable events detection when channel disabled
1608:                     *                                      - chEn: enable/disable channel functionality
1609:                     *                                      - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1610:                     *                                  or any of the DmaChnCtrlFlags flags:
1611:                     *                                      DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1612:                     *
1613:                     * Output:          None
1614:                     *
1615:                     * Side Effects:    None
1616:                     *
1617:                     * Overview:        The function sets the selected DMA channel control flags:
1618:                     *                  the chaining or auto mode, and events detection.
1619:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1620:                     *                  set for the selected channel, the other channel control flags won't be touched.
1621:                     *
1622:                     * Note:            None.
1623:                     *
1624:                     * Example:         either:
1625:                     *                      DmaChnSetControlFlags(DMA_CHANNEL3, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1626:                     *                  or:
1627:                     *                      DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1628:                     *                      DmaChnSetControlFlags(DMA_CHANNEL3, chCtrl.w);
1629:                     *
1630:                     ********************************************************************/
1631:                     void           DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1632:                
1633:                    /*********************************************************************
1634:                     * Function:        void DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1635:                     *
1636:                     * PreCondition:    chn - valid DMA channel
1637:                     *
1638:                     * Input:           chn         - DMA channel number
1639:                     *                  dmaChnCtrl  -   either a DmaChnCtrl structure field, carrying the following info:
1640:                     *                                      - autoEn: enable/disable the automatic mode
1641:                     *                                      - chainEn: enable/disable channel chaining
1642:                     *                                      - detectEn: enable/disable events detection when channel disabled
1643:                     *                                      - chEn: enable/disable channel functionality
1644:                     *                                      - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1645:                     *                                  or any of the DmaChnCtrlFlags flags:
1646:                     *                                      DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1647:                     *
1648:                     * Output:          None
1649:                     *
1650:                     * Side Effects:    None
1651:                     *
1652:                     * Overview:        The function clears the selected DMA channel control flags:
1653:                     *                  the chaining or auto mode and events detection.
1654:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1655:                     *                  cleared for the selected channel, the other channel control flags won't be touched.
1656:                     *
1657:                     * Note:            None.
1658:                     *
1659:                     * Example:         either:
1660:                     *                      DmaChnClrControlFlags(DMA_CHANNEL3, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1661:                     *                  or:
1662:                     *                      DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1663:                     *                      DmaChnClrControlFlags(DMA_CHANNEL3, chCtrl.w);
1664:                     *
1665:                     ********************************************************************/
1666:                     void           DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1667:                
1668:                    /*********************************************************************
1669:                     * Function:        void DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1670:                     *
1671:                     * PreCondition:    chn - valid DMA channel
1672:                     *
1673:                     * Input:           chn         - DMA channel number
1674:                     *                  dmaChnCtrl  -   either a DmaChnCtrl structure field, carrying the following info:
1675:                     *                                      - chPri: channel priority 0-3
1676:                     *                                      - autoEn: enable/disable the automatic mode
1677:                     *                                      - chainEn: enable/disable channel chaining
1678:                     *                                      - detectEn: enable/disable events detection when channel disabled
1679:                     *                                      - chEn: enable/disable channel functionality
1680:                     *                                      - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1681:                     *                                  or any of the DmaChnCtrlFlags flags:
1682:                     *                                      DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1683:                     *
1684:                     * Output:          None
1685:                     *
1686:                     * Side Effects:    None
1687:                     *
1688:                     * Overview:        The function enables/disables the selected DMA channel and also sets
1689:                     *                  the channel priority, chaining mode or auto and events detection.
1690:                     *
1691:                     * Note:            None.
1692:                     *
1693:                     * Example:         either:
1694:                     *                      DmaChnWriteControlFlags(DMA_CHANNEL3, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1695:                     *                  or:
1696:                     *                      DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1697:                     *                      DmaChnWriteControlFlags(DMA_CHANNEL3, chCtrl.w);
1698:                     *
1699:                     ********************************************************************/
1700:                     void           DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1701:                
1702:                    /*********************************************************************
1703:                     * Function:        void DmaChnSetControl(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1704:                     *
1705:                     * PreCondition:    chn - valid DMA channel
1706:                     *
1707:                     * Input:       chn     - DMA channel number
1708:                     *                  dmaChnCtrl  -   either a DmaChnCtrl structure field, carrying the following info:
1709:                     *                      - chPri: channel priority 0-3
1710:                     *                      - autoEn: enable/disable the automatic mode
1711:                     *                      - chainEn: enable/disable channel chaining
1712:                     *                      - detectEn: enable/disable events detection when channel disabled
1713:                     *                      - chEn: enable/disable channel functionality
1714:                     *                      - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1715:                     *                  or any of the DmaChnCtrlFlags flags:
1716:                     *                      DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1717:                     *
1718:                     * Output:          None
1719:                     *
1720:                     * Side Effects:    None
1721:                     *
1722:                     * Overview:        The function enables/disables the selected DMA channel and also sets
1723:                     *                  the channel priority, chaining mode or auto and events detection.
1724:                     *
1725:                     * Note:            Another name ( backward compatible) for DmaChnWriteControlFlags().
1726:                     *
1727:                     * Example:         either:
1728:                     *                      DmaChnSetControl(DMA_CHANNEL3, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1729:                     *                  or:
1730:                     *                      DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1731:                     *          DmaChnSetControl(DMA_CHANNEL3, chCtrl.w);
1732:                     *
1733:                     ********************************************************************/
1734:                    #define     DmaChnSetControl(chn, dmaChnCtrl)   DmaChnWriteControlFlags(chn, dmaChnCtrl)
1735:                
1736:                    /*********************************************************************
1737:                     * Function:        DmaChnCtrlFlags DmaChnGetControlFlags(DmaChannel chn)
1738:                     *
1739:                     * PreCondition:    chn - valid DMA channel
1740:                     *
1741:                     * Input:           chn         - DMA channel number
1742:                     *
1743:                     * Output:          - either a DmaChnCtrl structure field, carrying the following info:
1744:                     *                          - chPri: channel priority 0-3
1745:                     *                          - autoEn: enable/disable the automatic mode
1746:                     *                          - chainEn: enable/disable channel chaining
1747:                     *                          - detectEn: enable/disable events detection when channel disabled
1748:                     *                          - chEn: enable/disable channel functionality
1749:                     *                          - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1750:                     *                      or any of the DmaChnCtrlFlags flags:
1751:                     *                          DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1752:                     *
1753:                     * Side Effects:    None
1754:                     *
1755:                     * Overview:        The function retrieves the current control settings for the selected DMA channel,
1756:                     *                  including the channel enable/disable status, the channel priority,
1757:                     *                  chaining mode, auto mode and events detection.
1758:                     *
1759:                     * Note:            None.
1760:                     *
1761:                     * Example:         either:
1762:                     *                      DmaChnCtrlFlags ctrl=DmaChnGetControlFlags(DMA_CHANNEL3); if(ctrl&DMA_CTL_AUTO_EN) {...}
1763:                     *                  or:
1764:                     *                      DmaChnCtrl chnCtrl; chnCtrl.w=DmaChnGetControlFlags(DMA_CHANNEL3); if(chnCtrl.autoEn) {...}
1765:                     *
1766:                     ********************************************************************/
1767:                     DmaChnCtrlFlags    DmaChnGetControlFlags(DmaChannel chn);
1768:                
1769:                
1770:                    /*********************************************************************
1771:                     * Function:        int DmaChnGetEvDetect(DmaChannel chn)
1772:                     *
1773:                     * PreCondition:    chn - valid DMA channel
1774:                     *
1775:                     * Input:           chn     - DMA channel number
1776:                     *
1777:                     * Output:          TRUE if an DMA event was detected, FALSE otherwise.
1778:                     *
1779:                     * Side Effects:    None
1780:                     *
1781:                     * Overview:        The function returns the current event detection for the selected DMA channel.
1782:                     *
1783:                     * Note:            None.
1784:                     *
1785:                     * Example:         int evDetect=DmaChnGetEvDetect(DMA_CHANNEL3);
1786:                     *
1787:                     ********************************************************************/
1788:                     int            DmaChnGetEvDetect(DmaChannel chn);
1789:                
1790:                    /*********************************************************************
1791:                     * Function:        void DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0)
1792:                     *
1793:                     * PreCondition:    chn     - valid DMA channel
1794:                     *                  pTxCtrl - valid pointer
1795:                     *
1796:                     * Input:           chn         - DMA channel number
1797:                     *                  pTxCtrl     - pointer to a DmaTxferCtrl that will carry the following info:
1798:                     *                              - vSrcAdd: source of the DMA transfer
1799:                     *                              - vDstAdd: destination of the DMA transfer
1800:                     *                              - srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
1801:                     *                              - dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
1802:                     *                              - cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
1803:                     *                  mapToK0     - if TRUE, a Kernel address is mapped to KSeg0, else KSeg1.
1804:                     *
1805:                     * Output:          None
1806:                     *
1807:                     * Side Effects:    None
1808:                     *
1809:                     * Overview:        The function retrieves the transfer characteristics for a DMA channel transfer:
1810:                     *                  the source and the destination addresses.
1811:                     *                  It also retrieves the source and destination lengths
1812:                     *                  and the number of bytes transferred per event.
1813:                     *
1814:                     * Note:            None
1815:                     *
1816:                     * Example:         DmaTxferCtrl txCtl; DmaChnGetTxfer(DMA_CHANNEL3, &txCtl, FALSE);
1817:                     ********************************************************************/
1818:                     void           DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0);
1819:                
1820:                    // Low level checksum functions
1821:                
1822:                    /*********************************************************************
1823:                     * Function:        void DmaSfmEnable(int enable)
1824:                     *
1825:                     * PreCondition:    None
1826:                     *
1827:                     * Input:           enable _ boolean to enable/disable the SFM functionality
1828:                     *
1829:                     * Output:          None
1830:                     *
1831:                     * Side Effects:    None
1832:                     *
1833:                     * Overview:        The function enables/diables the checksum module functionality.
1834:                     *                  When enabled the attached DMA channel transfers are routed to the SFM module.
1835:                     *
1836:                     * Note:            The SFM module should be properly configured before enabled.
1837:                     *
1838:                     * Example:         DmaSfmEnable(1);
1839:                     ********************************************************************/
1840:                    extern __inline__ void __attribute__((always_inline)) DmaSfmEnable(int enable)
1841:                    {
1842:                        if(enable)
1843:                        {
1844:                            DCRCCONSET=_DCRCCON_CRCEN_MASK;
1845:                        }
1846:                        else
1847:                        {
1848:                            DCRCCONCLR=_DCRCCON_CRCEN_MASK;
1849:                        }
1850:                    }
1851:                    #define DmaCrcEnable    DmaSfmEnable        // PIC32_3xx backward compatibility
1852:                
1853:                
1854:                    /*********************************************************************
1855:                     * Function:        int DmaSfmGetEnable(void)
1856:                     *
1857:                     * PreCondition:    None
1858:                     *
1859:                     * Input:           None
1860:                     *
1861:                     * Output:          TRUE, if the SFM module is enabled
1862:                     *          FALSE otherwise
1863:                     *
1864:                     * Side Effects:    None
1865:                     *
1866:                     * Overview:        The function returns the SFM module enabling status.
1867:                     *
1868:                     * Note:            None
1869:                     *
1870:                     * Example:     int isSfmEnabled=DmaSfmGetEnable();
1871:                     ********************************************************************/
1872:                    extern __inline__ int __attribute__((always_inline)) DmaSfmGetEnable(void)
1873:                    {
1874:                        return DCRCCONbits.CRCEN!=0;
1875:                    }
1876:                    #define     DmaCrcGetEnable     DmaSfmGetEnable     // PIC32_3xx backward compatibility
1877:                
1878:                
1879:                    /*********************************************************************
1880:                     * Function:        void DmaSfmAppendEnable(int enable)
1881:                     *
1882:                     * PreCondition:    None
1883:                     *
1884:                     * Input:           enable _ boolean to enable/disable the SFM append mode
1885:                     *
1886:                     * Output:          None
1887:                     *
1888:                     * Side Effects:    None
1889:                     *
1890:                     * Overview:        The function enables the SFM append mode. In this mode, the attached DMA channel reads
1891:                     *                  the source data but does not write it to the destination address. The data it's just passed
1892:                     *                  to the checksum generator for CRC/IP checksum calculation.
1893:                     *                  When the block transfer is completed, the checksum result is written to the
1894:                     *                  DMA channel destination address.
1895:                     *
1896:                     * Note:            The SFM module should be properly configured before enabled.
1897:                     *
1898:                     * Example:         DmaSfmAppendModeEnable(TRUE);
1899:                     ********************************************************************/
1900:                    extern __inline__ void __attribute__((always_inline)) DmaSfmAppendEnable(int enable)
1901:                    {
1902:                        if(enable)
1903:                        {
1904:                            DCRCCONSET=_DCRCCON_CRCAPP_MASK;
1905:                        }
1906:                        else
1907:                        {
1908:                            DCRCCONCLR=_DCRCCON_CRCAPP_MASK;
1909:                        }
1910:                    }
1911:                    #define     DmaCrcAppendModeEnable  DmaSfmAppendEnable  // PIC32_3xx backward compatibility
1912:                
1913:                
1914:                    /*********************************************************************
1915:                     * Function:        int DmaSfmGetAppendMode(void)
1916:                     *
1917:                     * PreCondition:    None
1918:                     *
1919:                     * Input:           None
1920:                     *
1921:                     * Output:          TRUE, if the SFM append mode is enabled
1922:                     *                  FALSE otherwise
1923:                     *
1924:                     * Side Effects:    None
1925:                     *
1926:                     * Overview:        The function returns the SFM module enabling status.
1927:                     *
1928:                     * Note:            None
1929:                     *
1930:                     * Example:         int isAppendEnabled=DmaSfmGetAppendMode();
1931:                     ********************************************************************/
1932:                    extern __inline__ int __attribute__((always_inline)) DmaSfmGetAppendMode(void)
1933:                    {
1934:                        return DCRCCONbits.CRCAPP!=0;
1935:                    }
1936:                    #define DmaCrcGetAppendMode DmaSfmGetAppendMode     // PIC32_3xx backward compatibility
1937:                
1938:                
1939:                    /*********************************************************************
1940:                     * Function:        void DmaSfmSetAttach(DmaChannel chn)
1941:                     *
1942:                     * PreCondition:    chn     - valid DMA channel
1943:                     *
1944:                     * Input:           chn - the DMA channel to be attached to the SFM module (the DMA channel transfers will be routed to the SFM module)
1945:                     *
1946:                     * Output:          None
1947:                     *
1948:                     * Side Effects:    None
1949:                     *
1950:                     * Overview:        The function directly attaches a DMA channel to the SFM module.
1951:                     *
1952:                     * Note:            None
1953:                     *
1954:                     * Example:         DmaSfmSetAttach(DMA_CHANNEL3);
1955:                     ********************************************************************/
1956:                    extern __inline__ void __attribute__((always_inline)) DmaSfmSetAttach(DmaChannel chn)
1957:                    {
1958:                        DCRCCONCLR=_DCRCCON_CRCCH_MASK;
1959:                        DCRCCONSET=chn;
1960:                    }
1961:                    #define     DmaCrcSetAttach     DmaSfmSetAttach     // PIC32_3xx backward compatibility
1962:                
1963:                
1964:                    /*********************************************************************
1965:                     * Function:        DmaChannel DmaSfmGetAttach(void)
1966:                     *
1967:                     * PreCondition:    None
1968:                     *
1969:                     * Input:           None
1970:                     *
1971:                     * Output:          the DMA channel that is currently attached to the CRC module
1972:                     *
1973:                     * Side Effects:    None
1974:                     *
1975:                     * Overview:        The function returns the DMA channel number that is currently attached to the SFM module.
1976:                     *
1977:                     * Note:            None
1978:                     *
1979:                     * Example:         DmaChannel chn=DmaSfmGetAttach();
1980:                     ********************************************************************/
1981:                    extern __inline__ DmaChannel __attribute__((always_inline)) DmaSfmGetAttach(void)
1982:                    {
1983:                        return (DmaChannel)DCRCCONbits.CRCCH;
1984:                    }
1985:                    #define     DmaCrcGetAttach     DmaSfmGetAttach     // PIC32_3xx backward compatibility
1986:                
1987:                    /*********************************************************************
1988:                     * Function:        void DmaCrcSetPLen(int pLen)
1989:                     *
1990:                     * PreCondition:    pLen - valid polynomial length within 1-32
1991:                     *
1992:                     * Input:           pLen    - the length of the CRC generator polynomial
1993:                     *
1994:                     * Output:          None
1995:                     *
1996:                     * Side Effects:    None
1997:                     *
1998:                     * Overview:        The length of the CRC generator polynomial is set as being pLen;
1999:                     *
2000:                     * Note:            None
2001:                     *
2002:                     * Example:         DmaCrcSetPLen(32);
2003:                     ********************************************************************/
2004:                    extern __inline__ void __attribute__((always_inline)) DmaCrcSetPLen(int pLen)
2005:                    {
2006:                        DCRCCONCLR=_DCRCCON_PLEN_MASK;
2007:                        DCRCCONSET=(pLen)-1;
2008:                    }
2009:                
2010:                    /*********************************************************************
2011:                     * Function:        int DmaCrcGetPLen(void)
2012:                     *
2013:                     * PreCondition:    None
2014:                     *
2015:                     * Input:           None
2016:                     *
2017:                     * Output:          the length of the CRC generator polynomial
2018:                     *
2019:                     * Side Effects:    None
2020:                     *
2021:                     * Overview:        The function returns the current length of the CRC generator polynomial.
2022:                     *                  It's always a number between 1 and 32.
2023:                     *
2024:                     * Note:            None
2025:                     *
2026:                     * Example:         int polyLen=DmaCrcGetPLen();
2027:                     ********************************************************************/
2028:                    extern __inline__ int __attribute__((always_inline)) DmaCrcGetPLen(void)
2029:                    {
2030:                        return  DCRCCONbits.PLEN+1;
2031:                    }
2032:                
2033:                    /*********************************************************************
2034:                     * Function:        void DmaCrcSetShiftFeedback(unsigned int feedback)
2035:                     *
2036:                     * PreCondition:    None
2037:                     *
2038:                     * Input:           feedback - the layout of the CRC generator
2039:                     *
2040:                     * Output:          None
2041:                     *
2042:                     * Side Effects:    None
2043:                     *
2044:                     * Overview:        The function sets the layout of the shift stages that take place in the CRC generation.
2045:                     *                  Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
2046:                     *                  If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
2047:                     *
2048:                     * Note:            Bit 0 of the generator polynomial is always XOR'ed.
2049:                     *
2050:                     * Example:         DmaCrcSetShiftFeedback(0x04c11db7);
2051:                     ********************************************************************/
2052:                    extern __inline__ void __attribute__((always_inline)) DmaCrcSetShiftFeedback(unsigned int feedback)
2053:                    {
2054:                        DCRCXOR=feedback;
2055:                    }
2056:                
2057:                
2058:                    /*********************************************************************
2059:                     * Function:        unsigned int DmaCrcGetShiftFeedback(void)
2060:                     *
2061:                     * PreCondition:    None
2062:                     *
2063:                     * Input:           None
2064:                     *
2065:                     * Output:          the current layout of the CRC generator
2066:                     *
2067:                     * Side Effects:    None
2068:                     *
2069:                     * Overview:        The function returns the layout of the shift stages that take place in the CRC generation.
2070:                     *                  A bit set to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
2071:                     *                  If a bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
2072:                     *
2073:                     * Note:            Bit 0 of the generator polynomial is always XOR'ed.
2074:                     *
2075:                     * Example:         int feedback=DmaCrcGetShiftFeedback();
2076:                     ********************************************************************/
2077:                    extern __inline__ unsigned int __attribute__((always_inline)) DmaCrcGetShiftFeedback(void)
2078:                    {
2079:                        return DCRCXOR;
2080:                    }
2081:                
2082:                
2083:                
2084:                    // Channel test/debug and special functions
2085:                
2086:                    /*********************************************************************
2087:                     * Function:        void DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags)
2088:                     *
2089:                     * PreCondition:    chn - valid DMA channel
2090:                     *
2091:                     * Input:           chn     - DMA channel number
2092:                     *                  eFlags  - event flags with the following significance:
2093:                     *                              - DMA_EV_ERR: address error event
2094:                     *                              - DMA_EV_ABORT: transfer abort event
2095:                     *                              - DMA_EV_CELL_DONE: cell transfer complete event
2096:                     *                              - DMA_EV_BLOCK_DONE: block transfer complete event
2097:                     *                              - DMA_EV_DST_HALF: destination half event
2098:                     *                              - DMA_EV_DST_FULL: destination full event
2099:                     *                              - DMA_EV_SRC_HALF: source half event
2100:                     *                              - DMA_EV_SRC_FULL: source full event
2101:                     *                              - DMA_EV_ALL_EVNTS: all of the above flags
2102:                     *
2103:                     * Output:          None
2104:                     *
2105:                     * Side Effects:    None
2106:                     *
2107:                     * Overview:        The function sets the event flags for the selected DMA channel.
2108:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
2109:                     *                  set for the selected channel, the other channel event flags won't be touched.
2110:                     *
2111:                     * Note:            This is intended as a channel test function.
2112:                     *
2113:                     * Example:         DmaChnSetEvFlags(DMA_CHANNEL0, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2114:                     ********************************************************************/
2115:                     void           DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2116:                
2117:                    /*********************************************************************
2118:                     * Function:        void DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags)
2119:                     *
2120:                     * PreCondition:    chn - valid DMA channel
2121:                     *
2122:                     * Input:           chn     - DMA channel number
2123:                     *                  eFlags  - event flags with the following significance:
2124:                     *                              - DMA_EV_ERR: address error event
2125:                     *                              - DMA_EV_ABORT: transfer abort event
2126:                     *                              - DMA_EV_CELL_DONE: cell transfer complete event
2127:                     *                              - DMA_EV_BLOCK_DONE: block transfer complete event
2128:                     *                              - DMA_EV_DST_HALF: destination half event
2129:                     *                              - DMA_EV_DST_FULL: destination full event
2130:                     *                              - DMA_EV_SRC_HALF: source half event
2131:                     *                              - DMA_EV_SRC_FULL: source full event
2132:                     *                              - DMA_EV_ALL_EVNTS: all of the above flags
2133:                     *
2134:                     * Output:          None
2135:                     *
2136:                     * Side Effects:    None
2137:                     *
2138:                     * Overview:        The function writes the event flags for the selected DMA channel.
2139:                     *                  The channel event flags are forced to the eFlags value.
2140:                     *
2141:                     * Note:            This is intended as a channel test function.
2142:                     *
2143:                     * Example:         DmaChnWriteEvFlags(DMA_CHANNEL0, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2144:                     ********************************************************************/
2145:                     void           DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2146:                
2147:                
2148:                    /********************************************************************
2149:                     * Include legacy DMA functions
2150:                     * New projects should not use them!
2151:                     * Note that interrupt functions are no longer provided.
2152:                     * The functions in the int.h should be used instead.
2153:                     ********************************************************************/
2154:                    #ifndef _PLIB_DISABLE_LEGACY
2155:                        #include <peripheral/legacy/dma_legacy.h>
2156:                    #endif
2157:                
2158:                
2159:                #else
2160:                    #undef _DMA_CHANNELS        // no DMA channels
2161:                #endif  // _DMAC0
2162:                
2163:                #endif /*_DMA_1XX_2XX_H_*/
2164:                
2165:                

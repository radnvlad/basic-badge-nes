Disassembly Listing for badge1
Generated From:
/Users/nitro/basic-badge/firmware/badge1.X/dist/default/debug/badge1.X.debug.elf
May 29, 2018 11:58:59 PM

---  /Users/nitro/basic-badge/firmware/badge1.X/src/vt100.c  --------------------------------------------
1:                   #include <string.h>
2:                   #include <stdlib.h>
3:                   #include <stdio.h>
4:                   #include "vt100.h"
5:                   #include "badge.h"
6:                   #include "hw.h"
7:                   
8:                   #define MAX_BUF 50
9:                   
10:                  uint8_t msg1[50];
11:                  
12:                  uint8_t color_composite;
13:                  uint16_t count;
14:                  volatile uint16_t bufhead;
15:                  volatile uint16_t buftail;
16:                  volatile uint16_t bufsize;
17:                  static int8_t cx;
18:                  static int8_t cy;
19:                  static uint8_t showcursor;
20:                  /* parameters from setup */
21:                  static uint8_t newlineseq;
22:                  static uint8_t process_escseqs;
23:                  static uint8_t local_echo;
24:                  /* escape sequence processing */
25:                  static uint8_t in_esc;
26:                  static int8_t paramstr[MAX_ESC_LEN+1];
27:                  static int8_t *paramptr;
28:                  static uint8_t paramch;
29:                  /* current attributes */
30:                  static uint8_t graphicchars;  /* set to 1 with an SI and set to 0 with an SO */
31:                  static uint8_t revvideo;      /* reverse video attribute */
32:                  static termstate_t savedstate;/* state used for save/restore sequences */
33:                  /* Vertical margins */
34:                  static int8_t mtop;
35:                  static int8_t mbottom;
36:                  
37:                  /* reverse video */
38:                  static uint8_t revvideo;
39:                  
40:                  uint8_t cur_type,cur_blink;
41:                  
42:                  extern int8_t disp_buffer[DISP_BUFFER_HIGH+1][DISP_BUFFER_WIDE];
43:                  extern int8_t color_buffer[DISP_BUFFER_HIGH+1][DISP_BUFFER_WIDE];
44:                  volatile uint8_t buf[MAX_BUF];
45:                  
46:                  void video_set_color(uint8_t fg, uint8_t bg)
47:                  	{
48:                  	color_composite = (fg&0xF) | ((bg&0xF)<<4);
9D01A374  00052900   SLL A1, A1, 4
9D01A378  3084000F   ANDI A0, A0, 15
9D01A37C  00A42825   OR A1, A1, A0
9D01A380  03E00008   JR RA
9D01A384  A38581C9   SB A1, -32311(GP)
9D01A6DC  2402000F   ADDIU V0, ZERO, 15
9D01A6E0  A38281C9   SB V0, -32311(GP)
49:                  	}
50:                  
51:                  void term_init (void)
52:                  	{
9D01A6A4  27BDFFE8   ADDIU SP, SP, -24
9D01A6A8  AFBF0014   SW RA, 20(SP)
53:                  	video_reset_margins();
9D01A6AC  0F4069A1   JAL video_reset_margins
9D01A6B0  00000000   NOP
54:                  	reset_term();
9D01A6B4  0F40694F   JAL reset_term
9D01A6B8  00000000   NOP
55:                  	process_escseqs = 1;
9D01A6BC  24020001   ADDIU V0, ZERO, 1
9D01A6C0  A382818D   SB V0, -32371(GP)
56:                  	buftail = 0;
9D01A6C4  A78081CA   SH ZERO, -32310(GP)
57:                  	bufhead = 0;
9D01A6C8  A78081C2   SH ZERO, -32318(GP)
58:                  	bufsize = 0;
9D01A6CC  A78081C0   SH ZERO, -32320(GP)
59:                  	cur_blink = 1;
9D01A6D0  A38281C8   SB V0, -32312(GP)
60:                  	cur_type = 2;
9D01A6D4  24020002   ADDIU V0, ZERO, 2
9D01A6D8  A38281C4   SB V0, -32316(GP)
61:                  	video_set_color(15,0);
62:                  	}
9D01A6E4  8FBF0014   LW RA, 20(SP)
9D01A6E8  03E00008   JR RA
9D01A6EC  27BD0018   ADDIU SP, SP, 24
63:                  
64:                  void buf_enqueue(uint8_t c)
65:                  	{
66:                  	if (bufsize < MAX_BUF)
9D01A388  978281C0   LHU V0, -32320(GP)
9D01A38C  3042FFFF   ANDI V0, V0, -1
9D01A390  2C420032   SLTIU V0, V0, 50
9D01A394  10400012   BEQ V0, ZERO, 0x9D01A3E0
9D01A398  00000000   NOP
67:                  		{
68:                  		buf[buftail] = c;
9D01A39C  978381CA   LHU V1, -32310(GP)
9D01A3A0  3063FFFF   ANDI V1, V1, -1
9D01A3A4  3C02A000   LUI V0, -24576
9D01A3A8  244219B4   ADDIU V0, V0, 6580
9D01A3AC  00621021   ADDU V0, V1, V0
9D01A3B0  A0440000   SB A0, 0(V0)
69:                  		if (++buftail >= MAX_BUF) buftail = 0;
9D01A3B4  978281CA   LHU V0, -32310(GP)
9D01A3B8  24420001   ADDIU V0, V0, 1
9D01A3BC  3042FFFF   ANDI V0, V0, -1
9D01A3C0  A78281CA   SH V0, -32310(GP)
9D01A3C4  2C420032   SLTIU V0, V0, 50
9D01A3C8  50400001   BEQL V0, ZERO, 0x9D01A3D0
9D01A3CC  A78081CA   SH ZERO, -32310(GP)
70:                  		bufsize++;
9D01A3D0  978281C0   LHU V0, -32320(GP)
9D01A3D4  24420001   ADDIU V0, V0, 1
9D01A3D8  3042FFFF   ANDI V0, V0, -1
9D01A3DC  A78281C0   SH V0, -32320(GP)
9D01A3E0  03E00008   JR RA
9D01A3E4  00000000   NOP
71:                  		}
72:                  	}
73:                  
74:                  uint8_t buf_dequeue()
75:                  	{
76:                  	uint8_t ret = 0;
77:                  	if (bufsize > 0)
9D01A3E8  978381C0   LHU V1, -32320(GP)
9D01A3EC  3063FFFF   ANDI V1, V1, -1
9D01A3F0  10600013   BEQ V1, ZERO, .LBE2
9D01A3F4  00001021   ADDU V0, ZERO, ZERO
78:                  		{
79:                  		uint8_t c = buf[bufhead];
9D01A3F8  978381C2   LHU V1, -32318(GP)
9D01A3FC  3063FFFF   ANDI V1, V1, -1
9D01A400  3C02A000   LUI V0, -24576
9D01A404  244219B4   ADDIU V0, V0, 6580
9D01A408  00621021   ADDU V0, V1, V0
9D01A40C  90420000   LBU V0, 0(V0)
9D01A410  304200FF   ANDI V0, V0, 255
80:                  		if (++bufhead >= MAX_BUF) bufhead = 0;
9D01A414  978381C2   LHU V1, -32318(GP)
9D01A418  24630001   ADDIU V1, V1, 1
9D01A41C  3063FFFF   ANDI V1, V1, -1
9D01A420  A78381C2   SH V1, -32318(GP)
9D01A424  2C630032   SLTIU V1, V1, 50
9D01A428  50600001   BEQL V1, ZERO, 0x9D01A430
9D01A42C  A78081C2   SH ZERO, -32318(GP)
81:                  		bufsize--;
9D01A430  978381C0   LHU V1, -32320(GP)
9D01A434  2463FFFF   ADDIU V1, V1, -1
9D01A438  3063FFFF   ANDI V1, V1, -1
9D01A43C  A78381C0   SH V1, -32320(GP)
82:                  		ret = c;
83:                  		}
84:                  	return ret;
85:                  	}
9D01A440  03E00008   JR RA
9D01A444  00000000   NOP
86:                  
87:                  uint8_t buf_size()
88:                  	{
89:                  	uint8_t sz;
90:                  	sz = bufsize;
9D01A448  978281C0   LHU V0, -32320(GP)
91:                  	return sz;
92:                  	}
9D01A44C  03E00008   JR RA
9D01A450  304200FF   ANDI V0, V0, 255
93:                  
94:                  //jar
95:                  /*
96:                  ISR(USART_RX_vect)
97:                  {
98:                  	buf_enqueue(RCREG);
99:                  }
100:                 
101:                 */
102:                 
103:                 
104:                 
105:                 void receive_char(uint8_t c)
106:                 	{
9D01B41C  27BDFFE8   ADDIU SP, SP, -24
9D01B420  AFBF0014   SW RA, 20(SP)
107:                 	if (!process_escseqs)
9D01B424  9382818D   LBU V0, -32371(GP)
9D01B428  14400005   BNE V0, ZERO, 0x9D01B440
9D01B42C  00000000   NOP
108:                 		{
109:                 		video_putc_raw(c);
9D01B430  0F406CEA   JAL video_putc_raw
9D01B434  7C042420   SEB A0, A0
110:                 		return;
9D01B438  0B406D4F   J 0x9D01B53C
9D01B43C  8FBF0014   LW RA, 20(SP)
111:                 		}
112:                 
113:                 	if (c)
9D01B440  1080003D   BEQ A0, ZERO, .LVL207
9D01B444  9382818C   LBU V0, -32372(GP)
114:                 		{
115:                 		if (in_esc)
9D01B448  10400005   BEQ V0, ZERO, 0x9D01B460
9D01B44C  2402000D   ADDIU V0, ZERO, 13
116:                 			escseq_process(c);
9D01B450  0F406C9E   JAL escseq_process
9D01B454  7C042420   SEB A0, A0
9D01B458  0B406D4F   J 0x9D01B53C
9D01B45C  8FBF0014   LW RA, 20(SP)
117:                 		else switch (c)
9D01B460  10820035   BEQ A0, V0, .LVL207
9D01B464  2C82000E   SLTIU V0, A0, 14
9D01B468  1040000F   BEQ V0, ZERO, 0x9D01B4A8
9D01B46C  2402000F   ADDIU V0, ZERO, 15
9D01B470  24020008   ADDIU V0, ZERO, 8
9D01B474  10820017   BEQ A0, V0, 0x9D01B4D4
9D01B478  2C820009   SLTIU V0, A0, 9
9D01B47C  10400006   BEQ V0, ZERO, 0x9D01B498
9D01B480  2C82000A   SLTIU V0, A0, 10
9D01B484  24020007   ADDIU V0, ZERO, 7
9D01B488  1082002C   BEQ A0, V0, 0x9D01B53C
9D01B48C  8FBF0014   LW RA, 20(SP)
9D01B498  10400016   BEQ V0, ZERO, 0x9D01B4F4
9D01B49C  2C820020   SLTIU V0, A0, 32
9D01B4A0  0B406D4A   J 0x9D01B528
9D01B4A4  00000000   NOP
9D01B4A8  1082001B   BEQ A0, V0, 0x9D01B518
9D01B4AC  2C82000F   SLTIU V0, A0, 15
9D01B4B0  14400016   BNE V0, ZERO, 0x9D01B50C
9D01B4B4  2402001B   ADDIU V0, ZERO, 27
9D01B4B8  10820019   BEQ A0, V0, 0x9D01B520
9D01B4BC  24020001   ADDIU V0, ZERO, 1
9D01B4C0  2402007F   ADDIU V0, ZERO, 127
9D01B4C4  14820018   BNE A0, V0, 0x9D01B528
9D01B4C8  2C820020   SLTIU V0, A0, 32
118:                 				{
119:                 				case 0x07: /* BEL */
120:                 					break;   /* ignore bells */
121:                 				case '\b': /* backspace */
122:                 					video_cback();
9D01B4D4  0F406A0A   JAL video_cback
9D01B4D8  00000000   NOP
123:                 					video_putc_raw(' ');
9D01B4DC  0F406CEA   JAL video_putc_raw
9D01B4E0  24040020   ADDIU A0, ZERO, 32
124:                 					video_cback();
9D01B4E4  0F406A0A   JAL video_cback
9D01B4E8  00000000   NOP
125:                 					break;
9D01B4EC  0B406D4F   J 0x9D01B53C
9D01B4F0  8FBF0014   LW RA, 20(SP)
126:                 				case 0x0A: /* LF, VT, and FF all print a linefeed */
127:                 				case 0x0B:
128:                 				case 0x0C:
129:                 					video_setx(0);
9D01B4F4  0F406970   JAL video_setx
9D01B4F8  00002021   ADDU A0, ZERO, ZERO
130:                 					video_lf();
9D01B4FC  0F4069EF   JAL video_lf
9D01B500  00000000   NOP
131:                 					break;
9D01B504  0B406D4F   J 0x9D01B53C
9D01B508  8FBF0014   LW RA, 20(SP)
132:                 				case 0x0D: /* CR */
133:                 //       video_setx(0);
134:                 					break;
135:                 				case 0x0E: /* SO; enable box-drawing characters */
136:                 					graphicchars = 1;
9D01B50C  24020001   ADDIU V0, ZERO, 1
137:                 					break;
9D01B510  0B406D4E   J .LVL207
9D01B514  A3828185   SB V0, -32379(GP)
138:                 				case 0x0F: /* SI; return to normal characters */
139:                 					graphicchars = 0;
140:                 					break;
9D01B518  0B406D4E   J .LVL207
9D01B51C  A3808185   SB ZERO, -32379(GP)
141:                 				case 0x1B: /* ESC */
142:                 					in_esc = ESC_GOT_1B;
143:                 					break;
9D01B520  0B406D4E   J .LVL207
9D01B524  A382818C   SB V0, -32372(GP)
144:                 				case 0x7F: /* DEL */
145:                 					break;
146:                 				default:
147:                 					if (c >= ' ')
9D01B490  0B406D4A   J 0x9D01B528
9D01B494  2C820020   SLTIU V0, A0, 32
9D01B528  14400004   BNE V0, ZERO, 0x9D01B53C
9D01B52C  8FBF0014   LW RA, 20(SP)
148:                 						{
149:                 //jar
150:                 						/*
151:                 						          if (graphicchars && c >= '_' && c <= '~')
152:                 						            c -= 95;
153:                 						          c |= revvideo;
154:                 						*/
155:                 						video_putc_raw(c);
9D01B530  0F406CEA   JAL video_putc_raw
9D01B534  7C042420   SEB A0, A0
156:                 						}
157:                 				}
158:                 		}
159:                 	}
9D01B4CC  0B406D4F   J 0x9D01B53C
9D01B4D0  8FBF0014   LW RA, 20(SP)
9D01B538  8FBF0014   LW RA, 20(SP)
9D01B53C  03E00008   JR RA
9D01B540  27BD0018   ADDIU SP, SP, 24
160:                 
161:                 
162:                 void escseq_process(int8_t c)
163:                 	{
9D01B278  27BDFFE8   ADDIU SP, SP, -24
164:                 	/* CAN and SUB interrupt escape sequences */
165:                 	if (c == 0x18 || c == 0x1A)
9D01B27C  2402FFFD   ADDIU V0, ZERO, -3
9D01B280  00821824   AND V1, A0, V0
9D01B284  24020018   ADDIU V0, ZERO, 24
9D01B288  14620003   BNE V1, V0, 0x9D01B298
9D01B28C  AFBF0014   SW RA, 20(SP)
166:                 		{
167:                 		in_esc = NOT_IN_ESC;
168:                 		return;
9D01B290  0B406CB7   J .LVL183
9D01B294  A380818C   SB ZERO, -32372(GP)
169:                 		}
170:                 
171:                 	if (in_esc == ESC_CSI)
9D01B298  9382818C   LBU V0, -32372(GP)
9D01B29C  24030002   ADDIU V1, ZERO, 2
9D01B2A0  14430005   BNE V0, V1, 0x9D01B2B8
9D01B2A4  24030003   ADDIU V1, ZERO, 3
172:                 		escseq_process_csi(c);
9D01B2A8  0F406B98   JAL escseq_process_csi
9D01B2AC  00000000   NOP
9D01B2B0  0B406CB8   J 0x9D01B2E0
9D01B2B4  8FBF0014   LW RA, 20(SP)
173:                 	else if (in_esc == ESC_NONCSI)
9D01B2B8  14430003   BNE V0, V1, 0x9D01B2C8
9D01B2BC  24030001   ADDIU V1, ZERO, 1
9D01B2C0  0B406CB7   J .LVL183
9D01B2C4  A380818C   SB ZERO, -32372(GP)
174:                 		{
175:                 		/* received a non-CSI sequence that requires a parameter
176:                 		 * (ESC #, ESC %, etc)
177:                 		 * These aren't supported, so eat this character */
178:                 		in_esc = NOT_IN_ESC;
179:                 		}
180:                 	else if (in_esc == ESC_GOT_1B)
9D01B2C8  14430005   BNE V0, V1, 0x9D01B2E0
9D01B2CC  8FBF0014   LW RA, 20(SP)
181:                 		{
182:                 		in_esc = ESC_NONCSI;
9D01B2D0  24020003   ADDIU V0, ZERO, 3
183:                 		escseq_process_noncsi(c);
9D01B2D4  0F406A3E   JAL escseq_process_noncsi
9D01B2D8  A382818C   SB V0, -32372(GP)
184:                 		}
185:                 	}
9D01B2DC  8FBF0014   LW RA, 20(SP)
9D01B2E0  03E00008   JR RA
9D01B2E4  27BD0018   ADDIU SP, SP, 24
186:                 
187:                 /* Process sequences that begin with ESC */
188:                 void escseq_process_noncsi(int8_t c)
189:                 	{
9D01A8F8  27BDFFE8   ADDIU SP, SP, -24
190:                 	switch (c)
9D01A8FC  2484FFDD   ADDIU A0, A0, -35
9D01A900  308200FF   ANDI V0, A0, 255
9D01A904  2C420041   SLTIU V0, V0, 65
9D01A908  10400074   BEQ V0, ZERO, .LVL86, .L116
9D01A90C  AFBF0014   SW RA, 20(SP)
9D01A910  308400FF   ANDI A0, A0, 255
9D01A914  00042080   SLL A0, A0, 2
9D01A918  3C029D02   LUI V0, -25342
9D01A91C  2442A930   ADDIU V0, V0, -22224
9D01A920  00442021   ADDU A0, V0, A0
9D01A924  8C820000   LW V0, 0(A0)
9D01A928  00400008   JR V0
9D01A92C  00000000   NOP
191:                 		{
192:                 		case '[': /* got the [; this is a CSI sequence */
193:                 			escseq_csi_start();
9D01AA34  0F406915   JAL escseq_csi_start
9D01AA38  00000000   NOP
194:                 			in_esc = ESC_CSI;
9D01AA3C  24020002   ADDIU V0, ZERO, 2
195:                 			break;
9D01AA40  0B406AB8   J 0x9D01AAE0
9D01AA44  A382818C   SB V0, -32372(GP)
196:                 		case '%': /* non-CSI codes that require parameters */
197:                 		case '#': /* (we don't support these) */
198:                 		case '(':
199:                 		case ')':
200:                 			break;  /* return without setting in_esc to NOT_IN_ESC */
201:                 		case '7': /* save cursor position and attributes */
202:                 			save_term_state();
9D01AA48  0F406945   JAL save_term_state
9D01AA4C  00000000   NOP
203:                 			goto esc_done;
9D01AA50  0B406AB8   J 0x9D01AAE0
9D01AA54  A380818C   SB ZERO, -32372(GP)
204:                 		case '8': /* restore cursor position and attributes */
205:                 			restore_term_state();
9D01AA58  0F40694A   JAL restore_term_state
9D01AA5C  00000000   NOP
206:                 			goto esc_done;
9D01AA60  0B406AB8   J 0x9D01AAE0
9D01AA64  A380818C   SB ZERO, -32372(GP)
207:                 		case 'E': /* next line */
208:                 			video_movesol(); /* fall through */
209:                 		case 'D': /* index */
210:                 
211:                 			if (video_gety() == video_bottom_margin())
9D01AA6C  8383818F   LB V1, -32369(GP)
9D01AA70  8382817C   LB V0, -32388(GP)
9D01AA74  14620005   BNE V1, V0, 0x9D01AA8C
9D01AA78  00000000   NOP
212:                 				video_scrollup();
213:                 			else
214:                 				video_movey(1);
9D01AA8C  0F4069C9   JAL video_movey
9D01AA90  24040001   ADDIU A0, ZERO, 1
215:                 			goto esc_done;
216:                 		case 'M': /* reverse index */
217:                 			if (video_gety() == video_top_margin())
9D01AA9C  8383818F   LB V1, -32369(GP)
9D01AAA0  8382817D   LB V0, -32387(GP)
9D01AAA4  14620005   BNE V1, V0, 0x9D01AABC
9D01AAA8  00000000   NOP
218:                 				video_scrolldown();
219:                 			else
220:                 				video_movey(-1);
9D01AABC  0F4069C9   JAL video_movey
9D01AAC0  2404FFFF   ADDIU A0, ZERO, -1
221:                 			goto esc_done;
222:                 		case 'c': /* reset */
223:                 			video_clrscr();
9D01AACC  0F406A2B   JAL video_clrscr
9D01AAD0  00000000   NOP
224:                 			reset_term();
9D01AAD4  0F40694F   JAL reset_term
9D01AAD8  00000000   NOP
225:                 			goto esc_done;
226:                 		default: /* other non-CSI codes */
227:                 esc_done:
228:                 			in_esc = NOT_IN_ESC; /* unimplemented */
9D01AA84  0B406AB8   J 0x9D01AAE0
9D01AA88  A380818C   SB ZERO, -32372(GP)
9D01AA94  0B406AB8   J 0x9D01AAE0
9D01AA98  A380818C   SB ZERO, -32372(GP)
9D01AAB4  0B406AB8   J 0x9D01AAE0
9D01AAB8  A380818C   SB ZERO, -32372(GP)
9D01AAC4  0B406AB8   J 0x9D01AAE0
9D01AAC8  A380818C   SB ZERO, -32372(GP)
9D01AADC  A380818C   SB ZERO, -32372(GP)
229:                 			break;
230:                 		}
231:                 	}
9D01AAE0  8FBF0014   LW RA, 20(SP)
9D01AAE4  03E00008   JR RA
9D01AAE8  27BD0018   ADDIU SP, SP, 24
232:                 
233:                 /* Process sequences that begin with ESC [ */
234:                 void escseq_process_csi(int8_t c)
235:                 	{
9D01AE60  27BDFFE0   ADDIU SP, SP, -32
9D01AE64  AFBF001C   SW RA, 28(SP)
9D01AE68  AFB20018   SW S2, 24(SP)
9D01AE6C  AFB10014   SW S1, 20(SP)
236:                 	if ((c >= '0' && c <= '9') || c == ';' || c == '?') /* digit or separator */
9D01AE70  2482FFD0   ADDIU V0, A0, -48
9D01AE74  304200FF   ANDI V0, V0, 255
9D01AE78  2C42000A   SLTIU V0, V0, 10
9D01AE7C  14400006   BNE V0, ZERO, 0x9D01AE98
9D01AE80  AFB00010   SW S0, 16(SP)
9D01AE84  2402FFFB   ADDIU V0, ZERO, -5
9D01AE88  00821824   AND V1, A0, V0
9D01AE8C  2402003B   ADDIU V0, ZERO, 59
9D01AE90  5462000D   BNEL V1, V0, 0x9D01AEC8
9D01AE94  2484FFBF   ADDIU A0, A0, -65
237:                 		{
238:                 		/* save the character */
239:                 		if (paramch >= MAX_ESC_LEN) /* received too many characters */
9D01AE98  93828186   LBU V0, -32378(GP)
9D01AE9C  2C430030   SLTIU V1, V0, 48
9D01AEA0  14600003   BNE V1, ZERO, 0x9D01AEB0
9D01AEA4  3C03A001   LUI V1, -24575
240:                 			{
241:                 			in_esc = NOT_IN_ESC;
242:                 			return;
9D01AEA8  0B406C98   J 0x9D01B260
9D01AEAC  A380818C   SB ZERO, -32372(GP)
243:                 			}
244:                 		paramstr[paramch] = c;
9D01AEB0  2463B698   ADDIU V1, V1, -18792
9D01AEB4  00431821   ADDU V1, V0, V1
9D01AEB8  A0640000   SB A0, 0(V1)
245:                 		paramch++;
9D01AEBC  24420001   ADDIU V0, V0, 1
9D01AEC0  0B406C98   J 0x9D01B260
9D01AEC4  A3828186   SB V0, -32378(GP)
246:                 		}
247:                 	else
248:                 		{
249:                 		/* take the appropriate action */
250:                 		switch (c)
9D01AEC8  308200FF   ANDI V0, A0, 255
9D01AECC  2C420032   SLTIU V0, V0, 50
9D01AED0  104000E2   BEQ V0, ZERO, .LVL179, .LBE53
9D01AED4  308400FF   ANDI A0, A0, 255
9D01AED8  00042080   SLL A0, A0, 2
9D01AEDC  3C029D02   LUI V0, -25342
9D01AEE0  2442AEF4   ADDIU V0, V0, -20748
9D01AEE4  00441021   ADDU V0, V0, A0
9D01AEE8  8C420000   LW V0, 0(V0)
9D01AEEC  00400008   JR V0
9D01AEF0  00000000   NOP
251:                 			{
252:                 			case 'A': /* cursor up */
253:                 				video_movey(-escseq_get_param(1));
9D01AFCC  0F406927   JAL escseq_get_param
9D01AFD0  24040001   ADDIU A0, ZERO, 1
9D01AFD4  00021023   SUBU V0, ZERO, V0
9D01AFD8  0F4069C9   JAL video_movey
9D01AFDC  7C022420   SEB A0, V0
254:                 				break;
9D01AFE0  0B406C98   J 0x9D01B260
9D01AFE4  A380818C   SB ZERO, -32372(GP)
255:                 			case 'B': /* cursor down */
256:                 				video_movey(escseq_get_param(1));
9D01AFE8  0F406927   JAL escseq_get_param
9D01AFEC  24040001   ADDIU A0, ZERO, 1
9D01AFF0  0F4069C9   JAL video_movey
9D01AFF4  7C022420   SEB A0, V0
257:                 				break;
9D01AFF8  0B406C98   J 0x9D01B260
9D01AFFC  A380818C   SB ZERO, -32372(GP)
258:                 			case 'C': /* cursor forward */
259:                 				video_movex(escseq_get_param(1));
9D01B000  0F406927   JAL escseq_get_param
9D01B004  24040001   ADDIU A0, ZERO, 1
9D01B008  0F4069BC   JAL video_movex
9D01B00C  7C022420   SEB A0, V0
260:                 				break;
9D01B010  0B406C98   J 0x9D01B260
9D01B014  A380818C   SB ZERO, -32372(GP)
261:                 			case 'D': /* cursor back */
262:                 				video_movex(-escseq_get_param(1));
9D01B018  0F406927   JAL escseq_get_param
9D01B01C  24040001   ADDIU A0, ZERO, 1
9D01B020  00021023   SUBU V0, ZERO, V0
9D01B024  0F4069BC   JAL video_movex
9D01B028  7C022420   SEB A0, V0
263:                 				break;
9D01B02C  0B406C98   J 0x9D01B260
9D01B030  A380818C   SB ZERO, -32372(GP)
264:                 			case 'E': /* cursor to next line */
265:                 				video_movey(escseq_get_param(1));
9D01B034  0F406927   JAL escseq_get_param
9D01B038  24040001   ADDIU A0, ZERO, 1
9D01B03C  0F4069C9   JAL video_movey
9D01B040  7C022420   SEB A0, V0
266:                 				video_movesol();
267:                 				break;
268:                 			case 'F': /* cursor to previous line */
269:                 				video_movey(-escseq_get_param(1));
9D01B04C  0F406927   JAL escseq_get_param
9D01B050  24040001   ADDIU A0, ZERO, 1
9D01B054  00021023   SUBU V0, ZERO, V0
9D01B058  0F4069C9   JAL video_movey
9D01B05C  7C022420   SEB A0, V0
270:                 				video_movesol();
271:                 				break;
272:                 			case 'G': /* cursor horizontal absolute */
273:                 				video_setx(escseq_get_param(1)-1); /* one-indexed */
9D01B068  0F406927   JAL escseq_get_param
9D01B06C  24040001   ADDIU A0, ZERO, 1
9D01B070  2442FFFF   ADDIU V0, V0, -1
9D01B074  0F406970   JAL video_setx
9D01B078  7C022420   SEB A0, V0
274:                 				break;
9D01B07C  0B406C98   J 0x9D01B260
9D01B080  A380818C   SB ZERO, -32372(GP)
275:                 			case 'H':
276:                 			case 'f': /* horizonal and vertical position */
277:                 				{
278:                 				uint8_t y = escseq_get_param(1);
9D01B084  0F406927   JAL escseq_get_param
9D01B088  24040001   ADDIU A0, ZERO, 1
9D01B08C  00408021   ADDU S0, V0, ZERO
279:                 				uint8_t x = escseq_get_param(1);
9D01B090  0F406927   JAL escseq_get_param
9D01B094  24040001   ADDIU A0, ZERO, 1
280:                 				video_gotoxy(x-1, y-1);
9D01B098  2442FFFF   ADDIU V0, V0, -1
9D01B09C  2605FFFF   ADDIU A1, S0, -1
9D01B0A0  7C022420   SEB A0, V0
9D01B0A4  0F40697A   JAL video_gotoxy
9D01B0A8  7C052C20   SEB A1, A1
281:                 				break;
9D01B0AC  0B406C98   J 0x9D01B260
9D01B0B0  A380818C   SB ZERO, -32372(GP)
282:                 				}
283:                 			case 'J': /* erase */
284:                 				video_erase(escseq_get_param(0));
9D01B0B4  0F406927   JAL escseq_get_param
9D01B0B8  00002021   ADDU A0, ZERO, ZERO
9D01B0BC  0F406AF0   JAL video_erase
9D01B0C0  00402021   ADDU A0, V0, ZERO
285:                 				break;
9D01B0C4  0B406C98   J 0x9D01B260
9D01B0C8  A380818C   SB ZERO, -32372(GP)
286:                 			case 'K': /* erase in line */
287:                 				video_eraseline(escseq_get_param(0));
9D01B0CC  0F406927   JAL escseq_get_param
9D01B0D0  00002021   ADDU A0, ZERO, ZERO
9D01B0D4  0F406B4A   JAL video_eraseline
9D01B0D8  00402021   ADDU A0, V0, ZERO
288:                 				break;
9D01B0DC  0B406C98   J 0x9D01B260
9D01B0E0  A380818C   SB ZERO, -32372(GP)
289:                 			case 'L': /* erase in line */
290:                 //jar
291:                 				_video_scrolldown_lin(video_gety());
9D01B0E4  938B818F   LBU T3, -32369(GP)
292:                 				break;
293:                 			case 'M': /* erase in line */
294:                 //jar
295:                 				_video_scrollup_lin(video_gety());
296:                 				break;
297:                 
298:                 			case 'm': /* set graphic rendition */
299:                 				while (paramptr) /* read attributes until we reach the end */
9D01B220  8F828188   LW V0, -32376(GP)
9D01B224  1440FFF4   BNE V0, ZERO, .LBE51, .LBE50
9D01B228  00000000   NOP
9D01B22C  0B406C98   J 0x9D01B260
9D01B230  A380818C   SB ZERO, -32372(GP)
300:                 					{
301:                 					uint8_t attr = escseq_get_param(0);
9D01B1F8  0F406927   JAL escseq_get_param
9D01B1FC  00002021   ADDU A0, ZERO, ZERO
302:                 					if (attr == 0 || attr == 27)
9D01AFBC  2410001B   ADDIU S0, ZERO, 27
9D01B200  50400007   BEQL V0, ZERO, 0x9D01B220
9D01B204  A3808184   SB ZERO, -32380(GP)
9D01B208  14500003   BNE V0, S0, 0x9D01B218
9D01B20C  00000000   NOP
303:                 						revvideo = 0;
9D01B210  0B406C88   J 0x9D01B220
9D01B214  A3808184   SB ZERO, -32380(GP)
304:                 					else if (attr == 7)
9D01AFC0  24110007   ADDIU S1, ZERO, 7
9D01B218  50510001   BEQL V0, S1, 0x9D01B220
9D01B21C  A3928184   SB S2, -32380(GP)
305:                 						revvideo = 0x80;
9D01AFC4  0B406C88   J 0x9D01B220
9D01AFC8  2412FF80   ADDIU S2, ZERO, -128
306:                 					}
307:                 				break;
308:                 			case 'r': /* set top and bottom margins */
309:                 				{
310:                 				uint8_t top = escseq_get_param(1);
9D01B234  0F406927   JAL escseq_get_param
9D01B238  24040001   ADDIU A0, ZERO, 1
9D01B23C  00408021   ADDU S0, V0, ZERO
311:                 				uint8_t bottom = escseq_get_param(DISP_BUFFER_HIGH);
9D01B240  0F406927   JAL escseq_get_param
9D01B244  24040014   ADDIU A0, ZERO, 20
312:                 				video_set_margins(top-1, bottom-1);
9D01B248  2604FFFF   ADDIU A0, S0, -1
9D01B24C  2442FFFF   ADDIU V0, V0, -1
9D01B250  7C042420   SEB A0, A0
9D01B254  0F40698C   JAL video_set_margins
9D01B258  7C022C20   SEB A1, V0
313:                 				break;
314:                 				}
315:                 			default: /* unknown */
316:                 				break;
317:                 			}
318:                 
319:                 		in_esc = NOT_IN_ESC;
9D01B25C  A380818C   SB ZERO, -32372(GP)
320:                 		}
321:                 	}
9D01B260  8FBF001C   LW RA, 28(SP)
9D01B264  8FB20018   LW S2, 24(SP)
9D01B268  8FB10014   LW S1, 20(SP)
9D01B26C  8FB00010   LW S0, 16(SP)
9D01B270  03E00008   JR RA
9D01B274  27BD0020   ADDIU SP, SP, 32
322:                 
323:                 void escseq_csi_start()
324:                 	{
325:                 	paramch = 0;
9D01A454  A3808186   SB ZERO, -32378(GP)
326:                 	memset(paramstr, 0, MAX_ESC_LEN+1);
9D01A458  3C02A001   LUI V0, -24575
9D01A45C  AC40B698   SW ZERO, -18792(V0)
9D01A460  2442B698   ADDIU V0, V0, -18792
9D01A464  AC400004   SW ZERO, 4(V0)
9D01A468  AC400008   SW ZERO, 8(V0)
9D01A46C  AC40000C   SW ZERO, 12(V0)
9D01A470  AC400010   SW ZERO, 16(V0)
9D01A474  AC400014   SW ZERO, 20(V0)
9D01A478  AC400018   SW ZERO, 24(V0)
9D01A47C  AC40001C   SW ZERO, 28(V0)
9D01A480  AC400020   SW ZERO, 32(V0)
9D01A484  AC400024   SW ZERO, 36(V0)
9D01A488  AC400028   SW ZERO, 40(V0)
9D01A48C  AC40002C   SW ZERO, 44(V0)
9D01A490  A0400030   SB ZERO, 48(V0)
327:                 	paramptr = &paramstr[0];
9D01A494  03E00008   JR RA
9D01A498  AF828188   SW V0, -32376(GP)
328:                 	}
329:                 
330:                 uint8_t escseq_get_param(uint8_t defaultval)
331:                 	{
9D01A49C  27BDFFE0   ADDIU SP, SP, -32
9D01A4A0  AFBF001C   SW RA, 28(SP)
9D01A4A4  AFB10018   SW S1, 24(SP)
9D01A4A8  AFB00014   SW S0, 20(SP)
332:                 	uint8_t val;
333:                 	int8_t *startptr;
334:                 	int8_t *endptr;
335:                 
336:                 	if (!paramptr)
9D01A4AC  8F908188   LW S0, -32376(GP)
9D01A4B0  12000012   BEQ S0, ZERO, 0x9D01A4FC
9D01A4B4  00808821   ADDU S1, A0, ZERO
337:                 		return defaultval;
338:                 
339:                 	val = defaultval;
340:                 	startptr = paramptr;
341:                 	/* get everything up to the semicolon, move past it */
342:                 	endptr = strchr(paramptr, ';');
9D01A4B8  02002021   ADDU A0, S0, ZERO
9D01A4BC  0F40E2E0   JAL strchr
9D01A4C0  2405003B   ADDIU A1, ZERO, 59
343:                 	if (endptr)
9D01A4C4  10400004   BEQ V0, ZERO, 0x9D01A4D8
9D01A4C8  24430001   ADDIU V1, V0, 1
344:                 		{
345:                 		*endptr = '\0'; /* replace the semicolon to make atoi stop here */
9D01A4CC  A0400000   SB ZERO, 0(V0)
9D01A4D0  0B406937   J 0x9D01A4DC
9D01A4D4  AF838188   SW V1, -32376(GP)
346:                 		paramptr = endptr+1;
347:                 		}
348:                 	else
349:                 		paramptr = NULL;
9D01A4D8  AF808188   SW ZERO, -32376(GP)
350:                 
351:                 	/* ascii to integer, as long as the string isn't empty */
352:                 	/* default value is given if the string is empty */
353:                 	if (*startptr)
9D01A4DC  82020000   LB V0, 0(S0)
9D01A4E0  10400007   BEQ V0, ZERO, 0x9D01A500
9D01A4E4  02201021   ADDU V0, S1, ZERO
354:                 		val = atoi(startptr); /* will read up to the null */
9D01A4E8  02002021   ADDU A0, S0, ZERO
9D01A4EC  00002821   ADDU A1, ZERO, ZERO
9D01A4F0  0F40CF59   JAL strtol
9D01A4F4  2406000A   ADDIU A2, ZERO, 10
9D01A4F8  305100FF   ANDI S1, V0, 255
355:                 
356:                 
357:                 	return val;
358:                 	}
9D01A4FC  02201021   ADDU V0, S1, ZERO
9D01A500  8FBF001C   LW RA, 28(SP)
9D01A504  8FB10018   LW S1, 24(SP)
9D01A508  8FB00014   LW S0, 20(SP)
9D01A50C  03E00008   JR RA
9D01A510  27BD0020   ADDIU SP, SP, 32
359:                 
360:                 void save_term_state()
361:                 	{
362:                 //jar
363:                 //  savedstate.cx = video_getx();
364:                 //  savedstate.cy = video_gety();
365:                 	savedstate.graphicchars = graphicchars;
9D01A514  93828185   LBU V0, -32379(GP)
9D01A518  A3828182   SB V0, -32382(GP)
366:                 	savedstate.revvideo = revvideo;
9D01A51C  93828184   LBU V0, -32380(GP)
9D01A520  03E00008   JR RA
9D01A524  A3828183   SB V0, -32381(GP)
367:                 	}
368:                 
369:                 void restore_term_state()
370:                 	{
371:                 //jar
372:                 //  video_gotoxy(savedstate.cx, savedstate.cy);
373:                 	graphicchars = savedstate.graphicchars;
9D01A528  93828182   LBU V0, -32382(GP)
9D01A52C  A3828185   SB V0, -32379(GP)
374:                 	revvideo = savedstate.revvideo;
9D01A530  93828183   LBU V0, -32381(GP)
9D01A534  03E00008   JR RA
9D01A538  A3828184   SB V0, -32380(GP)
375:                 	}
376:                 
377:                 void reset_term()
378:                 	{
9D01A53C  27BDFFE8   ADDIU SP, SP, -24
9D01A540  AFBF0014   SW RA, 20(SP)
379:                 	graphicchars = 0;
9D01A544  A3808185   SB ZERO, -32379(GP)
380:                 	revvideo = 0;
9D01A548  A3808184   SB ZERO, -32380(GP)
381:                 	in_esc = 0;
382:                 	save_term_state();
9D01A54C  0F406945   JAL save_term_state
9D01A550  A380818C   SB ZERO, -32372(GP)
383:                 	}
9D01A554  8FBF0014   LW RA, 20(SP)
9D01A558  03E00008   JR RA
9D01A55C  27BD0018   ADDIU SP, SP, 24
384:                 
385:                 
386:                 void video_reset_margins()
387:                 	{
9D01A684  27BDFFE8   ADDIU SP, SP, -24
9D01A688  AFBF0014   SW RA, 20(SP)
388:                 	video_set_margins(0, DISP_BUFFER_HIGH-1);
9D01A68C  00002021   ADDU A0, ZERO, ZERO
9D01A690  0F40698C   JAL video_set_margins
9D01A694  24050013   ADDIU A1, ZERO, 19
389:                 	}
9D01A698  8FBF0014   LW RA, 20(SP)
9D01A69C  03E00008   JR RA
9D01A6A0  27BD0018   ADDIU SP, SP, 24
390:                 
391:                 void video_set_margins(int8_t top, int8_t bottom)
392:                 	{
9D01A630  27BDFFE8   ADDIU SP, SP, -24
9D01A634  00041027   NOR V0, ZERO, A0
9D01A638  000217C3   SRA V0, V0, 31
9D01A63C  00442024   AND A0, V0, A0
9D01A640  00A01021   ADDU V0, A1, ZERO
9D01A644  28A50014   SLTI A1, A1, 20
9D01A648  14A00002   BNE A1, ZERO, 0x9D01A654
9D01A64C  AFBF0014   SW RA, 20(SP)
9D01A650  24020013   ADDIU V0, ZERO, 19
9D01A654  7C021420   SEB V0, V0
393:                 	/* sanitize input */
394:                 	if (top < 0) top = 0;
395:                 	if (bottom >= DISP_BUFFER_HIGH) bottom = DISP_BUFFER_HIGH-1;
396:                 	if (top >= bottom)
9D01A658  0082182A   SLT V1, A0, V0
397:                 		{
398:                 		top = 0;
399:                 		bottom = DISP_BUFFER_HIGH-1;
9D01A65C  24050013   ADDIU A1, ZERO, 19
9D01A660  00A3100A   MOVZ V0, A1, V1
9D01A664  0003200A   MOVZ A0, ZERO, V1
400:                 		}
401:                 
402:                 	mtop = top;
9D01A668  A384817D   SB A0, -32387(GP)
403:                 	mbottom = bottom;
9D01A66C  A382817C   SB V0, -32388(GP)
404:                 	video_gotoxy(mtop, 0);
9D01A670  0F40697A   JAL video_gotoxy
9D01A674  00002821   ADDU A1, ZERO, ZERO
405:                 	}
9D01A678  8FBF0014   LW RA, 20(SP)
9D01A67C  03E00008   JR RA
9D01A680  27BD0018   ADDIU SP, SP, 24
406:                 
407:                 int8_t video_top_margin()
408:                 	{
409:                 	return mtop;
410:                 	}
9D01A560  03E00008   JR RA
9D01A564  8382817D   LB V0, -32387(GP)
411:                 
412:                 int8_t video_bottom_margin()
413:                 	{
414:                 	return mbottom;
415:                 	}
9D01A568  03E00008   JR RA
9D01A56C  8382817C   LB V0, -32388(GP)
416:                 
417:                 void video_set_reverse(uint8_t val)
418:                 	{
419:                 	revvideo = (val) ? 0x80 : 0;
9D01A570  24020080   ADDIU V0, ZERO, 128
9D01A574  0004100A   MOVZ V0, ZERO, A0
9D01A578  03E00008   JR RA
9D01A57C  A3828184   SB V0, -32380(GP)
420:                 	}
421:                 
422:                 static void _video_scrollup()
423:                 	{
424:                 	uint8_t i,j;
425:                 //jar
426:                 	/*
427:                 	  memmove(&disp_buffer[mtop], &disp_buffer[mtop+1], (mbottom-mtop)*DISP_BUFFER_WIDE);
428:                 	  memset(&disp_buffer[mbottom], revvideo, DISP_BUFFER_WIDE);
429:                 	*/
430:                 	for (j=1; j<(mbottom+1); j++)
9D01A0A8  838B817C   LB T3, -32388(GP)
9D01A0AC  25680001   ADDIU T0, T3, 1
9D01A0B0  29020002   SLTI V0, T0, 2
9D01A0B4  14400023   BNE V0, ZERO, 0x9D01A144
9D01A0B8  3C0AA000   LUI T2, -24576
9D01A0BC  24020001   ADDIU V0, ZERO, 1
9D01A0C0  24060001   ADDIU A2, ZERO, 1
9D01A0C4  3C07A000   LUI A3, -24576
9D01A0C8  24E71E64   ADDIU A3, A3, 7780
9D01A0CC  254A1B1C   ADDIU T2, T2, 6940
9D01A0D0  0B406842   J 0x9D01A108
9D01A0D4  24E90028   ADDIU T1, A3, 40
9D01A0F4  24C60001   ADDIU A2, A2, 1
9D01A0F8  30C600FF   ANDI A2, A2, 255
9D01A0FC  00C8182A   SLT V1, A2, T0
9D01A100  10600010   BEQ V1, ZERO, 0x9D01A144
9D01A104  00C01021   ADDU V0, A2, ZERO
9D01A108  000228C0   SLL A1, V0, 3
9D01A10C  00021140   SLL V0, V0, 5
9D01A110  00A22821   ADDU A1, A1, V0
9D01A114  00E51021   ADDU V0, A3, A1
9D01A118  01451821   ADDU V1, T2, A1
9D01A11C  0B406836   J 0x9D01A0D8
9D01A120  01252821   ADDU A1, T1, A1
9D01A124  00E21821   ADDU V1, A3, V0
9D01A168  00001021   ADDU V0, ZERO, ZERO
431:                 		{
432:                 		for (i=0; i<DISP_BUFFER_WIDE; i++)
9D01A0EC  1445FFFA   BNE V0, A1, 0x9D01A0D8
9D01A0F0  24630001   ADDIU V1, V1, 1
433:                 			{
434:                 			disp_buffer[j-1][i] = disp_buffer[j][i];
9D01A0D8  90440000   LBU A0, 0(V0)
9D01A0DC  A044FFD8   SB A0, -40(V0)
435:                 			color_buffer[j-1][i] = color_buffer[j][i];
9D01A0E0  90640000   LBU A0, 0(V1)
9D01A0E4  A064FFD8   SB A0, -40(V1)
9D01A0E8  24420001   ADDIU V0, V0, 1
436:                 			}
437:                 		}
438:                 	for (i=0; i<DISP_BUFFER_WIDE; i++)
9D01A134  1444FFFB   BNE V0, A0, 0x9D01A124
9D01A138  A0600000   SB ZERO, 0(V1)
9D01A13C  03E00008   JR RA
9D01A140  00000000   NOP
9D01A144  000B10C0   SLL V0, T3, 3
9D01A148  000B5940   SLL T3, T3, 5
9D01A14C  004B1021   ADDU V0, V0, T3
9D01A150  3C07A000   LUI A3, -24576
9D01A154  24E71E64   ADDIU A3, A3, 7780
9D01A158  00E23821   ADDU A3, A3, V0
9D01A15C  3C06A000   LUI A2, -24576
9D01A160  24C61B1C   ADDIU A2, A2, 6940
9D01A164  00C23021   ADDU A2, A2, V0
9D01A170  0B406849   J 0x9D01A124
9D01A174  24040028   ADDIU A0, ZERO, 40
439:                 		{
440:                 		disp_buffer[mbottom][i] = ' ';
9D01A128  A0650000   SB A1, 0(V1)
9D01A12C  00C21821   ADDU V1, A2, V0
9D01A130  24420001   ADDIU V0, V0, 1
9D01A16C  24050020   ADDIU A1, ZERO, 32
9D01A170  0B406849   J 0x9D01A124
9D01A174  24040028   ADDIU A0, ZERO, 40
441:                 		color_buffer[mbottom][i] = 0;
442:                 		}
443:                 
444:                 	}
445:                 
446:                 static void _video_scrollup_lin(uint8_t lin)
447:                 	{
448:                 	uint8_t i,j;
449:                 //jar
450:                 	/*
451:                 	  memmove(&disp_buffer[mtop], &disp_buffer[mtop+1], (mbottom-mtop)*DISP_BUFFER_WIDE);
452:                 	  memset(&disp_buffer[mbottom], revvideo, DISP_BUFFER_WIDE);
453:                 	*/
454:                 	for (j=(lin+1); j<(mbottom+1); j++)
9D01B174  9386818F   LBU A2, -32369(GP)
9D01B1C8  24C60001   ADDIU A2, A2, 1
455:                 		{
456:                 		for (i=0; i<DISP_BUFFER_WIDE; i++)
9D01B1C0  1445FFFA   BNE V0, A1, 0x9D01B1AC
457:                 			{
458:                 			disp_buffer[j-1][i] = disp_buffer[j][i];
9D01B1AC  90440000   LBU A0, 0(V0)
459:                 			color_buffer[j-1][i] = color_buffer[j][i];
9D01B1B4  90640000   LBU A0, 0(V1)
9D01B1B8  A064FFD8   SB A0, -40(V1)
9D01B1BC  24420001   ADDIU V0, V0, 1
9D01B1C0  1445FFFA   BNE V0, A1, 0x9D01B1AC
9D01B1C4  24630001   ADDIU V1, V1, 1
9D01B1C8  24C60001   ADDIU A2, A2, 1
9D01B1CC  30C600FF   ANDI A2, A2, 255
9D01B1D0  00C8182A   SLT V1, A2, T0
9D01B1D4  10600021   BEQ V1, ZERO, .LVL179, .LBE53
9D01B1D8  00C01021   ADDU V0, A2, ZERO
9D01B1DC  000228C0   SLL A1, V0, 3
9D01B1E0  00021140   SLL V0, V0, 5
9D01B1E4  00A22821   ADDU A1, A1, V0
9D01B1E8  00E51021   ADDU V0, A3, A1
9D01B1EC  01451821   ADDU V1, T2, A1
9D01B1F0  0B406C6B   J 0x9D01B1AC
9D01B1F4  01252821   ADDU A1, T1, A1
460:                 			}
461:                 		}
462:                 	/*
463:                 	for (i=0;i<DISP_BUFFER_WIDE;i++)
464:                 		{
465:                 		disp_buffer[lin][i] = ' ';
466:                 		}
467:                 	*/
468:                 	}
469:                 
470:                 static void _video_scrolldown()
471:                 	{
472:                 	uint8_t i,j;
473:                 //  memmove(&disp_buffer[mtop+1], &disp_buffer[mtop], (mbottom-mtop)*DISP_BUFFER_WIDE);
474:                 //  memset(&disp_buffer[mtop], revvideo, DISP_BUFFER_WIDE);
475:                 	for (j=mbottom; j>0; j--)
9D01A178  9389817C   LBU T1, -32388(GP)
9D01A17C  11200028   BEQ T1, ZERO, 0x9D01A220
9D01A180  3C0AA000   LUI T2, -24576
9D01A184  254A1E64   ADDIU T2, T2, 7780
9D01A188  3C0BA000   LUI T3, -24576
9D01A18C  0B406874   J 0x9D01A1D0
9D01A190  256B1B1C   ADDIU T3, T3, 6940
9D01A1C0  2529FFFF   ADDIU T1, T1, -1
9D01A1C4  312900FF   ANDI T1, T1, 255
9D01A1C8  51200016   BEQL T1, ZERO, 0x9D01A224
9D01A1CC  8383817D   LB V1, -32387(GP)
476:                 		{
477:                 		for (i=0; i<DISP_BUFFER_WIDE; i++)
9D01A1B8  1448FFF6   BNE V0, T0, 0x9D01A194
9D01A1BC  24630001   ADDIU V1, V1, 1
478:                 			{
479:                 			disp_buffer[j][i] = disp_buffer[j-1][i];
9D01A194  80470000   LB A3, 0(V0)
9D01A198  00453021   ADDU A2, V0, A1
9D01A19C  00C43021   ADDU A2, A2, A0
9D01A1A0  A0C70028   SB A3, 40(A2)
9D01A1D0  2522FFFF   ADDIU V0, T1, -1
9D01A1D4  000218C0   SLL V1, V0, 3
9D01A1D8  00021140   SLL V0, V0, 5
9D01A1DC  00621821   ADDU V1, V1, V0
9D01A1E0  01431021   ADDU V0, T2, V1
9D01A1E4  01631821   ADDU V1, T3, V1
9D01A1E8  000920C0   SLL A0, T1, 3
9D01A1EC  00092940   SLL A1, T1, 5
9D01A1F0  00852021   ADDU A0, A0, A1
9D01A1F4  01444021   ADDU T0, T2, A0
9D01A1F8  0B406865   J 0x9D01A194
9D01A1FC  00042823   SUBU A1, ZERO, A0
9D01A200  00E21821   ADDU V1, A3, V0
480:                 			color_buffer[j][i] = color_buffer[j-1][i];
9D01A1A4  80670000   LB A3, 0(V1)
9D01A1A8  00653021   ADDU A2, V1, A1
9D01A1AC  00C43021   ADDU A2, A2, A0
9D01A1B0  A0C70028   SB A3, 40(A2)
9D01A1B4  24420001   ADDIU V0, V0, 1
481:                 			}
482:                 		}
483:                 	for (i=0; i<DISP_BUFFER_WIDE; i++)
9D01A210  1444FFFB   BNE V0, A0, 0x9D01A200
9D01A214  A0600000   SB ZERO, 0(V1)
9D01A218  03E00008   JR RA
9D01A21C  00000000   NOP
9D01A220  8383817D   LB V1, -32387(GP)
9D01A224  000310C0   SLL V0, V1, 3
9D01A228  00031940   SLL V1, V1, 5
9D01A22C  00431021   ADDU V0, V0, V1
9D01A230  3C07A000   LUI A3, -24576
9D01A234  24E71E64   ADDIU A3, A3, 7780
9D01A238  00E23821   ADDU A3, A3, V0
9D01A23C  3C06A000   LUI A2, -24576
9D01A240  24C61B1C   ADDIU A2, A2, 6940
9D01A244  00C23021   ADDU A2, A2, V0
9D01A250  0B406880   J 0x9D01A200
9D01A254  24040028   ADDIU A0, ZERO, 40
484:                 		{
485:                 		disp_buffer[mtop][i] = ' ';
9D01A204  A0650000   SB A1, 0(V1)
9D01A208  00C21821   ADDU V1, A2, V0
9D01A20C  24420001   ADDIU V0, V0, 1
9D01A248  00001021   ADDU V0, ZERO, ZERO
9D01A24C  24050020   ADDIU A1, ZERO, 32
9D01A250  0B406880   J 0x9D01A200
9D01A254  24040028   ADDIU A0, ZERO, 40
486:                 		color_buffer[mtop][i] = 0;
487:                 		}
488:                 	}
489:                 
490:                 static void _video_scrolldown_lin(uint8_t line)
491:                 	{
492:                 	uint8_t i,j;
493:                 //  memmove(&disp_buffer[mtop+1], &disp_buffer[mtop], (mbottom-mtop)*DISP_BUFFER_WIDE);
494:                 //  memset(&disp_buffer[mtop], revvideo, DISP_BUFFER_WIDE);
495:                 	for (j=mbottom; j>(line); j--)
9D01B0E8  9389817C   LBU T1, -32388(GP)
9D01B134  2529FFFF   ADDIU T1, T1, -1
496:                 		{
497:                 		for (i=0; i<DISP_BUFFER_WIDE; i++)
9D01B12C  1448FFF6   BNE V0, T0, 0x9D01B108
498:                 			{
499:                 			disp_buffer[j][i] = disp_buffer[j-1][i];
9D01B108  80470000   LB A3, 0(V0)
9D01B144  2522FFFF   ADDIU V0, T1, -1
500:                 			color_buffer[j][i] = color_buffer[j-1][i];
9D01B118  80670000   LB A3, 0(V1)
9D01B11C  00A33021   ADDU A2, A1, V1
9D01B120  00C43021   ADDU A2, A2, A0
9D01B124  A0C70028   SB A3, 40(A2)
9D01B128  24420001   ADDIU V0, V0, 1
9D01B12C  1448FFF6   BNE V0, T0, 0x9D01B108
9D01B130  24630001   ADDIU V1, V1, 1
9D01B134  2529FFFF   ADDIU T1, T1, -1
9D01B138  312900FF   ANDI T1, T1, 255
9D01B13C  51690048   BEQL T3, T1, 0x9D01B260
9D01B140  A380818C   SB ZERO, -32372(GP)
9D01B144  2522FFFF   ADDIU V0, T1, -1
9D01B148  000218C0   SLL V1, V0, 3
9D01B14C  00021140   SLL V0, V0, 5
9D01B150  00621821   ADDU V1, V1, V0
9D01B154  01431021   ADDU V0, T2, V1
9D01B158  01831821   ADDU V1, T4, V1
9D01B15C  000920C0   SLL A0, T1, 3
9D01B160  00092940   SLL A1, T1, 5
9D01B164  00852021   ADDU A0, A0, A1
9D01B168  01444021   ADDU T0, T2, A0
9D01B16C  0B406C42   J 0x9D01B108
9D01B170  00042823   SUBU A1, ZERO, A0
501:                 			}
502:                 		}
503:                 	/*
504:                 	for (i=0;i<DISP_BUFFER_WIDE;i++)
505:                 		{
506:                 		disp_buffer[mtop][i] = '-';
507:                 		}
508:                 	*/
509:                 	}
510:                 
511:                 
512:                 
513:                 void video_scrollup()
514:                 	{
9D01A580  27BDFFE8   ADDIU SP, SP, -24
9D01A584  AFBF0014   SW RA, 20(SP)
515:                 	CURSOR_INVERT();
516:                 	_video_scrollup();
9D01A588  0F40682A   JAL .Letext0, .LFE45, .LFB27, _video_scrollup, .Ltext0
9D01A58C  00000000   NOP
9D01AA7C  0F40682A   JAL .Letext0, .LFE45, .LFB27, _video_scrollup, .Ltext0
9D01AA80  00000000   NOP
517:                 	CURSOR_INVERT();
518:                 	}
9D01A590  8FBF0014   LW RA, 20(SP)
9D01A594  03E00008   JR RA
9D01A598  27BD0018   ADDIU SP, SP, 24
519:                 
520:                 void video_scrolldown()
521:                 	{
9D01A59C  27BDFFE8   ADDIU SP, SP, -24
9D01A5A0  AFBF0014   SW RA, 20(SP)
522:                 	CURSOR_INVERT();
523:                 	_video_scrolldown();
9D01A5A4  0F40685E   JAL .LFB29, _video_scrolldown, .LFE27
9D01A5A8  00000000   NOP
9D01AAAC  0F40685E   JAL .LFB29, _video_scrolldown, .LFE27
9D01AAB0  00000000   NOP
524:                 	CURSOR_INVERT();
525:                 	}
9D01A5AC  8FBF0014   LW RA, 20(SP)
9D01A5B0  03E00008   JR RA
9D01A5B4  27BD0018   ADDIU SP, SP, 24
526:                 
527:                 void video_movesol()
528:                 	{
529:                 	CURSOR_INVERT();
530:                 	cx = 0;
9D01A5B8  03E00008   JR RA
9D01A5BC  A3808190   SB ZERO, -32368(GP)
9D01AA68  A3808190   SB ZERO, -32368(GP)
9D01B044  0B406C97   J .LVL179, .LBE53
9D01B048  A3808190   SB ZERO, -32368(GP)
9D01B060  0B406C97   J .LVL179, .LBE53
9D01B064  A3808190   SB ZERO, -32368(GP)
9D01B068  0F406927   JAL escseq_get_param
9D01B06C  24040001   ADDIU A0, ZERO, 1
9D01B070  2442FFFF   ADDIU V0, V0, -1
9D01B074  0F406970   JAL video_setx
9D01B078  7C022420   SEB A0, V0
9D01B07C  0B406C98   J 0x9D01B260
9D01B080  A380818C   SB ZERO, -32372(GP)
9D01B084  0F406927   JAL escseq_get_param
9D01B088  24040001   ADDIU A0, ZERO, 1
9D01B08C  00408021   ADDU S0, V0, ZERO
9D01B090  0F406927   JAL escseq_get_param
9D01B094  24040001   ADDIU A0, ZERO, 1
9D01B098  2442FFFF   ADDIU V0, V0, -1
9D01B09C  2605FFFF   ADDIU A1, S0, -1
9D01B0A0  7C022420   SEB A0, V0
9D01B0A4  0F40697A   JAL video_gotoxy
9D01B0A8  7C052C20   SEB A1, A1
9D01B0AC  0B406C98   J 0x9D01B260
9D01B0B0  A380818C   SB ZERO, -32372(GP)
9D01B0B4  0F406927   JAL escseq_get_param
9D01B0B8  00002021   ADDU A0, ZERO, ZERO
9D01B0BC  0F406AF0   JAL video_erase
9D01B0C0  00402021   ADDU A0, V0, ZERO
9D01B0C4  0B406C98   J 0x9D01B260
9D01B0C8  A380818C   SB ZERO, -32372(GP)
9D01B0CC  0F406927   JAL escseq_get_param
9D01B0D0  00002021   ADDU A0, ZERO, ZERO
9D01B0D4  0F406B4A   JAL video_eraseline
9D01B0D8  00402021   ADDU A0, V0, ZERO
9D01B0DC  0B406C98   J 0x9D01B260
9D01B0E0  A380818C   SB ZERO, -32372(GP)
9D01B0E4  938B818F   LBU T3, -32369(GP)
9D01B0E8  9389817C   LBU T1, -32388(GP)
9D01B0EC  0169102B   SLTU V0, T3, T1
9D01B0F0  1040005A   BEQ V0, ZERO, .LVL179, .LBE53
9D01B0F4  3C0AA000   LUI T2, -24576
9D01B0F8  254A1E64   ADDIU T2, T2, 7780
9D01B0FC  3C0CA000   LUI T4, -24576
9D01B100  0B406C51   J .LBE49
9D01B104  258C1B1C   ADDIU T4, T4, 6940
9D01B108  80470000   LB A3, 0(V0)
9D01B10C  00453021   ADDU A2, V0, A1
9D01B110  00C43021   ADDU A2, A2, A0
9D01B114  A0C70028   SB A3, 40(A2)
9D01B118  80670000   LB A3, 0(V1)
9D01B11C  00A33021   ADDU A2, A1, V1
9D01B120  00C43021   ADDU A2, A2, A0
9D01B124  A0C70028   SB A3, 40(A2)
9D01B128  24420001   ADDIU V0, V0, 1
9D01B12C  1448FFF6   BNE V0, T0, 0x9D01B108
9D01B130  24630001   ADDIU V1, V1, 1
9D01B134  2529FFFF   ADDIU T1, T1, -1
9D01B138  312900FF   ANDI T1, T1, 255
9D01B13C  51690048   BEQL T3, T1, 0x9D01B260
9D01B140  A380818C   SB ZERO, -32372(GP)
9D01B144  2522FFFF   ADDIU V0, T1, -1
9D01B148  000218C0   SLL V1, V0, 3
9D01B14C  00021140   SLL V0, V0, 5
9D01B150  00621821   ADDU V1, V1, V0
9D01B154  01431021   ADDU V0, T2, V1
9D01B158  01831821   ADDU V1, T4, V1
9D01B15C  000920C0   SLL A0, T1, 3
9D01B160  00092940   SLL A1, T1, 5
9D01B164  00852021   ADDU A0, A0, A1
9D01B168  01444021   ADDU T0, T2, A0
9D01B16C  0B406C42   J 0x9D01B108
9D01B170  00042823   SUBU A1, ZERO, A0
9D01B174  9386818F   LBU A2, -32369(GP)
9D01B178  24C60001   ADDIU A2, A2, 1
9D01B17C  30C600FF   ANDI A2, A2, 255
9D01B180  8388817C   LB T0, -32388(GP)
9D01B184  25080001   ADDIU T0, T0, 1
9D01B188  00C8182A   SLT V1, A2, T0
9D01B18C  10600033   BEQ V1, ZERO, .LVL179, .LBE53
9D01B190  00C01021   ADDU V0, A2, ZERO
9D01B194  3C07A000   LUI A3, -24576
9D01B198  24E71E64   ADDIU A3, A3, 7780
9D01B19C  3C0AA000   LUI T2, -24576
9D01B1A0  254A1B1C   ADDIU T2, T2, 6940
9D01B1A4  0B406C77   J 0x9D01B1DC
9D01B1A8  24E90028   ADDIU T1, A3, 40
9D01B1AC  90440000   LBU A0, 0(V0)
9D01B1B0  A044FFD8   SB A0, -40(V0)
9D01B1B4  90640000   LBU A0, 0(V1)
9D01B1B8  A064FFD8   SB A0, -40(V1)
9D01B1BC  24420001   ADDIU V0, V0, 1
9D01B1C0  1445FFFA   BNE V0, A1, 0x9D01B1AC
9D01B1C4  24630001   ADDIU V1, V1, 1
9D01B1C8  24C60001   ADDIU A2, A2, 1
9D01B1CC  30C600FF   ANDI A2, A2, 255
9D01B1D0  00C8182A   SLT V1, A2, T0
9D01B1D4  10600021   BEQ V1, ZERO, .LVL179, .LBE53
9D01B1D8  00C01021   ADDU V0, A2, ZERO
9D01B1DC  000228C0   SLL A1, V0, 3
9D01B1E0  00021140   SLL V0, V0, 5
9D01B1E4  00A22821   ADDU A1, A1, V0
9D01B1E8  00E51021   ADDU V0, A3, A1
9D01B1EC  01451821   ADDU V1, T2, A1
9D01B1F0  0B406C6B   J 0x9D01B1AC
9D01B1F4  01252821   ADDU A1, T1, A1
9D01B1F8  0F406927   JAL escseq_get_param
9D01B1FC  00002021   ADDU A0, ZERO, ZERO
9D01B200  50400007   BEQL V0, ZERO, 0x9D01B220
9D01B204  A3808184   SB ZERO, -32380(GP)
9D01B208  14500003   BNE V0, S0, 0x9D01B218
9D01B20C  00000000   NOP
9D01B210  0B406C88   J 0x9D01B220
9D01B214  A3808184   SB ZERO, -32380(GP)
9D01B218  50510001   BEQL V0, S1, 0x9D01B220
9D01B21C  A3928184   SB S2, -32380(GP)
9D01B220  8F828188   LW V0, -32376(GP)
9D01B224  1440FFF4   BNE V0, ZERO, .LBE51, .LBE50
9D01B228  00000000   NOP
9D01B22C  0B406C98   J 0x9D01B260
9D01B230  A380818C   SB ZERO, -32372(GP)
9D01B234  0F406927   JAL escseq_get_param
9D01B238  24040001   ADDIU A0, ZERO, 1
9D01B23C  00408021   ADDU S0, V0, ZERO
9D01B240  0F406927   JAL escseq_get_param
9D01B244  24040014   ADDIU A0, ZERO, 20
9D01B248  2604FFFF   ADDIU A0, S0, -1
9D01B24C  2442FFFF   ADDIU V0, V0, -1
9D01B250  7C042420   SEB A0, A0
9D01B254  0F40698C   JAL video_set_margins
9D01B258  7C022C20   SEB A1, V0
9D01B25C  A380818C   SB ZERO, -32372(GP)
9D01B260  8FBF001C   LW RA, 28(SP)
9D01B264  8FB20018   LW S2, 24(SP)
9D01B268  8FB10014   LW S1, 20(SP)
9D01B26C  8FB00010   LW S0, 16(SP)
9D01B270  03E00008   JR RA
9D01B274  27BD0020   ADDIU SP, SP, 32
531:                 	CURSOR_INVERT();
532:                 	}
533:                 
534:                 void video_setx(int8_t x)
535:                 	{
536:                 	CURSOR_INVERT();
537:                 	cx = x;
538:                 	if (cx < 0) cx = 0;
9D01A5C0  04810003   BGEZ A0, 0x9D01A5D0
9D01A5C4  A3848190   SB A0, -32368(GP)
9D01A5C8  03E00008   JR RA
9D01A5CC  A3808190   SB ZERO, -32368(GP)
539:                 	if (cx >= DISP_BUFFER_WIDE) cx = DISP_BUFFER_WIDE-1;
9D01A5D0  28840028   SLTI A0, A0, 40
9D01A5D4  14800002   BNE A0, ZERO, 0x9D01A5E0
9D01A5D8  24020027   ADDIU V0, ZERO, 39
9D01A5DC  A3828190   SB V0, -32368(GP)
9D01A5E0  03E00008   JR RA
9D01A5E4  00000000   NOP
540:                 	CURSOR_INVERT();
541:                 	}
542:                 
543:                 /* Absolute positioning does not respect top/bottom margins */
544:                 void video_gotoxy(int8_t x, int8_t y)
545:                 	{
546:                 	CURSOR_INVERT();
547:                 	cx = x;
548:                 	if (cx < 0) cx = 0;
9D01A5E8  04810003   BGEZ A0, 0x9D01A5F8
9D01A5EC  A3848190   SB A0, -32368(GP)
9D01A5F0  0B406982   J 0x9D01A608
9D01A5F4  A3808190   SB ZERO, -32368(GP)
549:                 	if (cx >= DISP_BUFFER_WIDE) cx = DISP_BUFFER_WIDE-1;
9D01A5F8  28840028   SLTI A0, A0, 40
9D01A5FC  14800002   BNE A0, ZERO, 0x9D01A608
9D01A600  24020027   ADDIU V0, ZERO, 39
9D01A604  A3828190   SB V0, -32368(GP)
550:                 	cy = y;
551:                 	if (cy < 0) cy = 0;
9D01A608  04A10003   BGEZ A1, 0x9D01A618
9D01A60C  A385818F   SB A1, -32369(GP)
9D01A610  03E00008   JR RA
9D01A614  A380818F   SB ZERO, -32369(GP)
552:                 	if (cy >= DISP_BUFFER_HIGH) cy = DISP_BUFFER_HIGH-1;
9D01A618  28A50014   SLTI A1, A1, 20
9D01A61C  14A00002   BNE A1, ZERO, 0x9D01A628
9D01A620  24020013   ADDIU V0, ZERO, 19
9D01A624  A382818F   SB V0, -32369(GP)
9D01A628  03E00008   JR RA
9D01A62C  00000000   NOP
553:                 	CURSOR_INVERT();
554:                 	}
555:                 
556:                 void video_movex(int8_t dx)
557:                 	{
558:                 	CURSOR_INVERT();
559:                 	cx += dx;
9D01A6F0  93828190   LBU V0, -32368(GP)
9D01A6F4  00822021   ADDU A0, A0, V0
9D01A6F8  7C042420   SEB A0, A0
560:                 	if (cx < 0) cx = 0;
9D01A6FC  04810003   BGEZ A0, 0x9D01A70C
9D01A700  A3848190   SB A0, -32368(GP)
9D01A704  03E00008   JR RA
9D01A708  A3808190   SB ZERO, -32368(GP)
561:                 	if (cx >= DISP_BUFFER_WIDE) cx = DISP_BUFFER_WIDE-1;
9D01A70C  28840028   SLTI A0, A0, 40
9D01A710  14800002   BNE A0, ZERO, 0x9D01A71C
9D01A714  24020027   ADDIU V0, ZERO, 39
9D01A718  A3828190   SB V0, -32368(GP)
9D01A71C  03E00008   JR RA
9D01A720  00000000   NOP
562:                 	CURSOR_INVERT();
563:                 	}
564:                 
565:                 void video_movey(int8_t dy)
566:                 	{
567:                 	CURSOR_INVERT();
568:                 	cy += dy;
9D01A724  9382818F   LBU V0, -32369(GP)
9D01A728  00822021   ADDU A0, A0, V0
9D01A72C  7C042420   SEB A0, A0
9D01A730  A384818F   SB A0, -32369(GP)
569:                 	if (cy < mtop) cy = mtop;
9D01A734  8382817D   LB V0, -32387(GP)
9D01A738  0082202A   SLT A0, A0, V0
9D01A73C  54800001   BNEL A0, ZERO, 0x9D01A744
9D01A740  A382818F   SB V0, -32369(GP)
570:                 	if (cy > mbottom) cy = mbottom;
9D01A744  8382817C   LB V0, -32388(GP)
9D01A748  8383818F   LB V1, -32369(GP)
9D01A74C  0043182A   SLT V1, V0, V1
9D01A750  54600001   BNEL V1, ZERO, 0x9D01A758
9D01A754  A382818F   SB V0, -32369(GP)
9D01A758  03E00008   JR RA
9D01A75C  00000000   NOP
571:                 	CURSOR_INVERT();
572:                 	}
573:                 
574:                 static void _video_lfwd()
575:                 	{
9D01A258  27BDFFE8   ADDIU SP, SP, -24
9D01A25C  AFBF0014   SW RA, 20(SP)
576:                 	cx = 0;
9D01A260  A3808190   SB ZERO, -32368(GP)
577:                 	if (++cy > mbottom)
9D01A264  9382818F   LBU V0, -32369(GP)
9D01A268  24420001   ADDIU V0, V0, 1
9D01A26C  7C021420   SEB V0, V0
9D01A270  A382818F   SB V0, -32369(GP)
9D01A274  8383817C   LB V1, -32388(GP)
9D01A278  0062102A   SLT V0, V1, V0
9D01A27C  10400004   BEQ V0, ZERO, 0x9D01A290
9D01A280  8FBF0014   LW RA, 20(SP)
578:                 		{
579:                 		cy = mbottom;
580:                 		_video_scrollup();
9D01A284  0F40682A   JAL .Letext0, .LFE45, .LFB27, _video_scrollup, .Ltext0
9D01A288  A383818F   SB V1, -32369(GP)
581:                 		}
582:                 	}
9D01A28C  8FBF0014   LW RA, 20(SP)
9D01A290  03E00008   JR RA
9D01A294  27BD0018   ADDIU SP, SP, 24
583:                 
584:                 static void _video_cfwd()
585:                 	{
9D01A298  27BDFFE8   ADDIU SP, SP, -24
9D01A29C  AFBF0014   SW RA, 20(SP)
586:                 	if (++cx > DISP_BUFFER_WIDE)
9D01A2A0  93828190   LBU V0, -32368(GP)
9D01A2A4  24420001   ADDIU V0, V0, 1
9D01A2A8  7C021420   SEB V0, V0
9D01A2AC  A3828190   SB V0, -32368(GP)
9D01A2B0  28420029   SLTI V0, V0, 41
9D01A2B4  14400004   BNE V0, ZERO, 0x9D01A2C8
9D01A2B8  8FBF0014   LW RA, 20(SP)
587:                 		_video_lfwd();
9D01A2BC  0F406896   JAL .LFB38, _video_lfwd, .LFE29
9D01A2C0  00000000   NOP
588:                 	}
9D01A2C4  8FBF0014   LW RA, 20(SP)
9D01A2C8  03E00008   JR RA
9D01A2CC  27BD0018   ADDIU SP, SP, 24
589:                 
590:                 void video_cfwd()
591:                 	{
9D01A760  27BDFFE8   ADDIU SP, SP, -24
9D01A764  AFBF0014   SW RA, 20(SP)
592:                 	CURSOR_INVERT();
593:                 	_video_cfwd();
9D01A768  0F4068A6   JAL .LFB39, _video_cfwd, .LFE38
9D01A76C  00000000   NOP
594:                 	CURSOR_INVERT();
595:                 	}
9D01A770  8FBF0014   LW RA, 20(SP)
9D01A774  03E00008   JR RA
9D01A778  27BD0018   ADDIU SP, SP, 24
596:                 
597:                 void video_lfwd()
598:                 	{
9D01A77C  27BDFFE8   ADDIU SP, SP, -24
9D01A780  AFBF0014   SW RA, 20(SP)
599:                 	CURSOR_INVERT();
600:                 	cx = 0;
9D01A784  A3808190   SB ZERO, -32368(GP)
601:                 	if (++cy > mbottom)
9D01A788  9382818F   LBU V0, -32369(GP)
9D01A78C  24420001   ADDIU V0, V0, 1
9D01A790  7C021420   SEB V0, V0
9D01A794  A382818F   SB V0, -32369(GP)
9D01A798  8383817C   LB V1, -32388(GP)
9D01A79C  0062102A   SLT V0, V1, V0
9D01A7A0  10400004   BEQ V0, ZERO, 0x9D01A7B4
9D01A7A4  8FBF0014   LW RA, 20(SP)
602:                 		{
603:                 		cy = mbottom;
604:                 		_video_scrollup();
9D01A7A8  0F40682A   JAL .Letext0, .LFE45, .LFB27, _video_scrollup, .Ltext0
9D01A7AC  A383818F   SB V1, -32369(GP)
605:                 		}
606:                 	CURSOR_INVERT();
607:                 	}
9D01A7B0  8FBF0014   LW RA, 20(SP)
9D01A7B4  03E00008   JR RA
9D01A7B8  27BD0018   ADDIU SP, SP, 24
608:                 
609:                 void video_lf()
610:                 	{
9D01A7BC  27BDFFE8   ADDIU SP, SP, -24
9D01A7C0  AFBF0014   SW RA, 20(SP)
611:                 	CURSOR_INVERT();
612:                 	if (++cy > mbottom)
9D01A7C4  9382818F   LBU V0, -32369(GP)
9D01A7C8  24420001   ADDIU V0, V0, 1
9D01A7CC  7C021420   SEB V0, V0
9D01A7D0  A382818F   SB V0, -32369(GP)
9D01A7D4  8383817C   LB V1, -32388(GP)
9D01A7D8  0062102A   SLT V0, V1, V0
9D01A7DC  10400004   BEQ V0, ZERO, 0x9D01A7F0
9D01A7E0  8FBF0014   LW RA, 20(SP)
613:                 		{
614:                 		cy = mbottom;
615:                 		_video_scrollup();
9D01A7E4  0F40682A   JAL .Letext0, .LFE45, .LFB27, _video_scrollup, .Ltext0
9D01A7E8  A383818F   SB V1, -32369(GP)
616:                 		}
617:                 	CURSOR_INVERT();
618:                 	}
9D01A7EC  8FBF0014   LW RA, 20(SP)
9D01A7F0  03E00008   JR RA
9D01A7F4  27BD0018   ADDIU SP, SP, 24
619:                 
620:                 static void _video_lback()
621:                 	{
622:                 	cx = DISP_BUFFER_WIDE-1;
9D01A844  A3828190   SB V0, -32368(GP)
623:                 	if (--cy < 0)
9D01A848  9382818F   LBU V0, -32369(GP)
624:                 		{
625:                 		cx = 0;
9D01A85C  A3808190   SB ZERO, -32368(GP)
626:                 		cy = mtop;
9D01A860  9382817D   LBU V0, -32387(GP)
9D01A864  A382818F   SB V0, -32369(GP)
9D01A868  03E00008   JR RA
9D01A86C  00000000   NOP
627:                 		}
628:                 	}
629:                 
630:                 void video_lback()
631:                 	{
632:                 	CURSOR_INVERT();
633:                 	cx = DISP_BUFFER_WIDE-1;
9D01A7F8  24020027   ADDIU V0, ZERO, 39
9D01A7FC  A3828190   SB V0, -32368(GP)
634:                 	if (--cy < 0)
9D01A800  9382818F   LBU V0, -32369(GP)
9D01A804  2442FFFF   ADDIU V0, V0, -1
9D01A808  7C021420   SEB V0, V0
9D01A80C  04410004   BGEZ V0, 0x9D01A820
9D01A810  A382818F   SB V0, -32369(GP)
635:                 		{
636:                 		cx = 0;
9D01A814  A3808190   SB ZERO, -32368(GP)
637:                 		cy = mtop;
9D01A818  9382817D   LBU V0, -32387(GP)
9D01A81C  A382818F   SB V0, -32369(GP)
9D01A820  03E00008   JR RA
9D01A824  00000000   NOP
638:                 		}
639:                 	CURSOR_INVERT();
640:                 	}
641:                 
642:                 void video_cback()
643:                 	{
644:                 	CURSOR_INVERT();
645:                 	if (--cx < 0)
9D01A828  93828190   LBU V0, -32368(GP)
9D01A82C  2442FFFF   ADDIU V0, V0, -1
9D01A830  7C021420   SEB V0, V0
9D01A834  04420003   BLTZL V0, .LBB9
9D01A838  24020027   ADDIU V0, ZERO, 39
9D01A83C  03E00008   JR RA
9D01A840  A3828190   SB V0, -32368(GP)
9D01A844  A3828190   SB V0, -32368(GP)
9D01A848  9382818F   LBU V0, -32369(GP)
9D01A84C  2442FFFF   ADDIU V0, V0, -1
9D01A850  7C021420   SEB V0, V0
9D01A854  04410004   BGEZ V0, 0x9D01A868
9D01A858  A382818F   SB V0, -32369(GP)
9D01A85C  A3808190   SB ZERO, -32368(GP)
9D01A860  9382817D   LBU V0, -32387(GP)
9D01A864  A382818F   SB V0, -32369(GP)
9D01A868  03E00008   JR RA
9D01A86C  00000000   NOP
646:                 		_video_lback();
647:                 	CURSOR_INVERT();
648:                 	}
649:                 
650:                 int8_t video_getx()
651:                 	{
652:                 	return cx;
653:                 	}
9D01A870  03E00008   JR RA
9D01A874  83828190   LB V0, -32368(GP)
654:                 
655:                 int8_t video_gety(void)
656:                 	{
657:                 	return cy;
658:                 	}
9D01A878  03E00008   JR RA
9D01A87C  8382818F   LB V0, -32369(GP)
659:                 
660:                 int8_t video_charat(int8_t x, int8_t y)
661:                 	{
662:                 	return disp_buffer[cy][cx];
9D01A880  8382818F   LB V0, -32369(GP)
9D01A884  83838190   LB V1, -32368(GP)
9D01A888  000220C0   SLL A0, V0, 3
9D01A88C  00021140   SLL V0, V0, 5
9D01A890  00821021   ADDU V0, A0, V0
9D01A894  00431021   ADDU V0, V0, V1
9D01A898  3C03A000   LUI V1, -24576
9D01A89C  24631E64   ADDIU V1, V1, 7780
9D01A8A0  00431021   ADDU V0, V0, V1
663:                 	}
9D01A8A4  03E00008   JR RA
9D01A8A8  80420000   LB V0, 0(V0)
664:                 
665:                 void video_clrscr()
666:                 	{
9D01A8AC  27BDFFE8   ADDIU SP, SP, -24
9D01A8B0  AFBF0014   SW RA, 20(SP)
667:                 	CURSOR_INVERT();
668:                 	video_reset_margins();
9D01A8B4  0F4069A1   JAL video_reset_margins
9D01A8B8  00000000   NOP
669:                 	memset(disp_buffer, revvideo, DISP_BUFFER_WIDE*DISP_BUFFER_HIGH);
9D01A8BC  3C04A000   LUI A0, -24576
9D01A8C0  24841E64   ADDIU A0, A0, 7780
9D01A8C4  93858184   LBU A1, -32380(GP)
9D01A8C8  0F40E7C9   JAL .Letext0, .LFE0, memset
9D01A8CC  24060320   ADDIU A2, ZERO, 800
670:                 	memset(color_buffer, 0, DISP_BUFFER_WIDE*DISP_BUFFER_HIGH);
9D01A8D0  3C04A000   LUI A0, -24576
9D01A8D4  24841B1C   ADDIU A0, A0, 6940
9D01A8D8  00002821   ADDU A1, ZERO, ZERO
9D01A8DC  0F40E7C9   JAL .Letext0, .LFE0, memset
9D01A8E0  24060320   ADDIU A2, ZERO, 800
671:                 	cx = cy = 0;
9D01A8E4  A380818F   SB ZERO, -32369(GP)
9D01A8E8  A3808190   SB ZERO, -32368(GP)
672:                 	CURSOR_INVERT();
673:                 	}
9D01A8EC  8FBF0014   LW RA, 20(SP)
9D01A8F0  03E00008   JR RA
9D01A8F4  27BD0018   ADDIU SP, SP, 24
674:                 
675:                 void video_clrline()
676:                 	{
9D01AAEC  27BDFFE8   ADDIU SP, SP, -24
9D01AAF0  AFBF0014   SW RA, 20(SP)
9D01AAF4  AFB00010   SW S0, 16(SP)
677:                 	CURSOR_INVERT();
678:                 	memset(&disp_buffer[cy], revvideo, DISP_BUFFER_WIDE);
9D01AAF8  8382818F   LB V0, -32369(GP)
9D01AAFC  000280C0   SLL S0, V0, 3
9D01AB00  00021140   SLL V0, V0, 5
9D01AB04  02028021   ADDU S0, S0, V0
9D01AB08  3C04A000   LUI A0, -24576
9D01AB0C  24841E64   ADDIU A0, A0, 7780
9D01AB10  00902021   ADDU A0, A0, S0
9D01AB14  93858184   LBU A1, -32380(GP)
9D01AB18  0F40E7C9   JAL .Letext0, .LFE0, memset
9D01AB1C  24060028   ADDIU A2, ZERO, 40
679:                 	memset(&color_buffer[cy], 0, DISP_BUFFER_WIDE);
9D01AB20  3C04A000   LUI A0, -24576
9D01AB24  24841B1C   ADDIU A0, A0, 6940
9D01AB28  00902021   ADDU A0, A0, S0
9D01AB2C  00002821   ADDU A1, ZERO, ZERO
9D01AB30  0F40E7C9   JAL .Letext0, .LFE0, memset
9D01AB34  24060028   ADDIU A2, ZERO, 40
680:                 	cx = 0;
9D01AB38  A3808190   SB ZERO, -32368(GP)
681:                 	CURSOR_INVERT();
682:                 	}
9D01AB3C  8FBF0014   LW RA, 20(SP)
9D01AB40  8FB00010   LW S0, 16(SP)
9D01AB44  03E00008   JR RA
9D01AB48  27BD0018   ADDIU SP, SP, 24
683:                 
684:                 void video_clreol()
685:                 	{
9D01AB4C  27BDFFE0   ADDIU SP, SP, -32
9D01AB50  AFBF001C   SW RA, 28(SP)
9D01AB54  AFB10018   SW S1, 24(SP)
9D01AB58  AFB00014   SW S0, 20(SP)
686:                 	memset(&disp_buffer[cy][cx], revvideo, DISP_BUFFER_WIDE-cx);
9D01AB5C  8383818F   LB V1, -32369(GP)
9D01AB60  83828190   LB V0, -32368(GP)
9D01AB64  24100028   ADDIU S0, ZERO, 40
9D01AB68  02028023   SUBU S0, S0, V0
9D01AB6C  000388C0   SLL S1, V1, 3
9D01AB70  00031940   SLL V1, V1, 5
9D01AB74  02238821   ADDU S1, S1, V1
9D01AB78  02228821   ADDU S1, S1, V0
9D01AB7C  3C04A000   LUI A0, -24576
9D01AB80  24841E64   ADDIU A0, A0, 7780
9D01AB84  00912021   ADDU A0, A0, S1
9D01AB88  93858184   LBU A1, -32380(GP)
9D01AB8C  0F40E7C9   JAL .Letext0, .LFE0, memset
9D01AB90  02003021   ADDU A2, S0, ZERO
687:                 	memset(&color_buffer[cy][cx], 0, DISP_BUFFER_WIDE-cx);
9D01AB94  3C04A000   LUI A0, -24576
9D01AB98  24841B1C   ADDIU A0, A0, 6940
9D01AB9C  00912021   ADDU A0, A0, S1
9D01ABA0  00002821   ADDU A1, ZERO, ZERO
9D01ABA4  0F40E7C9   JAL .Letext0, .LFE0, memset
9D01ABA8  02003021   ADDU A2, S0, ZERO
688:                 	}
9D01ABAC  8FBF001C   LW RA, 28(SP)
9D01ABB0  8FB10018   LW S1, 24(SP)
9D01ABB4  8FB00014   LW S0, 20(SP)
9D01ABB8  03E00008   JR RA
9D01ABBC  27BD0020   ADDIU SP, SP, 32
689:                 
690:                 void video_erase(uint8_t erasemode)
691:                 	{
692:                 	uint8_t x,y;
693:                 	CURSOR_INVERT();
694:                 	switch(erasemode)
9D01ABC0  24020001   ADDIU V0, ZERO, 1
9D01ABC4  1082000C   BEQ A0, V0, 0x9D01ABF8
9D01ABC8  838C8190   LB T4, -32368(GP)
9D01ABCC  10800015   BEQ A0, ZERO, 0x9D01AC24
9D01ABD0  24020002   ADDIU V0, ZERO, 2
9D01ABD4  14820031   BNE A0, V0, 0x9D01AC9C
9D01ABD8  3C05A000   LUI A1, -24576
9D01ABDC  24A51E64   ADDIU A1, A1, 7780
9D01ABE0  3C06A000   LUI A2, -24576
9D01ABE4  24C61B1C   ADDIU A2, A2, 6940
9D01ABE8  24A80028   ADDIU T0, A1, 40
695:                 		{
696:                 		case 0: /* erase from cursor to end of screen */
697:                 //jar
698:                 //      memset(&disp_buffer[cy][cx], revvideo,
699:                 //          (DISP_BUFFER_WIDE*DISP_BUFFER_HIGH)-(cy*DISP_BUFFER_WIDE+cx));
700:                 			for (x=cx; x<DISP_BUFFER_WIDE; x++)
9D01AC24  93858190   LBU A1, -32368(GP)
9D01AC28  2CA20028   SLTIU V0, A1, 40
9D01AC2C  1040001B   BEQ V0, ZERO, 0x9D01AC9C
9D01AC30  938C818F   LBU T4, -32369(GP)
9D01AC50  240A0028   ADDIU T2, ZERO, 40
9D01AC8C  24A50001   ADDIU A1, A1, 1
9D01AC90  30A500FF   ANDI A1, A1, 255
9D01AC94  14AAFFEF   BNE A1, T2, 0x9D01AC54
9D01AC98  00000000   NOP
9D01AC9C  03E00008   JR RA
9D01ACA0  00000000   NOP
701:                 				for (y=cy; y<DISP_BUFFER_HIGH; y++)
9D01AC34  2D8B0014   SLTIU T3, T4, 20
9D01AC4C  24060014   ADDIU A2, ZERO, 20
9D01AC54  5160000E   BEQL T3, ZERO, 0x9D01AC90
9D01AC58  24A50001   ADDIU A1, A1, 1
9D01AC5C  01801021   ADDU V0, T4, ZERO
9D01AC7C  24420001   ADDIU V0, V0, 1
9D01AC80  304200FF   ANDI V0, V0, 255
9D01AC84  1446FFF6   BNE V0, A2, 0x9D01AC60
9D01AC88  A0600000   SB ZERO, 0(V1)
702:                 					{
703:                 					disp_buffer[y][x] = ' ';
9D01AC38  3C09A000   LUI T1, -24576
9D01AC3C  25291E64   ADDIU T1, T1, 7780
9D01AC40  24080020   ADDIU T0, ZERO, 32
9D01AC60  000220C0   SLL A0, V0, 3
9D01AC64  00021940   SLL V1, V0, 5
9D01AC68  00831821   ADDU V1, A0, V1
9D01AC6C  00651821   ADDU V1, V1, A1
9D01AC70  00692021   ADDU A0, V1, T1
9D01AC74  A0880000   SB T0, 0(A0)
704:                 					color_buffer[y][x] = 0;
9D01AC44  3C07A000   LUI A3, -24576
9D01AC48  24E71B1C   ADDIU A3, A3, 6940
9D01AC78  00671821   ADDU V1, V1, A3
705:                 					}
706:                 			break;
707:                 		case 1: /* erase from beginning of screen to cursor */
708:                 //jar
709:                 //      memset(disp_buffer, revvideo, cy*DISP_BUFFER_WIDE+cx+1);
710:                 			for (x=0; x<cx; x++)
9D01ABF8  19800028   BLEZ T4, 0x9D01AC9C
9D01ABFC  838B818F   LB T3, -32369(GP)
9D01AC04  00002821   ADDU A1, ZERO, ZERO
9D01AC08  00005021   ADDU T2, ZERO, ZERO
9D01ACD8  254A0001   ADDIU T2, T2, 1
9D01ACDC  314A00FF   ANDI T2, T2, 255
9D01ACE0  014C102A   SLT V0, T2, T4
9D01ACE4  1040FFED   BEQ V0, ZERO, 0x9D01AC9C
9D01ACE8  01402821   ADDU A1, T2, ZERO
9D01AD20  0B406B3F   J 0x9D01ACFC
9D01AD24  00001021   ADDU V0, ZERO, ZERO
711:                 				for (y=0; y<cy; y++)
9D01AC00  01604821   ADDU T1, T3, ZERO
9D01ACC4  24420001   ADDIU V0, V0, 1
9D01ACC8  304200FF   ANDI V0, V0, 255
9D01ACCC  0049202A   SLT A0, V0, T1
9D01ACD0  1480FFF4   BNE A0, ZERO, 0x9D01ACA4
9D01ACD4  00401821   ADDU V1, V0, ZERO
9D01ACEC  1960FFFA   BLEZ T3, 0x9D01ACD8
9D01ACF0  00001021   ADDU V0, ZERO, ZERO
9D01ACF4  0B406B29   J 0x9D01ACA4
9D01ACF8  00001821   ADDU V1, ZERO, ZERO
9D01ACFC  00A22021   ADDU A0, A1, V0
712:                 					{
713:                 					disp_buffer[y][x] = ' ';
9D01AC0C  3C08A000   LUI T0, -24576
9D01AC10  25081E64   ADDIU T0, T0, 7780
9D01AC14  24070020   ADDIU A3, ZERO, 32
9D01ACA4  000320C0   SLL A0, V1, 3
9D01ACA8  00031940   SLL V1, V1, 5
9D01ACAC  00831821   ADDU V1, A0, V1
9D01ACB0  00651821   ADDU V1, V1, A1
9D01ACB4  00682021   ADDU A0, V1, T0
9D01ACB8  A0870000   SB A3, 0(A0)
714:                 					color_buffer[y][x] = 0;
9D01AC18  3C06A000   LUI A2, -24576
9D01AC1C  0B406B3B   J 0x9D01ACEC
9D01AC20  24C61B1C   ADDIU A2, A2, 6940
9D01ACBC  00661821   ADDU V1, V1, A2
9D01ACC0  A0600000   SB ZERO, 0(V1)
715:                 					}
716:                 			break;
717:                 		case 2: /* erase entire screen */
718:                 //jar
719:                 //      memset(disp_buffer, revvideo, DISP_BUFFER_WIDE*DISP_BUFFER_HIGH);
720:                 			for (x=0; x<DISP_BUFFER_WIDE; x++)
9D01AD18  10A8FFE0   BEQ A1, T0, 0x9D01AC9C
9D01AD1C  24C60001   ADDIU A2, A2, 1
721:                 				for (y=0; y<DISP_BUFFER_HIGH; y++)
9D01ABF0  0B406B48   J 0x9D01AD20
9D01ABF4  24070320   ADDIU A3, ZERO, 800
9D01AD0C  1447FFFB   BNE V0, A3, 0x9D01ACFC
9D01AD10  A0830000   SB V1, 0(A0)
9D01AD14  24A50001   ADDIU A1, A1, 1
722:                 					{
723:                 					disp_buffer[y][x] = ' ';
9D01ABEC  24030020   ADDIU V1, ZERO, 32
9D01AD00  A0830000   SB V1, 0(A0)
9D01AD04  00C22021   ADDU A0, A2, V0
9D01AD08  24420028   ADDIU V0, V0, 40
9D01AD0C  1447FFFB   BNE V0, A3, 0x9D01ACFC
9D01AD10  A0830000   SB V1, 0(A0)
9D01AD14  24A50001   ADDIU A1, A1, 1
9D01AD18  10A8FFE0   BEQ A1, T0, 0x9D01AC9C
9D01AD1C  24C60001   ADDIU A2, A2, 1
9D01AD20  0B406B3F   J 0x9D01ACFC
9D01AD24  00001021   ADDU V0, ZERO, ZERO
724:                 					color_buffer[y][x] = ' ';
725:                 					}
726:                 			break;
727:                 		}
728:                 	CURSOR_INVERT();
729:                 	}
730:                 
731:                 void video_eraseline(uint8_t erasemode)
732:                 	{
733:                 	uint8_t y,x;
734:                 	CURSOR_INVERT();
735:                 	switch(erasemode)
9D01AD28  24020001   ADDIU V0, ZERO, 1
9D01AD2C  10820007   BEQ A0, V0, 0x9D01AD4C
9D01AD30  83898190   LB T1, -32368(GP)
9D01AD34  10800009   BEQ A0, ZERO, 0x9D01AD5C
9D01AD38  24020002   ADDIU V0, ZERO, 2
9D01AD3C  10820034   BEQ A0, V0, 0x9D01AE10
9D01AD40  8383818F   LB V1, -32369(GP)
9D01AD44  03E00008   JR RA
9D01AD48  00000000   NOP
736:                 		{
737:                 		case 0: /* erase from cursor to end of line */
738:                 //jar
739:                 			for (x=cx; x<DISP_BUFFER_WIDE; x++)
9D01AD5C  93828190   LBU V0, -32368(GP)
9D01AD60  2C430028   SLTIU V1, V0, 40
9D01AD64  1060FFF7   BEQ V1, ZERO, 0x9D01AD44
9D01AD68  8383818F   LB V1, -32369(GP)
9D01AD8C  24050028   ADDIU A1, ZERO, 40
9D01ADA0  24420001   ADDIU V0, V0, 1
9D01ADA4  304200FF   ANDI V0, V0, 255
9D01ADA8  1445FFF9   BNE V0, A1, 0x9D01AD90
9D01ADAC  A0600000   SB ZERO, 0(V1)
9D01ADB0  03E00008   JR RA
9D01ADB4  00000000   NOP
740:                 				{
741:                 				disp_buffer[cy][x] = ' ';
9D01AD6C  000348C0   SLL T1, V1, 3
9D01AD70  00031940   SLL V1, V1, 5
9D01AD74  01234821   ADDU T1, T1, V1
9D01AD78  3C08A000   LUI T0, -24576
9D01AD7C  25081E64   ADDIU T0, T0, 7780
9D01AD80  24070020   ADDIU A3, ZERO, 32
9D01AD90  01221821   ADDU V1, T1, V0
9D01AD94  00682021   ADDU A0, V1, T0
9D01AD98  A0870000   SB A3, 0(A0)
742:                 				color_buffer[cy][x] = 0;
9D01AD84  3C06A000   LUI A2, -24576
9D01AD88  24C61B1C   ADDIU A2, A2, 6940
9D01AD9C  00661821   ADDU V1, V1, A2
743:                 				}
744:                 //      memset(&disp_buffer[cy][cx], revvideo, DISP_BUFFER_WIDE-cx);
745:                 			break;
746:                 		case 1: /* erase from beginning of line to cursor */
747:                 //jar
748:                 			for (x=0; x<cx; x++)
9D01AD4C  1D20001A   BGTZ T1, 0x9D01ADB8
9D01AD50  8384818F   LB A0, -32369(GP)
9D01AD54  03E00008   JR RA
9D01AD58  00000000   NOP
9D01ADB8  00001821   ADDU V1, ZERO, ZERO
9D01ADBC  00001021   ADDU V0, ZERO, ZERO
9D01ADF4  24420001   ADDIU V0, V0, 1
9D01ADF8  304200FF   ANDI V0, V0, 255
9D01ADFC  0049202A   SLT A0, V0, T1
9D01AE00  1480FFF7   BNE A0, ZERO, 0x9D01ADE0
9D01AE04  00401821   ADDU V1, V0, ZERO
9D01AE08  03E00008   JR RA
9D01AE0C  00000000   NOP
9D01AE10  000310C0   SLL V0, V1, 3
9D01AE14  00031940   SLL V1, V1, 5
9D01AE18  00431021   ADDU V0, V0, V1
9D01AE1C  3C07A000   LUI A3, -24576
9D01AE20  24E71E64   ADDIU A3, A3, 7780
9D01AE24  00E23821   ADDU A3, A3, V0
9D01AE28  3C06A000   LUI A2, -24576
9D01AE2C  24C61B1C   ADDIU A2, A2, 6940
9D01AE30  00C23021   ADDU A2, A2, V0
749:                 				{
750:                 				disp_buffer[cy][x] = ' ';
9D01ADC0  000440C0   SLL T0, A0, 3
9D01ADC4  00042140   SLL A0, A0, 5
9D01ADC8  01044021   ADDU T0, T0, A0
9D01ADCC  3C07A000   LUI A3, -24576
9D01ADD0  24E71E64   ADDIU A3, A3, 7780
9D01ADD4  24060020   ADDIU A2, ZERO, 32
9D01ADE0  01031821   ADDU V1, T0, V1
9D01ADE4  00672021   ADDU A0, V1, A3
9D01ADE8  A0860000   SB A2, 0(A0)
751:                 				color_buffer[cy][x] = 0;
9D01ADD8  3C05A000   LUI A1, -24576
9D01ADDC  24A51B1C   ADDIU A1, A1, 6940
9D01ADEC  00651821   ADDU V1, V1, A1
9D01ADF0  A0600000   SB ZERO, 0(V1)
752:                 				}
753:                 
754:                 //      memset(&disp_buffer[cy], revvideo, cx+1);
755:                 			break;
756:                 		case 2: /* erase entire line */
757:                 //jar
758:                 			for (x=0; x<DISP_BUFFER_WIDE; x++)
9D01AE3C  24040028   ADDIU A0, ZERO, 40
9D01AE40  00E21821   ADDU V1, A3, V0
9D01AE50  1444FFFB   BNE V0, A0, 0x9D01AE40
9D01AE54  A0600000   SB ZERO, 0(V1)
9D01AE58  03E00008   JR RA
9D01AE5C  00000000   NOP
759:                 				{
760:                 				disp_buffer[cy][x] = ' ';
9D01AE34  00001021   ADDU V0, ZERO, ZERO
9D01AE38  24050020   ADDIU A1, ZERO, 32
9D01AE44  A0650000   SB A1, 0(V1)
9D01AE48  00C21821   ADDU V1, A2, V0
9D01AE4C  24420001   ADDIU V0, V0, 1
9D01AE50  1444FFFB   BNE V0, A0, 0x9D01AE40
9D01AE54  A0600000   SB ZERO, 0(V1)
9D01AE58  03E00008   JR RA
9D01AE5C  00000000   NOP
761:                 				color_buffer[cy][x] = 0;
762:                 				}
763:                 
764:                 //      memset(&disp_buffer[cy], revvideo, DISP_BUFFER_WIDE);
765:                 			break;
766:                 		}
767:                 	CURSOR_INVERT();
768:                 	}
769:                 
770:                 /* Does not respect top/bottom margins */
771:                 void video_putcxy(int8_t x, int8_t y, int8_t c)
772:                 	{
773:                 	if (x < 0 || x >= DISP_BUFFER_WIDE) return;
9D01B2E8  308200FF   ANDI V0, A0, 255
9D01B2EC  2C420028   SLTIU V0, V0, 40
9D01B2F0  10400012   BEQ V0, ZERO, 0x9D01B33C
9D01B2F4  30A200FF   ANDI V0, A1, 255
774:                 	if (y < 0 || y >= DISP_BUFFER_HIGH) return;
9D01B2F8  2C420014   SLTIU V0, V0, 20
9D01B2FC  1040000F   BEQ V0, ZERO, 0x9D01B33C
9D01B300  000510C0   SLL V0, A1, 3
775:                 	disp_buffer[y][x] = c ^ revvideo;
9D01B304  00052940   SLL A1, A1, 5
9D01B308  00452821   ADDU A1, V0, A1
9D01B30C  00A42021   ADDU A0, A1, A0
9D01B310  3C02A000   LUI V0, -24576
9D01B314  24421E64   ADDIU V0, V0, 7780
9D01B318  00821021   ADDU V0, A0, V0
9D01B31C  93838184   LBU V1, -32380(GP)
9D01B320  00C33026   XOR A2, A2, V1
9D01B324  A0460000   SB A2, 0(V0)
776:                 	color_buffer[y][x] = color_composite;
9D01B328  3C02A000   LUI V0, -24576
9D01B32C  24421B1C   ADDIU V0, V0, 6940
9D01B330  00822021   ADDU A0, A0, V0
9D01B334  938281C9   LBU V0, -32311(GP)
9D01B338  A0820000   SB V0, 0(A0)
9D01B33C  03E00008   JR RA
9D01B340  00000000   NOP
777:                 	}
778:                 
779:                 /* Does not respect top/bottom margins */
780:                 void video_putsxy(int8_t x, int8_t y, int8_t *str)
781:                 	{
9D01B60C  27BDFFD8   ADDIU SP, SP, -40
9D01B610  AFBF0024   SW RA, 36(SP)
9D01B614  AFB40020   SW S4, 32(SP)
9D01B618  AFB3001C   SW S3, 28(SP)
9D01B61C  AFB20018   SW S2, 24(SP)
9D01B620  AFB10014   SW S1, 20(SP)
9D01B624  AFB00010   SW S0, 16(SP)
782:                 	int16_t len;
783:                 	if (x < 0 || x >= DISP_BUFFER_WIDE) return;
9D01B628  308200FF   ANDI V0, A0, 255
9D01B62C  2C420028   SLTIU V0, V0, 40
9D01B630  10400026   BEQ V0, ZERO, .LVL232
9D01B634  00808021   ADDU S0, A0, ZERO
784:                 	if (y < 0 || y >= DISP_BUFFER_HIGH) return;
9D01B638  30A200FF   ANDI V0, A1, 255
9D01B63C  2C420014   SLTIU V0, V0, 20
9D01B640  10400022   BEQ V0, ZERO, .LVL232
9D01B644  00A08821   ADDU S1, A1, ZERO
9D01B648  00C09821   ADDU S3, A2, ZERO
785:                 	len = strlen(str);
9D01B64C  0F40D9CB   JAL strlen
9D01B650  00C02021   ADDU A0, A2, ZERO
9D01B654  7C029620   SEH S2, V0
786:                 	if (len > DISP_BUFFER_WIDE-x) len = DISP_BUFFER_WIDE-x;
9D01B658  24020028   ADDIU V0, ZERO, 40
9D01B65C  00501023   SUBU V0, V0, S0
9D01B660  0052102A   SLT V0, V0, S2
9D01B664  10400003   BEQ V0, ZERO, 0x9D01B674
9D01B668  0011A0C0   SLL S4, S1, 3
9D01B66C  24120028   ADDIU S2, ZERO, 40
9D01B670  02509023   SUBU S2, S2, S0
787:                 	memcpy((int8_t *)(&disp_buffer[y][x]), str, len);
9D01B674  00111140   SLL V0, S1, 5
9D01B678  0282A021   ADDU S4, S4, V0
9D01B67C  0290A021   ADDU S4, S4, S0
9D01B680  3C04A000   LUI A0, -24576
9D01B684  24841E64   ADDIU A0, A0, 7780
9D01B688  00942021   ADDU A0, A0, S4
9D01B68C  02602821   ADDU A1, S3, ZERO
9D01B690  0F40D971   JAL .Letext0, .LFE1, memcpy
9D01B694  02403021   ADDU A2, S2, ZERO
788:                 	memset((int8_t *)(&color_buffer[y][x]), color_composite, len);
9D01B698  3C04A000   LUI A0, -24576
9D01B69C  24841B1C   ADDIU A0, A0, 6940
9D01B6A0  00942021   ADDU A0, A0, S4
9D01B6A4  938581C9   LBU A1, -32311(GP)
9D01B6A8  0F40E7C9   JAL .Letext0, .LFE0, memset
9D01B6AC  02403021   ADDU A2, S2, ZERO
789:                 	if (revvideo) video_invert_range(x, y, len);
9D01B6B0  93828184   LBU V0, -32380(GP)
9D01B6B4  10400006   BEQ V0, ZERO, 0x9D01B6D0
9D01B6B8  8FBF0024   LW RA, 36(SP)
9D01B6BC  02002021   ADDU A0, S0, ZERO
9D01B6C0  02202821   ADDU A1, S1, ZERO
9D01B6C4  0F406D6E   JAL video_invert_range
9D01B6C8  324600FF   ANDI A2, S2, 255
790:                 	}
9D01B6CC  8FBF0024   LW RA, 36(SP)
9D01B6D0  8FB40020   LW S4, 32(SP)
9D01B6D4  8FB3001C   LW S3, 28(SP)
9D01B6D8  8FB20018   LW S2, 24(SP)
9D01B6DC  8FB10014   LW S1, 20(SP)
9D01B6E0  8FB00010   LW S0, 16(SP)
9D01B6E4  03E00008   JR RA
9D01B6E8  27BD0028   ADDIU SP, SP, 40
791:                 
792:                 
793:                 /* Does not respect top/bottom margins */
794:                 void video_putline(int8_t y, int8_t *str)
795:                 	{
9D01B6EC  27BDFFE0   ADDIU SP, SP, -32
9D01B6F0  AFBF001C   SW RA, 28(SP)
9D01B6F4  AFB20018   SW S2, 24(SP)
9D01B6F8  AFB10014   SW S1, 20(SP)
9D01B6FC  AFB00010   SW S0, 16(SP)
796:                 	if (y < 0 || y >= DISP_BUFFER_HIGH) return;
9D01B700  308200FF   ANDI V0, A0, 255
9D01B704  2C420014   SLTIU V0, V0, 20
9D01B708  10400019   BEQ V0, ZERO, .LVL238
9D01B70C  00808021   ADDU S0, A0, ZERO
9D01B710  00A08821   ADDU S1, A1, ZERO
797:                 	/* strncpy fills unused bytes in the destination with nulls */
798:                 	strncpy((int8_t *)(&disp_buffer[y]), str, DISP_BUFFER_WIDE);
9D01B714  000490C0   SLL S2, A0, 3
9D01B718  00041140   SLL V0, A0, 5
9D01B71C  02429021   ADDU S2, S2, V0
9D01B720  3C04A000   LUI A0, -24576
9D01B724  24841E64   ADDIU A0, A0, 7780
9D01B728  00922021   ADDU A0, A0, S2
9D01B72C  0F40E164   JAL .LFE23, strncpy
9D01B730  24060028   ADDIU A2, ZERO, 40
799:                 	memset((int8_t *)(&color_buffer[y]), color_composite, strlen(str));
9D01B734  0F40D9CB   JAL strlen
9D01B738  02202021   ADDU A0, S1, ZERO
9D01B73C  3C04A000   LUI A0, -24576
9D01B740  24841B1C   ADDIU A0, A0, 6940
9D01B744  00922021   ADDU A0, A0, S2
9D01B748  938581C9   LBU A1, -32311(GP)
9D01B74C  0F40E7C9   JAL .Letext0, .LFE0, memset
9D01B750  00403021   ADDU A2, V0, ZERO
800:                 	if (revvideo) video_invert_range(0, y, DISP_BUFFER_WIDE);
9D01B754  93828184   LBU V0, -32380(GP)
9D01B758  10400006   BEQ V0, ZERO, 0x9D01B774
9D01B75C  8FBF001C   LW RA, 28(SP)
9D01B760  00002021   ADDU A0, ZERO, ZERO
9D01B764  02002821   ADDU A1, S0, ZERO
9D01B768  0F406D6E   JAL video_invert_range
9D01B76C  24060028   ADDIU A2, ZERO, 40
801:                 	}
9D01B770  8FBF001C   LW RA, 28(SP)
9D01B774  8FB20018   LW S2, 24(SP)
9D01B778  8FB10014   LW S1, 20(SP)
9D01B77C  8FB00010   LW S0, 16(SP)
9D01B780  03E00008   JR RA
9D01B784  27BD0020   ADDIU SP, SP, 32
802:                 
803:                 void video_setc(int8_t c)
804:                 	{
805:                 	CURSOR_INVERT();
806:                 	disp_buffer[cy][cx] = c ^ revvideo;
9D01B344  8383818F   LB V1, -32369(GP)
9D01B348  83858190   LB A1, -32368(GP)
9D01B34C  000310C0   SLL V0, V1, 3
9D01B350  00031940   SLL V1, V1, 5
9D01B354  00431021   ADDU V0, V0, V1
9D01B358  00451021   ADDU V0, V0, A1
9D01B35C  3C03A000   LUI V1, -24576
9D01B360  24631E64   ADDIU V1, V1, 7780
9D01B364  00431821   ADDU V1, V0, V1
9D01B368  93858184   LBU A1, -32380(GP)
9D01B36C  00852026   XOR A0, A0, A1
9D01B370  A0640000   SB A0, 0(V1)
807:                 	color_buffer[cy][cx] = color_composite;
9D01B374  3C03A000   LUI V1, -24576
9D01B378  24631B1C   ADDIU V1, V1, 6940
9D01B37C  00431021   ADDU V0, V0, V1
9D01B380  938381C9   LBU V1, -32311(GP)
9D01B384  03E00008   JR RA
9D01B388  A0430000   SB V1, 0(V0)
808:                 	CURSOR_INVERT();
809:                 	}
810:                 
811:                 static void _video_putc(int8_t c)
812:                 	{
9D01A2D0  27BDFFE8   ADDIU SP, SP, -24
9D01A2D4  AFBF0014   SW RA, 20(SP)
9D01A2D8  AFB00010   SW S0, 16(SP)
813:                 	/* If the last character printed exceeded the right boundary,
814:                 	 * we have to go to a new line. */
815:                 	if (cx >= DISP_BUFFER_WIDE) _video_lfwd();
9D01A2DC  83828190   LB V0, -32368(GP)
9D01A2E0  28420028   SLTI V0, V0, 40
9D01A2E4  14400003   BNE V0, ZERO, .LVL23
9D01A2E8  00808021   ADDU S0, A0, ZERO
9D01A2EC  0F406896   JAL .LFB38, _video_lfwd, .LFE29
9D01A2F0  00000000   NOP
816:                 
817:                 	if (c == '\r') cx = 0;
9D01A2F4  2402000D   ADDIU V0, ZERO, 13
9D01A2F8  16020003   BNE S0, V0, 0x9D01A308
9D01A2FC  2402000A   ADDIU V0, ZERO, 10
9D01A300  0B4068D9   J .LVL25
9D01A304  A3808190   SB ZERO, -32368(GP)
818:                 	else if (c == '\n') _video_lfwd();
9D01A308  16020005   BNE S0, V0, 0x9D01A320
9D01A30C  8383818F   LB V1, -32369(GP)
9D01A310  0F406896   JAL .LFB38, _video_lfwd, .LFE29
9D01A314  00000000   NOP
9D01A318  0B4068DA   J 0x9D01A368
9D01A31C  8FBF0014   LW RA, 20(SP)
819:                 	else
820:                 		{
821:                 		disp_buffer[cy][cx] = c ^ revvideo;
9D01A320  83848190   LB A0, -32368(GP)
9D01A324  000310C0   SLL V0, V1, 3
9D01A328  00031940   SLL V1, V1, 5
9D01A32C  00431021   ADDU V0, V0, V1
9D01A330  00441021   ADDU V0, V0, A0
9D01A334  3C03A000   LUI V1, -24576
9D01A338  24631E64   ADDIU V1, V1, 7780
9D01A33C  00431821   ADDU V1, V0, V1
9D01A340  93848184   LBU A0, -32380(GP)
9D01A344  02048026   XOR S0, S0, A0
9D01A348  A0700000   SB S0, 0(V1)
822:                 		color_buffer[cy][cx] = color_composite;
9D01A34C  3C03A000   LUI V1, -24576
9D01A350  24631B1C   ADDIU V1, V1, 6940
9D01A354  00431021   ADDU V0, V0, V1
9D01A358  938381C9   LBU V1, -32311(GP)
823:                 		_video_cfwd();
9D01A35C  0F4068A6   JAL .LFB39, _video_cfwd, .LFE38
9D01A360  A0430000   SB V1, 0(V0)
824:                 		}
825:                 	}
9D01A364  8FBF0014   LW RA, 20(SP)
9D01A368  8FB00010   LW S0, 16(SP)
9D01A36C  03E00008   JR RA
9D01A370  27BD0018   ADDIU SP, SP, 24
826:                 
827:                 void video_putc(int8_t c)
828:                 	{
9D01B38C  27BDFFE8   ADDIU SP, SP, -24
9D01B390  AFBF0014   SW RA, 20(SP)
829:                 	CURSOR_INVERT();
830:                 	_video_putc(c);
9D01B394  0F4068B4   JAL .LFB58, _video_putc, .LFE39
9D01B398  00000000   NOP
831:                 	CURSOR_INVERT();
832:                 	}
9D01B39C  8FBF0014   LW RA, 20(SP)
9D01B3A0  03E00008   JR RA
9D01B3A4  27BD0018   ADDIU SP, SP, 24
833:                 
834:                 void video_putc_raw(int8_t c)
835:                 	{
9D01B3A8  27BDFFE8   ADDIU SP, SP, -24
9D01B3AC  AFBF0014   SW RA, 20(SP)
9D01B3B0  AFB00010   SW S0, 16(SP)
836:                 	CURSOR_INVERT();
837:                 
838:                 	/* If the last character printed exceeded the right boundary,
839:                 	 * we have to go to a new line. */
840:                 	if (cx >= DISP_BUFFER_WIDE) _video_lfwd();
9D01B3B4  83828190   LB V0, -32368(GP)
9D01B3B8  28420028   SLTI V0, V0, 40
9D01B3BC  14400003   BNE V0, ZERO, .LVL193
9D01B3C0  00808021   ADDU S0, A0, ZERO
9D01B3C4  0F406896   JAL .LFB38, _video_lfwd, .LFE29
9D01B3C8  00000000   NOP
841:                 //jar
842:                 //  disp_buffer[cy][cx] = c ^ revvideo;
843:                 	disp_buffer[cy][cx] = c;
9D01B3CC  8383818F   LB V1, -32369(GP)
9D01B3D0  83848190   LB A0, -32368(GP)
9D01B3D4  000310C0   SLL V0, V1, 3
9D01B3D8  00031940   SLL V1, V1, 5
9D01B3DC  00431021   ADDU V0, V0, V1
9D01B3E0  00441021   ADDU V0, V0, A0
9D01B3E4  3C03A000   LUI V1, -24576
9D01B3E8  24631E64   ADDIU V1, V1, 7780
9D01B3EC  00431821   ADDU V1, V0, V1
9D01B3F0  A0700000   SB S0, 0(V1)
844:                 	color_buffer[cy][cx] = color_composite;
9D01B3F4  3C03A000   LUI V1, -24576
9D01B3F8  24631B1C   ADDIU V1, V1, 6940
9D01B3FC  00431021   ADDU V0, V0, V1
9D01B400  938381C9   LBU V1, -32311(GP)
845:                 	_video_cfwd();
9D01B404  0F4068A6   JAL .LFB39, _video_cfwd, .LFE38
9D01B408  A0430000   SB V1, 0(V0)
846:                 	CURSOR_INVERT();
847:                 	}
9D01B40C  8FBF0014   LW RA, 20(SP)
9D01B410  8FB00010   LW S0, 16(SP)
9D01B414  03E00008   JR RA
9D01B418  27BD0018   ADDIU SP, SP, 24
848:                 
849:                 void video_puts(int8_t *str)
850:                 	{
9D01B544  27BDFFE8   ADDIU SP, SP, -24
9D01B548  AFBF0014   SW RA, 20(SP)
9D01B54C  AFB00010   SW S0, 16(SP)
851:                 	/* Characters are interpreted and printed one at a time. */
852:                 	int8_t c;
853:                 	CURSOR_INVERT();
854:                 	while ((c = *str++))
9D01B550  24900001   ADDIU S0, A0, 1
9D01B554  80840000   LB A0, 0(A0)
9D01B558  10800006   BEQ A0, ZERO, 0x9D01B574
9D01B55C  8FBF0014   LW RA, 20(SP)
9D01B568  8204FFFF   LB A0, -1(S0)
9D01B56C  1480FFFC   BNE A0, ZERO, 0x9D01B560
9D01B570  8FBF0014   LW RA, 20(SP)
855:                 		_video_putc(c);
9D01B560  0F4068B4   JAL .LFB58, _video_putc, .LFE39
9D01B564  26100001   ADDIU S0, S0, 1
856:                 	CURSOR_INVERT();
857:                 	}
9D01B574  8FB00010   LW S0, 16(SP)
9D01B578  03E00008   JR RA
9D01B57C  27BD0018   ADDIU SP, SP, 24
858:                 
859:                 void video_show_cursor()
860:                 	{
861:                 	if (!showcursor)
9D01B580  9382818E   LBU V0, -32370(GP)
9D01B584  14400002   BNE V0, ZERO, 0x9D01B590
9D01B588  2402FF80   ADDIU V0, ZERO, -128
862:                 		{
863:                 		showcursor = 0x80;
9D01B58C  A382818E   SB V0, -32370(GP)
9D01B590  03E00008   JR RA
9D01B594  00000000   NOP
864:                 		CURSOR_INVERT();
865:                 		}
866:                 	}
867:                 
868:                 void video_hide_cursor()
869:                 	{
870:                 	if (showcursor)
9D01B598  9382818E   LBU V0, -32370(GP)
9D01B59C  54400001   BNEL V0, ZERO, 0x9D01B5A4
9D01B5A0  A380818E   SB ZERO, -32370(GP)
9D01B5A4  03E00008   JR RA
9D01B5A8  00000000   NOP
871:                 		{
872:                 		CURSOR_INVERT();
873:                 		showcursor = 0;
874:                 		}
875:                 	}
876:                 
877:                 uint8_t video_cursor_visible()
878:                 	{
879:                 	return showcursor != 0;
9D01B5AC  9382818E   LBU V0, -32370(GP)
880:                 	}
9D01B5B0  03E00008   JR RA
9D01B5B4  0002102B   SLTU V0, ZERO, V0
881:                 
882:                 void video_invert_range(int8_t x, int8_t y, uint8_t rangelen)
883:                 	{
884:                 	int8_t *start = &disp_buffer[y][x];
9D01B5B8  000510C0   SLL V0, A1, 3
9D01B5BC  00052940   SLL A1, A1, 5
9D01B5C0  00451021   ADDU V0, V0, A1
9D01B5C4  00442021   ADDU A0, V0, A0
9D01B5C8  3C02A000   LUI V0, -24576
9D01B5CC  24421E64   ADDIU V0, V0, 7780
885:                 	uint8_t i;
886:                 	for (i = 0; i < rangelen; i++)
9D01B5D0  10C0000C   BEQ A2, ZERO, 0x9D01B604
9D01B5D4  00441021   ADDU V0, V0, A0
9D01B5D8  24C5FFFF   ADDIU A1, A2, -1
9D01B5DC  30A500FF   ANDI A1, A1, 255
9D01B5E0  24A50001   ADDIU A1, A1, 1
9D01B5E4  00452821   ADDU A1, V0, A1
9D01B5FC  5445FFFC   BNEL V0, A1, 0x9D01B5F0
9D01B600  90430000   LBU V1, 0(V0)
9D01B604  03E00008   JR RA
9D01B608  00000000   NOP
887:                 		{
888:                 		*start ^= 0x80;
9D01B5E8  2404FF80   ADDIU A0, ZERO, -128
9D01B5EC  90430000   LBU V1, 0(V0)
9D01B5F0  00641826   XOR V1, V1, A0
9D01B5F4  A0430000   SB V1, 0(V0)
889:                 		start++;
9D01B5F8  24420001   ADDIU V0, V0, 1
9D01B5FC  5445FFFC   BNEL V0, A1, 0x9D01B5F0
9D01B600  90430000   LBU V1, 0(V0)
9D01B604  03E00008   JR RA
9D01B608  00000000   NOP
890:                 		}
891:                 	}
892:                 
893:                 static void CURSOR_INVERT(void)
894:                 	{
895:                 //jar
896:                 //  disp_buffer[cy][cx] ^= showcursor;
897:                 	}
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/vid_drv.c  ---------------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** vid_drv.c
21:                  **
22:                  ** Video driver
23:                  ** $Id: vid_drv.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <string.h>
27:                  #include <noftypes.h>
28:                  #include <log.h>
29:                  #include <bitmap.h>
30:                  #include <vid_drv.h>
31:                  #include <gui.h>
32:                  #include <osd.h>
33:                  
34:                  /* hardware surface */
35:                  static bitmap_t *screen = NULL;
36:                  
37:                  /* primary / backbuffer surfaces */
38:                  bitmap_t *primary_buffer = NULL; //, *back_buffer = NULL;
39:                  
40:                  static viddriver_t *driver = NULL;
41:                  
42:                  /* fast automagic loop unrolling */
43:                  #define  DUFFS_DEVICE(transfer, count) \
44:                  { \
45:                     register int n = (count + 7) / 8; \
46:                     switch (count % 8) \
47:                     { \
48:                     case 0:  do {  { transfer; } \
49:                     case 7:        { transfer; } \
50:                     case 6:        { transfer; } \
51:                     case 5:        { transfer; } \
52:                     case 4:        { transfer; } \
53:                     case 3:        { transfer; } \
54:                     case 2:        { transfer; } \
55:                     case 1:        { transfer; } \
56:                              } while (--n > 0); \
57:                     } \
58:                  }
59:                  
60:                  /* some system dependent replacement routines (for speed) */
61:                  INLINE int vid_memcmp(const void *p1, const void *p2, int len)
62:                  {
63:                     /* check for 32-bit aligned data */
64:                     if (0 == (((uint32) p1 & 3) | ((uint32) p2 & 3)))
65:                     {
66:                        uint32 *dw1 = (uint32 *) p1;
67:                        uint32 *dw2 = (uint32 *) p2;
68:                  
69:                        len >>= 2;
70:                  
71:                        DUFFS_DEVICE(if (*dw1++ != *dw2++) return -1, len);
72:                     }
73:                     else
74:                     /* fall back to 8-bit compares */
75:                     {
76:                        uint8 *b1 = (uint8 *) p1;
77:                        uint8 *b2 = (uint8 *) p2;
78:                        
79:                        DUFFS_DEVICE(if (*b1++ != *b2++) return -1, len);
80:                     }
81:                     
82:                     return 0;
83:                  }
84:                  
85:                  /* super-dooper assembly memcpy (thanks, SDL!) */
86:                  #if defined(__GNUC__) && defined(i386)
87:                  #define vid_memcpy(dest, src, len) \
88:                  { \
89:                     int u0, u1, u2; \
90:                     __asm__ __volatile__ ( \
91:                        "  cld            \n" \
92:                        "  rep            \n" \
93:                        "  movsl          \n" \
94:                        "  testb $2,%b4   \n" \
95:                        "  je    1f       \n" \
96:                        "  movsw          \n" \
97:                        "1:               \n" \
98:                        "  testb $1,%b4   \n" \
99:                        "  je 2f          \n" \
100:                       "  movsb          \n" \
101:                       "2:               \n" \
102:                       : "=&c" (u0), "=&D" (u1), "=&S" (u2) \
103:                       : "0" ((len)/4), "q" (len), "1" (dest), "2" (src) \
104:                       : "memory"); \
105:                 }
106:                 #else /* !(defined(__GNUC__) && defined(i386)) */
107:                 INLINE void vid_memcpy(void *dest, const void *src, int len)
108:                 {
109:                    uint32 *s = (uint32 *) src;
110:                    uint32 *d = (uint32 *) dest;
111:                 
112:                    ASSERT(0 == ((len & 3) | ((uint32) src & 3) | ((uint32) dest & 3)));
113:                    len >>= 2;
9D02E398  00081083   SRA V0, T0, 2
114:                 
115:                    DUFFS_DEVICE(*d++ = *s++, len);
9D02E39C  24430007   ADDIU V1, V0, 7
9D02E3A0  2444000E   ADDIU A0, V0, 14
9D02E3A4  286C0000   SLTI T4, V1, 0
9D02E3A8  008C180B   MOVN V1, A0, T4
9D02E3AC  000360C3   SRA T4, V1, 3
9D02E3B0  000847C3   SRA T0, T0, 31
9D02E3B4  00084742   SRL T0, T0, 29
9D02E3B8  00481021   ADDU V0, V0, T0
9D02E3BC  30420007   ANDI V0, V0, 7
9D02E3C0  00481023   SUBU V0, V0, T0
9D02E3C4  2C4B0008   SLTIU T3, V0, 8
9D02E3C8  00021080   SLL V0, V0, 2
9D02E3CC  3C0D9D03   LUI T5, -25341
9D02E3D0  25ADE3F0   ADDIU T5, T5, -7184
9D02E3D4  01A26821   ADDU T5, T5, V0
9D02E3DC  5160004F   BEQL T3, ZERO, 0x9D02E51C
9D02E3E0  00AE2821   ADDU A1, A1, T6
9D02E3E4  8DA40000   LW A0, 0(T5)
9D02E3E8  00800008   JR A0
9D02E3EC  00000000   NOP
9D02E410  01801021   ADDU V0, T4, ZERO
9D02E414  00E02021   ADDU A0, A3, ZERO
9D02E418  00A01821   ADDU V1, A1, ZERO
9D02E41C  24880004   ADDIU T0, A0, 4
9D02E420  24690004   ADDIU T1, V1, 4
9D02E424  8C630000   LW V1, 0(V1)
9D02E428  0B40B90F   J 0x9D02E43C
9D02E42C  AC830000   SW V1, 0(A0)
9D02E430  01801021   ADDU V0, T4, ZERO
9D02E434  00E04021   ADDU T0, A3, ZERO
9D02E438  00A04821   ADDU T1, A1, ZERO
9D02E43C  25030004   ADDIU V1, T0, 4
9D02E440  25260004   ADDIU A2, T1, 4
9D02E444  8D240000   LW A0, 0(T1)
9D02E448  0B40B917   J 0x9D02E45C
9D02E44C  AD040000   SW A0, 0(T0)
9D02E450  01801021   ADDU V0, T4, ZERO
9D02E454  00E01821   ADDU V1, A3, ZERO
9D02E458  00A03021   ADDU A2, A1, ZERO
9D02E45C  24640004   ADDIU A0, V1, 4
9D02E460  24C80004   ADDIU T0, A2, 4
9D02E464  8CC60000   LW A2, 0(A2)
9D02E468  0B40B91F   J 0x9D02E47C
9D02E46C  AC660000   SW A2, 0(V1)
9D02E470  01801021   ADDU V0, T4, ZERO
9D02E474  00E02021   ADDU A0, A3, ZERO
9D02E478  00A04021   ADDU T0, A1, ZERO
9D02E47C  24830004   ADDIU V1, A0, 4
9D02E480  25060004   ADDIU A2, T0, 4
9D02E484  8D080000   LW T0, 0(T0)
9D02E488  0B40B927   J 0x9D02E49C
9D02E48C  AC880000   SW T0, 0(A0)
9D02E490  01801021   ADDU V0, T4, ZERO
9D02E494  00E01821   ADDU V1, A3, ZERO
9D02E498  00A03021   ADDU A2, A1, ZERO
9D02E49C  24640004   ADDIU A0, V1, 4
9D02E4A0  24C90004   ADDIU T1, A2, 4
9D02E4A4  8CC60000   LW A2, 0(A2)
9D02E4A8  0B40B92F   J 0x9D02E4BC
9D02E4AC  AC660000   SW A2, 0(V1)
9D02E4B0  01801021   ADDU V0, T4, ZERO
9D02E4B4  00E02021   ADDU A0, A3, ZERO
9D02E4B8  00A04821   ADDU T1, A1, ZERO
9D02E4BC  24860004   ADDIU A2, A0, 4
9D02E4C0  25280004   ADDIU T0, T1, 4
9D02E4C4  8D230000   LW V1, 0(T1)
9D02E4C8  0B40B937   J 0x9D02E4DC
9D02E4CC  AC830000   SW V1, 0(A0)
9D02E4D0  01801021   ADDU V0, T4, ZERO
9D02E4D4  00E03021   ADDU A2, A3, ZERO
9D02E4D8  00A04021   ADDU T0, A1, ZERO
9D02E4DC  24C40004   ADDIU A0, A2, 4
9D02E4E0  25030004   ADDIU V1, T0, 4
9D02E4E4  8D080000   LW T0, 0(T0)
9D02E4E8  0B40B93F   J 0x9D02E4FC
9D02E4EC  ACC80000   SW T0, 0(A2)
9D02E4F0  01801021   ADDU V0, T4, ZERO
9D02E4F4  00E02021   ADDU A0, A3, ZERO
9D02E4F8  00A01821   ADDU V1, A1, ZERO
9D02E4FC  8C660000   LW A2, 0(V1)
9D02E500  2442FFFF   ADDIU V0, V0, -1
9D02E504  18400004   BLEZ V0, 0x9D02E518
9D02E508  AC860000   SW A2, 0(A0)
9D02E50C  24840004   ADDIU A0, A0, 4
9D02E510  0B40B907   J 0x9D02E41C
9D02E514  24630004   ADDIU V1, V1, 4
116:                 }
117:                 #endif /* !(defined(__GNUC__) && defined(i386)) */
118:                 
119:                 
120:                 /* TODO: any way to remove this filth (GUI needs it)? */
121:                 bitmap_t *vid_getbuffer(void)
122:                 {
123:                    return primary_buffer;
124:                 }
9D02E278  03E00008   JR RA
9D02E27C  8F82812C   LW V0, -32468(GP)
125:                 
126:                 void vid_setpalette(rgb_t *p)
127:                 {
9D02E280  27BDFFE8   ADDIU SP, SP, -24
9D02E284  AFBF0014   SW RA, 20(SP)
128:                    ASSERT(driver);
129:                    ASSERT(p);
130:                 
131:                    driver->set_palette(p);
9D02E288  8F828128   LW V0, -32472(GP)
9D02E28C  8C420010   LW V0, 16(V0)
9D02E290  0040F809   JALR V0
9D02E294  00000000   NOP
132:                 }
9D02E298  8FBF0014   LW RA, 20(SP)
9D02E29C  03E00008   JR RA
9D02E2A0  27BD0018   ADDIU SP, SP, 24
133:                 
134:                 /* blits a bitmap onto primary buffer */
135:                 void vid_blit(bitmap_t *bitmap, int src_x, int src_y, int dest_x, int dest_y, 
136:                               int width, int height)
137:                 {
9D02E2A4  8FA90010   LW T1, 16(SP)
9D02E2A8  8FA80014   LW T0, 20(SP)
138:                    int bitmap_pitch, primary_pitch;
139:                    uint8 *dest_ptr, *src_ptr;
140:                 
141:                    ASSERT(bitmap);
142:                 
143:                    /* clip to source */
144:                    if (src_y >= bitmap->height)
9D02E2AC  8C830004   LW V1, 4(A0)
9D02E2B0  00C3502A   SLT T2, A2, V1
9D02E2B4  1140009C   BEQ T2, ZERO, 0x9D02E528
9D02E2B8  8FA20018   LW V0, 24(SP)
145:                       return;
146:                    if (src_y + height > bitmap->height)
9D02E2BC  00C25021   ADDU T2, A2, V0
9D02E2C0  006A502A   SLT T2, V1, T2
147:                       height = bitmap->height - src_y;
9D02E2C4  00661823   SUBU V1, V1, A2
9D02E2C8  006A100B   MOVN V0, V1, T2
148:                 
149:                    if (src_x >= bitmap->width)
9D02E2CC  8C830000   LW V1, 0(A0)
9D02E2D0  00A3502A   SLT T2, A1, V1
9D02E2D4  11400094   BEQ T2, ZERO, 0x9D02E528
9D02E2D8  00A85021   ADDU T2, A1, T0
150:                       return;
151:                    if (src_x + width > bitmap->width)
9D02E2DC  006A502A   SLT T2, V1, T2
152:                       width = bitmap->width - src_x;
9D02E2E0  00651823   SUBU V1, V1, A1
9D02E2E4  006A400B   MOVN T0, V1, T2
153:                 
154:                    /* clip to dest */
155:                    if (dest_y + height <= 0)
9D02E2E8  01221821   ADDU V1, T1, V0
9D02E2EC  1860008E   BLEZ V1, 0x9D02E528
9D02E2F0  00000000   NOP
156:                    {
157:                       return;
158:                    }
159:                    else if (dest_y < 0)
9D02E2F4  05210004   BGEZ T1, 0x9D02E308
9D02E2F8  8F8A812C   LW T2, -32468(GP)
160:                    {
161:                       height += dest_y;
9D02E300  00601021   ADDU V0, V1, ZERO
162:                       src_y -= dest_y;
9D02E2FC  00C93023   SUBU A2, A2, T1
163:                       dest_y = 0;
9D02E304  00004821   ADDU T1, ZERO, ZERO
164:                    }
165:                 
166:                    if (dest_y >= primary_buffer->height)
9D02E308  8D430004   LW V1, 4(T2)
9D02E30C  0123582A   SLT T3, T1, V1
9D02E310  11600085   BEQ T3, ZERO, 0x9D02E528
9D02E314  01225821   ADDU T3, T1, V0
167:                       return;
168:                    if (dest_y + height > primary_buffer->height)
9D02E318  006B582A   SLT T3, V1, T3
169:                       height = primary_buffer->height - dest_y;
9D02E31C  00691823   SUBU V1, V1, T1
9D02E320  006B100B   MOVN V0, V1, T3
170:                 
171:                    if (dest_x + width <= 0)
9D02E324  00E81821   ADDU V1, A3, T0
9D02E328  1860007F   BLEZ V1, 0x9D02E528
9D02E32C  00000000   NOP
172:                    {
173:                       return;
174:                    }
175:                    else if (dest_x < 0)
9D02E330  04E30005   BGEZL A3, 0x9D02E348
9D02E334  8D430000   LW V1, 0(T2)
176:                    {
177:                       width += dest_x;
9D02E33C  00604021   ADDU T0, V1, ZERO
178:                       src_x -= dest_x;
9D02E338  00A72823   SUBU A1, A1, A3
179:                       dest_x = 0;
9D02E340  00003821   ADDU A3, ZERO, ZERO
180:                    }
181:                 
182:                    if (dest_x >= primary_buffer->width)
9D02E344  8D430000   LW V1, 0(T2)
9D02E348  00E3582A   SLT T3, A3, V1
9D02E34C  11600076   BEQ T3, ZERO, 0x9D02E528
9D02E350  00E85821   ADDU T3, A3, T0
183:                       return;
184:                    if (dest_x + width > primary_buffer->width)
9D02E354  006B582A   SLT T3, V1, T3
185:                       width = primary_buffer->width - dest_x;   
9D02E358  00671823   SUBU V1, V1, A3
9D02E35C  006B400B   MOVN T0, V1, T3
186:                 
187:                    src_ptr = bitmap->line[src_y] + src_x;
9D02E360  24C60004   ADDIU A2, A2, 4
9D02E364  00063080   SLL A2, A2, 2
9D02E368  00863021   ADDU A2, A0, A2
9D02E36C  8CC30004   LW V1, 4(A2)
9D02E370  00652821   ADDU A1, V1, A1
188:                    dest_ptr = primary_buffer->line[dest_y] + dest_x;
9D02E374  25290004   ADDIU T1, T1, 4
9D02E378  00094880   SLL T1, T1, 2
9D02E37C  01494821   ADDU T1, T2, T1
9D02E380  8D230004   LW V1, 4(T1)
9D02E384  00673821   ADDU A3, V1, A3
189:                 
190:                    /* Avoid doing unnecessary indexed lookups */
191:                    bitmap_pitch = bitmap->pitch;
9D02E388  8C8E0008   LW T6, 8(A0)
192:                    primary_pitch = primary_buffer->pitch;
9D02E38C  8D4F0008   LW T7, 8(T2)
193:                 
194:                    /* do the copy */
195:                    while (height--)
9D02E390  10400065   BEQ V0, ZERO, 0x9D02E528
9D02E394  244AFFFF   ADDIU T2, V0, -1
9D02E3D8  2418FFFF   ADDIU T8, ZERO, -1
9D02E51C  254AFFFF   ADDIU T2, T2, -1
9D02E520  1558FFAE   BNE T2, T8, 0x9D02E3DC
9D02E524  00EF3821   ADDU A3, A3, T7
9D02E528  03E00008   JR RA
9D02E52C  00000000   NOP
196:                    {
197:                       vid_memcpy(dest_ptr, src_ptr, width);
198:                       src_ptr += bitmap_pitch;
9D02E518  00AE2821   ADDU A1, A1, T6
9D02E51C  254AFFFF   ADDIU T2, T2, -1
9D02E520  1558FFAE   BNE T2, T8, 0x9D02E3DC
9D02E524  00EF3821   ADDU A3, A3, T7
9D02E528  03E00008   JR RA
9D02E52C  00000000   NOP
199:                       dest_ptr += primary_pitch;
200:                    }
201:                 }
202:                 
203:                 static void vid_blitscreen(int num_dirties, rect_t *dirty_rects)
204:                 {
205:                    int src_x, src_y, dest_x, dest_y;
206:                    int blit_width, blit_height;
207:                 
208:                    screen = driver->lock_write();
209:                 
210:                    /* center in y direction */
211:                    if (primary_buffer->height <= screen->height)
212:                    {
213:                       src_y = 0;
214:                       blit_height = primary_buffer->height;
215:                       dest_y = (screen->height - blit_height) >> 1;
216:                    }
217:                    else
218:                    {
219:                       src_y = (primary_buffer->height - screen->height) >> 1;
220:                       blit_height = screen->height;
221:                       dest_y = 0;
222:                    }
223:                 
224:                    /* and in x */
225:                    if (primary_buffer->width <= screen->width)
226:                    {
227:                       src_x = 0;
228:                       blit_width = primary_buffer->width;
229:                       dest_x = (screen->width - blit_width) >> 1;
230:                    }
231:                    else
232:                    {
233:                       src_x = (primary_buffer->width - screen->width) >> 1;
234:                       blit_width = screen->width;
235:                       dest_x = 0;
236:                    }
237:                    
238:                    /* should we just copy the entire screen? */
239:                    if (-1 == num_dirties)
240:                    {
241:                       uint8 *dest, *src;
242:                 
243:                       src = primary_buffer->line[src_y] + src_x;
244:                       dest = screen->line[dest_y] + dest_x;
245:                 
246:                       while (blit_height--)
247:                       {
248:                          vid_memcpy(dest, src, primary_buffer->width);
249:                          src += primary_buffer->pitch;
250:                          dest += screen->pitch;
251:                       }
252:                    }
253:                    else
254:                    {
255:                       /* we need to blit just a bunch of dirties */
256:                       int i, j, height;
257:                       rect_t *rects = dirty_rects;
258:                 
259:                       for (i = 0; i < num_dirties && blit_height; i++)
260:                       {
261:                          height = rects->h;
262:                          if (blit_height < height)
263:                             height = blit_height;
264:                 
265:                          j = 0;
266:                          DUFFS_DEVICE(  
267:                          {
268:                             vid_memcpy(screen->line[dest_y + rects->y + j] + rects->x + dest_x,
269:                                        primary_buffer->line[src_y + rects->y + j] + rects->x + src_x,
270:                                        rects->w);
271:                             j++;
272:                             blit_height--;
273:                          }, height);
274:                 
275:                          rects++;
276:                       }
277:                    }
278:                 
279:                    if (driver->free_write)
280:                       driver->free_write(num_dirties, dirty_rects);
281:                 }
282:                 
283:                 /* TODO: this code is sickly */
284:                 
285:                 #define  CHUNK_WIDTH    256
286:                 #define  CHUNK_HEIGHT   16
287:                 #define  MAX_DIRTIES    ((256 / CHUNK_WIDTH) * (240 / CHUNK_HEIGHT))
288:                 #define  DIRTY_CUTOFF   ((3 * MAX_DIRTIES) / 4)
289:                 
290:                 #if 0
291:                 INLINE int calc_dirties(rect_t *list)
292:                 {
293:                    bool dirty;
294:                    int num_dirties = 0;
295:                    int i = 0, j, line_offset = 0;
296:                    int iterations = primary_buffer->height / CHUNK_HEIGHT;
297:                 
298:                    for (i = 0; i < iterations; i++)
299:                    {
300:                       dirty = false;
301:                 
302:                       j = line_offset;
303:                       DUFFS_DEVICE(
304:                       { 
305:                          if (vid_memcmp(back_buffer->line[j], primary_buffer->line[j], 
306:                                         CHUNK_WIDTH))
307:                          { 
308:                             dirty = true; 
309:                             break; 
310:                          } 
311:                 
312:                          j++; 
313:                       }, CHUNK_HEIGHT);
314:                 
315:                       if (true == dirty)
316:                       {
317:                          list->h = CHUNK_HEIGHT;
318:                          list->w = CHUNK_WIDTH;
319:                          list->x = 0;
320:                          list->y = line_offset;
321:                          list++;
322:                 
323:                          /* totally arbitrary at this point */
324:                          if (++num_dirties > DIRTY_CUTOFF)
325:                             return -1;
326:                       }
327:                 
328:                       line_offset += CHUNK_HEIGHT;
329:                    }
330:                 
331:                    return num_dirties;
332:                 }
333:                 #endif
334:                 
335:                 void vid_flush(void)
336:                 {
9D02E530  03E00008   JR RA
9D02E534  00000000   NOP
337:                    bitmap_t *temp;
338:                    int num_dirties;
339:                    rect_t dirty_rects[MAX_DIRTIES];
340:                 
341:                    //ASSERT(driver);
342:                 
343:                 //   if (true == driver->invalidate)
344:                 //   {
345:                 //      driver->invalidate = false;
346:                 //      num_dirties = -1;
347:                 //   }
348:                    //else
349:                    //{
350:                       //num_dirties = calc_dirties(dirty_rects);
351:                       num_dirties = -1;
352:                    //}
353:                 
354:                    //if (driver->custom_blit)
355:                    //   driver->custom_blit(primary_buffer, num_dirties, dirty_rects);
356:                    //else
357:                       //vid_blitscreen(num_dirties, dirty_rects);
358:                 
359:                    /* Swap pointers to the main/back buffers */
360:                 //   temp = back_buffer;
361:                 //   back_buffer = primary_buffer;
362:                 //   primary_buffer = temp;
363:                 }
364:                 
365:                 /* emulated machine tells us which resolution it wants */
366:                 int vid_setmode(int width, int height)
367:                 {
9D02E538  27BDFFE0   ADDIU SP, SP, -32
9D02E53C  AFBF001C   SW RA, 28(SP)
9D02E540  AFB10018   SW S1, 24(SP)
9D02E544  AFB00014   SW S0, 20(SP)
9D02E548  00808821   ADDU S1, A0, ZERO
368:                    if (NULL != primary_buffer)
9D02E54C  8F82812C   LW V0, -32468(GP)
9D02E550  10400003   BEQ V0, ZERO, .LVL59
9D02E554  00A08021   ADDU S0, A1, ZERO
369:                       bmp_destroy(&primary_buffer);
9D02E558  0F40D3C9   JAL bmp_destroy
9D02E55C  2784812C   ADDIU A0, GP, -32468
370:                 //   if (NULL != back_buffer)
371:                 //      bmp_destroy(&back_buffer);
372:                 
373:                    primary_buffer = bmp_create(width, height, 0); /* no overdraw */
9D02E560  02202021   ADDU A0, S1, ZERO
9D02E564  02002821   ADDU A1, S0, ZERO
9D02E568  0F40D39E   JAL bmp_create
9D02E56C  00003021   ADDU A2, ZERO, ZERO
374:                    if (NULL == primary_buffer)
9D02E570  10400006   BEQ V0, ZERO, 0x9D02E58C
9D02E574  AF82812C   SW V0, -32468(GP)
375:                       return -1;
9D02E58C  2402FFFF   ADDIU V0, ZERO, -1
376:                 
377:                    /* Create our backbuffer */
378:                 #if 0
379:                    back_buffer = bmp_create(width, height, 0); /* no overdraw */
380:                    if (NULL == back_buffer)
381:                    {
382:                       bmp_destroy(&primary_buffer);
383:                       return -1;
384:                    }
385:                    bmp_clear(back_buffer, GUI_BLACK);
386:                 #endif
387:                    bmp_clear(primary_buffer, GUI_BLACK);
9D02E578  00402021   ADDU A0, V0, ZERO
9D02E57C  0F40D394   JAL bmp_clear
9D02E580  240500C0   ADDIU A1, ZERO, 192
388:                 
389:                    return 0;
9D02E584  0B40B964   J 0x9D02E590
9D02E588  00001021   ADDU V0, ZERO, ZERO
390:                 }
9D02E590  8FBF001C   LW RA, 28(SP)
9D02E594  8FB10018   LW S1, 24(SP)
9D02E598  8FB00014   LW S0, 20(SP)
9D02E59C  03E00008   JR RA
9D02E5A0  27BD0020   ADDIU SP, SP, 32
391:                 
392:                 static int vid_findmode(int width, int height, viddriver_t *osd_driver)
393:                 {
394:                    if (osd_driver->init(width, height))
9D02E5C4  8CC20004   LW V0, 4(A2)
9D02E5C8  0040F809   JALR V0
9D02E5CC  00C08021   ADDU S0, A2, ZERO
9D02E5D0  1040000A   BEQ V0, ZERO, 0x9D02E5FC
9D02E5D4  00408821   ADDU S1, V0, ZERO
395:                    {
396:                       driver = NULL;
9D02E5D8  AF808128   SW ZERO, -32472(GP)
397:                       return -1; /* mode not available! */
398:                    }
399:                 
400:                    /* we got our driver */
401:                    driver = osd_driver;
9D02E5FC  AF908128   SW S0, -32472(GP)
402:                 
403:                    /* re-assert dimensions, clear the surface */
404:                    screen = driver->lock_write();
9D02E600  8E020018   LW V0, 24(S0)
9D02E604  0040F809   JALR V0
9D02E608  00000000   NOP
9D02E60C  AF828130   SW V0, -32464(GP)
405:                 
406:                    /* use custom pageclear, if necessary */
407:                    if (driver->clear)
9D02E610  8F838128   LW V1, -32472(GP)
9D02E614  8C630014   LW V1, 20(V1)
9D02E618  10600005   BEQ V1, ZERO, 0x9D02E630
9D02E61C  00402021   ADDU A0, V0, ZERO
408:                       driver->clear(GUI_BLACK);
9D02E620  0060F809   JALR V1
9D02E624  240400C0   ADDIU A0, ZERO, 192
409:                    else
410:                       bmp_clear(screen, GUI_BLACK);
9D02E630  0F40D394   JAL bmp_clear
9D02E634  240500C0   ADDIU A1, ZERO, 192
411:                 
412:                    /* release surface */
413:                    if (driver->free_write)
9D02E628  0B40B98F   J 0x9D02E63C
9D02E62C  8F828128   LW V0, -32472(GP)
9D02E638  8F828128   LW V0, -32472(GP)
9D02E63C  8C42001C   LW V0, 28(V0)
9D02E640  50400005   BEQL V0, ZERO, 0x9D02E658
9D02E644  8F828130   LW V0, -32464(GP)
414:                       driver->free_write(-1, NULL);
9D02E648  2404FFFF   ADDIU A0, ZERO, -1
9D02E64C  0040F809   JALR V0
9D02E650  00002821   ADDU A1, ZERO, ZERO
415:                 
416:                    log_printf("video driver: %s at %dx%d\n", driver->name,
9D02E658  3C049D04   LUI A0, -25340
9D02E65C  2484B360   ADDIU A0, A0, -19616
9D02E660  8F838128   LW V1, -32472(GP)
9D02E664  8C650000   LW A1, 0(V1)
9D02E668  8C460000   LW A2, 0(V0)
9D02E66C  0F40EEE8   JAL log_printf
9D02E670  8C470004   LW A3, 4(V0)
417:                               screen->width, screen->height);
9D02E654  8F828130   LW V0, -32464(GP)
418:                 
419:                    return 0;
420:                 }
421:                 
422:                 /* This is the interface to the drivers, used in nofrendo.c */
423:                 int vid_init(int width, int height, viddriver_t *osd_driver)
424:                 {
9D02E5A4  27BDFFD8   ADDIU SP, SP, -40
9D02E5A8  AFBF0024   SW RA, 36(SP)
9D02E5AC  AFB30020   SW S3, 32(SP)
9D02E5B0  AFB2001C   SW S2, 28(SP)
9D02E5B4  AFB10018   SW S1, 24(SP)
9D02E5B8  AFB00014   SW S0, 20(SP)
9D02E5BC  00809821   ADDU S3, A0, ZERO
9D02E5C0  00A09021   ADDU S2, A1, ZERO
425:                    if (vid_findmode(width, height, osd_driver))
426:                    {
427:                       log_printf("video initialization failed for %s at %dx%d\n",
9D02E5DC  3C049D04   LUI A0, -25340
9D02E5E0  2484B330   ADDIU A0, A0, -19664
9D02E5E4  8E050000   LW A1, 0(S0)
9D02E5E8  02603021   ADDU A2, S3, ZERO
9D02E5EC  0F40EEE8   JAL log_printf
9D02E5F0  02403821   ADDU A3, S2, ZERO
428:                                  osd_driver->name, width, height);
429:                       return -1;
9D02E5F4  0B40B9A0   J .LVL73
9D02E5F8  2411FFFF   ADDIU S1, ZERO, -1
430:                    }
431:                 	log_printf("vid_init done\n");
9D02E674  3C049D04   LUI A0, -25340
9D02E678  0F40EEE8   JAL log_printf
9D02E67C  2484B37C   ADDIU A0, A0, -19588
432:                 
433:                    return 0;
434:                 }
9D02E680  02201021   ADDU V0, S1, ZERO
9D02E684  8FBF0024   LW RA, 36(SP)
9D02E688  8FB30020   LW S3, 32(SP)
9D02E68C  8FB2001C   LW S2, 28(SP)
9D02E690  8FB10018   LW S1, 24(SP)
9D02E694  8FB00014   LW S0, 20(SP)
9D02E698  03E00008   JR RA
9D02E69C  27BD0028   ADDIU SP, SP, 40
435:                 
436:                 void vid_shutdown(void)
437:                 {
9D02E6A0  27BDFFE8   ADDIU SP, SP, -24
9D02E6A4  AFBF0014   SW RA, 20(SP)
438:                    if (NULL == driver)
9D02E6A8  8F828128   LW V0, -32472(GP)
9D02E6AC  1040000D   BEQ V0, ZERO, 0x9D02E6E4
9D02E6B0  8F83812C   LW V1, -32468(GP)
439:                       return;
440:                 
441:                    if (NULL != primary_buffer)
9D02E6B4  50600007   BEQL V1, ZERO, 0x9D02E6D4
9D02E6B8  8C420008   LW V0, 8(V0)
442:                       bmp_destroy(&primary_buffer);
9D02E6BC  0F40D3C9   JAL bmp_destroy
9D02E6C0  2784812C   ADDIU A0, GP, -32468
443:                 #if 0
444:                    if (NULL != back_buffer)
445:                       bmp_destroy(&back_buffer);
446:                 #endif
447:                 
448:                    if (driver && driver->shutdown)
9D02E6C4  8F828128   LW V0, -32472(GP)
9D02E6C8  10400007   BEQ V0, ZERO, 0x9D02E6E8
9D02E6CC  8FBF0014   LW RA, 20(SP)
9D02E6D0  8C420008   LW V0, 8(V0)
9D02E6D4  10400004   BEQ V0, ZERO, 0x9D02E6E8
9D02E6D8  8FBF0014   LW RA, 20(SP)
449:                       driver->shutdown();
9D02E6DC  0040F809   JALR V0
9D02E6E0  00000000   NOP
450:                 }
9D02E6E4  8FBF0014   LW RA, 20(SP)
9D02E6E8  03E00008   JR RA
9D02E6EC  27BD0018   ADDIU SP, SP, 24
451:                 
452:                 
453:                 /*
454:                 ** $Log: vid_drv.c,v $
455:                 ** Revision 1.2  2001/04/27 14:37:11  neil
456:                 ** wheeee
457:                 **
458:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
459:                 ** initial
460:                 **
461:                 ** Revision 1.40  2000/11/25 20:26:42  matt
462:                 ** not much
463:                 **
464:                 ** Revision 1.39  2000/11/16 14:27:27  matt
465:                 ** even more crash-proofness
466:                 **
467:                 ** Revision 1.38  2000/11/16 14:11:18  neil
468:                 ** Better *not* to crash in case of catastrophic failure in the driver
469:                 **
470:                 ** Revision 1.37  2000/11/13 00:55:16  matt
471:                 ** no dirties seems to be faster (!?!?)
472:                 **
473:                 ** Revision 1.36  2000/11/06 05:16:18  matt
474:                 ** minor clipping bug
475:                 **
476:                 ** Revision 1.35  2000/11/06 02:16:26  matt
477:                 ** cleanups
478:                 **
479:                 ** Revision 1.34  2000/11/05 22:53:13  matt
480:                 ** only one video driver per system, please
481:                 **
482:                 ** Revision 1.33  2000/11/05 16:37:18  matt
483:                 ** rolled rgb.h into bitmap.h
484:                 **
485:                 ** Revision 1.32  2000/11/05 06:23:41  matt
486:                 ** thinlib spawns changes
487:                 **
488:                 ** Revision 1.31  2000/10/10 13:58:14  matt
489:                 ** stroustrup squeezing his way in the door
490:                 **
491:                 ** Revision 1.30  2000/10/10 13:03:53  matt
492:                 ** Mr. Clean makes a guest appearance
493:                 **
494:                 ** Revision 1.29  2000/10/08 17:58:23  matt
495:                 ** lock_read() should not allow us to clear the bitmap
496:                 **
497:                 ** Revision 1.28  2000/09/18 02:06:48  matt
498:                 ** -pedantic is your friend
499:                 **
500:                 ** Revision 1.27  2000/08/16 02:53:05  matt
501:                 ** changed init() interface a wee bit
502:                 **
503:                 ** Revision 1.26  2000/08/14 02:45:59  matt
504:                 ** fixed nasty bug in vid_blitscreen
505:                 **
506:                 ** Revision 1.24  2000/08/11 01:44:37  matt
507:                 ** clipping bugfix
508:                 **
509:                 ** Revision 1.23  2000/07/31 04:28:47  matt
510:                 ** one million cleanups
511:                 **
512:                 ** Revision 1.22  2000/07/28 07:25:49  neil
513:                 ** Video driver has an invalidate flag, telling vid_drv not to calculate dirties for the next frame
514:                 **
515:                 ** Revision 1.21  2000/07/28 03:51:45  matt
516:                 ** lock_read used instead of lock_write in some places
517:                 **
518:                 ** Revision 1.20  2000/07/28 01:24:05  matt
519:                 ** dirty rectangle support
520:                 **
521:                 ** Revision 1.19  2000/07/27 23:49:52  matt
522:                 ** no more getmode
523:                 **
524:                 ** Revision 1.18  2000/07/27 04:30:37  matt
525:                 ** change to get_mode api
526:                 **
527:                 ** Revision 1.17  2000/07/27 04:05:58  matt
528:                 ** changed place where name goes
529:                 **
530:                 ** Revision 1.16  2000/07/27 01:16:22  matt
531:                 ** api changes for new main and dirty rects
532:                 **
533:                 ** Revision 1.15  2000/07/26 21:36:13  neil
534:                 ** Big honkin' change -- see the mailing list
535:                 **
536:                 ** Revision 1.14  2000/07/24 04:33:57  matt
537:                 ** skeleton of dirty rectangle code in place
538:                 **
539:                 ** Revision 1.13  2000/07/23 14:35:39  matt
540:                 ** cleanups
541:                 **
542:                 ** Revision 1.12  2000/07/18 19:41:26  neil
543:                 ** use screen->pitch in blitscreen, not screen_width
544:                 **
545:                 ** Revision 1.11  2000/07/11 04:30:16  matt
546:                 ** overdraw unnecessary!
547:                 **
548:                 ** Revision 1.10  2000/07/10 19:07:57  matt
549:                 ** added custom clear() member call to video driver
550:                 **
551:                 ** Revision 1.9  2000/07/10 03:06:49  matt
552:                 ** my dependency file is broken... *snif*
553:                 **
554:                 ** Revision 1.8  2000/07/10 03:04:15  matt
555:                 ** removed scanlines, backbuffer from custom blit
556:                 **
557:                 ** Revision 1.7  2000/07/10 01:03:20  neil
558:                 ** New video scheme allows for custom blitters to be determined by the driver at runtime
559:                 **
560:                 ** Revision 1.6  2000/07/09 03:34:46  matt
561:                 ** temporary cleanup
562:                 **
563:                 ** Revision 1.5  2000/07/08 23:48:29  neil
564:                 ** Another assumption GGI kills: pitch == width for hardware bitmaps
565:                 **
566:                 ** Revision 1.4  2000/07/07 20:18:03  matt
567:                 ** added overdraw, fixed some bugs in blitters
568:                 **
569:                 ** Revision 1.3  2000/07/07 18:33:55  neil
570:                 ** no need to lock for reading just to get the dimensions
571:                 **
572:                 ** Revision 1.2  2000/07/07 18:11:37  neil
573:                 ** Generalizing the video driver
574:                 **
575:                 ** Revision 1.1  2000/07/06 16:48:47  matt
576:                 ** initial revision
577:                 **
578:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/sndhrdw/vrcvisnd.c  ------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** vrcvisnd.c
21:                  **
22:                  ** VRCVI sound hardware emulation
23:                  ** $Id: vrcvisnd.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <vrcvisnd.h>
28:                  #include <nes_apu.h>
29:                  
30:                  typedef struct vrcvirectangle_s
31:                  {
32:                     bool enabled;
33:                  
34:                     uint8 reg[3];
35:                     
36:                     float accum;
37:                     uint8 adder;
38:                  
39:                     int32 freq;
40:                     int32 volume;
41:                     uint8 duty_flip;
42:                  } vrcvirectangle_t;
43:                  
44:                  typedef struct vrcvisawtooth_s
45:                  {
46:                     bool enabled;
47:                     
48:                     uint8 reg[3];
49:                     
50:                     float accum;
51:                     uint8 adder;
52:                     uint8 output_acc;
53:                  
54:                     int32 freq;
55:                     uint8 volume;
56:                  } vrcvisawtooth_t;
57:                  
58:                  typedef struct vrcvisnd_s
59:                  {
60:                     vrcvirectangle_t rectangle[2];
61:                     vrcvisawtooth_t saw;
62:                     float incsize;
63:                  } vrcvisnd_t;
64:                  
65:                  
66:                  static vrcvisnd_t vrcvi;
67:                  
68:                  /* VRCVI rectangle wave generation */
69:                  static int32 vrcvi_rectangle(vrcvirectangle_t *chan)
70:                  {
9D02F3DC  27BDFFD8   ADDIU SP, SP, -40
9D02F3E0  AFBF0024   SW RA, 36(SP)
9D02F3E4  AFB30020   SW S3, 32(SP)
9D02F3E8  AFB2001C   SW S2, 28(SP)
9D02F3EC  AFB10018   SW S1, 24(SP)
9D02F3F0  AFB00014   SW S0, 20(SP)
9D02F3F4  00809821   ADDU S3, A0, ZERO
71:                     /* reg0: 0-3=volume, 4-6=duty cycle
72:                     ** reg1: 8 bits of freq
73:                     ** reg2: 0-3=high freq, 7=enable
74:                     */
75:                  
76:                     chan->accum -= vrcvi.incsize; /* # of clocks per wave cycle */
9D02F3F8  8C840008   LW A0, 8(A0)
9D02F3FC  3C02A001   LUI V0, -24575
9D02F400  0F40CFF8   JAL __subsf3
9D02F404  8C45AD34   LW A1, -21196(V0)
9D02F408  00408021   ADDU S0, V0, ZERO
9D02F40C  AE620008   SW V0, 8(S3)
77:                     while (chan->accum < 0)
9D02F410  00402021   ADDU A0, V0, ZERO
9D02F414  0F40E8E3   JAL __lesf2
9D02F418  00002821   ADDU A1, ZERO, ZERO
9D02F41C  04430013   BGEZL V0, 0x9D02F46C
9D02F420  8E630000   LW V1, 0(S3)
9D02F44C  00402021   ADDU A0, V0, ZERO
9D02F450  0F40E8E3   JAL __lesf2
9D02F454  00002821   ADDU A1, ZERO, ZERO
9D02F458  0440FFF7   BLTZ V0, 0x9D02F438
9D02F45C  02002021   ADDU A0, S0, ZERO
9D02F460  AE700008   SW S0, 8(S3)
9D02F464  A271000C   SB S1, 12(S3)
78:                     {
79:                        chan->accum += chan->freq;
9D02F424  0F40ECB4   JAL sitofp
9D02F428  8E640010   LW A0, 16(S3)
9D02F42C  00409021   ADDU S2, V0, ZERO
9D02F430  9271000C   LBU S1, 12(S3)
9D02F434  02002021   ADDU A0, S0, ZERO
9D02F438  0F40CFFA   JAL fpadd
9D02F43C  02402821   ADDU A1, S2, ZERO
9D02F440  00408021   ADDU S0, V0, ZERO
80:                        chan->adder = (chan->adder + 1) & 0x0F;
9D02F444  26230001   ADDIU V1, S1, 1
9D02F448  3071000F   ANDI S1, V1, 15
81:                     }
82:                  
83:                     /* return if not enabled */
84:                     if (false == chan->enabled)
9D02F468  8E630000   LW V1, 0(S3)
9D02F46C  10600007   BEQ V1, ZERO, 0x9D02F48C
9D02F470  00001021   ADDU V0, ZERO, ZERO
85:                        return 0;
86:                  
87:                     if (chan->adder < chan->duty_flip)
9D02F474  9263000C   LBU V1, 12(S3)
9D02F478  92620018   LBU V0, 24(S3)
9D02F47C  0062102B   SLTU V0, V1, V0
9D02F480  10400002   BEQ V0, ZERO, 0x9D02F48C
9D02F484  8E620014   LW V0, 20(S3)
9D02F488  00021023   SUBU V0, ZERO, V0
88:                        return -(chan->volume);
89:                     else
90:                        return chan->volume;
91:                  }
9D02F48C  8FBF0024   LW RA, 36(SP)
9D02F490  8FB30020   LW S3, 32(SP)
9D02F494  8FB2001C   LW S2, 28(SP)
9D02F498  8FB10018   LW S1, 24(SP)
9D02F49C  8FB00014   LW S0, 20(SP)
9D02F4A0  03E00008   JR RA
9D02F4A4  27BD0028   ADDIU SP, SP, 40
92:                  
93:                  /* VRCVI sawtooth wave generation */
94:                  static int32 vrcvi_sawtooth(vrcvisawtooth_t *chan)
95:                  {
96:                     /* reg0: 0-5=phase accumulator bits
97:                     ** reg1: 8 bits of freq
98:                     ** reg2: 0-3=high freq, 7=enable
99:                     */
100:                 
101:                    chan->accum -= vrcvi.incsize; /* # of clocks per wav cycle */
9D02F4EC  2610ACE4   ADDIU S0, S0, -21276
9D02F4F0  8E040040   LW A0, 64(S0)
9D02F4F4  0F40CFF8   JAL __subsf3
9D02F4F8  8E050050   LW A1, 80(S0)
102:                    while (chan->accum < 0)
9D02F554  02002021   ADDU A0, S0, ZERO
9D02F558  0F40E8E3   JAL __lesf2
9D02F55C  00002821   ADDU A1, ZERO, ZERO
9D02F560  0440FFED   BLTZ V0, 0x9D02F518
9D02F564  3C02A001   LUI V0, -24575
9D02F568  2442ACE4   ADDIU V0, V0, -21276
9D02F56C  AC500040   SW S0, 64(V0)
9D02F570  A0520045   SB S2, 69(V0)
9D02F574  A0510044   SB S1, 68(V0)
103:                    {
104:                       chan->accum += chan->freq;
9D02F4FC  8E150048   LW S5, 72(S0)
9D02F518  0F40ECB4   JAL sitofp
9D02F51C  02A02021   ADDU A0, S5, ZERO
9D02F520  00402021   ADDU A0, V0, ZERO
9D02F524  0F40CFFA   JAL fpadd
9D02F528  02002821   ADDU A1, S0, ZERO
9D02F52C  02549021   ADDU S2, S2, S4
9D02F530  26310001   ADDIU S1, S1, 1
9D02F534  323100FF   ANDI S1, S1, 255
9D02F540  0B40BD55   J 0x9D02F554
9D02F544  00408021   ADDU S0, V0, ZERO
9D02F548  00408021   ADDU S0, V0, ZERO
105:                       chan->output_acc += chan->volume;
9D02F500  9214004C   LBU S4, 76(S0)
9D02F504  92120045   LBU S2, 69(S0)
9D02F508  92110044   LBU S1, 68(S0)
9D02F50C  00408021   ADDU S0, V0, ZERO
106:                       
107:                       chan->adder++;
108:                       if (7 == chan->adder)
9D02F510  0B40BD55   J 0x9D02F554
9D02F514  24130007   ADDIU S3, ZERO, 7
9D02F538  12330003   BEQ S1, S3, 0x9D02F548
9D02F53C  325200FF   ANDI S2, S2, 255
109:                       {
110:                          chan->adder = 0;
9D02F550  00008821   ADDU S1, ZERO, ZERO
111:                          chan->output_acc = 0;
9D02F54C  00009021   ADDU S2, ZERO, ZERO
112:                       }
113:                    }
114:                 
115:                    /* return if not enabled */
116:                    if (false == chan->enabled)
9D02F578  8C430038   LW V1, 56(V0)
9D02F57C  10600005   BEQ V1, ZERO, 0x9D02F594
9D02F580  00001021   ADDU V0, ZERO, ZERO
117:                       return 0;
118:                 
119:                    return (chan->output_acc >> 3) << 9;
9D02F584  3C02A001   LUI V0, -24575
9D02F588  9042AD29   LBU V0, -21207(V0)
9D02F58C  000210C2   SRL V0, V0, 3
9D02F590  00021240   SLL V0, V0, 9
120:                 }
121:                 
122:                 /* mix vrcvi sound channels together */
123:                 static int32 vrcvi_process(void)
124:                 {
9D02F4A8  27BDFFD0   ADDIU SP, SP, -48
9D02F4AC  AFBF002C   SW RA, 44(SP)
9D02F4B0  AFB60028   SW S6, 40(SP)
9D02F4B4  AFB50024   SW S5, 36(SP)
9D02F4B8  AFB40020   SW S4, 32(SP)
9D02F4BC  AFB3001C   SW S3, 28(SP)
9D02F4C0  AFB20018   SW S2, 24(SP)
9D02F4C4  AFB10014   SW S1, 20(SP)
9D02F4C8  AFB00010   SW S0, 16(SP)
125:                    int32 output;
126:                 
127:                    output = vrcvi_rectangle(&vrcvi.rectangle[0]);
9D02F4CC  3C10A001   LUI S0, -24575
9D02F4D0  0F40BCF7   JAL .LFB0, vrcvi_rectangle, .Ltext0
9D02F4D4  2604ACE4   ADDIU A0, S0, -21276
9D02F4D8  0040B021   ADDU S6, V0, ZERO
128:                    output += vrcvi_rectangle(&vrcvi.rectangle[1]);
9D02F4DC  3C04A001   LUI A0, -24575
9D02F4E0  0F40BCF7   JAL .LFB0, vrcvi_rectangle, .Ltext0
9D02F4E4  2484AD00   ADDIU A0, A0, -21248
9D02F4E8  0056B021   ADDU S6, V0, S6
129:                    output += vrcvi_sawtooth(&vrcvi.saw);
130:                 
131:                    return output;
132:                 }
9D02F594  02C21021   ADDU V0, S6, V0
9D02F598  8FBF002C   LW RA, 44(SP)
9D02F59C  8FB60028   LW S6, 40(SP)
9D02F5A0  8FB50024   LW S5, 36(SP)
9D02F5A4  8FB40020   LW S4, 32(SP)
9D02F5A8  8FB3001C   LW S3, 28(SP)
9D02F5AC  8FB20018   LW S2, 24(SP)
9D02F5B0  8FB10014   LW S1, 20(SP)
9D02F5B4  8FB00010   LW S0, 16(SP)
9D02F5B8  03E00008   JR RA
9D02F5BC  27BD0030   ADDIU SP, SP, 48
133:                 
134:                 /* write to registers */
135:                 static void vrcvi_write(uint32 address, uint8 value)
136:                 {
137:                    int chan = (address >> 12) - 9;
9D02F5C0  00041302   SRL V0, A0, 12
9D02F5C4  2446FFF7   ADDIU A2, V0, -9
138:                 
139:                    switch (address & 0xB003)
9D02F5C8  3084B003   ANDI A0, A0, -20477
9D02F5CC  3402A001   ORI V0, ZERO, -24575
9D02F5D0  10820032   BEQ A0, V0, 0x9D02F69C
9D02F5D4  3403A002   ORI V1, ZERO, -24574
9D02F5D8  0083182B   SLTU V1, A0, V1
9D02F5DC  10600012   BEQ V1, ZERO, 0x9D02F628
9D02F5E0  3402B000   ORI V0, ZERO, -20480
9D02F5E4  34029001   ORI V0, ZERO, -28671
9D02F5E8  1082002C   BEQ A0, V0, 0x9D02F69C
9D02F5EC  34029002   ORI V0, ZERO, -28670
9D02F5F0  0082102B   SLTU V0, A0, V0
9D02F5F4  10400006   BEQ V0, ZERO, 0x9D02F610
9D02F5F8  34029002   ORI V0, ZERO, -28670
9D02F5FC  34029000   ORI V0, ZERO, -28672
9D02F600  10820019   BEQ A0, V0, 0x9D02F668
9D02F604  00061880   SLL V1, A2, 2
9D02F608  03E00008   JR RA
9D02F60C  00000000   NOP
9D02F610  10820030   BEQ A0, V0, 0x9D02F6D4
9D02F614  3402A000   ORI V0, ZERO, -24576
9D02F618  10820013   BEQ A0, V0, 0x9D02F668
9D02F61C  00061880   SLL V1, A2, 2
9D02F620  03E00008   JR RA
9D02F624  00000000   NOP
9D02F628  1082003A   BEQ A0, V0, 0x9D02F714
9D02F62C  3402B001   ORI V0, ZERO, -20479
9D02F630  0082102B   SLTU V0, A0, V0
9D02F634  10400006   BEQ V0, ZERO, 0x9D02F650
9D02F638  3402B001   ORI V0, ZERO, -20479
9D02F63C  3402A002   ORI V0, ZERO, -24574
9D02F640  10820025   BEQ A0, V0, 0x9D02F6D8
9D02F644  00061880   SLL V1, A2, 2
9D02F648  03E00008   JR RA
9D02F64C  00000000   NOP
9D02F650  10820036   BEQ A0, V0, 0x9D02F72C
9D02F654  3402B002   ORI V0, ZERO, -20478
9D02F658  1082003F   BEQ A0, V0, 0x9D02F758
9D02F65C  3C02A001   LUI V0, -24575
9D02F660  03E00008   JR RA
9D02F664  00000000   NOP
140:                    {
141:                    case 0x9000:
142:                    case 0xA000:
143:                       vrcvi.rectangle[chan].reg[0] = value;
9D02F668  00063140   SLL A2, A2, 5
9D02F66C  00C33023   SUBU A2, A2, V1
9D02F670  3C03A001   LUI V1, -24575
9D02F674  2463ACE4   ADDIU V1, V1, -21276
9D02F678  00C33021   ADDU A2, A2, V1
9D02F67C  A0C50004   SB A1, 4(A2)
144:                       vrcvi.rectangle[chan].volume = (value & 0x0F) << 8;
9D02F680  30A2000F   ANDI V0, A1, 15
9D02F684  00021200   SLL V0, V0, 8
9D02F688  ACC20014   SW V0, 20(A2)
145:                       vrcvi.rectangle[chan].duty_flip = (value >> 4) + 1;
9D02F68C  00052902   SRL A1, A1, 4
9D02F690  24A50001   ADDIU A1, A1, 1
146:                       break;
9D02F694  03E00008   JR RA
9D02F698  A0C50018   SB A1, 24(A2)
147:                 
148:                    case 0x9001:
149:                    case 0xA001:
150:                       vrcvi.rectangle[chan].reg[1] = value;
9D02F69C  00061880   SLL V1, A2, 2
9D02F6A0  00063140   SLL A2, A2, 5
9D02F6A4  00C33023   SUBU A2, A2, V1
9D02F6A8  3C03A001   LUI V1, -24575
9D02F6AC  2463ACE4   ADDIU V1, V1, -21276
9D02F6B0  00C33021   ADDU A2, A2, V1
9D02F6B4  A0C50005   SB A1, 5(A2)
151:                       vrcvi.rectangle[chan].freq = ((vrcvi.rectangle[chan].reg[2] & 0x0F) << 8) + value + 1;
9D02F6B8  90C20006   LBU V0, 6(A2)
9D02F6BC  3042000F   ANDI V0, V0, 15
9D02F6C0  00021200   SLL V0, V0, 8
9D02F6C4  00452821   ADDU A1, V0, A1
9D02F6C8  24A50001   ADDIU A1, A1, 1
152:                       break;
9D02F6CC  03E00008   JR RA
9D02F6D0  ACC50010   SW A1, 16(A2)
153:                 
154:                    case 0x9002:
155:                    case 0xA002:
156:                       vrcvi.rectangle[chan].reg[2] = value;
9D02F6D4  00061880   SLL V1, A2, 2
9D02F6D8  00063140   SLL A2, A2, 5
9D02F6DC  00C33023   SUBU A2, A2, V1
9D02F6E0  3C03A001   LUI V1, -24575
9D02F6E4  2463ACE4   ADDIU V1, V1, -21276
9D02F6E8  00C33021   ADDU A2, A2, V1
9D02F6EC  A0C50006   SB A1, 6(A2)
157:                       vrcvi.rectangle[chan].freq = ((value & 0x0F) << 8) + vrcvi.rectangle[chan].reg[1] + 1;
9D02F6F0  30A2000F   ANDI V0, A1, 15
9D02F6F4  00021200   SLL V0, V0, 8
9D02F6F8  90C30005   LBU V1, 5(A2)
9D02F6FC  00431021   ADDU V0, V0, V1
9D02F700  24420001   ADDIU V0, V0, 1
9D02F704  ACC20010   SW V0, 16(A2)
158:                       vrcvi.rectangle[chan].enabled = (value & 0x80) ? true : false;
9D02F708  000529C2   SRL A1, A1, 7
159:                       break;
9D02F70C  03E00008   JR RA
9D02F710  ACC50000   SW A1, 0(A2)
160:                 
161:                    case 0xB000:
162:                       vrcvi.saw.reg[0] = value;
9D02F714  3C02A001   LUI V0, -24575
9D02F718  2442ACE4   ADDIU V0, V0, -21276
9D02F71C  A045003C   SB A1, 60(V0)
163:                       vrcvi.saw.volume = value & 0x3F;
9D02F720  30A5003F   ANDI A1, A1, 63
164:                       break;
9D02F724  03E00008   JR RA
9D02F728  A045004C   SB A1, 76(V0)
165:                 
166:                    case 0xB001:
167:                       vrcvi.saw.reg[1] = value;
9D02F72C  3C02A001   LUI V0, -24575
9D02F730  2442ACE4   ADDIU V0, V0, -21276
9D02F734  A045003D   SB A1, 61(V0)
168:                       vrcvi.saw.freq = (((vrcvi.saw.reg[2] & 0x0F) << 8) + value + 1) << 1;
9D02F738  9043003E   LBU V1, 62(V0)
9D02F73C  3063000F   ANDI V1, V1, 15
9D02F740  00031A00   SLL V1, V1, 8
9D02F744  00652821   ADDU A1, V1, A1
9D02F748  24A50001   ADDIU A1, A1, 1
9D02F74C  00052840   SLL A1, A1, 1
169:                       break;
9D02F750  03E00008   JR RA
9D02F754  AC450048   SW A1, 72(V0)
170:                 
171:                    case 0xB002:
172:                       vrcvi.saw.reg[2] = value;
9D02F758  2442ACE4   ADDIU V0, V0, -21276
9D02F75C  A045003E   SB A1, 62(V0)
173:                       vrcvi.saw.freq = (((value & 0x0F) << 8) + vrcvi.saw.reg[1] + 1) << 1;
9D02F760  30A3000F   ANDI V1, A1, 15
9D02F764  00031A00   SLL V1, V1, 8
9D02F768  9044003D   LBU A0, 61(V0)
9D02F76C  00641821   ADDU V1, V1, A0
9D02F770  24630001   ADDIU V1, V1, 1
9D02F774  00031840   SLL V1, V1, 1
9D02F778  AC430048   SW V1, 72(V0)
174:                       vrcvi.saw.enabled = (value & 0x80) ? true : false;
9D02F77C  000529C2   SRL A1, A1, 7
9D02F780  03E00008   JR RA
9D02F784  AC450038   SW A1, 56(V0)
175:                       break;
176:                 
177:                    default:
178:                       break;
179:                    }
180:                 }
181:                 
182:                 /* reset state of vrcvi sound channels */
183:                 static void vrcvi_reset(void)
184:                 {
9D02F788  27BDFE70   ADDIU SP, SP, -400
9D02F78C  AFBF018C   SW RA, 396(SP)
9D02F790  AFB10188   SW S1, 392(SP)
9D02F794  AFB00184   SW S0, 388(SP)
185:                    int i;
186:                    apu_t apu;
187:                 
188:                    /* get the phase period from the apu */
189:                    apu_getcontext(&apu);
9D02F798  0F40765D   JAL apu_getcontext
9D02F79C  27A40010   ADDIU A0, SP, 16
190:                    vrcvi.incsize = apu.cycle_rate;
9D02F7A0  8FA3015C   LW V1, 348(SP)
9D02F7A4  3C02A001   LUI V0, -24575
9D02F7A8  AC43AD34   SW V1, -21196(V0)
9D02F7AC  34109000   ORI S0, ZERO, -28672
191:                 
192:                    /* preload regs */
193:                    for (i = 0; i < 3; i++)
9D02F7B0  34119003   ORI S1, ZERO, -28669
9D02F7DC  1611FFF6   BNE S0, S1, 0x9D02F7B8
9D02F7E0  02002021   ADDU A0, S0, ZERO
194:                    {
195:                       vrcvi_write(0x9000 + i, 0);
9D02F7B4  02002021   ADDU A0, S0, ZERO
9D02F7B8  0F40BD70   JAL .LFB3, vrcvi_write, .LFE2
9D02F7BC  00002821   ADDU A1, ZERO, ZERO
196:                       vrcvi_write(0xA000 + i, 0);
9D02F7C0  26041000   ADDIU A0, S0, 4096
9D02F7C4  0F40BD70   JAL .LFB3, vrcvi_write, .LFE2
9D02F7C8  00002821   ADDU A1, ZERO, ZERO
197:                       vrcvi_write(0xB000 + i, 0);
9D02F7CC  26042000   ADDIU A0, S0, 8192
9D02F7D0  0F40BD70   JAL .LFB3, vrcvi_write, .LFE2
9D02F7D4  00002821   ADDU A1, ZERO, ZERO
9D02F7D8  26100001   ADDIU S0, S0, 1
198:                    }
199:                 }
9D02F7E4  8FBF018C   LW RA, 396(SP)
9D02F7E8  8FB10188   LW S1, 392(SP)
9D02F7EC  8FB00184   LW S0, 388(SP)
9D02F7F0  03E00008   JR RA
9D02F7F4  27BD0190   ADDIU SP, SP, 400
200:                 
201:                 static apu_memwrite vrcvi_memwrite[] =
202:                 {
203:                    { 0x9000, 0x9002, vrcvi_write }, /* vrc6 */
204:                    { 0xA000, 0xA002, vrcvi_write },
205:                    { 0xB000, 0xB002, vrcvi_write },
206:                    {     -1,     -1, NULL }
207:                 };
208:                 
209:                 apuext_t vrcvi_ext =
210:                 {
211:                    NULL, /* no init */
212:                    NULL, /* no shutdown */
213:                    vrcvi_reset,
214:                    vrcvi_process,
215:                    NULL, /* no reads */
216:                    vrcvi_memwrite
217:                 };
218:                 
219:                 /*
220:                 ** $Log: vrcvisnd.c,v $
221:                 ** Revision 1.2  2001/04/27 14:37:11  neil
222:                 ** wheeee
223:                 **
224:                 ** Revision 1.1  2001/04/27 12:54:40  neil
225:                 ** blah
226:                 **
227:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
228:                 ** initial
229:                 **
230:                 ** Revision 1.2  2000/11/05 22:21:00  matt
231:                 ** help me!
232:                 **
233:                 ** Revision 1.1  2000/10/24 12:20:00  matt
234:                 ** changed directory structure
235:                 **
236:                 ** Revision 1.17  2000/10/10 13:58:18  matt
237:                 ** stroustrup squeezing his way in the door
238:                 **
239:                 ** Revision 1.16  2000/10/03 11:56:20  matt
240:                 ** better support for optional sound ext routines
241:                 **
242:                 ** Revision 1.15  2000/09/27 12:26:03  matt
243:                 ** changed sound accumulators back to floats
244:                 **
245:                 ** Revision 1.14  2000/09/15 13:38:40  matt
246:                 ** changes for optimized apu core
247:                 **
248:                 ** Revision 1.13  2000/09/15 04:58:07  matt
249:                 ** simplifying and optimizing APU core
250:                 **
251:                 ** Revision 1.12  2000/07/30 04:32:59  matt
252:                 ** no more apu_getcyclerate hack
253:                 **
254:                 ** Revision 1.11  2000/07/17 01:52:31  matt
255:                 ** made sure last line of all source files is a newline
256:                 **
257:                 ** Revision 1.10  2000/07/06 11:42:41  matt
258:                 ** forgot to remove FDS register range
259:                 **
260:                 ** Revision 1.9  2000/07/04 04:51:41  matt
261:                 ** cleanups
262:                 **
263:                 ** Revision 1.8  2000/07/03 02:18:53  matt
264:                 ** much better external module exporting
265:                 **
266:                 ** Revision 1.7  2000/06/20 04:06:16  matt
267:                 ** migrated external sound definition to apu module
268:                 **
269:                 ** Revision 1.6  2000/06/20 00:08:58  matt
270:                 ** changed to driver based API
271:                 **
272:                 ** Revision 1.5  2000/06/09 16:49:02  matt
273:                 ** removed all floating point from sound generation
274:                 **
275:                 ** Revision 1.4  2000/06/09 15:12:28  matt
276:                 ** initial revision
277:                 **
278:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/sndhrdw/nes_apu.c  -------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** nes_apu.c
21:                  **
22:                  ** NES APU emulation
23:                  ** $Id: nes_apu.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <string.h>
27:                  #include <noftypes.h>
28:                  #include <log.h>
29:                  #include <nes_apu.h>
30:                  #include "nes6502.h"
31:                   
32:                  
33:                  #define  APU_OVERSAMPLE
34:                  #define  APU_VOLUME_DECAY(x)  ((x) -= ((x) >> 7))
35:                  
36:                  /* the following seem to be the correct (empirically determined)
37:                  ** relative volumes between the sound channels
38:                  */
39:                  #define  APU_RECTANGLE_OUTPUT(channel) (apu.rectangle[channel].output_vol)
40:                  #define  APU_TRIANGLE_OUTPUT           (apu.triangle.output_vol + (apu.triangle.output_vol >> 2))
41:                  #define  APU_NOISE_OUTPUT              ((apu.noise.output_vol + apu.noise.output_vol + apu.noise.output_vol) >> 2)
42:                  #define  APU_DMC_OUTPUT                ((apu.dmc.output_vol + apu.dmc.output_vol + apu.dmc.output_vol) >> 2)
43:                  
44:                  /* active APU */
45:                  static apu_t apu;
46:                  
47:                  /* look up table madness */
48:                  static int32 decay_lut[16];
49:                  static int vbl_lut[32];
50:                  static int trilength_lut[128];
51:                  
52:                  /* noise lookups for both modes */
53:                  #ifndef REALTIME_NOISE
54:                  static int8 noise_long_lut[APU_NOISE_32K];
55:                  static int8 noise_short_lut[APU_NOISE_93];
56:                  #endif /* !REALTIME_NOISE */
57:                  
58:                  
59:                  /* vblank length table used for rectangles, triangle, noise */
60:                  static const uint8 vbl_length[32] =
61:                  {
62:                      5, 127,
63:                     10,   1,
64:                     19,   2,
65:                     40,   3,
66:                     80,   4,
67:                     30,   5,
68:                      7,   6,
69:                     13,   7,
70:                      6,   8,
71:                     12,   9,
72:                     24,  10,
73:                     48,  11,
74:                     96,  12,
75:                     36,  13,
76:                      8,  14,
77:                     16,  15
78:                  };
79:                  
80:                  /* frequency limit of rectangle channels */
81:                  static const int freq_limit[8] =
82:                  {
83:                     0x3FF, 0x555, 0x666, 0x71C, 0x787, 0x7C1, 0x7E0, 0x7F0
84:                  };
85:                  
86:                  /* noise frequency lookup table */
87:                  static const int noise_freq[16] =
88:                  {
89:                       4,    8,   16,   32,   64,   96,  128,  160,
90:                     202,  254,  380,  508,  762, 1016, 2034, 4068
91:                  };
92:                  
93:                  /* DMC transfer freqs */
94:                  const int dmc_clocks[16] =
95:                  {
96:                     428, 380, 340, 320, 286, 254, 226, 214,
97:                     190, 160, 142, 128, 106,  85,  72,  54
98:                  };
99:                  
100:                 /* ratios of pos/neg pulse for rectangle waves */
101:                 static const int duty_flip[4] = { 2, 4, 8, 12 };
102:                 
103:                 
104:                 void apu_setcontext(apu_t *src_apu)
105:                 {
106:                    apu = *src_apu;
9D01D91C  00801021   ADDU V0, A0, ZERO
9D01D920  3C03A001   LUI V1, -24575
9D01D924  246392F4   ADDIU V1, V1, -27916
9D01D928  24840160   ADDIU A0, A0, 352
9D01D92C  8C480000   LW T0, 0(V0)
9D01D930  8C470004   LW A3, 4(V0)
9D01D934  8C460008   LW A2, 8(V0)
9D01D938  8C45000C   LW A1, 12(V0)
9D01D93C  AC680000   SW T0, 0(V1)
9D01D940  AC670004   SW A3, 4(V1)
9D01D944  AC660008   SW A2, 8(V1)
9D01D948  AC65000C   SW A1, 12(V1)
9D01D94C  24420010   ADDIU V0, V0, 16
9D01D950  1444FFF6   BNE V0, A0, 0x9D01D92C
9D01D954  24630010   ADDIU V1, V1, 16
9D01D958  8C450000   LW A1, 0(V0)
9D01D95C  8C440004   LW A0, 4(V0)
9D01D960  8C420008   LW V0, 8(V0)
9D01D964  AC650000   SW A1, 0(V1)
9D01D968  AC640004   SW A0, 4(V1)
9D01D96C  03E00008   JR RA
9D01D970  AC620008   SW V0, 8(V1)
107:                 }
108:                 
109:                 void apu_getcontext(apu_t *dest_apu)
110:                 {
111:                    *dest_apu = apu;
9D01D974  3C02A001   LUI V0, -24575
9D01D978  244292F4   ADDIU V0, V0, -27916
9D01D97C  24430160   ADDIU V1, V0, 352
9D01D980  8C480000   LW T0, 0(V0)
9D01D984  8C470004   LW A3, 4(V0)
9D01D988  8C460008   LW A2, 8(V0)
9D01D98C  8C45000C   LW A1, 12(V0)
9D01D990  AC880000   SW T0, 0(A0)
9D01D994  AC870004   SW A3, 4(A0)
9D01D998  AC860008   SW A2, 8(A0)
9D01D99C  AC85000C   SW A1, 12(A0)
9D01D9A0  24420010   ADDIU V0, V0, 16
9D01D9A4  1443FFF6   BNE V0, V1, 0x9D01D980
9D01D9A8  24840010   ADDIU A0, A0, 16
9D01D9AC  8C450000   LW A1, 0(V0)
9D01D9B0  8C430004   LW V1, 4(V0)
9D01D9B4  8C420008   LW V0, 8(V0)
9D01D9B8  AC850000   SW A1, 0(A0)
9D01D9BC  AC830004   SW V1, 4(A0)
9D01D9C0  03E00008   JR RA
9D01D9C4  AC820008   SW V0, 8(A0)
112:                 }
113:                 
114:                 void apu_setchan(int chan, bool enabled)
115:                 {
116:                    if (enabled)
9D01D9C8  10A00008   BEQ A1, ZERO, 0x9D01D9EC
9D01D9CC  3C02A001   LUI V0, -24575
117:                       apu.mix_enable |= (1 << chan);
9D01D9D0  244292F4   ADDIU V0, V0, -27916
9D01D9D4  24030001   ADDIU V1, ZERO, 1
9D01D9D8  00832004   SLLV A0, V1, A0
9D01D9DC  90430140   LBU V1, 320(V0)
9D01D9E0  00832025   OR A0, A0, V1
9D01D9E4  03E00008   JR RA
9D01D9E8  A0440140   SB A0, 320(V0)
118:                    else
119:                       apu.mix_enable &= ~(1 << chan);
9D01D9EC  244292F4   ADDIU V0, V0, -27916
9D01D9F0  24030001   ADDIU V1, ZERO, 1
9D01D9F4  00832004   SLLV A0, V1, A0
9D01D9F8  00042027   NOR A0, ZERO, A0
9D01D9FC  90430140   LBU V1, 320(V0)
9D01DA00  00832024   AND A0, A0, V1
9D01DA04  03E00008   JR RA
9D01DA08  A0440140   SB A0, 320(V0)
120:                 }
121:                 
122:                 /* emulation of the 15-bit shift register the
123:                 ** NES uses to generate pseudo-random series
124:                 ** for the white noise channel
125:                 */
126:                 #ifdef REALTIME_NOISE
127:                 INLINE int8 shift_register15(uint8 xor_tap)
128:                 {
129:                    static int sreg = 0x4000;
130:                    int bit0, tap, bit14;
131:                 
132:                    bit0 = sreg & 1;
9D01D5A8  32E20001   ANDI V0, S7, 1
133:                    tap = (sreg & xor_tap) ? 1 : 0;
9D01D584  92F700FC   LBU S7, 252(S7)
9D01D588  AFB70020   SW S7, 32(SP)
9D01D58C  8F978018   LW S7, -32744(GP)
9D01D5AC  8FA40020   LW A0, 32(SP)
9D01D5B0  02E41824   AND V1, S7, A0
9D01D5B4  0003182B   SLTU V1, ZERO, V1
134:                    bit14 = (bit0 ^ tap);
9D01D5B8  00621826   XOR V1, V1, V0
135:                    sreg >>= 1;
9D01D5C0  0017B843   SRA S7, S7, 1
136:                    sreg |= (bit14 << 14);
9D01D5BC  00031B80   SLL V1, V1, 14
9D01D5C4  0077B825   OR S7, V1, S7
137:                    return (bit0 ^ 1);
138:                 }
139:                 #else /* !REALTIME_NOISE */
140:                 static void shift_register15(int8 *buf, int count)
141:                 {
142:                    static int sreg = 0x4000;
143:                    int bit0, bit1, bit6, bit14;
144:                 
145:                    if (count == APU_NOISE_93)
146:                    {
147:                       while (count--)
148:                       {
149:                          bit0 = sreg & 1;
150:                          bit6 = (sreg & 0x40) >> 6;
151:                          bit14 = (bit0 ^ bit6);
152:                          sreg >>= 1;
153:                          sreg |= (bit14 << 14);
154:                          *buf++ = bit0 ^ 1;
155:                       }
156:                    }
157:                    else /* 32K noise */
158:                    {
159:                       while (count--)
160:                       {
161:                          bit0 = sreg & 1;
162:                          bit1 = (sreg & 2) >> 1;
163:                          bit14 = (bit0 ^ bit1);
164:                          sreg >>= 1;
165:                          sreg |= (bit14 << 14);
166:                          *buf++ = bit0 ^ 1;
167:                       }
168:                    }
169:                 }
170:                 #endif /* !REALTIME_NOISE */
171:                 
172:                 /* RECTANGLE WAVE
173:                 ** ==============
174:                 ** reg0: 0-3=volume, 4=envelope, 5=hold, 6-7=duty cycle
175:                 ** reg1: 0-2=sweep shifts, 3=sweep inc/dec, 4-6=sweep length, 7=sweep on
176:                 ** reg2: 8 bits of freq
177:                 ** reg3: 0-2=high freq, 7-4=vbl length counter
178:                 */
179:                 #ifdef APU_OVERSAMPLE
180:                 
181:                 #define  APU_MAKE_RECTANGLE(ch) \
182:                 static int32 apu_rectangle_##ch(void) \
183:                 { \
184:                    int32 output, total; \
185:                    int num_times; \
186:                 \
187:                    APU_VOLUME_DECAY(apu.rectangle[ch].output_vol); \
188:                 \
189:                    if (false == apu.rectangle[ch].enabled || 0 == apu.rectangle[ch].vbl_length) \
190:                       return APU_RECTANGLE_OUTPUT(ch); \
191:                 \
192:                    /* vbl length counter */ \
193:                    if (false == apu.rectangle[ch].holdnote) \
194:                       apu.rectangle[ch].vbl_length--; \
195:                 \
196:                    /* envelope decay at a rate of (env_delay + 1) / 240 secs */ \
197:                    apu.rectangle[ch].env_phase -= 4; /* 240/60 */ \
198:                    while (apu.rectangle[ch].env_phase < 0) \
199:                    { \
200:                       apu.rectangle[ch].env_phase += apu.rectangle[ch].env_delay; \
201:                 \
202:                       if (apu.rectangle[ch].holdnote) \
203:                          apu.rectangle[ch].env_vol = (apu.rectangle[ch].env_vol + 1) & 0x0F; \
204:                       else if (apu.rectangle[ch].env_vol < 0x0F) \
205:                          apu.rectangle[ch].env_vol++; \
206:                    } \
207:                 \
208:                    /* TODO: find true relation of freq_limit to register values */ \
209:                    if (apu.rectangle[ch].freq < 8 \
210:                        || (false == apu.rectangle[ch].sweep_inc \
211:                            && apu.rectangle[ch].freq > apu.rectangle[ch].freq_limit)) \
212:                       return APU_RECTANGLE_OUTPUT(ch); \
213:                 \
214:                    /* frequency sweeping at a rate of (sweep_delay + 1) / 120 secs */ \
215:                    if (apu.rectangle[ch].sweep_on && apu.rectangle[ch].sweep_shifts) \
216:                    { \
217:                       apu.rectangle[ch].sweep_phase -= 2; /* 120/60 */ \
218:                       while (apu.rectangle[ch].sweep_phase < 0) \
219:                       { \
220:                          apu.rectangle[ch].sweep_phase += apu.rectangle[ch].sweep_delay; \
221:                 \
222:                          if (apu.rectangle[ch].sweep_inc) /* ramp up */ \
223:                          { \
224:                             if (0 == ch) \
225:                                apu.rectangle[ch].freq += ~(apu.rectangle[ch].freq >> apu.rectangle[ch].sweep_shifts); \
226:                             else \
227:                                apu.rectangle[ch].freq -= (apu.rectangle[ch].freq >> apu.rectangle[ch].sweep_shifts); \
228:                          } \
229:                          else /* ramp down */ \
230:                          { \
231:                             apu.rectangle[ch].freq += (apu.rectangle[ch].freq >> apu.rectangle[ch].sweep_shifts); \
232:                          } \
233:                       } \
234:                    } \
235:                 \
236:                    apu.rectangle[ch].accum -= apu.cycle_rate; \
237:                    if (apu.rectangle[ch].accum >= 0) \
238:                       return APU_RECTANGLE_OUTPUT(ch); \
239:                 \
240:                    if (apu.rectangle[ch].fixed_envelope) \
241:                       output = apu.rectangle[ch].volume << 8; /* fixed volume */ \
242:                    else \
243:                       output = (apu.rectangle[ch].env_vol ^ 0x0F) << 8; \
244:                 \
245:                    num_times = total = 0; \
246:                 \
247:                    while (apu.rectangle[ch].accum < 0) \
248:                    { \
249:                       apu.rectangle[ch].accum += apu.rectangle[ch].freq + 1; \
250:                       apu.rectangle[ch].adder = (apu.rectangle[ch].adder + 1) & 0x0F; \
251:                 \
252:                       if (apu.rectangle[ch].adder < apu.rectangle[ch].duty_flip) \
253:                          total += output; \
254:                       else \
255:                          total -= output; \
256:                 \
257:                       num_times++; \
258:                    } \
259:                 \
260:                    apu.rectangle[ch].output_vol = total / num_times; \
261:                    return APU_RECTANGLE_OUTPUT(ch); \
262:                 } 
263:                 
264:                 #else /* !APU_OVERSAMPLE */
265:                 #define  APU_MAKE_RECTANGLE(ch) \
266:                 static int32 apu_rectangle_##ch(void) \
267:                 { \
268:                    int32 output; \
269:                 \
270:                    APU_VOLUME_DECAY(apu.rectangle[ch].output_vol); \
271:                 \
272:                    if (false == apu.rectangle[ch].enabled || 0 == apu.rectangle[ch].vbl_length) \
273:                       return APU_RECTANGLE_OUTPUT(ch); \
274:                 \
275:                    /* vbl length counter */ \
276:                    if (false == apu.rectangle[ch].holdnote) \
277:                       apu.rectangle[ch].vbl_length--; \
278:                 \
279:                    /* envelope decay at a rate of (env_delay + 1) / 240 secs */ \
280:                    apu.rectangle[ch].env_phase -= 4; /* 240/60 */ \
281:                    while (apu.rectangle[ch].env_phase < 0) \
282:                    { \
283:                       apu.rectangle[ch].env_phase += apu.rectangle[ch].env_delay; \
284:                 \
285:                       if (apu.rectangle[ch].holdnote) \
286:                          apu.rectangle[ch].env_vol = (apu.rectangle[ch].env_vol + 1) & 0x0F; \
287:                       else if (apu.rectangle[ch].env_vol < 0x0F) \
288:                          apu.rectangle[ch].env_vol++; \
289:                    } \
290:                 \
291:                    /* TODO: find true relation of freq_limit to register values */ \
292:                    if (apu.rectangle[ch].freq < 8 || (false == apu.rectangle[ch].sweep_inc && apu.rectangle[ch].freq > apu.rectangle[ch].freq_limit)) \
293:                       return APU_RECTANGLE_OUTPUT(ch); \
294:                 \
295:                    /* frequency sweeping at a rate of (sweep_delay + 1) / 120 secs */ \
296:                    if (apu.rectangle[ch].sweep_on && apu.rectangle[ch].sweep_shifts) \
297:                    { \
298:                       apu.rectangle[ch].sweep_phase -= 2; /* 120/60 */ \
299:                       while (apu.rectangle[ch].sweep_phase < 0) \
300:                       { \
301:                          apu.rectangle[ch].sweep_phase += apu.rectangle[ch].sweep_delay; \
302:                 \
303:                          if (apu.rectangle[ch].sweep_inc) /* ramp up */ \
304:                          { \
305:                             if (0 == ch) \
306:                                apu.rectangle[ch].freq += ~(apu.rectangle[ch].freq >> apu.rectangle[ch].sweep_shifts); \
307:                             else \
308:                                apu.rectangle[ch].freq -= (apu.rectangle[ch].freq >> apu.rectangle[ch].sweep_shifts); \
309:                          } \
310:                          else /* ramp down */ \
311:                          { \
312:                             apu.rectangle[ch].freq += (apu.rectangle[ch].freq >> apu.rectangle[ch].sweep_shifts); \
313:                          } \
314:                       } \
315:                    } \
316:                 \
317:                    apu.rectangle[ch].accum -= apu.cycle_rate; \
318:                    if (apu.rectangle[ch].accum >= 0) \
319:                       return APU_RECTANGLE_OUTPUT(ch); \
320:                 \
321:                    while (apu.rectangle[ch].accum < 0) \
322:                    { \
323:                       apu.rectangle[ch].accum += (apu.rectangle[ch].freq + 1); \
324:                       apu.rectangle[ch].adder = (apu.rectangle[ch].adder + 1) & 0x0F; \
325:                    } \
326:                 \
327:                    if (apu.rectangle[ch].fixed_envelope) \
328:                       output = apu.rectangle[ch].volume << 8; /* fixed volume */ \
329:                    else \
330:                       output = (apu.rectangle[ch].env_vol ^ 0x0F) << 8; \
331:                 \
332:                    if (0 == apu.rectangle[ch].adder) \
333:                       apu.rectangle[ch].output_vol = output; \
334:                    else if (apu.rectangle[ch].adder == apu.rectangle[ch].duty_flip) \
335:                       apu.rectangle[ch].output_vol = -output; \
336:                 \
337:                    return APU_RECTANGLE_OUTPUT(ch); \
338:                 }
339:                 
340:                 #endif /* !APU_OVERSAMPLE */
341:                 
342:                 /* generate the functions */
343:                 APU_MAKE_RECTANGLE(0)
9D01CE50  260292F4   ADDIU V0, S0, -27916
9D01CE54  8C430010   LW V1, 16(V0)
9D01CE58  000389C3   SRA S1, V1, 7
9D01CE5C  00718823   SUBU S1, V1, S1
9D01CE60  AC510010   SW S1, 16(V0)
9D01CE64  8C420004   LW V0, 4(V0)
9D01CE68  10400086   BEQ V0, ZERO, 0x9D01D084
9D01CE6C  260292F4   ADDIU V0, S0, -27916
9D01CE70  8C420044   LW V0, 68(V0)
9D01CE74  10400083   BEQ V0, ZERO, 0x9D01D084
9D01CE78  260392F4   ADDIU V1, S0, -27916
9D01CE7C  8C650018   LW A1, 24(V1)
9D01CE80  54A00004   BNEL A1, ZERO, 0x9D01CE94
9D01CE84  260292F4   ADDIU V0, S0, -27916
9D01CE88  2442FFFF   ADDIU V0, V0, -1
9D01CE8C  AC620044   SW V0, 68(V1)
9D01CE90  260292F4   ADDIU V0, S0, -27916
9D01CE94  90430040   LBU V1, 64(V0)
9D01CE98  8C46003C   LW A2, 60(V0)
9D01CE9C  8C420038   LW V0, 56(V0)
9D01CEA0  0B4073B4   J 0x9D01CED0
9D01CEA4  2442FFFC   ADDIU V0, V0, -4
9D01CEA8  50A00004   BEQL A1, ZERO, 0x9D01CEBC
9D01CEAC  2C64000F   SLTIU A0, V1, 15
9D01CEB0  24630001   ADDIU V1, V1, 1
9D01CEB4  0B4073B3   J 0x9D01CECC
9D01CEB8  3063000F   ANDI V1, V1, 15
9D01CEBC  50800004   BEQL A0, ZERO, 0x9D01CED0
9D01CEC0  00461021   ADDU V0, V0, A2
9D01CEC4  24630001   ADDIU V1, V1, 1
9D01CEC8  306300FF   ANDI V1, V1, 255
9D01CECC  00461021   ADDU V0, V0, A2
9D01CED0  0440FFF5   BLTZ V0, 0x9D01CEA8
9D01CED4  00402021   ADDU A0, V0, ZERO
9D01CED8  260292F4   ADDIU V0, S0, -27916
9D01CEDC  AC440038   SW A0, 56(V0)
9D01CEE0  A0430040   SB V1, 64(V0)
9D01CEE4  8C42000C   LW V0, 12(V0)
9D01CEE8  28430008   SLTI V1, V0, 8
9D01CEEC  14600065   BNE V1, ZERO, 0x9D01D084
9D01CEF0  260392F4   ADDIU V1, S0, -27916
9D01CEF4  8C640030   LW A0, 48(V1)
9D01CEF8  54800005   BNEL A0, ZERO, 0x9D01CF10
9D01CEFC  260292F4   ADDIU V0, S0, -27916
9D01CF00  8C630034   LW V1, 52(V1)
9D01CF04  0062102A   SLT V0, V1, V0
9D01CF08  1440005E   BNE V0, ZERO, 0x9D01D084
9D01CF0C  260292F4   ADDIU V0, S0, -27916
9D01CF10  8C420028   LW V0, 40(V0)
9D01CF14  10400017   BEQ V0, ZERO, 0x9D01CF74
9D01CF18  261792F4   ADDIU S7, S0, -27916
9D01CF1C  260292F4   ADDIU V0, S0, -27916
9D01CF20  9045002C   LBU A1, 44(V0)
9D01CF24  50A00014   BEQL A1, ZERO, 0x9D01CF78
9D01CF28  8EE40008   LW A0, 8(S7)
9D01CF2C  8C43000C   LW V1, 12(V0)
9D01CF30  8C470024   LW A3, 36(V0)
9D01CF34  8C420020   LW V0, 32(V0)
9D01CF38  0B4073D7   J 0x9D01CF5C
9D01CF3C  2442FFFE   ADDIU V0, V0, -2
9D01CF40  10800004   BEQ A0, ZERO, 0x9D01CF54
9D01CF44  00A33007   SRAV A2, V1, A1
9D01CF48  00063027   NOR A2, ZERO, A2
9D01CF4C  0B4073D6   J 0x9D01CF58
9D01CF50  00C31821   ADDU V1, A2, V1
9D01CF54  00C31821   ADDU V1, A2, V1
9D01CF58  00471021   ADDU V0, V0, A3
9D01CF5C  0440FFF8   BLTZ V0, 0x9D01CF40
9D01CF60  00403021   ADDU A2, V0, ZERO
9D01CF64  260292F4   ADDIU V0, S0, -27916
9D01CF68  AC43000C   SW V1, 12(V0)
9D01CF6C  AC460020   SW A2, 32(V0)
9D01CF70  261792F4   ADDIU S7, S0, -27916
9D01CF74  8EE40008   LW A0, 8(S7)
9D01CF78  0F40CFF8   JAL __subsf3
9D01CF7C  8EE5014C   LW A1, 332(S7)
9D01CF80  0040F021   ADDU FP, V0, ZERO
9D01CF84  AEE20008   SW V0, 8(S7)
9D01CF88  00002021   ADDU A0, ZERO, ZERO
9D01CF8C  0F40E8E3   JAL __lesf2
9D01CF90  00402821   ADDU A1, V0, ZERO
9D01CF94  1840003C   BLEZ V0, 0x9D01D088
9D01CF98  32420002   ANDI V0, S2, 2
9D01CF9C  8EE20014   LW V0, 20(S7)
9D01CFA0  10400005   BEQ V0, ZERO, 0x9D01CFB8
9D01CFA4  260292F4   ADDIU V0, S0, -27916
9D01CFA8  92E2001C   LBU V0, 28(S7)
9D01CFAC  00021200   SLL V0, V0, 8
9D01CFB0  0B4073F2   J 0x9D01CFC8
9D01CFB4  AFA20014   SW V0, 20(SP)
9D01CFB8  90420040   LBU V0, 64(V0)
9D01CFBC  3842000F   XORI V0, V0, 15
9D01CFC0  00021200   SLL V0, V0, 8
9D01CFC4  AFA20014   SW V0, 20(SP)
9D01CFC8  03C02021   ADDU A0, FP, ZERO
9D01CFCC  0F40E8E3   JAL __lesf2
9D01CFD0  00002821   ADDU A1, ZERO, ZERO
9D01CFD4  04410022   BGEZ V0, 0x9D01D060
9D01CFD8  261192F4   ADDIU S1, S0, -27916
9D01CFDC  8E24000C   LW A0, 12(S1)
9D01CFE0  0F40ECB4   JAL sitofp
9D01CFE4  24840001   ADDIU A0, A0, 1
9D01CFE8  AFA20018   SW V0, 24(SP)
9D01CFEC  8E22004C   LW V0, 76(S1)
9D01CFF0  AFA2001C   SW V0, 28(SP)
9D01CFF4  92310048   LBU S1, 72(S1)
9D01CFF8  AFA00010   SW ZERO, 16(SP)
9D01CFFC  0000B821   ADDU S7, ZERO, ZERO
9D01D000  03C02021   ADDU A0, FP, ZERO
9D01D004  0F40CFFA   JAL fpadd
9D01D008  8FA50018   LW A1, 24(SP)
9D01D00C  0040F021   ADDU FP, V0, ZERO
9D01D010  26310001   ADDIU S1, S1, 1
9D01D014  3231000F   ANDI S1, S1, 15
9D01D018  8FA4001C   LW A0, 28(SP)
9D01D01C  0224182A   SLT V1, S1, A0
9D01D020  8FA50014   LW A1, 20(SP)
9D01D024  02E51021   ADDU V0, S7, A1
9D01D028  02E5B823   SUBU S7, S7, A1
9D01D02C  0043B80B   MOVN S7, V0, V1
9D01D030  8FA60010   LW A2, 16(SP)
9D01D034  24C60001   ADDIU A2, A2, 1
9D01D038  AFA60010   SW A2, 16(SP)
9D01D03C  03C02021   ADDU A0, FP, ZERO
9D01D040  0F40E8E3   JAL __lesf2
9D01D044  00002821   ADDU A1, ZERO, ZERO
9D01D048  0440FFEE   BLTZ V0, 0x9D01D004
9D01D04C  03C02021   ADDU A0, FP, ZERO
9D01D050  260292F4   ADDIU V0, S0, -27916
9D01D054  AC5E0008   SW FP, 8(V0)
9D01D058  0B40741A   J 0x9D01D068
9D01D05C  A0510048   SB S1, 72(V0)
9D01D060  AFA00010   SW ZERO, 16(SP)
9D01D064  0000B821   ADDU S7, ZERO, ZERO
9D01D068  8FA30010   LW V1, 16(SP)
9D01D06C  02E3001A   DIV S7, V1
9D01D070  006001F4   TEQ V1, ZERO
9D01D074  0000B812   MFLO S7
9D01D078  00008812   MFLO S1
9D01D07C  260292F4   ADDIU V0, S0, -27916
9D01D080  AC570010   SW S7, 16(V0)
344:                 APU_MAKE_RECTANGLE(1)
9D01D094  260292F4   ADDIU V0, S0, -27916
9D01D098  8C430060   LW V1, 96(V0)
9D01D09C  0003F1C3   SRA FP, V1, 7
9D01D0A0  007EF023   SUBU FP, V1, FP
9D01D0A4  AC5E0060   SW FP, 96(V0)
9D01D0A8  8C420054   LW V0, 84(V0)
9D01D0AC  10400089   BEQ V0, ZERO, 0x9D01D2D4
9D01D0B0  03C01821   ADDU V1, FP, ZERO
9D01D0B4  260292F4   ADDIU V0, S0, -27916
9D01D0B8  8C420094   LW V0, 148(V0)
9D01D0BC  50400086   BEQL V0, ZERO, 0x9D01D2D8
9D01D0C0  02238821   ADDU S1, S1, V1
9D01D0C4  260392F4   ADDIU V1, S0, -27916
9D01D0C8  8C650068   LW A1, 104(V1)
9D01D0CC  54A00004   BNEL A1, ZERO, 0x9D01D0E0
9D01D0D0  260292F4   ADDIU V0, S0, -27916
9D01D0D4  2442FFFF   ADDIU V0, V0, -1
9D01D0D8  AC620094   SW V0, 148(V1)
9D01D0DC  260292F4   ADDIU V0, S0, -27916
9D01D0E0  90430090   LBU V1, 144(V0)
9D01D0E4  8C46008C   LW A2, 140(V0)
9D01D0E8  8C420088   LW V0, 136(V0)
9D01D0EC  0B407447   J 0x9D01D11C
9D01D0F0  2442FFFC   ADDIU V0, V0, -4
9D01D0F4  50A00004   BEQL A1, ZERO, 0x9D01D108
9D01D0F8  2C64000F   SLTIU A0, V1, 15
9D01D0FC  24630001   ADDIU V1, V1, 1
9D01D100  0B407446   J 0x9D01D118
9D01D104  3063000F   ANDI V1, V1, 15
9D01D108  50800004   BEQL A0, ZERO, 0x9D01D11C
9D01D10C  00461021   ADDU V0, V0, A2
9D01D110  24630001   ADDIU V1, V1, 1
9D01D114  306300FF   ANDI V1, V1, 255
9D01D118  00461021   ADDU V0, V0, A2
9D01D11C  0440FFF5   BLTZ V0, 0x9D01D0F4
9D01D120  00402021   ADDU A0, V0, ZERO
9D01D124  260292F4   ADDIU V0, S0, -27916
9D01D128  AC440088   SW A0, 136(V0)
9D01D12C  A0430090   SB V1, 144(V0)
9D01D130  8C42005C   LW V0, 92(V0)
9D01D134  28440008   SLTI A0, V0, 8
9D01D138  14800066   BNE A0, ZERO, 0x9D01D2D4
9D01D13C  03C01821   ADDU V1, FP, ZERO
9D01D140  260392F4   ADDIU V1, S0, -27916
9D01D144  8C640080   LW A0, 128(V1)
9D01D148  54800006   BNEL A0, ZERO, 0x9D01D164
9D01D14C  260292F4   ADDIU V0, S0, -27916
9D01D150  8C630084   LW V1, 132(V1)
9D01D154  0062102A   SLT V0, V1, V0
9D01D158  1440005E   BNE V0, ZERO, 0x9D01D2D4
9D01D15C  03C01821   ADDU V1, FP, ZERO
9D01D160  260292F4   ADDIU V0, S0, -27916
9D01D164  8C420078   LW V0, 120(V0)
9D01D168  10400016   BEQ V0, ZERO, 0x9D01D1C4
9D01D16C  261792F4   ADDIU S7, S0, -27916
9D01D170  260292F4   ADDIU V0, S0, -27916
9D01D174  9045007C   LBU A1, 124(V0)
9D01D178  50A00013   BEQL A1, ZERO, 0x9D01D1C8
9D01D17C  8EE40058   LW A0, 88(S7)
9D01D180  8C43005C   LW V1, 92(V0)
9D01D184  8C470074   LW A3, 116(V0)
9D01D188  8C420070   LW V0, 112(V0)
9D01D18C  0B40746B   J 0x9D01D1AC
9D01D190  2442FFFE   ADDIU V0, V0, -2
9D01D194  10800003   BEQ A0, ZERO, 0x9D01D1A4
9D01D198  00A33007   SRAV A2, V1, A1
9D01D19C  0B40746A   J 0x9D01D1A8
9D01D1A0  00661823   SUBU V1, V1, A2
9D01D1A4  00C31821   ADDU V1, A2, V1
9D01D1A8  00471021   ADDU V0, V0, A3
9D01D1AC  0440FFF9   BLTZ V0, 0x9D01D194
9D01D1B0  00403021   ADDU A2, V0, ZERO
9D01D1B4  260292F4   ADDIU V0, S0, -27916
9D01D1B8  AC43005C   SW V1, 92(V0)
9D01D1BC  AC460070   SW A2, 112(V0)
9D01D1C0  261792F4   ADDIU S7, S0, -27916
9D01D1C4  8EE40058   LW A0, 88(S7)
9D01D1C8  0F40CFF8   JAL __subsf3
9D01D1CC  8EE5014C   LW A1, 332(S7)
9D01D1D0  AFA20010   SW V0, 16(SP)
9D01D1D4  AEE20058   SW V0, 88(S7)
9D01D1D8  00002021   ADDU A0, ZERO, ZERO
9D01D1DC  0F40E8E3   JAL __lesf2
9D01D1E0  00402821   ADDU A1, V0, ZERO
9D01D1E4  1840003B   BLEZ V0, 0x9D01D2D4
9D01D1E8  03C01821   ADDU V1, FP, ZERO
9D01D1EC  8EE20064   LW V0, 100(S7)
9D01D1F0  10400005   BEQ V0, ZERO, 0x9D01D208
9D01D1F4  260292F4   ADDIU V0, S0, -27916
9D01D1F8  92E2006C   LBU V0, 108(S7)
9D01D1FC  00021200   SLL V0, V0, 8
9D01D200  0B407486   J 0x9D01D218
9D01D204  AFA20018   SW V0, 24(SP)
9D01D208  90420090   LBU V0, 144(V0)
9D01D20C  3842000F   XORI V0, V0, 15
9D01D210  00021200   SLL V0, V0, 8
9D01D214  AFA20018   SW V0, 24(SP)
9D01D218  8FA40010   LW A0, 16(SP)
9D01D21C  0F40E8E3   JAL __lesf2
9D01D220  00002821   ADDU A1, ZERO, ZERO
9D01D224  04410023   BGEZ V0, 0x9D01D2B4
9D01D228  261792F4   ADDIU S7, S0, -27916
9D01D22C  8EE4005C   LW A0, 92(S7)
9D01D230  0F40ECB4   JAL sitofp
9D01D234  24840001   ADDIU A0, A0, 1
9D01D238  AFA2001C   SW V0, 28(SP)
9D01D23C  8EE4009C   LW A0, 156(S7)
9D01D240  AFA40020   SW A0, 32(SP)
9D01D244  92F70098   LBU S7, 152(S7)
9D01D248  AFA00014   SW ZERO, 20(SP)
9D01D24C  0000F021   ADDU FP, ZERO, ZERO
9D01D250  8FA40010   LW A0, 16(SP)
9D01D254  0F40CFFA   JAL fpadd
9D01D258  8FA5001C   LW A1, 28(SP)
9D01D25C  AFA20010   SW V0, 16(SP)
9D01D260  26F70001   ADDIU S7, S7, 1
9D01D264  32F7000F   ANDI S7, S7, 15
9D01D268  8FA50020   LW A1, 32(SP)
9D01D26C  02E5182A   SLT V1, S7, A1
9D01D270  8FA60018   LW A2, 24(SP)
9D01D274  03C61021   ADDU V0, FP, A2
9D01D278  03C6F023   SUBU FP, FP, A2
9D01D27C  0043F00B   MOVN FP, V0, V1
9D01D280  8FA20014   LW V0, 20(SP)
9D01D284  24420001   ADDIU V0, V0, 1
9D01D288  AFA20014   SW V0, 20(SP)
9D01D28C  8FA40010   LW A0, 16(SP)
9D01D290  0F40E8E3   JAL __lesf2
9D01D294  00002821   ADDU A1, ZERO, ZERO
9D01D298  0440FFEE   BLTZ V0, 0x9D01D254
9D01D29C  8FA40010   LW A0, 16(SP)
9D01D2A0  260292F4   ADDIU V0, S0, -27916
9D01D2A4  8FA30010   LW V1, 16(SP)
9D01D2A8  AC430058   SW V1, 88(V0)
9D01D2AC  0B4074AF   J 0x9D01D2BC
9D01D2B0  A0570098   SB S7, 152(V0)
9D01D2B4  AFA00014   SW ZERO, 20(SP)
9D01D2B8  0000F021   ADDU FP, ZERO, ZERO
9D01D2BC  8FA20014   LW V0, 20(SP)
9D01D2C0  03C2001A   DIV FP, V0
9D01D2C4  004001F4   TEQ V0, ZERO
9D01D2C8  00001812   MFLO V1
9D01D2CC  260292F4   ADDIU V0, S0, -27916
9D01D2D0  AC430060   SW V1, 96(V0)
345:                 
346:                 
347:                 /* TRIANGLE WAVE
348:                 ** =============
349:                 ** reg0: 7=holdnote, 6-0=linear length counter
350:                 ** reg2: low 8 bits of frequency
351:                 ** reg3: 7-3=length counter, 2-0=high 3 bits of frequency
352:                 */
353:                 static int32 apu_triangle(void)
354:                 {
355:                    APU_VOLUME_DECAY(apu.triangle.output_vol);
9D01D2E8  260292F4   ADDIU V0, S0, -27916
9D01D2EC  8C4300B0   LW V1, 176(V0)
9D01D2F0  000321C3   SRA A0, V1, 7
9D01D2F4  00641823   SUBU V1, V1, A0
9D01D2F8  AC4300B0   SW V1, 176(V0)
356:                 
357:                    if (false == apu.triangle.enabled || 0 == apu.triangle.vbl_length)
9D01D2FC  8C4200A4   LW V0, 164(V0)
9D01D300  10400004   BEQ V0, ZERO, 0x9D01D314
9D01D304  260292F4   ADDIU V0, S0, -27916
9D01D308  8C4200C4   LW V0, 196(V0)
9D01D30C  14400004   BNE V0, ZERO, 0x9D01D320
9D01D310  260492F4   ADDIU A0, S0, -27916
358:                       return APU_TRIANGLE_OUTPUT;
9D01D314  00031083   SRA V0, V1, 2
9D01D318  0B40750F   J 0x9D01D43C
9D01D31C  00621821   ADDU V1, V1, V0
359:                 
360:                    if (apu.triangle.counter_started)
9D01D320  8C8400BC   LW A0, 188(A0)
9D01D324  5080000B   BEQL A0, ZERO, 0x9D01D354
9D01D328  260292F4   ADDIU V0, S0, -27916
361:                    {
362:                       if (apu.triangle.linear_length > 0)
9D01D32C  260492F4   ADDIU A0, S0, -27916
9D01D330  8C8400C8   LW A0, 200(A0)
9D01D334  18800167   BLEZ A0, 0x9D01D8D4
9D01D338  260592F4   ADDIU A1, S0, -27916
363:                          apu.triangle.linear_length--;
9D01D33C  2484FFFF   ADDIU A0, A0, -1
9D01D340  0B407635   J 0x9D01D8D4
9D01D344  ACA400C8   SW A0, 200(A1)
364:                       if (apu.triangle.vbl_length && false == apu.triangle.holdnote)
9D01D8D4  260492F4   ADDIU A0, S0, -27916
9D01D8D8  8C8400B8   LW A0, 184(A0)
9D01D8DC  1080FE9A   BEQ A0, ZERO, 0x9D01D348
9D01D8E0  260492F4   ADDIU A0, S0, -27916
365:                          apu.triangle.vbl_length--;
9D01D348  2442FFFF   ADDIU V0, V0, -1
9D01D34C  0B4074E0   J 0x9D01D380
9D01D350  AC8200C4   SW V0, 196(A0)
366:                    }
367:                    else if (false == apu.triangle.holdnote && apu.triangle.write_latency)
9D01D354  8C4200B8   LW V0, 184(V0)
9D01D358  1440000A   BNE V0, ZERO, 0x9D01D384
9D01D35C  260292F4   ADDIU V0, S0, -27916
9D01D360  8C4200C0   LW V0, 192(V0)
9D01D364  50400007   BEQL V0, ZERO, 0x9D01D384
9D01D368  260292F4   ADDIU V0, S0, -27916
368:                    {
369:                       if (--apu.triangle.write_latency == 0)
9D01D36C  2442FFFF   ADDIU V0, V0, -1
9D01D370  260492F4   ADDIU A0, S0, -27916
9D01D374  14400002   BNE V0, ZERO, 0x9D01D380
9D01D378  AC8200C0   SW V0, 192(A0)
370:                          apu.triangle.counter_started = true;
9D01CE34  24160001   ADDIU S6, ZERO, 1
9D01D37C  AC9600BC   SW S6, 188(A0)
371:                    }
372:                 
373:                    if (0 == apu.triangle.linear_length || apu.triangle.freq < 4) /* inaudible */
9D01D380  260292F4   ADDIU V0, S0, -27916
9D01D384  8C4200C8   LW V0, 200(V0)
9D01D388  10400006   BEQ V0, ZERO, 0x9D01D3A4
9D01D38C  260292F4   ADDIU V0, S0, -27916
9D01D390  8C4200AC   LW V0, 172(V0)
9D01D394  AFA20014   SW V0, 20(SP)
9D01D398  28420004   SLTI V0, V0, 4
9D01D39C  10400004   BEQ V0, ZERO, 0x9D01D3B0
9D01D3A0  261792F4   ADDIU S7, S0, -27916
9D01D8E4  0B4074E1   J 0x9D01D384
9D01D8E8  260292F4   ADDIU V0, S0, -27916
374:                       return APU_TRIANGLE_OUTPUT;
9D01D3A4  00031083   SRA V0, V1, 2
9D01D3A8  0B40750F   J 0x9D01D43C
9D01D3AC  00621821   ADDU V1, V1, V0
375:                 
376:                    apu.triangle.accum -= apu.cycle_rate; \
9D01D3B0  8EE400A8   LW A0, 168(S7)
9D01D3B4  0F40CFF8   JAL __subsf3
9D01D3B8  8EE5014C   LW A1, 332(S7)
9D01D3BC  8EE300B0   LW V1, 176(S7)
9D01D3C0  AFA30010   SW V1, 16(SP)
9D01D3C4  92FE00B4   LBU FP, 180(S7)
9D01D3C8  0B407504   J 0x9D01D410
9D01D3CC  0040B821   ADDU S7, V0, ZERO
377:                    while (apu.triangle.accum < 0)
9D01D410  02E02021   ADDU A0, S7, ZERO
9D01D414  0F40E8E3   JAL __lesf2
9D01D418  00002821   ADDU A1, ZERO, ZERO
9D01D41C  0440FFEC   BLTZ V0, 0x9D01D3D0
9D01D420  260292F4   ADDIU V0, S0, -27916
9D01D424  8FA50010   LW A1, 16(SP)
9D01D428  AC4500B0   SW A1, 176(V0)
9D01D42C  AC5700A8   SW S7, 168(V0)
9D01D430  A05E00B4   SB FP, 180(V0)
378:                    {
379:                       apu.triangle.accum += apu.triangle.freq;
9D01D3D0  0F40ECB4   JAL sitofp
9D01D3D4  8FA40014   LW A0, 20(SP)
9D01D3D8  00402021   ADDU A0, V0, ZERO
9D01D3DC  0F40CFFA   JAL fpadd
9D01D3E0  02E02821   ADDU A1, S7, ZERO
9D01D408  0040B821   ADDU S7, V0, ZERO
380:                       apu.triangle.adder = (apu.triangle.adder + 1) & 0x1F;
9D01D3E4  27DE0001   ADDIU FP, FP, 1
9D01D3E8  33DE00FF   ANDI FP, FP, 255
9D01D40C  33DE001F   ANDI FP, FP, 31
381:                 
382:                       if (apu.triangle.adder & 0x10)
9D01D3EC  33C50010   ANDI A1, FP, 16
9D01D3F0  30A500FF   ANDI A1, A1, 255
383:                          apu.triangle.output_vol -= (2 << 8);
9D01D3F4  8FA40010   LW A0, 16(SP)
9D01D3F8  2483FE00   ADDIU V1, A0, -512
9D01D3FC  24840200   ADDIU A0, A0, 512
9D01D400  0085180A   MOVZ V1, A0, A1
9D01D404  AFA30010   SW V1, 16(SP)
384:                       else
385:                          apu.triangle.output_vol += (2 << 8);
386:                    }
387:                 
388:                    return APU_TRIANGLE_OUTPUT;
9D01D434  00051883   SRA V1, A1, 2
9D01D438  00A31821   ADDU V1, A1, V1
389:                 }
390:                 
391:                 
392:                 /* WHITE NOISE CHANNEL
393:                 ** ===================
394:                 ** reg0: 0-3=volume, 4=envelope, 5=hold
395:                 ** reg2: 7=small(93 byte) sample,3-0=freq lookup
396:                 ** reg3: 7-4=vbl length counter
397:                 */
398:                 /* TODO: AAAAAAAAAAAAAAAAAAAAAAAA!  #ifdef MADNESS! */
399:                 static int32 apu_noise(void)
400:                 {
401:                    int32 outvol;
402:                 
403:                 #if defined(APU_OVERSAMPLE) && defined(REALTIME_NOISE)
404:                 #else /* !(APU_OVERSAMPLE && REALTIME_NOISE) */
405:                    int32 noise_bit;
406:                 #endif /* !(APU_OVERSAMPLE && REALTIME_NOISE) */
407:                 #ifdef APU_OVERSAMPLE
408:                    int num_times;
409:                    int32 total;
410:                 #endif /* APU_OVERSAMPLE */
411:                 
412:                    APU_VOLUME_DECAY(apu.noise.output_vol);
9D01D450  260292F4   ADDIU V0, S0, -27916
9D01D454  8C4300DC   LW V1, 220(V0)
9D01D458  0003B9C3   SRA S7, V1, 7
9D01D45C  0077B823   SUBU S7, V1, S7
9D01D460  AC5700DC   SW S7, 220(V0)
413:                 
414:                    if (false == apu.noise.enabled || 0 == apu.noise.vbl_length)
9D01D464  8C4200D0   LW V0, 208(V0)
9D01D468  10400004   BEQ V0, ZERO, 0x9D01D47C
9D01D46C  260292F4   ADDIU V0, S0, -27916
9D01D470  8C4200F8   LW V0, 248(V0)
9D01D474  14400005   BNE V0, ZERO, 0x9D01D48C
9D01D478  260392F4   ADDIU V1, S0, -27916
415:                       return APU_NOISE_OUTPUT;
9D01D47C  00171040   SLL V0, S7, 1
9D01D480  02E2B821   ADDU S7, S7, V0
9D01D484  0B407591   J 0x9D01D644
9D01D488  0017B883   SRA S7, S7, 2
416:                 
417:                    /* vbl length counter */
418:                    if (false == apu.noise.holdnote)
9D01D48C  8C6500F0   LW A1, 240(V1)
9D01D490  54A00004   BNEL A1, ZERO, 0x9D01D4A4
9D01D494  260292F4   ADDIU V0, S0, -27916
419:                       apu.noise.vbl_length--;
9D01D498  2442FFFF   ADDIU V0, V0, -1
9D01D49C  AC6200F8   SW V0, 248(V1)
9D01D4A0  260292F4   ADDIU V0, S0, -27916
9D01D4A4  904300E8   LBU V1, 232(V0)
9D01D4A8  8C4600E4   LW A2, 228(V0)
420:                 
421:                    /* envelope decay at a rate of (env_delay + 1) / 240 secs */
422:                    apu.noise.env_phase -= 4; /* 240/60 */
9D01D4AC  8C4200E0   LW V0, 224(V0)
9D01D4B0  0B407538   J 0x9D01D4E0
9D01D4B4  2442FFFC   ADDIU V0, V0, -4
423:                    while (apu.noise.env_phase < 0)
9D01D4E0  0440FFF5   BLTZ V0, 0x9D01D4B8
9D01D4E4  00000000   NOP
9D01D4E8  3C06A001   LUI A2, -24575
9D01D4EC  24C692F4   ADDIU A2, A2, -27916
9D01D4F0  ACC200E0   SW V0, 224(A2)
9D01D4F4  A0C300E8   SB V1, 232(A2)
424:                    {
425:                       apu.noise.env_phase += apu.noise.env_delay;
426:                 
427:                       if (apu.noise.holdnote)
9D01D4B8  10A00004   BEQ A1, ZERO, 0x9D01D4CC
9D01D4BC  2C64000F   SLTIU A0, V1, 15
428:                          apu.noise.env_vol = (apu.noise.env_vol + 1) & 0x0F;
9D01D4C0  24630001   ADDIU V1, V1, 1
9D01D4C4  0B407537   J 0x9D01D4DC
9D01D4C8  3063000F   ANDI V1, V1, 15
429:                       else if (apu.noise.env_vol < 0x0F)
9D01D4CC  50800004   BEQL A0, ZERO, 0x9D01D4E0
9D01D4D0  00461021   ADDU V0, V0, A2
430:                          apu.noise.env_vol++;
9D01D4D4  24630001   ADDIU V1, V1, 1
9D01D4D8  306300FF   ANDI V1, V1, 255
9D01D4DC  00461021   ADDU V0, V0, A2
431:                    }
432:                 
433:                    apu.noise.accum -= apu.cycle_rate;
9D01D4F8  8CC400D4   LW A0, 212(A2)
9D01D4FC  0F40CFF8   JAL __subsf3
9D01D500  8CC5014C   LW A1, 332(A2)
9D01D504  0040F021   ADDU FP, V0, ZERO
9D01D508  3C02A001   LUI V0, -24575
9D01D50C  244292F4   ADDIU V0, V0, -27916
9D01D510  AC5E00D4   SW FP, 212(V0)
434:                    if (apu.noise.accum >= 0)
9D01D514  00002021   ADDU A0, ZERO, ZERO
9D01D518  0F40E8E3   JAL __lesf2
9D01D51C  03C02821   ADDU A1, FP, ZERO
9D01D520  1C400004   BGTZ V0, 0x9D01D534
9D01D524  00171040   SLL V0, S7, 1
435:                       return APU_NOISE_OUTPUT;
9D01D528  02E2B821   ADDU S7, S7, V0
9D01D52C  0B407591   J 0x9D01D644
9D01D530  0017B883   SRA S7, S7, 2
436:                    
437:                 #ifdef APU_OVERSAMPLE
438:                    if (apu.noise.fixed_envelope)
9D01D534  260292F4   ADDIU V0, S0, -27916
9D01D538  8C4200EC   LW V0, 236(V0)
9D01D53C  10400005   BEQ V0, ZERO, 0x9D01D554
9D01D540  260292F4   ADDIU V0, S0, -27916
439:                       outvol = apu.noise.volume << 8; /* fixed volume */
9D01D544  904200F4   LBU V0, 244(V0)
9D01D548  00021200   SLL V0, V0, 8
9D01D54C  0B407559   J 0x9D01D564
9D01D550  AFA20018   SW V0, 24(SP)
440:                    else
441:                       outvol = (apu.noise.env_vol ^ 0x0F) << 8;
9D01D554  904200E8   LBU V0, 232(V0)
9D01D558  3842000F   XORI V0, V0, 15
9D01D55C  00021200   SLL V0, V0, 8
9D01D560  AFA20018   SW V0, 24(SP)
442:                 
443:                    num_times = total = 0;
9D01D590  AFA00014   SW ZERO, 20(SP)
9D01D594  AFA00010   SW ZERO, 16(SP)
9D01D614  AFA00014   SW ZERO, 20(SP)
9D01D618  AFA00010   SW ZERO, 16(SP)
444:                 #endif /* APU_OVERSAMPLE */
445:                 
446:                    while (apu.noise.accum < 0)
9D01D564  03C02021   ADDU A0, FP, ZERO
9D01D568  0F40E8E3   JAL __lesf2
9D01D56C  00002821   ADDU A1, ZERO, ZERO
9D01D570  04410028   BGEZ V0, 0x9D01D614
9D01D574  261792F4   ADDIU S7, S0, -27916
9D01D5F0  03C02021   ADDU A0, FP, ZERO
9D01D5F4  0F40E8E3   JAL __lesf2
9D01D5F8  00002821   ADDU A1, ZERO, ZERO
9D01D5FC  0440FFE7   BLTZ V0, 0x9D01D59C
9D01D600  03C02021   ADDU A0, FP, ZERO
9D01D604  260292F4   ADDIU V0, S0, -27916
9D01D608  AC5E00D4   SW FP, 212(V0)
9D01D60C  0B407587   J 0x9D01D61C
9D01D610  AF978018   SW S7, -32744(GP)
447:                    {
448:                       apu.noise.accum += apu.noise.freq;
9D01D578  0F40ECB4   JAL sitofp
9D01D57C  8EE400D8   LW A0, 216(S7)
9D01D580  AFA2001C   SW V0, 28(SP)
9D01D598  03C02021   ADDU A0, FP, ZERO
9D01D59C  0F40CFFA   JAL fpadd
9D01D5A0  8FA5001C   LW A1, 28(SP)
9D01D5A4  0040F021   ADDU FP, V0, ZERO
449:                 
450:                 #ifdef REALTIME_NOISE
451:                 
452:                 #ifdef APU_OVERSAMPLE
453:                       if (shift_register15(apu.noise.xor_tap))
454:                          total += outvol;
9D01D5C8  8FA50010   LW A1, 16(SP)
9D01D5CC  8FA60018   LW A2, 24(SP)
9D01D5D0  00A61821   ADDU V1, A1, A2
9D01D5D4  00A62023   SUBU A0, A1, A2
9D01D5D8  00561026   XOR V0, V0, S6
9D01D5DC  0082180A   MOVZ V1, A0, V0
9D01D5E0  AFA30010   SW V1, 16(SP)
455:                       else
456:                          total -= outvol;
457:                 
458:                       num_times++;
9D01D5E4  8FA20014   LW V0, 20(SP)
9D01D5E8  24420001   ADDIU V0, V0, 1
9D01D5EC  AFA20014   SW V0, 20(SP)
459:                 #else /* !APU_OVERSAMPLE */
460:                       noise_bit = shift_register15(apu.noise.xor_tap);
461:                 #endif /* !APU_OVERSAMPLE */
462:                 
463:                 #else /* !REALTIME_NOISE */
464:                       apu.noise.cur_pos++;
465:                 
466:                       if (apu.noise.short_sample)
467:                       {
468:                          if (APU_NOISE_93 == apu.noise.cur_pos)
469:                             apu.noise.cur_pos = 0;
470:                       }
471:                       else
472:                       {
473:                          if (APU_NOISE_32K == apu.noise.cur_pos)
474:                             apu.noise.cur_pos = 0;
475:                       }
476:                 
477:                 #ifdef APU_OVERSAMPLE
478:                       if (apu.noise.short_sample)
479:                          noise_bit = noise_short_lut[apu.noise.cur_pos];
480:                       else
481:                          noise_bit = noise_long_lut[apu.noise.cur_pos];
482:                 
483:                       if (noise_bit)
484:                          total += outvol;
485:                       else
486:                          total -= outvol;
487:                 
488:                       num_times++;
489:                 #endif /* APU_OVERSAMPLE */
490:                 #endif /* !REALTIME_NOISE */
491:                    }
492:                 
493:                 #ifdef APU_OVERSAMPLE
494:                    apu.noise.output_vol = total / num_times;
9D01D61C  8FA30010   LW V1, 16(SP)
9D01D620  8FA40014   LW A0, 20(SP)
9D01D624  0064001A   DIV V1, A0
9D01D628  008001F4   TEQ A0, ZERO
9D01D62C  0000B812   MFLO S7
9D01D630  260292F4   ADDIU V0, S0, -27916
9D01D634  AC5700DC   SW S7, 220(V0)
495:                 #else /* !APU_OVERSAMPLE */
496:                    if (apu.noise.fixed_envelope)
497:                       outvol = apu.noise.volume << 8; /* fixed volume */
498:                    else
499:                       outvol = (apu.noise.env_vol ^ 0x0F) << 8;
500:                 
501:                 #ifndef REALTIME_NOISE
502:                    if (apu.noise.short_sample)
503:                       noise_bit = noise_short_lut[apu.noise.cur_pos];
504:                    else
505:                       noise_bit = noise_long_lut[apu.noise.cur_pos];
506:                 #endif /* !REALTIME_NOISE */
507:                 
508:                    if (noise_bit)
509:                       apu.noise.output_vol = outvol;
510:                    else
511:                       apu.noise.output_vol = -outvol;
512:                 #endif /* !APU_OVERSAMPLE */
513:                 
514:                    return APU_NOISE_OUTPUT;
9D01D638  00171040   SLL V0, S7, 1
9D01D63C  02E2B821   ADDU S7, S7, V0
9D01D640  0017B883   SRA S7, S7, 2
515:                 }
516:                 
517:                 
518:                 INLINE void apu_dmcreload(void)
519:                 {
520:                    apu.dmc.address = apu.dmc.cached_addr;
9D01D710  8C630118   LW V1, 280(V1)
9D01DF60  3C02A001   LUI V0, -24575
521:                    apu.dmc.dma_length = apu.dmc.cached_dmalength;
9D01D718  8C430120   LW V1, 288(V0)
9D01DF70  8C430120   LW V1, 288(V0)
522:                    apu.dmc.irq_occurred = false;
9D01D720  0B4075D7   J 0x9D01D75C
9D01D724  AC400130   SW ZERO, 304(V0)
523:                 }
524:                 
525:                 /* DELTA MODULATION CHANNEL
526:                 ** =========================
527:                 ** reg0: 7=irq gen, 6=looping, 3-0=pointer to clock table
528:                 ** reg1: output dc level, 6 bits unsigned
529:                 ** reg2: 8 bits of 64-byte aligned address offset : $C000 + (value * 64)
530:                 ** reg3: length, (value * 16) + 1
531:                 */
532:                 static int32 apu_dmc(void)
533:                 {
534:                    int delta_bit;
535:                 
536:                    APU_VOLUME_DECAY(apu.dmc.output_vol);
9D01D658  8C430110   LW V1, 272(V0)
9D01D65C  000321C3   SRA A0, V1, 7
9D01D660  00641823   SUBU V1, V1, A0
9D01D664  AC430110   SW V1, 272(V0)
537:                 
538:                    /* only process when channel is alive */
539:                    if (apu.dmc.dma_length)
9D01D668  8C42011C   LW V0, 284(V0)
9D01D66C  1040005C   BEQ V0, ZERO, 0x9D01D7E0
9D01D670  261292F4   ADDIU S2, S0, -27916
540:                    {
541:                       apu.dmc.accum -= apu.cycle_rate;
9D01D674  8E440108   LW A0, 264(S2)
9D01D678  0F40CFF8   JAL __subsf3
9D01D67C  8E45014C   LW A1, 332(S2)
9D01D680  0B4075F1   J 0x9D01D7C4
9D01D684  AE420108   SW V0, 264(S2)
542:                       
543:                       while (apu.dmc.accum < 0)
9D01D7C4  260292F4   ADDIU V0, S0, -27916
9D01D7C8  8C570108   LW S7, 264(V0)
9D01D7CC  02E02021   ADDU A0, S7, ZERO
9D01D7D0  0F40E8E3   JAL __lesf2
9D01D7D4  00002821   ADDU A1, ZERO, ZERO
9D01D7D8  0440FFAB   BLTZ V0, 0x9D01D688
9D01D7DC  261292F4   ADDIU S2, S0, -27916
544:                       {
545:                          apu.dmc.accum += apu.dmc.freq;
9D01D688  0F40ECB4   JAL sitofp
9D01D68C  8E44010C   LW A0, 268(S2)
9D01D690  00402021   ADDU A0, V0, ZERO
9D01D694  0F40CFFA   JAL fpadd
9D01D698  02E02821   ADDU A1, S7, ZERO
9D01D69C  AE420108   SW V0, 264(S2)
546:                          
547:                          delta_bit = (apu.dmc.dma_length & 7) ^ 7;
9D01D6A0  8E52011C   LW S2, 284(S2)
9D01D6A4  00129027   NOR S2, ZERO, S2
9D01D6A8  32520007   ANDI S2, S2, 7
548:                          
549:                          if (7 == delta_bit)
9D01D6AC  16540011   BNE S2, S4, 0x9D01D6F4
9D01D6B0  260392F4   ADDIU V1, S0, -27916
550:                          {
551:                             apu.dmc.cur_byte = nes6502_getbyte(apu.dmc.address);
9D01D6B4  261792F4   ADDIU S7, S0, -27916
9D01D6B8  0F4028BE   JAL nes6502_getbyte
9D01D6BC  8EE40114   LW A0, 276(S7)
9D01D6C0  A2E20124   SB V0, 292(S7)
552:                             
553:                             /* steal a cycle from CPU*/
554:                             nes6502_burn(1);
9D01D6C4  0F404EA2   JAL nes6502_burn
9D01D6C8  02C02021   ADDU A0, S6, ZERO
555:                 
556:                             /* prevent wraparound */
557:                             if (0xFFFF == apu.dmc.address)
9D01D6CC  8EE20114   LW V0, 276(S7)
9D01D6D0  3405FFFF   ORI A1, ZERO, -1
9D01D6D4  14450004   BNE V0, A1, 0x9D01D6E8
9D01D6D8  260392F4   ADDIU V1, S0, -27916
558:                                apu.dmc.address = 0x8000;
9D01D6DC  34068000   ORI A2, ZERO, -32768
9D01D6E0  0B4075BD   J 0x9D01D6F4
9D01D6E4  AEE60114   SW A2, 276(S7)
559:                             else
560:                                apu.dmc.address++;
9D01D6E8  24420001   ADDIU V0, V0, 1
9D01D6EC  AC620114   SW V0, 276(V1)
561:                          }
562:                 
563:                          if (--apu.dmc.dma_length == 0)
9D01D6F0  260392F4   ADDIU V1, S0, -27916
9D01D6F4  8C62011C   LW V0, 284(V1)
9D01D6F8  2442FFFF   ADDIU V0, V0, -1
9D01D6FC  14400017   BNE V0, ZERO, 0x9D01D75C
9D01D700  AC62011C   SW V0, 284(V1)
564:                          {
565:                             /* if loop bit set, we're cool to retrigger sample */
566:                             if (apu.dmc.looping)
9D01D704  8C620128   LW V0, 296(V1)
9D01D708  10400007   BEQ V0, ZERO, 0x9D01D728
9D01D70C  00601021   ADDU V0, V1, ZERO
567:                             {
568:                                apu_dmcreload();
569:                             }
570:                             else
571:                             {
572:                                /* check to see if we should generate an irq */
573:                                if (apu.dmc.irq_gen)
9D01D728  260292F4   ADDIU V0, S0, -27916
9D01D72C  8C42012C   LW V0, 300(V0)
9D01D730  10400007   BEQ V0, ZERO, 0x9D01D750
9D01D734  260292F4   ADDIU V0, S0, -27916
574:                                {
575:                                   apu.dmc.irq_occurred = true;
9D01D738  AC560130   SW S6, 304(V0)
576:                                   if (apu.irq_callback)
9D01D73C  8C420160   LW V0, 352(V0)
9D01D740  50400004   BEQL V0, ZERO, 0x9D01D754
9D01D744  260292F4   ADDIU V0, S0, -27916
577:                                      apu.irq_callback();
9D01D748  0040F809   JALR V0
9D01D74C  00000000   NOP
578:                                }
579:                 
580:                                /* bodge for timestamp queue */
581:                                apu.dmc.enabled = false;
9D01D750  260292F4   ADDIU V0, S0, -27916
9D01D754  0B4075F8   J 0x9D01D7E0
9D01D758  AC400104   SW ZERO, 260(V0)
582:                                break;
583:                             }
584:                          }
585:                 
586:                          /* positive delta */
587:                          if (apu.dmc.cur_byte & (1 << delta_bit))
9D01D75C  260292F4   ADDIU V0, S0, -27916
9D01D760  90420124   LBU V0, 292(V0)
9D01D764  02429007   SRAV S2, V0, S2
9D01D768  32520001   ANDI S2, S2, 1
9D01D76C  1240000C   BEQ S2, ZERO, 0x9D01D7A0
9D01D770  260292F4   ADDIU V0, S0, -27916
588:                          {
589:                             if (apu.dmc.regs[1] < 0x7D)
9D01D774  90420101   LBU V0, 257(V0)
9D01D778  2C43007D   SLTIU V1, V0, 125
9D01D77C  50600012   BEQL V1, ZERO, 0x9D01D7C8
9D01D780  260292F4   ADDIU V0, S0, -27916
590:                             {
591:                                apu.dmc.regs[1] += 2;
9D01D784  260392F4   ADDIU V1, S0, -27916
9D01D788  24420002   ADDIU V0, V0, 2
9D01D78C  A0620101   SB V0, 257(V1)
592:                                apu.dmc.output_vol += (2 << 8);
9D01D790  8C620110   LW V0, 272(V1)
9D01D794  24420200   ADDIU V0, V0, 512
9D01D798  0B4075F1   J 0x9D01D7C4
9D01D79C  AC620110   SW V0, 272(V1)
593:                             }
594:                          }
595:                          /* negative delta */
596:                          else            
597:                          {
598:                             if (apu.dmc.regs[1] > 1)
9D01D7A0  90430101   LBU V1, 257(V0)
9D01D7A4  2C620002   SLTIU V0, V1, 2
9D01D7A8  14400006   BNE V0, ZERO, 0x9D01D7C4
9D01D7AC  260292F4   ADDIU V0, S0, -27916
599:                             {
600:                                apu.dmc.regs[1] -= 2;
9D01D7B0  2463FFFE   ADDIU V1, V1, -2
9D01D7B4  A0430101   SB V1, 257(V0)
601:                                apu.dmc.output_vol -= (2 << 8);
9D01D7B8  8C430110   LW V1, 272(V0)
9D01D7BC  2463FE00   ADDIU V1, V1, -512
9D01D7C0  AC430110   SW V1, 272(V0)
602:                             }
603:                          }
604:                       }
605:                    }
606:                 
607:                    return APU_DMC_OUTPUT;
9D01D7E0  260292F4   ADDIU V0, S0, -27916
9D01D7E4  8C420110   LW V0, 272(V0)
9D01D7E8  00021840   SLL V1, V0, 1
9D01D7EC  00431021   ADDU V0, V0, V1
9D01D7F0  00021083   SRA V0, V0, 2
608:                 }
609:                 
610:                 
611:                 void apu_write(uint32 address, uint8 value)
612:                 {  
9D01DA1C  27BDFFE0   ADDIU SP, SP, -32
9D01DA20  AFBF001C   SW RA, 28(SP)
9D01DA24  AFB10018   SW S1, 24(SP)
9D01DA28  AFB00014   SW S0, 20(SP)
613:                    int chan;
614:                 
615:                    switch (address)
9D01DA0C  2482C000   ADDIU V0, A0, -16384
9D01DA10  2C430016   SLTIU V1, V0, 22
9D01DA14  10600160   BEQ V1, ZERO, 0x9D01DF98
9D01DA18  00021080   SLL V0, V0, 2
9D01DA2C  3C039D02   LUI V1, -25342
9D01DA30  2463DA44   ADDIU V1, V1, -9660
9D01DA34  00621021   ADDU V0, V1, V0
9D01DA38  8C420000   LW V0, 0(V0)
9D01DA3C  00400008   JR V0
9D01DA40  00A08021   ADDU S0, A1, ZERO
616:                    {
617:                    /* rectangles */
618:                    case APU_WRA0:
619:                    case APU_WRB0:
620:                       chan = (address & 4) >> 2;
9D01DA9C  7C840080   EXT A0, A0, 2, 1
621:                       apu.rectangle[chan].regs[0] = value;
9D01DAA0  00041100   SLL V0, A0, 4
9D01DAA4  00042180   SLL A0, A0, 6
9D01DAA8  00442021   ADDU A0, V0, A0
9D01DAAC  3C02A001   LUI V0, -24575
9D01DAB0  244292F4   ADDIU V0, V0, -27916
9D01DAB4  00821021   ADDU V0, A0, V0
9D01DAB8  A0450000   SB A1, 0(V0)
622:                       apu.rectangle[chan].volume = value & 0x0F;
9D01DABC  30A3000F   ANDI V1, A1, 15
9D01DAC0  A043001C   SB V1, 28(V0)
623:                       apu.rectangle[chan].env_delay = decay_lut[value & 0x0F];
9D01DAC4  00031880   SLL V1, V1, 2
9D01DAC8  3C04A001   LUI A0, -24575
9D01DACC  248492B4   ADDIU A0, A0, -27980
9D01DAD0  00641821   ADDU V1, V1, A0
9D01DAD4  8C630000   LW V1, 0(V1)
9D01DAD8  AC43003C   SW V1, 60(V0)
624:                       apu.rectangle[chan].holdnote = (value & 0x20) ? true : false;
9D01DADC  7CA30140   EXT V1, A1, 5, 1
9D01DAE0  AC430018   SW V1, 24(V0)
625:                       apu.rectangle[chan].fixed_envelope = (value & 0x10) ? true : false;
9D01DAE4  7CA30100   EXT V1, A1, 4, 1
9D01DAE8  AC430014   SW V1, 20(V0)
626:                       apu.rectangle[chan].duty_flip = duty_flip[value >> 6];
9D01DAEC  00058182   SRL S0, A1, 6
9D01DAF0  00108080   SLL S0, S0, 2
9D01DAF4  3C039D04   LUI V1, -25340
9D01DAF8  246390E8   ADDIU V1, V1, -28440
9D01DAFC  02031821   ADDU V1, S0, V1
9D01DB00  8C630000   LW V1, 0(V1)
627:                       break;
9D01DB04  0B4077E2   J 0x9D01DF88
9D01DB08  AC43004C   SW V1, 76(V0)
628:                 
629:                    case APU_WRA1:
630:                    case APU_WRB1:
631:                       chan = (address & 4) >> 2;
9D01DB0C  7C840080   EXT A0, A0, 2, 1
632:                       apu.rectangle[chan].regs[1] = value;
9D01DB10  00041100   SLL V0, A0, 4
9D01DB14  00042180   SLL A0, A0, 6
9D01DB18  00442021   ADDU A0, V0, A0
9D01DB1C  3C02A001   LUI V0, -24575
9D01DB20  244292F4   ADDIU V0, V0, -27916
9D01DB24  00821021   ADDU V0, A0, V0
9D01DB28  A0450001   SB A1, 1(V0)
633:                       apu.rectangle[chan].sweep_on = (value & 0x80) ? true : false;
9D01DB2C  000519C2   SRL V1, A1, 7
9D01DB30  AC430028   SW V1, 40(V0)
634:                       apu.rectangle[chan].sweep_shifts = value & 7;
9D01DB34  30A30007   ANDI V1, A1, 7
9D01DB38  A043002C   SB V1, 44(V0)
635:                       apu.rectangle[chan].sweep_delay = decay_lut[(value >> 4) & 7];
9D01DB3C  7CA51100   EXT A1, A1, 4, 3
9D01DB40  00052880   SLL A1, A1, 2
9D01DB44  3C04A001   LUI A0, -24575
9D01DB48  248492B4   ADDIU A0, A0, -27980
9D01DB4C  00A42021   ADDU A0, A1, A0
9D01DB50  8C840000   LW A0, 0(A0)
9D01DB54  AC440024   SW A0, 36(V0)
636:                       apu.rectangle[chan].sweep_inc = (value & 0x08) ? true : false;
9D01DB58  7E1000C0   EXT S0, S0, 3, 1
9D01DB5C  AC500030   SW S0, 48(V0)
637:                       apu.rectangle[chan].freq_limit = freq_limit[value & 7];
9D01DB60  00031880   SLL V1, V1, 2
9D01DB64  3C049D04   LUI A0, -25340
9D01DB68  24849178   ADDIU A0, A0, -28296
9D01DB6C  00641821   ADDU V1, V1, A0
9D01DB70  8C630000   LW V1, 0(V1)
638:                       break;
9D01DB74  0B4077E2   J 0x9D01DF88
9D01DB78  AC430034   SW V1, 52(V0)
639:                 
640:                    case APU_WRA2:
641:                    case APU_WRB2:
642:                       chan = (address & 4) >> 2;
9D01DB7C  7C840080   EXT A0, A0, 2, 1
643:                       apu.rectangle[chan].regs[2] = value;
9D01DB80  00041100   SLL V0, A0, 4
9D01DB84  00042180   SLL A0, A0, 6
9D01DB88  00442021   ADDU A0, V0, A0
9D01DB8C  3C02A001   LUI V0, -24575
9D01DB90  244292F4   ADDIU V0, V0, -27916
9D01DB94  00821021   ADDU V0, A0, V0
9D01DB98  A0450002   SB A1, 2(V0)
644:                       apu.rectangle[chan].freq = (apu.rectangle[chan].freq & ~0xFF) | value;
9D01DB9C  8C43000C   LW V1, 12(V0)
9D01DBA0  7C033804   INS V1, ZERO, 0, 8
9D01DBA4  00A38025   OR S0, A1, V1
645:                       break;
9D01DBA8  0B4077E2   J 0x9D01DF88
9D01DBAC  AC50000C   SW S0, 12(V0)
646:                 
647:                    case APU_WRA3:
648:                    case APU_WRB3:
649:                       chan = (address & 4) >> 2;
9D01DBB0  7C840080   EXT A0, A0, 2, 1
650:                       apu.rectangle[chan].regs[3] = value;
9D01DBB4  00041100   SLL V0, A0, 4
9D01DBB8  00042180   SLL A0, A0, 6
9D01DBBC  00442021   ADDU A0, V0, A0
9D01DBC0  3C02A001   LUI V0, -24575
9D01DBC4  244292F4   ADDIU V0, V0, -27916
9D01DBC8  00821021   ADDU V0, A0, V0
9D01DBCC  A0450003   SB A1, 3(V0)
651:                       apu.rectangle[chan].vbl_length = vbl_lut[value >> 3];
9D01DBD0  000520C2   SRL A0, A1, 3
9D01DBD4  00042080   SLL A0, A0, 2
9D01DBD8  3C03A001   LUI V1, -24575
9D01DBDC  24639234   ADDIU V1, V1, -28108
9D01DBE0  00831821   ADDU V1, A0, V1
9D01DBE4  8C630000   LW V1, 0(V1)
9D01DBE8  AC430044   SW V1, 68(V0)
652:                       apu.rectangle[chan].env_vol = 0;
9D01DBEC  A0400040   SB ZERO, 64(V0)
653:                       apu.rectangle[chan].freq = ((value & 7) << 8) | (apu.rectangle[chan].freq & 0xFF);
9D01DBF0  30B00007   ANDI S0, A1, 7
9D01DBF4  00108200   SLL S0, S0, 8
9D01DBF8  9043000C   LBU V1, 12(V0)
9D01DBFC  02031825   OR V1, S0, V1
9D01DC00  AC43000C   SW V1, 12(V0)
654:                       apu.rectangle[chan].adder = 0;
655:                       break;
9D01DC04  0B4077E2   J 0x9D01DF88
9D01DC08  A0400048   SB ZERO, 72(V0)
656:                 
657:                    /* triangle */
658:                    case APU_WRC0:
659:                       apu.triangle.regs[0] = value;
9D01DC0C  3C02A001   LUI V0, -24575
9D01DC10  244292F4   ADDIU V0, V0, -27916
9D01DC14  A04500A0   SB A1, 160(V0)
660:                       apu.triangle.holdnote = (value & 0x80) ? true : false;
9D01DC18  000519C2   SRL V1, A1, 7
9D01DC1C  AC4300B8   SW V1, 184(V0)
661:                 
662:                       if (false == apu.triangle.counter_started && apu.triangle.vbl_length)
9D01DC20  8C4200BC   LW V0, 188(V0)
9D01DC24  144000D8   BNE V0, ZERO, 0x9D01DF88
9D01DC28  3C02A001   LUI V0, -24575
9D01DC2C  8C4293B8   LW V0, -27720(V0)
9D01DC30  104000D6   BEQ V0, ZERO, 0x9D01DF8C
9D01DC34  8FBF001C   LW RA, 28(SP)
663:                          apu.triangle.linear_length = trilength_lut[value & 0x7F];
9D01DC38  30B0007F   ANDI S0, A1, 127
9D01DC3C  00108080   SLL S0, S0, 2
9D01DC40  3C02A001   LUI V0, -24575
9D01DC44  24429034   ADDIU V0, V0, -28620
9D01DC48  02021021   ADDU V0, S0, V0
9D01DC4C  8C430000   LW V1, 0(V0)
9D01DC50  3C02A001   LUI V0, -24575
9D01DC54  0B4077E2   J 0x9D01DF88
9D01DC58  AC4393BC   SW V1, -27716(V0)
664:                 
665:                       break;
666:                 
667:                    case APU_WRC2:
668:                       apu.triangle.regs[1] = value;
9D01DC5C  3C02A001   LUI V0, -24575
9D01DC60  244292F4   ADDIU V0, V0, -27916
9D01DC64  A04500A1   SB A1, 161(V0)
669:                       apu.triangle.freq = (((apu.triangle.regs[2] & 7) << 8) + value) + 1;
9D01DC68  904300A2   LBU V1, 162(V0)
9D01DC6C  30630007   ANDI V1, V1, 7
9D01DC70  00031A00   SLL V1, V1, 8
9D01DC74  00658021   ADDU S0, V1, A1
9D01DC78  26100001   ADDIU S0, S0, 1
670:                       break;
9D01DC7C  0B4077E2   J 0x9D01DF88
9D01DC80  AC5000AC   SW S0, 172(V0)
671:                 
672:                    case APU_WRC3:
673:                 
674:                       apu.triangle.regs[2] = value;
9D01DC84  3C11A001   LUI S1, -24575
9D01DC88  263192F4   ADDIU S1, S1, -27916
9D01DC8C  A22500A2   SB A1, 162(S1)
675:                   
676:                       /* this is somewhat of a hack.  there appears to be some latency on 
677:                       ** the Real Thing between when trireg0 is written to and when the 
678:                       ** linear length counter actually begins its countdown.  we want to 
679:                       ** prevent the case where the program writes to the freq regs first, 
680:                       ** then to reg 0, and the counter accidentally starts running because 
681:                       ** of the sound queue's timestamp processing.
682:                       **
683:                       ** set latency to a couple hundred cycles -- should be plenty of time 
684:                       ** for the 6502 code to do a couple of table dereferences and load up 
685:                       ** the other triregs
686:                       */
687:                       apu.triangle.write_latency = (int) (228 / apu.cycle_rate);
9D01DC90  3C029D04   LUI V0, -25340
9D01DC94  8C4491B8   LW A0, -28232(V0)
9D01DC98  0F40D242   JAL __divsf3
9D01DC9C  8E25014C   LW A1, 332(S1)
9D01DCA0  0F40EA89   JAL __fixsfsi
9D01DCA4  00402021   ADDU A0, V0, ZERO
9D01DCA8  AE2200C0   SW V0, 192(S1)
688:                       apu.triangle.freq = (((value & 7) << 8) + apu.triangle.regs[1]) + 1;
9D01DCAC  32030007   ANDI V1, S0, 7
9D01DCB0  00031A00   SLL V1, V1, 8
9D01DCB4  922200A1   LBU V0, 161(S1)
9D01DCB8  00621021   ADDU V0, V1, V0
9D01DCBC  24420001   ADDIU V0, V0, 1
9D01DCC0  AE2200AC   SW V0, 172(S1)
689:                       apu.triangle.vbl_length = vbl_lut[value >> 3];
9D01DCC4  001080C2   SRL S0, S0, 3
9D01DCC8  00108080   SLL S0, S0, 2
9D01DCCC  3C02A001   LUI V0, -24575
9D01DCD0  24429234   ADDIU V0, V0, -28108
9D01DCD4  02021021   ADDU V0, S0, V0
9D01DCD8  8C420000   LW V0, 0(V0)
9D01DCDC  AE2200C4   SW V0, 196(S1)
690:                       apu.triangle.counter_started = false;
9D01DCE0  AE2000BC   SW ZERO, 188(S1)
691:                       apu.triangle.linear_length = trilength_lut[apu.triangle.regs[0] & 0x7F];
9D01DCE4  922300A0   LBU V1, 160(S1)
9D01DCE8  3063007F   ANDI V1, V1, 127
9D01DCEC  00031880   SLL V1, V1, 2
9D01DCF0  3C02A001   LUI V0, -24575
9D01DCF4  24429034   ADDIU V0, V0, -28620
9D01DCF8  00621021   ADDU V0, V1, V0
9D01DCFC  8C420000   LW V0, 0(V0)
692:                       break;
9D01DD00  0B4077E2   J 0x9D01DF88
9D01DD04  AE2200C8   SW V0, 200(S1)
693:                 
694:                    /* noise */
695:                    case APU_WRD0:
696:                       apu.noise.regs[0] = value;
9D01DD08  3C02A001   LUI V0, -24575
9D01DD0C  244292F4   ADDIU V0, V0, -27916
9D01DD10  A04500CC   SB A1, 204(V0)
697:                       apu.noise.env_delay = decay_lut[value & 0x0F];
9D01DD14  30A3000F   ANDI V1, A1, 15
9D01DD18  00032880   SLL A1, V1, 2
9D01DD1C  3C04A001   LUI A0, -24575
9D01DD20  248492B4   ADDIU A0, A0, -27980
9D01DD24  00A42021   ADDU A0, A1, A0
9D01DD28  8C840000   LW A0, 0(A0)
9D01DD2C  AC4400E4   SW A0, 228(V0)
698:                       apu.noise.holdnote = (value & 0x20) ? true : false;
9D01DD30  7E040140   EXT A0, S0, 5, 1
9D01DD34  AC4400F0   SW A0, 240(V0)
699:                       apu.noise.fixed_envelope = (value & 0x10) ? true : false;
9D01DD38  7E100100   EXT S0, S0, 4, 1
9D01DD3C  AC5000EC   SW S0, 236(V0)
700:                       apu.noise.volume = value & 0x0F;
701:                       break;
9D01DD40  0B4077E2   J 0x9D01DF88
9D01DD44  A04300F4   SB V1, 244(V0)
702:                 
703:                    case APU_WRD2:
704:                       apu.noise.regs[1] = value;
9D01DD48  3C02A001   LUI V0, -24575
9D01DD4C  244292F4   ADDIU V0, V0, -27916
9D01DD50  A04500CD   SB A1, 205(V0)
705:                       apu.noise.freq = noise_freq[value & 0x0F];
9D01DD54  30A4000F   ANDI A0, A1, 15
9D01DD58  00042080   SLL A0, A0, 2
9D01DD5C  3C039D04   LUI V1, -25340
9D01DD60  24639138   ADDIU V1, V1, -28360
9D01DD64  00831821   ADDU V1, A0, V1
9D01DD68  8C630000   LW V1, 0(V1)
9D01DD6C  AC4300D8   SW V1, 216(V0)
706:                 
707:                 #ifdef REALTIME_NOISE
708:                       apu.noise.xor_tap = (value & 0x80) ? 0x40: 0x02;
9D01DD70  000581C2   SRL S0, A1, 7
9D01DD74  24020040   ADDIU V0, ZERO, 64
9D01DD78  24030002   ADDIU V1, ZERO, 2
9D01DD7C  0070100A   MOVZ V0, V1, S0
9D01DD80  00408021   ADDU S0, V0, ZERO
9D01DD84  3C02A001   LUI V0, -24575
709:                 #else /* !REALTIME_NOISE */
710:                       /* detect transition from long->short sample */
711:                       if ((value & 0x80) && false == apu.noise.short_sample)
712:                       {
713:                          /* recalculate short noise buffer */
714:                          shift_register15(noise_short_lut, APU_NOISE_93);
715:                          apu.noise.cur_pos = 0;
716:                       }
717:                       apu.noise.short_sample = (value & 0x80) ? true : false;
718:                 #endif /* !REALTIME_NOISE */
719:                       break;
9D01DD88  0B4077E2   J 0x9D01DF88
9D01DD8C  A05093F0   SB S0, -27664(V0)
720:                 
721:                    case APU_WRD3:
722:                       apu.noise.regs[2] = value;
9D01DD90  3C02A001   LUI V0, -24575
9D01DD94  244292F4   ADDIU V0, V0, -27916
9D01DD98  A04500CE   SB A1, 206(V0)
723:                       apu.noise.vbl_length = vbl_lut[value >> 3];
9D01DD9C  000580C2   SRL S0, A1, 3
9D01DDA0  00108080   SLL S0, S0, 2
9D01DDA4  3C03A001   LUI V1, -24575
9D01DDA8  24639234   ADDIU V1, V1, -28108
9D01DDAC  02031821   ADDU V1, S0, V1
9D01DDB0  8C630000   LW V1, 0(V1)
9D01DDB4  AC4300F8   SW V1, 248(V0)
724:                       apu.noise.env_vol = 0; /* reset envelope */
725:                       break;
9D01DDB8  0B4077E2   J 0x9D01DF88
9D01DDBC  A04000E8   SB ZERO, 232(V0)
726:                 
727:                    /* DMC */
728:                    case APU_WRE0:
729:                       apu.dmc.regs[0] = value;
9D01DDC0  3C02A001   LUI V0, -24575
9D01DDC4  244292F4   ADDIU V0, V0, -27916
9D01DDC8  A0450100   SB A1, 256(V0)
730:                       apu.dmc.freq = dmc_clocks[value & 0x0F];
9D01DDCC  30A4000F   ANDI A0, A1, 15
9D01DDD0  00042080   SLL A0, A0, 2
9D01DDD4  3C039D04   LUI V1, -25340
9D01DDD8  246390F8   ADDIU V1, V1, -28424
9D01DDDC  00831821   ADDU V1, A0, V1
9D01DDE0  8C630000   LW V1, 0(V1)
9D01DDE4  AC43010C   SW V1, 268(V0)
731:                       apu.dmc.looping = (value & 0x40) ? true : false;
9D01DDE8  7CA30180   EXT V1, A1, 6, 1
732:                 
733:                       if (value & 0x80)
9D01DDEC  7C058420   SEB S0, A1
9D01DDF0  06010005   BGEZ S0, 0x9D01DE08
9D01DDF4  AC430128   SW V1, 296(V0)
734:                       {
735:                          apu.dmc.irq_gen = true;
9D01DDF8  24030001   ADDIU V1, ZERO, 1
9D01DDFC  3C02A001   LUI V0, -24575
9D01DE00  0B4077E2   J 0x9D01DF88
9D01DE04  AC439420   SW V1, -27616(V0)
736:                       }
737:                       else
738:                       {
739:                          apu.dmc.irq_gen = false;
9D01DE08  3C02A001   LUI V0, -24575
9D01DE0C  244292F4   ADDIU V0, V0, -27916
9D01DE10  AC40012C   SW ZERO, 300(V0)
740:                          apu.dmc.irq_occurred = false;
9D01DE14  0B4077E2   J 0x9D01DF88
9D01DE18  AC400130   SW ZERO, 304(V0)
741:                       }
742:                       break;
743:                 
744:                    case APU_WRE1: /* 7-bit DAC */
745:                       /* add the _delta_ between written value and
746:                       ** current output level of the volume reg
747:                       */
748:                       value &= 0x7F; /* bit 7 ignored */
9D01DE1C  30B0007F   ANDI S0, A1, 127
749:                       apu.dmc.output_vol += ((value - apu.dmc.regs[1]) << 8);
9D01DE20  3C02A001   LUI V0, -24575
9D01DE24  244292F4   ADDIU V0, V0, -27916
9D01DE28  90430101   LBU V1, 257(V0)
9D01DE2C  02031823   SUBU V1, S0, V1
9D01DE30  00031A00   SLL V1, V1, 8
9D01DE34  8C440110   LW A0, 272(V0)
9D01DE38  00831821   ADDU V1, A0, V1
9D01DE3C  AC430110   SW V1, 272(V0)
750:                       apu.dmc.regs[1] = value;
751:                       break;
9D01DE40  0B4077E2   J 0x9D01DF88
9D01DE44  A0500101   SB S0, 257(V0)
752:                 
753:                    case APU_WRE2:
754:                       apu.dmc.regs[2] = value;
9D01DE48  3C02A001   LUI V0, -24575
9D01DE4C  244292F4   ADDIU V0, V0, -27916
9D01DE50  A0450102   SB A1, 258(V0)
755:                       apu.dmc.cached_addr = 0xC000 + (uint16) (value << 6);
9D01DE54  00058180   SLL S0, A1, 6
9D01DE58  3403C000   ORI V1, ZERO, -16384
9D01DE5C  02038021   ADDU S0, S0, V1
756:                       break;
9D01DE60  0B4077E2   J 0x9D01DF88
9D01DE64  AC500118   SW S0, 280(V0)
757:                 
758:                    case APU_WRE3:
759:                       apu.dmc.regs[3] = value;
9D01DE68  3C02A001   LUI V0, -24575
9D01DE6C  244292F4   ADDIU V0, V0, -27916
9D01DE70  A0450103   SB A1, 259(V0)
760:                       apu.dmc.cached_dmalength = ((value << 4) + 1) << 3;
9D01DE74  000581C0   SLL S0, A1, 7
9D01DE78  26100008   ADDIU S0, S0, 8
761:                       break;
9D01DE7C  0B4077E2   J 0x9D01DF88
9D01DE80  AC500120   SW S0, 288(V0)
762:                 
763:                    case APU_SMASK:
764:                       /* bodge for timestamp queue */
765:                       apu.dmc.enabled = (value & 0x10) ? true : false;
9D01DE84  7CA20100   EXT V0, A1, 4, 1
9D01DE88  3C03A001   LUI V1, -24575
9D01DE8C  246392F4   ADDIU V1, V1, -27916
9D01DE90  AC620104   SW V0, 260(V1)
766:                       apu.enable_reg = value;
9D01DE94  A0650134   SB A1, 308(V1)
767:                 
768:                       for (chan = 0; chan < 2; chan++)
769:                       {
770:                          if (value & (1 << chan))
9D01DE98  30A30001   ANDI V1, A1, 1
9D01DE9C  14600006   BNE V1, ZERO, 0x9D01DEB8
9D01DEA0  24040001   ADDIU A0, ZERO, 1
9D01DEC0  7E030040   EXT V1, S0, 1, 1
9D01DEC4  10600005   BEQ V1, ZERO, 0x9D01DEDC
9D01DEC8  3C03A001   LUI V1, -24575
771:                          {
772:                             apu.rectangle[chan].enabled = true;
9D01DEB8  3C03A001   LUI V1, -24575
9D01DEBC  AC6492F8   SW A0, -27912(V1)
9D01DECC  24040001   ADDIU A0, ZERO, 1
9D01DED0  3C03A001   LUI V1, -24575
9D01DED4  0B4077BA   J 0x9D01DEE8
9D01DED8  AC649348   SW A0, -27832(V1)
773:                          }
774:                          else
775:                          {
776:                             apu.rectangle[chan].enabled = false;
9D01DEA4  3C03A001   LUI V1, -24575
9D01DEA8  246392F4   ADDIU V1, V1, -27916
9D01DEAC  AC600004   SW ZERO, 4(V1)
9D01DEDC  246392F4   ADDIU V1, V1, -27916
9D01DEE0  AC600054   SW ZERO, 84(V1)
777:                             apu.rectangle[chan].vbl_length = 0;
9D01DEB0  0B4077B0   J 0x9D01DEC0
9D01DEB4  AC600044   SW ZERO, 68(V1)
9D01DEE4  AC600094   SW ZERO, 148(V1)
778:                          }
779:                       }
780:                 
781:                       if (value & 0x04)
9D01DEE8  32030004   ANDI V1, S0, 4
9D01DEEC  306300FF   ANDI V1, V1, 255
9D01DEF0  10600005   BEQ V1, ZERO, 0x9D01DF08
9D01DEF4  3C03A001   LUI V1, -24575
782:                       {
783:                          apu.triangle.enabled = true;
9D01DEF8  24040001   ADDIU A0, ZERO, 1
9D01DEFC  3C03A001   LUI V1, -24575
9D01DF00  0B4077C8   J 0x9D01DF20
9D01DF04  AC649398   SW A0, -27752(V1)
784:                       }
785:                       else
786:                       {
787:                          apu.triangle.enabled = false;
9D01DF08  246392F4   ADDIU V1, V1, -27916
9D01DF0C  AC6000A4   SW ZERO, 164(V1)
788:                          apu.triangle.vbl_length = 0;
9D01DF10  AC6000C4   SW ZERO, 196(V1)
789:                          apu.triangle.linear_length = 0;
9D01DF14  AC6000C8   SW ZERO, 200(V1)
790:                          apu.triangle.counter_started = false;
9D01DF18  AC6000BC   SW ZERO, 188(V1)
791:                          apu.triangle.write_latency = 0;
9D01DF1C  AC6000C0   SW ZERO, 192(V1)
792:                       }
793:                 
794:                       if (value & 0x08)
9D01DF20  32100008   ANDI S0, S0, 8
9D01DF24  321000FF   ANDI S0, S0, 255
9D01DF28  12000005   BEQ S0, ZERO, 0x9D01DF40
9D01DF2C  3C03A001   LUI V1, -24575
795:                       {
796:                          apu.noise.enabled = true;
9D01DF30  24040001   ADDIU A0, ZERO, 1
9D01DF34  3C03A001   LUI V1, -24575
9D01DF38  0B4077D3   J 0x9D01DF4C
9D01DF3C  AC6493C4   SW A0, -27708(V1)
797:                       }
798:                       else
799:                       {
800:                          apu.noise.enabled = false;
9D01DF40  246392F4   ADDIU V1, V1, -27916
9D01DF44  AC6000D0   SW ZERO, 208(V1)
801:                          apu.noise.vbl_length = 0;
9D01DF48  AC6000F8   SW ZERO, 248(V1)
802:                       }
803:                 
804:                       if (value & 0x10)
9D01DF4C  1040000B   BEQ V0, ZERO, 0x9D01DF7C
9D01DF50  3C02A001   LUI V0, -24575
805:                       {
806:                          if (0 == apu.dmc.dma_length)
9D01DF54  8C429410   LW V0, -27632(V0)
9D01DF58  1440000A   BNE V0, ZERO, 0x9D01DF84
9D01DF5C  3C02A001   LUI V0, -24575
807:                             apu_dmcreload();
808:                       }
809:                       else
810:                       {
811:                          apu.dmc.dma_length = 0;
9D01DF7C  AC409410   SW ZERO, -27632(V0)
812:                       }
813:                 
814:                       apu.dmc.irq_occurred = false;
9D01DF80  3C02A001   LUI V0, -24575
9D01DF84  AC409424   SW ZERO, -27612(V0)
815:                       break;
816:                 
817:                       /* unused, but they get hit in some mem-clear loops */
818:                    case 0x4009:
819:                    case 0x400D:
820:                       break;
821:                    
822:                    default:
823:                       break;
824:                    }
825:                 }
9D01DF88  8FBF001C   LW RA, 28(SP)
9D01DF8C  8FB10018   LW S1, 24(SP)
9D01DF90  8FB00014   LW S0, 20(SP)
9D01DF94  27BD0020   ADDIU SP, SP, 32
9D01DF98  03E00008   JR RA
9D01DF9C  00000000   NOP
826:                 
827:                 /* Read from $4000-$4017 */
828:                 uint8 apu_read(uint32 address)
829:                 {
9D01DFA0  27BDFFE8   ADDIU SP, SP, -24
9D01DFA4  AFBF0014   SW RA, 20(SP)
9D01DFA8  AFB00010   SW S0, 16(SP)
830:                    uint8 value;
831:                 
832:                    switch (address)
9D01DFAC  24024015   ADDIU V0, ZERO, 16405
9D01DFB0  14820031   BNE A0, V0, 0x9D01E078
9D01DFB4  7C903A00   EXT S0, A0, 8, 8
833:                    {
834:                    case APU_SMASK:
835:                       value = 0;
9D01DFD0  0010802B   SLTU S0, ZERO, S0
836:                       /* Return 1 in 0-5 bit pos if a channel is playing */
837:                       if (apu.rectangle[0].enabled && apu.rectangle[0].vbl_length)
9D01DFB8  3C02A001   LUI V0, -24575
9D01DFBC  8C4292F8   LW V0, -27912(V0)
9D01DFC0  10400004   BEQ V0, ZERO, 0x9D01DFD4
9D01DFC4  00008021   ADDU S0, ZERO, ZERO
9D01DFC8  3C02A001   LUI V0, -24575
9D01DFCC  8C509338   LW S0, -27848(V0)
838:                          value |= 0x01;
839:                       if (apu.rectangle[1].enabled && apu.rectangle[1].vbl_length)
9D01DFD4  3C02A001   LUI V0, -24575
9D01DFD8  8C429348   LW V0, -27832(V0)
9D01DFDC  10400006   BEQ V0, ZERO, 0x9D01DFF8
9D01DFE0  3C02A001   LUI V0, -24575
9D01DFE4  3C02A001   LUI V0, -24575
9D01DFE8  8C439388   LW V1, -27768(V0)
840:                          value |= 0x02;
9D01DFEC  36020002   ORI V0, S0, 2
9D01DFF0  0043800B   MOVN S0, V0, V1
841:                       if (apu.triangle.enabled && apu.triangle.vbl_length)
9D01DFF4  3C02A001   LUI V0, -24575
9D01DFF8  8C429398   LW V0, -27752(V0)
9D01DFFC  10400006   BEQ V0, ZERO, 0x9D01E018
9D01E000  3C02A001   LUI V0, -24575
9D01E004  3C02A001   LUI V0, -24575
9D01E008  8C4393B8   LW V1, -27720(V0)
842:                          value |= 0x04;
9D01E00C  36020004   ORI V0, S0, 4
9D01E010  0043800B   MOVN S0, V0, V1
843:                       if (apu.noise.enabled && apu.noise.vbl_length)
9D01E014  3C02A001   LUI V0, -24575
9D01E018  8C4293C4   LW V0, -27708(V0)
9D01E01C  10400006   BEQ V0, ZERO, 0x9D01E038
9D01E020  3C02A001   LUI V0, -24575
9D01E024  3C02A001   LUI V0, -24575
9D01E028  8C4393EC   LW V1, -27668(V0)
844:                          value |= 0x08;
9D01E02C  36020008   ORI V0, S0, 8
9D01E030  0043800B   MOVN S0, V0, V1
845:                 
846:                       /* bodge for timestamp queue */
847:                       if (apu.dmc.enabled)
9D01E034  3C02A001   LUI V0, -24575
9D01E038  8C4393F8   LW V1, -27656(V0)
848:                          value |= 0x10;
9D01E03C  36020010   ORI V0, S0, 16
9D01E040  0043800B   MOVN S0, V0, V1
849:                 
850:                       if (apu.dmc.irq_occurred)
9D01E044  3C02A001   LUI V0, -24575
9D01E048  8C439424   LW V1, -27612(V0)
851:                          value |= 0x80;
9D01E04C  36020080   ORI V0, S0, 128
9D01E050  0043800B   MOVN S0, V0, V1
852:                 
853:                       if (apu.irqclear_callback)
9D01E054  3C02A001   LUI V0, -24575
9D01E058  8C429458   LW V0, -27560(V0)
9D01E05C  50400007   BEQL V0, ZERO, 0x9D01E07C
9D01E060  02001021   ADDU V0, S0, ZERO
854:                          value |= apu.irqclear_callback();
9D01E064  0040F809   JALR V0
9D01E068  00000000   NOP
9D01E06C  00501025   OR V0, V0, S0
9D01E070  0B40781E   J 0x9D01E078
9D01E074  305000FF   ANDI S0, V0, 255
855:                 
856:                       break;
857:                 
858:                    default:
859:                       value = (address >> 8); /* heavy capacitance on data bus */
860:                       break;
861:                    }
862:                 
863:                    return value;
864:                 }
9D01E078  02001021   ADDU V0, S0, ZERO
9D01E07C  8FBF0014   LW RA, 20(SP)
9D01E080  8FB00010   LW S0, 16(SP)
9D01E084  03E00008   JR RA
9D01E088  27BD0018   ADDIU SP, SP, 24
865:                 
866:                 #define CLIP_OUTPUT16(out) \
867:                 { \
868:                    /*out <<= 1;*/ \
869:                    if (out > 0x7FFF) \
870:                       out = 0x7FFF; \
871:                    else if (out < -0x8000) \
872:                       out = -0x8000; \
873:                 }
874:                 
875:                 void apu_process(void *buffer, int num_samples)
876:                 {
9D01CDEC  27BDFFB0   ADDIU SP, SP, -80
9D01CDF0  AFBF004C   SW RA, 76(SP)
9D01CDF4  AFBE0048   SW FP, 72(SP)
9D01CDF8  AFB70044   SW S7, 68(SP)
9D01CDFC  AFB60040   SW S6, 64(SP)
9D01CE00  AFB5003C   SW S5, 60(SP)
9D01CE04  AFB40038   SW S4, 56(SP)
9D01CE08  AFB30034   SW S3, 52(SP)
9D01CE0C  AFB20030   SW S2, 48(SP)
9D01CE10  AFB1002C   SW S1, 44(SP)
9D01CE14  AFB00028   SW S0, 40(SP)
877:                    static int32 prev_sample = 0;
878:                 
879:                    int16 *buf16;
880:                    uint8 *buf8;
881:                 
882:                    if (NULL != buffer)
9D01CE18  108002B4   BEQ A0, ZERO, 0x9D01D8EC
9D01CE1C  AFA40050   SW A0, 80(SP)
883:                    {
884:                       /* bleh */
885:                       apu.buffer = buffer;
9D01CE20  3C02A001   LUI V0, -24575
9D01CE24  AC44942C   SW A0, -27604(V0)
9D01CE28  00A09821   ADDU S3, A1, ZERO
886:                 
887:                       buf16 = (int16 *) buffer;
888:                       buf8 = (uint8 *) buffer;
9D01CE2C  0080A821   ADDU S5, A0, ZERO
889:                 
890:                       while (num_samples--)
9D01CE38  0B407631   J 0x9D01D8C4
9D01CE3C  24140007   ADDIU S4, ZERO, 7
9D01D8C4  1660FD5E   BNE S3, ZERO, 0x9D01CE40
9D01D8C8  260292F4   ADDIU V0, S0, -27916
9D01D8CC  0B40763C   J 0x9D01D8F0
9D01D8D0  8FBF004C   LW RA, 76(SP)
891:                       {
892:                          int32 next_sample, accum = 0;
893:                 
894:                          if (apu.mix_enable & 0x01)
9D01CE30  3C10A001   LUI S0, -24575
9D01CE40  90520140   LBU S2, 320(V0)
9D01CE44  32420001   ANDI V0, S2, 1
9D01CE48  1040008E   BEQ V0, ZERO, 0x9D01D084
9D01CE4C  00008821   ADDU S1, ZERO, ZERO
895:                             accum += apu_rectangle_0();
896:                          if (apu.mix_enable & 0x02)
9D01D084  32420002   ANDI V0, S2, 2
9D01D088  304200FF   ANDI V0, V0, 255
9D01D08C  10400093   BEQ V0, ZERO, 0x9D01D2DC
9D01D090  32420004   ANDI V0, S2, 4
897:                             accum += apu_rectangle_1();
9D01D2D4  02238821   ADDU S1, S1, V1
898:                          if (apu.mix_enable & 0x04)
9D01D2D8  32420004   ANDI V0, S2, 4
9D01D2DC  304200FF   ANDI V0, V0, 255
9D01D2E0  10400058   BEQ V0, ZERO, 0x9D01D444
9D01D2E4  32420008   ANDI V0, S2, 8
899:                             accum += apu_triangle();
9D01D43C  02238821   ADDU S1, S1, V1
900:                          if (apu.mix_enable & 0x08)
9D01D440  32420008   ANDI V0, S2, 8
9D01D444  304200FF   ANDI V0, V0, 255
9D01D448  50400080   BEQL V0, ZERO, 0x9D01D64C
9D01D44C  32520010   ANDI S2, S2, 16
901:                             accum += apu_noise();
9D01D644  02378821   ADDU S1, S1, S7
902:                          if (apu.mix_enable & 0x10)
9D01D648  32520010   ANDI S2, S2, 16
9D01D64C  325200FF   ANDI S2, S2, 255
9D01D650  1240006A   BEQ S2, ZERO, 0x9D01D7FC
9D01D654  260292F4   ADDIU V0, S0, -27916
903:                             accum += apu_dmc();
9D01D7F4  02228821   ADDU S1, S1, V0
904:                          if (apu.ext && (apu.mix_enable & 0x20))
9D01D7F8  260292F4   ADDIU V0, S0, -27916
9D01D7FC  8C420168   LW V0, 360(V0)
9D01D800  1040000A   BEQ V0, ZERO, 0x9D01D82C
9D01D804  260392F4   ADDIU V1, S0, -27916
9D01D808  90630140   LBU V1, 320(V1)
9D01D80C  30630020   ANDI V1, V1, 32
9D01D810  306300FF   ANDI V1, V1, 255
9D01D814  50600006   BEQL V1, ZERO, 0x9D01D830
9D01D818  260292F4   ADDIU V0, S0, -27916
905:                             accum += apu.ext->process();
9D01D81C  8C42000C   LW V0, 12(V0)
9D01D820  0040F809   JALR V0
9D01D824  00000000   NOP
9D01D828  02228821   ADDU S1, S1, V0
906:                 
907:                          /* do any filtering */
908:                          if (APU_FILTER_NONE != apu.filter_type)
9D01D82C  260292F4   ADDIU V0, S0, -27916
9D01D830  8C420144   LW V0, 324(V0)
9D01D834  1040000E   BEQ V0, ZERO, 0x9D01D870
9D01D838  2A238000   SLTI V1, S1, -32768
909:                          {
910:                             next_sample = accum;
911:                 
912:                             if (APU_FILTER_LOWPASS == apu.filter_type)
9D01D83C  54560005   BNEL V0, S6, 0x9D01D854
9D01D840  00111040   SLL V0, S1, 1
913:                             {
914:                                accum += prev_sample;
9D01D844  8F82811C   LW V0, -32484(GP)
9D01D848  02221021   ADDU V0, S1, V0
9D01D84C  0B407619   J 0x9D01D864
9D01D850  00021043   SRA V0, V0, 1
915:                                accum >>= 1;
916:                             }
917:                             else
918:                                accum = (accum + accum + accum + prev_sample) >> 2;
9D01D854  00511021   ADDU V0, V0, S1
9D01D858  8F83811C   LW V1, -32484(GP)
9D01D85C  00431021   ADDU V0, V0, V1
9D01D860  00021083   SRA V0, V0, 2
919:                 
920:                             prev_sample = next_sample;
9D01D864  AF91811C   SW S1, -32484(GP)
9D01D868  00408821   ADDU S1, V0, ZERO
9D01D86C  2A238000   SLTI V1, S1, -32768
9D01D870  24028000   ADDIU V0, ZERO, -32768
9D01D874  0043880B   MOVN S1, V0, V1
9D01D878  34028000   ORI V0, ZERO, -32768
9D01D87C  0222182A   SLT V1, S1, V0
9D01D880  24027FFF   ADDIU V0, ZERO, 32767
9D01D884  0043880A   MOVZ S1, V0, V1
921:                          }
922:                 
923:                          /* do clipping */
924:                          CLIP_OUTPUT16(accum);
925:                 
926:                          /* signed 16-bit output, unsigned 8-bit */
927:                          if (16 == apu.sample_bits)
9D01D888  260292F4   ADDIU V0, S0, -27916
9D01D88C  8C430154   LW V1, 340(V0)
9D01D890  24020010   ADDIU V0, ZERO, 16
9D01D894  54620006   BNEL V1, V0, 0x9D01D8B0
9D01D898  00118A03   SRA S1, S1, 8
928:                             *buf16++ = (int16) accum;
9D01D89C  8FA30050   LW V1, 80(SP)
9D01D8A0  A4710000   SH S1, 0(V1)
9D01D8A4  24630002   ADDIU V1, V1, 2
9D01D8A8  0B407630   J 0x9D01D8C0
9D01D8AC  AFA30050   SW V1, 80(SP)
929:                          else
930:                             *buf8++ = (accum >> 8) ^ 0x80;
9D01D8B0  2402FF80   ADDIU V0, ZERO, -128
9D01D8B4  02228826   XOR S1, S1, V0
9D01D8B8  A2B10000   SB S1, 0(S5)
9D01D8BC  26B50001   ADDIU S5, S5, 1
9D01D8C0  2673FFFF   ADDIU S3, S3, -1
931:                       }
932:                    }
933:                 }
9D01D8EC  8FBF004C   LW RA, 76(SP)
9D01D8F0  8FBE0048   LW FP, 72(SP)
9D01D8F4  8FB70044   LW S7, 68(SP)
9D01D8F8  8FB60040   LW S6, 64(SP)
9D01D8FC  8FB5003C   LW S5, 60(SP)
9D01D900  8FB40038   LW S4, 56(SP)
9D01D904  8FB30034   LW S3, 52(SP)
9D01D908  8FB20030   LW S2, 48(SP)
9D01D90C  8FB1002C   LW S1, 44(SP)
9D01D910  8FB00028   LW S0, 40(SP)
9D01D914  03E00008   JR RA
9D01D918  27BD0050   ADDIU SP, SP, 80
934:                 
935:                 /* set the filter type */
936:                 void apu_setfilter(int filter_type)
937:                 {
938:                    apu.filter_type = filter_type;
9D01E08C  3C02A001   LUI V0, -24575
9D01E090  03E00008   JR RA
9D01E094  AC449438   SW A0, -27592(V0)
9D01E344  24030002   ADDIU V1, ZERO, 2
9D01E348  3C02A001   LUI V0, -24575
9D01E34C  AC439438   SW V1, -27592(V0)
939:                 }
940:                 
941:                 void apu_reset(void)
942:                 {
9D01E098  27BDFFE0   ADDIU SP, SP, -32
9D01E09C  AFBF001C   SW RA, 28(SP)
9D01E0A0  AFB10018   SW S1, 24(SP)
9D01E0A4  AFB00014   SW S0, 20(SP)
943:                    uint32 address;
944:                 
945:                    /* initialize all channel members */
946:                    for (address = 0x4000; address <= 0x4013; address++)
9D01E0A8  24104000   ADDIU S0, ZERO, 16384
9D01E0AC  24114014   ADDIU S1, ZERO, 16404
9D01E0BC  26100001   ADDIU S0, S0, 1
9D01E0C0  1611FFFC   BNE S0, S1, 0x9D01E0B4
9D01E0C4  02002021   ADDU A0, S0, ZERO
947:                       apu_write(address, 0);
9D01E0B0  02002021   ADDU A0, S0, ZERO
9D01E0B4  0F407683   JAL apu_write
9D01E0B8  00002821   ADDU A1, ZERO, ZERO
948:                 
949:                    apu_write(0x4015, 0);
9D01E0C8  24044015   ADDIU A0, ZERO, 16405
9D01E0CC  0F407683   JAL apu_write
9D01E0D0  00002821   ADDU A1, ZERO, ZERO
950:                 
951:                    if (apu.ext && NULL != apu.ext->reset)
9D01E0D4  3C02A001   LUI V0, -24575
9D01E0D8  8C42945C   LW V0, -27556(V0)
9D01E0DC  10400007   BEQ V0, ZERO, 0x9D01E0FC
9D01E0E0  8FBF001C   LW RA, 28(SP)
9D01E0E4  8C420008   LW V0, 8(V0)
9D01E0E8  10400005   BEQ V0, ZERO, 0x9D01E100
9D01E0EC  8FB10018   LW S1, 24(SP)
952:                       apu.ext->reset();
9D01E0F0  0040F809   JALR V0
9D01E0F4  00000000   NOP
953:                 }
9D01E0F8  8FBF001C   LW RA, 28(SP)
9D01E0FC  8FB10018   LW S1, 24(SP)
9D01E100  8FB00014   LW S0, 20(SP)
9D01E104  03E00008   JR RA
9D01E108  27BD0020   ADDIU SP, SP, 32
954:                 
955:                 void apu_build_luts(int num_samples)
956:                 {
9D01E10C  27BDFFD0   ADDIU SP, SP, -48
9D01E110  AFBF002C   SW RA, 44(SP)
9D01E114  AFB50028   SW S5, 40(SP)
9D01E118  AFB40024   SW S4, 36(SP)
9D01E11C  AFB30020   SW S3, 32(SP)
9D01E120  AFB2001C   SW S2, 28(SP)
9D01E124  AFB10018   SW S1, 24(SP)
9D01E128  AFB00014   SW S0, 20(SP)
9D01E12C  00809821   ADDU S3, A0, ZERO
9D01E130  00802821   ADDU A1, A0, ZERO
9D01E134  3C02A001   LUI V0, -24575
9D01E138  244292B4   ADDIU V0, V0, -27980
9D01E13C  24440040   ADDIU A0, V0, 64
9D01E140  02601821   ADDU V1, S3, ZERO
957:                    int i;
958:                 
959:                    /* lut used for enveloping and frequency sweeps */
960:                    for (i = 0; i < 16; i++)
9D01E14C  1444FFFD   BNE V0, A0, 0x9D01E144
9D01E150  00651821   ADDU V1, V1, A1
9D01E154  3C029D04   LUI V0, -25340
9D01E158  24429198   ADDIU V0, V0, -28264
9D01E15C  3C03A001   LUI V1, -24575
9D01E160  24639234   ADDIU V1, V1, -28108
9D01E164  24450020   ADDIU A1, V0, 32
961:                       decay_lut[i] = num_samples * (i + 1);
9D01E144  AC430000   SW V1, 0(V0)
9D01E148  24420004   ADDIU V0, V0, 4
962:                 
963:                    /* used for note length, based on vblanks and size of audio buffer */
964:                    for (i = 0; i < 32; i++)
9D01E178  1445FFFB   BNE V0, A1, 0x9D01E168
9D01E17C  24630004   ADDIU V1, V1, 4
9D01E180  3C11A001   LUI S1, -24575
9D01E184  26319034   ADDIU S1, S1, -28620
9D01E188  00008021   ADDU S0, ZERO, ZERO
965:                       vbl_lut[i] = vbl_length[i] * num_samples;
9D01E168  90440000   LBU A0, 0(V0)
9D01E16C  70932002   MUL A0, A0, S3
9D01E170  AC640000   SW A0, 0(V1)
9D01E174  24420001   ADDIU V0, V0, 1
966:                 
967:                    /* triangle wave channel's linear length table */
968:                    for (i = 0; i < 128; i++)
9D01E194  24140080   ADDIU S4, ZERO, 128
9D01E1D0  26100001   ADDIU S0, S0, 1
9D01E1D4  1614FFF0   BNE S0, S4, 0x9D01E198
9D01E1D8  26310004   ADDIU S1, S1, 4
969:                       trilength_lut[i] = (int) (0.25 * i * num_samples);
9D01E18C  3C029D04   LUI V0, -25340
9D01E190  8C5591BC   LW S5, -28228(V0)
9D01E198  0F40ECB4   JAL sitofp
9D01E19C  02002021   ADDU A0, S0, ZERO
9D01E1A0  00402021   ADDU A0, V0, ZERO
9D01E1A4  0F40D562   JAL __mulsf3
9D01E1A8  02A02821   ADDU A1, S5, ZERO
9D01E1AC  00409021   ADDU S2, V0, ZERO
9D01E1B0  0F40ECB4   JAL sitofp
9D01E1B4  02602021   ADDU A0, S3, ZERO
9D01E1B8  02402021   ADDU A0, S2, ZERO
9D01E1BC  0F40D562   JAL __mulsf3
9D01E1C0  00402821   ADDU A1, V0, ZERO
9D01E1C4  0F40EA89   JAL __fixsfsi
9D01E1C8  00402021   ADDU A0, V0, ZERO
9D01E1CC  AE220000   SW V0, 0(S1)
970:                 
971:                 #ifndef REALTIME_NOISE
972:                    /* generate noise samples */
973:                    shift_register15(noise_long_lut, APU_NOISE_32K);
974:                    shift_register15(noise_short_lut, APU_NOISE_93);
975:                 #endif /* !REALTIME_NOISE */
976:                 }
9D01E1DC  8FBF002C   LW RA, 44(SP)
9D01E1E0  8FB50028   LW S5, 40(SP)
9D01E1E4  8FB40024   LW S4, 36(SP)
9D01E1E8  8FB30020   LW S3, 32(SP)
9D01E1EC  8FB2001C   LW S2, 28(SP)
9D01E1F0  8FB10018   LW S1, 24(SP)
9D01E1F4  8FB00014   LW S0, 20(SP)
9D01E1F8  03E00008   JR RA
9D01E1FC  27BD0030   ADDIU SP, SP, 48
977:                 
978:                 void apu_setparams(double base_freq, int sample_rate, int refresh_rate, int sample_bits)
979:                 {
9D01E200  27BDFFE0   ADDIU SP, SP, -32
9D01E204  AFBF001C   SW RA, 28(SP)
9D01E208  AFB20018   SW S2, 24(SP)
9D01E20C  AFB10014   SW S1, 20(SP)
9D01E210  AFB00010   SW S0, 16(SP)
9D01E214  00809021   ADDU S2, A0, ZERO
9D01E218  00A08021   ADDU S0, A1, ZERO
980:                    apu.sample_rate = sample_rate;
9D01E21C  3C02A001   LUI V0, -24575
9D01E220  244292F4   ADDIU V0, V0, -27916
9D01E224  AC450150   SW A1, 336(V0)
981:                    apu.refresh_rate = refresh_rate;
9D01E228  AC460158   SW A2, 344(V0)
982:                    apu.sample_bits = sample_bits;
9D01E22C  AC470154   SW A3, 340(V0)
983:                    apu.num_samples = sample_rate / refresh_rate;
9D01E230  00A6001A   DIV A1, A2
9D01E234  00C001F4   TEQ A2, ZERO
9D01E238  00008812   MFLO S1
9D01E23C  AC51013C   SW S1, 316(V0)
984:                    if (0 == base_freq)
9D01E240  0F40E8E3   JAL __lesf2
9D01E244  00002821   ADDU A1, ZERO, ZERO
9D01E248  14400006   BNE V0, ZERO, 0x9D01E264
9D01E24C  3C02A001   LUI V0, -24575
985:                       apu.base_freq = APU_BASEFREQ;
9D01E250  3C029D04   LUI V0, -25340
9D01E254  8C4391C0   LW V1, -28224(V0)
9D01E258  3C02A001   LUI V0, -24575
9D01E25C  0B40789A   J 0x9D01E268
9D01E260  AC43943C   SW V1, -27588(V0)
986:                    else
987:                       apu.base_freq = base_freq;
9D01E264  AC52943C   SW S2, -27588(V0)
988:                    apu.cycle_rate = (float) (apu.base_freq / sample_rate);
9D01E268  3C12A001   LUI S2, -24575
9D01E26C  265292F4   ADDIU S2, S2, -27916
9D01E270  0F40ECB4   JAL sitofp
9D01E274  02002021   ADDU A0, S0, ZERO
9D01E278  8E440148   LW A0, 328(S2)
9D01E27C  0F40D242   JAL __divsf3
9D01E280  00402821   ADDU A1, V0, ZERO
9D01E284  AE42014C   SW V0, 332(S2)
989:                 
990:                    /* build various lookup tables for apu */
991:                    apu_build_luts(apu.num_samples);
9D01E288  0F407843   JAL apu_build_luts
9D01E28C  02202021   ADDU A0, S1, ZERO
992:                 
993:                    apu_reset();
9D01E290  0F407826   JAL apu_reset
9D01E294  00000000   NOP
994:                 }
9D01E298  8FBF001C   LW RA, 28(SP)
9D01E29C  8FB20018   LW S2, 24(SP)
9D01E2A0  8FB10014   LW S1, 20(SP)
9D01E2A4  8FB00010   LW S0, 16(SP)
9D01E2A8  03E00008   JR RA
9D01E2AC  27BD0020   ADDIU SP, SP, 32
995:                 
996:                 /* Initializes emulated sound hardware, creates waveforms/voices */
997:                 apu_t *apu_create(double base_freq, int sample_rate, int refresh_rate, int sample_bits)
998:                 {
9D01E2B0  27BDFFD8   ADDIU SP, SP, -40
9D01E2B4  AFBF0024   SW RA, 36(SP)
9D01E2B8  AFB40020   SW S4, 32(SP)
9D01E2BC  AFB3001C   SW S3, 28(SP)
9D01E2C0  AFB20018   SW S2, 24(SP)
9D01E2C4  AFB10014   SW S1, 20(SP)
9D01E2C8  AFB00010   SW S0, 16(SP)
9D01E2CC  0080A021   ADDU S4, A0, ZERO
9D01E2D0  00A09821   ADDU S3, A1, ZERO
9D01E2D4  00C09021   ADDU S2, A2, ZERO
9D01E2D8  00E08021   ADDU S0, A3, ZERO
999:                    apu_t *temp_apu;
1000:                   int channel;
1001:                
1002:                   temp_apu = malloc(sizeof(apu_t));
9D01E2DC  0F40DB84   JAL _my_malloc
9D01E2E0  2404016C   ADDIU A0, ZERO, 364
1003:                   if (NULL == temp_apu)
9D01E2E4  1040001E   BEQ V0, ZERO, 0x9D01E360
9D01E2E8  00408821   ADDU S1, V0, ZERO
1004:                      return NULL;
9D01E360  00001021   ADDU V0, ZERO, ZERO
1005:                
1006:                   memset(temp_apu, 0, sizeof(apu_t));
9D01E2EC  00402021   ADDU A0, V0, ZERO
9D01E2F0  00002821   ADDU A1, ZERO, ZERO
9D01E2F4  0F40E7C9   JAL .Letext0, .LFE0, memset
9D01E2F8  2406016C   ADDIU A2, ZERO, 364
1007:                
1008:                   /* set the update routine */
1009:                   temp_apu->process = apu_process;
9D01E2FC  3C029D02   LUI V0, -25342
9D01E300  2442CDEC   ADDIU V0, V0, -12820
9D01E304  AE22015C   SW V0, 348(S1)
1010:                   temp_apu->ext = NULL;
1011:                
1012:                   /* clear the callbacks */
1013:                   temp_apu->irq_callback = NULL;
1014:                   temp_apu->irqclear_callback = NULL;
1015:                
1016:                   apu_setcontext(temp_apu);
9D01E308  0F407647   JAL apu_setcontext
9D01E30C  02202021   ADDU A0, S1, ZERO
1017:                
1018:                   apu_setparams(base_freq, sample_rate, refresh_rate, sample_bits);
9D01E310  02802021   ADDU A0, S4, ZERO
9D01E314  02602821   ADDU A1, S3, ZERO
9D01E318  02403021   ADDU A2, S2, ZERO
9D01E31C  0F407880   JAL apu_setparams
9D01E320  02003821   ADDU A3, S0, ZERO
1019:                
1020:                   for (channel = 0; channel < 6; channel++)
9D01E324  00008021   ADDU S0, ZERO, ZERO
9D01E328  24120006   ADDIU S2, ZERO, 6
9D01E338  26100001   ADDIU S0, S0, 1
9D01E33C  1612FFFC   BNE S0, S2, 0x9D01E330
9D01E340  02002021   ADDU A0, S0, ZERO
1021:                      apu_setchan(channel, true);
9D01E32C  02002021   ADDU A0, S0, ZERO
9D01E330  0F407672   JAL apu_setchan
9D01E334  24050001   ADDIU A1, ZERO, 1
1022:                
1023:                   apu_setfilter(APU_FILTER_WEIGHTED);
1024:                
1025:                   apu_getcontext(temp_apu);
9D01E350  0F40765D   JAL apu_getcontext
9D01E354  02202021   ADDU A0, S1, ZERO
1026:                
1027:                   return temp_apu;
9D01E358  0B4078D9   J 0x9D01E364
9D01E35C  02201021   ADDU V0, S1, ZERO
1028:                }
9D01E364  8FBF0024   LW RA, 36(SP)
9D01E368  8FB40020   LW S4, 32(SP)
9D01E36C  8FB3001C   LW S3, 28(SP)
9D01E370  8FB20018   LW S2, 24(SP)
9D01E374  8FB10014   LW S1, 20(SP)
9D01E378  8FB00010   LW S0, 16(SP)
9D01E37C  03E00008   JR RA
9D01E380  27BD0028   ADDIU SP, SP, 40
1029:                
1030:                void apu_destroy(apu_t **src_apu)
1031:                {
9D01E384  27BDFFE8   ADDIU SP, SP, -24
9D01E388  AFBF0014   SW RA, 20(SP)
9D01E38C  AFB00010   SW S0, 16(SP)
1032:                   if (*src_apu)
9D01E390  8C820000   LW V0, 0(A0)
9D01E394  1040000C   BEQ V0, ZERO, 0x9D01E3C8
9D01E398  00808021   ADDU S0, A0, ZERO
1033:                   {
1034:                      if ((*src_apu)->ext && NULL != (*src_apu)->ext->shutdown)
9D01E39C  8C420168   LW V0, 360(V0)
9D01E3A0  10400006   BEQ V0, ZERO, 0x9D01E3BC
9D01E3A4  00000000   NOP
9D01E3A8  8C420004   LW V0, 4(V0)
9D01E3AC  10400003   BEQ V0, ZERO, 0x9D01E3BC
9D01E3B0  00000000   NOP
1035:                         (*src_apu)->ext->shutdown();
9D01E3B4  0040F809   JALR V0
9D01E3B8  00000000   NOP
1036:                      free(*src_apu);
9D01E3BC  0F40DB97   JAL _my_free
9D01E3C0  02002021   ADDU A0, S0, ZERO
1037:                      *src_apu = NULL;
9D01E3C4  AE000000   SW ZERO, 0(S0)
1038:                   }
1039:                }
9D01E3C8  8FBF0014   LW RA, 20(SP)
9D01E3CC  8FB00010   LW S0, 16(SP)
9D01E3D0  03E00008   JR RA
9D01E3D4  27BD0018   ADDIU SP, SP, 24
1040:                
1041:                void apu_setext(apu_t *src_apu, apuext_t *ext)
1042:                {
9D01E3EC  27BDFFE8   ADDIU SP, SP, -24
9D01E3F0  AFBF0014   SW RA, 20(SP)
1043:                   ASSERT(src_apu);
1044:                
1045:                   src_apu->ext = ext;
1046:                
1047:                   /* initialize it */
1048:                   if (src_apu->ext && NULL != src_apu->ext->init)
9D01E3D8  10A0000A   BEQ A1, ZERO, 0x9D01E404
9D01E3DC  AC850168   SW A1, 360(A0)
9D01E3E0  8CA20000   LW V0, 0(A1)
9D01E3E4  10400007   BEQ V0, ZERO, 0x9D01E404
9D01E3E8  00000000   NOP
1049:                      src_apu->ext->init();
9D01E3F4  0040F809   JALR V0
9D01E3F8  00000000   NOP
1050:                }
9D01E3FC  8FBF0014   LW RA, 20(SP)
9D01E400  27BD0018   ADDIU SP, SP, 24
9D01E404  03E00008   JR RA
9D01E408  00000000   NOP
1051:                
1052:                /*
1053:                ** $Log: nes_apu.c,v $
1054:                ** Revision 1.2  2001/04/27 14:37:11  neil
1055:                ** wheeee
1056:                **
1057:                ** Revision 1.1  2001/04/27 12:54:40  neil
1058:                ** blah
1059:                **
1060:                ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
1061:                ** initial
1062:                **
1063:                ** Revision 1.6  2000/12/08 02:36:14  matt
1064:                ** bye bye apu queue (for now)
1065:                **
1066:                ** Revision 1.5  2000/11/27 19:33:53  matt
1067:                ** no special treatment for nsf
1068:                **
1069:                ** Revision 1.4  2000/11/25 20:29:17  matt
1070:                ** weighted filter is now default
1071:                **
1072:                ** Revision 1.3  2000/11/21 13:28:19  matt
1073:                ** take care to zero allocated mem
1074:                **
1075:                ** Revision 1.2  2000/10/28 15:20:59  matt
1076:                ** irq callbacks in nes_apu
1077:                **
1078:                ** Revision 1.1  2000/10/24 12:19:59  matt
1079:                ** changed directory structure
1080:                **
1081:                ** Revision 1.44  2000/10/23 17:53:06  matt
1082:                ** set ptr to NULL after freeing
1083:                **
1084:                ** Revision 1.43  2000/10/17 11:56:42  matt
1085:                ** selectable apu base frequency
1086:                **
1087:                ** Revision 1.42  2000/10/13 12:16:01  matt
1088:                ** macro-ized the stuff that should be removed
1089:                **
1090:                ** Revision 1.41  2000/10/10 13:58:18  matt
1091:                ** stroustrup squeezing his way in the door
1092:                **
1093:                ** Revision 1.40  2000/10/03 11:56:20  matt
1094:                ** better support for optional sound ext routines
1095:                **
1096:                ** Revision 1.39  2000/09/27 12:26:03  matt
1097:                ** changed sound accumulators back to floats
1098:                **
1099:                ** Revision 1.38  2000/09/18 02:12:55  matt
1100:                ** more optimizations
1101:                **
1102:                ** Revision 1.37  2000/09/15 13:38:40  matt
1103:                ** changes for optimized apu core
1104:                **
1105:                ** Revision 1.36  2000/09/15 04:58:07  matt
1106:                ** simplifying and optimizing APU core
1107:                **
1108:                ** Revision 1.35  2000/09/07 21:57:14  matt
1109:                ** api change
1110:                **
1111:                ** Revision 1.34  2000/08/16 05:01:01  matt
1112:                ** small buglet fixed
1113:                **
1114:                ** Revision 1.33  2000/08/15 12:38:04  matt
1115:                ** removed debug output
1116:                **
1117:                ** Revision 1.32  2000/08/15 12:36:51  matt
1118:                ** calling apu_process with buffer=NULL causes silent emulation of APU
1119:                **
1120:                ** Revision 1.31  2000/08/11 02:27:21  matt
1121:                ** general cleanups, plus apu_setparams routine
1122:                **
1123:                ** Revision 1.30  2000/07/31 04:32:52  matt
1124:                ** fragsize problem fixed, perhaps
1125:                **
1126:                ** Revision 1.29  2000/07/30 04:32:59  matt
1127:                ** no more apu_getcyclerate hack
1128:                **
1129:                ** Revision 1.28  2000/07/28 03:15:46  matt
1130:                ** accuracy changes for rectangle frequency sweeps
1131:                **
1132:                ** Revision 1.27  2000/07/27 02:49:50  matt
1133:                ** eccentricity in sweeping hardware now emulated correctly
1134:                **
1135:                ** Revision 1.26  2000/07/25 02:25:14  matt
1136:                ** safer apu_destroy
1137:                **
1138:                ** Revision 1.25  2000/07/23 15:10:54  matt
1139:                ** hacks for win32
1140:                **
1141:                ** Revision 1.24  2000/07/17 01:52:31  matt
1142:                ** made sure last line of all source files is a newline
1143:                **
1144:                ** Revision 1.23  2000/07/10 19:24:55  matt
1145:                ** irqs are not supported in NSF playing mode
1146:                **
1147:                ** Revision 1.22  2000/07/10 13:54:32  matt
1148:                ** using generic nes_irq() now
1149:                **
1150:                ** Revision 1.21  2000/07/10 05:29:34  matt
1151:                ** moved joypad/oam dma from apu to ppu
1152:                **
1153:                ** Revision 1.20  2000/07/09 03:49:31  matt
1154:                ** apu irqs now draw an irq line (bleh)
1155:                **
1156:                ** Revision 1.19  2000/07/04 04:53:26  matt
1157:                ** minor changes, sound amplification
1158:                **
1159:                ** Revision 1.18  2000/07/03 02:18:53  matt
1160:                ** much better external module exporting
1161:                **
1162:                ** Revision 1.17  2000/06/26 11:01:55  matt
1163:                ** made triangle a tad quieter
1164:                **
1165:                ** Revision 1.16  2000/06/26 05:10:33  matt
1166:                ** fixed cycle rate generation accuracy
1167:                **
1168:                ** Revision 1.15  2000/06/26 05:00:37  matt
1169:                ** cleanups
1170:                **
1171:                ** Revision 1.14  2000/06/23 11:06:24  matt
1172:                ** more faithful mixing of channels
1173:                **
1174:                ** Revision 1.13  2000/06/23 03:29:27  matt
1175:                ** cleaned up external sound inteface
1176:                **
1177:                ** Revision 1.12  2000/06/20 00:08:39  matt
1178:                ** bugfix to rectangle wave
1179:                **
1180:                ** Revision 1.11  2000/06/13 13:48:58  matt
1181:                ** fixed triangle write latency for fixed point apu cycle rate
1182:                **
1183:                ** Revision 1.10  2000/06/12 01:14:36  matt
1184:                ** minor change to clipping extents
1185:                **
1186:                ** Revision 1.9  2000/06/09 20:00:56  matt
1187:                ** fixed noise hiccup in NSF player mode
1188:                **
1189:                ** Revision 1.8  2000/06/09 16:49:02  matt
1190:                ** removed all floating point from sound generation
1191:                **
1192:                ** Revision 1.7  2000/06/09 15:12:28  matt
1193:                ** initial revision
1194:                **
1195:                */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/sndhrdw/mmc5_snd.c  ------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** mmc5_snd.c
21:                  **
22:                  ** Nintendo MMC5 sound emulation
23:                  ** $Id: mmc5_snd.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <string.h>
27:                  #include <noftypes.h>
28:                  #include "mmc5_snd.h"
29:                  #include <nes_apu.h>
30:                  
31:                  /* TODO: encapsulate apu/mmc5 rectangle */
32:                  
33:                  #define  APU_OVERSAMPLE
34:                  #define  APU_VOLUME_DECAY(x)  ((x) -= ((x) >> 7))
35:                  
36:                  /* look up table madness */
37:                  static int32 decay_lut[16];
38:                  static int vbl_lut[32];
39:                  
40:                  /* various sound constants for sound emulation */
41:                  /* vblank length table used for rectangles, triangle, noise */
42:                  static const uint8 vbl_length[32] =
43:                  {
44:                     5, 127, 10, 1, 19,  2, 40,  3, 80,  4, 30,  5, 7,  6, 13,  7,
45:                     6,   8, 12, 9, 24, 10, 48, 11, 96, 12, 36, 13, 8, 14, 16, 15
46:                  };
47:                  
48:                  /* ratios of pos/neg pulse for rectangle waves
49:                  ** 2/16 = 12.5%, 4/16 = 25%, 8/16 = 50%, 12/16 = 75% 
50:                  ** (4-bit adder in rectangles, hence the 16)
51:                  */
52:                  static const int duty_lut[4] =
53:                  {
54:                     2, 4, 8, 12
55:                  };
56:                  
57:                  
58:                  #define  MMC5_WRA0    0x5000
59:                  #define  MMC5_WRA1    0x5001
60:                  #define  MMC5_WRA2    0x5002
61:                  #define  MMC5_WRA3    0x5003
62:                  #define  MMC5_WRB0    0x5004
63:                  #define  MMC5_WRB1    0x5005
64:                  #define  MMC5_WRB2    0x5006
65:                  #define  MMC5_WRB3    0x5007
66:                  #define  MMC5_SMASK   0x5015
67:                  
68:                  typedef struct mmc5rectangle_s
69:                  {
70:                     uint8 regs[4];
71:                  
72:                     bool enabled;
73:                     
74:                     float accum;
75:                     int32 freq;
76:                     int32 output_vol;
77:                     bool fixed_envelope;
78:                     bool holdnote;
79:                     uint8 volume;
80:                  
81:                     int32 env_phase;
82:                     int32 env_delay;
83:                     uint8 env_vol;
84:                  
85:                     int vbl_length;
86:                     uint8 adder;
87:                     int duty_flip;
88:                  } mmc5rectangle_t;
89:                  
90:                  typedef struct mmc5dac_s
91:                  {
92:                     int32 output;
93:                     bool enabled;
94:                  } mmc5dac_t;
95:                  
96:                  
97:                  static struct
98:                  {
99:                     float incsize;
100:                    uint8 mul[2];
101:                    mmc5rectangle_t rect[2];
102:                    mmc5dac_t dac;
103:                 } mmc5;
104:                 
105:                 
106:                 #define  MMC5_RECTANGLE_OUTPUT   chan->output_vol
107:                 static int32 mmc5_rectangle(mmc5rectangle_t *chan)
108:                 {
9D02CD9C  27BDFFC8   ADDIU SP, SP, -56
9D02CDA0  AFBF0034   SW RA, 52(SP)
9D02CDA4  AFB70030   SW S7, 48(SP)
9D02CDA8  AFB6002C   SW S6, 44(SP)
9D02CDAC  AFB50028   SW S5, 40(SP)
9D02CDB0  AFB40024   SW S4, 36(SP)
9D02CDB4  AFB30020   SW S3, 32(SP)
9D02CDB8  AFB2001C   SW S2, 28(SP)
9D02CDBC  AFB10018   SW S1, 24(SP)
9D02CDC0  AFB00014   SW S0, 20(SP)
9D02CDC4  00808021   ADDU S0, A0, ZERO
109:                    int32 output;
110:                 
111:                 #ifdef APU_OVERSAMPLE
112:                    int num_times;
113:                    int32 total;
114:                 #endif /* APU_OVERSAMPLE */
115:                 
116:                    /* reg0: 0-3=volume, 4=envelope, 5=hold, 6-7=duty cycle
117:                    ** reg1: 0-2=sweep shifts, 3=sweep inc/dec, 4-6=sweep length, 7=sweep on
118:                    ** reg2: 8 bits of freq
119:                    ** reg3: 0-2=high freq, 7-4=vbl length counter
120:                    */
121:                 
122:                    APU_VOLUME_DECAY(chan->output_vol);
9D02CDC8  8C820010   LW V0, 16(A0)
9D02CDCC  000289C3   SRA S1, V0, 7
9D02CDD0  00518823   SUBU S1, V0, S1
9D02CDD4  AC910010   SW S1, 16(A0)
123:                 
124:                    if (false == chan->enabled || 0 == chan->vbl_length)
9D02CDD8  8C820004   LW V0, 4(A0)
9D02CDDC  10400058   BEQ V0, ZERO, 0x9D02CF40
9D02CDE0  02201821   ADDU V1, S1, ZERO
9D02CDE4  8C82002C   LW V0, 44(A0)
9D02CDE8  50400056   BEQL V0, ZERO, 0x9D02CF44
9D02CDEC  00601021   ADDU V0, V1, ZERO
125:                       return MMC5_RECTANGLE_OUTPUT;
126:                 
127:                    /* vbl length counter */
128:                    if (false == chan->holdnote)
9D02CDF0  8C840018   LW A0, 24(A0)
9D02CDF4  54800004   BNEL A0, ZERO, 0x9D02CE08
9D02CDF8  8E020020   LW V0, 32(S0)
129:                       chan->vbl_length--;
9D02CDFC  2442FFFF   ADDIU V0, V0, -1
9D02CE00  AE02002C   SW V0, 44(S0)
130:                 
131:                    /* envelope decay at a rate of (env_delay + 1) / 240 secs */
132:                    chan->env_phase -= 4; /* 240/60 */
9D02CE04  8E020020   LW V0, 32(S0)
9D02CE08  2442FFFC   ADDIU V0, V0, -4
133:                    while (chan->env_phase < 0)
9D02CE0C  0B40B393   J 0x9D02CE4C
9D02CE10  AE020020   SW V0, 32(S0)
9D02CE4C  8E020020   LW V0, 32(S0)
9D02CE50  0442FFF0   BLTZL V0, 0x9D02CE14
9D02CE54  8E030024   LW V1, 36(S0)
134:                    {
135:                       chan->env_phase += chan->env_delay;
9D02CE14  00431021   ADDU V0, V0, V1
136:                 
137:                       if (chan->holdnote)
9D02CE18  10800006   BEQ A0, ZERO, 0x9D02CE34
9D02CE1C  AE020020   SW V0, 32(S0)
138:                          chan->env_vol = (chan->env_vol + 1) & 0x0F;
9D02CE20  92020028   LBU V0, 40(S0)
9D02CE24  24420001   ADDIU V0, V0, 1
9D02CE28  3042000F   ANDI V0, V0, 15
9D02CE2C  0B40B393   J 0x9D02CE4C
9D02CE30  A2020028   SB V0, 40(S0)
139:                       else if (chan->env_vol < 0x0F)
9D02CE34  92020028   LBU V0, 40(S0)
9D02CE38  2C43000F   SLTIU V1, V0, 15
9D02CE3C  50600004   BEQL V1, ZERO, 0x9D02CE50
9D02CE40  8E020020   LW V0, 32(S0)
140:                          chan->env_vol++;
9D02CE44  24420001   ADDIU V0, V0, 1
9D02CE48  A2020028   SB V0, 40(S0)
141:                    }
142:                 
143:                    if (chan->freq < 4)
9D02CE58  8E16000C   LW S6, 12(S0)
9D02CE5C  2AC20004   SLTI V0, S6, 4
9D02CE60  14400037   BNE V0, ZERO, 0x9D02CF40
9D02CE64  02201821   ADDU V1, S1, ZERO
144:                       return MMC5_RECTANGLE_OUTPUT;
145:                 
146:                    chan->accum -= mmc5.incsize; /* # of cycles per sample */
9D02CE68  8E040008   LW A0, 8(S0)
9D02CE6C  3C02A001   LUI V0, -24575
9D02CE70  0F40CFF8   JAL __subsf3
9D02CE74  8C45A3B0   LW A1, -23632(V0)
9D02CE78  00409021   ADDU S2, V0, ZERO
9D02CE7C  AE020008   SW V0, 8(S0)
147:                    if (chan->accum >= 0)
9D02CE80  00002021   ADDU A0, ZERO, ZERO
9D02CE84  0F40E8E3   JAL __lesf2
9D02CE88  00402821   ADDU A1, V0, ZERO
9D02CE8C  1840002C   BLEZ V0, 0x9D02CF40
9D02CE90  02201821   ADDU V1, S1, ZERO
148:                       return MMC5_RECTANGLE_OUTPUT;
149:                 
150:                 #ifdef APU_OVERSAMPLE
151:                    num_times = total = 0;
152:                 
153:                    if (chan->fixed_envelope)
9D02CE94  8E020014   LW V0, 20(S0)
9D02CE98  5040000B   BEQL V0, ZERO, 0x9D02CEC8
9D02CE9C  92150028   LBU S5, 40(S0)
154:                       output = chan->volume << 8; /* fixed volume */
9D02CEA0  9215001C   LBU S5, 28(S0)
9D02CEA4  0015AA00   SLL S5, S5, 8
155:                    else
156:                       output = (chan->env_vol ^ 0x0F) << 8;
9D02CEC8  3AB5000F   XORI S5, S5, 15
9D02CECC  0B40B3AA   J 0x9D02CEA8
9D02CED0  0015AA00   SLL S5, S5, 8
9D02CED4  92130030   LBU S3, 48(S0)
157:                 #endif
158:                 
159:                    while (chan->accum < 0)
9D02CEA8  02402021   ADDU A0, S2, ZERO
9D02CEAC  0F40E8E3   JAL __lesf2
9D02CEB0  00002821   ADDU A1, ZERO, ZERO
9D02CEB4  00008821   ADDU S1, ZERO, ZERO
9D02CEB8  0441001D   BGEZ V0, 0x9D02CF30
9D02CEBC  0000A021   ADDU S4, ZERO, ZERO
9D02CF14  02402021   ADDU A0, S2, ZERO
9D02CF18  0F40E8E3   JAL __lesf2
9D02CF1C  00002821   ADDU A1, ZERO, ZERO
9D02CF20  0440FFEF   BLTZ V0, 0x9D02CEE0
9D02CF24  00000000   NOP
9D02CF28  AE120008   SW S2, 8(S0)
9D02CF2C  A2130030   SB S3, 48(S0)
160:                    {
161:                       chan->accum += chan->freq;
9D02CEE0  0F40ECB4   JAL sitofp
9D02CEE4  02C02021   ADDU A0, S6, ZERO
9D02CEE8  02402021   ADDU A0, S2, ZERO
9D02CEEC  0F40CFFA   JAL fpadd
9D02CEF0  00402821   ADDU A1, V0, ZERO
9D02CEF4  00409021   ADDU S2, V0, ZERO
162:                       chan->adder = (chan->adder + 1) & 0x0F;
9D02CEF8  26730001   ADDIU S3, S3, 1
9D02CEFC  3273000F   ANDI S3, S3, 15
163:                 
164:                 #ifdef APU_OVERSAMPLE
165:                       if (chan->adder < chan->duty_flip)
9D02CEC0  0B40B3B5   J 0x9D02CED4
9D02CEC4  8E170034   LW S7, 52(S0)
9D02CED8  00008821   ADDU S1, ZERO, ZERO
9D02CEDC  0000A021   ADDU S4, ZERO, ZERO
9D02CF00  0277182A   SLT V1, S3, S7
166:                          total += output;
9D02CF04  02351021   ADDU V0, S1, S5
9D02CF08  02358823   SUBU S1, S1, S5
9D02CF0C  0043880B   MOVN S1, V0, V1
167:                       else
168:                          total -= output;
169:                 
170:                       num_times++;
9D02CF10  26940001   ADDIU S4, S4, 1
171:                 #endif
172:                    }
173:                 
174:                 #ifdef APU_OVERSAMPLE
175:                    chan->output_vol = total / num_times;
9D02CF30  0234001A   DIV S1, S4
9D02CF34  028001F4   TEQ S4, ZERO
9D02CF38  00001812   MFLO V1
9D02CF3C  AE030010   SW V1, 16(S0)
176:                 #else
177:                    if (chan->fixed_envelope)
178:                       output = chan->volume << 8; /* fixed volume */
179:                    else
180:                       output = (chan->env_vol ^ 0x0F) << 8;
181:                 
182:                    if (0 == chan->adder)
183:                       chan->output_vol = output;
184:                    else if (chan->adder == chan->duty_flip)
185:                       chan->output_vol = -output;
186:                 #endif
187:                 
188:                    return MMC5_RECTANGLE_OUTPUT;
189:                 }
9D02CF40  00601021   ADDU V0, V1, ZERO
9D02CF44  8FBF0034   LW RA, 52(SP)
9D02CF48  8FB70030   LW S7, 48(SP)
9D02CF4C  8FB6002C   LW S6, 44(SP)
9D02CF50  8FB50028   LW S5, 40(SP)
9D02CF54  8FB40024   LW S4, 36(SP)
9D02CF58  8FB30020   LW S3, 32(SP)
9D02CF5C  8FB2001C   LW S2, 28(SP)
9D02CF60  8FB10018   LW S1, 24(SP)
9D02CF64  8FB00014   LW S0, 20(SP)
9D02CF68  03E00008   JR RA
9D02CF6C  27BD0038   ADDIU SP, SP, 56
190:                 
191:                 static uint8 mmc5_read(uint32 address)
192:                 {
193:                    uint32 retval;
194:                 
195:                    retval = (uint32) (mmc5.mul[0] * mmc5.mul[1]);
9D02CF70  3C03A001   LUI V1, -24575
9D02CF74  2463A3B0   ADDIU V1, V1, -23632
9D02CF78  90650004   LBU A1, 4(V1)
9D02CF7C  90620005   LBU V0, 5(V1)
196:                 
197:                    switch (address)
9D02CF80  24035205   ADDIU V1, ZERO, 20997
9D02CF84  10830006   BEQ A0, V1, 0x9D02CFA0
9D02CF88  70A21002   MUL V0, A1, V0
198:                    {
199:                    case 0x5205:
200:                       return (uint8) retval;
201:                 
202:                    case 0x5206:
203:                       return (uint8) (retval >> 8);
204:                 
205:                    default:
206:                       return 0xFF;
9D02CF8C  00021202   SRL V0, V0, 8
9D02CF90  38845206   XORI A0, A0, 20998
9D02CF94  240300FF   ADDIU V1, ZERO, 255
9D02CF98  03E00008   JR RA
9D02CF9C  0064100B   MOVN V0, V1, A0
207:                    }
208:                 }
9D02CFA0  03E00008   JR RA
9D02CFA4  304200FF   ANDI V0, V0, 255
209:                 
210:                 /* mix vrcvi sound channels together */
211:                 static int32 mmc5_process(void)
212:                 {
9D02CFA8  27BDFFE8   ADDIU SP, SP, -24
9D02CFAC  AFBF0014   SW RA, 20(SP)
9D02CFB0  AFB00010   SW S0, 16(SP)
213:                    int32 accum;
214:                 
215:                    accum = mmc5_rectangle(&mmc5.rect[0]);
9D02CFB4  3C04A001   LUI A0, -24575
9D02CFB8  0F40B367   JAL .Letext0, .LFE14, .LFB5, mmc5_rectangle, .Ltext0
9D02CFBC  2484A3B8   ADDIU A0, A0, -23624
9D02CFC0  00408021   ADDU S0, V0, ZERO
216:                    accum += mmc5_rectangle(&mmc5.rect[1]);
9D02CFC4  3C04A001   LUI A0, -24575
9D02CFC8  0F40B367   JAL .Letext0, .LFE14, .LFB5, mmc5_rectangle, .Ltext0
9D02CFCC  2484A3F0   ADDIU A0, A0, -23568
217:                    if (mmc5.dac.enabled)
9D02CFD0  3C03A001   LUI V1, -24575
9D02CFD4  8C63A42C   LW V1, -23508(V1)
9D02CFD8  10600004   BEQ V1, ZERO, 0x9D02CFEC
9D02CFDC  00501021   ADDU V0, V0, S0
218:                       accum += mmc5.dac.output;
9D02CFE0  3C03A001   LUI V1, -24575
9D02CFE4  8C63A428   LW V1, -23512(V1)
9D02CFE8  00431021   ADDU V0, V0, V1
219:                 
220:                    return accum;
221:                 }
9D02CFEC  8FBF0014   LW RA, 20(SP)
9D02CFF0  8FB00010   LW S0, 16(SP)
9D02CFF4  03E00008   JR RA
9D02CFF8  27BD0018   ADDIU SP, SP, 24
222:                 
223:                 /* write to registers */
224:                 static void mmc5_write(uint32 address, uint8 value)
225:                 {
226:                    int chan;
227:                 
228:                    switch (address)
9D02CFFC  24025007   ADDIU V0, ZERO, 20487
9D02D000  1082005B   BEQ A0, V0, 0x9D02D170
9D02D004  2C825008   SLTIU V0, A0, 20488
9D02D008  10400013   BEQ V0, ZERO, 0x9D02D058
9D02D00C  24025015   ADDIU V0, ZERO, 20501
9D02D010  24025003   ADDIU V0, ZERO, 20483
9D02D014  10820056   BEQ A0, V0, 0x9D02D170
9D02D018  2C825004   SLTIU V0, A0, 20484
9D02D01C  10400007   BEQ V0, ZERO, 0x9D02D03C
9D02D020  24025000   ADDIU V0, ZERO, 20480
9D02D024  1082001D   BEQ A0, V0, 0x9D02D09C
9D02D028  24025002   ADDIU V0, ZERO, 20482
9D02D02C  1082003C   BEQ A0, V0, 0x9D02D120
9D02D030  7C840080   EXT A0, A0, 2, 1
9D02D034  03E00008   JR RA
9D02D038  00000000   NOP
9D02D03C  24025004   ADDIU V0, ZERO, 20484
9D02D040  10820016   BEQ A0, V0, 0x9D02D09C
9D02D044  24025006   ADDIU V0, ZERO, 20486
9D02D048  10820035   BEQ A0, V0, 0x9D02D120
9D02D04C  7C840080   EXT A0, A0, 2, 1
9D02D050  03E00008   JR RA
9D02D054  00000000   NOP
9D02D058  1082006A   BEQ A0, V0, 0x9D02D204
9D02D05C  2C825016   SLTIU V0, A0, 20502
9D02D060  10400007   BEQ V0, ZERO, 0x9D02D080
9D02D064  24025010   ADDIU V0, ZERO, 20496
9D02D068  1082007C   BEQ A0, V0, 0x9D02D25C
9D02D06C  24025011   ADDIU V0, ZERO, 20497
9D02D070  10820082   BEQ A0, V0, 0x9D02D27C
9D02D074  38A50080   XORI A1, A1, 128
9D02D078  03E00008   JR RA
9D02D07C  00000000   NOP
9D02D080  24025205   ADDIU V0, ZERO, 20997
9D02D084  10820081   BEQ A0, V0, 0x9D02D28C
9D02D088  24025206   ADDIU V0, ZERO, 20998
9D02D08C  10820082   BEQ A0, V0, 0x9D02D298
9D02D090  3C02A001   LUI V0, -24575
9D02D094  03E00008   JR RA
9D02D098  00000000   NOP
229:                    {
230:                    /* rectangles */
231:                    case MMC5_WRA0:
232:                    case MMC5_WRB0:
233:                       chan = (address & 4) ? 1 : 0;
9D02D09C  7C840080   EXT A0, A0, 2, 1
234:                       mmc5.rect[chan].regs[0] = value;
9D02D0A0  000410C0   SLL V0, A0, 3
9D02D0A4  00041980   SLL V1, A0, 6
9D02D0A8  00621023   SUBU V0, V1, V0
9D02D0AC  3C03A001   LUI V1, -24575
9D02D0B0  2463A3B0   ADDIU V1, V1, -23632
9D02D0B4  00431021   ADDU V0, V0, V1
9D02D0B8  A0450008   SB A1, 8(V0)
235:                 
236:                       mmc5.rect[chan].volume = value & 0x0F;
9D02D0BC  30A6000F   ANDI A2, A1, 15
9D02D0C0  A0460024   SB A2, 36(V0)
237:                       mmc5.rect[chan].env_delay = decay_lut[value & 0x0F];
9D02D0C4  00063080   SLL A2, A2, 2
9D02D0C8  3C07A001   LUI A3, -24575
9D02D0CC  24E7A4B0   ADDIU A3, A3, -23376
9D02D0D0  00C73021   ADDU A2, A2, A3
9D02D0D4  8CC60000   LW A2, 0(A2)
9D02D0D8  AC46002C   SW A2, 44(V0)
238:                       mmc5.rect[chan].holdnote = (value & 0x20) ? true : false;
9D02D0DC  7CA60140   EXT A2, A1, 5, 1
9D02D0E0  AC460020   SW A2, 32(V0)
239:                       mmc5.rect[chan].fixed_envelope = (value & 0x10) ? true : false;
9D02D0E4  7CA60100   EXT A2, A1, 4, 1
9D02D0E8  AC46001C   SW A2, 28(V0)
240:                       mmc5.rect[chan].duty_flip = duty_lut[value >> 6];
9D02D0EC  24840001   ADDIU A0, A0, 1
9D02D0F0  000410C0   SLL V0, A0, 3
9D02D0F4  00042180   SLL A0, A0, 6
9D02D0F8  00822023   SUBU A0, A0, V0
9D02D0FC  00641821   ADDU V1, V1, A0
9D02D100  00052982   SRL A1, A1, 6
9D02D104  00052880   SLL A1, A1, 2
9D02D108  3C029D04   LUI V0, -25340
9D02D10C  2442BCD4   ADDIU V0, V0, -17196
9D02D110  00A22821   ADDU A1, A1, V0
9D02D114  8CA20000   LW V0, 0(A1)
241:                       break;
9D02D118  03E00008   JR RA
9D02D11C  AC620004   SW V0, 4(V1)
242:                 
243:                    case MMC5_WRA1:
244:                    case MMC5_WRB1:
245:                       break;
246:                 
247:                    case MMC5_WRA2:
248:                    case MMC5_WRB2:
249:                       chan = (address & 4) ? 1 : 0;
250:                       mmc5.rect[chan].regs[2] = value;
9D02D120  000410C0   SLL V0, A0, 3
9D02D124  00041980   SLL V1, A0, 6
9D02D128  00621023   SUBU V0, V1, V0
9D02D12C  3C03A001   LUI V1, -24575
9D02D130  2463A3B0   ADDIU V1, V1, -23632
9D02D134  00431021   ADDU V0, V0, V1
9D02D138  A045000A   SB A1, 10(V0)
251:                       if (mmc5.rect[chan].enabled)
9D02D13C  8C42000C   LW V0, 12(V0)
9D02D140  1040FFBC   BEQ V0, ZERO, 0x9D02D034
9D02D144  000410C0   SLL V0, A0, 3
252:                          mmc5.rect[chan].freq = (((mmc5.rect[chan].regs[3] & 7) << 8) + value) + 1;
9D02D148  00042180   SLL A0, A0, 6
9D02D14C  00822023   SUBU A0, A0, V0
9D02D150  00641021   ADDU V0, V1, A0
9D02D154  9043000B   LBU V1, 11(V0)
9D02D158  30630007   ANDI V1, V1, 7
9D02D15C  00031A00   SLL V1, V1, 8
9D02D160  00652821   ADDU A1, V1, A1
9D02D164  24A50001   ADDIU A1, A1, 1
9D02D168  03E00008   JR RA
9D02D16C  AC450014   SW A1, 20(V0)
253:                       break;
254:                 
255:                    case MMC5_WRA3:
256:                    case MMC5_WRB3:
257:                       chan = (address & 4) ? 1 : 0;
9D02D170  7C840080   EXT A0, A0, 2, 1
258:                       mmc5.rect[chan].regs[3] = value;
9D02D174  000410C0   SLL V0, A0, 3
9D02D178  00041980   SLL V1, A0, 6
9D02D17C  00621023   SUBU V0, V1, V0
9D02D180  3C03A001   LUI V1, -24575
9D02D184  2463A3B0   ADDIU V1, V1, -23632
9D02D188  00431021   ADDU V0, V0, V1
9D02D18C  A045000B   SB A1, 11(V0)
259:                 
260:                       if (mmc5.rect[chan].enabled)
9D02D190  8C42000C   LW V0, 12(V0)
9D02D194  1040FFA7   BEQ V0, ZERO, 0x9D02D034
9D02D198  3C03A001   LUI V1, -24575
261:                       {
262:                          mmc5.rect[chan].vbl_length = vbl_lut[value >> 3];
9D02D19C  2463A3B0   ADDIU V1, V1, -23632
9D02D1A0  000410C0   SLL V0, A0, 3
9D02D1A4  00043180   SLL A2, A0, 6
9D02D1A8  00C21023   SUBU V0, A2, V0
9D02D1AC  00621021   ADDU V0, V1, V0
9D02D1B0  000538C2   SRL A3, A1, 3
9D02D1B4  00073880   SLL A3, A3, 2
9D02D1B8  3C06A001   LUI A2, -24575
9D02D1BC  24C6A430   ADDIU A2, A2, -23504
9D02D1C0  00E63021   ADDU A2, A3, A2
9D02D1C4  8CC60000   LW A2, 0(A2)
9D02D1C8  AC460034   SW A2, 52(V0)
263:                          mmc5.rect[chan].env_vol = 0;
9D02D1CC  A0400030   SB ZERO, 48(V0)
264:                          mmc5.rect[chan].freq = (((value & 7) << 8) + mmc5.rect[chan].regs[2]) + 1;
9D02D1D0  30A50007   ANDI A1, A1, 7
9D02D1D4  00052A00   SLL A1, A1, 8
9D02D1D8  9046000A   LBU A2, 10(V0)
9D02D1DC  00A62821   ADDU A1, A1, A2
9D02D1E0  24A50001   ADDIU A1, A1, 1
9D02D1E4  AC450014   SW A1, 20(V0)
265:                          mmc5.rect[chan].adder = 0;
9D02D1E8  24840001   ADDIU A0, A0, 1
9D02D1EC  000410C0   SLL V0, A0, 3
9D02D1F0  00042180   SLL A0, A0, 6
9D02D1F4  00822023   SUBU A0, A0, V0
9D02D1F8  00831821   ADDU V1, A0, V1
9D02D1FC  03E00008   JR RA
9D02D200  A0600000   SB ZERO, 0(V1)
266:                       }
267:                       break;
268:                    
269:                    case MMC5_SMASK:
270:                       if (value & 0x01)
9D02D204  30A20001   ANDI V0, A1, 1
9D02D208  10400005   BEQ V0, ZERO, 0x9D02D220
9D02D20C  3C02A001   LUI V0, -24575
271:                       {
272:                          mmc5.rect[0].enabled = true;
9D02D210  24030001   ADDIU V1, ZERO, 1
9D02D214  3C02A001   LUI V0, -24575
9D02D218  0B40B48B   J 0x9D02D22C
9D02D21C  AC43A3BC   SW V1, -23620(V0)
273:                       }
274:                       else
275:                       {
276:                          mmc5.rect[0].enabled = false;
9D02D220  2442A3B0   ADDIU V0, V0, -23632
9D02D224  AC40000C   SW ZERO, 12(V0)
277:                          mmc5.rect[0].vbl_length = 0;
9D02D228  AC400034   SW ZERO, 52(V0)
278:                       }
279:                 
280:                       if (value & 0x02)
9D02D22C  30A50002   ANDI A1, A1, 2
9D02D230  30A500FF   ANDI A1, A1, 255
9D02D234  10A00005   BEQ A1, ZERO, 0x9D02D24C
9D02D238  3C02A001   LUI V0, -24575
281:                       {
282:                          mmc5.rect[1].enabled = true;
9D02D23C  24030001   ADDIU V1, ZERO, 1
9D02D240  3C02A001   LUI V0, -24575
9D02D244  03E00008   JR RA
9D02D248  AC43A3F4   SW V1, -23564(V0)
283:                       }
284:                       else
285:                       {
286:                          mmc5.rect[1].enabled = false;
9D02D24C  2442A3B0   ADDIU V0, V0, -23632
9D02D250  AC400044   SW ZERO, 68(V0)
287:                          mmc5.rect[1].vbl_length = 0;
9D02D254  03E00008   JR RA
9D02D258  AC40006C   SW ZERO, 108(V0)
288:                       }
289:                 
290:                       break;
291:                 
292:                    case 0x5010:
293:                       if (value & 0x01)
9D02D25C  30A50001   ANDI A1, A1, 1
9D02D260  10A00004   BEQ A1, ZERO, 0x9D02D274
9D02D264  3C02A001   LUI V0, -24575
294:                          mmc5.dac.enabled = true;
9D02D268  24030001   ADDIU V1, ZERO, 1
9D02D26C  03E00008   JR RA
9D02D270  AC43A42C   SW V1, -23508(V0)
295:                       else
296:                          mmc5.dac.enabled = false;
9D02D274  03E00008   JR RA
9D02D278  AC40A42C   SW ZERO, -23508(V0)
297:                       break;
298:                 
299:                    case 0x5011:
300:                       mmc5.dac.output = (value ^ 0x80) << 8;
9D02D27C  00052A00   SLL A1, A1, 8
9D02D280  3C02A001   LUI V0, -24575
301:                       break;
9D02D284  03E00008   JR RA
9D02D288  AC45A428   SW A1, -23512(V0)
302:                 
303:                    case 0x5205:
304:                       mmc5.mul[0] = value;
9D02D28C  3C02A001   LUI V0, -24575
305:                       break;
9D02D290  03E00008   JR RA
9D02D294  A045A3B4   SB A1, -23628(V0)
306:                 
307:                    case 0x5206:
308:                       mmc5.mul[1] = value;
9D02D298  A045A3B5   SB A1, -23627(V0)
9D02D29C  03E00008   JR RA
9D02D2A0  00000000   NOP
309:                       break;
310:                 
311:                    case 0x5114:
312:                    case 0x5115:
313:                       /* ???? */
314:                       break;
315:                    
316:                    default:
317:                       break;
318:                    }
319:                 }
320:                 
321:                 /* reset state of vrcvi sound channels */
322:                 static void mmc5_reset(void)
323:                 {
9D02D2A4  27BDFE70   ADDIU SP, SP, -400
9D02D2A8  AFBF018C   SW RA, 396(SP)
9D02D2AC  AFB10188   SW S1, 392(SP)
9D02D2B0  AFB00184   SW S0, 388(SP)
324:                    int i;
325:                    apu_t apu;
326:                 
327:                 
328:                    /* get the phase period from the apu */
329:                    apu_getcontext(&apu);
9D02D2B4  0F40765D   JAL apu_getcontext
9D02D2B8  27A40010   ADDIU A0, SP, 16
330:                    mmc5.incsize = apu.cycle_rate;
9D02D2BC  8FA3015C   LW V1, 348(SP)
9D02D2C0  3C02A001   LUI V0, -24575
9D02D2C4  AC43A3B0   SW V1, -23632(V0)
331:                 
332:                    for (i = 0x5000; i < 0x5008; i++)
9D02D2C8  24105000   ADDIU S0, ZERO, 20480
9D02D2CC  24115008   ADDIU S1, ZERO, 20488
9D02D2DC  26100001   ADDIU S0, S0, 1
9D02D2E0  1611FFFC   BNE S0, S1, 0x9D02D2D4
9D02D2E4  02002021   ADDU A0, S0, ZERO
333:                       mmc5_write(i, 0);
9D02D2D0  02002021   ADDU A0, S0, ZERO
9D02D2D4  0F40B3FF   JAL .LFB8, mmc5_write, .LFE7
9D02D2D8  00002821   ADDU A1, ZERO, ZERO
334:                 
335:                    mmc5_write(0x5010, 0);
9D02D2E8  24045010   ADDIU A0, ZERO, 20496
9D02D2EC  0F40B3FF   JAL .LFB8, mmc5_write, .LFE7
9D02D2F0  00002821   ADDU A1, ZERO, ZERO
336:                    mmc5_write(0x5011, 0);
9D02D2F4  24045011   ADDIU A0, ZERO, 20497
9D02D2F8  0F40B3FF   JAL .LFB8, mmc5_write, .LFE7
9D02D2FC  00002821   ADDU A1, ZERO, ZERO
337:                 }
9D02D300  8FBF018C   LW RA, 396(SP)
9D02D304  8FB10188   LW S1, 392(SP)
9D02D308  8FB00184   LW S0, 388(SP)
9D02D30C  03E00008   JR RA
9D02D310  27BD0190   ADDIU SP, SP, 400
338:                 
339:                 static int mmc5_init(void)
340:                 {
9D02D314  27BDFE78   ADDIU SP, SP, -392
9D02D318  AFBF0184   SW RA, 388(SP)
341:                    int i, num_samples;
342:                    apu_t apu;
343:                 
344:                    apu_getcontext(&apu);
9D02D31C  0F40765D   JAL apu_getcontext
9D02D320  27A40010   ADDIU A0, SP, 16
345:                    num_samples = apu.num_samples;
9D02D324  8FA5014C   LW A1, 332(SP)
9D02D328  00A03021   ADDU A2, A1, ZERO
9D02D32C  3C02A001   LUI V0, -24575
9D02D330  2442A4B0   ADDIU V0, V0, -23376
9D02D334  24440040   ADDIU A0, V0, 64
9D02D338  00A01821   ADDU V1, A1, ZERO
346:                 
347:                    /* lut used for enveloping and frequency sweeps */
348:                    for (i = 0; i < 16; i++)
9D02D344  1444FFFD   BNE V0, A0, 0x9D02D33C
9D02D348  00661821   ADDU V1, V1, A2
9D02D34C  3C029D04   LUI V0, -25340
9D02D350  2442BCE4   ADDIU V0, V0, -17180
9D02D354  3C03A001   LUI V1, -24575
9D02D358  2463A430   ADDIU V1, V1, -23504
9D02D35C  24460020   ADDIU A2, V0, 32
349:                       decay_lut[i] = num_samples * (i + 1);
9D02D33C  AC430000   SW V1, 0(V0)
9D02D340  24420004   ADDIU V0, V0, 4
350:                 
351:                    /* used for note length, based on vblanks and size of audio buffer */
352:                    for (i = 0; i < 32; i++)
9D02D370  1446FFFB   BNE V0, A2, 0x9D02D360
9D02D374  24630004   ADDIU V1, V1, 4
353:                       vbl_lut[i] = vbl_length[i] * num_samples;
9D02D360  90440000   LBU A0, 0(V0)
9D02D364  70852002   MUL A0, A0, A1
9D02D368  AC640000   SW A0, 0(V1)
9D02D36C  24420001   ADDIU V0, V0, 1
354:                 
355:                    return 0;
356:                 }
9D02D378  00001021   ADDU V0, ZERO, ZERO
9D02D37C  8FBF0184   LW RA, 388(SP)
9D02D380  03E00008   JR RA
9D02D384  27BD0188   ADDIU SP, SP, 392
357:                 
358:                 static apu_memread mmc5_memread[] =
359:                 {
360:                    { 0x5205, 0x5206, mmc5_read },
361:                    {     -1,     -1, NULL }
362:                 };
363:                 
364:                 static apu_memwrite mmc5_memwrite[] =
365:                 {
366:                    { 0x5000, 0x5015, mmc5_write },
367:                    { 0x5114, 0x5115, mmc5_write },
368:                    { 0x5205, 0x5206, mmc5_write },
369:                    {     -1,     -1, NULL }
370:                 };
371:                 
372:                 apuext_t mmc5_ext =
373:                 {
374:                    mmc5_init,
375:                    NULL, /* no shutdown */
376:                    mmc5_reset,
377:                    mmc5_process,
378:                    mmc5_memread,
379:                    mmc5_memwrite
380:                 };
381:                 
382:                 /*
383:                 ** $Log: mmc5_snd.c,v $
384:                 ** Revision 1.2  2001/04/27 14:37:11  neil
385:                 ** wheeee
386:                 **
387:                 ** Revision 1.1  2001/04/27 12:54:40  neil
388:                 ** blah
389:                 **
390:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
391:                 ** initial
392:                 **
393:                 ** Revision 1.2  2000/11/13 00:57:08  matt
394:                 ** doesn't look as nasty now
395:                 **
396:                 ** Revision 1.1  2000/10/24 12:19:59  matt
397:                 ** changed directory structure
398:                 **
399:                 ** Revision 1.16  2000/10/17 11:56:42  matt
400:                 ** selectable apu base frequency
401:                 **
402:                 ** Revision 1.15  2000/10/10 14:04:29  matt
403:                 ** make way for bjarne
404:                 **
405:                 ** Revision 1.14  2000/10/10 13:58:18  matt
406:                 ** stroustrup squeezing his way in the door
407:                 **
408:                 ** Revision 1.13  2000/10/08 17:50:18  matt
409:                 ** appears $5114/$5115 do something
410:                 **
411:                 ** Revision 1.12  2000/10/03 11:56:20  matt
412:                 ** better support for optional sound ext routines
413:                 **
414:                 ** Revision 1.11  2000/09/27 12:26:03  matt
415:                 ** changed sound accumulators back to floats
416:                 **
417:                 ** Revision 1.10  2000/09/15 13:38:40  matt
418:                 ** changes for optimized apu core
419:                 **
420:                 ** Revision 1.9  2000/09/15 04:58:07  matt
421:                 ** simplifying and optimizing APU core
422:                 **
423:                 ** Revision 1.8  2000/07/30 04:32:59  matt
424:                 ** no more apu_getcyclerate hack
425:                 **
426:                 ** Revision 1.7  2000/07/17 01:52:31  matt
427:                 ** made sure last line of all source files is a newline
428:                 **
429:                 ** Revision 1.6  2000/07/04 04:51:41  matt
430:                 ** cleanups
431:                 **
432:                 ** Revision 1.5  2000/07/03 02:18:53  matt
433:                 ** much better external module exporting
434:                 **
435:                 ** Revision 1.4  2000/06/28 22:03:51  matt
436:                 ** fixed stupid oversight
437:                 **
438:                 ** Revision 1.3  2000/06/20 20:46:58  matt
439:                 ** minor cleanups
440:                 **
441:                 ** Revision 1.2  2000/06/20 04:06:16  matt
442:                 ** migrated external sound definition to apu module
443:                 **
444:                 ** Revision 1.1  2000/06/20 00:06:47  matt
445:                 ** initial revision
446:                 **
447:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/sndhrdw/fds_snd.c  -------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** fds_snd.c
21:                  **
22:                  ** Famicom Disk System sound emulation
23:                  ** $Id: fds_snd.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_apu.h>
28:                  #include <fds_snd.h>
29:                  
30:                  static int32 fds_incsize = 0;
31:                  
32:                  /* mix sound channels together */
33:                  static int32 fds_process(void)
34:                  {
35:                     int32 output;
36:                     output = 0;
37:                  
38:                     return output;
39:                  }
9D03B650  03E00008   JR RA
9D03B654  00001021   ADDU V0, ZERO, ZERO
40:                  
41:                  /* write to registers */
42:                  static void fds_write(uint32 address, uint8 value)
43:                  {
9D03B658  03E00008   JR RA
9D03B65C  00000000   NOP
44:                     UNUSED(address);
45:                     UNUSED(value);
46:                  }
47:                  
48:                  /* reset state of vrcvi sound channels */
49:                  static void fds_reset(void)
50:                  {
9D03B660  27BDFE78   ADDIU SP, SP, -392
9D03B664  AFBF0184   SW RA, 388(SP)
51:                     apu_t apu;
52:                  
53:                     apu_getcontext(&apu);
9D03B668  0F40765D   JAL apu_getcontext
9D03B66C  27A40010   ADDIU A0, SP, 16
54:                  //   fds_incsize = apu.cycle_rate;
55:                     fds_incsize = (int32) (APU_BASEFREQ * 65536.0 / (float) apu.sample_rate);
9D03B670  0F40ECB4   JAL sitofp
9D03B674  8FA40160   LW A0, 352(SP)
9D03B678  3C039D04   LUI V1, -25340
9D03B67C  8C64C504   LW A0, -15100(V1)
9D03B680  0F40D242   JAL __divsf3
9D03B684  00402821   ADDU A1, V0, ZERO
9D03B688  0F40EA89   JAL __fixsfsi
9D03B68C  00402021   ADDU A0, V0, ZERO
9D03B690  AF828120   SW V0, -32480(GP)
56:                  }
9D03B694  8FBF0184   LW RA, 388(SP)
9D03B698  03E00008   JR RA
9D03B69C  27BD0188   ADDIU SP, SP, 392
57:                  
58:                  static apu_memwrite fds_memwrite[] =
59:                  {
60:                     { 0x4040, 0x4092, fds_write }, 
61:                     {     -1,     -1, NULL }
62:                  };
63:                  
64:                  apuext_t fds_ext = 
65:                  {
66:                     NULL, /* no init */
67:                     NULL, /* no shutdown */
68:                     fds_reset,
69:                     fds_process,
70:                     NULL, /* no reads */
71:                     fds_memwrite
72:                  };
73:                  
74:                  /*
75:                  ** $Log: fds_snd.c,v $
76:                  ** Revision 1.2  2001/04/27 14:37:11  neil
77:                  ** wheeee
78:                  **
79:                  ** Revision 1.1  2001/04/27 12:54:40  neil
80:                  ** blah
81:                  **
82:                  ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
83:                  ** initial
84:                  **
85:                  ** Revision 1.1  2000/10/24 12:19:59  matt
86:                  ** changed directory structure
87:                  **
88:                  ** Revision 1.9  2000/10/11 12:13:15  matt
89:                  ** quelled warnings
90:                  **
91:                  ** Revision 1.8  2000/10/03 11:56:20  matt
92:                  ** better support for optional sound ext routines
93:                  **
94:                  ** Revision 1.7  2000/09/15 13:38:40  matt
95:                  ** changes for optimized apu core
96:                  **
97:                  ** Revision 1.6  2000/09/15 04:58:07  matt
98:                  ** simplifying and optimizing APU core
99:                  **
100:                 ** Revision 1.5  2000/07/30 04:32:59  matt
101:                 ** no more apu_getcyclerate hack
102:                 **
103:                 ** Revision 1.4  2000/07/17 01:52:30  matt
104:                 ** made sure last line of all source files is a newline
105:                 **
106:                 ** Revision 1.3  2000/07/03 02:18:53  matt
107:                 ** much better external module exporting
108:                 **
109:                 ** Revision 1.2  2000/06/20 04:06:16  matt
110:                 ** migrated external sound definition to apu module
111:                 **
112:                 ** Revision 1.1  2000/06/20 00:06:47  matt
113:                 ** initial revision
114:                 **
115:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/pcx.c  -------------------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** pcx.c
21:                  **
22:                  ** PCX format screen-saving routines
23:                  ** $Id: pcx.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <stdio.h>
27:                  #include <string.h>
28:                  #include <noftypes.h>
29:                  #include <bitmap.h>
30:                  #include <pcx.h>
31:                  
32:                  /* Save a PCX snapshot from a given NES bitmap */
33:                  int pcx_write(char *filename, bitmap_t *bmp, rgb_t *pal)
34:                  {
9D034F7C  27BDFF40   ADDIU SP, SP, -192
9D034F80  AFBF00BC   SW RA, 188(SP)
9D034F84  AFBE00B8   SW FP, 184(SP)
9D034F88  AFB700B4   SW S7, 180(SP)
9D034F8C  AFB600B0   SW S6, 176(SP)
9D034F90  AFB500AC   SW S5, 172(SP)
9D034F94  AFB400A8   SW S4, 168(SP)
9D034F98  AFB300A4   SW S3, 164(SP)
9D034F9C  AFB200A0   SW S2, 160(SP)
9D034FA0  AFB1009C   SW S1, 156(SP)
9D034FA4  AFB00098   SW S0, 152(SP)
9D034FA8  00A0F021   ADDU FP, A1, ZERO
9D034FAC  AFA600C8   SW A2, 200(SP)
35:                     FILE *fp;
36:                     pcxheader_t header;
37:                     int i, line;
38:                     int width, height, x_min, y_min;
39:                  
40:                     ASSERT(bmp);
41:                  
42:                     width = bmp->width;
9D034FB0  8CB30000   LW S3, 0(A1)
43:                     height = bmp->height;
9D034FB4  8CA20004   LW V0, 4(A1)
9D034FB8  AFA20090   SW V0, 144(SP)
44:                     x_min = 0;
45:                     y_min = 0;
46:                  
47:                     fp = fopen(filename, "wb");
9D034FBC  3C059D04   LUI A1, -25340
9D034FC0  0F40DA7E   JAL .Letext0, .LFE3, fopen
9D034FC4  24A5C508   ADDIU A1, A1, -15096
48:                     if (NULL == fp)
9D034FC8  10400065   BEQ V0, ZERO, 0x9D035160
9D034FCC  0040A021   ADDU S4, V0, ZERO
49:                        return -1;
9D035160  2402FFFF   ADDIU V0, ZERO, -1
50:                  
51:                     /* Fill in the header nonsense */
52:                     memset(&header, 0, sizeof(header));
9D034FD0  27A40010   ADDIU A0, SP, 16
9D034FD4  00002821   ADDU A1, ZERO, ZERO
9D034FD8  0F40E7C9   JAL .Letext0, .LFE0, memset
9D034FDC  24060080   ADDIU A2, ZERO, 128
53:                  
54:                     header.Manufacturer = 10;
9D034FE0  2402000A   ADDIU V0, ZERO, 10
9D034FE4  A3A20010   SB V0, 16(SP)
55:                     header.Version = 5;
9D034FE8  24020005   ADDIU V0, ZERO, 5
9D034FEC  A3A20011   SB V0, 17(SP)
56:                     header.Encoding = 1;
9D034FF0  24050001   ADDIU A1, ZERO, 1
9D034FF4  A3A50012   SB A1, 18(SP)
57:                     header.BitsPerPixel = 8;
9D034FF8  24020008   ADDIU V0, ZERO, 8
9D034FFC  A3A20013   SB V0, 19(SP)
58:                     header.Xmin = x_min;
59:                     header.Ymin = y_min;
60:                     header.Xmax = width - 1;
9D035000  3264FFFF   ANDI A0, S3, -1
9D035004  2483FFFF   ADDIU V1, A0, -1
9D035008  3063FFFF   ANDI V1, V1, -1
9D03500C  A7A30018   SH V1, 24(SP)
61:                     header.Ymax = height - 1;
9D035010  8FA60090   LW A2, 144(SP)
9D035014  24C2FFFF   ADDIU V0, A2, -1
9D035018  3042FFFF   ANDI V0, V0, -1
9D03501C  A7A2001A   SH V0, 26(SP)
62:                     header.NPlanes = 1;
9D035020  A3A50051   SB A1, 81(SP)
63:                     header.BytesPerLine = width;
9D035024  A7A40052   SH A0, 82(SP)
64:                     header.PaletteInfo = 1;
9D035028  24040001   ADDIU A0, ZERO, 1
9D03502C  A7A40054   SH A0, 84(SP)
65:                     header.HscreenSize = width - 1;
9D035030  A7A30056   SH V1, 86(SP)
66:                     header.VscreenSize = height - 1;
9D035034  A7A20058   SH V0, 88(SP)
67:                  
68:                     fwrite(&header, 1, sizeof(header), fp);
9D035038  27A40010   ADDIU A0, SP, 16
9D03503C  24050001   ADDIU A1, ZERO, 1
9D035040  24060080   ADDIU A2, ZERO, 128
9D035044  0F40EFC8   JAL fwrite
9D035048  02803821   ADDU A3, S4, ZERO
69:                  
70:                     /* RLE encoding */
71:                     for (line = 0; line < height; line++)
9D03504C  8FA20090   LW V0, 144(SP)
9D035050  1840002F   BLEZ V0, 0x9D035110
9D035054  2404000C   ADDIU A0, ZERO, 12
9D035058  0000B821   ADDU S7, ZERO, ZERO
9D0350FC  26F70001   ADDIU S7, S7, 1
9D035100  8FA60090   LW A2, 144(SP)
9D035104  16E6FFD6   BNE S7, A2, 0x9D035060
9D035108  27DE0004   ADDIU FP, FP, 4
72:                     {
73:                        uint8 last, *mem;
74:                        int xpos = 0;
9D035068  00008821   ADDU S1, ZERO, ZERO
9D03506C  2465003F   ADDIU A1, V1, 63
9D035070  00608021   ADDU S0, V1, ZERO
75:                  
76:                        mem = bmp->line[line + y_min] + x_min;
77:                  
78:                        while (xpos < width)
9D035060  1A600026   BLEZ S3, .LBE2
9D035064  8FC30014   LW V1, 20(FP)
9D0350F0  02B3A82A   SLT S5, S5, S3
9D0350F4  16A0FFDD   BNE S5, ZERO, 0x9D03506C
9D0350F8  02001821   ADDU V1, S0, ZERO
79:                        {
80:                           int rle_count = 0;
81:                  
82:                           do
83:                           {
84:                              last = *mem++;
9D035074  26100001   ADDIU S0, S0, 1
9D035078  9202FFFF   LBU V0, -1(S0)
85:                              xpos++;
9D03507C  26310001   ADDIU S1, S1, 1
9D0350A8  0220A821   ADDU S5, S1, ZERO
9D0350AC  00409021   ADDU S2, V0, ZERO
86:                              rle_count++;
87:                           }
88:                           while (*mem == last && xpos < width && rle_count < 0x3F);
9D035080  92120000   LBU S2, 0(S0)
9D035084  16420008   BNE S2, V0, 0x9D0350A8
9D035088  02032023   SUBU A0, S0, V1
9D03508C  0233102A   SLT V0, S1, S3
9D035090  10400007   BEQ V0, ZERO, 0x9D0350B0
9D035094  0220A821   ADDU S5, S1, ZERO
9D035098  5605FFF7   BNEL S0, A1, 0x9D035078
9D03509C  26100001   ADDIU S0, S0, 1
9D0350A0  0B40D42D   J 0x9D0350B4
9D0350A4  28820002   SLTI V0, A0, 2
89:                  
90:                           if (rle_count > 1 || 0xC0 == (last & 0xC0))
9D03505C  241600C0   ADDIU S6, ZERO, 192
9D0350B0  28820002   SLTI V0, A0, 2
9D0350B4  50400005   BEQL V0, ZERO, 0x9D0350CC
9D0350B8  348400C0   ORI A0, A0, 192
9D0350BC  324200C0   ANDI V0, S2, 192
9D0350C0  54560009   BNEL V0, S6, 0x9D0350E8
9D0350C4  02402021   ADDU A0, S2, ZERO
91:                           {
92:                              fputc(0xC0 | rle_count, fp);
9D0350C8  348400C0   ORI A0, A0, 192
9D0350CC  0F40E71E   JAL .Letext0, .LFE0, fputc
9D0350D0  02802821   ADDU A1, S4, ZERO
93:                              fputc(last, fp);
9D0350D4  02402021   ADDU A0, S2, ZERO
9D0350D8  0F40E71E   JAL .Letext0, .LFE0, fputc
9D0350DC  02802821   ADDU A1, S4, ZERO
9D0350E0  0B40D43D   J 0x9D0350F4
9D0350E4  02B3A82A   SLT S5, S5, S3
94:                           }
95:                           else
96:                           {
97:                              fputc(last, fp);
9D0350E8  0F40E71E   JAL .Letext0, .LFE0, fputc
9D0350EC  02802821   ADDU A1, S4, ZERO
98:                           }
99:                        }
100:                    }
101:                 
102:                    /* Write palette */
103:                    fputc(0x0C, fp); /* $0C signifies 256 color palette */
9D03510C  2404000C   ADDIU A0, ZERO, 12
9D035110  0F40E71E   JAL .Letext0, .LFE0, fputc
9D035114  02802821   ADDU A1, S4, ZERO
9D035118  8FB000C8   LW S0, 200(SP)
9D03511C  24110100   ADDIU S1, ZERO, 256
104:                    for (i = 0; i < 256; i++)
9D035148  1620FFF5   BNE S1, ZERO, 0x9D035120
9D03514C  2610000C   ADDIU S0, S0, 12
105:                    {
106:                       fputc(pal[i].r, fp);
9D035120  8E040000   LW A0, 0(S0)
9D035124  0F40E71E   JAL .Letext0, .LFE0, fputc
9D035128  02802821   ADDU A1, S4, ZERO
107:                       fputc(pal[i].g, fp);
9D03512C  8E040004   LW A0, 4(S0)
9D035130  0F40E71E   JAL .Letext0, .LFE0, fputc
9D035134  02802821   ADDU A1, S4, ZERO
108:                       fputc(pal[i].b, fp);
9D035138  8E040008   LW A0, 8(S0)
9D03513C  0F40E71E   JAL .Letext0, .LFE0, fputc
9D035140  02802821   ADDU A1, S4, ZERO
9D035144  2631FFFF   ADDIU S1, S1, -1
109:                    }
110:                 
111:                    /* We're done! */
112:                    fclose(fp);
9D035150  0F40E9A2   JAL .Letext0, .LFE1, fclose
9D035154  02802021   ADDU A0, S4, ZERO
113:                    return 0;
9D035158  0B40D459   J 0x9D035164
9D03515C  00001021   ADDU V0, ZERO, ZERO
114:                 }
9D035164  8FBF00BC   LW RA, 188(SP)
9D035168  8FBE00B8   LW FP, 184(SP)
9D03516C  8FB700B4   LW S7, 180(SP)
9D035170  8FB600B0   LW S6, 176(SP)
9D035174  8FB500AC   LW S5, 172(SP)
9D035178  8FB400A8   LW S4, 168(SP)
9D03517C  8FB300A4   LW S3, 164(SP)
9D035180  8FB200A0   LW S2, 160(SP)
9D035184  8FB1009C   LW S1, 156(SP)
9D035188  8FB00098   LW S0, 152(SP)
9D03518C  03E00008   JR RA
9D035190  27BD00C0   ADDIU SP, SP, 192
115:                 
116:                 /*
117:                 ** $Log: pcx.c,v $
118:                 ** Revision 1.2  2001/04/27 14:37:11  neil
119:                 ** wheeee
120:                 **
121:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
122:                 ** initial
123:                 **
124:                 ** Revision 1.8  2000/11/06 05:17:48  matt
125:                 ** better!
126:                 **
127:                 ** Revision 1.7  2000/11/05 16:37:18  matt
128:                 ** rolled rgb.h into bitmap.h
129:                 **
130:                 ** Revision 1.6  2000/07/17 01:52:27  matt
131:                 ** made sure last line of all source files is a newline
132:                 **
133:                 ** Revision 1.5  2000/06/26 04:55:13  matt
134:                 ** changed routine name, big whoop
135:                 **
136:                 ** Revision 1.4  2000/06/09 15:12:25  matt
137:                 ** initial revision
138:                 **
139:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/nofrendo.c  --------------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** nofrendo.c
21:                  **
22:                  ** Entry point of program
23:                  ** Note: all architectures should call these functions
24:                  ** $Id: nofrendo.c,v 1.3 2001/04/27 14:37:11 neil Exp $
25:                  */
26:                  
27:                  #include <stdio.h>
28:                  #include <stdlib.h>
29:                  #include <noftypes.h>
30:                  #include <nofrendo.h>
31:                  #include <event.h>
32:                  #include <nofconfig.h>
33:                  #include <log.h>
34:                  #include <osd.h>
35:                  #include <gui.h>
36:                  #include <vid_drv.h>
37:                  
38:                  /* emulated system includes */
39:                  #include <nes.h>
40:                  
41:                  /* our global machine structure */
42:                  static struct
43:                  {
44:                     char *filename, *nextfilename;
45:                     system_t type, nexttype;
46:                  
47:                     union 
48:                     {
49:                        nes_t *nes;
50:                     } machine;
51:                  
52:                     int refresh_rate;
53:                  
54:                     bool quit;
55:                  } console;
56:                  
57:                  /* our happy little timer ISR */
58:                  volatile int nofrendo_ticks = 0;
59:                  static void timer_isr(void)
60:                  {
61:                     nofrendo_ticks++;
62:                  }
63:                  
64:                  static void timer_isr_end(void) {} /* code marker for djgpp */
65:                  
66:                  static void shutdown_everything(void)
67:                  {
68:                     if (console.filename)
69:                     {
70:                        free(console.filename);
71:                        console.filename = NULL;
72:                     }
73:                     if (console.nextfilename)
74:                     {
75:                        free(console.nextfilename);
76:                        console.nextfilename = NULL;
77:                     }
78:                  
79:                     config.close();
80:                     //osd_shutdown();
81:                     gui_shutdown();
82:                     vid_shutdown();
83:                     log_shutdown();
84:                  }
85:                  
86:                  /* End the current context */
87:                  void main_eject(void)
88:                  {
9D032F40  27BDFFE8   ADDIU SP, SP, -24
9D032F44  AFBF0014   SW RA, 20(SP)
9D032F48  AFB00010   SW S0, 16(SP)
89:                     switch (console.type)
9D032F4C  3C02A001   LUI V0, -24575
9D032F50  8C43B85C   LW V1, -18340(V0)
9D032F54  24020002   ADDIU V0, ZERO, 2
9D032F58  14620007   BNE V1, V0, 0x9D032F78
9D032F5C  3C02A001   LUI V0, -24575
90:                     {
91:                     case system_nes:
92:                        nes_poweroff();
9D032F60  0F408BCB   JAL nes_poweroff
9D032F64  00000000   NOP
93:                        nes_destroy(&(console.machine.nes));
9D032F68  3C04A001   LUI A0, -24575
9D032F6C  0F408BA7   JAL nes_destroy
9D032F70  2484B864   ADDIU A0, A0, -18332
94:                        break;
95:                  
96:                     default:
97:                        break;
98:                     }
99:                  
100:                    if (NULL != console.filename)
9D032F74  3C02A001   LUI V0, -24575
9D032F78  8C42B854   LW V0, -18348(V0)
9D032F7C  10400004   BEQ V0, ZERO, 0x9D032F90
9D032F80  3C10A001   LUI S0, -24575
101:                    {
102:                       free(console.filename);
9D032F84  0F40DB97   JAL _my_free
9D032F88  2604B854   ADDIU A0, S0, -18348
103:                       console.filename = NULL;
9D032F8C  AE00B854   SW ZERO, -18348(S0)
104:                    }
105:                    console.type = system_unknown;
9D032F90  3C02A001   LUI V0, -24575
9D032F94  AC40B85C   SW ZERO, -18340(V0)
106:                 }
9D032F98  8FBF0014   LW RA, 20(SP)
9D032F9C  8FB00010   LW S0, 16(SP)
9D032FA0  03E00008   JR RA
9D032FA4  27BD0018   ADDIU SP, SP, 24
107:                 
108:                 /* Act on the user's quit requests */
109:                 void main_quit(void)
110:                 {
9D032FA8  27BDFFE8   ADDIU SP, SP, -24
9D032FAC  AFBF0014   SW RA, 20(SP)
9D032FB0  AFB00010   SW S0, 16(SP)
111:                    console.quit = true;
9D032FB4  3C10A001   LUI S0, -24575
9D032FB8  2610B854   ADDIU S0, S0, -18348
9D032FBC  24020001   ADDIU V0, ZERO, 1
112:                 
113:                    main_eject();
9D032FC0  0F40CBD0   JAL main_eject
9D032FC4  AE020018   SW V0, 24(S0)
114:                 
115:                    /* if there's a pending filename / system, clear */
116:                    if (NULL != console.nextfilename)
9D032FC8  8E020004   LW V0, 4(S0)
9D032FCC  10400007   BEQ V0, ZERO, 0x9D032FEC
9D032FD0  3C02A001   LUI V0, -24575
117:                    {
118:                       free(console.nextfilename);
9D032FD4  3C04A001   LUI A0, -24575
9D032FD8  0F40DB97   JAL _my_free
9D032FDC  2484B858   ADDIU A0, A0, -18344
119:                       console.nextfilename = NULL;
9D032FE0  3C02A001   LUI V0, -24575
9D032FE4  AC40B858   SW ZERO, -18344(V0)
120:                    }
121:                    console.nexttype = system_unknown;
9D032FE8  3C02A001   LUI V0, -24575
9D032FEC  AC40B860   SW ZERO, -18336(V0)
122:                 }
9D032FF0  8FBF0014   LW RA, 20(SP)
9D032FF4  8FB00010   LW S0, 16(SP)
9D032FF8  03E00008   JR RA
9D032FFC  27BD0018   ADDIU SP, SP, 24
123:                 
124:                 extern unsigned char _binary_SuperMarioBros_nes_start[];
125:                 
126:                 /* brute force system autodetection */
127:                 static system_t detect_systemtype(const char *filename)
128:                 {
129:                    if (NULL == filename)
9D032E4C  50800006   BEQL A0, ZERO, 0x9D032E68
130:                       return system_unknown;
131:                 
132:                    if (0 == nes_isourfile(filename))
9D032E54  0F408AC9   JAL nes_isourfile
133:                       return system_nes;
9D032E5C  24050002   ADDIU A1, ZERO, 2
134:                    
135:                    /* can't figure out what this thing is */
136:                    return system_unknown;
137:                 }
138:                 
139:                 static int install_timer(int hertz)
140:                 {
141:                    //return osd_installtimer(hertz, (void *) timer_isr,
142:                    //                        (int) timer_isr_end - (int) timer_isr,
143:                    //                        (void *) &nofrendo_ticks, 
144:                    //                        sizeof(nofrendo_ticks));
145:                 }
146:                 
147:                 /* This assumes there is no current context */
148:                 static int internal_insert(const char *filename, system_t type)
149:                 {
9D032E30  27BDFFE0   ADDIU SP, SP, -32
9D032E34  AFBF001C   SW RA, 28(SP)
9D032E38  AFB10018   SW S1, 24(SP)
9D032E3C  AFB00014   SW S0, 20(SP)
150:                    /* autodetect system type? */
151:                    if (system_autodetect == type)
9D032E40  24020001   ADDIU V0, ZERO, 1
9D032E44  14A20008   BNE A1, V0, 0x9D032E68
9D032E48  00808821   ADDU S1, A0, ZERO
152:                       type = detect_systemtype(filename);
153:                 
154:                    //console.filename = strdup(filename);
155:                    console.type = type;
9D032E68  3C10A001   LUI S0, -24575
9D032E6C  2610B854   ADDIU S0, S0, -18348
9D032E70  AE050008   SW A1, 8(S0)
156:                 
157:                    /* set up the event system for this system type */
158:                    event_set_system(type);
9D032E74  0F409D0A   JAL event_set_system
9D032E78  00A02021   ADDU A0, A1, ZERO
159:                 
160:                    switch (console.type)
9D032E7C  8E030008   LW V1, 8(S0)
9D032E80  24020002   ADDIU V0, ZERO, 2
9D032E84  1462001A   BNE V1, V0, 0x9D032EF0
9D032E88  3C049D04   LUI A0, -25340
161:                    {
162:                    case system_nes:
163:                       gui_setrefresh(NES_REFRESH_RATE);
9D032E8C  0F4090D5   JAL gui_setrefresh
9D032E90  2404003C   ADDIU A0, ZERO, 60
164:                 
165:                       console.machine.nes = nes_create();
9D032E94  0F408D42   JAL nes_create
9D032E98  00000000   NOP
9D032E9C  3C03A001   LUI V1, -24575
166:                       if (NULL == console.machine.nes)
9D032EA0  14400006   BNE V0, ZERO, 0x9D032EBC
9D032EA4  AC62B864   SW V0, -18332(V1)
167:                       {
168:                          log_printf("Failed to create NES instance.\n");
9D032EA8  3C049D04   LUI A0, -25340
9D032EAC  0F40EEE8   JAL log_printf
9D032EB0  2484B38C   ADDIU A0, A0, -19572
169:                          return -1;
9D032EB4  0B40CBCA   J 0x9D032F28
9D032EB8  2410FFFF   ADDIU S0, ZERO, -1
170:                       }
171:                 
172:                       if (nes_insertcart(&_binary_SuperMarioBros_nes_start, console.machine.nes))
9D032EBC  3C049D00   LUI A0, -25344
9D032EC0  24840000   ADDIU A0, A0, 0
9D032EC4  0F408BD5   JAL nes_insertcart
9D032EC8  00402821   ADDU A1, V0, ZERO
9D032ECC  14400015   BNE V0, ZERO, 0x9D032F24
9D032ED0  00408021   ADDU S0, V0, ZERO
173:                          return -1;
9D032F24  2410FFFF   ADDIU S0, ZERO, -1
174:                 
175:                       vid_setmode(NES_SCREEN_WIDTH, NES_VISIBLE_HEIGHT);
9D032ED4  24040100   ADDIU A0, ZERO, 256
9D032ED8  0F40B94E   JAL vid_setmode
9D032EDC  240500E0   ADDIU A1, ZERO, 224
176:                 
177:                       if (install_timer(NES_REFRESH_RATE))
178:                          return -1;
179:                 
180:                       nes_emulate();
9D032EE0  0F408B27   JAL nes_emulate
9D032EE4  00000000   NOP
181:                       break;
182:                    
183:                    case system_unknown:
184:                    default:
185:                       log_printf("system type unknown, playing nofrendo NES intro.\n");
9D032EF0  0F40EEE8   JAL log_printf
9D032EF4  2484B3AC   ADDIU A0, A0, -19540
186:                       if (NULL != console.filename)
9D032EF8  3C02A001   LUI V0, -24575
9D032EFC  8C42B854   LW V0, -18348(V0)
9D032F00  10400003   BEQ V0, ZERO, .LVL13
9D032F04  3C04A001   LUI A0, -24575
187:                          free(console.filename);
9D032F08  0F40DB97   JAL _my_free
9D032F0C  2484B854   ADDIU A0, A0, -18348
188:                 
189:                       /* oooh, recursion */
190:                       return internal_insert(filename, system_nes);
9D032F10  02202021   ADDU A0, S1, ZERO
9D032F14  0F40CB8C   JAL .Letext0, .LFE7, .LFB10, internal_insert, .Ltext0
9D032F18  24050002   ADDIU A1, ZERO, 2
9D032F1C  0B40CBCA   J 0x9D032F28
9D032F20  00408021   ADDU S0, V0, ZERO
191:                    }
192:                 
193:                    return 0;
9D032EE8  0B40CBCB   J 0x9D032F2C
9D032EEC  02001021   ADDU V0, S0, ZERO
194:                 }
9D032F28  02001021   ADDU V0, S0, ZERO
9D032F2C  8FBF001C   LW RA, 28(SP)
9D032F30  8FB10018   LW S1, 24(SP)
9D032F34  8FB00014   LW S0, 20(SP)
9D032F38  03E00008   JR RA
9D032F3C  27BD0020   ADDIU SP, SP, 32
195:                 
196:                 /* This tells main_loop to load this next image */
197:                 void main_insert(const char *filename, system_t type)
198:                 {
9D033000  27BDFFE8   ADDIU SP, SP, -24
9D033004  AFBF0014   SW RA, 20(SP)
9D033008  AFB00010   SW S0, 16(SP)
199:                    console.nextfilename = strdup(filename);
9D03300C  0F40DBBB   JAL _my_strdup
9D033010  00A08021   ADDU S0, A1, ZERO
9D033014  3C03A001   LUI V1, -24575
9D033018  2463B854   ADDIU V1, V1, -18348
9D03301C  AC620004   SW V0, 4(V1)
200:                    console.nexttype = type;
201:                 
202:                    main_eject();
9D033020  0F40CBD0   JAL main_eject
9D033024  AC70000C   SW S0, 12(V1)
203:                 }
9D033028  8FBF0014   LW RA, 20(SP)
9D03302C  8FB00010   LW S0, 16(SP)
9D033030  03E00008   JR RA
9D033034  27BD0018   ADDIU SP, SP, 24
204:                 
205:                 int nofrendo_main(int argc, char *argv[])
206:                 {
9D03307C  27BDFFE8   ADDIU SP, SP, -24
9D033080  AFBF0014   SW RA, 20(SP)
207:                    /* initialize our system structure */
208:                    console.filename = NULL;
9D033084  3C02A001   LUI V0, -24575
9D033088  AC40B854   SW ZERO, -18348(V0)
209:                    console.nextfilename = NULL;
9D03308C  2442B854   ADDIU V0, V0, -18348
9D033090  AC400004   SW ZERO, 4(V0)
210:                    console.type = system_unknown;
9D033094  AC400008   SW ZERO, 8(V0)
211:                    console.nexttype = system_unknown;
9D033098  AC40000C   SW ZERO, 12(V0)
212:                    console.refresh_rate = 0;
9D03309C  AC400014   SW ZERO, 20(V0)
213:                    console.quit = false;
214:                    
215:                    if (log_init())
9D0330A0  0F40EEE2   JAL log_init
9D0330A4  AC400018   SW ZERO, 24(V0)
9D0330A8  14400007   BNE V0, ZERO, .LVL32
9D0330AC  2402FFFF   ADDIU V0, ZERO, -1
216:                       return -1;
217:                 
218:                    event_init();
9D0330B0  0F409D01   JAL event_init
9D0330B4  00000000   NOP
219:                 
220:                    //return osd_main(argc, argv);
221:                    main_loop("test",system_nes);
9D0330B8  3C049D04   LUI A0, -25340
9D0330BC  2484B3E0   ADDIU A0, A0, -19488
9D0330C0  0F40CC0E   JAL main_loop
9D0330C4  24050002   ADDIU A1, ZERO, 2
222:                 }
9D0330C8  8FBF0014   LW RA, 20(SP)
9D0330CC  03E00008   JR RA
9D0330D0  27BD0018   ADDIU SP, SP, 24
223:                 
224:                 /* This is the final leg of main() */
225:                 int main_loop(const char *filename, system_t type)
226:                 {
9D033038  27BDFFE8   ADDIU SP, SP, -24
9D03303C  AFBF0014   SW RA, 20(SP)
9D033040  AFB00010   SW S0, 16(SP)
227:                    vidinfo_t video;
228:                 
229:                    /* register shutdown, in case of assertions, etc. */
230:                 //   atexit(shutdown_everything);
231:                 
232:                 //   if (config.open())
233:                 //s      return -1;
234:                 
235:                    //if (osd_init())
236:                    //   return -1;
237:                 
238:                    //if (gui_init())
239:                    //   return -1;
240:                 
241:                    //osd_getvideoinfo(&video);
242:                 //   if (vid_init(video.default_width, video.default_height, video.driver))
243:                 //      return -1;
244:                 //	printf("vid_init done\n");
245:                 
246:                    console.nextfilename = strdup(filename);
9D033044  0F40DBBB   JAL _my_strdup
9D033048  00A08021   ADDU S0, A1, ZERO
9D03304C  3C03A001   LUI V1, -24575
9D033050  2463B854   ADDIU V1, V1, -18348
9D033054  AC620004   SW V0, 4(V1)
247:                    console.nexttype = type;
9D033058  AC70000C   SW S0, 12(V1)
248:                 
249:                    //while (false == console.quit)
250:                    //{
251:                       if (internal_insert(console.nextfilename, console.nexttype))
9D03305C  00402021   ADDU A0, V0, ZERO
9D033060  0F40CB8C   JAL .Letext0, .LFE7, .LFB10, internal_insert, .Ltext0
9D033064  02002821   ADDU A1, S0, ZERO
252:                          return 1;
253:                    //}
254:                 
255:                    return 0;
256:                 }
9D033068  0002102B   SLTU V0, ZERO, V0
9D03306C  8FBF0014   LW RA, 20(SP)
9D033070  8FB00010   LW S0, 16(SP)
9D033074  03E00008   JR RA
9D033078  27BD0018   ADDIU SP, SP, 24
257:                 
258:                 /*
259:                 ** $Log: nofrendo.c,v $
260:                 ** Revision 1.3  2001/04/27 14:37:11  neil
261:                 ** wheeee
262:                 **
263:                 ** Revision 1.2  2001/04/27 11:10:08  neil
264:                 ** compile
265:                 **
266:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
267:                 ** initial
268:                 **
269:                 ** Revision 1.48  2000/11/27 12:47:08  matt
270:                 ** free them strings
271:                 **
272:                 ** Revision 1.47  2000/11/25 20:26:05  matt
273:                 ** removed fds "system"
274:                 **
275:                 ** Revision 1.46  2000/11/25 01:51:53  matt
276:                 ** bool stinks sometimes
277:                 **
278:                 ** Revision 1.45  2000/11/20 13:22:12  matt
279:                 ** standardized timer ISR, added nofrendo_ticks
280:                 **
281:                 ** Revision 1.44  2000/11/05 22:53:13  matt
282:                 ** only one video driver per system, please
283:                 **
284:                 ** Revision 1.43  2000/11/01 14:15:35  matt
285:                 ** multi-system event system, or whatever
286:                 **
287:                 ** Revision 1.42  2000/10/28 15:16:24  matt
288:                 ** removed nsf_init
289:                 **
290:                 ** Revision 1.41  2000/10/27 12:58:44  matt
291:                 ** gui_init can now fail
292:                 **
293:                 ** Revision 1.40  2000/10/26 22:48:57  matt
294:                 ** prelim NSF support
295:                 **
296:                 ** Revision 1.39  2000/10/25 13:42:02  matt
297:                 ** strdup - giddyap!
298:                 **
299:                 ** Revision 1.38  2000/10/25 01:23:08  matt
300:                 ** basic system autodetection
301:                 **
302:                 ** Revision 1.37  2000/10/23 17:50:47  matt
303:                 ** adding fds support
304:                 **
305:                 ** Revision 1.36  2000/10/23 15:52:04  matt
306:                 ** better system handling
307:                 **
308:                 ** Revision 1.35  2000/10/21 19:25:59  matt
309:                 ** many more cleanups
310:                 **
311:                 ** Revision 1.34  2000/10/10 13:58:13  matt
312:                 ** stroustrup squeezing his way in the door
313:                 **
314:                 ** Revision 1.33  2000/10/10 13:03:54  matt
315:                 ** Mr. Clean makes a guest appearance
316:                 **
317:                 ** Revision 1.32  2000/09/15 04:58:06  matt
318:                 ** simplifying and optimizing APU core
319:                 **
320:                 ** Revision 1.31  2000/09/10 23:19:14  matt
321:                 ** i'm a sloppy coder
322:                 **
323:                 ** Revision 1.30  2000/09/07 01:30:57  matt
324:                 ** nes6502_init deprecated
325:                 **
326:                 ** Revision 1.29  2000/08/16 03:17:49  matt
327:                 ** bpb
328:                 **
329:                 ** Revision 1.28  2000/08/16 02:58:19  matt
330:                 ** changed video interface a wee bit
331:                 **
332:                 ** Revision 1.27  2000/07/31 04:28:46  matt
333:                 ** one million cleanups
334:                 **
335:                 ** Revision 1.26  2000/07/30 04:31:26  matt
336:                 ** automagic loading of the nofrendo intro
337:                 **
338:                 ** Revision 1.25  2000/07/27 01:16:36  matt
339:                 ** sorted out the video problems
340:                 **
341:                 ** Revision 1.24  2000/07/26 21:54:53  neil
342:                 ** eject has to clear the nextfilename and nextsystem
343:                 **
344:                 ** Revision 1.23  2000/07/26 21:36:13  neil
345:                 ** Big honkin' change -- see the mailing list
346:                 **
347:                 ** Revision 1.22  2000/07/25 02:21:36  matt
348:                 ** safer xxx_destroy calls
349:                 **
350:                 ** Revision 1.21  2000/07/23 16:46:47  matt
351:                 ** fixed crash in win32 by reodering shutdown calls
352:                 **
353:                 ** Revision 1.20  2000/07/23 15:18:23  matt
354:                 ** removed unistd.h from includes
355:                 **
356:                 ** Revision 1.19  2000/07/23 00:48:15  neil
357:                 ** Win32 SDL
358:                 **
359:                 ** Revision 1.18  2000/07/21 13:42:06  neil
360:                 ** get_options removed, as it should be handled by osd_main
361:                 **
362:                 ** Revision 1.17  2000/07/21 04:53:48  matt
363:                 ** moved palette calls out of nofrendo.c and into ppu_create
364:                 **
365:                 ** Revision 1.16  2000/07/21 02:40:43  neil
366:                 ** more main fixes
367:                 **
368:                 ** Revision 1.15  2000/07/21 02:09:07  neil
369:                 ** new main structure?
370:                 **
371:                 ** Revision 1.14  2000/07/20 17:05:12  neil
372:                 ** Moved osd_init before setup_video
373:                 **
374:                 ** Revision 1.13  2000/07/11 15:01:05  matt
375:                 ** moved config.close() into registered atexit() routine
376:                 **
377:                 ** Revision 1.12  2000/07/11 13:35:38  bsittler
378:                 ** Changed the config API, implemented config file "nofrendo.cfg". The
379:                 ** GGI drivers use the group [GGI]. Visual= and Mode= keys are understood.
380:                 **
381:                 ** Revision 1.11  2000/07/11 04:32:21  matt
382:                 ** less magic number nastiness for screen dimensions
383:                 **
384:                 ** Revision 1.10  2000/07/10 03:04:15  matt
385:                 ** removed scanlines, backbuffer from custom blit
386:                 **
387:                 ** Revision 1.9  2000/07/07 04:39:54  matt
388:                 ** removed garbage dpp shite
389:                 **
390:                 ** Revision 1.8  2000/07/06 16:48:25  matt
391:                 ** new video driver
392:                 **
393:                 ** Revision 1.7  2000/07/05 17:26:16  neil
394:                 ** Moved the externs in nofrendo.c to osd.h
395:                 **
396:                 ** Revision 1.6  2000/06/26 04:55:44  matt
397:                 ** cleaned up main()
398:                 **
399:                 ** Revision 1.5  2000/06/20 20:41:21  matt
400:                 ** moved <stdlib.h> include to top (duh)
401:                 **
402:                 ** Revision 1.4  2000/06/09 15:12:25  matt
403:                 ** initial revision
404:                 **
405:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/nes/nesstate.c  ----------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** nesstate.c
21:                  **
22:                  ** state saving/loading
23:                  ** $Id: nesstate.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <stdio.h>
27:                  #include <string.h>
28:                  #include <noftypes.h>
29:                  #include <nesstate.h>
30:                  #include <gui.h>
31:                  #include <nes.h>
32:                  #include <log.h>
33:                  #include <osd.h>
34:                  #include <libsnss.h>
35:                  #include "nes6502.h"
36:                  
37:                  #define  FIRST_STATE_SLOT  0
38:                  #define  LAST_STATE_SLOT   9
39:                  
40:                  static int state_slot = FIRST_STATE_SLOT;
41:                  
42:                  /* Set the state-save slot to use (0 - 9) */
43:                  void state_setslot(int slot)
44:                  {
9D0250CC  27BDFFE8   ADDIU SP, SP, -24
9D0250D0  AFBF0014   SW RA, 20(SP)
45:                     /* Don't send a message if we're already at that slot */
46:                     if (state_slot != slot && slot >= FIRST_STATE_SLOT
9D0250D4  8F828110   LW V0, -32496(GP)
9D0250D8  10440009   BEQ V0, A0, .LVL2
9D0250DC  00803021   ADDU A2, A0, ZERO
47:                         && slot <= LAST_STATE_SLOT)
9D0250E0  2C82000A   SLTIU V0, A0, 10
9D0250E4  10400007   BEQ V0, ZERO, 0x9D025104
9D0250E8  8FBF0014   LW RA, 20(SP)
48:                     {
49:                        state_slot = slot;
9D0250EC  AF848110   SW A0, -32496(GP)
50:                        gui_sendmsg(GUI_WHITE, "State slot set to %d", slot);
9D0250F0  240400C4   ADDIU A0, ZERO, 196
9D0250F4  3C059D04   LUI A1, -25340
9D0250F8  0F409020   JAL gui_sendmsg
9D0250FC  24A59A6C   ADDIU A1, A1, -26004
51:                     }
52:                  }
9D025100  8FBF0014   LW RA, 20(SP)
9D025104  03E00008   JR RA
9D025108  27BD0018   ADDIU SP, SP, 24
53:                  
54:                  static int save_baseblock(nes_t *state, SNSS_FILE *snssFile)
55:                  {
56:                     int i;
57:                  
58:                     ASSERT(state);
59:                  
60:                     nes6502_getcontext(state->cpu);
9D025170  0F40289D   JAL nes6502_getcontext
61:                     ppu_getcontext(state->ppu);
9D025178  0F406093   JAL ppu_getcontext
62:                  
63:                     snssFile->baseBlock.regA = state->cpu->a_reg;
9D025180  8E020000   LW V0, 0(S0)
64:                     snssFile->baseBlock.regX = state->cpu->x_reg;
9D02518C  8E020000   LW V0, 0(S0)
65:                     snssFile->baseBlock.regY = state->cpu->y_reg;
9D025198  8E020000   LW V0, 0(S0)
66:                     snssFile->baseBlock.regFlags = state->cpu->p_reg;
9D0251A4  8E020000   LW V0, 0(S0)
67:                     snssFile->baseBlock.regStack = state->cpu->s_reg;
9D0251B0  8E020000   LW V0, 0(S0)
68:                     snssFile->baseBlock.regPc = state->cpu->pc_reg;
9D0251BC  8E020000   LW V0, 0(S0)
69:                  
70:                     snssFile->baseBlock.reg2000 = state->ppu->ctrl0;
9D0251C8  8E020304   LW V0, 772(S0)
71:                     snssFile->baseBlock.reg2001 = state->ppu->ctrl1;
9D0251D4  8E020304   LW V0, 772(S0)
72:                  
73:                     memcpy(snssFile->baseBlock.cpuRam, state->cpu->mem_page[0], 0x800);
9D0251E0  8E020000   LW V0, 0(S0)
74:                     memcpy(snssFile->baseBlock.spriteRam, state->ppu->oam, 0x100);
9D02523C  8E040304   LW A0, 772(S0)
75:                     memcpy(snssFile->baseBlock.ppuRam, state->ppu->nametab, 0x1000);
9D025298  8E030304   LW V1, 772(S0)
76:                  
77:                     /* Mask off priority color bits */
78:                     for (i = 0; i < 32; i++)
9D0252F0  00001821   ADDU V1, ZERO, ZERO
9D02530C  24630001   ADDIU V1, V1, 1
79:                        snssFile->baseBlock.palette[i] = state->ppu->palette[i] & 0x3F;
9D0252FC  8E040304   LW A0, 772(S0)
80:                  
81:                     snssFile->baseBlock.mirrorState[0] = (state->ppu->page[8] + 0x2000 - state->ppu->nametab) / 0x400;
9D025318  8E030304   LW V1, 772(S0)
82:                     snssFile->baseBlock.mirrorState[1] = (state->ppu->page[9] + 0x2400 - state->ppu->nametab) / 0x400;
9D02533C  8E030304   LW V1, 772(S0)
83:                     snssFile->baseBlock.mirrorState[2] = (state->ppu->page[10] + 0x2800 - state->ppu->nametab) / 0x400;
9D025360  8E030304   LW V1, 772(S0)
84:                     snssFile->baseBlock.mirrorState[3] = (state->ppu->page[11] + 0x2C00 - state->ppu->nametab) / 0x400;
9D025384  8E030304   LW V1, 772(S0)
85:                  
86:                     snssFile->baseBlock.vramAddress = state->ppu->vaddr;
9D0253A8  8E020304   LW V0, 772(S0)
87:                     snssFile->baseBlock.spriteRamAddress = state->ppu->oam_addr;
9D0253B4  8E020304   LW V0, 772(S0)
88:                     snssFile->baseBlock.tileXOffset = state->ppu->tile_xofs;
9D0253C0  8E020304   LW V0, 772(S0)
9D0253C4  8C42116C   LW V0, 4460(V0)
9D0253C8  A2221945   SB V0, 6469(S1)
89:                  
90:                     return 0;
91:                  }
92:                  
93:                  static bool save_vramblock(nes_t *state, SNSS_FILE *snssFile)
94:                  {
95:                     ASSERT(state);
96:                  
97:                     if (NULL == state->rominfo->vram)
9D0253E0  8E020310   LW V0, 784(S0)
9D0253E4  8C43000C   LW V1, 12(V0)
9D0253E8  10600015   BEQ V1, ZERO, 0x9D025440
9D0253EC  8FA40010   LW A0, 16(SP)
98:                        return -1;
99:                  
100:                    if (state->rominfo->vram_banks > 2)
9D0253F0  8C45001C   LW A1, 28(V0)
9D0253F4  28A20003   SLTI V0, A1, 3
9D0253F8  54400006   BNEL V0, ZERO, 0x9D025414
9D0253FC  00052B40   SLL A1, A1, 13
101:                    {
102:                       log_printf("too many VRAM banks: %d\n", state->rominfo->vram_banks);
9D025400  3C049D04   LUI A0, -25340
9D025404  0F40EEE8   JAL log_printf
9D025408  24849A8C   ADDIU A0, A0, -25972
103:                       return -1;
104:                    }
105:                 
106:                    snssFile->vramBlock.vramSize = VRAM_8K * state->rominfo->vram_banks;
9D025414  30A6FFFF   ANDI A2, A1, -1
9D025418  A4861946   SH A2, 6470(A0)
107:                 
108:                    memcpy(snssFile->vramBlock.vram, state->rominfo->vram, snssFile->vramBlock.vramSize);
9D02541C  8E020310   LW V0, 784(S0)
9D025420  24841948   ADDIU A0, A0, 6472
9D025424  0F40D971   JAL .Letext0, .LFE1, memcpy
9D025428  8C45000C   LW A1, 12(V0)
109:                    return 0;
110:                 }
111:                 
112:                 static int save_sramblock(nes_t *state, SNSS_FILE *snssFile)
113:                 {
114:                    int i;
115:                    bool written = false;
116:                    int sram_length;
117:                 
118:                    ASSERT(state);
119:                 
120:                    sram_length = state->rominfo->sram_banks * SRAM_1K;
9D025444  8E020310   LW V0, 784(S0)
9D025448  8C450018   LW A1, 24(V0)
9D02544C  00053280   SLL A2, A1, 10
121:                 
122:                    /* Check to see if any SRAM was written to */
123:                    for (i = 0; i < sram_length; i++)
9D025450  18C0001F   BLEZ A2, .LBB25
9D025454  8FB10010   LW S1, 16(SP)
9D02547C  1446FFFC   BNE V0, A2, 0x9D025470
9D025480  24420001   ADDIU V0, V0, 1
124:                    {
125:                       if (state->rominfo->sram[i])
9D025458  8C430008   LW V1, 8(V0)
9D02545C  90620000   LBU V0, 0(V1)
9D025460  144000AB   BNE V0, ZERO, 0x9D025710
9D025464  24620001   ADDIU V0, V1, 1
9D025468  0B40951F   J 0x9D02547C
9D02546C  00663021   ADDU A2, V1, A2
9D025470  9043FFFF   LBU V1, -1(V0)
9D025474  546000A7   BNEL V1, ZERO, 0x9D025714
9D025478  28A20009   SLTI V0, A1, 9
126:                       {
127:                          written = true;
128:                          break;
129:                       }
130:                    }
131:                 
132:                    if (false == written)
133:                       return -1;
134:                 
135:                    if (state->rominfo->sram_banks > 8)
9D025710  28A20009   SLTI V0, A1, 9
9D025714  5440FF61   BNEL V0, ZERO, 0x9D02549C
9D025718  00052A80   SLL A1, A1, 10
136:                    {
137:                       log_printf("Unsupported number of SRAM banks: %d\n", state->rominfo->sram_banks);
9D02548C  0F40EEE8   JAL log_printf
9D025490  24849AA8   ADDIU A0, A0, -25944
9D02571C  0B409523   J 0x9D02548C
9D025720  3C049D04   LUI A0, -25340
138:                       return -1;
139:                    }
140:                 
141:                    snssFile->sramBlock.sramSize = SRAM_1K * state->rominfo->sram_banks;
9D02549C  30A6FFFF   ANDI A2, A1, -1
9D0254A0  A4865948   SH A2, 22856(A0)
142:                 
143:                    /* TODO: this should not always be true!! */
144:                    snssFile->sramBlock.sramEnabled = true;
9D0254A4  24020001   ADDIU V0, ZERO, 1
9D0254A8  A082594A   SB V0, 22858(A0)
145:                 
146:                    memcpy(snssFile->sramBlock.sram, state->rominfo->sram, snssFile->sramBlock.sramSize);
9D0254AC  8E020310   LW V0, 784(S0)
9D0254B0  2484594B   ADDIU A0, A0, 22859
9D0254B4  0F40D971   JAL .Letext0, .LFE1, memcpy
9D0254B8  8C450008   LW A1, 8(V0)
147:                 
148:                    return 0;
149:                 }
150:                 
151:                 static int save_soundblock(nes_t *state, SNSS_FILE *snssFile)
152:                 {
153:                    ASSERT(state);
154:                 
155:                    apu_getcontext(state->apu);
9D0254D0  0F40765D   JAL apu_getcontext
156:                 
157:                    /* rect 0 */
158:                    snssFile->soundBlock.soundRegisters[0x00] = state->apu->rectangle[0].regs[0];
9D0254D8  8E020308   LW V0, 776(S0)
159:                    snssFile->soundBlock.soundRegisters[0x01] = state->apu->rectangle[0].regs[1];
9D0254E4  8E020308   LW V0, 776(S0)
160:                    snssFile->soundBlock.soundRegisters[0x02] = state->apu->rectangle[0].regs[2];
9D0254F0  8E020308   LW V0, 776(S0)
161:                    snssFile->soundBlock.soundRegisters[0x03] = state->apu->rectangle[0].regs[3];
9D0254FC  8E020308   LW V0, 776(S0)
162:                    /* rect 1 */
163:                    snssFile->soundBlock.soundRegisters[0x04] = state->apu->rectangle[1].regs[0];
9D025508  8E020308   LW V0, 776(S0)
164:                    snssFile->soundBlock.soundRegisters[0x05] = state->apu->rectangle[1].regs[1];
9D025514  8E020308   LW V0, 776(S0)
165:                    snssFile->soundBlock.soundRegisters[0x06] = state->apu->rectangle[1].regs[2];
9D025520  8E020308   LW V0, 776(S0)
166:                    snssFile->soundBlock.soundRegisters[0x07] = state->apu->rectangle[1].regs[3];
9D02552C  8E020308   LW V0, 776(S0)
167:                    /* triangle */
168:                    snssFile->soundBlock.soundRegisters[0x08] = state->apu->triangle.regs[0];
9D025538  8E020308   LW V0, 776(S0)
169:                    snssFile->soundBlock.soundRegisters[0x0A] = state->apu->triangle.regs[1];
9D025544  8E020308   LW V0, 776(S0)
170:                    snssFile->soundBlock.soundRegisters[0x0B] = state->apu->triangle.regs[2];
9D025550  8E020308   LW V0, 776(S0)
171:                    /* noise */
172:                    snssFile->soundBlock.soundRegisters[0X0C] = state->apu->noise.regs[0];
9D02555C  8E020308   LW V0, 776(S0)
173:                    snssFile->soundBlock.soundRegisters[0X0E] = state->apu->noise.regs[1];
9D025568  8E020308   LW V0, 776(S0)
174:                    snssFile->soundBlock.soundRegisters[0x0F] = state->apu->noise.regs[2];
9D025574  8E020308   LW V0, 776(S0)
175:                    /* dmc */
176:                    snssFile->soundBlock.soundRegisters[0x10] = state->apu->dmc.regs[0];
9D025580  8E020308   LW V0, 776(S0)
177:                    snssFile->soundBlock.soundRegisters[0x11] = state->apu->dmc.regs[1];
9D02558C  8E020308   LW V0, 776(S0)
178:                    snssFile->soundBlock.soundRegisters[0x12] = state->apu->dmc.regs[2];
9D025598  8E020308   LW V0, 776(S0)
179:                    snssFile->soundBlock.soundRegisters[0x13] = state->apu->dmc.regs[3];
9D0255A4  8E020308   LW V0, 776(S0)
180:                    /* control */
181:                    snssFile->soundBlock.soundRegisters[0x15] = state->apu->enable_reg;
9D0255B0  8E020308   LW V0, 776(S0)
182:                 
183:                    return 0;
184:                 }
185:                 
186:                 static int save_mapperblock(nes_t *state, SNSS_FILE *snssFile)
187:                 {
188:                    int i;
189:                    ASSERT(state);
190:                 
191:                    mmc_getcontext(state->mmc);
9D0255D0  0F40B1E3   JAL mmc_getcontext
9D0255D4  8E04030C   LW A0, 780(S0)
192:                 
193:                    /* TODO: filthy hack in snss standard */
194:                    /* We don't need to write mapper state for mapper 0 */
195:                    if (0 == state->mmc->intf->number)
9D0255D8  8E02030C   LW V0, 780(S0)
9D0255DC  8C420000   LW V0, 0(V0)
9D0255E0  8C420000   LW V0, 0(V0)
9D0255E4  10400035   BEQ V0, ZERO, 0x9D0256BC
9D0255E8  00000000   NOP
196:                       return -1;
197:                 
198:                    nes6502_getcontext(state->cpu);
9D0255EC  0F40289D   JAL nes6502_getcontext
9D0255F0  8E040000   LW A0, 0(S0)
9D0255F4  24020008   ADDIU V0, ZERO, 8
199:                 
200:                    /* TODO: snss spec should be updated, using 4kB ROM pages.. */
201:                    for (i = 0; i < 4; i++)
9D0255F8  24060010   ADDIU A2, ZERO, 16
9D0255FC  02621821   ADDU V1, S3, V0
9D025624  1446FFF5   BNE V0, A2, 0x9D0255FC
9D025628  A4647944   SH A0, 31044(V1)
202:                       snssFile->mapperBlock.prgPages[i] = (state->cpu->mem_page[(i + 4) * 2] - state->rominfo->rom) >> 13;
9D025600  8E050000   LW A1, 0(S0)
9D025604  00022080   SLL A0, V0, 2
9D025608  00A42821   ADDU A1, A1, A0
9D02560C  8E040310   LW A0, 784(S0)
9D025610  8CA50000   LW A1, 0(A1)
9D025614  8C840000   LW A0, 0(A0)
9D025618  00A42023   SUBU A0, A1, A0
9D02561C  00042343   SRA A0, A0, 13
9D025620  24420002   ADDIU V0, V0, 2
203:                 
204:                    if (state->rominfo->vrom_banks)
9D02562C  8E020310   LW V0, 784(S0)
9D025630  8C420014   LW V0, 20(V0)
9D025634  10400012   BEQ V0, ZERO, 0x9D025680
9D025638  02601821   ADDU V1, S3, ZERO
9D02563C  02609021   ADDU S2, S3, ZERO
9D025640  00008821   ADDU S1, ZERO, ZERO
9D025680  00001021   ADDU V0, ZERO, ZERO
205:                    {
206:                       for (i = 0; i < 8; i++)
9D025644  24140008   ADDIU S4, ZERO, 8
9D02566C  26310001   ADDIU S1, S1, 1
9D025670  1634FFF5   BNE S1, S4, 0x9D025648
9D025674  26520002   ADDIU S2, S2, 2
207:                          snssFile->mapperBlock.chrPages[i] = (ppu_getpage(i) - state->rominfo->vrom + (i * 0x400)) >> 10;
9D025648  0F406143   JAL ppu_getpage
9D02564C  02202021   ADDU A0, S1, ZERO
9D025650  00111A80   SLL V1, S1, 10
9D025654  8E040310   LW A0, 784(S0)
9D025658  8C850004   LW A1, 4(A0)
9D02565C  00451023   SUBU V0, V0, A1
9D025660  00621821   ADDU V1, V1, V0
9D025664  00031A83   SRA V1, V1, 10
9D025668  A6437954   SH V1, 31060(S2)
208:                    }
209:                    else
210:                    {
211:                       /* bleh! slight hack */
212:                       for (i = 0; i < 8; i++)
9D025684  24040008   ADDIU A0, ZERO, 8
9D02568C  24420001   ADDIU V0, V0, 1
9D025690  1444FFFD   BNE V0, A0, 0x9D025688
9D025694  24630002   ADDIU V1, V1, 2
213:                          snssFile->mapperBlock.chrPages[i] = i;
9D025688  A4627954   SH V0, 31060(V1)
214:                    }
215:                 
216:                    if (state->mmc->intf->get_state)
9D025678  0B4095A7   J 0x9D02569C
9D02567C  8E02030C   LW V0, 780(S0)
9D025698  8E02030C   LW V0, 780(S0)
9D02569C  8C420000   LW V0, 0(V0)
9D0256A0  8C420014   LW V0, 20(V0)
9D0256A4  5040001F   BEQL V0, ZERO, 0x9D025724
9D0256A8  8FA40010   LW A0, 16(SP)
217:                       state->mmc->intf->get_state(&snssFile->mapperBlock);
9D0256AC  0040F809   JALR V0
9D0256B0  2664794C   ADDIU A0, S3, 31052
218:                 
219:                    return 0;
220:                 }
221:                 
222:                 static void load_baseblock(nes_t *state, SNSS_FILE *snssFile)
223:                 {
224:                    int i;
225:                    
226:                    ASSERT(state);
227:                 
228:                    nes6502_getcontext(state->cpu);
9D02584C  0F40289D   JAL nes6502_getcontext
229:                    ppu_getcontext(state->ppu);
9D025854  0F406093   JAL ppu_getcontext
230:                 
231:                    state->cpu->a_reg = snssFile->baseBlock.regA;
9D02585C  8E220000   LW V0, 0(S1)
232:                    state->cpu->x_reg = snssFile->baseBlock.regX;
9D025868  8E220000   LW V0, 0(S1)
233:                    state->cpu->y_reg = snssFile->baseBlock.regY;
9D025874  8E220000   LW V0, 0(S1)
234:                    state->cpu->p_reg = snssFile->baseBlock.regFlags;
9D025880  8E220000   LW V0, 0(S1)
235:                    state->cpu->s_reg = snssFile->baseBlock.regStack;
9D02588C  8E220000   LW V0, 0(S1)
236:                    state->cpu->pc_reg = snssFile->baseBlock.regPc;
9D025898  8E220000   LW V0, 0(S1)
237:                 
238:                    state->ppu->ctrl0 = snssFile->baseBlock.reg2000;
9D0258A4  8E220304   LW V0, 772(S1)
239:                    state->ppu->ctrl1 = snssFile->baseBlock.reg2001;
9D0258B0  8E220304   LW V0, 772(S1)
240:                 
241:                    memcpy(state->cpu->mem_page[0], snssFile->baseBlock.cpuRam, 0x800);
9D0258BC  8E220000   LW V0, 0(S1)
242:                    memcpy(state->ppu->oam, snssFile->baseBlock.spriteRam, 0x100);
9D025918  8E220304   LW V0, 772(S1)
243:                    memcpy(state->ppu->nametab, snssFile->baseBlock.ppuRam, 0x1000);
9D025974  2603091E   ADDIU V1, S0, 2334
244:                    memcpy(state->ppu->palette, snssFile->baseBlock.palette, 0x20);
9D0259CC  8E2B0304   LW T3, 772(S1)
245:                 
246:                    /* TODO: argh, this is to handle nofrendo's filthy sprite priority method */
247:                    for (i = 0; i < 8; i++)
9D025A58  00001021   ADDU V0, ZERO, ZERO
9D025A60  24050008   ADDIU A1, ZERO, 8
9D025A78  24420001   ADDIU V0, V0, 1
248:                       state->ppu->palette[i << 2] = state->ppu->palette[0] | 0x80;//BG_TRANS_MASK;
9D025A5C  2406FF80   ADDIU A2, ZERO, -128
9D025A64  8E230304   LW V1, 772(S1)
249:                 
250:                    for (i = 0; i < 4; i++)
9D025A8C  2407000C   ADDIU A3, ZERO, 12
9D025ACC  1447FFF0   BNE V0, A3, 0x9D025A90
251:                    {
252:                       state->ppu->page[i + 8] = state->ppu->page[i + 12] =
9D025AA8  2446044C   ADDIU A2, V0, 1100
253:                          state->ppu->nametab + (snssFile->baseBlock.mirrorState[i] * 0x400) - (0x2000 + (i * 0x400));
9D025A90  8E230304   LW V1, 772(S1)
254:                    }
255:                 
256:                    state->ppu->vaddr = snssFile->baseBlock.vramAddress;
9D025AD4  8E220304   LW V0, 772(S1)
257:                    state->ppu->oam_addr = snssFile->baseBlock.spriteRamAddress;
9D025AE0  8E220304   LW V0, 772(S1)
258:                    state->ppu->tile_xofs = snssFile->baseBlock.tileXOffset;
9D025AEC  8E220304   LW V0, 772(S1)
259:                 
260:                    /* do some extra handling */
261:                    state->ppu->flipflop = 0;
9D025AF8  8E220304   LW V0, 772(S1)
262:                    state->ppu->strikeflag = false;
9D025B00  8E220304   LW V0, 772(S1)
263:                 
264:                    nes6502_setcontext(state->cpu);
9D025B08  0F402877   JAL nes6502_setcontext
265:                    ppu_setcontext(state->ppu);
9D025B10  0F406058   JAL ppu_setcontext
266:                 
267:                    ppu_write(PPU_CTRL0, state->ppu->ctrl0);
9D025B18  8E220304   LW V0, 772(S1)
268:                    ppu_write(PPU_CTRL1, state->ppu->ctrl1);
9D025B28  8E220304   LW V0, 772(S1)
269:                    ppu_write(PPU_VADDR, (uint8) (state->ppu->vaddr >> 8));
9D025B38  8E220304   LW V0, 772(S1)
270:                    ppu_write(PPU_VADDR, (uint8) (state->ppu->vaddr & 0xFF));
9D025B48  8E220304   LW V0, 772(S1)
9D025B4C  24042006   ADDIU A0, ZERO, 8198
9D025B50  0F40624F   JAL ppu_write
9D025B54  90451164   LBU A1, 4452(V0)
271:                 }
272:                 
273:                 static void load_vramblock(nes_t *state, SNSS_FILE *snssFile)
274:                 {
275:                    ASSERT(state);
276:                 
277:                    ASSERT(snssFile->vramBlock.vramSize <= VRAM_8K); /* can't handle more than this! */
278:                    memcpy(state->rominfo->vram, snssFile->vramBlock.vram, snssFile->vramBlock.vramSize);
9D025B64  8E230310   LW V1, 784(S1)
9D025B68  8C64000C   LW A0, 12(V1)
9D025B6C  24451948   ADDIU A1, V0, 6472
9D025B70  0F40D971   JAL .Letext0, .LFE1, memcpy
9D025B74  94461946   LHU A2, 6470(V0)
279:                 }
280:                 
281:                 static void load_sramblock(nes_t *state, SNSS_FILE *snssFile)
282:                 {
283:                    ASSERT(state);
284:                 
285:                    ASSERT(snssFile->sramBlock.sramSize <= SRAM_8K); /* can't handle more than this! */
286:                    memcpy(state->rominfo->sram, snssFile->sramBlock.sram, snssFile->sramBlock.sramSize);
9D025B84  8E230310   LW V1, 784(S1)
9D025B88  8C640008   LW A0, 8(V1)
9D025B8C  2445594B   ADDIU A1, V0, 22859
9D025B90  0F40D971   JAL .Letext0, .LFE1, memcpy
9D025B94  94465948   LHU A2, 22856(V0)
287:                 }
288:                 
289:                 static void load_controllerblock(nes_t *state, SNSS_FILE *snssFile)
290:                 {
291:                    UNUSED(state);
292:                    UNUSED(snssFile);
293:                 }
294:                 
295:                 static void load_soundblock(nes_t *state, SNSS_FILE *snssFile)
296:                 {
297:                    int i;
298:                 
299:                    ASSERT(state);
300:                 
301:                    for (i = 0; i < 0x15; i++)
9D025C88  2A020015   SLTI V0, S0, 21
302:                    {
303:                       if (i != 0x13) /* do NOT trigger OAM DMA! */
9D025C68  0B40971D   J .LBB52, .LBB53
9D025C6C  24120014   ADDIU S2, ZERO, 20
9D025C70  26100001   ADDIU S0, S0, 1
9D025C74  1212FFFE   BEQ S0, S2, 0x9D025C70
9D025C78  02701021   ADDU V0, S3, S0
304:                          apu_write(0x4000 + i, snssFile->soundBlock.soundRegisters[i]);
9D025C7C  26043FFF   ADDIU A0, S0, 16383
9D025C80  0F407683   JAL apu_write
9D025C84  904579E4   LBU A1, 31204(V0)
9D025C88  2A020015   SLTI V0, S0, 21
9D025C8C  5440FFF9   BNEL V0, ZERO, .LBB52, .LBB53
9D025C90  26100001   ADDIU S0, S0, 1
305:                    }
306:                 }
307:                 
308:                 /* TODO: magic numbers galore */
309:                 static void load_mapperblock(nes_t *state, SNSS_FILE *snssFile)
310:                 {
311:                    int i;
312:                    
313:                    ASSERT(state);
314:                 
315:                    mmc_getcontext(state->mmc);
9D025BA4  0F40B1E3   JAL mmc_getcontext
9D025BA8  8E24030C   LW A0, 780(S1)
9D025BAC  02609021   ADDU S2, S3, ZERO
9D025BB0  34108000   ORI S0, ZERO, -32768
316:                 
317:                    for (i = 0; i < 4; i++)
9D025BB4  3C170001   LUI S7, 1
9D025BCC  1617FFFA   BNE S0, S7, 0x9D025BB8
9D025BD0  26520002   ADDIU S2, S2, 2
318:                       mmc_bankrom(8, 0x8000 + (i * 0x2000), snssFile->mapperBlock.prgPages[i]);
9D025BB8  24040008   ADDIU A0, ZERO, 8
9D025BBC  02002821   ADDU A1, S0, ZERO
9D025BC0  0F40B246   JAL mmc_bankrom
9D025BC4  9646794C   LHU A2, 31052(S2)
9D025BC8  26102000   ADDIU S0, S0, 8192
319:                 
320:                    if (state->rominfo->vrom_banks)
9D025BD4  8E220310   LW V0, 784(S1)
9D025BD8  8C420014   LW V0, 20(V0)
9D025BDC  1040000C   BEQ V0, ZERO, 0x9D025C10
9D025BE0  00008021   ADDU S0, ZERO, ZERO
321:                    {
322:                       for (i = 0; i < 8; i++)
9D025BE4  24120010   ADDIU S2, ZERO, 16
9D025BE8  02701021   ADDU V0, S3, S0
9D025C00  5612FFFA   BNEL S0, S2, 0x9D025BEC
9D025C04  02701021   ADDU V0, S3, S0
323:                          mmc_bankvrom(1, i * 0x400, snssFile->mapperBlock.chrPages[i]);
9D025BEC  24040001   ADDIU A0, ZERO, 1
9D025BF0  00102A40   SLL A1, S0, 9
9D025BF4  0F40B1E8   JAL mmc_bankvrom
9D025BF8  94467954   LHU A2, 31060(V0)
9D025BFC  26100002   ADDIU S0, S0, 2
324:                    }
325:                    else
326:                    {
327:                       ASSERT(state->rominfo->vram);
328:                 
329:                       for (i = 0; i < 8; i++)
9D025C10  24120008   ADDIU S2, ZERO, 8
9D025C28  26100001   ADDIU S0, S0, 1
9D025C2C  5612FFFA   BNEL S0, S2, 0x9D025C18
9D025C30  8E220310   LW V0, 784(S1)
330:                          ppu_setpage(1, i, state->rominfo->vram);
9D025C14  8E220310   LW V0, 784(S1)
9D025C18  24040001   ADDIU A0, ZERO, 1
9D025C1C  02002821   ADDU A1, S0, ZERO
9D025C20  0F4060DF   JAL ppu_setpage
9D025C24  8C46000C   LW A2, 12(V0)
331:                    }
332:                 
333:                    if (state->mmc->intf->set_state)
9D025C08  0B40970E   J 0x9D025C38
9D025C0C  8E22030C   LW V0, 780(S1)
9D025C34  8E22030C   LW V0, 780(S1)
9D025C38  8C420000   LW V0, 0(V0)
9D025C3C  8C420018   LW V0, 24(V0)
9D025C40  10400003   BEQ V0, ZERO, .LVL108
9D025C44  00000000   NOP
334:                       state->mmc->intf->set_state(&snssFile->mapperBlock);
9D025C48  0040F809   JALR V0
9D025C4C  2664794C   ADDIU A0, S3, 31052
335:                 
336:                    mmc_setcontext(state->mmc);
9D025C50  0F40B1DE   JAL mmc_setcontext
9D025C54  8E24030C   LW A0, 780(S1)
337:                 }
338:                 
339:                 
340:                 int state_save(void)
341:                 {
9D02510C  27BDFDC8   ADDIU SP, SP, -568
9D025110  AFBF0234   SW RA, 564(SP)
9D025114  AFB40230   SW S4, 560(SP)
9D025118  AFB3022C   SW S3, 556(SP)
9D02511C  AFB20228   SW S2, 552(SP)
9D025120  AFB10224   SW S1, 548(SP)
342:                    SNSS_FILE *snssFile;
343:                    SNSS_RETURN_CODE status;
344:                    char fn[PATH_MAX + 1], ext[5];
345:                    nes_t *machine;
346:                 
347:                    /* get the pointer to our NES machine context */
348:                    machine = nes_getcontextptr();
9D025124  0F408AD0   JAL nes_getcontextptr
9D025128  AFB00220   SW S0, 544(SP)
9D02512C  00408021   ADDU S0, V0, ZERO
349:                    ASSERT(machine);
350:                    
351:                    /* build our filename using the image's name and the slot number */
352:                    strncpy(fn, machine->rominfo->filename, PATH_MAX - 4);
9D025130  8C450310   LW A1, 784(V0)
9D025134  27A40014   ADDIU A0, SP, 20
9D025138  24A50029   ADDIU A1, A1, 41
9D02513C  0F40E164   JAL .LFE23, strncpy
9D025140  240601FC   ADDIU A2, ZERO, 508
353:                    
354:                    ASSERT(state_slot >= FIRST_STATE_SLOT && state_slot <= LAST_STATE_SLOT);
355:                    sprintf(ext, ".ss%d", state_slot);
9D025144  27A40218   ADDIU A0, SP, 536
9D025148  3C059D04   LUI A1, -25340
9D02514C  24A59A84   ADDIU A1, A1, -25980
9D025150  0F40EBB1   JAL _sprintf_cdnopuxX, _sprintf_cdnopsuxX
9D025154  8F868110   LW A2, -32496(GP)
356:                    //osd_newextension(fn, ext);
357:                 
358:                    /* open our state file for writing */
359:                    status = SNSS_OpenFile(&snssFile, fn, SNSS_OPEN_WRITE);
9D025158  27A40010   ADDIU A0, SP, 16
9D02515C  27A50014   ADDIU A1, SP, 20
9D025160  0F408414   JAL SNSS_OpenFile
9D025164  24060001   ADDIU A2, ZERO, 1
360:                    if (SNSS_OK != status)
9D025168  1440015E   BNE V0, ZERO, .L6
9D02516C  8FB10010   LW S1, 16(SP)
361:                       goto _error;
362:                 
363:                    /* now get all of our blocks */
364:                    if (0 == save_baseblock(machine, snssFile))
365:                    {
366:                       status = SNSS_WriteBlock(snssFile, SNSS_BASR);
9D0253CC  8FA40010   LW A0, 16(SP)
9D0253D0  0F4085B4   JAL SNSS_WriteBlock
9D0253D4  00002821   ADDU A1, ZERO, ZERO
367:                       if (SNSS_OK != status)
9D0253D8  144000C2   BNE V0, ZERO, .L6
9D0253DC  00000000   NOP
368:                          goto _error;
369:                    }
370:                 
371:                    if (0 == save_vramblock(machine, snssFile))
372:                    {
373:                       status = SNSS_WriteBlock(snssFile, SNSS_VRAM);
9D02542C  8FA40010   LW A0, 16(SP)
9D025430  0F4085B4   JAL SNSS_WriteBlock
9D025434  24050001   ADDIU A1, ZERO, 1
374:                       if (SNSS_OK != status)
9D025438  144000AA   BNE V0, ZERO, .L6
9D02543C  00000000   NOP
375:                          goto _error;
376:                    }
377:                 
378:                    if (0 == save_sramblock(machine, snssFile))
9D02540C  0B409511   J .LBB18
9D025410  8FA40010   LW A0, 16(SP)
9D025440  8FA40010   LW A0, 16(SP)
379:                    {
380:                       status = SNSS_WriteBlock(snssFile, SNSS_SRAM);
9D0254BC  8FA40010   LW A0, 16(SP)
9D0254C0  0F4085B4   JAL SNSS_WriteBlock
9D0254C4  24050002   ADDIU A1, ZERO, 2
381:                       if (SNSS_OK != status)
9D0254C8  14400086   BNE V0, ZERO, .L6
9D0254CC  8FB10010   LW S1, 16(SP)
382:                          goto _error;
383:                    }
384:                 
385:                    if (0 == save_soundblock(machine, snssFile))
9D025484  0B409534   J .LBB25
9D025488  8FB10010   LW S1, 16(SP)
9D025494  0B409534   J .LBB25
9D025498  8FB10010   LW S1, 16(SP)
386:                    {
387:                       status = SNSS_WriteBlock(snssFile, SNSS_SOUN);
9D0255BC  8FA40010   LW A0, 16(SP)
9D0255C0  0F4085B4   JAL SNSS_WriteBlock
9D0255C4  24050005   ADDIU A1, ZERO, 5
388:                       if (SNSS_OK != status)
9D0255C8  14400046   BNE V0, ZERO, .L6
9D0255CC  8FB30010   LW S3, 16(SP)
389:                          goto _error;
390:                    }
391:                 
392:                    if (0 == save_mapperblock(machine, snssFile))
393:                    {
394:                       status = SNSS_WriteBlock(snssFile, SNSS_MPRD);
9D0256B4  0B4095C9   J 0x9D025724
9D0256B8  8FA40010   LW A0, 16(SP)
9D025724  0F4085B4   JAL SNSS_WriteBlock
9D025728  24050003   ADDIU A1, ZERO, 3
395:                       if (SNSS_OK != status)
9D02572C  1040FFE3   BEQ V0, ZERO, 0x9D0256BC
9D025730  00000000   NOP
9D025734  0B4095B9   J .L6
9D025738  00000000   NOP
396:                          goto _error;
397:                    }
398:                 
399:                    /* close the file, we're done */
400:                    status = SNSS_CloseFile(&snssFile);
9D0256BC  0F40846C   JAL SNSS_CloseFile
9D0256C0  27A40010   ADDIU A0, SP, 16
401:                    if (SNSS_OK != status)
9D0256C4  14400007   BNE V0, ZERO, .L6
9D0256C8  3C059D04   LUI A1, -25340
402:                       goto _error;
403:                 
404:                    gui_sendmsg(GUI_GREEN, "State %d saved", state_slot);
9D0256CC  240400C6   ADDIU A0, ZERO, 198
9D0256D0  24A59AD0   ADDIU A1, A1, -25904
9D0256D4  0F409020   JAL gui_sendmsg
9D0256D8  8F868110   LW A2, -32496(GP)
405:                    return 0;
9D0256DC  0B4095CF   J 0x9D02573C
9D0256E0  00001021   ADDU V0, ZERO, ZERO
406:                 
407:                 _error:
408:                    gui_sendmsg(GUI_RED, "error: %s", SNSS_GetErrorString(status));
9D0256E4  0F4083E8   JAL SNSS_GetErrorString
9D0256E8  00402021   ADDU A0, V0, ZERO
9D0256EC  240400C5   ADDIU A0, ZERO, 197
9D0256F0  3C059D04   LUI A1, -25340
9D0256F4  24A59AE0   ADDIU A1, A1, -25888
9D0256F8  0F409020   JAL gui_sendmsg
9D0256FC  00403021   ADDU A2, V0, ZERO
409:                    SNSS_CloseFile(&snssFile);
9D025700  0F40846C   JAL SNSS_CloseFile
9D025704  27A40010   ADDIU A0, SP, 16
410:                    return -1;
9D025708  0B4095CF   J 0x9D02573C
9D02570C  2402FFFF   ADDIU V0, ZERO, -1
411:                 }
9D02573C  8FBF0234   LW RA, 564(SP)
9D025740  8FB40230   LW S4, 560(SP)
9D025744  8FB3022C   LW S3, 556(SP)
9D025748  8FB20228   LW S2, 552(SP)
9D02574C  8FB10224   LW S1, 548(SP)
9D025750  8FB00220   LW S0, 544(SP)
9D025754  03E00008   JR RA
9D025758  27BD0238   ADDIU SP, SP, 568
412:                 
413:                 int state_load(void)
414:                 {
9D02575C  27BDFDB0   ADDIU SP, SP, -592
9D025760  AFBF024C   SW RA, 588(SP)
9D025764  AFB70248   SW S7, 584(SP)
9D025768  AFB60244   SW S6, 580(SP)
9D02576C  AFB50240   SW S5, 576(SP)
9D025770  AFB4023C   SW S4, 572(SP)
9D025774  AFB30238   SW S3, 568(SP)
9D025778  AFB20234   SW S2, 564(SP)
9D02577C  AFB10230   SW S1, 560(SP)
415:                    SNSS_FILE *snssFile;
416:                    SNSS_RETURN_CODE status;
417:                    SNSS_BLOCK_TYPE block_type;
418:                    char fn[PATH_MAX + 1], ext[5];
419:                    unsigned int i;
420:                    nes_t *machine;
421:                 
422:                    /* get our machine's context pointer */
423:                    machine = nes_getcontextptr();
9D025780  0F408AD0   JAL nes_getcontextptr
9D025784  AFB0022C   SW S0, 556(SP)
9D025788  00408821   ADDU S1, V0, ZERO
424:                    ASSERT(machine);
425:                 
426:                    /* build the state name using the ROM's name and the slot number */
427:                    strncpy(fn, machine->rominfo->filename, PATH_MAX - 4);
9D02578C  8C450310   LW A1, 784(V0)
9D025790  27A40018   ADDIU A0, SP, 24
9D025794  24A50029   ADDIU A1, A1, 41
9D025798  0F40E164   JAL .LFE23, strncpy
9D02579C  240601FC   ADDIU A2, ZERO, 508
428:                 
429:                    ASSERT(state_slot >= FIRST_STATE_SLOT && state_slot <= LAST_STATE_SLOT);
430:                    sprintf(ext, ".ss%d", state_slot);
9D0257A0  27A4021C   ADDIU A0, SP, 540
9D0257A4  3C059D04   LUI A1, -25340
9D0257A8  24A59A84   ADDIU A1, A1, -25980
9D0257AC  0F40EBB1   JAL _sprintf_cdnopuxX, _sprintf_cdnopsuxX
9D0257B0  8F868110   LW A2, -32496(GP)
431:                    //osd_newextension(fn, ext);
432:                    
433:                    /* open our file for writing */
434:                    status = SNSS_OpenFile(&snssFile, fn, SNSS_OPEN_READ);
9D0257B4  27A40010   ADDIU A0, SP, 16
9D0257B8  27A50018   ADDIU A1, SP, 24
9D0257BC  0F408414   JAL SNSS_OpenFile
9D0257C0  00003021   ADDU A2, ZERO, ZERO
435:                    if (SNSS_OK != status)
9D0257C4  14400147   BNE V0, ZERO, .L43
9D0257C8  8FA50010   LW A1, 16(SP)
436:                       goto _error;
437:                 
438:                    /* iterate through all present blocks */
439:                    for (i = 0; i < snssFile->headerBlock.numberOfBlocks; i++)
9D0257CC  8CA20010   LW V0, 16(A1)
9D0257D0  1040013A   BEQ V0, ZERO, 0x9D025CBC
9D0257D4  0000A021   ADDU S4, ZERO, ZERO
9D025B58  0B40972A   J 0x9D025CA8
9D025B5C  26940001   ADDIU S4, S4, 1
9D025B78  0B40972A   J 0x9D025CA8
9D025B7C  26940001   ADDIU S4, S4, 1
9D025B98  0B40972A   J 0x9D025CA8
9D025B9C  26940001   ADDIU S4, S4, 1
9D025C58  0B40972A   J 0x9D025CA8
9D025C5C  26940001   ADDIU S4, S4, 1
9D025C94  0B40972A   J 0x9D025CA8
9D025C98  26940001   ADDIU S4, S4, 1
9D025CA4  26940001   ADDIU S4, S4, 1
9D025CA8  8FA50010   LW A1, 16(SP)
9D025CAC  8CA20010   LW V0, 16(A1)
9D025CB0  0282102B   SLTU V0, S4, V0
9D025CB4  1440FECC   BNE V0, ZERO, 0x9D0257E8
9D025CB8  00000000   NOP
440:                    {
441:                       status = SNSS_GetNextBlockType(&block_type, snssFile);
9D0257E8  0F408499   JAL SNSS_GetNextBlockType
9D0257EC  27A40014   ADDIU A0, SP, 20
442:                       if (SNSS_OK != status)
9D0257F0  1440013C   BNE V0, ZERO, .L43
9D0257F4  00000000   NOP
443:                          goto _error;
444:                 
445:                       status = SNSS_ReadBlock(snssFile, block_type);
9D0257F8  8FA40010   LW A0, 16(SP)
9D0257FC  0F40850C   JAL SNSS_ReadBlock
9D025800  8FA50014   LW A1, 20(SP)
446:                       if (SNSS_OK != status)
9D025804  14400137   BNE V0, ZERO, .L43
9D025808  00000000   NOP
447:                          goto _error;
448:                 
449:                       switch (block_type)
9D0257E0  3C159D02   LUI S5, -25342
9D0257E4  26B55830   ADDIU S5, S5, 22576
9D02580C  8FA20014   LW V0, 20(SP)
9D025810  2C420006   SLTIU V0, V0, 6
9D025814  10400121   BEQ V0, ZERO, 0x9D025C9C
9D025818  8FA20014   LW V0, 20(SP)
9D02581C  00021080   SLL V0, V0, 2
9D025820  02A21021   ADDU V0, S5, V0
9D025824  8C420000   LW V0, 0(V0)
9D025828  00400008   JR V0
9D02582C  00000000   NOP
450:                       {
451:                       case SNSS_BASR:
452:                          load_baseblock(machine, snssFile);
9D025848  8FB00010   LW S0, 16(SP)
453:                          break;
454:                 
455:                       case SNSS_VRAM:
456:                          load_vramblock(machine, snssFile);
9D025B60  8FA20010   LW V0, 16(SP)
457:                          break;
458:                 
459:                       case SNSS_SRAM:
460:                          load_sramblock(machine, snssFile);
9D025B80  8FA20010   LW V0, 16(SP)
461:                          break;
462:                       
463:                       case SNSS_MPRD:
464:                          load_mapperblock(machine, snssFile);
9D025BA0  8FB30010   LW S3, 16(SP)
465:                          break;
466:                       
467:                       case SNSS_CNTR:
468:                          load_controllerblock(machine, snssFile);
469:                          break;
470:                       
471:                       case SNSS_SOUN:
472:                          load_soundblock(machine, snssFile);
9D025C60  8FB30010   LW S3, 16(SP)
9D025C64  24100001   ADDIU S0, ZERO, 1
473:                          break;
474:                       
475:                       case SNSS_UNKNOWN_BLOCK:
476:                       default:
477:                          log_printf("unknown SNSS block type\n");
9D0257D8  3C169D04   LUI S6, -25340
9D0257DC  26D69AEC   ADDIU S6, S6, -25876
9D025C9C  0F40EEE8   JAL log_printf
9D025CA0  02C02021   ADDU A0, S6, ZERO
478:                          break;
479:                       }
480:                    }
481:                 
482:                    /* close file, we're done */
483:                    status = SNSS_CloseFile(&snssFile);
9D025CBC  0F40846C   JAL SNSS_CloseFile
9D025CC0  27A40010   ADDIU A0, SP, 16
484:                    if (SNSS_OK != status)
9D025CC4  14400007   BNE V0, ZERO, .L43
9D025CC8  3C059D04   LUI A1, -25340
485:                       goto _error;
486:                 
487:                    gui_sendmsg(GUI_GREEN, "State %d restored", state_slot);
9D025CCC  240400C6   ADDIU A0, ZERO, 198
9D025CD0  24A59B08   ADDIU A1, A1, -25848
9D025CD4  0F409020   JAL gui_sendmsg
9D025CD8  8F868110   LW A2, -32496(GP)
488:                 
489:                    return 0;
9D025CDC  0B409743   J 0x9D025D0C
9D025CE0  00001021   ADDU V0, ZERO, ZERO
490:                 
491:                 _error:
492:                    gui_sendmsg(GUI_RED, "error: %s", SNSS_GetErrorString(status));
9D025CE4  0F4083E8   JAL SNSS_GetErrorString
9D025CE8  00402021   ADDU A0, V0, ZERO
9D025CEC  240400C5   ADDIU A0, ZERO, 197
9D025CF0  3C059D04   LUI A1, -25340
9D025CF4  24A59AE0   ADDIU A1, A1, -25888
9D025CF8  0F409020   JAL gui_sendmsg
9D025CFC  00403021   ADDU A2, V0, ZERO
493:                    SNSS_CloseFile(&snssFile);
9D025D00  0F40846C   JAL SNSS_CloseFile
9D025D04  27A40010   ADDIU A0, SP, 16
494:                    return -1;
9D025D08  2402FFFF   ADDIU V0, ZERO, -1
495:                 }
9D025D0C  8FBF024C   LW RA, 588(SP)
9D025D10  8FB70248   LW S7, 584(SP)
9D025D14  8FB60244   LW S6, 580(SP)
9D025D18  8FB50240   LW S5, 576(SP)
9D025D1C  8FB4023C   LW S4, 572(SP)
9D025D20  8FB30238   LW S3, 568(SP)
9D025D24  8FB20234   LW S2, 564(SP)
9D025D28  8FB10230   LW S1, 560(SP)
9D025D2C  8FB0022C   LW S0, 556(SP)
9D025D30  03E00008   JR RA
9D025D34  27BD0250   ADDIU SP, SP, 592
496:                 
497:                 /*
498:                 ** $Log: nesstate.c,v $
499:                 ** Revision 1.2  2001/04/27 14:37:11  neil
500:                 ** wheeee
501:                 **
502:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
503:                 ** initial
504:                 **
505:                 ** Revision 1.4  2000/11/11 14:52:33  matt
506:                 ** states finally bleepin' work again
507:                 **
508:                 ** Revision 1.3  2000/11/09 14:07:28  matt
509:                 ** state load fixed, state save mostly fixed
510:                 **
511:                 ** Revision 1.2  2000/10/25 00:23:16  matt
512:                 ** makefiles updated for new directory structure
513:                 **
514:                 ** Revision 1.1  2000/10/24 12:20:28  matt
515:                 ** initial revision
516:                 **
517:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/nes/nesinput.c  ----------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** nesinput.c
21:                  **
22:                  ** Event handling system routines
23:                  ** $Id: nesinput.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nesinput.h>
28:                  #include <log.h>
29:                  
30:                  /* TODO: make a linked list of inputs sources, so they
31:                  **       can be removed if need be
32:                  */
33:                  
34:                  static nesinput_t *nes_input[MAX_CONTROLLERS];
35:                  static int active_entries = 0;
36:                  
37:                  /* read counters */
38:                  static int pad0_readcount, pad1_readcount, ppad_readcount, ark_readcount;
39:                  
40:                  
41:                  static int retrieve_type(int type)
42:                  {
43:                     int i, value = 0;
9D0330EC  00001021   ADDU V0, ZERO, ZERO
44:                  
45:                     for (i = 0; i < active_entries; i++)
9D0330D4  8F878108   LW A3, -32504(GP)
9D0330D8  18E0000F   BLEZ A3, 0x9D033118
9D0330DC  3C03A001   LUI V1, -24575
9D0330E0  2463AB48   ADDIU V1, V1, -21688
9D0330E4  00073880   SLL A3, A3, 2
9D0330E8  00673821   ADDU A3, V1, A3
9D033108  5467FFFA   BNEL V1, A3, 0x9D0330F4
9D03310C  8C650000   LW A1, 0(V1)
9D033110  03E00008   JR RA
9D033114  00000000   NOP
46:                     {
47:                        ASSERT(nes_input[i]);
48:                  
49:                        if (type == nes_input[i]->type)
9D0330F0  8C650000   LW A1, 0(V1)
9D0330F4  8CA60000   LW A2, 0(A1)
9D0330F8  14C40003   BNE A2, A0, 0x9D033108
9D0330FC  24630004   ADDIU V1, V1, 4
50:                           value |= nes_input[i]->data;
9D033100  8CA50004   LW A1, 4(A1)
9D033104  00451025   OR V0, V0, A1
51:                     }
52:                  
53:                     return value;
54:                  }
9D033118  03E00008   JR RA
9D03311C  00001021   ADDU V0, ZERO, ZERO
55:                  
56:                  static uint8 get_pad0(void)
57:                  {
58:                     uint8 value;
59:                  
60:                     value = (uint8) retrieve_type(INP_JOYPAD0);
9D033140  0F40CC35   JAL .LFB0, retrieve_type, .Ltext0, .Letext0, .LFE12
61:                  
62:                     /* mask out left/right simultaneous keypresses */
63:                     if ((value & INP_PAD_UP) && (value & INP_PAD_DOWN))
9D03314C  30420030   ANDI V0, V0, 48
64:                        value &= ~(INP_PAD_UP | INP_PAD_DOWN);
9D033150  306400CF   ANDI A0, V1, 207
65:                  
66:                     if ((value & INP_PAD_LEFT) && (value & INP_PAD_RIGHT))
9D03315C  30620040   ANDI V0, V1, 64
67:                        value &= ~(INP_PAD_LEFT | INP_PAD_RIGHT);
9D03316C  3062003F   ANDI V0, V1, 63
68:                  
69:                     /* return (0x40 | value) due to bus conflicts */
70:                     return (0x40 | ((value >> pad0_readcount++) & 1));
9D033178  8F918104   LW S1, -32508(GP)
9D03317C  26220001   ADDIU V0, S1, 1
9D033180  AF828104   SW V0, -32508(GP)
9D033184  02238807   SRAV S1, V1, S1
9D033188  32310001   ANDI S1, S1, 1
9D03318C  36310040   ORI S1, S1, 64
9D033190  323100FF   ANDI S1, S1, 255
71:                  }
72:                  
73:                  static uint8 get_pad1(void)
74:                  {
75:                     uint8 value;
76:                  
77:                     value = (uint8) retrieve_type(INP_JOYPAD1);
9D0331A0  0F40CC35   JAL .LFB0, retrieve_type, .Ltext0, .Letext0, .LFE12
78:                  
79:                     /* mask out left/right simultaneous keypresses */
80:                     if ((value & INP_PAD_UP) && (value & INP_PAD_DOWN))
9D0331AC  30420030   ANDI V0, V0, 48
81:                        value &= ~(INP_PAD_UP | INP_PAD_DOWN);
9D0331B0  306400CF   ANDI A0, V1, 207
82:                  
83:                     if ((value & INP_PAD_LEFT) && (value & INP_PAD_RIGHT))
9D0331BC  30620040   ANDI V0, V1, 64
84:                        value &= ~(INP_PAD_LEFT | INP_PAD_RIGHT);
9D0331CC  3062003F   ANDI V0, V1, 63
85:                  
86:                     /* return (0x40 | value) due to bus conflicts */
87:                     return (0x40 | ((value >> pad1_readcount++) & 1));
9D0331D8  8F828100   LW V0, -32512(GP)
9D0331DC  24440001   ADDIU A0, V0, 1
9D0331E0  AF848100   SW A0, -32512(GP)
9D0331E4  00431007   SRAV V0, V1, V0
9D0331E8  30420001   ANDI V0, V0, 1
9D0331EC  34420040   ORI V0, V0, 64
88:                  }
89:                  
90:                  static uint8 get_zapper(void)
91:                  {
92:                     return (uint8) (retrieve_type(INP_ZAPPER));
9D033200  0F40CC35   JAL .LFB0, retrieve_type, .Ltext0, .Letext0, .LFE12
9D033204  24040004   ADDIU A0, ZERO, 4
93:                  }
94:                  
95:                  static uint8 get_powerpad(void)
96:                  {
97:                     int value;
98:                     uint8 ret_val = 0;
9D033234  24050010   ADDIU A1, ZERO, 16
99:                     
100:                    value = retrieve_type(INP_POWERPAD);
9D03321C  0F40CC35   JAL .LFB0, retrieve_type, .Ltext0, .Letext0, .LFE12
101:                 
102:                    if (((value >> 8) >> ppad_readcount) & 1)
9D033224  8F8380FC   LW V1, -32516(GP)
103:                       ret_val |= 0x10;
104:                    if (((value & 0xFF) >> ppad_readcount) & 1)
9D03323C  304200FF   ANDI V0, V0, 255
105:                       ret_val |= 0x08;
9D033250  34A40008   ORI A0, A1, 8
106:                 
107:                    ppad_readcount++;
9D033258  24630001   ADDIU V1, V1, 1
9D03325C  AF8380FC   SW V1, -32516(GP)
108:                 
109:                    return ret_val;
110:                 }
111:                 
112:                 static uint8 get_vsdips0(void)
113:                 {
114:                    return (retrieve_type(INP_VSDIPSW0));
9D033270  0F40CC35   JAL .LFB0, retrieve_type, .Ltext0, .Letext0, .LFE12
9D033274  24040020   ADDIU A0, ZERO, 32
115:                 }
116:                 
117:                 static uint8 get_vsdips1(void)
118:                 {
119:                    return (retrieve_type(INP_VSDIPSW1));
9D03328C  0F40CC35   JAL .LFB0, retrieve_type, .Ltext0, .Letext0, .LFE12
9D033290  24040040   ADDIU A0, ZERO, 64
120:                 }
121:                 
122:                 static uint8 get_arkanoid(void)
123:                 {
124:                    uint8 value = retrieve_type(INP_ARKANOID);
9D0332A8  0F40CC35   JAL .LFB0, retrieve_type, .Ltext0, .Letext0, .LFE12
9D0332AC  24040010   ADDIU A0, ZERO, 16
125:                 
126:                    if ((value >> (7 - ark_readcount++)) & 1)
9D0332B0  8F8380F8   LW V1, -32520(GP)
9D0332B4  24640001   ADDIU A0, V1, 1
9D0332B8  AF8480F8   SW A0, -32520(GP)
9D0332BC  304200FF   ANDI V0, V0, 255
9D0332C0  24040007   ADDIU A0, ZERO, 7
9D0332C4  00831823   SUBU V1, A0, V1
9D0332C8  00621807   SRAV V1, V0, V1
9D0332CC  30630001   ANDI V1, V1, 1
127:                       return 0x02;
9D0332D0  24020002   ADDIU V0, ZERO, 2
9D0332D4  0003100A   MOVZ V0, ZERO, V1
128:                    else
129:                       return 0;
130:                 }
131:                 
132:                 /* return input state for all types indicated (can be ORed together) */
133:                 uint8 input_get(int types)
134:                 {
9D033120  27BDFFE0   ADDIU SP, SP, -32
9D033124  AFBF001C   SW RA, 28(SP)
9D033128  AFB10018   SW S1, 24(SP)
9D03312C  AFB00014   SW S0, 20(SP)
9D033130  00808021   ADDU S0, A0, ZERO
135:                    uint8 value = 0;
136:                 
137:                    if (types & INP_JOYPAD0)
9D033134  30820001   ANDI V0, A0, 1
9D033138  10400016   BEQ V0, ZERO, .LBE17, .LBE16
9D03313C  00008821   ADDU S1, ZERO, ZERO
138:                       value |= get_pad0();
139:                    if (types & INP_JOYPAD1)
9D033194  32020002   ANDI V0, S0, 2
9D033198  10400017   BEQ V0, ZERO, 0x9D0331F8
9D03319C  32020004   ANDI V0, S0, 4
140:                       value |= get_pad1();
9D0331F0  02228825   OR S1, S1, V0
141:                    if (types & INP_ZAPPER)
9D0331F4  32020004   ANDI V0, S0, 4
9D0331F8  10400006   BEQ V0, ZERO, 0x9D033214
9D0331FC  32020008   ANDI V0, S0, 8
142:                       value |= get_zapper();
9D033208  02221025   OR V0, S1, V0
9D03320C  305100FF   ANDI S1, V0, 255
143:                    if (types & INP_POWERPAD)
9D033210  32020008   ANDI V0, S0, 8
9D033214  10400014   BEQ V0, ZERO, 0x9D033268
9D033218  32020020   ANDI V0, S0, 32
144:                       value |= get_powerpad();
9D033260  00918825   OR S1, A0, S1
145:                    if (types & INP_VSDIPSW0)
9D033264  32020020   ANDI V0, S0, 32
9D033268  10400006   BEQ V0, ZERO, 0x9D033284
9D03326C  32020040   ANDI V0, S0, 64
146:                       value |= get_vsdips0();
9D033278  02221025   OR V0, S1, V0
9D03327C  305100FF   ANDI S1, V0, 255
147:                    if (types & INP_VSDIPSW1)
9D033280  32020040   ANDI V0, S0, 64
9D033284  50400006   BEQL V0, ZERO, 0x9D0332A0
9D033288  32100010   ANDI S0, S0, 16
148:                       value |= get_vsdips1();
9D033294  02221025   OR V0, S1, V0
9D033298  305100FF   ANDI S1, V0, 255
149:                    if (types & INP_ARKANOID)
9D03329C  32100010   ANDI S0, S0, 16
9D0332A0  1200000F   BEQ S0, ZERO, 0x9D0332E0
9D0332A4  02201021   ADDU V0, S1, ZERO
150:                       value |= get_arkanoid();
9D0332D8  00518825   OR S1, V0, S1
151:                 
152:                    return value;
153:                 }
9D0332DC  02201021   ADDU V0, S1, ZERO
9D0332E0  8FBF001C   LW RA, 28(SP)
9D0332E4  8FB10018   LW S1, 24(SP)
9D0332E8  8FB00014   LW S0, 20(SP)
9D0332EC  03E00008   JR RA
9D0332F0  27BD0020   ADDIU SP, SP, 32
154:                 
155:                 /* register an input type */
156:                 void input_register(nesinput_t *input)
157:                 {
158:                    if (NULL == input)
9D0332F4  10800008   BEQ A0, ZERO, 0x9D033318
9D0332F8  8F828108   LW V0, -32504(GP)
159:                       return;
160:                 
161:                    nes_input[active_entries] = input;
9D0332FC  00022880   SLL A1, V0, 2
9D033300  3C03A001   LUI V1, -24575
9D033304  2463AB48   ADDIU V1, V1, -21688
9D033308  00A31821   ADDU V1, A1, V1
9D03330C  AC640000   SW A0, 0(V1)
162:                    active_entries++;
9D033310  24420001   ADDIU V0, V0, 1
9D033314  AF828108   SW V0, -32504(GP)
9D033318  03E00008   JR RA
9D03331C  00000000   NOP
163:                 }
164:                 
165:                 void input_event(nesinput_t *input, int state, int value)
166:                 {
167:                    ASSERT(input);
168:                 
169:                    if (state == INP_STATE_MAKE)
9D033320  24020001   ADDIU V0, ZERO, 1
9D033324  54A20005   BNEL A1, V0, 0x9D03333C
9D033328  00063027   NOR A2, ZERO, A2
170:                       input->data |= value;   /* OR it in */
9D03332C  8C820004   LW V0, 4(A0)
9D033330  00463025   OR A2, V0, A2
9D033334  03E00008   JR RA
9D033338  AC860004   SW A2, 4(A0)
171:                    else /* break state */
172:                       input->data &= ~value;  /* mask it out */
9D03333C  8C820004   LW V0, 4(A0)
9D033340  00463024   AND A2, V0, A2
9D033344  03E00008   JR RA
9D033348  AC860004   SW A2, 4(A0)
173:                 }
174:                 
175:                 void input_strobe(void)
176:                 {
177:                    pad0_readcount = 0;
9D03334C  AF808104   SW ZERO, -32508(GP)
178:                    pad1_readcount = 0;
9D033350  AF808100   SW ZERO, -32512(GP)
179:                    ppad_readcount = 0;
9D033354  AF8080FC   SW ZERO, -32516(GP)
180:                    ark_readcount = 0;
9D033358  03E00008   JR RA
9D03335C  AF8080F8   SW ZERO, -32520(GP)
181:                 }
182:                 
183:                 /*
184:                 ** $Log: nesinput.c,v $
185:                 ** Revision 1.2  2001/04/27 14:37:11  neil
186:                 ** wheeee
187:                 **
188:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
189:                 ** initial
190:                 **
191:                 ** Revision 1.1  2000/10/24 12:20:28  matt
192:                 ** changed directory structure
193:                 **
194:                 ** Revision 1.9  2000/09/10 23:25:03  matt
195:                 ** minor changes
196:                 **
197:                 ** Revision 1.8  2000/07/31 04:27:59  matt
198:                 ** one million cleanups
199:                 **
200:                 ** Revision 1.7  2000/07/23 15:11:45  matt
201:                 ** removed unused variables
202:                 **
203:                 ** Revision 1.6  2000/07/17 01:52:28  matt
204:                 ** made sure last line of all source files is a newline
205:                 **
206:                 ** Revision 1.5  2000/07/04 04:56:50  matt
207:                 ** include changes
208:                 **
209:                 ** Revision 1.4  2000/06/09 15:12:26  matt
210:                 ** initial revision
211:                 **
212:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/nes/nes_rom.c  -----------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** nes_rom.c
21:                  **
22:                  ** NES ROM loading/saving related functions
23:                  ** $Id: nes_rom.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  /* TODO: make this a generic ROM loading routine */
27:                  
28:                  #include <stdio.h>
29:                  #include <string.h>
30:                  #include <noftypes.h>
31:                  #include <nes_rom.h>
32:                  #include <intro.h>
33:                  #include <nes_mmc.h>
34:                  #include <nes_ppu.h>
35:                  #include <nes.h>
36:                  #include <gui.h>
37:                  #include <log.h>
38:                  #include <osd.h>
39:                  
40:                  extern char *osd_getromdata();
41:                  
42:                  /* Max length for displayed filename */
43:                  #define  ROM_DISP_MAXLEN   20
44:                  
45:                  
46:                  #ifdef ZLIB
47:                  #include <zlib.h>
48:                  #define  _fopen            gzopen
49:                  #define  _fclose           gzclose
50:                  #define  _fread(B,N,L,F)   gzread((F),(B),(L)*(N))
51:                  #else
52:                  #define  _fopen            fopen
53:                  #define  _fclose           fclose
54:                  #define  _fread(B,N,L,F)   fread((B),(N),(L),(F))
55:                  #endif
56:                  
57:                  #define  ROM_FOURSCREEN    0x08
58:                  #define  ROM_TRAINER       0x04
59:                  #define  ROM_BATTERY       0x02
60:                  #define  ROM_MIRRORTYPE    0x01
61:                  #define  ROM_INES_MAGIC    "NES\x1A"
62:                  
63:                  //ToDo: packed - JD
64:                  typedef struct inesheader_s
65:                  {
66:                     uint8 ines_magic[4]    ;
67:                     uint8 rom_banks        ;
68:                     uint8 vrom_banks       ;
69:                     uint8 rom_type         ;
70:                     uint8 mapper_hinybble  ;
71:                     uint8 reserved[8]      ;
72:                  } inesheader_t;
73:                  
74:                  
75:                  #define  TRAINER_OFFSET    0x1000
76:                  #define  TRAINER_LENGTH    0x200
77:                  #define  VRAM_LENGTH       0x2000
78:                  
79:                  #define  ROM_BANK_LENGTH   0x4000
80:                  #define  VROM_BANK_LENGTH  0x2000
81:                  
82:                  #define  SRAM_BANK_LENGTH  0x0400
83:                  #define  VRAM_BANK_LENGTH  0x2000
84:                  
85:                  /* Save battery-backed RAM */
86:                  static void rom_savesram(rominfo_t *rominfo)
87:                  {
9D02A958  27BDFDD8   ADDIU SP, SP, -552
9D02A95C  AFBF0224   SW RA, 548(SP)
9D02A960  AFB10220   SW S1, 544(SP)
9D02A964  AFB0021C   SW S0, 540(SP)
88:                     FILE *fp;
89:                     char fn[PATH_MAX + 1];
90:                  
91:                     ASSERT(rominfo);
92:                  
93:                     if (rominfo->flags & ROM_FLAG_BATTERY)
9D02A968  90820028   LBU V0, 40(A0)
9D02A96C  30420001   ANDI V0, V0, 1
9D02A970  10400016   BEQ V0, ZERO, .LVL14
9D02A974  00808021   ADDU S0, A0, ZERO
94:                     {
95:                        strncpy(fn, rominfo->filename, PATH_MAX);
9D02A978  27A40010   ADDIU A0, SP, 16
9D02A97C  26050029   ADDIU A1, S0, 41
9D02A980  0F40E164   JAL .LFE23, strncpy
9D02A984  24060200   ADDIU A2, ZERO, 512
96:                        //osd_newextension(fn, ".sav");
97:                  
98:                        fp = fopen(fn, "wb");
9D02A988  27A40010   ADDIU A0, SP, 16
9D02A98C  3C059D03   LUI A1, -25341
9D02A990  0F40DA7E   JAL .Letext0, .LFE3, fopen
9D02A994  24A553B8   ADDIU A1, A1, 21432
99:                        if (NULL != fp)
9D02A998  1040000C   BEQ V0, ZERO, .LVL14
9D02A99C  00408821   ADDU S1, V0, ZERO
100:                       {
101:                          fwrite(rominfo->sram, SRAM_BANK_LENGTH, rominfo->sram_banks, fp);
9D02A9A0  8E040008   LW A0, 8(S0)
9D02A9A4  24050400   ADDIU A1, ZERO, 1024
9D02A9A8  8E060018   LW A2, 24(S0)
9D02A9AC  0F40EFC8   JAL fwrite
9D02A9B0  00403821   ADDU A3, V0, ZERO
102:                          fclose(fp);
9D02A9B4  0F40E9A2   JAL .Letext0, .LFE1, fclose
9D02A9B8  02202021   ADDU A0, S1, ZERO
103:                          log_printf("Wrote battery RAM to %s.\n", fn);
9D02A9BC  3C049D03   LUI A0, -25341
9D02A9C0  248453BC   ADDIU A0, A0, 21436
9D02A9C4  0F40EEE8   JAL log_printf
9D02A9C8  27A50010   ADDIU A1, SP, 16
104:                       }
105:                    }
106:                 }
9D02A9CC  8FBF0224   LW RA, 548(SP)
9D02A9D0  8FB10220   LW S1, 544(SP)
9D02A9D4  8FB0021C   LW S0, 540(SP)
9D02A9D8  03E00008   JR RA
9D02A9DC  27BD0228   ADDIU SP, SP, 552
107:                 
108:                 /* Load battery-backed RAM from disk */
109:                 static void rom_loadsram(rominfo_t *rominfo)
110:                 {
9D02A8D0  27BDFDD8   ADDIU SP, SP, -552
9D02A8D4  AFBF0224   SW RA, 548(SP)
9D02A8D8  AFB10220   SW S1, 544(SP)
9D02A8DC  AFB0021C   SW S0, 540(SP)
111:                    FILE *fp;
112:                    char fn[PATH_MAX + 1];
113:                 
114:                    ASSERT(rominfo);
115:                 
116:                    if (rominfo->flags & ROM_FLAG_BATTERY)
9D02A8E0  90820028   LBU V0, 40(A0)
9D02A8E4  30420001   ANDI V0, V0, 1
9D02A8E8  10400016   BEQ V0, ZERO, .LVL6
9D02A8EC  00808021   ADDU S0, A0, ZERO
117:                    {
118:                       strncpy(fn, rominfo->filename, PATH_MAX);
9D02A8F0  27A40010   ADDIU A0, SP, 16
9D02A8F4  26050029   ADDIU A1, S0, 41
9D02A8F8  0F40E164   JAL .LFE23, strncpy
9D02A8FC  24060200   ADDIU A2, ZERO, 512
119:                       //osd_newextension(fn, ".sav");
120:                 
121:                       fp = fopen(fn, "rb");
9D02A900  27A40010   ADDIU A0, SP, 16
9D02A904  3C059D03   LUI A1, -25341
9D02A908  0F40DA7E   JAL .Letext0, .LFE3, fopen
9D02A90C  24A55398   ADDIU A1, A1, 21400
122:                       if (NULL != fp)
9D02A910  1040000C   BEQ V0, ZERO, .LVL6
9D02A914  00408821   ADDU S1, V0, ZERO
123:                       {
124:                          fread(rominfo->sram, SRAM_BANK_LENGTH, rominfo->sram_banks, fp);
9D02A918  8E040008   LW A0, 8(S0)
9D02A91C  24050400   ADDIU A1, ZERO, 1024
9D02A920  8E060018   LW A2, 24(S0)
9D02A924  0F40CA31   JAL .Letext0, .LFE1, fread
9D02A928  00403821   ADDU A3, V0, ZERO
125:                          fclose(fp);
9D02A92C  0F40E9A2   JAL .Letext0, .LFE1, fclose
9D02A930  02202021   ADDU A0, S1, ZERO
126:                          log_printf("Read battery RAM from %s.\n", fn);
9D02A934  3C049D03   LUI A0, -25341
9D02A938  2484539C   ADDIU A0, A0, 21404
9D02A93C  0F40EEE8   JAL log_printf
9D02A940  27A50010   ADDIU A1, SP, 16
127:                       }
128:                    }
129:                 }
9D02A944  8FBF0224   LW RA, 548(SP)
9D02A948  8FB10220   LW S1, 544(SP)
9D02A94C  8FB0021C   LW S0, 540(SP)
9D02A950  03E00008   JR RA
9D02A954  27BD0228   ADDIU SP, SP, 552
130:                 
131:                 /* Allocate space for SRAM */
132:                 static int rom_allocsram(rominfo_t *rominfo)
133:                 {
134:                    /* Load up SRAM */
135:                    rominfo->sram = malloc(SRAM_BANK_LENGTH * rominfo->sram_banks);
9D02AF68  8E240018   LW A0, 24(S1)
136:                    if (NULL == rominfo->sram)
9D02AF74  14400007   BNE V0, ZERO, 0x9D02AF94
137:                    {
138:                       gui_sendmsg(GUI_RED, "Could not allocate space for battery RAM");
9D02AF7C  240400C5   ADDIU A0, ZERO, 197
139:                       return -1;
140:                    }
141:                 
142:                    /* make damn sure SRAM is clear */
143:                    memset(rominfo->sram, 0, SRAM_BANK_LENGTH * rominfo->sram_banks);
9D02AF94  8E260018   LW A2, 24(S1)
9D02AF98  00402021   ADDU A0, V0, ZERO
9D02AF9C  00002821   ADDU A1, ZERO, ZERO
9D02AFA0  0F40E7C9   JAL .Letext0, .LFE0, memset
9D02AFA4  00063280   SLL A2, A2, 10
144:                    return 0;
145:                 }
146:                 
147:                 /* If there's a trainer, load it in at $7000 */
148:                 static void rom_loadtrainer(unsigned char **rom, rominfo_t *rominfo)
149:                 {
150:                    ASSERT(rom);
151:                    ASSERT(rominfo);
152:                 
153:                    if (rominfo->flags & ROM_FLAG_TRAINER)
9D02AFAC  90430028   LBU V1, 40(V0)
154:                    {
155:                 //      fread(rominfo->sram + TRAINER_OFFSET, TRAINER_LENGTH, 1, fp);
156:                       memcpy(rominfo->sram + TRAINER_OFFSET, *rom, TRAINER_LENGTH);
9D02AFC0  8C420008   LW V0, 8(V0)
157:                       rom+=TRAINER_LENGTH;
158:                       log_printf("Read in trainer at $7000\n");
9D02B01C  3C049D03   LUI A0, -25341
9D02B020  0F40EEE8   JAL log_printf
9D02B024  24845538   ADDIU A0, A0, 21816
159:                    }
160:                 }
161:                 
162:                 static int rom_loadrom(unsigned char **rom, rominfo_t *rominfo)
163:                 {
164:                    ASSERT(rom);
165:                    ASSERT(rominfo);
166:                 
167:                    /* Allocate ROM space, and load it up! */
168:                 /*
169:                    rominfo->rom = malloc((rominfo->rom_banks * ROM_BANK_LENGTH));
170:                    if (NULL == rominfo->rom)
171:                    {
172:                       gui_sendmsg(GUI_RED, "Could not allocate space for ROM image");
173:                       return -1;
174:                    }
175:                    _fread(rominfo->rom, ROM_BANK_LENGTH, rominfo->rom_banks, fp);
176:                 */
177:                    rominfo->rom=*rom;
9D02B02C  AE300000   SW S0, 0(S1)
178:                    *rom+=ROM_BANK_LENGTH*rominfo->rom_banks;
9D02B03C  00031B80   SLL V1, V1, 14
9D02B040  02038021   ADDU S0, S0, V1
179:                 
180:                 
181:                    /* If there's VROM, allocate and stuff it in */
182:                    if (rominfo->vrom_banks)
9D02B030  8E220014   LW V0, 20(S1)
9D02B034  10400005   BEQ V0, ZERO, 0x9D02B04C
9D02B038  8E230010   LW V1, 16(S1)
183:                    {
184:                 /*
185:                       rominfo->vrom = malloc((rominfo->vrom_banks * VROM_BANK_LENGTH));
186:                       if (NULL == rominfo->vrom)
187:                       {
188:                          gui_sendmsg(GUI_RED, "Could not allocate space for VROM");
189:                          return -1;
190:                       }
191:                       _fread(rominfo->vrom, VROM_BANK_LENGTH, rominfo->vrom_banks, fp);
192:                 */
193:                       rominfo->vrom=*rom;
9D02B044  0B40AC30   J 0x9D02B0C0
9D02B048  AE300004   SW S0, 4(S1)
194:                       *rom+=VROM_BANK_LENGTH*rominfo->vrom_banks;
195:                 
196:                    }
197:                    else
198:                    {
199:                       rominfo->vram = malloc(VRAM_LENGTH);
9D02B04C  0F40DB84   JAL _my_malloc
9D02B050  24042000   ADDIU A0, ZERO, 8192
200:                       if (NULL == rominfo->vram)
9D02B054  14400007   BNE V0, ZERO, 0x9D02B074
9D02B058  AE22000C   SW V0, 12(S1)
201:                       {
202:                          gui_sendmsg(GUI_RED, "Could not allocate space for VRAM");
9D02B05C  240400C5   ADDIU A0, ZERO, 197
9D02B060  3C059D03   LUI A1, -25341
9D02B064  0F409020   JAL gui_sendmsg
9D02B068  24A55554   ADDIU A1, A1, 21844
9D02B06C  0B40AC23   J .L47
9D02B070  00000000   NOP
203:                          return -1;
204:                       }
205:                       memset(rominfo->vram, 0, VRAM_LENGTH);
9D02B074  00402021   ADDU A0, V0, ZERO
9D02B078  00002821   ADDU A1, ZERO, ZERO
9D02B07C  0F40E7C9   JAL .Letext0, .LFE0, memset
9D02B080  24062000   ADDIU A2, ZERO, 8192
9D02B084  0B40AC30   J 0x9D02B0C0
9D02B088  00000000   NOP
206:                    }
207:                 
208:                    return 0;
209:                 }
210:                 
211:                 /* If we've got a VS. system game, load in the palette, as well */
212:                 static void rom_checkforpal(rominfo_t *rominfo)
213:                 {
214:                    FILE *fp;
215:                    rgb_t vs_pal[64];
216:                    char filename[PATH_MAX + 1];
217:                    int i;
218:                 
219:                    ASSERT(rominfo);
220:                 
221:                    strncpy(filename, rominfo->filename, PATH_MAX);
222:                    //osd_newextension(filename, ".pal");
223:                 
224:                    fp = fopen(filename, "rb");
225:                    if (NULL == fp)
226:                       return; /* no palette found  */
227:                 
228:                    for (i = 0; i < 64; i++)
229:                    {
230:                       vs_pal[i].r = fgetc(fp);
231:                       vs_pal[i].g = fgetc(fp);
232:                       vs_pal[i].b = fgetc(fp);
233:                    }
234:                 
235:                    fclose(fp);
236:                    /* TODO: this should really be a *SYSTEM* flag */
237:                    rominfo->flags |= ROM_FLAG_VERSUS;
238:                    /* TODO: bad, BAD idea, calling nes_getcontextptr... */
239:                    ppu_setpal(nes_getcontextptr()->ppu, vs_pal);
240:                    log_printf("Game specific palette found -- assuming VS. UniSystem\n");
241:                 }
242:                 
243:                 static FILE *rom_findrom(const char *filename, rominfo_t *rominfo)
244:                 {
245:                    FILE *fp;
246:                 
247:                    ASSERT(rominfo);
248:                 
249:                    if (NULL == filename)
9D02A9E0  1080002C   BEQ A0, ZERO, 0x9D02AA94
9D02A9E4  3C059D03   LUI A1, -25341
250:                       return NULL;
251:                 
252:                    /* Make a copy of the name so we can extend it */
253:                    //osd_fullname(rominfo->filename, filename);
254:                 
255:                    fp = _fopen(rominfo->filename, "rb");
9D02A9F4  27A40049   ADDIU A0, SP, 73
9D02A9F8  0F40DA7E   JAL .Letext0, .LFE3, fopen
9D02A9FC  24A55398   ADDIU A1, A1, 21400
256:                    if (NULL == fp)
9D02AA00  14400015   BNE V0, ZERO, 0x9D02AA58
9D02AA04  00408021   ADDU S0, V0, ZERO
257:                    {
258:                       /* Didn't find the file?  Maybe the .NES extension was omitted */
259:                       if (NULL == strrchr(rominfo->filename, '.'))
9D02AA08  27A40049   ADDIU A0, SP, 73
9D02AA0C  0F40EFB6   JAL .Letext0, .LFE0, strrchr
9D02AA10  2405002E   ADDIU A1, ZERO, 46
9D02AA14  1440000A   BNE V0, ZERO, 0x9D02AA40
9D02AA18  27A40049   ADDIU A0, SP, 73
260:                          strncat(rominfo->filename, ".nes", PATH_MAX - strlen(rominfo->filename));
9D02AA1C  0F40D9CB   JAL strlen
9D02AA20  27A40049   ADDIU A0, SP, 73
9D02AA24  27A40049   ADDIU A0, SP, 73
9D02AA28  3C059D03   LUI A1, -25341
9D02AA2C  24A553D8   ADDIU A1, A1, 21464
9D02AA30  24060200   ADDIU A2, ZERO, 512
9D02AA34  0F40E7F3   JAL strncat
9D02AA38  00C23023   SUBU A2, A2, V0
261:                 
262:                       /* this will either return NULL or a valid file pointer */
263:                       fp = _fopen(rominfo->filename, "rb");
9D02AA3C  27A40049   ADDIU A0, SP, 73
9D02AA40  3C059D03   LUI A1, -25341
9D02AA44  0F40DA7E   JAL .Letext0, .LFE3, fopen
9D02AA48  24A55398   ADDIU A1, A1, 21400
9D02AA4C  00408021   ADDU S0, V0, ZERO
264:                    }
265:                 
266:                    return fp;
267:                 }
268:                 
269:                 /* Add ROM name to a list with dirty headers */
270:                 static int rom_adddirty(char *filename)
271:                 {
272:                 #ifdef NOFRENDO_DEBUG
273:                 #define  MAX_BUFFER_LENGTH    255
274:                    char buffer[MAX_BUFFER_LENGTH + 1];
275:                    bool found = false;
276:                 
277:                    FILE *fp = fopen("dirtyrom.txt", "rt");
278:                    if (NULL == fp)
279:                       return -1;
280:                 
281:                    while (fgets(buffer, MAX_BUFFER_LENGTH, fp))
282:                    {
283:                       if (0 == strncmp(filename, buffer, strlen(filename)))
284:                       {
285:                          found = true;
286:                          break;
287:                       }
288:                    }
289:                 
290:                    if (false == found)
291:                    {
292:                       /* close up the file, open it back up for writing */
293:                       fclose(fp);
294:                       fp = fopen("dirtyrom.txt", "at");
295:                       fprintf(fp, "%s -- dirty header\n", filename);
296:                    }
297:                 
298:                    fclose(fp);
299:                 #endif /* NOFRENDO_DEBUG */
300:                 
301:                    return 0;
302:                 }
303:                 
304:                 /* return 0 if this *is* an iNES file */
305:                 int rom_checkmagic(const char *filename)
306:                 {
9D02A9E8  27BDFDA8   ADDIU SP, SP, -600
9D02A9EC  AFBF0254   SW RA, 596(SP)
9D02A9F0  AFB00250   SW S0, 592(SP)
307:                    inesheader_t head;
308:                    rominfo_t rominfo;
309:                    FILE *fp;
310:                 
311:                    fp = rom_findrom(filename, &rominfo);
312:                    if (NULL == fp)
9D02AA50  12000012   BEQ S0, ZERO, 0x9D02AA9C
9D02AA54  2402FFFF   ADDIU V0, ZERO, -1
313:                       return -1;
9D02AA94  03E00008   JR RA
9D02AA98  2402FFFF   ADDIU V0, ZERO, -1
314:                 
315:                    _fread(&head, 1, sizeof(head), fp);
9D02AA58  27A40010   ADDIU A0, SP, 16
9D02AA5C  24050001   ADDIU A1, ZERO, 1
9D02AA60  24060010   ADDIU A2, ZERO, 16
9D02AA64  0F40CA31   JAL .Letext0, .LFE1, fread
9D02AA68  02003821   ADDU A3, S0, ZERO
316:                 
317:                    _fclose(fp);
9D02AA6C  0F40E9A2   JAL .Letext0, .LFE1, fclose
9D02AA70  02002021   ADDU A0, S0, ZERO
318:                 
319:                    if (0 == memcmp(head.ines_magic, ROM_INES_MAGIC, 4))
9D02AA74  27A40010   ADDIU A0, SP, 16
9D02AA78  3C059D03   LUI A1, -25341
9D02AA7C  24A553E0   ADDIU A1, A1, 21472
9D02AA80  0F40E931   JAL .LFE0, memcmp
9D02AA84  24060004   ADDIU A2, ZERO, 4
9D02AA88  0002102B   SLTU V0, ZERO, V0
9D02AA8C  0B40AAA7   J 0x9D02AA9C
9D02AA90  00021023   SUBU V0, ZERO, V0
320:                       /* not an iNES file */
321:                       return 0;
322:                 
323:                    return -1;
324:                 }
9D02AA9C  8FBF0254   LW RA, 596(SP)
9D02AAA0  8FB00250   LW S0, 592(SP)
9D02AAA4  03E00008   JR RA
9D02AAA8  27BD0258   ADDIU SP, SP, 600
325:                 
326:                 static int rom_getheader(unsigned char **rom, rominfo_t *rominfo)
327:                 {
328:                 #define  RESERVED_LENGTH   8
329:                    inesheader_t head;
330:                    uint8 reserved[RESERVED_LENGTH];
331:                    bool header_dirty;
332:                 
333:                    ASSERT(rom);
334:                    ASSERT(*rom);
335:                    ASSERT(rominfo);
336:                 
337:                    /* Read in the header */
338:                 //   _fread(&head, 1, sizeof(head), fp);
339:                 	printf("Head: %p (%x %x %x %x)\n", *rom, (*rom)[0], (*rom)[1], (*rom)[2], (*rom)[3]);
9D02AD90  92060000   LBU A2, 0(S0)
9D02AD94  92070001   LBU A3, 1(S0)
9D02AD98  92020002   LBU V0, 2(S0)
9D02AD9C  AFA20010   SW V0, 16(SP)
9D02ADA0  92020003   LBU V0, 3(S0)
9D02ADA4  AFA20014   SW V0, 20(SP)
9D02ADA8  3C049D03   LUI A0, -25341
9D02ADAC  24845448   ADDIU A0, A0, 21576
9D02ADB0  0F40EE92   JAL _printf_cdnopuxX
9D02ADB4  02002821   ADDU A1, S0, ZERO
340:                 	memcpy(&head, *rom, sizeof(head));
9D02ADB8  8A050003   LWL A1, 3(S0)
9D02ADBC  9A050000   LWR A1, 0(S0)
9D02ADC0  8A040007   LWL A0, 7(S0)
9D02ADC4  9A040004   LWR A0, 4(S0)
9D02ADC8  8A03000B   LWL V1, 11(S0)
9D02ADCC  9A030008   LWR V1, 8(S0)
9D02ADD0  8A02000F   LWL V0, 15(S0)
9D02ADD4  9A02000C   LWR V0, 12(S0)
9D02ADD8  AFA5001C   SW A1, 28(SP)
9D02ADDC  AFA40020   SW A0, 32(SP)
9D02ADE0  AFA30024   SW V1, 36(SP)
9D02ADE4  AFA20028   SW V0, 40(SP)
341:                 	*rom+=sizeof(head);
9D02ADE8  26100010   ADDIU S0, S0, 16
342:                 
343:                    if (memcmp(head.ines_magic, ROM_INES_MAGIC, 4))
9D02ADEC  27A4001C   ADDIU A0, SP, 28
9D02ADF0  3C059D03   LUI A1, -25341
9D02ADF4  24A553E0   ADDIU A1, A1, 21472
9D02ADF8  0F40E931   JAL .LFE0, memcmp
9D02ADFC  24060004   ADDIU A2, ZERO, 4
9D02AE00  50400008   BEQL V0, ZERO, 0x9D02AE24
9D02AE04  93A20020   LBU V0, 32(SP)
344:                    {
345:                       gui_sendmsg(GUI_RED, "%s is not a valid ROM image", rominfo->filename);
9D02AE08  240400C5   ADDIU A0, ZERO, 197
9D02AE0C  3C059D03   LUI A1, -25341
9D02AE10  24A55460   ADDIU A1, A1, 21600
9D02AE14  0F409020   JAL gui_sendmsg
9D02AE18  26260029   ADDIU A2, S1, 41
9D02AE1C  0B40AC23   J .L47
9D02AE20  00000000   NOP
346:                       return -1;
347:                    }
348:                 
349:                    rominfo->rom_banks = head.rom_banks;
9D02AE24  AE220010   SW V0, 16(S1)
350:                    rominfo->vrom_banks = head.vrom_banks;
9D02AE28  93A20021   LBU V0, 33(SP)
9D02AE2C  AE220014   SW V0, 20(S1)
351:                    /* iNES assumptions */
352:                    rominfo->sram_banks = 8; /* 1kB banks, so 8KB */
9D02AE30  24020008   ADDIU V0, ZERO, 8
9D02AE34  AE220018   SW V0, 24(S1)
353:                    rominfo->vram_banks = 1; /* 8kB banks, so 8KB */
9D02AE38  24020001   ADDIU V0, ZERO, 1
9D02AE3C  AE22001C   SW V0, 28(S1)
354:                    rominfo->mirror = (head.rom_type & ROM_MIRRORTYPE) ? MIRROR_VERT : MIRROR_HORIZ;
9D02AE40  93A20022   LBU V0, 34(SP)
9D02AE44  30430001   ANDI V1, V0, 1
9D02AE48  AE230024   SW V1, 36(S1)
355:                    rominfo->flags = 0;
9D02AE5C  0B40AB9A   J 0x9D02AE68
9D02AE60  A2200028   SB ZERO, 40(S1)
356:                    if (head.rom_type & ROM_BATTERY)
9D02AE4C  30430002   ANDI V1, V0, 2
9D02AE50  306300FF   ANDI V1, V1, 255
9D02AE54  14600003   BNE V1, ZERO, 0x9D02AE64
9D02AE58  24030001   ADDIU V1, ZERO, 1
357:                       rominfo->flags |= ROM_FLAG_BATTERY;
9D02AE64  A2230028   SB V1, 40(S1)
358:                    if (head.rom_type & ROM_TRAINER)
9D02AE68  30430004   ANDI V1, V0, 4
9D02AE6C  306300FF   ANDI V1, V1, 255
9D02AE70  10600005   BEQ V1, ZERO, 0x9D02AE88
9D02AE74  30430008   ANDI V1, V0, 8
359:                       rominfo->flags |= ROM_FLAG_TRAINER;
9D02AE78  92230028   LBU V1, 40(S1)
9D02AE7C  34630002   ORI V1, V1, 2
9D02AE80  A2230028   SB V1, 40(S1)
360:                    if (head.rom_type & ROM_FOURSCREEN)
9D02AE84  30430008   ANDI V1, V0, 8
9D02AE88  306300FF   ANDI V1, V1, 255
9D02AE8C  10600004   BEQ V1, ZERO, 0x9D02AEA0
9D02AE90  00029102   SRL S2, V0, 4
361:                       rominfo->flags |= ROM_FLAG_FOURSCREEN;
9D02AE94  92230028   LBU V1, 40(S1)
9D02AE98  34630004   ORI V1, V1, 4
9D02AE9C  A2230028   SB V1, 40(S1)
362:                    /* TODO: fourscreen a mirroring type? */
363:                    rominfo->mapper_number = head.rom_type >> 4;
9D02AEA0  AE320020   SW S2, 32(S1)
364:                 
365:                    /* Do a compare - see if we've got a clean extended header */
366:                    memset(reserved, 0, RESERVED_LENGTH);
9D02AEA4  AFA0002C   SW ZERO, 44(SP)
9D02AEA8  AFA00030   SW ZERO, 48(SP)
367:                    if (0 == memcmp(head.reserved, reserved, RESERVED_LENGTH))
9D02AEAC  27A40024   ADDIU A0, SP, 36
9D02AEB0  27A5002C   ADDIU A1, SP, 44
9D02AEB4  0F40E931   JAL .LFE0, memcmp
9D02AEB8  24060008   ADDIU A2, ZERO, 8
9D02AEBC  54400006   BNEL V0, ZERO, 0x9D02AED8
9D02AEC0  93B20023   LBU S2, 35(SP)
368:                    {
369:                       /* We were clean */
370:                       header_dirty = false;
371:                       rominfo->mapper_number |= (head.mapper_hinybble & 0xF0);
9D02AEC4  93A20023   LBU V0, 35(SP)
9D02AEC8  304200F0   ANDI V0, V0, 240
9D02AECC  00529025   OR S2, V0, S2
9D02AED0  0B40ABCB   J 0x9D02AF2C
9D02AED4  AE320020   SW S2, 32(S1)
372:                    }
373:                    else
374:                    {
375:                       header_dirty = true;
376:                 
377:                       /* @!?#@! DiskDude. */
378:                       if (('D' == head.mapper_hinybble) && (0 == memcmp(head.reserved, "iskDude!", 8)))
9D02AED8  24020044   ADDIU V0, ZERO, 68
9D02AEDC  1642000D   BNE S2, V0, 0x9D02AF14
9D02AEE0  3C049D03   LUI A0, -25341
9D02AEE4  27A40024   ADDIU A0, SP, 36
9D02AEE8  3C059D03   LUI A1, -25341
9D02AEEC  24A5547C   ADDIU A1, A1, 21628
9D02AEF0  0F40E931   JAL .LFE0, memcmp
9D02AEF4  24060008   ADDIU A2, ZERO, 8
9D02AEF8  54400006   BNEL V0, ZERO, 0x9D02AF14
9D02AEFC  3C049D03   LUI A0, -25341
379:                          log_printf("`DiskDude!' found in ROM header, ignoring high mapper nybble\n");
9D02AF00  3C049D03   LUI A0, -25341
9D02AF04  0F40EEE8   JAL log_printf
9D02AF08  24845488   ADDIU A0, A0, 21640
380:                       else
381:                       {
382:                          log_printf("ROM header dirty, possible problem\n");
9D02AF14  0F40EEE8   JAL log_printf
9D02AF18  248454C8   ADDIU A0, A0, 21704
383:                          rominfo->mapper_number |= (head.mapper_hinybble & 0xF0);
9D02AF1C  325200F0   ANDI S2, S2, 240
9D02AF20  8E220020   LW V0, 32(S1)
9D02AF24  00529025   OR S2, V0, S2
9D02AF28  AE320020   SW S2, 32(S1)
384:                       }
385:                 
386:                       rom_adddirty(rominfo->filename);
387:                    }
388:                 
389:                    /* TODO: this is an ugly hack, but necessary, I guess */
390:                    /* Check for VS unisystem mapper */
391:                    if (99 == rominfo->mapper_number)
9D02AF0C  0B40ABCC   J 0x9D02AF30
9D02AF10  8E230020   LW V1, 32(S1)
9D02AF2C  8E230020   LW V1, 32(S1)
9D02AF30  24020063   ADDIU V0, ZERO, 99
9D02AF34  1462005C   BNE V1, V0, 0x9D02B0A8
9D02AF38  8FA20018   LW V0, 24(SP)
392:                       rominfo->flags |= ROM_FLAG_VERSUS;
9D02AF3C  92220028   LBU V0, 40(S1)
9D02AF40  34420008   ORI V0, V0, 8
9D02AF44  0B40AC29   J 0x9D02B0A4
9D02AF48  A2220028   SB V0, 40(S1)
393:                 
394:                    return 0;
395:                 }
396:                 
397:                 /* Build the info string for ROM display */
398:                 char *rom_getinfo(rominfo_t *rominfo)
399:                 {
9D02AAAC  27BDFBD0   ADDIU SP, SP, -1072
9D02AAB0  AFBF042C   SW RA, 1068(SP)
9D02AAB4  AFB10428   SW S1, 1064(SP)
9D02AAB8  AFB00424   SW S0, 1060(SP)
9D02AABC  00808021   ADDU S0, A0, ZERO
400:                    static char info[PATH_MAX + 1];
401:                    char romname[PATH_MAX + 1], temp[PATH_MAX + 1];
402:                 
403:                    /* Look to see if we were given a path along with filename */
404:                    /* TODO: strip extensions */
405:                    if (strrchr(rominfo->filename, PATH_SEP))
9D02AAC0  24910029   ADDIU S1, A0, 41
9D02AAC4  02202021   ADDU A0, S1, ZERO
9D02AAC8  0F40EFB6   JAL .Letext0, .LFE0, strrchr
9D02AACC  2405002F   ADDIU A1, ZERO, 47
9D02AAD0  10400006   BEQ V0, ZERO, 0x9D02AAEC
9D02AAD4  24450001   ADDIU A1, V0, 1
406:                       strncpy(romname, strrchr(rominfo->filename, PATH_SEP) + 1, PATH_MAX);
9D02AAD8  27A40018   ADDIU A0, SP, 24
9D02AADC  0F40E164   JAL .LFE23, strncpy
9D02AAE0  24060200   ADDIU A2, ZERO, 512
9D02AAE4  0B40AABF   J .LVL34
9D02AAE8  00000000   NOP
407:                    else
408:                       strncpy(romname, rominfo->filename, PATH_MAX);
9D02AAEC  27A40018   ADDIU A0, SP, 24
9D02AAF0  02202821   ADDU A1, S1, ZERO
9D02AAF4  0F40E164   JAL .LFE23, strncpy
9D02AAF8  24060200   ADDIU A2, ZERO, 512
409:                 
410:                    /* If our filename is too long, truncate our displayed filename */
411:                    if (strlen(romname) > ROM_DISP_MAXLEN)
9D02AAFC  0F40D9CB   JAL strlen
9D02AB00  27A40018   ADDIU A0, SP, 24
9D02AB04  2C420015   SLTIU V0, V0, 21
9D02AB08  1440000C   BNE V0, ZERO, 0x9D02AB3C
9D02AB0C  3C04A001   LUI A0, -24575
412:                    {
413:                       strncpy(info, romname, ROM_DISP_MAXLEN - 3);
9D02AB10  2484A1AC   ADDIU A0, A0, -24148
9D02AB14  27A50018   ADDIU A1, SP, 24
9D02AB18  0F40E164   JAL .LFE23, strncpy
9D02AB1C  24060011   ADDIU A2, ZERO, 17
414:                       strcpy(info + (ROM_DISP_MAXLEN - 3), "...");
9D02AB20  3C02A001   LUI V0, -24575
9D02AB24  3C039D03   LUI V1, -25341
9D02AB28  8C6353E8   LW V1, 21480(V1)
9D02AB2C  2444A1BD   ADDIU A0, V0, -24131
9D02AB30  A8830003   SWL V1, 3(A0)
9D02AB34  0B40AAD2   J .LVL37
9D02AB38  B843A1BD   SWR V1, -24131(V0)
415:                    }
416:                    else
417:                    {
418:                       strcpy(info, romname);
9D02AB3C  2484A1AC   ADDIU A0, A0, -24148
9D02AB40  0F40D714   JAL .LFE23, strcpy
9D02AB44  27A50018   ADDIU A1, SP, 24
419:                    }
420:                 
421:                    sprintf(temp, " [%d] %dk/%dk %c", rominfo->mapper_number,
9D02AB48  8E060020   LW A2, 32(S0)
9D02AB4C  8E070010   LW A3, 16(S0)
9D02AB50  8E030014   LW V1, 20(S0)
9D02AB54  000318C0   SLL V1, V1, 3
9D02AB58  8E020024   LW V0, 36(S0)
9D02AB5C  38420001   XORI V0, V0, 1
9D02AB60  24040056   ADDIU A0, ZERO, 86
9D02AB64  24050048   ADDIU A1, ZERO, 72
9D02AB68  00A2200B   MOVN A0, A1, V0
9D02AB6C  AFA30010   SW V1, 16(SP)
9D02AB70  AFA40014   SW A0, 20(SP)
9D02AB74  27A4021C   ADDIU A0, SP, 540
9D02AB78  3C059D03   LUI A1, -25341
9D02AB7C  24A553EC   ADDIU A1, A1, 21484
9D02AB80  0F40EBB1   JAL _sprintf_cdnopuxX, _sprintf_cdnopsuxX
9D02AB84  00073900   SLL A3, A3, 4
422:                            rominfo->rom_banks * 16, rominfo->vrom_banks * 8,
423:                            (rominfo->mirror == MIRROR_VERT) ? 'V' : 'H');
424:                    
425:                    /* Stick it on there! */
426:                    strncat(info, temp, PATH_MAX - strlen(info));
9D02AB88  3C11A001   LUI S1, -24575
9D02AB8C  0F40D9CB   JAL strlen
9D02AB90  2624A1AC   ADDIU A0, S1, -24148
9D02AB94  2624A1AC   ADDIU A0, S1, -24148
9D02AB98  27A5021C   ADDIU A1, SP, 540
9D02AB9C  24060200   ADDIU A2, ZERO, 512
9D02ABA0  0F40E7F3   JAL strncat
9D02ABA4  00C23023   SUBU A2, A2, V0
427:                 
428:                    if (rominfo->flags & ROM_FLAG_BATTERY)
9D02ABA8  92020028   LBU V0, 40(S0)
9D02ABAC  30420001   ANDI V0, V0, 1
9D02ABB0  5040000A   BEQL V0, ZERO, 0x9D02ABDC
9D02ABB4  92020028   LBU V0, 40(S0)
429:                       strncat(info, "B", PATH_MAX - strlen(info));
9D02ABB8  0F40D9CB   JAL strlen
9D02ABBC  2624A1AC   ADDIU A0, S1, -24148
9D02ABC0  2624A1AC   ADDIU A0, S1, -24148
9D02ABC4  3C059D03   LUI A1, -25341
9D02ABC8  24A55400   ADDIU A1, A1, 21504
9D02ABCC  24060200   ADDIU A2, ZERO, 512
9D02ABD0  0F40E7F3   JAL strncat
9D02ABD4  00C23023   SUBU A2, A2, V0
430:                    if (rominfo->flags & ROM_FLAG_TRAINER)
9D02ABD8  92020028   LBU V0, 40(S0)
9D02ABDC  30420002   ANDI V0, V0, 2
9D02ABE0  304200FF   ANDI V0, V0, 255
9D02ABE4  5040000B   BEQL V0, ZERO, 0x9D02AC14
9D02ABE8  92020028   LBU V0, 40(S0)
431:                       strncat(info, "T", PATH_MAX - strlen(info));
9D02ABEC  3C11A001   LUI S1, -24575
9D02ABF0  0F40D9CB   JAL strlen
9D02ABF4  2624A1AC   ADDIU A0, S1, -24148
9D02ABF8  2624A1AC   ADDIU A0, S1, -24148
9D02ABFC  3C059D03   LUI A1, -25341
9D02AC00  24A55404   ADDIU A1, A1, 21508
9D02AC04  24060200   ADDIU A2, ZERO, 512
9D02AC08  0F40E7F3   JAL strncat
9D02AC0C  00C23023   SUBU A2, A2, V0
432:                    if (rominfo->flags & ROM_FLAG_FOURSCREEN)
9D02AC10  92020028   LBU V0, 40(S0)
9D02AC14  30420004   ANDI V0, V0, 4
9D02AC18  304200FF   ANDI V0, V0, 255
9D02AC1C  1040000B   BEQ V0, ZERO, 0x9D02AC4C
9D02AC20  3C02A001   LUI V0, -24575
433:                       strncat(info, "4", PATH_MAX - strlen(info));
9D02AC24  3C10A001   LUI S0, -24575
9D02AC28  0F40D9CB   JAL strlen
9D02AC2C  2604A1AC   ADDIU A0, S0, -24148
9D02AC30  2604A1AC   ADDIU A0, S0, -24148
9D02AC34  3C059D03   LUI A1, -25341
9D02AC38  24A55408   ADDIU A1, A1, 21512
9D02AC3C  24060200   ADDIU A2, ZERO, 512
9D02AC40  0F40E7F3   JAL strncat
9D02AC44  00C23023   SUBU A2, A2, V0
434:                 
435:                    return info;
436:                 }
9D02AC48  3C02A001   LUI V0, -24575
9D02AC4C  2442A1AC   ADDIU V0, V0, -24148
9D02AC50  8FBF042C   LW RA, 1068(SP)
9D02AC54  8FB10428   LW S1, 1064(SP)
9D02AC58  8FB00424   LW S0, 1060(SP)
9D02AC5C  03E00008   JR RA
9D02AC60  27BD0430   ADDIU SP, SP, 1072
437:                 
438:                 /* Load a ROM image into memory */
439:                 rominfo_t *rom_load(const char *rom)
440:                 {
9D02AD54  27BDFFB8   ADDIU SP, SP, -72
9D02AD58  AFBF0044   SW RA, 68(SP)
9D02AD5C  AFB20040   SW S2, 64(SP)
9D02AD60  AFB1003C   SW S1, 60(SP)
9D02AD64  AFB00038   SW S0, 56(SP)
9D02AD68  00808021   ADDU S0, A0, ZERO
441:                    rominfo_t *rominfo;
442:                 
443:                    rominfo = malloc(sizeof(rominfo_t));
9D02AD6C  0F40DB84   JAL _my_malloc
9D02AD70  2404022C   ADDIU A0, ZERO, 556
444:                    if (NULL == rominfo)
9D02AD74  104000C9   BEQ V0, ZERO, 0x9D02B09C
9D02AD78  AFA20018   SW V0, 24(SP)
445:                       return NULL;
9D02B09C  0B40AC3A   J 0x9D02B0E8
9D02B0A0  00001021   ADDU V0, ZERO, ZERO
446:                 
447:                    memset(rominfo, 0, sizeof(rominfo_t));
9D02AD7C  00402021   ADDU A0, V0, ZERO
9D02AD80  00002821   ADDU A1, ZERO, ZERO
9D02AD84  0F40E7C9   JAL .Letext0, .LFE0, memset
9D02AD88  2406022C   ADDIU A2, ZERO, 556
448:                 
449:                    /* Get the header and stick it into rominfo struct */
450:                 	if (rom_getheader(&rom, rominfo))
9D02AD8C  8FB10018   LW S1, 24(SP)
451:                       goto _fail;
452:                 
453:                    /* Make sure we really support the mapper */
454:                    if (false == mmc_peek(rominfo->mapper_number))
9D02B0A4  8FA20018   LW V0, 24(SP)
9D02B0A8  0F40B2C4   JAL mmc_peek
9D02B0AC  8C440020   LW A0, 32(V0)
9D02B0B0  1440FFAD   BNE V0, ZERO, .LBB24
9D02B0B4  8FB10018   LW S1, 24(SP)
9D02B0B8  0B40ABD3   J 0x9D02AF4C
9D02B0BC  240400C5   ADDIU A0, ZERO, 197
455:                    {
456:                       gui_sendmsg(GUI_RED, "Mapper %d not yet implemented", rominfo->mapper_number);
9D02AF4C  3C059D03   LUI A1, -25341
9D02AF50  24A554EC   ADDIU A1, A1, 21740
9D02AF54  8FA20018   LW V0, 24(SP)
9D02AF58  0F409020   JAL gui_sendmsg
9D02AF5C  8C460020   LW A2, 32(V0)
457:                       goto _fail;
9D02AF60  0B40AC23   J .L47
9D02AF64  00000000   NOP
458:                    }
459:                 
460:                    /* iNES format doesn't tell us if we need SRAM, so
461:                    ** we have to always allocate it -- bleh!
462:                    ** UNIF, TAKE ME AWAY!  AAAAAAAAAA!!!
463:                    */
464:                    if (rom_allocsram(rominfo))
465:                       goto _fail;
466:                 
467:                       rom_loadtrainer(&rom, rominfo);
9D02AFA8  8FA20018   LW V0, 24(SP)
468:                 
469:                 	if (rom_loadrom(&rom, rominfo))
9D02B028  8FB10018   LW S1, 24(SP)
470:                       goto _fail;
471:                 
472:                    rom_loadsram(rominfo);
9D02B0C0  0F40AA34   JAL .LFB6, rom_loadsram, .Ltext0, .Letext0, .LFE17
9D02B0C4  8FA40018   LW A0, 24(SP)
473:                 
474:                    /* See if there's a palette we can load up */
475:                 //   rom_checkforpal(rominfo);
476:                 
477:                    gui_sendmsg(GUI_GREEN, "ROM loaded: %s", rom_getinfo(rominfo));
9D02B0C8  0F40AAAB   JAL rom_getinfo
9D02B0CC  8FA40018   LW A0, 24(SP)
9D02B0D0  240400C6   ADDIU A0, ZERO, 198
9D02B0D4  3C059D03   LUI A1, -25341
9D02B0D8  24A55578   ADDIU A1, A1, 21880
9D02B0DC  0F409020   JAL gui_sendmsg
9D02B0E0  00403021   ADDU A2, V0, ZERO
478:                 
479:                    return rominfo;
9D02B0E4  8FA20018   LW V0, 24(SP)
480:                 
481:                 _fail:
482:                    rom_free(&rominfo);
9D02B08C  0F40AB19   JAL rom_free
9D02B090  27A40018   ADDIU A0, SP, 24
483:                    return NULL;
9D02B094  0B40AC3A   J 0x9D02B0E8
9D02B098  00001021   ADDU V0, ZERO, ZERO
484:                 }
9D02B0E8  8FBF0044   LW RA, 68(SP)
9D02B0EC  8FB20040   LW S2, 64(SP)
9D02B0F0  8FB1003C   LW S1, 60(SP)
9D02B0F4  8FB00038   LW S0, 56(SP)
9D02B0F8  03E00008   JR RA
9D02B0FC  27BD0048   ADDIU SP, SP, 72
485:                 
486:                 /* Free a ROM */
487:                 void rom_free(rominfo_t **rominfo)
488:                 {
9D02AC64  27BDFFE8   ADDIU SP, SP, -24
9D02AC68  AFBF0014   SW RA, 20(SP)
9D02AC6C  AFB00010   SW S0, 16(SP)
489:                    if (NULL == *rominfo)
9D02AC70  8C820000   LW V0, 0(A0)
9D02AC74  14400007   BNE V0, ZERO, 0x9D02AC94
9D02AC78  00808021   ADDU S0, A0, ZERO
490:                    {
491:                       gui_sendmsg(GUI_GREEN, "ROM not loaded");
9D02AC7C  240400C6   ADDIU A0, ZERO, 198
9D02AC80  3C059D03   LUI A1, -25341
9D02AC84  0F409020   JAL gui_sendmsg
9D02AC88  24A5540C   ADDIU A1, A1, 21516
492:                       return;
9D02AC8C  0B40AB52   J 0x9D02AD48
9D02AC90  8FBF0014   LW RA, 20(SP)
493:                    }
494:                 
495:                    /* Restore palette if we loaded in a VS jobber */
496:                    if ((*rominfo)->flags & ROM_FLAG_VERSUS)
9D02AC94  90420028   LBU V0, 40(V0)
9D02AC98  30420008   ANDI V0, V0, 8
9D02AC9C  304200FF   ANDI V0, V0, 255
9D02ACA0  10400008   BEQ V0, ZERO, .LVL54
9D02ACA4  00000000   NOP
497:                    {
498:                       /* TODO: bad idea calling nes_getcontextptr... */
499:                       ppu_setdefaultpal(nes_getcontextptr()->ppu);
9D02ACA8  0F408AD0   JAL nes_getcontextptr
9D02ACAC  00000000   NOP
9D02ACB0  0F40636C   JAL ppu_setdefaultpal
9D02ACB4  8C440304   LW A0, 772(V0)
500:                       log_printf("Default NES palette restored\n");
9D02ACB8  3C049D03   LUI A0, -25341
9D02ACBC  0F40EEE8   JAL log_printf
9D02ACC0  2484541C   ADDIU A0, A0, 21532
501:                    }
502:                 
503:                    rom_savesram(*rominfo);
9D02ACC4  0F40AA56   JAL .LFB5, rom_savesram, .LFE6
9D02ACC8  8E040000   LW A0, 0(S0)
504:                 
505:                    if ((*rominfo)->sram)
9D02ACCC  8E040000   LW A0, 0(S0)
9D02ACD0  8C820008   LW V0, 8(A0)
9D02ACD4  50400005   BEQL V0, ZERO, 0x9D02ACEC
9D02ACD8  8C820000   LW V0, 0(A0)
506:                       free((*rominfo)->sram);
9D02ACDC  0F40DB97   JAL _my_free
9D02ACE0  24840008   ADDIU A0, A0, 8
507:                    if ((*rominfo)->rom)
9D02ACE4  8E040000   LW A0, 0(S0)
9D02ACE8  8C820000   LW V0, 0(A0)
9D02ACEC  50400004   BEQL V0, ZERO, 0x9D02AD00
9D02ACF0  8E040000   LW A0, 0(S0)
508:                       free((*rominfo)->rom);
9D02ACF4  0F40DB97   JAL _my_free
9D02ACF8  00000000   NOP
509:                    if ((*rominfo)->vrom)
9D02ACFC  8E040000   LW A0, 0(S0)
9D02AD00  8C820004   LW V0, 4(A0)
9D02AD04  50400004   BEQL V0, ZERO, 0x9D02AD18
9D02AD08  8E040000   LW A0, 0(S0)
510:                       free((*rominfo)->vrom);
9D02AD0C  0F40DB97   JAL _my_free
9D02AD10  24840004   ADDIU A0, A0, 4
511:                    if ((*rominfo)->vram)
9D02AD14  8E040000   LW A0, 0(S0)
9D02AD18  8C82000C   LW V0, 12(A0)
9D02AD1C  10400003   BEQ V0, ZERO, .LVL59
9D02AD20  00000000   NOP
512:                       free((*rominfo)->vram);
9D02AD24  0F40DB97   JAL _my_free
9D02AD28  2484000C   ADDIU A0, A0, 12
513:                 
514:                    free(*rominfo);
9D02AD2C  0F40DB97   JAL _my_free
9D02AD30  02002021   ADDU A0, S0, ZERO
515:                 
516:                    gui_sendmsg(GUI_GREEN, "ROM freed");
9D02AD34  240400C6   ADDIU A0, ZERO, 198
9D02AD38  3C059D03   LUI A1, -25341
9D02AD3C  0F409020   JAL gui_sendmsg
9D02AD40  24A5543C   ADDIU A1, A1, 21564
517:                 }
9D02AD44  8FBF0014   LW RA, 20(SP)
9D02AD48  8FB00010   LW S0, 16(SP)
9D02AD4C  03E00008   JR RA
9D02AD50  27BD0018   ADDIU SP, SP, 24
518:                 
519:                 /*
520:                 ** $Log: nes_rom.c,v $
521:                 ** Revision 1.2  2001/04/27 14:37:11  neil
522:                 ** wheeee
523:                 **
524:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
525:                 ** initial
526:                 **
527:                 ** Revision 1.8  2000/11/21 13:28:40  matt
528:                 ** take care to zero allocated mem
529:                 **
530:                 ** Revision 1.7  2000/11/09 14:07:28  matt
531:                 ** state load fixed, state save mostly fixed
532:                 **
533:                 ** Revision 1.6  2000/10/28 14:24:54  matt
534:                 ** where did I put that underscore?
535:                 **
536:                 ** Revision 1.5  2000/10/27 12:56:35  matt
537:                 ** api change for ppu palette functions
538:                 **
539:                 ** Revision 1.4  2000/10/26 22:51:44  matt
540:                 ** correct NULL filename handling
541:                 **
542:                 ** Revision 1.3  2000/10/25 01:23:08  matt
543:                 ** basic system autodetection
544:                 **
545:                 ** Revision 1.2  2000/10/25 00:23:16  matt
546:                 ** makefiles updated for new directory structure
547:                 **
548:                 ** Revision 1.1  2000/10/24 12:20:28  matt
549:                 ** changed directory structure
550:                 **
551:                 ** Revision 1.19  2000/10/21 14:35:58  matt
552:                 ** typo
553:                 **
554:                 ** Revision 1.18  2000/10/17 03:22:37  matt
555:                 ** cleaning up rom module
556:                 **
557:                 ** Revision 1.17  2000/10/10 13:58:13  matt
558:                 ** stroustrup squeezing his way in the door
559:                 **
560:                 ** Revision 1.16  2000/10/10 13:03:54  matt
561:                 ** Mr. Clean makes a guest appearance
562:                 **
563:                 ** Revision 1.15  2000/07/31 04:28:46  matt
564:                 ** one million cleanups
565:                 **
566:                 ** Revision 1.14  2000/07/30 04:31:26  matt
567:                 ** automagic loading of the nofrendo intro
568:                 **
569:                 ** Revision 1.13  2000/07/25 02:20:58  matt
570:                 ** cleanups
571:                 **
572:                 ** Revision 1.12  2000/07/20 01:53:27  matt
573:                 ** snprintf() ain't no standard function, eh?
574:                 **
575:                 ** Revision 1.11  2000/07/19 16:06:54  neil
576:                 ** little error fixed (tempinfo vs rominfo->info)
577:                 **
578:                 ** Revision 1.10  2000/07/19 15:59:39  neil
579:                 ** PATH_MAX, strncpy, snprintf, and strncat are our friends
580:                 **
581:                 ** Revision 1.9  2000/07/17 01:52:27  matt
582:                 ** made sure last line of all source files is a newline
583:                 **
584:                 ** Revision 1.8  2000/07/06 16:47:50  matt
585:                 ** new ppu palette setting calls
586:                 **
587:                 ** Revision 1.7  2000/07/05 23:21:54  neil
588:                 ** fclose(fp) should not be done if fp == NULL
589:                 **
590:                 ** Revision 1.6  2000/07/04 04:45:14  matt
591:                 ** changed include
592:                 **
593:                 ** Revision 1.5  2000/06/26 04:56:10  matt
594:                 ** minor cleanup
595:                 **
596:                 ** Revision 1.4  2000/06/09 15:12:25  matt
597:                 ** initial revision
598:                 **
599:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/nes/nes_ppu.c  -----------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** nes_ppu.c
21:                  **
22:                  ** NES PPU emulation
23:                  ** $Id: nes_ppu.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <string.h>
27:                  #include <stdlib.h>
28:                  #include <noftypes.h>
29:                  #include <nes_ppu.h>
30:                  #include <nes.h>
31:                  #include <gui.h>
32:                  #include "nes6502.h"
33:                  #include <log.h>
34:                  #include <nes_mmc.h>
35:                  
36:                  #include <bitmap.h>
37:                  #include <vid_drv.h>
38:                  #include <nes_pal.h>
39:                  #include <nesinput.h>
40:                  
41:                  
42:                  /* PPU access */
43:                  #define  PPU_MEM(x)           ppu.page[(x) >> 10][(x)]
44:                  
45:                  /* Background (color 0) and solid sprite pixel flags */
46:                  #define  BG_TRANS             0x80
47:                  #define  SP_PIXEL             0x40
48:                  #define  BG_CLEAR(V)          ((V) & BG_TRANS)
49:                  #define  BG_SOLID(V)          (0 == BG_CLEAR(V))
50:                  #define  SP_CLEAR(V)          (0 == ((V) & SP_PIXEL))
51:                  
52:                  /* Full BG color */
53:                  #define  FULLBG               (ppu.palette[0] | BG_TRANS)
54:                  
55:                  /* the NES PPU */
56:                  static ppu_t ppu;
57:                  
58:                  
59:                  void ppu_displaysprites(bool display)
60:                  {
61:                     ppu.drawsprites = display;
9D018154  3C02A000   LUI V0, -24576
9D018158  03E00008   JR RA
9D01815C  AC447FD4   SW A0, 32724(V0)
62:                  }
63:                  
64:                  void ppu_setcontext(ppu_t *src_ppu)
65:                  {
66:                     int nametab[4];
67:                     ASSERT(src_ppu);
68:                     ppu = *src_ppu;
9D018160  00801021   ADDU V0, A0, ZERO
9D018164  3C03A000   LUI V1, -24576
9D018168  24636220   ADDIU V1, V1, 25120
9D01816C  24851DB0   ADDIU A1, A0, 7600
9D018170  8C490000   LW T1, 0(V0)
9D018174  8C480004   LW T0, 4(V0)
9D018178  8C470008   LW A3, 8(V0)
9D01817C  8C46000C   LW A2, 12(V0)
9D018180  AC690000   SW T1, 0(V1)
9D018184  AC680004   SW T0, 4(V1)
9D018188  AC670008   SW A3, 8(V1)
9D01818C  AC66000C   SW A2, 12(V1)
9D018190  24420010   ADDIU V0, V0, 16
9D018194  1445FFF6   BNE V0, A1, 0x9D018170
9D018198  24630010   ADDIU V1, V1, 16
9D01819C  8C450000   LW A1, 0(V0)
9D0181A0  8C420004   LW V0, 4(V0)
9D0181A4  AC650000   SW A1, 0(V1)
9D0181A8  AC620004   SW V0, 4(V1)
69:                  
70:                     /* we can't just copy contexts here, because more than likely,
71:                     ** the top 8 pages of the ppu are pointing to internal PPU memory,
72:                     ** which means we need to recalculate the page pointers.
73:                     ** TODO: we can either get rid of the page pointing in the code,
74:                     ** or add more robust checks to make sure that pages 8-15 are
75:                     ** definitely pointing to internal PPU RAM, not just something
76:                     ** that some crazy mapper paged in.
77:                     */
78:                     nametab[0] = (src_ppu->page[8] - src_ppu->nametab + 0x2000) >> 10;
9D0181D0  8C861140   LW A2, 4416(A0)
9D0181D4  00C43023   SUBU A2, A2, A0
9D0181D8  24C62000   ADDIU A2, A2, 8192
79:                     nametab[1] = (src_ppu->page[9] - src_ppu->nametab + 0x2400) >> 10;
9D0181AC  8C851144   LW A1, 4420(A0)
9D0181B0  00A42823   SUBU A1, A1, A0
9D0181B4  24A52400   ADDIU A1, A1, 9216
80:                     nametab[2] = (src_ppu->page[10] - src_ppu->nametab + 0x2800) >> 10;
9D0181B8  8C871148   LW A3, 4424(A0)
9D0181BC  00E43823   SUBU A3, A3, A0
9D0181C0  24E72800   ADDIU A3, A3, 10240
81:                     nametab[3] = (src_ppu->page[11] - src_ppu->nametab + 0x2C00) >> 10;
9D0181C4  8C83114C   LW V1, 4428(A0)
9D0181C8  00641823   SUBU V1, V1, A0
9D0181CC  24632C00   ADDIU V1, V1, 11264
82:                  
83:                     ppu.page[8] = ppu.nametab + (nametab[0] << 10) - 0x2000;
9D0181DC  7C064804   INS A2, ZERO, 0, 10
9D0181E0  24C6E000   ADDIU A2, A2, -8192
9D0181E4  3C02A000   LUI V0, -24576
9D0181E8  24426220   ADDIU V0, V0, 25120
9D0181EC  00463021   ADDU A2, V0, A2
9D0181F0  AC461140   SW A2, 4416(V0)
84:                     ppu.page[9] = ppu.nametab + (nametab[1] << 10) - 0x2400;
9D0181F4  7C054804   INS A1, ZERO, 0, 10
9D0181F8  24A5DC00   ADDIU A1, A1, -9216
9D0181FC  00452821   ADDU A1, V0, A1
9D018200  AC451144   SW A1, 4420(V0)
85:                     ppu.page[10] = ppu.nametab + (nametab[2] << 10) - 0x2800;
9D018204  2408FC00   ADDIU T0, ZERO, -1024
9D018208  00E82024   AND A0, A3, T0
9D01820C  2484D800   ADDIU A0, A0, -10240
9D018210  00442021   ADDU A0, V0, A0
9D018214  AC441148   SW A0, 4424(V0)
86:                     ppu.page[11] = ppu.nametab + (nametab[3] << 10) - 0x2C00;
9D018218  7C034804   INS V1, ZERO, 0, 10
9D01821C  2463D400   ADDIU V1, V1, -11264
9D018220  00431821   ADDU V1, V0, V1
9D018224  AC43114C   SW V1, 4428(V0)
87:                     ppu.page[12] = ppu.page[8] - 0x1000;
9D018228  24C6F000   ADDIU A2, A2, -4096
9D01822C  AC461150   SW A2, 4432(V0)
88:                     ppu.page[13] = ppu.page[9] - 0x1000;
9D018230  24A5F000   ADDIU A1, A1, -4096
9D018234  AC451154   SW A1, 4436(V0)
89:                     ppu.page[14] = ppu.page[10] - 0x1000;
9D018238  2484F000   ADDIU A0, A0, -4096
9D01823C  AC441158   SW A0, 4440(V0)
90:                     ppu.page[15] = ppu.page[11] - 0x1000;
9D018240  2463F000   ADDIU V1, V1, -4096
9D018244  03E00008   JR RA
9D018248  AC43115C   SW V1, 4444(V0)
91:                  }
92:                  
93:                  void ppu_getcontext(ppu_t *dest_ppu)
94:                  {
95:                     int nametab[4];
96:                     
97:                     ASSERT(dest_ppu);
98:                     *dest_ppu = ppu;
9D01824C  3C02A000   LUI V0, -24576
9D018250  24426220   ADDIU V0, V0, 25120
9D018254  00801821   ADDU V1, A0, ZERO
9D018258  24451DB0   ADDIU A1, V0, 7600
9D01825C  8C490000   LW T1, 0(V0)
9D018260  8C480004   LW T0, 4(V0)
9D018264  8C470008   LW A3, 8(V0)
9D018268  8C46000C   LW A2, 12(V0)
9D01826C  AC690000   SW T1, 0(V1)
9D018270  AC680004   SW T0, 4(V1)
9D018274  AC670008   SW A3, 8(V1)
9D018278  AC66000C   SW A2, 12(V1)
9D01827C  24420010   ADDIU V0, V0, 16
9D018280  1445FFF6   BNE V0, A1, 0x9D01825C
9D018284  24630010   ADDIU V1, V1, 16
9D018288  8C450000   LW A1, 0(V0)
9D01828C  8C420004   LW V0, 4(V0)
9D018290  AC650000   SW A1, 0(V1)
9D018294  AC620004   SW V0, 4(V1)
99:                  
100:                    /* we can't just copy contexts here, because more than likely,
101:                    ** the top 8 pages of the ppu are pointing to internal PPU memory,
102:                    ** which means we need to recalculate the page pointers.
103:                    ** TODO: we can either get rid of the page pointing in the code,
104:                    ** or add more robust checks to make sure that pages 8-15 are
105:                    ** definitely pointing to internal PPU RAM, not just something
106:                    ** that some crazy mapper paged in.
107:                    */
108:                    nametab[0] = (ppu.page[8] - ppu.nametab + 0x2000) >> 10;
9D018298  3C02A000   LUI V0, -24576
9D01829C  24426220   ADDIU V0, V0, 25120
9D0182D0  24062000   ADDIU A2, ZERO, 8192
9D0182D4  00C23023   SUBU A2, A2, V0
9D0182D8  8C421140   LW V0, 4416(V0)
9D0182DC  00463021   ADDU A2, V0, A2
109:                    nametab[1] = (ppu.page[9] - ppu.nametab + 0x2400) >> 10;
9D0182A0  24052400   ADDIU A1, ZERO, 9216
9D0182A4  00A22823   SUBU A1, A1, V0
9D0182A8  8C431144   LW V1, 4420(V0)
9D0182AC  00652821   ADDU A1, V1, A1
110:                    nametab[2] = (ppu.page[10] - ppu.nametab + 0x2800) >> 10;
9D0182B0  24032800   ADDIU V1, ZERO, 10240
9D0182B4  00621823   SUBU V1, V1, V0
9D0182B8  8C461148   LW A2, 4424(V0)
9D0182BC  00C31821   ADDU V1, A2, V1
111:                    nametab[3] = (ppu.page[11] - ppu.nametab + 0x2C00) >> 10;
9D0182C0  24072C00   ADDIU A3, ZERO, 11264
9D0182C4  00E23823   SUBU A3, A3, V0
9D0182C8  8C46114C   LW A2, 4428(V0)
9D0182CC  00C73821   ADDU A3, A2, A3
112:                 
113:                    dest_ppu->page[8] = dest_ppu->nametab + (nametab[0] << 10) - 0x2000;
9D0182E0  7C064804   INS A2, ZERO, 0, 10
9D0182E4  24C6E000   ADDIU A2, A2, -8192
9D0182E8  00863021   ADDU A2, A0, A2
9D0182EC  AC861140   SW A2, 4416(A0)
114:                    dest_ppu->page[9] = dest_ppu->nametab + (nametab[1] << 10) - 0x2400;
9D0182F0  7C054804   INS A1, ZERO, 0, 10
9D0182F4  24A5DC00   ADDIU A1, A1, -9216
9D0182F8  00852821   ADDU A1, A0, A1
9D0182FC  AC851144   SW A1, 4420(A0)
115:                    dest_ppu->page[10] = dest_ppu->nametab + (nametab[2] << 10) - 0x2800;
9D018300  7C034804   INS V1, ZERO, 0, 10
9D018304  2463D800   ADDIU V1, V1, -10240
9D018308  00831821   ADDU V1, A0, V1
9D01830C  AC831148   SW V1, 4424(A0)
116:                    dest_ppu->page[11] = dest_ppu->nametab + (nametab[3] << 10) - 0x2C00;
9D018310  2408FC00   ADDIU T0, ZERO, -1024
9D018314  00E81024   AND V0, A3, T0
9D018318  2442D400   ADDIU V0, V0, -11264
9D01831C  00821021   ADDU V0, A0, V0
9D018320  AC82114C   SW V0, 4428(A0)
117:                    dest_ppu->page[12] = dest_ppu->page[8] - 0x1000;
9D018324  24C6F000   ADDIU A2, A2, -4096
9D018328  AC861150   SW A2, 4432(A0)
118:                    dest_ppu->page[13] = dest_ppu->page[9] - 0x1000;
9D01832C  24A5F000   ADDIU A1, A1, -4096
9D018330  AC851154   SW A1, 4436(A0)
119:                    dest_ppu->page[14] = dest_ppu->page[10] - 0x1000;
9D018334  2463F000   ADDIU V1, V1, -4096
9D018338  AC831158   SW V1, 4440(A0)
120:                    dest_ppu->page[15] = dest_ppu->page[11] - 0x1000;
9D01833C  2442F000   ADDIU V0, V0, -4096
9D018340  03E00008   JR RA
9D018344  AC82115C   SW V0, 4444(A0)
121:                 }
122:                 
123:                 ppu_t *ppu_create(void)
124:                 {
9D018DD0  27BDFFE8   ADDIU SP, SP, -24
9D018DD4  AFBF0014   SW RA, 20(SP)
9D018DD8  AFB00010   SW S0, 16(SP)
125:                    static bool pal_generated = false;
126:                    ppu_t *temp;
127:                 
128:                    temp = malloc(sizeof(ppu_t));
9D018DDC  0F40DB84   JAL _my_malloc
9D018DE0  24041DB8   ADDIU A0, ZERO, 7608
129:                    if (NULL == temp)
9D018DE4  10400012   BEQ V0, ZERO, 0x9D018E30
9D018DE8  00408021   ADDU S0, V0, ZERO
130:                       return NULL;
9D018E30  00001021   ADDU V0, ZERO, ZERO
131:                 
132:                    memset(temp, 0, sizeof(ppu_t));
9D018DEC  00402021   ADDU A0, V0, ZERO
9D018DF0  00002821   ADDU A1, ZERO, ZERO
9D018DF4  0F40E7C9   JAL .Letext0, .LFE0, memset
9D018DF8  24061DB8   ADDIU A2, ZERO, 7608
133:                 
134:                    temp->latchfunc = NULL;
135:                    temp->vromswitch = NULL;
136:                    temp->vram_present = false;
137:                    temp->drawsprites = true;
9D018DFC  24020001   ADDIU V0, ZERO, 1
9D018E00  AE021DB4   SW V0, 7604(S0)
138:                 
139:                    /* TODO: probably a better way to do this... */
140:                    if (false == pal_generated)
9D018E04  8F82810C   LW V0, -32500(GP)
9D018E08  14400005   BNE V0, ZERO, 0x9D018E20
9D018E0C  00000000   NOP
141:                    {
142:                       pal_generate();
9D018E10  0F40C0F7   JAL pal_generate
9D018E14  00000000   NOP
143:                       pal_generated = true;
9D018E18  24020001   ADDIU V0, ZERO, 1
9D018E1C  AF82810C   SW V0, -32500(GP)
144:                    }
145:                 
146:                    ppu_setdefaultpal(temp);
9D018E20  0F40636C   JAL ppu_setdefaultpal
9D018E24  02002021   ADDU A0, S0, ZERO
147:                 
148:                    return temp;
9D018E28  0B40638D   J 0x9D018E34
9D018E2C  02001021   ADDU V0, S0, ZERO
149:                 }
9D018E34  8FBF0014   LW RA, 20(SP)
9D018E38  8FB00010   LW S0, 16(SP)
9D018E3C  03E00008   JR RA
9D018E40  27BD0018   ADDIU SP, SP, 24
150:                 
151:                 void ppu_destroy(ppu_t **src_ppu)
152:                 {
9D018348  27BDFFE8   ADDIU SP, SP, -24
9D01834C  AFBF0014   SW RA, 20(SP)
9D018350  AFB00010   SW S0, 16(SP)
153:                    if (*src_ppu)
9D018354  8C820000   LW V0, 0(A0)
9D018358  10400004   BEQ V0, ZERO, 0x9D01836C
9D01835C  00808021   ADDU S0, A0, ZERO
154:                    {
155:                       free(*src_ppu);
9D018360  0F40DB97   JAL _my_free
9D018364  00000000   NOP
156:                       *src_ppu = NULL;
9D018368  AE000000   SW ZERO, 0(S0)
157:                    }
158:                 }
9D01836C  8FBF0014   LW RA, 20(SP)
9D018370  8FB00010   LW S0, 16(SP)
9D018374  03E00008   JR RA
9D018378  27BD0018   ADDIU SP, SP, 24
159:                 
160:                 void ppu_setpage(int size, int page_num, uint8 *location)
161:                 {
162:                    /* deliberately fall through */
163:                    switch (size)
9D01837C  24020002   ADDIU V0, ZERO, 2
9D018380  10820029   BEQ A0, V0, 0x9D018428
9D018384  28820003   SLTI V0, A0, 3
9D018388  50400006   BEQL V0, ZERO, 0x9D0183A4
9D01838C  24020004   ADDIU V0, ZERO, 4
9D018390  24030001   ADDIU V1, ZERO, 1
9D018394  1083002B   BEQ A0, V1, 0x9D018444
9D018398  00A01021   ADDU V0, A1, ZERO
9D01839C  03E00008   JR RA
9D0183A0  00000000   NOP
9D0183A4  10820015   BEQ A0, V0, 0x9D0183FC
9D0183A8  24020008   ADDIU V0, ZERO, 8
9D0183AC  1482FFFB   BNE A0, V0, 0x9D01839C
9D0183B0  24A30448   ADDIU V1, A1, 1096
164:                    {
165:                    case 8:  
166:                       ppu.page[page_num++] = location;
9D0183B4  00031880   SLL V1, V1, 2
9D0183B8  3C02A000   LUI V0, -24576
9D0183BC  24426220   ADDIU V0, V0, 25120
9D0183C0  00621821   ADDU V1, V1, V0
9D0183C4  AC660000   SW A2, 0(V1)
167:                       ppu.page[page_num++] = location;
9D0183C8  24A30449   ADDIU V1, A1, 1097
9D0183CC  00031880   SLL V1, V1, 2
9D0183D0  00621821   ADDU V1, V1, V0
9D0183D4  AC660000   SW A2, 0(V1)
168:                       ppu.page[page_num++] = location;
9D0183D8  24A4044A   ADDIU A0, A1, 1098
9D0183DC  00042080   SLL A0, A0, 2
9D0183E0  00822021   ADDU A0, A0, V0
9D0183E4  AC860000   SW A2, 0(A0)
169:                       ppu.page[page_num++] = location;
9D0183E8  24A3044B   ADDIU V1, A1, 1099
9D0183EC  24A50004   ADDIU A1, A1, 4
9D0183F0  00031880   SLL V1, V1, 2
9D0183F4  00621021   ADDU V0, V1, V0
9D0183F8  AC460000   SW A2, 0(V0)
170:                    case 4:  
171:                       ppu.page[page_num++] = location;
9D0183FC  24A40448   ADDIU A0, A1, 1096
9D018400  00042080   SLL A0, A0, 2
9D018404  3C02A000   LUI V0, -24576
9D018408  24426220   ADDIU V0, V0, 25120
9D01840C  00822021   ADDU A0, A0, V0
9D018410  AC860000   SW A2, 0(A0)
172:                       ppu.page[page_num++] = location;
9D018414  24A30449   ADDIU V1, A1, 1097
9D018418  24A50002   ADDIU A1, A1, 2
9D01841C  00031880   SLL V1, V1, 2
9D018420  00621021   ADDU V0, V1, V0
9D018424  AC460000   SW A2, 0(V0)
173:                    case 2:
174:                       ppu.page[page_num++] = location;
9D018428  24A20001   ADDIU V0, A1, 1
9D01842C  24A50448   ADDIU A1, A1, 1096
9D018430  00052880   SLL A1, A1, 2
9D018434  3C03A000   LUI V1, -24576
9D018438  24636220   ADDIU V1, V1, 25120
9D01843C  00A32821   ADDU A1, A1, V1
9D018440  ACA60000   SW A2, 0(A1)
175:                    case 1:
176:                       ppu.page[page_num++] = location;
9D018444  24420448   ADDIU V0, V0, 1096
9D018448  00021080   SLL V0, V0, 2
9D01844C  3C03A000   LUI V1, -24576
9D018450  24636220   ADDIU V1, V1, 25120
9D018454  00431021   ADDU V0, V0, V1
9D018458  AC460000   SW A2, 0(V0)
9D01845C  03E00008   JR RA
9D018460  00000000   NOP
177:                       break;
178:                    }
179:                 }
180:                 
181:                 /* make sure $3000-$3F00 mirrors $2000-$2F00 */
182:                 void ppu_mirrorhipages(void)
183:                 {
184:                    ppu.page[12] = ppu.page[8] - 0x1000;
9D018464  3C02A000   LUI V0, -24576
9D018468  24426220   ADDIU V0, V0, 25120
9D01846C  8C431140   LW V1, 4416(V0)
9D018470  2463F000   ADDIU V1, V1, -4096
9D018474  AC431150   SW V1, 4432(V0)
185:                    ppu.page[13] = ppu.page[9] - 0x1000;
9D018478  8C431144   LW V1, 4420(V0)
9D01847C  2463F000   ADDIU V1, V1, -4096
9D018480  AC431154   SW V1, 4436(V0)
186:                    ppu.page[14] = ppu.page[10] - 0x1000;
9D018484  8C431148   LW V1, 4424(V0)
9D018488  2463F000   ADDIU V1, V1, -4096
9D01848C  AC431158   SW V1, 4440(V0)
187:                    ppu.page[15] = ppu.page[11] - 0x1000;
9D018490  8C43114C   LW V1, 4428(V0)
9D018494  2463F000   ADDIU V1, V1, -4096
9D018498  03E00008   JR RA
9D01849C  AC43115C   SW V1, 4444(V0)
188:                 }
189:                 
190:                 void ppu_mirror(int nt1, int nt2, int nt3, int nt4)
191:                 {
192:                    ppu.page[8] = ppu.nametab + (nt1 << 10) - 0x2000;
9D0184A0  00042280   SLL A0, A0, 10
9D0184A4  2483E000   ADDIU V1, A0, -8192
9D0184A8  3C02A000   LUI V0, -24576
9D0184AC  24426220   ADDIU V0, V0, 25120
9D0184B0  00431821   ADDU V1, V0, V1
9D0184B4  AC431140   SW V1, 4416(V0)
193:                    ppu.page[9] = ppu.nametab + (nt2 << 10) - 0x2400;
9D0184B8  00052A80   SLL A1, A1, 10
9D0184BC  24A4DC00   ADDIU A0, A1, -9216
9D0184C0  00442021   ADDU A0, V0, A0
9D0184C4  AC441144   SW A0, 4420(V0)
194:                    ppu.page[10] = ppu.nametab + (nt3 << 10) - 0x2800;
9D0184C8  00063280   SLL A2, A2, 10
9D0184CC  24C5D800   ADDIU A1, A2, -10240
9D0184D0  00452821   ADDU A1, V0, A1
9D0184D4  AC451148   SW A1, 4424(V0)
195:                    ppu.page[11] = ppu.nametab + (nt4 << 10) - 0x2C00;
9D0184D8  00073A80   SLL A3, A3, 10
9D0184DC  24E6D400   ADDIU A2, A3, -11264
9D0184E0  00463021   ADDU A2, V0, A2
9D0184E4  AC46114C   SW A2, 4428(V0)
196:                    ppu.page[12] = ppu.page[8] - 0x1000;
9D0184E8  2463F000   ADDIU V1, V1, -4096
9D0184EC  AC431150   SW V1, 4432(V0)
197:                    ppu.page[13] = ppu.page[9] - 0x1000;
9D0184F0  2484F000   ADDIU A0, A0, -4096
9D0184F4  AC441154   SW A0, 4436(V0)
198:                    ppu.page[14] = ppu.page[10] - 0x1000;
9D0184F8  24A5F000   ADDIU A1, A1, -4096
9D0184FC  AC451158   SW A1, 4440(V0)
199:                    ppu.page[15] = ppu.page[11] - 0x1000;
9D018500  24C6F000   ADDIU A2, A2, -4096
9D018504  03E00008   JR RA
9D018508  AC46115C   SW A2, 4444(V0)
200:                 }
201:                 
202:                 /* bleh, for snss */
203:                 uint8 *ppu_getpage(int page)
204:                 {
205:                    return ppu.page[page];
9D01850C  24840448   ADDIU A0, A0, 1096
9D018510  00041080   SLL V0, A0, 2
9D018514  3C03A000   LUI V1, -24576
9D018518  24636220   ADDIU V1, V1, 25120
9D01851C  00431021   ADDU V0, V0, V1
206:                 }
9D018520  03E00008   JR RA
9D018524  8C420000   LW V0, 0(V0)
207:                 
208:                 static void mem_trash(uint8 *buffer, int length)
209:                 {
210:                    int i;
211:                 
212:                    for (i = 0; i < length; i++)
9D018564  1611FFFB   BNE S0, S1, .LBB4, .LBB5
213:                       buffer[i] = (uint8) rand();
9D018554  0F40ED55   JAL .Letext0, .LFE0, rand
9D018558  00000000   NOP
9D01855C  A2020000   SB V0, 0(S0)
9D018560  26100001   ADDIU S0, S0, 1
9D018564  1611FFFB   BNE S0, S1, .LBB4, .LBB5
9D018568  3C02A000   LUI V0, -24576
214:                 }
215:                 
216:                 /* reset state of ppu */
217:                 void ppu_reset(int reset_type)
218:                 {
9D018534  27BDFFE0   ADDIU SP, SP, -32
9D018538  AFBF001C   SW RA, 28(SP)
9D01853C  AFB10018   SW S1, 24(SP)
9D018540  AFB00014   SW S0, 20(SP)
9D018544  3C10A000   LUI S0, -24576
9D018548  26107220   ADDIU S0, S0, 29216
9D01854C  3C11A000   LUI S1, -24576
9D018550  26317320   ADDIU S1, S1, 29472
219:                    if (HARD_RESET == reset_type)
9D018528  24020001   ADDIU V0, ZERO, 1
9D01852C  14820022   BNE A0, V0, 0x9D0185B8
9D018530  3C02A000   LUI V0, -24576
220:                       mem_trash(ppu.oam, 256);
221:                 
222:                    ppu.ctrl0 = 0;
9D01856C  24426220   ADDIU V0, V0, 25120
9D018570  A0401160   SB ZERO, 4448(V0)
9D0185B8  24426220   ADDIU V0, V0, 25120
9D0185BC  A0401160   SB ZERO, 4448(V0)
223:                    ppu.ctrl1 = PPU_CTRL1F_OBJON | PPU_CTRL1F_BGON;
9D018574  24030018   ADDIU V1, ZERO, 24
9D018578  A0431161   SB V1, 4449(V0)
9D0185C0  24030018   ADDIU V1, ZERO, 24
9D0185C4  A0431161   SB V1, 4449(V0)
224:                    ppu.stat = 0;
9D01857C  A0401162   SB ZERO, 4450(V0)
9D0185C8  A0401162   SB ZERO, 4450(V0)
225:                    ppu.flipflop = 0;
9D018580  AC401170   SW ZERO, 4464(V0)
9D0185CC  AC401170   SW ZERO, 4464(V0)
226:                    ppu.vaddr = ppu.vaddr_latch = 0x2000;
9D018584  24032000   ADDIU V1, ZERO, 8192
9D018588  AC431168   SW V1, 4456(V0)
9D01858C  AC431164   SW V1, 4452(V0)
9D0185D0  24032000   ADDIU V1, ZERO, 8192
9D0185D4  AC431168   SW V1, 4456(V0)
9D0185D8  AC431164   SW V1, 4452(V0)
227:                    ppu.oam_addr = 0;
9D018590  A0401163   SB ZERO, 4451(V0)
9D0185DC  A0401163   SB ZERO, 4451(V0)
228:                    ppu.tile_xofs = 0;
9D018594  AC40116C   SW ZERO, 4460(V0)
9D0185E0  AC40116C   SW ZERO, 4460(V0)
229:                 
230:                    ppu.latch = 0;
9D018598  A0401198   SB ZERO, 4504(V0)
9D0185E4  A0401198   SB ZERO, 4504(V0)
231:                    ppu.vram_accessible = true;
9D01859C  24030001   ADDIU V1, ZERO, 1
9D0185A0  AC431DAC   SW V1, 7596(V0)
9D0185E8  24030001   ADDIU V1, ZERO, 1
9D0185EC  03E00008   JR RA
9D0185F0  AC431DAC   SW V1, 7596(V0)
232:                 }
9D0185A4  8FBF001C   LW RA, 28(SP)
9D0185A8  8FB10018   LW S1, 24(SP)
9D0185AC  8FB00014   LW S0, 20(SP)
9D0185B0  03E00008   JR RA
9D0185B4  27BD0020   ADDIU SP, SP, 32
9D0185B8  24426220   ADDIU V0, V0, 25120
9D0185BC  A0401160   SB ZERO, 4448(V0)
9D0185C0  24030018   ADDIU V1, ZERO, 24
9D0185C4  A0431161   SB V1, 4449(V0)
9D0185C8  A0401162   SB ZERO, 4450(V0)
9D0185CC  AC401170   SW ZERO, 4464(V0)
9D0185D0  24032000   ADDIU V1, ZERO, 8192
9D0185D4  AC431168   SW V1, 4456(V0)
9D0185D8  AC431164   SW V1, 4452(V0)
9D0185DC  A0401163   SB ZERO, 4451(V0)
9D0185E0  AC40116C   SW ZERO, 4460(V0)
9D0185E4  A0401198   SB ZERO, 4504(V0)
9D0185E8  24030001   ADDIU V1, ZERO, 1
9D0185EC  03E00008   JR RA
9D0185F0  AC431DAC   SW V1, 7596(V0)
233:                 
234:                 /* we render a scanline of graphics first so we know exactly
235:                 ** where the sprite 0 strike is going to occur (in terms of
236:                 ** cpu cycles), using the relation that 3 pixels == 1 cpu cycle
237:                 */
238:                 static void ppu_setstrike(int x_loc)
239:                 {
9D0180F4  27BDFFE0   ADDIU SP, SP, -32
9D0180F8  AFBF001C   SW RA, 28(SP)
9D0180FC  AFB10018   SW S1, 24(SP)
9D018100  AFB00014   SW S0, 20(SP)
9D018104  00808021   ADDU S0, A0, ZERO
240:                    if (false == ppu.strikeflag)
9D0180E4  3C02A000   LUI V0, -24576
9D0180E8  8C4273BC   LW V0, 29628(V0)
9D0180EC  14400017   BNE V0, ZERO, 0x9D01814C
9D0180F0  24020001   ADDIU V0, ZERO, 1
241:                    {
242:                       ppu.strikeflag = true;
9D018108  3C11A000   LUI S1, -24576
9D01810C  26316220   ADDIU S1, S1, 25120
9D018110  AE22119C   SW V0, 4508(S1)
243:                 
244:                       /* 3 pixels per cpu cycle */
245:                       ppu.strike_cycle = nes6502_getcycles(false) + (x_loc / 3);
9D018114  0F4028C8   JAL nes6502_getcycles
9D018118  00002021   ADDU A0, ZERO, ZERO
9D01811C  3C035555   LUI V1, 21845
9D018120  24635556   ADDIU V1, V1, 21846
9D018124  02030018   MULT 0, S0, V1
9D018128  00001810   MFHI V1
9D01812C  001087C3   SRA S0, S0, 31
9D018130  00708023   SUBU S0, V1, S0
9D018134  00501021   ADDU V0, V0, S0
9D018138  AE2211A0   SW V0, 4512(S1)
246:                    }
247:                 }
9D01813C  8FBF001C   LW RA, 28(SP)
9D018140  8FB10018   LW S1, 24(SP)
9D018144  8FB00014   LW S0, 20(SP)
9D018148  27BD0020   ADDIU SP, SP, 32
9D01814C  03E00008   JR RA
9D018150  00000000   NOP
248:                 
249:                 static void ppu_oamdma(uint8 value)
250:                 {
251:                    uint32 cpu_address;
252:                    uint8 oam_loc;
253:                 
254:                    cpu_address = (uint32) (value << 8);
9D018630  00058200   SLL S0, A1, 8
255:                 
256:                    /* Sprite DMA starts at the current SPRRAM address */
257:                    oam_loc = ppu.oam_addr;
9D018634  3C02A000   LUI V0, -24576
9D018638  90527383   LBU S2, 29571(V0)
258:                    do
259:                    {
260:                       ppu.oam[oam_loc++] = nes6502_getbyte(cpu_address++);
9D01863C  3C13A000   LUI S3, -24576
9D018640  26736220   ADDIU S3, S3, 25120
9D018644  26510001   ADDIU S1, S2, 1
9D018648  323100FF   ANDI S1, S1, 255
9D01864C  26140001   ADDIU S4, S0, 1
9D018650  0F4028BE   JAL nes6502_getbyte
9D018654  02002021   ADDU A0, S0, ZERO
9D018658  02539021   ADDU S2, S2, S3
9D01865C  A2421000   SB V0, 4096(S2)
9D01866C  0B406191   J 0x9D018644
9D018670  02808021   ADDU S0, S4, ZERO
261:                    }
262:                    while (oam_loc != ppu.oam_addr);
9D018660  92621163   LBU V0, 4451(S3)
9D018664  10510003   BEQ V0, S1, 0x9D018674
9D018668  02209021   ADDU S2, S1, ZERO
263:                 
264:                    /* TODO: enough with houdini */
265:                    cpu_address -= 256;
266:                    /* Odd address in $2003 */
267:                    if ((ppu.oam_addr >> 2) & 1)
9D018674  7E310080   EXT S1, S1, 2, 1
9D018678  12200015   BEQ S1, ZERO, 0x9D0186D0
9D01867C  2604FF01   ADDIU A0, S0, -255
9D018680  3C11A000   LUI S1, -24576
9D018684  26316220   ADDIU S1, S1, 25120
9D018688  2614FF05   ADDIU S4, S0, -251
9D01868C  02209021   ADDU S2, S1, ZERO
268:                    {
269:                       for (oam_loc = 4; oam_loc < 8; oam_loc++)
9D01869C  12740003   BEQ S3, S4, 0x9D0186AC
9D0186A0  26520001   ADDIU S2, S2, 1
270:                          ppu.oam[oam_loc] = nes6502_getbyte(cpu_address++);
9D018690  0F4028BE   JAL nes6502_getbyte
9D018694  24930001   ADDIU S3, A0, 1
9D018698  A2421004   SB V0, 4100(S2)
9D0186A4  0B4061A4   J 0x9D018690
9D0186A8  02602021   ADDU A0, S3, ZERO
271:                       cpu_address += 248;
9D0186AC  2604FFFD   ADDIU A0, S0, -3
9D0186B0  26100001   ADDIU S0, S0, 1
272:                       for (oam_loc = 0; oam_loc < 4; oam_loc++)
9D0186C0  1250000E   BEQ S2, S0, 0x9D0186FC
9D0186C4  26310001   ADDIU S1, S1, 1
273:                          ppu.oam[oam_loc] = nes6502_getbyte(cpu_address++);
9D0186B4  0F4028BE   JAL nes6502_getbyte
9D0186B8  24920001   ADDIU S2, A0, 1
9D0186BC  A2221000   SB V0, 4096(S1)
9D0186C8  0B4061AD   J 0x9D0186B4
9D0186CC  02402021   ADDU A0, S2, ZERO
9D0186D0  2612FF09   ADDIU S2, S0, -247
9D0186D4  3C02A000   LUI V0, -24576
9D0186D8  24426220   ADDIU V0, V0, 25120
9D0186DC  00508023   SUBU S0, V0, S0
274:                    }
275:                    /* Even address in $2003 */
276:                    else
277:                    {
278:                       for (oam_loc = 0; oam_loc < 8; oam_loc++)
9D0186EC  12320003   BEQ S1, S2, 0x9D0186FC
9D0186F0  A06210FE   SB V0, 4350(V1)
279:                          ppu.oam[oam_loc] = nes6502_getbyte(cpu_address++);
9D0186E0  0F4028BE   JAL nes6502_getbyte
9D0186E4  24910001   ADDIU S1, A0, 1
9D0186E8  02111821   ADDU V1, S0, S1
9D0186F4  0B4061B8   J 0x9D0186E0
9D0186F8  02202021   ADDU A0, S1, ZERO
280:                    }
281:                 
282:                    /* make the CPU spin for DMA cycles */
283:                    nes6502_burn(513);
9D0186FC  0F404EA2   JAL nes6502_burn
9D018700  24040201   ADDIU A0, ZERO, 513
284:                    nes6502_release();
9D018704  0F404EA8   JAL nes6502_release
9D018708  00000000   NOP
285:                 }
286:                 
287:                 /* TODO: this isn't the PPU! */
288:                 void ppu_writehigh(uint32 address, uint8 value)
289:                 {
9D0185F4  27BDFFD8   ADDIU SP, SP, -40
9D0185F8  AFBF0024   SW RA, 36(SP)
9D0185FC  AFB40020   SW S4, 32(SP)
9D018600  AFB3001C   SW S3, 28(SP)
9D018604  AFB20018   SW S2, 24(SP)
9D018608  AFB10014   SW S1, 20(SP)
9D01860C  AFB00010   SW S0, 16(SP)
290:                    switch (address)
9D018610  24024016   ADDIU V0, ZERO, 16406
9D018614  1082003F   BEQ A0, V0, 0x9D018714
9D018618  00A08021   ADDU S0, A1, ZERO
9D01861C  24024017   ADDIU V0, ZERO, 16407
9D018620  1082004D   BEQ A0, V0, 0x9D018758
9D018624  24024014   ADDIU V0, ZERO, 16404
9D018628  1482004E   BNE A0, V0, 0x9D018764
9D01862C  8FBF0024   LW RA, 36(SP)
291:                    {
292:                    case PPU_OAMDMA:
293:                       ppu_oamdma(value);
294:                       break;
295:                 
296:                    case PPU_JOY0:
297:                       /* VS system VROM switching - bleh!*/
298:                       if (ppu.vromswitch)
9D018714  3C02A000   LUI V0, -24576
9D018718  8C4273C8   LW V0, 29640(V0)
9D01871C  50400004   BEQL V0, ZERO, 0x9D018730
9D018720  32100001   ANDI S0, S0, 1
299:                          ppu.vromswitch(value);
9D018724  0040F809   JALR V0
9D018728  00A02021   ADDU A0, A1, ZERO
300:                 
301:                       /* see if we need to strobe them joypads */
302:                       value &= 1;
9D01872C  32100001   ANDI S0, S0, 1
303:                       
304:                       if (0 == value && ppu.strobe)
9D018730  16000006   BNE S0, ZERO, .LVL83
9D018734  3C02A000   LUI V0, -24576
9D018738  904273BA   LBU V0, 29626(V0)
9D01873C  10400004   BEQ V0, ZERO, 0x9D018750
9D018740  3C02A000   LUI V0, -24576
305:                          input_strobe();
9D018744  0F40CCD3   JAL input_strobe
9D018748  00000000   NOP
306:                 
307:                       ppu.strobe = value;
9D01874C  3C02A000   LUI V0, -24576
308:                       break;
9D018750  0B4061D8   J .LVL85
9D018754  A05073BA   SB S0, 29626(V0)
309:                 
310:                    case PPU_JOY1: /* frame IRQ control */
311:                       nes_setfiq(value);
9D018758  0F408B1A   JAL nes_setfiq
9D01875C  00A02021   ADDU A0, A1, ZERO
312:                       break;
313:                 
314:                    default:
315:                       break;
316:                    }
317:                 }
9D01870C  0B4061D9   J 0x9D018764
9D018710  8FBF0024   LW RA, 36(SP)
9D018760  8FBF0024   LW RA, 36(SP)
9D018764  8FB40020   LW S4, 32(SP)
9D018768  8FB3001C   LW S3, 28(SP)
9D01876C  8FB20018   LW S2, 24(SP)
9D018770  8FB10014   LW S1, 20(SP)
9D018774  8FB00010   LW S0, 16(SP)
9D018778  03E00008   JR RA
9D01877C  27BD0028   ADDIU SP, SP, 40
318:                 
319:                 /* TODO: this isn't the PPU! */
320:                 uint8 ppu_readhigh(uint32 address)
321:                 {
9D018780  27BDFFE8   ADDIU SP, SP, -24
322:                    uint8 value;
323:                 
324:                    switch (address)
9D018784  24024016   ADDIU V0, ZERO, 16406
9D018788  10820006   BEQ A0, V0, 0x9D0187A4
9D01878C  AFBF0014   SW RA, 20(SP)
9D018790  24024017   ADDIU V0, ZERO, 16407
9D018794  10820007   BEQ A0, V0, 0x9D0187B4
9D018798  00000000   NOP
325:                    {
326:                    case PPU_JOY0:
327:                       value = input_get(INP_JOYPAD0);
9D0187A4  0F40CC48   JAL input_get
9D0187A8  24040001   ADDIU A0, ZERO, 1
328:                       break;
9D0187AC  0B4061F2   J 0x9D0187C8
9D0187B0  8FBF0014   LW RA, 20(SP)
329:                 
330:                    case PPU_JOY1:
331:                       /* TODO: better input handling */
332:                       value = input_get(INP_ZAPPER | INP_JOYPAD1 
9D0187B4  0F40CC48   JAL input_get
9D0187B8  24040006   ADDIU A0, ZERO, 6
333:                                         /*| INP_ARKANOID*/ 
334:                                         /*| INP_POWERPAD*/);
335:                       break;
9D0187BC  0B4061F2   J 0x9D0187C8
9D0187C0  8FBF0014   LW RA, 20(SP)
336:                 
337:                    default:
338:                       value = 0xFF;
9D01879C  0B4061F1   J 0x9D0187C4
9D0187A0  240200FF   ADDIU V0, ZERO, 255
339:                       break;
340:                    }
341:                 
342:                    return value;
343:                 }
9D0187C4  8FBF0014   LW RA, 20(SP)
9D0187C8  03E00008   JR RA
9D0187CC  27BD0018   ADDIU SP, SP, 24
344:                 
345:                 /* Read from $2000-$2007 */
346:                 uint8 ppu_read(uint32 address)
347:                 {
9D0187D0  27BDFFE0   ADDIU SP, SP, -32
9D0187D4  AFBF001C   SW RA, 28(SP)
9D0187D8  AFB10018   SW S1, 24(SP)
348:                    uint8 value;
349:                    
350:                    /* handle mirrored reads up to $3FFF */
351:                    switch (address & 0x2007)
9D0187DC  30842007   ANDI A0, A0, 8199
9D0187E0  24022002   ADDIU V0, ZERO, 8194
9D0187E4  10820006   BEQ A0, V0, 0x9D018800
9D0187E8  AFB00014   SW S0, 20(SP)
9D0187EC  24022007   ADDIU V0, ZERO, 8199
9D0187F0  5082001A   BEQL A0, V0, 0x9D01885C
9D0187F4  3C02A000   LUI V0, -24576
352:                    {
353:                    case PPU_STAT:
354:                       value = (ppu.stat & 0xE0) | (ppu.latch & 0x1F);
9D018800  3C02A000   LUI V0, -24576
9D018804  24426220   ADDIU V0, V0, 25120
9D018808  90431198   LBU V1, 4504(V0)
9D01880C  3063001F   ANDI V1, V1, 31
9D018810  90501162   LBU S0, 4450(V0)
9D018814  321000E0   ANDI S0, S0, 224
355:                 
356:                       if (ppu.strikeflag)
9D018818  8C42119C   LW V0, 4508(V0)
9D01881C  10400008   BEQ V0, ZERO, 0x9D018840
9D018820  02038025   OR S0, S0, V1
357:                       {
358:                          if (nes6502_getcycles(false) >= ppu.strike_cycle)
9D018824  0F4028C8   JAL nes6502_getcycles
9D018828  00002021   ADDU A0, ZERO, ZERO
9D01882C  3C03A000   LUI V1, -24576
9D018830  8C6373C0   LW V1, 29632(V1)
9D018834  0043102B   SLTU V0, V0, V1
359:                             value |= PPU_STATF_STRIKE;
9D018838  36040040   ORI A0, S0, 64
9D01883C  0082800A   MOVZ S0, A0, V0
360:                       }
361:                 
362:                       /* clear both vblank flag and vram address flipflop */
363:                       ppu.stat &= ~PPU_STATF_VBLANK;
9D018840  3C02A000   LUI V0, -24576
9D018844  24426220   ADDIU V0, V0, 25120
9D018848  90431162   LBU V1, 4450(V0)
9D01884C  3063007F   ANDI V1, V1, 127
9D018850  A0431162   SB V1, 4450(V0)
364:                       ppu.flipflop = 0;
365:                       break;
9D018854  0B406249   J 0x9D018924
9D018858  AC401170   SW ZERO, 4464(V0)
366:                 
367:                    case PPU_VDATA:
368:                       /* buffered VRAM reads */
369:                       value = ppu.latch = ppu.vdata_latch;
9D01885C  24426220   ADDIU V0, V0, 25120
9D018860  90501199   LBU S0, 4505(V0)
9D018864  A0501198   SB S0, 4504(V0)
370:                 
371:                       /* VRAM only accessible during VBL */
372:                       if ((ppu.bg_on || ppu.obj_on) && !ppu.vram_accessible)
9D018868  8C421188   LW V0, 4488(V0)
9D01886C  14400006   BNE V0, ZERO, 0x9D018888
9D018870  3C02A000   LUI V0, -24576
9D018874  3C02A000   LUI V0, -24576
9D018878  8C4273AC   LW V0, 29612(V0)
9D01887C  10400012   BEQ V0, ZERO, .LBB18
9D018880  3C02A000   LUI V0, -24576
9D018884  3C02A000   LUI V0, -24576
9D018888  8C427FCC   LW V0, 32716(V0)
9D01888C  5440000E   BNEL V0, ZERO, .LBB18
9D018890  3C02A000   LUI V0, -24576
373:                       {
374:                          ppu.vdata_latch = 0xFF;
9D018894  3C02A000   LUI V0, -24576
9D018898  24426220   ADDIU V0, V0, 25120
9D01889C  2403FFFF   ADDIU V1, ZERO, -1
9D0188A0  A0431199   SB V1, 4505(V0)
375:                          log_printf("VRAM read at $%04X, scanline %d\n", 
9D0188AC  3C049D04   LUI A0, -25340
9D0188B0  2484B600   ADDIU A0, A0, -18944
9D0188B4  02202821   ADDU A1, S1, ZERO
9D0188B8  0F40EEE8   JAL log_printf
9D0188BC  8C460320   LW A2, 800(V0)
9D0188C0  0B406241   J 0x9D018904
9D0188C4  3C02A000   LUI V0, -24576
376:                                     ppu.vaddr, nes_getcontextptr()->scanline);
9D0188A4  0F408AD0   JAL nes_getcontextptr
9D0188A8  8C511164   LW S1, 4452(V0)
377:                       }
378:                       else
379:                       {
380:                          uint32 addr = ppu.vaddr;
9D0188C8  8C427384   LW V0, 29572(V0)
381:                          if (addr >= 0x3000)
9D0188CC  2C443000   SLTIU A0, V0, 12288
382:                             addr -= 0x1000;
9D0188D0  2443F000   ADDIU V1, V0, -4096
9D0188D4  0064100A   MOVZ V0, V1, A0
383:                          ppu.vdata_latch = PPU_MEM(addr);
9D0188D8  00022282   SRL A0, V0, 10
9D0188DC  24840448   ADDIU A0, A0, 1096
9D0188E0  00042080   SLL A0, A0, 2
9D0188E4  3C03A000   LUI V1, -24576
9D0188E8  24636220   ADDIU V1, V1, 25120
9D0188EC  00832021   ADDU A0, A0, V1
9D0188F0  8C840000   LW A0, 0(A0)
9D0188F4  00821021   ADDU V0, A0, V0
9D0188F8  90420000   LBU V0, 0(V0)
9D0188FC  A0621199   SB V0, 4505(V1)
384:                       }
385:                 
386:                       ppu.vaddr += ppu.vaddr_inc;
9D018908  8C441174   LW A0, 4468(V0)
9D01890C  8C431164   LW V1, 4452(V0)
9D018910  00831821   ADDU V1, A0, V1
387:                       ppu.vaddr &= 0x3FFF;
9D018900  3C02A000   LUI V0, -24576
9D018904  24426220   ADDIU V0, V0, 25120
9D018914  30633FFF   ANDI V1, V1, 16383
388:                       break;
9D018918  0B406249   J 0x9D018924
9D01891C  AC431164   SW V1, 4452(V0)
389:                 
390:                    case PPU_OAMDATA:
391:                    case PPU_CTRL0:
392:                    case PPU_CTRL1:
393:                    case PPU_OAMADDR:
394:                    case PPU_SCROLL:
395:                    case PPU_VADDR:
396:                    default:
397:                       value = ppu.latch;
9D0187F8  0B406248   J 0x9D018920
9D0187FC  3C02A000   LUI V0, -24576
9D018920  905073B8   LBU S0, 29624(V0)
398:                       break;
399:                    }
400:                 
401:                    return value;
402:                 }
9D018924  02001021   ADDU V0, S0, ZERO
9D018928  8FBF001C   LW RA, 28(SP)
9D01892C  8FB10018   LW S1, 24(SP)
9D018930  8FB00014   LW S0, 20(SP)
9D018934  03E00008   JR RA
9D018938  27BD0020   ADDIU SP, SP, 32
403:                 
404:                 /* Write to $2000-$2007 */
405:                 void ppu_write(uint32 address, uint8 value)
406:                 {
9D018B74  27BDFFE8   ADDIU SP, SP, -24
9D018B78  AFBF0014   SW RA, 20(SP)
9D018B7C  AFB00010   SW S0, 16(SP)
407:                    /* write goes into ppu latch... */
408:                    ppu.latch = value;
9D01893C  3C02A000   LUI V0, -24576
9D018940  A04573B8   SB A1, 29624(V0)
409:                    
410:                    switch (address & 0x2007)
9D018944  30842007   ANDI A0, A0, 8199
9D018948  2484E000   ADDIU A0, A0, -8192
9D01894C  2C820008   SLTIU V0, A0, 8
9D018950  104000E2   BEQ V0, ZERO, 0x9D018CDC
9D018954  00042080   SLL A0, A0, 2
9D018958  3C029D02   LUI V0, -25342
9D01895C  24428970   ADDIU V0, V0, -30352
9D018960  00442021   ADDU A0, V0, A0
9D018964  8C820000   LW V0, 0(A0)
9D018968  00400008   JR V0
9D01896C  00000000   NOP
411:                    {
412:                    case PPU_CTRL0:
413:                       ppu.ctrl0 = value;
9D018990  3C02A000   LUI V0, -24576
9D018994  A0457380   SB A1, 29568(V0)
414:                 
415:                       ppu.obj_height = (value & PPU_CTRL0F_OBJ16) ? 16 : 8;
9D018998  30A30020   ANDI V1, A1, 32
9D01899C  306300FF   ANDI V1, V1, 255
9D0189A0  24020010   ADDIU V0, ZERO, 16
9D0189A4  24040008   ADDIU A0, ZERO, 8
9D0189A8  0083100A   MOVZ V0, A0, V1
9D0189AC  00401821   ADDU V1, V0, ZERO
9D0189B0  3C02A000   LUI V0, -24576
9D0189B4  A043739C   SB V1, 29596(V0)
416:                       ppu.bg_base = (value & PPU_CTRL0F_BGADDR) ? 0x1000 : 0;
9D0189B8  30A30010   ANDI V1, A1, 16
9D0189BC  306300FF   ANDI V1, V1, 255
9D0189C0  24021000   ADDIU V0, ZERO, 4096
9D0189C4  0003100A   MOVZ V0, ZERO, V1
9D0189C8  00401821   ADDU V1, V0, ZERO
9D0189CC  3C02A000   LUI V0, -24576
9D0189D0  AC4373A4   SW V1, 29604(V0)
417:                       ppu.obj_base = (value & PPU_CTRL0F_OBJADDR) ? 0x1000 : 0;
9D0189D4  30A30008   ANDI V1, A1, 8
9D0189D8  306300FF   ANDI V1, V1, 255
9D0189DC  24021000   ADDIU V0, ZERO, 4096
9D0189E0  0003100A   MOVZ V0, ZERO, V1
9D0189E4  00401821   ADDU V1, V0, ZERO
9D0189E8  3C02A000   LUI V0, -24576
9D0189EC  AC4373A0   SW V1, 29600(V0)
418:                       ppu.vaddr_inc = (value & PPU_CTRL0F_ADDRINC) ? 32 : 1;
9D0189F0  30A30004   ANDI V1, A1, 4
9D0189F4  306300FF   ANDI V1, V1, 255
9D0189F8  24020020   ADDIU V0, ZERO, 32
9D0189FC  24040001   ADDIU A0, ZERO, 1
9D018A00  0083100A   MOVZ V0, A0, V1
9D018A04  00401821   ADDU V1, V0, ZERO
9D018A08  3C02A000   LUI V0, -24576
9D018A0C  24426220   ADDIU V0, V0, 25120
9D018A10  AC431174   SW V1, 4468(V0)
419:                       ppu.tile_nametab = value & PPU_CTRL0F_NAMETAB;      
9D018A14  30A50003   ANDI A1, A1, 3
9D018A18  AC451178   SW A1, 4472(V0)
420:                 
421:                       /* Mask out bits 10 & 11 in the ppu latch */
422:                       ppu.vaddr_latch &= ~0x0C00;
9D018A20  8C431168   LW V1, 4456(V0)
9D018A24  7C035A84   INS V1, ZERO, 10, 2
423:                       ppu.vaddr_latch |= ((value & 3) << 10);
9D018A1C  00052A80   SLL A1, A1, 10
9D018A28  00A32825   OR A1, A1, V1
424:                       break;
9D018A2C  03E00008   JR RA
9D018A30  AC451168   SW A1, 4456(V0)
425:                 
426:                    case PPU_CTRL1:
427:                       ppu.ctrl1 = value;
9D018A34  3C02A000   LUI V0, -24576
9D018A38  24426220   ADDIU V0, V0, 25120
9D018A3C  A0451161   SB A1, 4449(V0)
428:                 
429:                       ppu.obj_on = (value & PPU_CTRL1F_OBJON) ? true : false;
9D018A40  7CA30100   EXT V1, A1, 4, 1
9D018A44  AC43118C   SW V1, 4492(V0)
430:                       ppu.bg_on = (value & PPU_CTRL1F_BGON) ? true : false;
9D018A48  7CA300C0   EXT V1, A1, 3, 1
9D018A4C  AC431188   SW V1, 4488(V0)
431:                       ppu.obj_mask = (value & PPU_CTRL1F_OBJMASK) ? false : true;
9D018A50  38A30004   XORI V1, A1, 4
9D018A54  7C630080   EXT V1, V1, 2, 1
9D018A58  AC431190   SW V1, 4496(V0)
432:                       ppu.bg_mask = (value & PPU_CTRL1F_BGMASK) ? false : true;
9D018A5C  38A50002   XORI A1, A1, 2
9D018A60  7CA50040   EXT A1, A1, 1, 1
433:                       break;
9D018A64  03E00008   JR RA
9D018A68  AC451194   SW A1, 4500(V0)
434:                 
435:                    case PPU_OAMADDR:
436:                       ppu.oam_addr = value;
9D018A6C  3C02A000   LUI V0, -24576
437:                       break;
9D018A70  03E00008   JR RA
9D018A74  A0457383   SB A1, 29571(V0)
438:                 
439:                    case PPU_OAMDATA:
440:                       ppu.oam[ppu.oam_addr++] = value;
9D018A78  3C02A000   LUI V0, -24576
9D018A7C  24426220   ADDIU V0, V0, 25120
9D018A80  90431163   LBU V1, 4451(V0)
9D018A84  24640001   ADDIU A0, V1, 1
9D018A88  A0441163   SB A0, 4451(V0)
9D018A8C  00621021   ADDU V0, V1, V0
441:                       break;
9D018A90  03E00008   JR RA
9D018A94  A0451000   SB A1, 4096(V0)
442:                 
443:                    case PPU_SCROLL:
444:                       if (0 == ppu.flipflop)
9D018A98  3C02A000   LUI V0, -24576
9D018A9C  8C427390   LW V0, 29584(V0)
9D018AA0  1440000A   BNE V0, ZERO, 0x9D018ACC
9D018AA4  3C02A000   LUI V0, -24576
445:                       {
446:                          /* Mask out bits 4 - 0 in the ppu latch */
447:                          ppu.vaddr_latch &= ~0x001F;
9D018AB0  8C431168   LW V1, 4456(V0)
9D018AB4  7C032004   INS V1, ZERO, 0, 5
448:                          ppu.vaddr_latch |= (value >> 3);    /* Tile number */
9D018AA8  24426220   ADDIU V0, V0, 25120
9D018AAC  000520C2   SRL A0, A1, 3
9D018AB8  00831825   OR V1, A0, V1
9D018ABC  AC431168   SW V1, 4456(V0)
449:                          ppu.tile_xofs = (value & 7);  /* Tile offset (0-7 pix) */
9D018AC0  30A50007   ANDI A1, A1, 7
9D018AC4  0B4062BE   J 0x9D018AF8
9D018AC8  AC45116C   SW A1, 4460(V0)
450:                       }
451:                       else
452:                       {
453:                          /* Mask out bits 14-12 and 9-5 in the ppu latch */
454:                          ppu.vaddr_latch &= ~0x73E0;
9D018AE4  8C451168   LW A1, 4456(V0)
9D018AE8  24038C1F   ADDIU V1, ZERO, -29665
9D018AEC  00A31824   AND V1, A1, V1
455:                          ppu.vaddr_latch |= ((value & 0xF8) << 2);   /* Tile number */
9D018AD0  30A400F8   ANDI A0, A1, 248
9D018AD4  00042080   SLL A0, A0, 2
9D018AE0  00852025   OR A0, A0, A1
456:                          ppu.vaddr_latch |= ((value & 7) << 12);     /* Tile offset (0-7 pix) */
9D018ACC  24426220   ADDIU V0, V0, 25120
9D018AD8  30A50007   ANDI A1, A1, 7
9D018ADC  00052B00   SLL A1, A1, 12
9D018AF0  00831825   OR V1, A0, V1
9D018AF4  AC431168   SW V1, 4456(V0)
457:                       }
458:                 
459:                       ppu.flipflop ^= 1;
9D018AF8  3C02A000   LUI V0, -24576
9D018AFC  24426220   ADDIU V0, V0, 25120
9D018B00  8C431170   LW V1, 4464(V0)
9D018B04  38630001   XORI V1, V1, 1
9D018B08  AC431170   SW V1, 4464(V0)
9D018B0C  03E00008   JR RA
9D018B10  00000000   NOP
460:                 
461:                       break;
462:                 
463:                    case PPU_VADDR:
464:                       if (0 == ppu.flipflop)
9D018B14  3C02A000   LUI V0, -24576
9D018B18  8C427390   LW V0, 29584(V0)
9D018B1C  14400009   BNE V0, ZERO, 0x9D018B44
9D018B20  3C02A000   LUI V0, -24576
465:                       {
466:                          /* Mask out bits 15-8 in ppu latch */
467:                          ppu.vaddr_latch &= ~0xFF00;
9D018B30  8C431168   LW V1, 4456(V0)
9D018B34  7C037A04   INS V1, ZERO, 8, 8
468:                          ppu.vaddr_latch |= ((value & 0x3F) << 8);
9D018B24  24426220   ADDIU V0, V0, 25120
9D018B28  30A5003F   ANDI A1, A1, 63
9D018B2C  00052A00   SLL A1, A1, 8
9D018B38  00A31825   OR V1, A1, V1
9D018B3C  0B4062D7   J 0x9D018B5C
9D018B40  AC431168   SW V1, 4456(V0)
469:                       }
470:                       else
471:                       {
472:                          /* Mask out bits 7-0 in ppu latch */
473:                          ppu.vaddr_latch &= ~0x00FF;
9D018B44  24426220   ADDIU V0, V0, 25120
9D018B48  8C431168   LW V1, 4456(V0)
9D018B4C  7C033804   INS V1, ZERO, 0, 8
474:                          ppu.vaddr_latch |= value;
9D018B50  00A32825   OR A1, A1, V1
9D018B54  AC451168   SW A1, 4456(V0)
475:                          ppu.vaddr = ppu.vaddr_latch;
9D018B58  AC451164   SW A1, 4452(V0)
476:                       }
477:                       
478:                       ppu.flipflop ^= 1;
9D018B5C  3C02A000   LUI V0, -24576
9D018B60  24426220   ADDIU V0, V0, 25120
9D018B64  8C431170   LW V1, 4464(V0)
9D018B68  38630001   XORI V1, V1, 1
479:                 
480:                       break;
9D018B6C  03E00008   JR RA
9D018B70  AC431170   SW V1, 4464(V0)
481:                 
482:                    case PPU_VDATA:
483:                       if (ppu.vaddr < 0x3F00)
9D018B80  3C02A000   LUI V0, -24576
9D018B84  8C507384   LW S0, 29572(V0)
9D018B88  2E023F00   SLTIU V0, S0, 16128
9D018B8C  10400033   BEQ V0, ZERO, 0x9D018C5C
9D018B90  3202000F   ANDI V0, S0, 15
484:                       {
485:                          /* VRAM only accessible during scanlines 241-260 */
486:                          if ((ppu.bg_on || ppu.obj_on) && !ppu.vram_accessible)
9D018B94  3C02A000   LUI V0, -24576
9D018B98  8C4273A8   LW V0, 29608(V0)
9D018B9C  14400006   BNE V0, ZERO, 0x9D018BB8
9D018BA0  3C02A000   LUI V0, -24576
9D018BA4  3C02A000   LUI V0, -24576
9D018BA8  8C4273AC   LW V0, 29612(V0)
9D018BAC  10400018   BEQ V0, ZERO, .LBB19
9D018BB0  3C02A000   LUI V0, -24576
9D018BB4  3C02A000   LUI V0, -24576
9D018BB8  8C427FCC   LW V0, 32716(V0)
9D018BBC  14400014   BNE V0, ZERO, .LBB19
9D018BC0  3C02A000   LUI V0, -24576
487:                          {
488:                             log_printf("VRAM write to $%04X, scanline %d\n", 
9D018BCC  3C049D04   LUI A0, -25340
9D018BD0  2484B624   ADDIU A0, A0, -18908
9D018BD4  02002821   ADDU A1, S0, ZERO
9D018BD8  0F40EEE8   JAL log_printf
9D018BDC  8C460320   LW A2, 800(V0)
489:                                        ppu.vaddr, nes_getcontextptr()->scanline);
9D018BC4  0F408AD0   JAL nes_getcontextptr
9D018BC8  00000000   NOP
490:                             PPU_MEM(ppu.vaddr) = 0xFF; /* corrupt */
9D018BE0  3C03A000   LUI V1, -24576
9D018BE4  24636220   ADDIU V1, V1, 25120
9D018BE8  8C621164   LW V0, 4452(V1)
9D018BEC  00022282   SRL A0, V0, 10
9D018BF0  24840448   ADDIU A0, A0, 1096
9D018BF4  00042080   SLL A0, A0, 2
9D018BF8  00831821   ADDU V1, A0, V1
9D018BFC  8C630000   LW V1, 0(V1)
9D018C00  00621021   ADDU V0, V1, V0
9D018C04  2403FFFF   ADDIU V1, ZERO, -1
9D018C08  0B40632D   J 0x9D018CB4
9D018C0C  A0430000   SB V1, 0(V0)
491:                          }
492:                          else 
493:                          {
494:                             uint32 addr = ppu.vaddr;
495:                 
496:                             if (false == ppu.vram_present && addr >= 0x3000)
9D018C10  8C427FD0   LW V0, 32720(V0)
9D018C14  14400008   BNE V0, ZERO, 0x9D018C38
9D018C18  00101A82   SRL V1, S0, 10
9D018C1C  2E023000   SLTIU V0, S0, 12288
9D018C20  14400006   BNE V0, ZERO, 0x9D018C3C
9D018C24  24630448   ADDIU V1, V1, 1096
497:                                ppu.vaddr -= 0x1000;
9D018C28  2603F000   ADDIU V1, S0, -4096
9D018C2C  3C02A000   LUI V0, -24576
9D018C30  AC437384   SW V1, 29572(V0)
498:                 
499:                             PPU_MEM(addr) = value;
9D018C34  00101A82   SRL V1, S0, 10
9D018C38  24630448   ADDIU V1, V1, 1096
9D018C3C  00031880   SLL V1, V1, 2
9D018C40  3C02A000   LUI V0, -24576
9D018C44  24426220   ADDIU V0, V0, 25120
9D018C48  00621021   ADDU V0, V1, V0
9D018C4C  8C420000   LW V0, 0(V0)
9D018C50  00508021   ADDU S0, V0, S0
9D018C54  0B40632D   J 0x9D018CB4
9D018C58  A2050000   SB A1, 0(S0)
500:                          }
501:                       }
502:                       else
503:                       {
504:                          if (0 == (ppu.vaddr & 0x0F))
9D018C5C  5440000E   BNEL V0, ZERO, .LBE20
9D018C60  32020003   ANDI V0, S0, 3
505:                          {
506:                             int i;
507:                 
508:                             for (i = 0; i < 8; i ++)
9D018C78  24040008   ADDIU A0, ZERO, 8
9D018C84  24420001   ADDIU V0, V0, 1
9D018C88  1444FFFC   BNE V0, A0, 0x9D018C7C
9D018C8C  A0651100   SB A1, 4352(V1)
9D018C90  0B40632E   J 0x9D018CB8
9D018C94  3C02A000   LUI V0, -24576
509:                                ppu.palette[i << 2] = (value & 0x3F) | BG_TRANS;
9D018C64  3C06A000   LUI A2, -24576
9D018C68  24C66220   ADDIU A2, A2, 25120
9D018C6C  30A5003F   ANDI A1, A1, 63
9D018C70  2403FF80   ADDIU V1, ZERO, -128
9D018C74  00A32825   OR A1, A1, V1
9D018C7C  00021880   SLL V1, V0, 2
9D018C80  00661821   ADDU V1, V1, A2
510:                          }
511:                          else if (ppu.vaddr & 3)
9D018C98  10400007   BEQ V0, ZERO, 0x9D018CB8
9D018C9C  3C02A000   LUI V0, -24576
512:                          {
513:                             ppu.palette[ppu.vaddr & 0x1F] = value & 0x3F;
9D018CA0  3210001F   ANDI S0, S0, 31
9D018CA4  24426220   ADDIU V0, V0, 25120
9D018CA8  02021021   ADDU V0, S0, V0
9D018CAC  30A5003F   ANDI A1, A1, 63
9D018CB0  A0451100   SB A1, 4352(V0)
514:                          }
515:                       }
516:                 
517:                       ppu.vaddr += ppu.vaddr_inc;
9D018CBC  8C441174   LW A0, 4468(V0)
9D018CC0  8C431164   LW V1, 4452(V0)
9D018CC4  00831821   ADDU V1, A0, V1
518:                       ppu.vaddr &= 0x3FFF;
9D018CB4  3C02A000   LUI V0, -24576
9D018CB8  24426220   ADDIU V0, V0, 25120
9D018CC8  30633FFF   ANDI V1, V1, 16383
9D018CCC  AC431164   SW V1, 4452(V0)
519:                       break;
520:                 
521:                    default:
522:                       break;
523:                    }
524:                 }
9D018CD0  8FBF0014   LW RA, 20(SP)
9D018CD4  8FB00010   LW S0, 16(SP)
9D018CD8  27BD0018   ADDIU SP, SP, 24
9D018CDC  03E00008   JR RA
9D018CE0  00000000   NOP
525:                 
526:                 /* Builds a 256 color 8-bit palette based on a 64-color NES palette
527:                 ** Note that we set it up 3 times so that we flip bits on the primary
528:                 ** NES buffer for priorities
529:                 */
530:                 static void ppu_buildpalette(ppu_t *src_ppu, rgb_t *pal)
531:                 {
532:                    int i;
533:                 
534:                    /* Set it up 3 times, for sprite priority/BG transparency trickery */
535:                    for (i = 0; i < 64; i++)
9D018D24  14C0FFF1   BNE A2, ZERO, .LBB25, .LBB26
536:                    {
537:                       src_ppu->curpal[i].r = src_ppu->curpal[i + 64].r 
9D018CF8  AC43FA00   SW V1, -1536(V0)
538:                                            = src_ppu->curpal[i + 128].r = pal[i].r;
9D018CEC  8CA30000   LW V1, 0(A1)
539:                       src_ppu->curpal[i].g = src_ppu->curpal[i + 64].g
9D018D08  AC43FA04   SW V1, -1532(V0)
540:                                            = src_ppu->curpal[i + 128].g = pal[i].g;
9D018CFC  8CA30004   LW V1, 4(A1)
541:                       src_ppu->curpal[i].b = src_ppu->curpal[i + 64].b
9D018D18  AC43FA08   SW V1, -1528(V0)
542:                                            = src_ppu->curpal[i + 128].b = pal[i].b;
9D018D0C  8CA30008   LW V1, 8(A1)
543:                    }
544:                 
545:                    for (i = 0; i < GUI_TOTALCOLORS; i++)
9D018D58  1467FFF8   BNE V1, A3, 0x9D018D3C
546:                    {
547:                       src_ppu->curpal[i + 192].r = gui_pal[i].r;
9D018D3C  8C660000   LW A2, 0(V1)
548:                       src_ppu->curpal[i + 192].g = gui_pal[i].g;
9D018D44  8C660004   LW A2, 4(V1)
549:                       src_ppu->curpal[i + 192].b = gui_pal[i].b;
9D018D4C  8C660008   LW A2, 8(V1)
9D018D50  ACA61AB4   SW A2, 6836(A1)
9D018D54  2463000C   ADDIU V1, V1, 12
9D018D58  1467FFF8   BNE V1, A3, 0x9D018D3C
9D018D5C  24A5000C   ADDIU A1, A1, 12
550:                    }
551:                 }
552:                 
553:                 uint16 myPalette[256];
554:                 
555:                 /* copy nes palette over to hardware */
556:                 static void set_palette(rgb_t *pal)
557:                 {
558:                 	uint16 c;
559:                 
560:                    int i;
561:                 
562:                    for (i = 0; i < 256; i++)
9D018DA0  1466FFF3   BNE V1, A2, .LBB27, .LBB28
563:                    {
564:                       c=(pal[i].b>>3)+((pal[i].g>>2)<<5)+((pal[i].r>>3)<<11);
9D018D70  8C450004   LW A1, 4(V0)
565:                       //myPalette[i]=(c>>8)|((c&0xff)<<8);
566:                       myPalette[i]=c;
9D018D98  A4640000   SH A0, 0(V1)
9D018D9C  24630002   ADDIU V1, V1, 2
9D018DA0  1466FFF3   BNE V1, A2, .LBB27, .LBB28
9D018DA4  2442000C   ADDIU V0, V0, 12
567:                    }
568:                 
569:                 }
570:                 
571:                 /* build the emulator specific palette based on a 64-entry palette
572:                 ** input palette can be either nes_palette or a 64-entry RGB palette
573:                 ** read in from disk (i.e. for VS games)
574:                 */
575:                 void ppu_setpal(ppu_t *src_ppu, rgb_t *pal)
576:                 {
9D018CE4  248217AC   ADDIU V0, A0, 6060
9D018CE8  24060040   ADDIU A2, ZERO, 64
577:                    ppu_buildpalette(src_ppu, pal);
578:                    //vid_setpalette(src_ppu->curpal);
579:                    set_palette(src_ppu->curpal);
9D018D60  248211AC   ADDIU V0, A0, 4524
9D018D64  3C03A000   LUI V1, -24576
9D018D68  246303E0   ADDIU V1, V1, 992
9D018D6C  24660200   ADDIU A2, V1, 512
580:                 }
9D018DA8  03E00008   JR RA
9D018DAC  00000000   NOP
581:                 
582:                 void ppu_setdefaultpal(ppu_t *src_ppu)
583:                 {
9D018DB0  27BDFFE8   ADDIU SP, SP, -24
9D018DB4  AFBF0014   SW RA, 20(SP)
584:                    ppu_setpal(src_ppu, nes_palette);
9D018DB8  3C05A000   LUI A1, -24576
9D018DBC  0F406339   JAL ppu_setpal
9D018DC0  24A505E0   ADDIU A1, A1, 1504
585:                 }
9D018DC4  8FBF0014   LW RA, 20(SP)
9D018DC8  03E00008   JR RA
9D018DCC  27BD0018   ADDIU SP, SP, 24
586:                 
587:                 void ppu_setlatchfunc(ppulatchfunc_t func)
588:                 {
589:                    ppu.latchfunc = func;
9D018E44  3C02A000   LUI V0, -24576
9D018E48  03E00008   JR RA
9D018E4C  AC4473C4   SW A0, 29636(V0)
590:                 }
591:                 
592:                 void ppu_setvromswitch(ppuvromswitch_t func)
593:                 {
594:                    ppu.vromswitch = func;
9D018E50  3C02A000   LUI V0, -24576
9D018E54  03E00008   JR RA
9D018E58  AC4473C8   SW A0, 29640(V0)
595:                 }
596:                 
597:                 /* rendering routines */
598:                 INLINE void draw_bgtile(uint8 *surface, uint8 pat1, uint8 pat2, 
599:                                         const uint8 *colors)
600:                 {
601:                    uint32 pattern = ((pat2 & 0xAA) << 8) | ((pat2 & 0x55) << 1)
9D019114  2416FFAA   ADDIU S6, ZERO, -86
9D019168  00B61824   AND V1, A1, S6
9D01916C  00031A00   SLL V1, V1, 8
9D019170  30A50055   ANDI A1, A1, 85
9D019174  00052840   SLL A1, A1, 1
9D019178  00651825   OR V1, V1, A1
9D019C2C  240DFFAA   ADDIU T5, ZERO, -86
9D019DA8  006DA824   AND S5, V1, T5
9D019DAC  0015AA00   SLL S5, S5, 8
9D019DB0  30630055   ANDI V1, V1, 85
9D019DB4  00031840   SLL V1, V1, 1
9D019DB8  02A3A825   OR S5, S5, V1
9D019F7C  240BFFAA   ADDIU T3, ZERO, -86
9D019FC4  014B1824   AND V1, T2, T3
9D019FC8  00031A00   SLL V1, V1, 8
9D019FCC  314A0055   ANDI T2, T2, 85
9D019FD0  000A5040   SLL T2, T2, 1
9D019FD4  006A1825   OR V1, V1, T2
602:                                     | ((pat1 & 0xAA) << 7) | (pat1 & 0x55);
9D01917C  30860055   ANDI A2, A0, 85
9D019180  00661825   OR V1, V1, A2
9D019184  00962024   AND A0, A0, S6
9D019188  000421C0   SLL A0, A0, 7
9D01918C  00641825   OR V1, V1, A0
9D019DBC  32630055   ANDI V1, S3, 85
9D019DC0  02A31825   OR V1, S5, V1
9D019DC4  026D9824   AND S3, S3, T5
9D019DC8  001399C0   SLL S3, S3, 7
9D019DCC  00731825   OR V1, V1, S3
9D019FD8  31320055   ANDI S2, T1, 85
9D019FDC  00721825   OR V1, V1, S2
9D019FE0  012B4824   AND T1, T1, T3
9D019FE4  000949C0   SLL T1, T1, 7
9D019FE8  00691825   OR V1, V1, T1
603:                    
604:                    *surface++ = colors[(pattern >> 14) & 3];
9D019190  00032382   SRL A0, V1, 14
9D019194  00442021   ADDU A0, V0, A0
9D019198  90840000   LBU A0, 0(A0)
9D01919C  A2040000   SB A0, 0(S0)
9D019DD0  00039B82   SRL S3, V1, 14
9D019DD4  00F39821   ADDU S3, A3, S3
9D019DD8  92730000   LBU S3, 0(S3)
9D019DDC  A0530000   SB S3, 0(V0)
9D019FEC  00034B82   SRL T1, V1, 14
9D019FF0  00E94821   ADDU T1, A3, T1
9D019FF4  91290000   LBU T1, 0(T1)
9D019FF8  A0490000   SB T1, 0(V0)
605:                    *surface++ = colors[(pattern >> 6) & 3];
9D0191A0  7C640980   EXT A0, V1, 6, 2
9D0191A4  00442021   ADDU A0, V0, A0
9D0191A8  90840000   LBU A0, 0(A0)
9D0191AC  A2040001   SB A0, 1(S0)
9D019DE0  7C730980   EXT S3, V1, 6, 2
9D019DE4  00F39821   ADDU S3, A3, S3
9D019DE8  92730000   LBU S3, 0(S3)
9D019DEC  A0530001   SB S3, 1(V0)
9D019FFC  7C690980   EXT T1, V1, 6, 2
9D01A000  00E94821   ADDU T1, A3, T1
9D01A004  91290000   LBU T1, 0(T1)
9D01A008  A0490001   SB T1, 1(V0)
606:                    *surface++ = colors[(pattern >> 12) & 3];
9D0191B0  7C640B00   EXT A0, V1, 12, 2
9D0191B4  00442021   ADDU A0, V0, A0
9D0191B8  90840000   LBU A0, 0(A0)
9D0191BC  A2040002   SB A0, 2(S0)
9D019DF0  7C730B00   EXT S3, V1, 12, 2
9D019DF4  00F39821   ADDU S3, A3, S3
9D019DF8  92730000   LBU S3, 0(S3)
9D019DFC  A0530002   SB S3, 2(V0)
9D01A00C  7C690B00   EXT T1, V1, 12, 2
9D01A010  00E94821   ADDU T1, A3, T1
9D01A014  91290000   LBU T1, 0(T1)
9D01A018  A0490002   SB T1, 2(V0)
607:                    *surface++ = colors[(pattern >> 4) & 3];
9D0191C0  7C640900   EXT A0, V1, 4, 2
9D0191C4  00442021   ADDU A0, V0, A0
9D0191C8  90840000   LBU A0, 0(A0)
9D0191CC  A2040003   SB A0, 3(S0)
9D019E00  7C730900   EXT S3, V1, 4, 2
9D019E04  00F39821   ADDU S3, A3, S3
9D019E08  92730000   LBU S3, 0(S3)
9D019E0C  A0530003   SB S3, 3(V0)
9D01A01C  7C690900   EXT T1, V1, 4, 2
9D01A020  00E94821   ADDU T1, A3, T1
9D01A024  91290000   LBU T1, 0(T1)
9D01A028  A0490003   SB T1, 3(V0)
608:                    *surface++ = colors[(pattern >> 10) & 3];
9D0191D0  7C640A80   EXT A0, V1, 10, 2
9D0191D4  00442021   ADDU A0, V0, A0
9D0191D8  90840000   LBU A0, 0(A0)
9D0191DC  A2040004   SB A0, 4(S0)
9D019E10  7C730A80   EXT S3, V1, 10, 2
9D019E14  00F39821   ADDU S3, A3, S3
9D019E18  92730000   LBU S3, 0(S3)
9D019E1C  A0530004   SB S3, 4(V0)
9D01A02C  7C690A80   EXT T1, V1, 10, 2
9D01A030  00E94821   ADDU T1, A3, T1
9D01A034  91290000   LBU T1, 0(T1)
9D01A038  A0490004   SB T1, 4(V0)
609:                    *surface++ = colors[(pattern >> 2) & 3];
9D0191E0  7C640880   EXT A0, V1, 2, 2
9D0191E4  00442021   ADDU A0, V0, A0
9D0191E8  90840000   LBU A0, 0(A0)
9D0191EC  A2040005   SB A0, 5(S0)
9D019E20  7C730880   EXT S3, V1, 2, 2
9D019E24  00F39821   ADDU S3, A3, S3
9D019E28  92730000   LBU S3, 0(S3)
9D019E2C  A0530005   SB S3, 5(V0)
9D01A03C  7C690880   EXT T1, V1, 2, 2
9D01A040  00E94821   ADDU T1, A3, T1
9D01A044  91290000   LBU T1, 0(T1)
9D01A048  A0490005   SB T1, 5(V0)
610:                    *surface++ = colors[(pattern >> 8) & 3];
9D0191F0  7C640A00   EXT A0, V1, 8, 2
9D0191F4  00442021   ADDU A0, V0, A0
9D0191F8  90840000   LBU A0, 0(A0)
9D0191FC  A2040006   SB A0, 6(S0)
9D019E30  7C730A00   EXT S3, V1, 8, 2
9D019E34  00F39821   ADDU S3, A3, S3
9D019E38  92730000   LBU S3, 0(S3)
9D019E3C  A0530006   SB S3, 6(V0)
9D01A04C  7C690A00   EXT T1, V1, 8, 2
9D01A050  00E94821   ADDU T1, A3, T1
9D01A054  91290000   LBU T1, 0(T1)
9D01A058  A0490006   SB T1, 6(V0)
611:                    *surface = colors[pattern & 3];
9D019200  30630003   ANDI V1, V1, 3
9D019204  00431021   ADDU V0, V0, V1
9D019208  90420000   LBU V0, 0(V0)
9D01920C  A2020007   SB V0, 7(S0)
9D019E40  30630003   ANDI V1, V1, 3
9D019E44  00E31821   ADDU V1, A3, V1
9D019E48  90630000   LBU V1, 0(V1)
9D019E4C  A0430007   SB V1, 7(V0)
9D01A05C  30630003   ANDI V1, V1, 3
9D01A060  00E31821   ADDU V1, A3, V1
9D01A064  90630000   LBU V1, 0(V1)
9D01A068  A0430007   SB V1, 7(V0)
612:                 }
613:                 
614:                 INLINE int draw_oamtile(uint8 *surface, uint8 attrib, uint8 pat1, 
615:                                         uint8 pat2, const uint8 *col_tbl, bool check_strike)
616:                 {
617:                    int strike_pixel = -1;
9D0195CC  29AD0000   SLTI T5, T5, 0
9D0195D0  2402FFFF   ADDIU V0, ZERO, -1
9D0195D4  24040007   ADDIU A0, ZERO, 7
9D0195D8  004D200B   MOVN A0, V0, T5
618:                    uint32 color = ((pat2 & 0xAA) << 8) | ((pat2 & 0x55) << 1)
9D0194AC  2403FFAA   ADDIU V1, ZERO, -86
9D0194B0  00433024   AND A2, V0, V1
9D0194B4  00063200   SLL A2, A2, 8
9D0194B8  30420055   ANDI V0, V0, 85
9D0194BC  00021040   SLL V0, V0, 1
9D0194C0  00C23025   OR A2, A2, V0
619:                                   | ((pat1 & 0xAA) << 7) | (pat1 & 0x55);
9D0194C4  30820055   ANDI V0, A0, 85
9D0194C8  00C23025   OR A2, A2, V0
9D0194CC  00831024   AND V0, A0, V1
9D0194D0  000211C0   SLL V0, V0, 7
9D0194D4  00C21025   OR V0, A2, V0
620:                 
621:                    /* sprite is not 100% transparent */
622:                    if (color)
9D0194D8  104000F1   BEQ V0, ZERO, .LVL301
9D0194DC  32E30040   ANDI V1, S7, 64
623:                    {
624:                       uint8 colors[8];
625:                 
626:                       /* swap pixels around if our tile is flipped */
627:                       if (0 == (attrib & OAMF_HFLIP))
9D0194E0  306300FF   ANDI V1, V1, 255
9D0194E4  5460000A   BNEL V1, ZERO, 0x9D019510
9D0194E8  00026382   SRL T4, V0, 14
628:                       {
629:                          colors[0] = (color >> 14) & 3;
9D0194EC  00021B82   SRL V1, V0, 14
630:                          colors[1] = (color >> 6) & 3;
9D0194F0  7C460980   EXT A2, V0, 6, 2
631:                          colors[2] = (color >> 12) & 3;
9D0194F4  7C470B00   EXT A3, V0, 12, 2
632:                          colors[3] = (color >> 4) & 3;
9D0194F8  7C480900   EXT T0, V0, 4, 2
633:                          colors[4] = (color >> 10) & 3;
9D0194FC  7C490A80   EXT T1, V0, 10, 2
634:                          colors[5] = (color >> 2) & 3;
9D019500  7C4A0880   EXT T2, V0, 2, 2
635:                          colors[6] = (color >> 8) & 3;
9D019504  7C4B0A00   EXT T3, V0, 8, 2
636:                          colors[7] = color & 3;
9D019508  0B40654B   J 0x9D01952C
9D01950C  304C0003   ANDI T4, V0, 3
637:                       }
638:                       else
639:                       {
640:                          colors[7] = (color >> 14) & 3;
641:                          colors[6] = (color >> 6) & 3;
9D019510  7C4B0980   EXT T3, V0, 6, 2
642:                          colors[5] = (color >> 12) & 3;
9D019514  7C4A0B00   EXT T2, V0, 12, 2
643:                          colors[4] = (color >> 4) & 3;
9D019518  7C490900   EXT T1, V0, 4, 2
644:                          colors[3] = (color >> 10) & 3;
9D01951C  7C480A80   EXT T0, V0, 10, 2
645:                          colors[2] = (color >> 2) & 3;
9D019520  7C470880   EXT A3, V0, 2, 2
646:                          colors[1] = (color >> 8) & 3;
9D019524  7C460A00   EXT A2, V0, 8, 2
647:                          colors[0] = color & 3;
9D019528  30430003   ANDI V1, V0, 3
648:                       }
649:                 
650:                       /* check for solid sprite pixel overlapping solid bg pixel */
651:                       if (check_strike)
9D01952C  11A0002B   BEQ T5, ZERO, 0x9D0195DC
9D019530  2404FFFF   ADDIU A0, ZERO, -1
652:                       {
653:                          if (colors[0] && BG_SOLID(surface[0]))
9D019534  10600004   BEQ V1, ZERO, 0x9D019548
9D019538  00000000   NOP
9D01953C  82C20000   LB V0, 0(S6)
9D019540  04410195   BGEZ V0, 0x9D019B98
9D019544  32E20020   ANDI V0, S7, 32
654:                             strike_pixel = 0;
655:                          else if (colors[1] && BG_SOLID(surface[1]))
9D019548  10C00004   BEQ A2, ZERO, 0x9D01955C
9D01954C  00000000   NOP
9D019550  82C20001   LB V0, 1(S6)
9D019554  04410021   BGEZ V0, 0x9D0195DC
9D019558  24040001   ADDIU A0, ZERO, 1
656:                             strike_pixel = 1;
657:                          else if (colors[2] && BG_SOLID(surface[2]))
9D01955C  10E00004   BEQ A3, ZERO, 0x9D019570
9D019560  00000000   NOP
9D019564  82C20002   LB V0, 2(S6)
9D019568  0441001C   BGEZ V0, 0x9D0195DC
9D01956C  24040002   ADDIU A0, ZERO, 2
658:                             strike_pixel = 2;
659:                          else if (colors[3] && BG_SOLID(surface[3]))
9D019570  11000004   BEQ T0, ZERO, 0x9D019584
9D019574  00000000   NOP
9D019578  82C20003   LB V0, 3(S6)
9D01957C  04410017   BGEZ V0, 0x9D0195DC
9D019580  24040003   ADDIU A0, ZERO, 3
660:                             strike_pixel = 3;
661:                          else if (colors[4] && BG_SOLID(surface[4]))
9D019584  11200004   BEQ T1, ZERO, 0x9D019598
9D019588  00000000   NOP
9D01958C  82C20004   LB V0, 4(S6)
9D019590  04410012   BGEZ V0, 0x9D0195DC
9D019594  24040004   ADDIU A0, ZERO, 4
662:                             strike_pixel = 4;
663:                          else if (colors[5] && BG_SOLID(surface[5]))
9D019598  11400004   BEQ T2, ZERO, 0x9D0195AC
9D01959C  00000000   NOP
9D0195A0  82C20005   LB V0, 5(S6)
9D0195A4  0441000D   BGEZ V0, 0x9D0195DC
9D0195A8  24040005   ADDIU A0, ZERO, 5
664:                             strike_pixel = 5;
665:                          else if (colors[6] && BG_SOLID(surface[6]))
9D0195AC  11600004   BEQ T3, ZERO, 0x9D0195C0
9D0195B0  00000000   NOP
9D0195B4  82C20006   LB V0, 6(S6)
9D0195B8  04410008   BGEZ V0, 0x9D0195DC
9D0195BC  24040006   ADDIU A0, ZERO, 6
666:                             strike_pixel = 6;
667:                          else if (colors[7] && BG_SOLID(surface[7]))
9D0195C0  11800006   BEQ T4, ZERO, 0x9D0195DC
9D0195C4  2404FFFF   ADDIU A0, ZERO, -1
9D0195C8  82CD0007   LB T5, 7(S6)
668:                             strike_pixel = 7;
669:                       }
670:                 
671:                       /* draw the character */
672:                       if (attrib & OAMF_BEHIND)
9D0195DC  32E20020   ANDI V0, S7, 32
9D0195E0  304200FF   ANDI V0, V0, 255
9D0195E4  1040005A   BEQ V0, ZERO, 0x9D019750
9D0195E8  00000000   NOP
9D019B98  304200FF   ANDI V0, V0, 255
9D019B9C  1040FEEE   BEQ V0, ZERO, 0x9D019758
9D019BA0  00002021   ADDU A0, ZERO, ZERO
673:                       {
674:                          if (colors[0])
9D0195EC  1060000A   BEQ V1, ZERO, 0x9D019618
9D0195F0  00000000   NOP
9D0195F4  92C20000   LBU V0, 0(S6)
675:                             surface[0] = SP_PIXEL | (BG_CLEAR(surface[0]) ? col_tbl[colors[0]] : surface[0]);
9D0195F8  7C026C20   SEB T5, V0
9D0195FC  05A10005   BGEZ T5, 0x9D019614
9D019600  34420040   ORI V0, V0, 64
9D019604  00A31821   ADDU V1, A1, V1
9D019608  90620000   LBU V0, 0(V1)
9D01960C  34420040   ORI V0, V0, 64
9D019610  304200FF   ANDI V0, V0, 255
9D019614  A2C20000   SB V0, 0(S6)
9D019BA4  0B40657E   J 0x9D0195F8
9D019BA8  92C20000   LBU V0, 0(S6)
676:                          if (colors[1])
9D019618  10C0000A   BEQ A2, ZERO, 0x9D019644
9D01961C  00000000   NOP
677:                             surface[1] = SP_PIXEL | (BG_CLEAR(surface[1]) ? col_tbl[colors[1]] : surface[1]);
9D019620  92C20001   LBU V0, 1(S6)
9D019624  7C021C20   SEB V1, V0
9D019628  04610005   BGEZ V1, 0x9D019640
9D01962C  34420040   ORI V0, V0, 64
9D019630  00A63021   ADDU A2, A1, A2
9D019634  90C20000   LBU V0, 0(A2)
9D019638  34420040   ORI V0, V0, 64
9D01963C  304200FF   ANDI V0, V0, 255
9D019640  A2C20001   SB V0, 1(S6)
678:                          if (colors[2])
9D019644  10E0000A   BEQ A3, ZERO, 0x9D019670
9D019648  00000000   NOP
679:                             surface[2] = SP_PIXEL | (BG_CLEAR(surface[2]) ? col_tbl[colors[2]] : surface[2]);
9D01964C  92C20002   LBU V0, 2(S6)
9D019650  7C021C20   SEB V1, V0
9D019654  04610005   BGEZ V1, 0x9D01966C
9D019658  34420040   ORI V0, V0, 64
9D01965C  00A73821   ADDU A3, A1, A3
9D019660  90E20000   LBU V0, 0(A3)
9D019664  34420040   ORI V0, V0, 64
9D019668  304200FF   ANDI V0, V0, 255
9D01966C  A2C20002   SB V0, 2(S6)
680:                          if (colors[3])
9D019670  1100000A   BEQ T0, ZERO, 0x9D01969C
9D019674  00000000   NOP
681:                             surface[3] = SP_PIXEL | (BG_CLEAR(surface[3]) ? col_tbl[colors[3]] : surface[3]);
9D019678  92C20003   LBU V0, 3(S6)
9D01967C  7C021C20   SEB V1, V0
9D019680  04610005   BGEZ V1, 0x9D019698
9D019684  34420040   ORI V0, V0, 64
9D019688  00A84021   ADDU T0, A1, T0
9D01968C  91020000   LBU V0, 0(T0)
9D019690  34420040   ORI V0, V0, 64
9D019694  304200FF   ANDI V0, V0, 255
9D019698  A2C20003   SB V0, 3(S6)
682:                          if (colors[4])
9D01969C  1120000A   BEQ T1, ZERO, 0x9D0196C8
9D0196A0  00000000   NOP
683:                             surface[4] = SP_PIXEL | (BG_CLEAR(surface[4]) ? col_tbl[colors[4]] : surface[4]);
9D0196A4  92C20004   LBU V0, 4(S6)
9D0196A8  7C021C20   SEB V1, V0
9D0196AC  04610005   BGEZ V1, 0x9D0196C4
9D0196B0  34420040   ORI V0, V0, 64
9D0196B4  00A94821   ADDU T1, A1, T1
9D0196B8  91220000   LBU V0, 0(T1)
9D0196BC  34420040   ORI V0, V0, 64
9D0196C0  304200FF   ANDI V0, V0, 255
9D0196C4  A2C20004   SB V0, 4(S6)
684:                          if (colors[5])
9D0196C8  1140000A   BEQ T2, ZERO, 0x9D0196F4
9D0196CC  00000000   NOP
685:                             surface[5] = SP_PIXEL | (BG_CLEAR(surface[5]) ? col_tbl[colors[5]] : surface[5]);
9D0196D0  92C20005   LBU V0, 5(S6)
9D0196D4  7C021C20   SEB V1, V0
9D0196D8  04610005   BGEZ V1, 0x9D0196F0
9D0196DC  34420040   ORI V0, V0, 64
9D0196E0  00AA5021   ADDU T2, A1, T2
9D0196E4  91420000   LBU V0, 0(T2)
9D0196E8  34420040   ORI V0, V0, 64
9D0196EC  304200FF   ANDI V0, V0, 255
9D0196F0  A2C20005   SB V0, 5(S6)
686:                          if (colors[6])
9D0196F4  1160000A   BEQ T3, ZERO, 0x9D019720
9D0196F8  00000000   NOP
687:                             surface[6] = SP_PIXEL | (BG_CLEAR(surface[6]) ? col_tbl[colors[6]] : surface[6]);
9D0196FC  92C20006   LBU V0, 6(S6)
9D019700  7C021C20   SEB V1, V0
9D019704  04610005   BGEZ V1, 0x9D01971C
9D019708  34420040   ORI V0, V0, 64
9D01970C  00AB5821   ADDU T3, A1, T3
9D019710  91620000   LBU V0, 0(T3)
9D019714  34420040   ORI V0, V0, 64
9D019718  304200FF   ANDI V0, V0, 255
9D01971C  A2C20006   SB V0, 6(S6)
688:                          if (colors[7])
9D019720  1180005B   BEQ T4, ZERO, 0x9D019890
9D019724  00000000   NOP
689:                             surface[7] = SP_PIXEL | (BG_CLEAR(surface[7]) ? col_tbl[colors[7]] : surface[7]);
9D019728  92C20007   LBU V0, 7(S6)
9D01972C  7C021C20   SEB V1, V0
9D019730  04610005   BGEZ V1, 0x9D019748
9D019734  34420040   ORI V0, V0, 64
9D019738  00AC2821   ADDU A1, A1, T4
9D01973C  90A20000   LBU V0, 0(A1)
9D019740  34420040   ORI V0, V0, 64
9D019744  304200FF   ANDI V0, V0, 255
9D019748  0B406624   J 0x9D019890
9D01974C  A2C20007   SB V0, 7(S6)
690:                       }
691:                       else
692:                       {
693:                          if (colors[0] && SP_CLEAR(surface[0]))
9D019750  10600009   BEQ V1, ZERO, 0x9D019778
9D019754  00000000   NOP
9D019758  92C20000   LBU V0, 0(S6)
9D01975C  30420040   ANDI V0, V0, 64
9D019760  304200FF   ANDI V0, V0, 255
9D019764  14400004   BNE V0, ZERO, 0x9D019778
9D019768  00A31821   ADDU V1, A1, V1
694:                             surface[0] = SP_PIXEL | col_tbl[colors[0]];
9D01976C  90620000   LBU V0, 0(V1)
9D019770  34420040   ORI V0, V0, 64
9D019774  A2C20000   SB V0, 0(S6)
695:                          if (colors[1] && SP_CLEAR(surface[1]))
9D019778  10C00009   BEQ A2, ZERO, 0x9D0197A0
9D01977C  00000000   NOP
9D019780  92C20001   LBU V0, 1(S6)
9D019784  30420040   ANDI V0, V0, 64
9D019788  304200FF   ANDI V0, V0, 255
9D01978C  14400004   BNE V0, ZERO, 0x9D0197A0
9D019790  00A63021   ADDU A2, A1, A2
696:                             surface[1] = SP_PIXEL | col_tbl[colors[1]];
9D019794  90C20000   LBU V0, 0(A2)
9D019798  34420040   ORI V0, V0, 64
9D01979C  A2C20001   SB V0, 1(S6)
697:                          if (colors[2] && SP_CLEAR(surface[2]))
9D0197A0  10E00009   BEQ A3, ZERO, 0x9D0197C8
9D0197A4  00000000   NOP
9D0197A8  92C20002   LBU V0, 2(S6)
9D0197AC  30420040   ANDI V0, V0, 64
9D0197B0  304200FF   ANDI V0, V0, 255
9D0197B4  14400004   BNE V0, ZERO, 0x9D0197C8
9D0197B8  00A73821   ADDU A3, A1, A3
698:                             surface[2] = SP_PIXEL | col_tbl[colors[2]];
9D0197BC  90E20000   LBU V0, 0(A3)
9D0197C0  34420040   ORI V0, V0, 64
9D0197C4  A2C20002   SB V0, 2(S6)
699:                          if (colors[3] && SP_CLEAR(surface[3]))
9D0197C8  11000009   BEQ T0, ZERO, 0x9D0197F0
9D0197CC  00000000   NOP
9D0197D0  92C20003   LBU V0, 3(S6)
9D0197D4  30420040   ANDI V0, V0, 64
9D0197D8  304200FF   ANDI V0, V0, 255
9D0197DC  14400004   BNE V0, ZERO, 0x9D0197F0
9D0197E0  00A84021   ADDU T0, A1, T0
700:                             surface[3] = SP_PIXEL | col_tbl[colors[3]];
9D0197E4  91020000   LBU V0, 0(T0)
9D0197E8  34420040   ORI V0, V0, 64
9D0197EC  A2C20003   SB V0, 3(S6)
701:                          if (colors[4] && SP_CLEAR(surface[4]))
9D0197F0  11200009   BEQ T1, ZERO, 0x9D019818
9D0197F4  00000000   NOP
9D0197F8  92C20004   LBU V0, 4(S6)
9D0197FC  30420040   ANDI V0, V0, 64
9D019800  304200FF   ANDI V0, V0, 255
9D019804  14400004   BNE V0, ZERO, 0x9D019818
9D019808  00A94821   ADDU T1, A1, T1
702:                             surface[4] = SP_PIXEL | col_tbl[colors[4]];
9D01980C  91220000   LBU V0, 0(T1)
9D019810  34420040   ORI V0, V0, 64
9D019814  A2C20004   SB V0, 4(S6)
703:                          if (colors[5] && SP_CLEAR(surface[5]))
9D019818  11400009   BEQ T2, ZERO, 0x9D019840
9D01981C  00000000   NOP
9D019820  92C20005   LBU V0, 5(S6)
9D019824  30420040   ANDI V0, V0, 64
9D019828  304200FF   ANDI V0, V0, 255
9D01982C  14400004   BNE V0, ZERO, 0x9D019840
9D019830  00AA5021   ADDU T2, A1, T2
704:                             surface[5] = SP_PIXEL | col_tbl[colors[5]];
9D019834  91420000   LBU V0, 0(T2)
9D019838  34420040   ORI V0, V0, 64
9D01983C  A2C20005   SB V0, 5(S6)
705:                          if (colors[6] && SP_CLEAR(surface[6]))
9D019840  11600009   BEQ T3, ZERO, 0x9D019868
9D019844  00000000   NOP
9D019848  92C20006   LBU V0, 6(S6)
9D01984C  30420040   ANDI V0, V0, 64
9D019850  304200FF   ANDI V0, V0, 255
9D019854  14400004   BNE V0, ZERO, 0x9D019868
9D019858  00AB5821   ADDU T3, A1, T3
706:                             surface[6] = SP_PIXEL | col_tbl[colors[6]];
9D01985C  91620000   LBU V0, 0(T3)
9D019860  34420040   ORI V0, V0, 64
9D019864  A2C20006   SB V0, 6(S6)
707:                          if (colors[7] && SP_CLEAR(surface[7]))
9D019868  11800009   BEQ T4, ZERO, 0x9D019890
9D01986C  00000000   NOP
9D019870  92C20007   LBU V0, 7(S6)
9D019874  30420040   ANDI V0, V0, 64
9D019878  304200FF   ANDI V0, V0, 255
9D01987C  14400004   BNE V0, ZERO, 0x9D019890
9D019880  00AC2821   ADDU A1, A1, T4
708:                             surface[7] = SP_PIXEL | col_tbl[colors[7]];
9D019884  90A20000   LBU V0, 0(A1)
9D019888  34420040   ORI V0, V0, 64
9D01988C  A2C20007   SB V0, 7(S6)
709:                       }
710:                    }
711:                 
712:                    return strike_pixel;
713:                 }
714:                 
715:                 static void ppu_renderbg(uint8 *vidbuf)
716:                 {
717:                    uint8 *bmp_ptr, *data_ptr, *tile_ptr, *attrib_ptr;
718:                    uint32 refresh_vaddr, bg_offset, attrib_base;
719:                    int tile_count;
720:                    uint8 tile_index, x_tile, y_tile;
721:                    uint8 col_high, attrib, attrib_shift;
722:                 
723:                    /* draw a line of transparent background color if bg is disabled */
724:                    if (false == ppu.bg_on)
9D019014  1440000A   BNE V0, ZERO, 0x9D019040
9D019018  3C03A000   LUI V1, -24576
725:                    {
726:                       memset(vidbuf, FULLBG, NES_SCREEN_WIDTH);
9D01901C  3C02A000   LUI V0, -24576
9D019020  90457320   LBU A1, 29472(V0)
9D019024  30A5007F   ANDI A1, A1, 127
9D019028  8FA40028   LW A0, 40(SP)
9D01902C  34A50080   ORI A1, A1, 128
9D019030  0F40E7C9   JAL .Letext0, .LFE0, memset
9D019034  24060100   ADDIU A2, ZERO, 256
9D019B90  0B406408   J 0x9D019020
9D019B94  3C02A000   LUI V0, -24576
727:                       return;
728:                    }
729:                 
730:                    bmp_ptr = vidbuf - ppu.tile_xofs; /* scroll x */
9D019040  24636220   ADDIU V1, V1, 25120
9D019044  8C70116C   LW S0, 4460(V1)
9D019048  8FA60028   LW A2, 40(SP)
9D01904C  00D08023   SUBU S0, A2, S0
731:                    refresh_vaddr = 0x2000 + (ppu.vaddr & 0x0FE0); /* mask out x tile */
9D019050  8C621164   LW V0, 4452(V1)
9D019054  30440FE0   ANDI A0, V0, 4064
9D019058  24842000   ADDIU A0, A0, 8192
9D01905C  AFA40020   SW A0, 32(SP)
732:                    x_tile = ppu.vaddr & 0x1F;
9D019060  304400FF   ANDI A0, V0, 255
9D019064  3091001F   ANDI S1, A0, 31
733:                    y_tile = (ppu.vaddr >> 5) & 0x1F; /* to simplify calculations */
9D019068  7C453940   EXT A1, V0, 5, 8
734:                    bg_offset = ((ppu.vaddr >> 12) & 7) + ppu.bg_base; /* offset in y tile */
9D01906C  7C421300   EXT V0, V0, 12, 3
9D019070  8C661184   LW A2, 4484(V1)
9D019074  00463021   ADDU A2, V0, A2
9D019078  AFA60010   SW A2, 16(SP)
735:                 
736:                    /* calculate initial values */
737:                    tile_ptr = &PPU_MEM(refresh_vaddr + x_tile); /* pointer to tile index */
9D01907C  8FA70020   LW A3, 32(SP)
9D019080  02271021   ADDU V0, S1, A3
9D019084  00023282   SRL A2, V0, 10
9D019088  24C60448   ADDIU A2, A2, 1096
9D01908C  00063080   SLL A2, A2, 2
9D019090  00C33021   ADDU A2, A2, V1
9D019094  8CC60000   LW A2, 0(A2)
9D019098  00C21021   ADDU V0, A2, V0
738:                    attrib_base = (refresh_vaddr & 0x2C00) + 0x3C0 + ((y_tile & 0x1C) << 1);
9D01909C  30E72C00   ANDI A3, A3, 11264
9D0190A0  24E703C0   ADDIU A3, A3, 960
9D0190A4  30A6001C   ANDI A2, A1, 28
9D0190A8  00063040   SLL A2, A2, 1
9D0190AC  00E63021   ADDU A2, A3, A2
9D0190B0  AFA60024   SW A2, 36(SP)
739:                    attrib_ptr = &PPU_MEM(attrib_base + (x_tile >> 2));
9D0190B4  00113082   SRL A2, S1, 2
9D0190B8  8FA70024   LW A3, 36(SP)
9D0190BC  00E63021   ADDU A2, A3, A2
9D0190C0  00063A82   SRL A3, A2, 10
9D0190C4  24E70448   ADDIU A3, A3, 1096
9D0190C8  00073880   SLL A3, A3, 2
9D0190CC  00E31821   ADDU V1, A3, V1
9D0190D0  8C630000   LW V1, 0(V1)
9D0190D4  00661821   ADDU V1, V1, A2
740:                    attrib = *attrib_ptr++;
9D0190D8  24660001   ADDIU A2, V1, 1
9D0190DC  AFA60018   SW A2, 24(SP)
9D0190E0  90630000   LBU V1, 0(V1)
9D0190E4  AFA3001C   SW V1, 28(SP)
741:                    attrib_shift = (x_tile & 2) + ((y_tile & 2) << 1);
9D0190E8  30B70002   ANDI S7, A1, 2
9D0190EC  0017B840   SLL S7, S7, 1
9D0190F0  30840002   ANDI A0, A0, 2
9D0190F4  02E4B821   ADDU S7, S7, A0
742:                    col_high = ((attrib >> attrib_shift) & 3) << 2;
9D0190F8  02E3F007   SRAV FP, V1, S7
9D0190FC  33DE0003   ANDI FP, FP, 3
9D019100  001EF080   SLL FP, FP, 2
9D019104  26070108   ADDIU A3, S0, 264
9D019108  AFA70014   SW A3, 20(SP)
743:                 
744:                    /* ppu fetches 33 tiles */
745:                    tile_count = 33;
746:                    while (tile_count--)
9D0192B8  8FA70014   LW A3, 20(SP)
9D0192BC  1607FF96   BNE S0, A3, 0x9D019118
9D0192C0  02A01021   ADDU V0, S5, ZERO
747:                    {
748:                       /* Tile number from nametable */
749:                       tile_index = *tile_ptr++;
9D019118  24550001   ADDIU S5, V0, 1
9D01911C  90450000   LBU A1, 0(V0)
750:                       data_ptr = &PPU_MEM(bg_offset + (tile_index << 4));
9D01910C  3C12A000   LUI S2, -24576
9D019110  26526220   ADDIU S2, S2, 25120
9D019120  00059900   SLL S3, A1, 4
9D019124  8FA20010   LW V0, 16(SP)
9D019128  02629821   ADDU S3, S3, V0
9D01912C  00131282   SRL V0, S3, 10
9D019130  24420448   ADDIU V0, V0, 1096
9D019134  00021080   SLL V0, V0, 2
9D019138  00521021   ADDU V0, V0, S2
9D01913C  8C420000   LW V0, 0(V0)
9D019140  00539821   ADDU S3, V0, S3
751:                 
752:                       /* Handle $FD/$FE tile VROM switching (PunchOut) */
753:                       if (ppu.latchfunc)
9D019144  8E4211A4   LW V0, 4516(S2)
9D019148  50400004   BEQL V0, ZERO, 0x9D01915C
9D01914C  92640000   LBU A0, 0(S3)
754:                          ppu.latchfunc(ppu.bg_base, tile_index);
9D019150  0040F809   JALR V0
9D019154  8E441184   LW A0, 4484(S2)
755:                 
756:                       draw_bgtile(bmp_ptr, data_ptr[0], data_ptr[8], ppu.palette + col_high);
9D019158  92640000   LBU A0, 0(S3)
9D01915C  92650008   LBU A1, 8(S3)
9D019160  27C21100   ADDIU V0, FP, 4352
9D019164  02421021   ADDU V0, S2, V0
757:                       bmp_ptr += 8;
758:                 
759:                       x_tile++;
9D019210  26310001   ADDIU S1, S1, 1
9D019214  323100FF   ANDI S1, S1, 255
760:                 
761:                       if (0 == (x_tile & 1))     /* check every 2 tiles */
9D019218  32220001   ANDI V0, S1, 1
9D01921C  14400026   BNE V0, ZERO, 0x9D0192B8
9D019220  26100008   ADDIU S0, S0, 8
762:                       {
763:                          if (0 == (x_tile & 3))  /* check every 4 tiles */
9D019224  32220003   ANDI V0, S1, 3
9D019228  5440001F   BNEL V0, ZERO, 0x9D0192A8
9D01922C  3AF70002   XORI S7, S7, 2
764:                          {
765:                             if (32 == x_tile)    /* check every 32 tiles */
9D019230  24030020   ADDIU V1, ZERO, 32
9D019234  16230016   BNE S1, V1, 0x9D019290
9D019238  8FA20018   LW V0, 24(SP)
766:                             {
767:                                x_tile = 0;
9D019288  00008821   ADDU S1, ZERO, ZERO
768:                                refresh_vaddr ^= (1 << 10); /* switch nametable */
9D01923C  8FA60020   LW A2, 32(SP)
9D019240  38C60400   XORI A2, A2, 1024
9D019244  AFA60020   SW A2, 32(SP)
769:                                attrib_base ^= (1 << 10);
9D019248  8FA70024   LW A3, 36(SP)
9D01924C  38E70400   XORI A3, A3, 1024
9D019250  AFA70024   SW A3, 36(SP)
770:                 
771:                                /* recalculate pointers */
772:                                tile_ptr = &PPU_MEM(refresh_vaddr);
9D019254  00061282   SRL V0, A2, 10
9D019258  24420448   ADDIU V0, V0, 1096
9D01925C  00021080   SLL V0, V0, 2
9D019260  00521021   ADDU V0, V0, S2
9D019264  8C550000   LW S5, 0(V0)
9D019268  02A6A821   ADDU S5, S5, A2
773:                                attrib_ptr = &PPU_MEM(attrib_base);
9D01926C  00071282   SRL V0, A3, 10
9D019270  24420448   ADDIU V0, V0, 1096
9D019274  00021080   SLL V0, V0, 2
9D019278  00521021   ADDU V0, V0, S2
9D01927C  8C420000   LW V0, 0(V0)
9D019280  00471021   ADDU V0, V0, A3
9D019284  AFA20018   SW V0, 24(SP)
774:                             }
775:                 
776:                             /* Get the attribute byte */
777:                             attrib = *attrib_ptr++;
9D01928C  8FA20018   LW V0, 24(SP)
9D019290  90420000   LBU V0, 0(V0)
9D019294  AFA2001C   SW V0, 28(SP)
9D019298  8FA30018   LW V1, 24(SP)
9D01929C  24630001   ADDIU V1, V1, 1
9D0192A0  AFA30018   SW V1, 24(SP)
778:                          }
779:                 
780:                          attrib_shift ^= 2;
9D0192A4  3AF70002   XORI S7, S7, 2
781:                          col_high = ((attrib >> attrib_shift) & 3) << 2;
9D0192A8  8FA6001C   LW A2, 28(SP)
9D0192AC  02E6F007   SRAV FP, A2, S7
9D0192B0  33DE0003   ANDI FP, FP, 3
9D0192B4  001EF080   SLL FP, FP, 2
782:                       }
783:                    }
784:                 
785:                    /* Blank left hand column if need be */
786:                    if (ppu.bg_mask)
9D0192C4  3C02A000   LUI V0, -24576
9D0192C8  8C4273B4   LW V0, 29620(V0)
9D0192CC  1040000D   BEQ V0, ZERO, .LBE55
9D0192D0  3C02A000   LUI V0, -24576
787:                    {
788:                       uint32 *buf_ptr = (uint32 *) vidbuf;
789:                       uint32 bg_clear = FULLBG | FULLBG << 8 | FULLBG << 16 | FULLBG << 24;
9D0192D4  90427320   LBU V0, 29472(V0)
9D0192D8  3042007F   ANDI V0, V0, 127
9D0192DC  34420080   ORI V0, V0, 128
9D0192E0  00022200   SLL A0, V0, 8
9D0192E4  00021C00   SLL V1, V0, 16
9D0192E8  00831825   OR V1, A0, V1
9D0192EC  00621825   OR V1, V1, V0
9D0192F0  00021600   SLL V0, V0, 24
9D0192F4  00621025   OR V0, V1, V0
790:                 
791:                       ((uint32 *) buf_ptr)[0] = bg_clear;
9D0192F8  8FA30028   LW V1, 40(SP)
9D0192FC  AC620000   SW V0, 0(V1)
792:                       ((uint32 *) buf_ptr)[1] = bg_clear;
9D019300  AC620004   SW V0, 4(V1)
793:                    }
794:                 }
795:                 
796:                 /* OAM entry */
797:                 typedef struct obj_s
798:                 {
799:                    uint8 y_loc;
800:                    uint8 tile;
801:                    uint8 atr;
802:                    uint8 x_loc;
803:                 } obj_t;
804:                 
805:                 /* TODO: fetch valid OAM a scanline before, like the Real Thing */
806:                 static void ppu_renderoam(uint8 *vidbuf, int scanline)
807:                 {
808:                    uint8 *buf_ptr;
809:                    uint32 vram_offset, savecol[2];
810:                    int sprite_num, spritecount;
811:                    obj_t *sprite_ptr;
812:                    uint8 sprite_height;
813:                 
814:                    if (false == ppu.obj_on)
9D019324  8C4273AC   LW V0, 29612(V0)
9D019328  10400221   BEQ V0, ZERO, 0x9D019BB0
9D01932C  8FBF005C   LW RA, 92(SP)
815:                       return;
816:                 
817:                    /* Get our buffer pointer */
818:                    buf_ptr = vidbuf;
819:                 
820:                    /* Save left hand column? */
821:                    if (ppu.obj_mask)
9D019330  3C02A000   LUI V0, -24576
9D019334  8C4273B0   LW V0, 29616(V0)
9D019338  10400008   BEQ V0, ZERO, 0x9D01935C
9D01933C  3C02A000   LUI V0, -24576
822:                    {
823:                       savecol[0] = ((uint32 *) buf_ptr)[0];
9D019340  8FA70028   LW A3, 40(SP)
9D019344  8CE70000   LW A3, 0(A3)
9D019348  AFA7002C   SW A3, 44(SP)
824:                       savecol[1] = ((uint32 *) buf_ptr)[1];
9D01934C  8FA20028   LW V0, 40(SP)
9D019350  8C420004   LW V0, 4(V0)
9D019354  AFA20030   SW V0, 48(SP)
825:                    }
826:                 
827:                    sprite_height = ppu.obj_height;
9D019358  3C02A000   LUI V0, -24576
9D01935C  24426220   ADDIU V0, V0, 25120
9D019360  9055117C   LBU S5, 4476(V0)
828:                    vram_offset = ppu.obj_base;
9D019364  8C421180   LW V0, 4480(V0)
9D019368  AFA20018   SW V0, 24(SP)
829:                    spritecount = 0;
9D01936C  AFA00010   SW ZERO, 16(SP)
830:                 
831:                    sprite_ptr = (obj_t *) ppu.oam;
9D019374  3C10A000   LUI S0, -24576
9D019378  26107220   ADDIU S0, S0, 29216
832:                 
833:                    for (sprite_num = 0; sprite_num < 64; sprite_num++, sprite_ptr++)
9D019370  00009021   ADDU S2, ZERO, ZERO
9D019384  3C13A000   LUI S3, -24576
9D019388  26737320   ADDIU S3, S3, 29472
9D0198CC  26100004   ADDIU S0, S0, 4
9D0198D0  1613FEAE   BNE S0, S3, 0x9D01938C
9D0198D4  26520001   ADDIU S2, S2, 1
834:                    {
835:                       uint8 *data_ptr, *bmp_ptr;
836:                       uint32 vram_adr;
837:                       int y_offset;
838:                       uint8 tile_index, attrib, col_high;
839:                       uint8 sprite_y, sprite_x;
840:                       bool check_strike;
841:                       int strike_pixel;
842:                 
843:                       sprite_y = sprite_ptr->y_loc + 1;
9D01938C  92020000   LBU V0, 0(S0)
9D019390  24510001   ADDIU S1, V0, 1
844:                 
845:                       /* Check to see if sprite is out of range */
846:                       if ((sprite_y > scanline) || (sprite_y <= (scanline - sprite_height))
9D01937C  0295A823   SUBU S5, S4, S5
9D019394  323100FF   ANDI S1, S1, 255
9D019398  0291182A   SLT V1, S4, S1
9D01939C  5460014C   BNEL V1, ZERO, 0x9D0198D0
9D0193A0  26100004   ADDIU S0, S0, 4
9D0193A4  02B1182A   SLT V1, S5, S1
9D0193A8  50600149   BEQL V1, ZERO, 0x9D0198D0
9D0193AC  26100004   ADDIU S0, S0, 4
847:                           || (0 == sprite_y) || (sprite_y >= 240))
9D0193B0  24420011   ADDIU V0, V0, 17
9D0193B4  304200FF   ANDI V0, V0, 255
9D0193B8  2C420011   SLTIU V0, V0, 17
9D0193BC  54400144   BNEL V0, ZERO, 0x9D0198D0
9D0193C0  26100004   ADDIU S0, S0, 4
848:                          continue;
849:                 
850:                       sprite_x = sprite_ptr->x_loc;
851:                       tile_index = sprite_ptr->tile;
9D0193C4  92030001   LBU V1, 1(S0)
9D0193C8  AFA30014   SW V1, 20(SP)
852:                       attrib = sprite_ptr->atr;
9D0193CC  92170002   LBU S7, 2(S0)
853:                 
854:                       bmp_ptr = buf_ptr + sprite_x;
9D0193D0  92160003   LBU S6, 3(S0)
9D0193D4  8FA60028   LW A2, 40(SP)
855:                 
856:                       /* Handle $FD/$FE tile VROM switching (PunchOut) */
857:                       if (ppu.latchfunc)
9D019380  3C1EA000   LUI FP, -24576
9D0193D8  27C26220   ADDIU V0, FP, 25120
9D0193DC  8C4211A4   LW V0, 4516(V0)
9D0193E0  10400004   BEQ V0, ZERO, .LVL243
9D0193E4  00D6B021   ADDU S6, A2, S6
858:                          ppu.latchfunc(vram_offset, tile_index);
9D0193E8  8FA40018   LW A0, 24(SP)
9D0193EC  0040F809   JALR V0
9D0193F0  00602821   ADDU A1, V1, ZERO
859:                 
860:                       /* Get upper two bits of color */
861:                       col_high = ((attrib & 3) << 2);
9D0193F4  32E50003   ANDI A1, S7, 3
862:                 
863:                       /* 8x16 even sprites use $0000, odd use $1000 */
864:                       if (16 == ppu.obj_height)
9D0193F8  27C26220   ADDIU V0, FP, 25120
9D0193FC  9044117C   LBU A0, 4476(V0)
9D019400  24070010   ADDIU A3, ZERO, 16
9D019404  14870008   BNE A0, A3, 0x9D019428
9D019408  00052880   SLL A1, A1, 2
865:                          vram_adr = ((tile_index & 1) << 12) | ((tile_index & 0xFE) << 4);
9D01940C  8FA20014   LW V0, 20(SP)
9D019410  304300FE   ANDI V1, V0, 254
9D019414  00031900   SLL V1, V1, 4
9D019418  30420001   ANDI V0, V0, 1
9D01941C  00021300   SLL V0, V0, 12
9D019420  0B40650E   J 0x9D019438
9D019424  00621025   OR V0, V1, V0
866:                       else
867:                          vram_adr = vram_offset + (tile_index << 4);
9D019428  8FA30014   LW V1, 20(SP)
9D01942C  00031100   SLL V0, V1, 4
9D019430  8FA60018   LW A2, 24(SP)
9D019434  00461021   ADDU V0, V0, A2
868:                 
869:                       /* Get the address of the tile */
870:                       data_ptr = &PPU_MEM(vram_adr);
9D019438  00023282   SRL A2, V0, 10
9D01943C  24C60448   ADDIU A2, A2, 1096
9D019440  00063080   SLL A2, A2, 2
9D019444  27C36220   ADDIU V1, FP, 25120
9D019448  00C31821   ADDU V1, A2, V1
9D01944C  8C630000   LW V1, 0(V1)
9D019450  00621821   ADDU V1, V1, V0
871:                 
872:                       /* Calculate offset (line within the sprite) */
873:                       y_offset = scanline - sprite_y;
9D019454  02918823   SUBU S1, S4, S1
874:                       if (y_offset > 7)
9D019458  2A260008   SLTI A2, S1, 8
875:                          y_offset += 8;
9D01945C  26220008   ADDIU V0, S1, 8
9D019460  0046880A   MOVZ S1, V0, A2
876:                 
877:                       /* Account for vertical flippage */
878:                       if (attrib & OAMF_VFLIP)
9D019464  7C173420   SEB A2, S7
9D019468  04C10006   BGEZ A2, 0x9D019484
9D01946C  00711021   ADDU V0, V1, S1
879:                       {
880:                          if (16 == ppu.obj_height)
881:                             y_offset -= 23;
9D019470  2626FFE9   ADDIU A2, S1, -23
9D019474  2631FFF9   ADDIU S1, S1, -7
9D019478  38820010   XORI V0, A0, 16
9D01947C  0222300B   MOVN A2, S1, V0
882:                          else
883:                             y_offset -= 7;
884:                 
885:                          data_ptr -= y_offset;
9D019480  00661023   SUBU V0, V1, A2
886:                       }
887:                       else
888:                       {
889:                          data_ptr += y_offset;
890:                       }
891:                 
892:                       /* if we're on sprite 0 and sprite 0 strike flag isn't set,
893:                       ** check for a strike 
894:                       */
895:                       check_strike = (0 == sprite_num) && (false == ppu.strikeflag);
9D019484  16400004   BNE S2, ZERO, 0x9D019498
9D019488  00006821   ADDU T5, ZERO, ZERO
9D01948C  27C36220   ADDIU V1, FP, 25120
9D019490  8C6D119C   LW T5, 4508(V1)
9D019494  2DAD0001   SLTIU T5, T5, 1
896:                       strike_pixel = draw_oamtile(bmp_ptr, attrib, data_ptr[0], data_ptr[8], ppu.palette + 16 + col_high, check_strike);
9D019498  90440000   LBU A0, 0(V0)
9D01949C  90420008   LBU V0, 8(V0)
9D0194A0  24A31110   ADDIU V1, A1, 4368
9D0194A4  27C56220   ADDIU A1, FP, 25120
9D0194A8  00A32821   ADDU A1, A1, V1
897:                       if (strike_pixel >= 0)
9D019890  04800004   BLTZ A0, 0x9D0198A4
9D019894  8FA70010   LW A3, 16(SP)
898:                          ppu_setstrike(strike_pixel);
9D019898  0F406039   JAL .LFB19, ppu_setstrike, .Ltext0
9D01989C  00000000   NOP
899:                 
900:                       /* maximum of 8 sprites per scanline */
901:                       if (++spritecount == PPU_MAXSPRITE)
9D0198A0  8FA70010   LW A3, 16(SP)
9D0198A4  24E70001   ADDIU A3, A3, 1
9D0198A8  24020008   ADDIU V0, ZERO, 8
9D0198AC  14E20007   BNE A3, V0, 0x9D0198CC
9D0198B0  AFA70010   SW A3, 16(SP)
902:                       {
903:                          ppu.stat |= PPU_STATF_MAXSPRITE;
9D0198B4  3C02A000   LUI V0, -24576
9D0198B8  24426220   ADDIU V0, V0, 25120
9D0198BC  90431162   LBU V1, 4450(V0)
9D0198C0  34630020   ORI V1, V1, 32
9D0198C4  0B406636   J 0x9D0198D8
9D0198C8  A0431162   SB V1, 4450(V0)
904:                          break;
905:                       }
906:                    }
907:                 
908:                    /* Restore lefthand column */
909:                    if (ppu.obj_mask)
9D0198D8  3C02A000   LUI V0, -24576
9D0198DC  8C4273B0   LW V0, 29616(V0)
9D0198E0  104000B2   BEQ V0, ZERO, 0x9D019BAC
9D0198E4  8FA3002C   LW V1, 44(SP)
910:                    {
911:                       ((uint32 *) buf_ptr)[0] = savecol[0];
9D0198E8  8FA20028   LW V0, 40(SP)
9D0198EC  AC430000   SW V1, 0(V0)
912:                       ((uint32 *) buf_ptr)[1] = savecol[1];
9D0198F0  8FA60030   LW A2, 48(SP)
9D0198F4  0B4066EB   J 0x9D019BAC
9D0198F8  AC460004   SW A2, 4(V0)
913:                    }
914:                 }
915:                 
916:                 /* Fake rendering a line */
917:                 /* This is needed for sprite 0 hits when we're skipping drawing a frame */
918:                 static void ppu_fakeoam(int scanline)
919:                 {
920:                    uint8 *data_ptr;
921:                    obj_t *sprite_ptr;
922:                    uint32 vram_adr, color;
923:                    int y_offset;
924:                    uint8 pat1, pat2;
925:                    uint8 tile_index, attrib;
926:                    uint8 sprite_height, sprite_y, sprite_x;
927:                 
928:                    /* we don't need to be here if strike flag is set */
929:                 
930:                    if (false == ppu.obj_on || ppu.strikeflag)
9D0198FC  8C4273AC   LW V0, 29612(V0)
9D019900  104000AA   BEQ V0, ZERO, 0x9D019BAC
9D019904  3C02A000   LUI V0, -24576
9D019908  8C4273BC   LW V0, 29628(V0)
9D01990C  144000A7   BNE V0, ZERO, 0x9D019BAC
9D019910  3C02A000   LUI V0, -24576
931:                       return;
932:                 
933:                    sprite_height = ppu.obj_height;
9D019914  24426220   ADDIU V0, V0, 25120
9D019918  9045117C   LBU A1, 4476(V0)
934:                    sprite_ptr = (obj_t *) ppu.oam;
935:                    sprite_y = sprite_ptr->y_loc + 1;
9D01991C  90431000   LBU V1, 4096(V0)
9D019920  24620001   ADDIU V0, V1, 1
936:                 
937:                    /* Check to see if sprite is out of range */
938:                    if ((sprite_y > scanline) || (sprite_y <= (scanline - sprite_height)) 
9D019924  304200FF   ANDI V0, V0, 255
9D019928  0282202A   SLT A0, S4, V0
9D01992C  1480009F   BNE A0, ZERO, 0x9D019BAC
9D019930  02852023   SUBU A0, S4, A1
9D019934  0082202A   SLT A0, A0, V0
9D019938  1080009C   BEQ A0, ZERO, 0x9D019BAC
9D01993C  24630010   ADDIU V1, V1, 16
939:                        || (0 == sprite_y) || (sprite_y > 240))
9D019940  306300FF   ANDI V1, V1, 255
9D019944  2C630010   SLTIU V1, V1, 16
9D019948  14600098   BNE V1, ZERO, 0x9D019BAC
9D01994C  3C03A000   LUI V1, -24576
940:                       return;
941:                 
942:                    sprite_x = sprite_ptr->x_loc;
9D019950  24636220   ADDIU V1, V1, 25120
9D019954  90641003   LBU A0, 4099(V1)
943:                    tile_index = sprite_ptr->tile;
9D019958  90671001   LBU A3, 4097(V1)
944:                    attrib = sprite_ptr->atr;
9D01995C  90661002   LBU A2, 4098(V1)
945:                 
946:                    /* 8x16 even sprites use $0000, odd use $1000 */
947:                    if (16 == ppu.obj_height)
9D019960  24030010   ADDIU V1, ZERO, 16
9D019964  54A30007   BNEL A1, V1, 0x9D019984
9D019968  00073900   SLL A3, A3, 4
948:                       vram_adr = ((tile_index & 1) << 12) | ((tile_index & 0xFE) << 4);
9D01996C  30E800FE   ANDI T0, A3, 254
9D019970  00084100   SLL T0, T0, 4
9D019974  30E30001   ANDI V1, A3, 1
9D019978  00031B00   SLL V1, V1, 12
9D01997C  0B406664   J 0x9D019990
9D019980  01031825   OR V1, T0, V1
949:                    else
950:                       vram_adr = ppu.obj_base + (tile_index << 4);
9D019984  3C03A000   LUI V1, -24576
9D019988  8C6373A0   LW V1, 29600(V1)
9D01998C  00E31821   ADDU V1, A3, V1
951:                 
952:                    data_ptr = &PPU_MEM(vram_adr);
9D019990  00034282   SRL T0, V1, 10
9D019994  25080448   ADDIU T0, T0, 1096
9D019998  00084080   SLL T0, T0, 2
9D01999C  3C07A000   LUI A3, -24576
9D0199A0  24E76220   ADDIU A3, A3, 25120
9D0199A4  01073821   ADDU A3, T0, A3
9D0199A8  8CE70000   LW A3, 0(A3)
9D0199AC  00E33821   ADDU A3, A3, V1
953:                 
954:                    /* Calculate offset (line within the sprite) */
955:                    y_offset = scanline - sprite_y;
9D0199B0  02821023   SUBU V0, S4, V0
956:                    if (y_offset > 7)
9D0199B4  28480008   SLTI T0, V0, 8
957:                       y_offset += 8;
9D0199B8  24430008   ADDIU V1, V0, 8
9D0199BC  0068100A   MOVZ V0, V1, T0
958:                 
959:                    /* Account for vertical flippage */
960:                    if (attrib & OAMF_VFLIP)
9D0199C0  7C064420   SEB T0, A2
9D0199C4  05010006   BGEZ T0, 0x9D0199E0
9D0199C8  00E21821   ADDU V1, A3, V0
961:                    {
962:                       if (16 == ppu.obj_height)
963:                          y_offset -= 23;
9D0199CC  2448FFE9   ADDIU T0, V0, -23
9D0199D0  2442FFF9   ADDIU V0, V0, -7
9D0199D4  38A30010   XORI V1, A1, 16
9D0199D8  0043400B   MOVN T0, V0, V1
964:                       else
965:                          y_offset -= 7;
966:                       data_ptr -= y_offset;
9D0199DC  00E81823   SUBU V1, A3, T0
967:                    }
968:                    else
969:                    {
970:                       data_ptr += y_offset;
971:                    }
972:                 
973:                    /* check for a solid sprite 0 pixel */
974:                    pat1 = data_ptr[0];
9D0199E0  90650000   LBU A1, 0(V1)
975:                    pat2 = data_ptr[8];
9D0199E4  90620008   LBU V0, 8(V1)
976:                    color = ((pat2 & 0xAA) << 8) | ((pat2 & 0x55) << 1)
9D0199E8  2403FFAA   ADDIU V1, ZERO, -86
9D0199EC  00433824   AND A3, V0, V1
9D0199F0  00073A00   SLL A3, A3, 8
9D0199F4  30420055   ANDI V0, V0, 85
9D0199F8  00021040   SLL V0, V0, 1
9D0199FC  00E23825   OR A3, A3, V0
977:                                   | ((pat1 & 0xAA) << 7) | (pat1 & 0x55);
9D019A00  30A20055   ANDI V0, A1, 85
9D019A04  00E23825   OR A3, A3, V0
9D019A08  00A31024   AND V0, A1, V1
9D019A0C  000211C0   SLL V0, V0, 7
9D019A10  00E21025   OR V0, A3, V0
978:                 
979:                    if (color)
9D019A14  10400065   BEQ V0, ZERO, 0x9D019BAC
9D019A18  30C30040   ANDI V1, A2, 64
980:                    {
981:                       uint8 colors[8];
982:                 
983:                       /* buckle up, it's going to get ugly... */
984:                       if (0 == (attrib & OAMF_HFLIP))
9D019A1C  306300FF   ANDI V1, V1, 255
9D019A20  5460000A   BNEL V1, ZERO, 0x9D019A4C
9D019A24  00023382   SRL A2, V0, 14
985:                       {
986:                          colors[0] = (color >> 14) & 3;
9D019A28  00021B82   SRL V1, V0, 14
987:                          colors[1] = (color >> 6) & 3;
9D019A2C  7C450980   EXT A1, V0, 6, 2
988:                          colors[2] = (color >> 12) & 3;
9D019A30  7C4B0B00   EXT T3, V0, 12, 2
989:                          colors[3] = (color >> 4) & 3;
9D019A34  7C4A0900   EXT T2, V0, 4, 2
990:                          colors[4] = (color >> 10) & 3;
9D019A38  7C490A80   EXT T1, V0, 10, 2
991:                          colors[5] = (color >> 2) & 3;
9D019A3C  7C480880   EXT T0, V0, 2, 2
992:                          colors[6] = (color >> 8) & 3;
9D019A40  7C470A00   EXT A3, V0, 8, 2
993:                          colors[7] = color & 3;
9D019A44  0B40669A   J 0x9D019A68
9D019A48  30460003   ANDI A2, V0, 3
994:                       }
995:                       else
996:                       {
997:                          colors[7] = (color >> 14) & 3;
998:                          colors[6] = (color >> 6) & 3;
9D019A4C  7C470980   EXT A3, V0, 6, 2
999:                          colors[5] = (color >> 12) & 3;
9D019A50  7C480B00   EXT T0, V0, 12, 2
1000:                         colors[4] = (color >> 4) & 3;
9D019A54  7C490900   EXT T1, V0, 4, 2
1001:                         colors[3] = (color >> 10) & 3;
9D019A58  7C4A0A80   EXT T2, V0, 10, 2
1002:                         colors[2] = (color >> 2) & 3;
9D019A5C  7C4B0880   EXT T3, V0, 2, 2
1003:                         colors[1] = (color >> 8) & 3;
9D019A60  7C450A00   EXT A1, V0, 8, 2
1004:                         colors[0] = color & 3;
9D019A64  30430003   ANDI V1, V0, 3
1005:                      }
1006:                
1007:                      if (colors[0])
9D019A68  10600005   BEQ V1, ZERO, 0x9D019A80
9D019A6C  00000000   NOP
1008:                         ppu_setstrike(sprite_x + 0);
9D019A70  0F406039   JAL .LFB19, ppu_setstrike, .Ltext0
9D019A74  00000000   NOP
1009:                      else if (colors[1])
9D019A80  10A00005   BEQ A1, ZERO, 0x9D019A98
9D019A84  00000000   NOP
1010:                         ppu_setstrike(sprite_x + 1);
9D019A88  0F406039   JAL .LFB19, ppu_setstrike, .Ltext0
9D019A8C  24840001   ADDIU A0, A0, 1
1011:                      else if (colors[2])
9D019A98  11600005   BEQ T3, ZERO, 0x9D019AB0
9D019A9C  00000000   NOP
1012:                         ppu_setstrike(sprite_x + 2);
9D019AA0  0F406039   JAL .LFB19, ppu_setstrike, .Ltext0
9D019AA4  24840002   ADDIU A0, A0, 2
1013:                      else if (colors[3])
9D019AB0  11400005   BEQ T2, ZERO, 0x9D019AC8
9D019AB4  00000000   NOP
1014:                         ppu_setstrike(sprite_x + 3);
9D019AB8  0F406039   JAL .LFB19, ppu_setstrike, .Ltext0
9D019ABC  24840003   ADDIU A0, A0, 3
1015:                      else if (colors[4])
9D019AC8  11200005   BEQ T1, ZERO, 0x9D019AE0
9D019ACC  00000000   NOP
1016:                         ppu_setstrike(sprite_x + 4);
9D019AD0  0F406039   JAL .LFB19, ppu_setstrike, .Ltext0
9D019AD4  24840004   ADDIU A0, A0, 4
1017:                      else if (colors[5])
9D019AE0  11000005   BEQ T0, ZERO, 0x9D019AF8
9D019AE4  00000000   NOP
1018:                         ppu_setstrike(sprite_x + 5);
9D019AE8  0F406039   JAL .LFB19, ppu_setstrike, .Ltext0
9D019AEC  24840005   ADDIU A0, A0, 5
1019:                      else if (colors[6])
9D019AF8  10E00005   BEQ A3, ZERO, 0x9D019B10
9D019AFC  00000000   NOP
1020:                         ppu_setstrike(sprite_x + 6);
9D019B00  0F406039   JAL .LFB19, ppu_setstrike, .Ltext0
9D019B04  24840006   ADDIU A0, A0, 6
1021:                      else if (colors[7])
9D019B10  50C00027   BEQL A2, ZERO, 0x9D019BB0
9D019B14  8FBF005C   LW RA, 92(SP)
1022:                         ppu_setstrike(sprite_x + 7);
9D019B18  0F406039   JAL .LFB19, ppu_setstrike, .Ltext0
9D019B1C  24840007   ADDIU A0, A0, 7
1023:                   }
1024:                }
1025:                
1026:                bool ppu_enabled(void)
1027:                {
1028:                   return (ppu.bg_on || ppu.obj_on);
9D018E5C  3C02A000   LUI V0, -24576
9D018E60  8C4373A8   LW V1, 29608(V0)
9D018E64  14600004   BNE V1, ZERO, 0x9D018E78
9D018E68  24020001   ADDIU V0, ZERO, 1
9D018E6C  3C02A000   LUI V0, -24576
9D018E70  8C4273AC   LW V0, 29612(V0)
9D018E74  0002102B   SLTU V0, ZERO, V0
1029:                }
9D018E78  03E00008   JR RA
9D018E7C  00000000   NOP
1030:                
1031:                static void ppu_renderscanline(bitmap_t *bmp, int scanline, bool draw_flag)
1032:                {
1033:                   uint8 *buf = bmp->line[scanline];
9D018FA4  24A30004   ADDIU V1, A1, 4
9D018FA8  00031880   SLL V1, V1, 2
9D018FAC  00832021   ADDU A0, A0, V1
9D018FB0  8C840004   LW A0, 4(A0)
9D018FB4  AFA40028   SW A0, 40(SP)
1034:                
1035:                   /* start scanline - transfer ppu latch into vaddr */
1036:                   if (ppu.bg_on || ppu.obj_on)
9D018FB8  8C421188   LW V0, 4488(V0)
9D018FBC  14400004   BNE V0, ZERO, 0x9D018FD0
9D018FC0  3C03A000   LUI V1, -24576
9D018FC4  8C6373AC   LW V1, 29612(V1)
9D018FC8  106002EF   BEQ V1, ZERO, 0x9D019B88
9D018FCC  8FA70068   LW A3, 104(SP)
1037:                   {
1038:                      if (0 == scanline)
9D018FD0  16800005   BNE S4, ZERO, 0x9D018FE8
9D018FD4  3C03A000   LUI V1, -24576
1039:                      {
1040:                         ppu.vaddr = ppu.vaddr_latch;
9D018FD8  24636220   ADDIU V1, V1, 25120
9D018FDC  8C641168   LW A0, 4456(V1)
9D018FE0  0B406402   J 0x9D019008
9D018FE4  AC641164   SW A0, 4452(V1)
1041:                      }
1042:                      else
1043:                      {
1044:                         ppu.vaddr &= ~0x041F;
9D018FF4  8C661164   LW A2, 4452(V1)
9D018FF8  2404FBE0   ADDIU A0, ZERO, -1056
9D018FFC  00C42024   AND A0, A2, A0
1045:                         ppu.vaddr |= (ppu.vaddr_latch & 0x041F);
9D018FE8  24636220   ADDIU V1, V1, 25120
9D018FEC  8C651168   LW A1, 4456(V1)
9D018FF0  30A5041F   ANDI A1, A1, 1055
9D019000  00A42025   OR A0, A1, A0
9D019004  AC641164   SW A0, 4452(V1)
1046:                      }
1047:                   }
1048:                
1049:                   if (draw_flag)
9D019008  8FA30068   LW V1, 104(SP)
9D01900C  5060023B   BEQL V1, ZERO, .LBB88
9D019010  3C02A000   LUI V0, -24576
9D019B88  50E0FF5C   BEQL A3, ZERO, .LBB88
9D019B8C  3C02A000   LUI V0, -24576
1050:                      ppu_renderbg(buf);
1051:                
1052:                   /* TODO: fetch obj data 1 scanline before */
1053:                   if (true == ppu.drawsprites && true == draw_flag)
9D019038  0B4064C2   J 0x9D019308
9D01903C  3C02A000   LUI V0, -24576
9D019304  3C02A000   LUI V0, -24576
9D019308  8C437FD4   LW V1, 32724(V0)
9D01930C  24020001   ADDIU V0, ZERO, 1
9D019310  5462017A   BNEL V1, V0, .LBB88
9D019314  3C02A000   LUI V0, -24576
9D019318  8FA60068   LW A2, 104(SP)
9D01931C  14C20177   BNE A2, V0, .LBB88
9D019320  3C02A000   LUI V0, -24576
1054:                      ppu_renderoam(buf, scanline);
1055:                   else
1056:                      ppu_fakeoam(scanline);
1057:                }
1058:                
1059:                
1060:                void ppu_endscanline(int scanline)
1061:                {
1062:                   /* modify vram address at end of scanline */
1063:                   if (scanline < 240 && (ppu.bg_on || ppu.obj_on))
9D018E80  288400F0   SLTI A0, A0, 240
9D018E84  10800025   BEQ A0, ZERO, 0x9D018F1C
9D018E88  3C02A000   LUI V0, -24576
9D018E8C  8C4273A8   LW V0, 29608(V0)
9D018E90  14400005   BNE V0, ZERO, 0x9D018EA8
9D018E94  3C02A000   LUI V0, -24576
9D018E98  3C02A000   LUI V0, -24576
9D018E9C  8C4273AC   LW V0, 29612(V0)
9D018EA0  1040001E   BEQ V0, ZERO, 0x9D018F1C
9D018EA4  3C02A000   LUI V0, -24576
1064:                   {
1065:                      int ytile;
1066:                
1067:                      /* check for max 3 bit y tile offset */
1068:                      if (7 == (ppu.vaddr >> 12))
9D018EA8  8C427384   LW V0, 29572(V0)
9D018EAC  00022302   SRL A0, V0, 12
9D018EB0  24030007   ADDIU V1, ZERO, 7
9D018EB4  54830017   BNEL A0, V1, 0x9D018F14
9D018EB8  24421000   ADDIU V0, V0, 4096
1069:                      {
1070:                         ppu.vaddr &= ~0x7000;      /* clear y tile offset */
9D018EBC  24038FFF   ADDIU V1, ZERO, -28673
9D018EC0  00432024   AND A0, V0, V1
1071:                         ytile = (ppu.vaddr >> 5) & 0x1F;
9D018EC4  7C832140   EXT V1, A0, 5, 5
1072:                
1073:                         if (29 == ytile)
9D018EC8  2405001D   ADDIU A1, ZERO, 29
9D018ECC  54650007   BNEL V1, A1, 0x9D018EEC
9D018ED0  2405001F   ADDIU A1, ZERO, 31
1074:                         {
1075:                            ppu.vaddr &= ~0x03E0;   /* clear y tile */
9D018ED4  24038C1F   ADDIU V1, ZERO, -29665
9D018ED8  00431024   AND V0, V0, V1
1076:                            ppu.vaddr ^= 0x0800;    /* toggle nametable */
9D018EDC  38420800   XORI V0, V0, 2048
9D018EE0  3C03A000   LUI V1, -24576
9D018EE4  03E00008   JR RA
9D018EE8  AC627384   SW V0, 29572(V1)
1077:                         }
1078:                         else if (31 == ytile)
9D018EEC  54650006   BNEL V1, A1, 0x9D018F08
9D018EF0  24840020   ADDIU A0, A0, 32
1079:                         {
1080:                            ppu.vaddr &= ~0x03E0;   /* clear y tile */
9D018EF4  24038C1F   ADDIU V1, ZERO, -29665
9D018EF8  00431024   AND V0, V0, V1
9D018EFC  3C03A000   LUI V1, -24576
9D018F00  03E00008   JR RA
9D018F04  AC627384   SW V0, 29572(V1)
1081:                         }
1082:                         else
1083:                         {
1084:                            ppu.vaddr += 0x20;      /* increment y tile */
9D018F08  3C02A000   LUI V0, -24576
9D018F0C  03E00008   JR RA
9D018F10  AC447384   SW A0, 29572(V0)
1085:                         }
1086:                      }
1087:                      else
1088:                      {
1089:                         ppu.vaddr += 0x1000;       /* increment tile y offset */
9D018F14  3C03A000   LUI V1, -24576
9D018F18  AC627384   SW V0, 29572(V1)
9D018F1C  03E00008   JR RA
9D018F20  00000000   NOP
1090:                      }
1091:                   }
1092:                }
1093:                
1094:                void ppu_checknmi(void)
1095:                {
9D018F34  27BDFFE8   ADDIU SP, SP, -24
9D018F38  AFBF0014   SW RA, 20(SP)
1096:                   if (ppu.ctrl0 & PPU_CTRL0F_NMI)
9D018F24  3C02A000   LUI V0, -24576
9D018F28  80427380   LB V0, 29568(V0)
9D018F2C  04410007   BGEZ V0, 0x9D018F4C
9D018F30  00000000   NOP
1097:                      nes_nmi();
9D018F3C  0F408B20   JAL nes_nmi
9D018F40  00000000   NOP
1098:                }
9D018F44  8FBF0014   LW RA, 20(SP)
9D018F48  27BD0018   ADDIU SP, SP, 24
9D018F4C  03E00008   JR RA
9D018F50  00000000   NOP
1099:                
1100:                void ppu_scanline(bitmap_t *bmp, int scanline, bool draw_flag)
1101:                {
9D018F54  27BDFFA0   ADDIU SP, SP, -96
9D018F58  AFBF005C   SW RA, 92(SP)
9D018F5C  AFBE0058   SW FP, 88(SP)
9D018F60  AFB70054   SW S7, 84(SP)
9D018F64  AFB60050   SW S6, 80(SP)
9D018F68  AFB5004C   SW S5, 76(SP)
9D018F6C  AFB40048   SW S4, 72(SP)
9D018F70  AFB30044   SW S3, 68(SP)
9D018F74  AFB20040   SW S2, 64(SP)
9D018F78  AFB1003C   SW S1, 60(SP)
9D018F7C  AFB00038   SW S0, 56(SP)
9D018F80  00A0A021   ADDU S4, A1, ZERO
1102:                   if (scanline < 240)
9D018F84  28A200F0   SLTI V0, A1, 240
9D018F88  104002E7   BEQ V0, ZERO, 0x9D019B28
9D018F8C  AFA60068   SW A2, 104(SP)
1103:                   {
1104:                      /* Lower the Max Sprite per scanline flag */
1105:                      ppu.stat &= ~PPU_STATF_MAXSPRITE;
9D018F90  3C02A000   LUI V0, -24576
9D018F94  24426220   ADDIU V0, V0, 25120
9D018F98  90431162   LBU V1, 4450(V0)
9D018F9C  7C032944   INS V1, ZERO, 5, 1
9D018FA0  A0431162   SB V1, 4450(V0)
1106:                      ppu_renderscanline(bmp, scanline, draw_flag);
1107:                   }
1108:                   else if (241 == scanline)
9D019B28  240200F1   ADDIU V0, ZERO, 241
9D019B2C  14A2000A   BNE A1, V0, 0x9D019B58
9D019B30  24020105   ADDIU V0, ZERO, 261
1109:                   {
1110:                      ppu.stat |= PPU_STATF_VBLANK;
9D019B34  3C02A000   LUI V0, -24576
9D019B38  24426220   ADDIU V0, V0, 25120
9D019B3C  90441162   LBU A0, 4450(V0)
9D019B40  2403FF80   ADDIU V1, ZERO, -128
9D019B44  00831825   OR V1, A0, V1
9D019B48  A0431162   SB V1, 4450(V0)
1111:                      ppu.vram_accessible = true;
9D019B4C  24030001   ADDIU V1, ZERO, 1
9D019B50  0B4066EB   J 0x9D019BAC
9D019B54  AC431DAC   SW V1, 7596(V0)
1112:                   }
1113:                   else if (261 == scanline)
9D019B58  14A20015   BNE A1, V0, 0x9D019BB0
9D019B5C  8FBF005C   LW RA, 92(SP)
1114:                   {
1115:                      ppu.stat &= ~PPU_STATF_VBLANK;
9D019B60  3C02A000   LUI V0, -24576
9D019B64  24426220   ADDIU V0, V0, 25120
9D019B68  90431162   LBU V1, 4450(V0)
9D019B6C  3063007F   ANDI V1, V1, 127
9D019B70  A0431162   SB V1, 4450(V0)
1116:                      ppu.strikeflag = false;
9D019B74  AC40119C   SW ZERO, 4508(V0)
1117:                      ppu.strike_cycle = (uint32) -1;
9D019B78  2403FFFF   ADDIU V1, ZERO, -1
9D019B7C  AC4311A0   SW V1, 4512(V0)
1118:                
1119:                      ppu.vram_accessible = false;
9D019B80  0B4066EB   J 0x9D019BAC
9D019B84  AC401DAC   SW ZERO, 7596(V0)
1120:                   }
1121:                }
9D019A78  0B4066EC   J 0x9D019BB0
9D019A7C  8FBF005C   LW RA, 92(SP)
9D019A90  0B4066EC   J 0x9D019BB0
9D019A94  8FBF005C   LW RA, 92(SP)
9D019AA8  0B4066EC   J 0x9D019BB0
9D019AAC  8FBF005C   LW RA, 92(SP)
9D019AC0  0B4066EC   J 0x9D019BB0
9D019AC4  8FBF005C   LW RA, 92(SP)
9D019AD8  0B4066EC   J 0x9D019BB0
9D019ADC  8FBF005C   LW RA, 92(SP)
9D019AF0  0B4066EC   J 0x9D019BB0
9D019AF4  8FBF005C   LW RA, 92(SP)
9D019B08  0B4066EC   J 0x9D019BB0
9D019B0C  8FBF005C   LW RA, 92(SP)
9D019B20  0B4066EC   J 0x9D019BB0
9D019B24  8FBF005C   LW RA, 92(SP)
9D019BAC  8FBF005C   LW RA, 92(SP)
9D019BB0  8FBE0058   LW FP, 88(SP)
9D019BB4  8FB70054   LW S7, 84(SP)
9D019BB8  8FB60050   LW S6, 80(SP)
9D019BBC  8FB5004C   LW S5, 76(SP)
9D019BC0  8FB40048   LW S4, 72(SP)
9D019BC4  8FB30044   LW S3, 68(SP)
9D019BC8  8FB20040   LW S2, 64(SP)
9D019BCC  8FB1003C   LW S1, 60(SP)
9D019BD0  8FB00038   LW S0, 56(SP)
9D019BD4  03E00008   JR RA
9D019BD8  27BD0060   ADDIU SP, SP, 96
1122:                
1123:                /*
1124:                bool ppu_checkzapperhit(bitmap_t *bmp, int x, int y)
1125:                {
1126:                   uint8 pixel = bmp->line[y][x] & 0x3F;
1127:                
1128:                   if (0x20 == pixel || 0x30 == pixel)
1129:                      return true;
1130:                
1131:                   return false;
1132:                }
1133:                */
1134:                
1135:                /*************************************************/
1136:                /* TODO: all this stuff should go somewhere else */
1137:                /*************************************************/
1138:                INLINE void draw_box(bitmap_t *bmp, int x, int y, int height)
1139:                {
1140:                   int i;
1141:                   uint8 *vid;
1142:                
1143:                   vid = bmp->line[y] + x;
9D019C74  25220004   ADDIU V0, T1, 4
9D019C78  00021080   SLL V0, V0, 2
9D019C7C  00821021   ADDU V0, A0, V0
9D019C80  8C430004   LW V1, 4(V0)
9D019C84  00681821   ADDU V1, V1, T0
9D019C88  2467000A   ADDIU A3, V1, 10
1144:                
1145:                   for (i = 0; i < 10; i++)
9D019C90  1467FFFE   BNE V1, A3, 0x9D019C8C
9D019C94  A06BFFFF   SB T3, -1(V1)
1146:                      *vid++ = GUI_GRAY;
9D019C18  240BFFC2   ADDIU T3, ZERO, -62
9D019C8C  24630001   ADDIU V1, V1, 1
1147:                   vid += (bmp->pitch - 10);
9D019C98  8C820008   LW V0, 8(A0)
9D019C9C  2442FFF6   ADDIU V0, V0, -10
1148:                   for (i = 0; i < height; i++)
9D019CA0  19800097   BLEZ T4, 0x9D019F00
9D019CA4  00E21021   ADDU V0, A3, V0
9D019CA8  00001821   ADDU V1, ZERO, ZERO
9D019CBC  24630001   ADDIU V1, V1, 1
9D019CC0  006C382A   SLT A3, V1, T4
9D019CC4  54E0FFFA   BNEL A3, ZERO, 0x9D019CB0
9D019CC8  A04B0009   SB T3, 9(V0)
9D019CCC  0B406735   J 0x9D019CD4
9D019CD0  2443000A   ADDIU V1, V0, 10
9D019D9C  0263400B   MOVN T0, S3, V1
9D019F08  00004821   ADDU T1, ZERO, ZERO
1149:                   {
1150:                      vid[0] = vid[9] = GUI_GRAY;
9D019CAC  A04B0009   SB T3, 9(V0)
9D019CB0  A04B0000   SB T3, 0(V0)
1151:                      vid += bmp->pitch;
9D019CB4  8C870008   LW A3, 8(A0)
9D019CB8  00471021   ADDU V0, V0, A3
1152:                   }
1153:                   for (i = 0; i < 10; i++)
9D019CD8  1443FFFE   BNE V0, V1, 0x9D019CD4
9D019CDC  A04BFFFF   SB T3, -1(V0)
1154:                      *vid++ = GUI_GRAY;
9D019CD4  24420001   ADDIU V0, V0, 1
1155:                }
1156:                
1157:                INLINE void draw_deadsprite(bitmap_t *bmp, int x, int y, int height)
1158:                {
1159:                   int i, j, index;
1160:                   uint8 *vid;
1161:                   uint8 colbuf[8] = { GUI_BLACK, GUI_BLACK, GUI_BLACK, GUI_BLACK,
9D019C1C  3C199D04   LUI T9, -25340
9D019E70  88430003   LWL V1, 3(V0)
9D019E74  9B23B648   LWR V1, -18872(T9)
9D019E78  88470007   LWL A3, 7(V0)
9D019E7C  98470004   LWR A3, 4(V0)
9D019E80  AFA30000   SW V1, 0(SP)
9D019E84  AFA70004   SW A3, 4(SP)
1162:                                       GUI_BLACK, GUI_BLACK, GUI_BLACK, GUI_DKGRAY };
1163:                
1164:                   vid = bmp->line[y] + x;
9D019E88  25220005   ADDIU V0, T1, 5
9D019E8C  00021080   SLL V0, V0, 2
9D019E90  00821021   ADDU V0, A0, V0
9D019E98  8C490004   LW T1, 4(V0)
1165:                
1166:                   for (i = 0; i < height; i++)
9D019E9C  19800013   BLEZ T4, 0x9D019EEC
9D019EA0  01284821   ADDU T1, T1, T0
9D019EA4  00009821   ADDU S3, ZERO, ZERO
9D019EB0  00001021   ADDU V0, ZERO, ZERO
9D019EDC  26730001   ADDIU S3, S3, 1
9D019EE0  026C102A   SLT V0, S3, T4
9D019EE4  5440FFF1   BNEL V0, ZERO, 0x9D019EAC
9D019EE8  00131843   SRA V1, S3, 1
1167:                   {
1168:                      index = i;
1169:                
1170:                      if (height == 16)
1171:                         index >>= 1;
9D019C20  01857026   XOR T6, T4, A1
9D019EA8  00131843   SRA V1, S3, 1
9D019EAC  026E180B   MOVN V1, S3, T6
1172:                
1173:                      for (j = 0; j < 8; j++)
9D019C24  240A0008   ADDIU T2, ZERO, 8
9D019EC8  24420001   ADDIU V0, V0, 1
9D019ECC  144AFFF9   BNE V0, T2, 0x9D019EB4
9D019ED0  30E30007   ANDI V1, A3, 7
1174:                      {
1175:                         *(vid + j) = colbuf[index++];
9D019EB4  24670001   ADDIU A3, V1, 1
9D019EB8  01224021   ADDU T0, T1, V0
9D019EBC  03A31821   ADDU V1, SP, V1
9D019EC0  90630000   LBU V1, 0(V1)
9D019EC4  A1030000   SB V1, 0(T0)
1176:                         index &= 7;
1177:                      }
1178:                
1179:                      vid += bmp->pitch;
9D019ED4  8C820008   LW V0, 8(A0)
9D019ED8  01224821   ADDU T1, T1, V0
1180:                   }
1181:                }
1182:                
1183:                
1184:                /* Stuff for the OAM viewer */
1185:                static void draw_sprite(bitmap_t *bmp, int x, int y, uint8 tile_num, uint8 attrib)
1186:                {
1187:                   int line, height;
1188:                   int col_high, vram_adr;
1189:                   uint8 *vid, *data_ptr;
1190:                
1191:                   vid = bmp->line[y] + x;
9D019CFC  25220005   ADDIU V0, T1, 5
9D019D00  00021080   SLL V0, V0, 2
9D019D04  00821021   ADDU V0, A0, V0
9D019D0C  8C420004   LW V0, 4(V0)
1192:                
1193:                   /* Get upper two bits of color */
1194:                   col_high = ((attrib & 3) << 2);
9D019D10  91E70002   LBU A3, 2(T7)
9D019D14  30E70003   ANDI A3, A3, 3
9D019D18  00079880   SLL S3, A3, 2
1195:                
1196:                   /* 8x16 even sprites use $0000, odd use $1000 */
1197:                   height = ppu.obj_height;
9D019C28  3C06A000   LUI A2, -24576
9D019D1C  24C76220   ADDIU A3, A2, 25120
9D019D20  90F4117C   LBU S4, 4476(A3)
1198:                   if (16 == height)
9D019D24  1685000E   BNE S4, A1, 0x9D019D60
9D019D28  00481021   ADDU V0, V0, T0
1199:                      vram_adr = ((tile_num & 1) << 12) | ((tile_num & 0xFE) << 4);
9D019D2C  306700FE   ANDI A3, V1, 254
9D019D30  00073900   SLL A3, A3, 4
9D019D34  30630001   ANDI V1, V1, 1
9D019D38  00031B00   SLL V1, V1, 12
9D019D3C  00E31825   OR V1, A3, V1
1200:                   /* else just use the offset from $2000 */
1201:                   else
1202:                      vram_adr = ppu.obj_base + (tile_num << 4);
9D019D60  00031900   SLL V1, V1, 4
9D019D64  24C76220   ADDIU A3, A2, 25120
9D019D68  8CE81180   LW T0, 4480(A3)
9D019D6C  00681821   ADDU V1, V1, T0
1203:                
1204:                   data_ptr = &PPU_MEM(vram_adr);
9D019D40  00034283   SRA T0, V1, 10
9D019D44  25080448   ADDIU T0, T0, 1096
9D019D48  00084080   SLL T0, T0, 2
9D019D4C  24C76220   ADDIU A3, A2, 25120
9D019D50  01073821   ADDU A3, T0, A3
9D019D54  8CE80000   LW T0, 0(A3)
9D019D58  0B4067C2   J 0x9D019F08
9D019D5C  01034021   ADDU T0, T0, V1
9D019D70  00034283   SRA T0, V1, 10
9D019D74  25080448   ADDIU T0, T0, 1096
9D019D78  00084080   SLL T0, T0, 2
9D019D7C  01073821   ADDU A3, T0, A3
9D019D80  8CE80000   LW T0, 0(A3)
1205:                
1206:                   for (line = 0; line < height; line++)
9D019D84  1E800060   BGTZ S4, 0x9D019F08
9D019D88  01034021   ADDU T0, T0, V1
9D019E58  25290001   ADDIU T1, T1, 1
9D019E5C  0134182A   SLT V1, T1, S4
9D019E60  1460FFCC   BNE V1, ZERO, 0x9D019D94
9D019E64  25130001   ADDIU S3, T0, 1
1207:                   {
1208:                      if (line == 8)
1209:                         data_ptr += 8;
9D019D94  25080009   ADDIU T0, T0, 9
9D019D98  012A1826   XOR V1, T1, T2
1210:                
1211:                      draw_bgtile(vid, data_ptr[0], data_ptr[8], ppu.palette + 16 + col_high);
9D019DA0  91130000   LBU S3, 0(T0)
9D019DA4  91030008   LBU V1, 8(T0)
9D019F0C  26731110   ADDIU S3, S3, 4368
9D019F10  24C76220   ADDIU A3, A2, 25120
9D019F14  0B406768   J 0x9D019DA0
9D019F18  00F33821   ADDU A3, A3, S3
1212:                      //draw_oamtile(vid, attrib, data_ptr[0], data_ptr[8], ppu.palette + 16 + col_high);
1213:                
1214:                      data_ptr++;
1215:                      vid += bmp->pitch;
9D019E50  8C830008   LW V1, 8(A0)
9D019E54  00431021   ADDU V0, V0, V1
1216:                   }
1217:                }
1218:                
1219:                void ppu_dumpoam(bitmap_t *bmp, int x_loc, int y_loc)
1220:                {
9D019BDC  27BDFFE0   ADDIU SP, SP, -32
9D019BE0  AFB5001C   SW S5, 28(SP)
9D019BE4  AFB40018   SW S4, 24(SP)
9D019BE8  AFB30014   SW S3, 20(SP)
9D019BEC  AFB20010   SW S2, 16(SP)
9D019BF0  AFB1000C   SW S1, 12(SP)
9D019BF4  AFB00008   SW S0, 8(SP)
9D019BF8  00A08021   ADDU S0, A1, ZERO
9D019BFC  00C09021   ADDU S2, A2, ZERO
1221:                   int sprite, x_pos, y_pos, height;
1222:                   obj_t *spr_ptr;
1223:                
1224:                   spr_ptr = (obj_t *) ppu.oam;
9D019C08  3C0FA000   LUI T7, -24576
9D019C0C  25EF7220   ADDIU T7, T7, 29216
1225:                   height = ppu.obj_height;
9D019C00  3C02A000   LUI V0, -24576
9D019C04  904C739C   LBU T4, 29596(V0)
1226:                
1227:                   for (sprite = 0; sprite < 64; sprite++)
9D019C10  0000C021   ADDU T8, ZERO, ZERO
9D019C30  3C11A000   LUI S1, -24576
9D019C34  26317320   ADDIU S1, S1, 29472
9D019EF0  15F1FF51   BNE T7, S1, 0x9D019C38
9D019EF4  27180001   ADDIU T8, T8, 1
9D019EF8  0B4067C7   J 0x9D019F1C
9D019EFC  8FB5001C   LW S5, 28(SP)
9D019F00  0B406735   J 0x9D019CD4
9D019F04  2443000A   ADDIU V1, V0, 10
1228:                   {
1229:                      x_pos = ((sprite & 0x0F) << 3) + (sprite & 0x0F) + x_loc;
9D019C38  3302000F   ANDI V0, T8, 15
9D019C3C  000240C0   SLL T0, V0, 3
9D019C40  00481021   ADDU V0, V0, T0
1230:                      if (height == 16)
9D019C14  24050010   ADDIU A1, ZERO, 16
9D019C44  15850006   BNE T4, A1, 0x9D019C60
9D019C48  00504021   ADDU T0, V0, S0
1231:                         y_pos = (sprite & 0xF0) + (sprite >> 4) + y_loc;
9D019C4C  330900F0   ANDI T1, T8, 240
9D019C50  00181103   SRA V0, T8, 4
9D019C54  01224821   ADDU T1, T1, V0
9D019C58  0B40671D   J 0x9D019C74
9D019C5C  01324821   ADDU T1, T1, S2
1232:                      else
1233:                         y_pos = ((sprite & 0xF0) >> 1) + (sprite >> 4) + y_loc;
9D019C60  330900F0   ANDI T1, T8, 240
9D019C64  00094843   SRA T1, T1, 1
9D019C68  00181103   SRA V0, T8, 4
9D019C6C  01224821   ADDU T1, T1, V0
9D019C70  01324821   ADDU T1, T1, S2
1234:                
1235:                      draw_box(bmp, x_pos, y_pos, height);
1236:                
1237:                      if (spr_ptr->y_loc && spr_ptr->y_loc < 240)
9D019CE0  91E20000   LBU V0, 0(T7)
9D019CE4  2442FFFF   ADDIU V0, V0, -1
9D019CE8  304200FF   ANDI V0, V0, 255
9D019CEC  2C4200EF   SLTIU V0, V0, 239
9D019CF0  5040005F   BEQL V0, ZERO, 0x9D019E70
9D019CF4  2722B648   ADDIU V0, T9, -18872
1238:                         draw_sprite(bmp, x_pos + 1, y_pos + 1, spr_ptr->tile, spr_ptr->atr);
9D019CF8  91E30001   LBU V1, 1(T7)
9D019D08  25080001   ADDIU T0, T0, 1
1239:                      else
1240:                         draw_deadsprite(bmp, x_pos + 1, y_pos + 1, height);
9D019E94  25080001   ADDIU T0, T0, 1
1241:                
1242:                      spr_ptr++;
9D019D8C  0B4067BC   J 0x9D019EF0
9D019D90  25EF0004   ADDIU T7, T7, 4
9D019E68  0B4067BC   J 0x9D019EF0
9D019E6C  25EF0004   ADDIU T7, T7, 4
9D019EEC  25EF0004   ADDIU T7, T7, 4
1243:                   }
1244:                }
9D019F1C  8FB40018   LW S4, 24(SP)
9D019F20  8FB30014   LW S3, 20(SP)
9D019F24  8FB20010   LW S2, 16(SP)
9D019F28  8FB1000C   LW S1, 12(SP)
9D019F2C  8FB00008   LW S0, 8(SP)
9D019F30  03E00008   JR RA
9D019F34  27BD0020   ADDIU SP, SP, 32
1245:                
1246:                /* More of a debugging thing than anything else */
1247:                void ppu_dumppattern(bitmap_t *bmp, int table_num, int x_loc, int y_loc, int col)
1248:                {
9D019F38  27BDFFF0   ADDIU SP, SP, -16
9D019F3C  AFB2000C   SW S2, 12(SP)
9D019F40  AFB10008   SW S1, 8(SP)
9D019F44  AFB00004   SW S0, 4(SP)
1249:                   int x_tile, y_tile;
1250:                   uint8 *bmp_ptr, *data_ptr, *ptr;
1251:                   int tile_num, line;
1252:                   uint8 col_high;
1253:                
1254:                   tile_num = 0;
9D019F68  0000C821   ADDU T9, ZERO, ZERO
1255:                   col_high = col << 2;
9D019F48  8FA20020   LW V0, 32(SP)
9D019F4C  00021080   SLL V0, V0, 2
9D019F50  304200FF   ANDI V0, V0, 255
1256:                
1257:                   for (y_tile = 0; y_tile < 16; y_tile++)
9D019F80  24110100   ADDIU S1, ZERO, 256
9D01A08C  1731FFBD   BNE T9, S1, 0x9D019F84
9D01A090  26100020   ADDIU S0, S0, 32
1258:                   {
1259:                      /* Get our pointer to the bitmap */
1260:                      bmp_ptr = bmp->line[y_loc] + x_loc;
9D019F84  8E0D0000   LW T5, 0(S0)
9D019F88  01A66821   ADDU T5, T5, A2
9D019F8C  25AF0080   ADDIU T7, T5, 128
9D019F90  03207021   ADDU T6, T9, ZERO
1261:                
1262:                      for (x_tile = 0; x_tile < 16; x_tile++)
9D01A080  15AFFFC4   BNE T5, T7, 0x9D019F94
9D01A084  25CE0001   ADDIU T6, T6, 1
9D01A088  27390010   ADDIU T9, T9, 16
1263:                      {
1264:                         data_ptr = &PPU_MEM((table_num << 12) + (tile_num << 4));
9D019F54  00052B00   SLL A1, A1, 12
9D019F58  24E70004   ADDIU A3, A3, 4
9D019F5C  00078080   SLL S0, A3, 2
9D019F60  00908021   ADDU S0, A0, S0
9D019F64  26100004   ADDIU S0, S0, 4
9D019F6C  3C18A000   LUI T8, -24576
9D019F70  27186220   ADDIU T8, T8, 25120
9D019F94  000E4100   SLL T0, T6, 4
9D019F98  00A84021   ADDU T0, A1, T0
9D019F9C  00081283   SRA V0, T0, 10
9D019FA0  24420448   ADDIU V0, V0, 1096
9D019FA4  00021080   SLL V0, V0, 2
9D019FA8  00581021   ADDU V0, V0, T8
9D019FAC  8C420000   LW V0, 0(V0)
9D019FB0  00484021   ADDU T0, V0, T0
9D019FB4  250C0008   ADDIU T4, T0, 8
9D019FB8  01A01021   ADDU V0, T5, ZERO
1265:                         ptr = bmp_ptr;
1266:                
1267:                         for (line = 0; line < 8; line ++)
9D01A074  150CFFD1   BNE T0, T4, 0x9D019FBC
9D01A078  00431021   ADDU V0, V0, V1
1268:                         {
1269:                            draw_bgtile(ptr, data_ptr[0], data_ptr[8], ppu.palette + col_high);
9D019F74  24421100   ADDIU V0, V0, 4352
9D019F78  03023821   ADDU A3, T8, V0
9D019FBC  91090000   LBU T1, 0(T0)
9D019FC0  910A0008   LBU T2, 8(T0)
1270:                            data_ptr++;
9D01A06C  25080001   ADDIU T0, T0, 1
1271:                            ptr += bmp->pitch;
9D01A070  8C830008   LW V1, 8(A0)
1272:                         }
1273:                
1274:                         bmp_ptr += 8;
9D01A07C  25AD0008   ADDIU T5, T5, 8
1275:                         tile_num++;
1276:                      }
1277:                      y_loc += 8;
1278:                   }
1279:                }
9D01A094  8FB2000C   LW S2, 12(SP)
9D01A098  8FB10008   LW S1, 8(SP)
9D01A09C  8FB00004   LW S0, 4(SP)
9D01A0A0  03E00008   JR RA
9D01A0A4  27BD0010   ADDIU SP, SP, 16
1280:                
1281:                /*
1282:                ** $Log: nes_ppu.c,v $
1283:                ** Revision 1.2  2001/04/27 14:37:11  neil
1284:                ** wheeee
1285:                **
1286:                ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
1287:                ** initial
1288:                **
1289:                ** Revision 1.14  2000/11/29 12:58:23  matt
1290:                ** timing/fiq fixes
1291:                **
1292:                ** Revision 1.13  2000/11/27 19:36:15  matt
1293:                ** more timing fixes
1294:                **
1295:                ** Revision 1.12  2000/11/26 15:51:13  matt
1296:                ** frame IRQ emulation
1297:                **
1298:                ** Revision 1.11  2000/11/25 20:30:39  matt
1299:                ** scanline emulation simplifications/timing fixes
1300:                **
1301:                ** Revision 1.10  2000/11/24 14:56:02  matt
1302:                ** fixed a long-standing sprite 0 strike bug
1303:                **
1304:                ** Revision 1.9  2000/11/20 13:23:17  matt
1305:                ** PPU fixes
1306:                **
1307:                ** Revision 1.8  2000/11/19 13:47:30  matt
1308:                ** problem with frame irqs fixed
1309:                **
1310:                ** Revision 1.7  2000/11/19 13:40:19  matt
1311:                ** more accurate ppu behavior
1312:                **
1313:                ** Revision 1.6  2000/11/14 12:09:37  matt
1314:                ** only generate the palette once, please
1315:                **
1316:                ** Revision 1.5  2000/11/11 14:51:43  matt
1317:                ** context get/set fixed
1318:                **
1319:                ** Revision 1.4  2000/11/09 12:35:50  matt
1320:                ** fixed timing problem with VRAM reads/writes
1321:                **
1322:                ** Revision 1.3  2000/11/05 16:35:41  matt
1323:                ** rolled rgb.h into bitmap.h
1324:                **
1325:                ** Revision 1.2  2000/10/27 12:55:03  matt
1326:                ** palette generating functions now take *this pointers
1327:                **
1328:                ** Revision 1.1  2000/10/24 12:20:28  matt
1329:                ** changed directory structure
1330:                **
1331:                ** Revision 1.33  2000/10/23 15:53:08  matt
1332:                ** better system handling
1333:                **
1334:                ** Revision 1.32  2000/10/22 15:02:32  matt
1335:                ** simplified mirroring
1336:                **
1337:                ** Revision 1.31  2000/10/21 21:36:04  matt
1338:                ** ppu cleanups / fixes
1339:                **
1340:                ** Revision 1.30  2000/10/21 19:26:59  matt
1341:                ** many more cleanups
1342:                **
1343:                ** Revision 1.29  2000/10/10 13:58:15  matt
1344:                ** stroustrup squeezing his way in the door
1345:                **
1346:                ** Revision 1.28  2000/10/08 17:54:32  matt
1347:                ** reject VRAM access out of VINT period
1348:                **
1349:                ** Revision 1.27  2000/09/15 04:58:07  matt
1350:                ** simplifying and optimizing APU core
1351:                **
1352:                ** Revision 1.26  2000/09/08 11:57:29  matt
1353:                ** no more nes_fiq
1354:                **
1355:                ** Revision 1.25  2000/09/07 21:57:31  matt
1356:                ** api change
1357:                **
1358:                ** Revision 1.24  2000/07/31 04:27:59  matt
1359:                ** one million cleanups
1360:                **
1361:                ** Revision 1.23  2000/07/30 06:13:12  matt
1362:                ** default to no FIQs on startup
1363:                **
1364:                ** Revision 1.22  2000/07/30 04:32:32  matt
1365:                ** emulation of the NES frame IRQ
1366:                **
1367:                ** Revision 1.21  2000/07/25 02:25:53  matt
1368:                ** safer xxx_destroy calls
1369:                **
1370:                ** Revision 1.20  2000/07/23 15:12:43  matt
1371:                ** removed unused variables, changed INLINE
1372:                **
1373:                ** Revision 1.19  2000/07/21 04:50:39  matt
1374:                ** moved palette calls out of nofrendo.c and into ppu_create
1375:                **
1376:                ** Revision 1.18  2000/07/17 05:12:55  matt
1377:                ** nes_ppu.c is no longer a scary place to be-- cleaner & faster
1378:                **
1379:                ** Revision 1.17  2000/07/17 01:52:28  matt
1380:                ** made sure last line of all source files is a newline
1381:                **
1382:                ** Revision 1.16  2000/07/11 04:42:39  matt
1383:                ** updated for new screen dimension defines
1384:                **
1385:                ** Revision 1.15  2000/07/10 19:10:16  matt
1386:                ** should bomb out now if a game tries to write to VROM
1387:                **
1388:                ** Revision 1.14  2000/07/10 05:28:30  matt
1389:                ** moved joypad/oam dma from apu to ppu
1390:                **
1391:                ** Revision 1.13  2000/07/10 03:03:16  matt
1392:                ** added ppu_getcontext() routine
1393:                **
1394:                ** Revision 1.12  2000/07/09 03:46:05  matt
1395:                ** using pitch instead of width...
1396:                **
1397:                ** Revision 1.11  2000/07/06 16:42:40  matt
1398:                ** better palette setting interface
1399:                **
1400:                ** Revision 1.10  2000/07/05 22:49:25  matt
1401:                ** changed mmc2 (punchout) tile-access switching
1402:                **
1403:                ** Revision 1.9  2000/07/04 23:13:26  matt
1404:                ** added an irq line drawing debug feature hack
1405:                **
1406:                ** Revision 1.8  2000/06/26 04:58:08  matt
1407:                ** accuracy changes
1408:                **
1409:                ** Revision 1.7  2000/06/22 02:13:49  matt
1410:                ** more accurate emulation of $2002
1411:                **
1412:                ** Revision 1.6  2000/06/20 20:42:47  matt
1413:                ** accuracy changes
1414:                **
1415:                ** Revision 1.5  2000/06/20 00:05:12  matt
1416:                ** tested and verified STAT quirk, added code
1417:                **
1418:                ** Revision 1.4  2000/06/09 15:12:26  matt
1419:                ** initial revision
1420:                **
1421:                */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/nes/nes_pal.c  -----------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** nes_pal.c
21:                  **
22:                  ** NES RGB palette
23:                  ** $Id: nes_pal.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <math.h>
27:                  #include <noftypes.h>
28:                  #include <bitmap.h>
29:                  #include <nes_pal.h>
30:                  
31:                  #ifndef PI
32:                  #define PI 3.1415926535897932384626433832795
33:                  #endif
34:                  
35:                  /* my NES palette, converted to RGB */
36:                  rgb_t shady_palette[] =
37:                  {
38:                     {0x80,0x80,0x80}, {0x00,0x00,0xBB}, {0x37,0x00,0xBF}, {0x84,0x00,0xA6},
39:                     {0xBB,0x00,0x6A}, {0xB7,0x00,0x1E}, {0xB3,0x00,0x00}, {0x91,0x26,0x00},
40:                     {0x7B,0x2B,0x00}, {0x00,0x3E,0x00}, {0x00,0x48,0x0D}, {0x00,0x3C,0x22},
41:                     {0x00,0x2F,0x66}, {0x00,0x00,0x00}, {0x05,0x05,0x05}, {0x05,0x05,0x05},
42:                  
43:                     {0xC8,0xC8,0xC8}, {0x00,0x59,0xFF}, {0x44,0x3C,0xFF}, {0xB7,0x33,0xCC},
44:                     {0xFF,0x33,0xAA}, {0xFF,0x37,0x5E}, {0xFF,0x37,0x1A}, {0xD5,0x4B,0x00},
45:                     {0xC4,0x62,0x00}, {0x3C,0x7B,0x00}, {0x1E,0x84,0x15}, {0x00,0x95,0x66},
46:                     {0x00,0x84,0xC4}, {0x11,0x11,0x11}, {0x09,0x09,0x09}, {0x09,0x09,0x09},
47:                  
48:                     {0xFF,0xFF,0xFF}, {0x00,0x95,0xFF}, {0x6F,0x84,0xFF}, {0xD5,0x6F,0xFF},
49:                     {0xFF,0x77,0xCC}, {0xFF,0x6F,0x99}, {0xFF,0x7B,0x59}, {0xFF,0x91,0x5F},
50:                     {0xFF,0xA2,0x33}, {0xA6,0xBF,0x00}, {0x51,0xD9,0x6A}, {0x4D,0xD5,0xAE},
51:                     {0x00,0xD9,0xFF}, {0x66,0x66,0x66}, {0x0D,0x0D,0x0D}, {0x0D,0x0D,0x0D},
52:                  
53:                     {0xFF,0xFF,0xFF}, {0x84,0xBF,0xFF}, {0xBB,0xBB,0xFF}, {0xD0,0xBB,0xFF},
54:                     {0xFF,0xBF,0xEA}, {0xFF,0xBF,0xCC}, {0xFF,0xC4,0xB7}, {0xFF,0xCC,0xAE},
55:                     {0xFF,0xD9,0xA2}, {0xCC,0xE1,0x99}, {0xAE,0xEE,0xB7}, {0xAA,0xF7,0xEE},
56:                     {0xB3,0xEE,0xFF}, {0xDD,0xDD,0xDD}, {0x11,0x11,0x11}, {0x11,0x11,0x11}
57:                  };
58:                  
59:                  /* dynamic palette building routines,
60:                  ** care of Kevin Horton (khorton@iquest.net)
61:                  */
62:                  
63:                  /* our global palette */
64:                  rgb_t nes_palette[64];
65:                  
66:                  
67:                  static float hue = 334.0f;
68:                  static float tint = 0.4f;
69:                  
70:                  #include <gui.h>
71:                  
72:                  void pal_dechue(void)
73:                  {
9D0306A0  27BDFFE8   ADDIU SP, SP, -24
9D0306A4  AFBF0014   SW RA, 20(SP)
74:                     hue -= 0.5f;
9D0306A8  8F848014   LW A0, -32748(GP)
9D0306AC  3C029D04   LUI V0, -25340
9D0306B0  0F40CFF8   JAL __subsf3
9D0306B4  8C4599B0   LW A1, -26192(V0)
9D0306B8  AF828014   SW V0, -32748(GP)
75:                     gui_sendmsg(GUI_GREEN, "hue: %.02f", hue);
9D0306BC  240400C6   ADDIU A0, ZERO, 198
9D0306C0  3C059D04   LUI A1, -25340
9D0306C4  24A59904   ADDIU A1, A1, -26364
9D0306C8  0F409020   JAL gui_sendmsg
9D0306CC  00403021   ADDU A2, V0, ZERO
76:                     pal_generate();
9D0306D0  0F40C0F7   JAL pal_generate
9D0306D4  00000000   NOP
77:                  }
9D0306D8  8FBF0014   LW RA, 20(SP)
9D0306DC  03E00008   JR RA
9D0306E0  27BD0018   ADDIU SP, SP, 24
78:                  void pal_inchue(void)
79:                  {
9D0306E4  27BDFFE8   ADDIU SP, SP, -24
9D0306E8  AFBF0014   SW RA, 20(SP)
80:                     hue += 0.5f;
9D0306EC  8F848014   LW A0, -32748(GP)
9D0306F0  3C029D04   LUI V0, -25340
9D0306F4  0F40CFFA   JAL fpadd
9D0306F8  8C4599B0   LW A1, -26192(V0)
9D0306FC  AF828014   SW V0, -32748(GP)
81:                     gui_sendmsg(GUI_GREEN, "hue: %.02f", hue);
9D030700  240400C6   ADDIU A0, ZERO, 198
9D030704  3C059D04   LUI A1, -25340
9D030708  24A59904   ADDIU A1, A1, -26364
9D03070C  0F409020   JAL gui_sendmsg
9D030710  00403021   ADDU A2, V0, ZERO
82:                     pal_generate();
9D030714  0F40C0F7   JAL pal_generate
9D030718  00000000   NOP
83:                  }
9D03071C  8FBF0014   LW RA, 20(SP)
9D030720  03E00008   JR RA
9D030724  27BD0018   ADDIU SP, SP, 24
84:                  void pal_dectint(void)
85:                  {
9D030728  27BDFFE8   ADDIU SP, SP, -24
9D03072C  AFBF0014   SW RA, 20(SP)
86:                     tint -= 0.01f;
9D030730  8F848010   LW A0, -32752(GP)
9D030734  3C029D04   LUI V0, -25340
9D030738  0F40CFF8   JAL __subsf3
9D03073C  8C4599B4   LW A1, -26188(V0)
9D030740  AF828010   SW V0, -32752(GP)
87:                     gui_sendmsg(GUI_GREEN, "tint: %.02f", tint);
9D030744  240400C6   ADDIU A0, ZERO, 198
9D030748  3C059D04   LUI A1, -25340
9D03074C  24A59910   ADDIU A1, A1, -26352
9D030750  0F409020   JAL gui_sendmsg
9D030754  00403021   ADDU A2, V0, ZERO
88:                     pal_generate();
9D030758  0F40C0F7   JAL pal_generate
9D03075C  00000000   NOP
89:                  }
9D030760  8FBF0014   LW RA, 20(SP)
9D030764  03E00008   JR RA
9D030768  27BD0018   ADDIU SP, SP, 24
90:                  void pal_inctint(void)
91:                  {
9D03076C  27BDFFE8   ADDIU SP, SP, -24
9D030770  AFBF0014   SW RA, 20(SP)
92:                     tint += 0.01f;
9D030774  8F848010   LW A0, -32752(GP)
9D030778  3C029D04   LUI V0, -25340
9D03077C  0F40CFFA   JAL fpadd
9D030780  8C4599B4   LW A1, -26188(V0)
9D030784  AF828010   SW V0, -32752(GP)
93:                     gui_sendmsg(GUI_GREEN, "tint: %.02f", tint);
9D030788  240400C6   ADDIU A0, ZERO, 198
9D03078C  3C059D04   LUI A1, -25340
9D030790  24A59910   ADDIU A1, A1, -26352
9D030794  0F409020   JAL gui_sendmsg
9D030798  00403021   ADDU A2, V0, ZERO
94:                     pal_generate();
9D03079C  0F40C0F7   JAL pal_generate
9D0307A0  00000000   NOP
95:                  }
9D0307A4  8FBF0014   LW RA, 20(SP)
9D0307A8  03E00008   JR RA
9D0307AC  27BD0018   ADDIU SP, SP, 24
96:                  
97:                  static const float brightness[4][4] = 
98:                  {
99:                     { 0.50f, 0.75f, 1.00f, 1.00f },
100:                    { 0.29f, 0.45f, 0.73f, 0.90f },
101:                    { 0.00f, 0.24f, 0.47f, 0.77f },
102:                    { 0.02f, 0.04f, 0.05f, 0.07f }
103:                 };
104:                 
105:                 static const int col_angles[16] =
106:                 {
107:                    0, 240, 210, 180, 150, 120, 90, 60, 30, 0, 330, 300, 270, 0, 0, 0
108:                 };
109:                 
110:                 void pal_generate(void)
111:                 {
9D0303DC  27BDFFB8   ADDIU SP, SP, -72
9D0303E0  AFBF0044   SW RA, 68(SP)
9D0303E4  AFBE0040   SW FP, 64(SP)
9D0303E8  AFB7003C   SW S7, 60(SP)
9D0303EC  AFB60038   SW S6, 56(SP)
9D0303F0  AFB50034   SW S5, 52(SP)
9D0303F4  AFB40030   SW S4, 48(SP)
9D0303F8  AFB3002C   SW S3, 44(SP)
9D0303FC  AFB20028   SW S2, 40(SP)
9D030400  AFB10024   SW S1, 36(SP)
9D030404  AFB00020   SW S0, 32(SP)
112:                    int x, z;
113:                    float s, y, theta;
114:                    int r, g, b;
115:                 
116:                    for (x = 0; x < 4; x++)
9D030424  AFA00018   SW ZERO, 24(SP)
9D030428  0B40C191   J 0x9D030644
9D03042C  241500FF   ADDIU S5, ZERO, 255
9D030624  8FA20018   LW V0, 24(SP)
9D030628  24420001   ADDIU V0, V0, 1
9D03062C  AFA20018   SW V0, 24(SP)
9D030630  8FA30010   LW V1, 16(SP)
9D030634  24630004   ADDIU V1, V1, 4
9D030638  24040004   ADDIU A0, ZERO, 4
9D03063C  1044000C   BEQ V0, A0, 0x9D030670
9D030640  AFA30010   SW V1, 16(SP)
9D030644  3C029D04   LUI V0, -25340
9D030648  2454991C   ADDIU S4, V0, -26340
9D03064C  8FA30018   LW V1, 24(SP)
9D030650  00038980   SLL S1, V1, 6
9D030654  00031200   SLL V0, V1, 8
9D030658  00518823   SUBU S1, V0, S1
9D03065C  3C04A000   LUI A0, -24576
9D030660  248405E0   ADDIU A0, A0, 1504
9D030664  00918821   ADDU S1, A0, S1
117:                    {
118:                       for (z = 0; z < 16; z++)
9D030610  26100001   ADDIU S0, S0, 1
9D030614  26940004   ADDIU S4, S4, 4
9D030618  24040010   ADDIU A0, ZERO, 16
9D03061C  1604FF84   BNE S0, A0, 0x9D030430
9D030620  2631000C   ADDIU S1, S1, 12
119:                       {
120:                          switch (z)
9D030430  2404000D   ADDIU A0, ZERO, 13
9D030434  1204000E   BEQ S0, A0, 0x9D030470
9D030438  2A02000E   SLTI V0, S0, 14
9D03043C  10400005   BEQ V0, ZERO, 0x9D030454
9D030440  2A020010   SLTI V0, S0, 16
9D030444  12000007   BEQ S0, ZERO, 0x9D030464
9D030448  8FA20010   LW V0, 16(SP)
9D030454  5440000A   BNEL V0, ZERO, 0x9D030480
9D030458  8FA40010   LW A0, 16(SP)
121:                          {
122:                          case 0:
123:                             /* is color $x0?  If so, get luma */
124:                             s = 0;
125:                             y = brightness[0][x];
9D030464  8C530000   LW S3, 0(V0)
126:                             break;
9D030468  0B40C125   J 0x9D030494
9D03046C  00009021   ADDU S2, ZERO, ZERO
127:                 
128:                          case 13:
129:                             /* is color $xD?  If so, get luma */
130:                             s = 0;
131:                             y = brightness[2][x];
9D030470  8FA30010   LW V1, 16(SP)
9D030474  8C730020   LW S3, 32(V1)
132:                             break;
9D030478  0B40C125   J 0x9D030494
9D03047C  00009021   ADDU S2, ZERO, ZERO
133:                 
134:                          case 14:
135:                          case 15:
136:                             /* is color $xE/F?  If so, set to black */
137:                             s = 0;
138:                             y = brightness[3][x];
9D030480  8C930030   LW S3, 48(A0)
139:                             
140:                             break;
9D030484  0B40C125   J 0x9D030494
9D030488  00009021   ADDU S2, ZERO, ZERO
141:                 
142:                          default:
143:                             s = tint;                  /* grab tint */
9D030408  8F828010   LW V0, -32752(GP)
9D03040C  AFA2001C   SW V0, 28(SP)
9D030490  8FB2001C   LW S2, 28(SP)
144:                             y = brightness[1][x];      /* grab default luminance */
9D03044C  0B40C124   J 0x9D030490
9D030450  8C530010   LW S3, 16(V0)
9D03045C  0B40C123   J 0x9D03048C
9D030460  8FA20010   LW V0, 16(SP)
9D03048C  8C530010   LW S3, 16(V0)
145:                             break;
146:                          }
147:                 
148:                          theta = (float) (PI * ((col_angles[z] + hue) / 180.0));
9D030410  8F838014   LW V1, -32748(GP)
9D030414  AFA30014   SW V1, 20(SP)
9D030418  3C029D04   LUI V0, -25340
9D03041C  2442995C   ADDIU V0, V0, -26276
9D030420  AFA20010   SW V0, 16(SP)
9D030494  0F40ECB4   JAL sitofp
9D030498  8E840000   LW A0, 0(S4)
9D03049C  00402021   ADDU A0, V0, ZERO
9D0304A0  0F40CFFA   JAL fpadd
9D0304A4  8FA50014   LW A1, 20(SP)
9D0304A8  00402021   ADDU A0, V0, ZERO
9D0304AC  3C039D04   LUI V1, -25340
9D0304B0  2463999C   ADDIU V1, V1, -26212
9D0304B4  0F40D242   JAL __divsf3
9D0304B8  8C650000   LW A1, 0(V1)
9D0304BC  00402021   ADDU A0, V0, ZERO
9D0304C0  3C029D04   LUI V0, -25340
9D0304C4  244299A0   ADDIU V0, V0, -26208
9D0304C8  0F40D562   JAL __mulsf3
9D0304CC  8C450000   LW A1, 0(V0)
9D0304D0  0040F021   ADDU FP, V0, ZERO
149:                 
150:                          r = (int) (256.0 * (y + s * sin(theta)));
9D0304D4  0F40DE80   JAL fpsin, sinf
9D0304D8  00402021   ADDU A0, V0, ZERO
9D0304DC  0040B021   ADDU S6, V0, ZERO
9D0304E0  00402021   ADDU A0, V0, ZERO
9D0304E4  0F40D562   JAL __mulsf3
9D0304E8  02402821   ADDU A1, S2, ZERO
9D0304EC  00402021   ADDU A0, V0, ZERO
9D0304F0  0F40CFFA   JAL fpadd
9D0304F4  02602821   ADDU A1, S3, ZERO
9D0304F8  00402021   ADDU A0, V0, ZERO
9D0304FC  3C039D04   LUI V1, -25340
9D030500  246399A4   ADDIU V1, V1, -26204
9D030504  0F40D562   JAL __mulsf3
9D030508  8C650000   LW A1, 0(V1)
9D03050C  0F40EA89   JAL __fixsfsi
9D030510  00402021   ADDU A0, V0, ZERO
9D030514  0040B821   ADDU S7, V0, ZERO
151:                          g = (int) (256.0 * (y - ((27 / 53.0) * s * sin(theta)) + ((10 / 53.0) * s * cos(theta))));
9D030518  0F40DF0D   JAL fpcos, cosf
9D03051C  03C02021   ADDU A0, FP, ZERO
9D030520  0040F021   ADDU FP, V0, ZERO
9D030524  02402021   ADDU A0, S2, ZERO
9D030528  3C029D04   LUI V0, -25340
9D03052C  244299A8   ADDIU V0, V0, -26200
9D030530  0F40D562   JAL __mulsf3
9D030534  8C450000   LW A1, 0(V0)
9D030538  02C02021   ADDU A0, S6, ZERO
9D03053C  0F40D562   JAL __mulsf3
9D030540  00402821   ADDU A1, V0, ZERO
9D030544  02602021   ADDU A0, S3, ZERO
9D030548  0F40CFF8   JAL __subsf3
9D03054C  00402821   ADDU A1, V0, ZERO
9D030550  0040B021   ADDU S6, V0, ZERO
9D030554  02402021   ADDU A0, S2, ZERO
9D030558  3C039D04   LUI V1, -25340
9D03055C  246399AC   ADDIU V1, V1, -26196
9D030560  0F40D562   JAL __mulsf3
9D030564  8C650000   LW A1, 0(V1)
9D030568  00402021   ADDU A0, V0, ZERO
9D03056C  0F40D562   JAL __mulsf3
9D030570  03C02821   ADDU A1, FP, ZERO
9D030574  02C02021   ADDU A0, S6, ZERO
9D030578  0F40CFFA   JAL fpadd
9D03057C  00402821   ADDU A1, V0, ZERO
9D030580  00402021   ADDU A0, V0, ZERO
9D030584  3C029D04   LUI V0, -25340
9D030588  244299A4   ADDIU V0, V0, -26204
9D03058C  0F40D562   JAL __mulsf3
9D030590  8C450000   LW A1, 0(V0)
9D030594  0F40EA89   JAL __fixsfsi
9D030598  00402021   ADDU A0, V0, ZERO
9D03059C  0040B021   ADDU S6, V0, ZERO
152:                          b = (int) (256.0 * (y - (s * cos(theta))));
9D0305A0  02402021   ADDU A0, S2, ZERO
9D0305A4  0F40D562   JAL __mulsf3
9D0305A8  03C02821   ADDU A1, FP, ZERO
9D0305AC  02602021   ADDU A0, S3, ZERO
9D0305B0  0F40CFF8   JAL __subsf3
9D0305B4  00402821   ADDU A1, V0, ZERO
9D0305B8  00402021   ADDU A0, V0, ZERO
9D0305BC  3C039D04   LUI V1, -25340
9D0305C0  246399A4   ADDIU V1, V1, -26204
9D0305C4  0F40D562   JAL __mulsf3
9D0305C8  8C650000   LW A1, 0(V1)
9D0305CC  0F40EA89   JAL __fixsfsi
9D0305D0  00402021   ADDU A0, V0, ZERO
9D0305D4  2AE30000   SLTI V1, S7, 0
9D0305D8  0003B80B   MOVN S7, ZERO, V1
9D0305DC  2AC30000   SLTI V1, S6, 0
9D0305E0  0003B00B   MOVN S6, ZERO, V1
9D0305E4  28430000   SLTI V1, V0, 0
9D0305E8  0003100B   MOVN V0, ZERO, V1
9D0305EC  2AE30100   SLTI V1, S7, 256
9D0305F0  02A3B80A   MOVZ S7, S5, V1
153:                 
154:                          if (r > 255)
155:                             r = 255;
156:                          else if (r < 0)
157:                             r = 0;
158:                 
159:                          if (g > 255)
160:                             g = 255;
161:                          else if (g < 0)
162:                             g = 0;
163:                 
164:                          if (b > 255)
165:                             b = 255;
166:                          else if (b < 0)
167:                             b = 0;
168:                 
169:                          nes_palette[(x << 4) + z].r = r;
9D0305F4  AE370000   SW S7, 0(S1)
9D0305F8  2AC30100   SLTI V1, S6, 256
9D0305FC  02A3B00A   MOVZ S6, S5, V1
9D030668  0B40C10C   J 0x9D030430
9D03066C  00008021   ADDU S0, ZERO, ZERO
170:                          nes_palette[(x << 4) + z].g = g;
9D030600  AE360004   SW S6, 4(S1)
9D030604  28430100   SLTI V1, V0, 256
9D030608  02A3100A   MOVZ V0, S5, V1
171:                          nes_palette[(x << 4) + z].b = b;
9D03060C  AE220008   SW V0, 8(S1)
172:                       }
173:                    }   
174:                 }
9D030670  8FBF0044   LW RA, 68(SP)
9D030674  8FBE0040   LW FP, 64(SP)
9D030678  8FB7003C   LW S7, 60(SP)
9D03067C  8FB60038   LW S6, 56(SP)
9D030680  8FB50034   LW S5, 52(SP)
9D030684  8FB40030   LW S4, 48(SP)
9D030688  8FB3002C   LW S3, 44(SP)
9D03068C  8FB20028   LW S2, 40(SP)
9D030690  8FB10024   LW S1, 36(SP)
9D030694  8FB00020   LW S0, 32(SP)
9D030698  03E00008   JR RA
9D03069C  27BD0048   ADDIU SP, SP, 72
175:                 
176:                 /*
177:                 ** $Log: nes_pal.c,v $
178:                 ** Revision 1.2  2001/04/27 14:37:11  neil
179:                 ** wheeee
180:                 **
181:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
182:                 ** initial
183:                 **
184:                 ** Revision 1.3  2000/11/06 02:17:18  matt
185:                 ** no more double->float warnings
186:                 **
187:                 ** Revision 1.2  2000/11/05 16:35:41  matt
188:                 ** rolled rgb.h into bitmap.h
189:                 **
190:                 ** Revision 1.1  2000/10/24 12:20:28  matt
191:                 ** changed directory structure
192:                 **
193:                 ** Revision 1.9  2000/07/17 01:52:28  matt
194:                 ** made sure last line of all source files is a newline
195:                 **
196:                 ** Revision 1.8  2000/07/10 13:49:31  matt
197:                 ** renamed my palette and extern'ed it
198:                 **
199:                 ** Revision 1.7  2000/06/26 04:59:13  matt
200:                 ** selectable tint/hue hack (just for the time being)
201:                 **
202:                 ** Revision 1.6  2000/06/21 21:48:19  matt
203:                 ** changed range multiplier from 255.0 to 256.0
204:                 **
205:                 ** Revision 1.5  2000/06/20 20:42:47  matt
206:                 ** accuracy changes
207:                 **
208:                 ** Revision 1.4  2000/06/09 15:12:26  matt
209:                 ** initial revision
210:                 **
211:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/nes/nes_mmc.c  -----------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** nes_mmc.c
21:                  **
22:                  ** NES Memory Management Controller (mapper) emulation
23:                  ** $Id: nes_mmc.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <string.h>
27:                  #include <noftypes.h>
28:                  #include "nes6502.h"
29:                  #include <nes_mmc.h>
30:                  #include <nes_ppu.h>
31:                  #include <libsnss.h>
32:                  #include <log.h>
33:                  #include <mmclist.h>
34:                  #include <nes_rom.h>
35:                  
36:                  #define  MMC_8KROM         (mmc.cart->rom_banks * 2)
37:                  #define  MMC_16KROM        (mmc.cart->rom_banks)
38:                  #define  MMC_32KROM        (mmc.cart->rom_banks / 2)
39:                  #define  MMC_8KVROM        (mmc.cart->vrom_banks)
40:                  #define  MMC_4KVROM        (mmc.cart->vrom_banks * 2)
41:                  #define  MMC_2KVROM        (mmc.cart->vrom_banks * 4)
42:                  #define  MMC_1KVROM        (mmc.cart->vrom_banks * 8)
43:                  
44:                  #define  MMC_LAST8KROM     (MMC_8KROM - 1)
45:                  #define  MMC_LAST16KROM    (MMC_16KROM - 1)
46:                  #define  MMC_LAST32KROM    (MMC_32KROM - 1)
47:                  #define  MMC_LAST8KVROM    (MMC_8KVROM - 1)
48:                  #define  MMC_LAST4KVROM    (MMC_4KVROM - 1)
49:                  #define  MMC_LAST2KVROM    (MMC_2KVROM - 1)
50:                  #define  MMC_LAST1KVROM    (MMC_1KVROM - 1)
51:                  
52:                  static mmc_t mmc;
53:                  
54:                  rominfo_t *mmc_getinfo(void)
55:                  {
56:                     return mmc.cart;
57:                  }
9D02C770  03E00008   JR RA
9D02C774  8F8280F4   LW V0, -32524(GP)
58:                  
59:                  void mmc_setcontext(mmc_t *src_mmc)
60:                  {
61:                     ASSERT(src_mmc);
62:                  
63:                     mmc = *src_mmc;
9D02C778  8C830000   LW V1, 0(A0)
9D02C77C  8C820004   LW V0, 4(A0)
9D02C780  AF8380F0   SW V1, -32528(GP)
9D02C784  03E00008   JR RA
9D02C788  AF8280F4   SW V0, -32524(GP)
64:                  }
65:                  
66:                  void mmc_getcontext(mmc_t *dest_mmc)
67:                  {
68:                     *dest_mmc = mmc;
9D02C78C  8F8280F0   LW V0, -32528(GP)
9D02C790  AC820000   SW V0, 0(A0)
9D02C794  8F8280F4   LW V0, -32524(GP)
9D02C798  03E00008   JR RA
9D02C79C  AC820004   SW V0, 4(A0)
69:                  }
70:                  
71:                  /* VROM bankswitching */
72:                  void mmc_bankvrom(int size, uint32 address, int bank)
73:                  {
9D02C7A0  27BDFFE8   ADDIU SP, SP, -24
9D02C7A4  AFBF0014   SW RA, 20(SP)
9D02C7A8  00801021   ADDU V0, A0, ZERO
74:                     if (0 == mmc.cart->vrom_banks)
9D02C7AC  8F8480F4   LW A0, -32524(GP)
9D02C7B0  8C830014   LW V1, 20(A0)
9D02C7B4  10600055   BEQ V1, ZERO, .LVL31
9D02C7B8  24070002   ADDIU A3, ZERO, 2
75:                        return;
76:                  
77:                     switch (size)
9D02C7BC  10470020   BEQ V0, A3, 0x9D02C840
9D02C7C0  28470003   SLTI A3, V0, 3
9D02C7C4  10E00006   BEQ A3, ZERO, 0x9D02C7E0
9D02C7C8  24070004   ADDIU A3, ZERO, 4
9D02C7CC  24070001   ADDIU A3, ZERO, 1
9D02C7D0  5047000A   BEQL V0, A3, 0x9D02C7FC
9D02C7D4  2402FFFF   ADDIU V0, ZERO, -1
9D02C7E0  50470029   BEQL V0, A3, 0x9D02C888
9D02C7E4  2402FFFF   ADDIU V0, ZERO, -1
9D02C7E8  24050008   ADDIU A1, ZERO, 8
9D02C7EC  50450037   BEQL V0, A1, 0x9D02C8CC
9D02C7F0  2462FFFF   ADDIU V0, V1, -1
78:                     {
79:                     case 1:
80:                        if (bank == MMC_LASTBANK)
9D02C7FC  54C20004   BNEL A2, V0, 0x9D02C810
9D02C800  000318C0   SLL V1, V1, 3
81:                           bank = MMC_LAST1KVROM;
9D02C804  000330C0   SLL A2, V1, 3
9D02C808  24C6FFFF   ADDIU A2, A2, -1
82:                        ppu_setpage(1, address >> 10, &mmc.cart->vrom[(bank % MMC_1KVROM) << 10] - address);
9D02C80C  000318C0   SLL V1, V1, 3
9D02C810  00C3001A   DIV A2, V1
9D02C814  006001F4   TEQ V1, ZERO
9D02C818  00001010   MFHI V0
9D02C81C  00021A80   SLL V1, V0, 10
9D02C820  00651823   SUBU V1, V1, A1
9D02C824  8C860004   LW A2, 4(A0)
9D02C828  24040001   ADDIU A0, ZERO, 1
9D02C82C  00052A82   SRL A1, A1, 10
9D02C830  0F4060DF   JAL ppu_setpage
9D02C834  00C33021   ADDU A2, A2, V1
83:                        break;
9D02C838  0B40B244   J 0x9D02C910
9D02C83C  8FBF0014   LW RA, 20(SP)
84:                  
85:                     case 2:
86:                        if (bank == MMC_LASTBANK)
9D02C840  2402FFFF   ADDIU V0, ZERO, -1
9D02C844  54C20004   BNEL A2, V0, 0x9D02C858
9D02C848  00031880   SLL V1, V1, 2
87:                           bank = MMC_LAST2KVROM;
9D02C84C  00033080   SLL A2, V1, 2
9D02C850  24C6FFFF   ADDIU A2, A2, -1
88:                        ppu_setpage(2, address >> 10, &mmc.cart->vrom[(bank % MMC_2KVROM) << 11] - address);
9D02C854  00031880   SLL V1, V1, 2
9D02C858  00C3001A   DIV A2, V1
9D02C85C  006001F4   TEQ V1, ZERO
9D02C860  00001010   MFHI V0
9D02C864  00021AC0   SLL V1, V0, 11
9D02C868  00651823   SUBU V1, V1, A1
9D02C86C  8C860004   LW A2, 4(A0)
9D02C870  24040002   ADDIU A0, ZERO, 2
9D02C874  00052A82   SRL A1, A1, 10
9D02C878  0F4060DF   JAL ppu_setpage
9D02C87C  00C33021   ADDU A2, A2, V1
89:                        break;
9D02C880  0B40B244   J 0x9D02C910
9D02C884  8FBF0014   LW RA, 20(SP)
90:                  
91:                     case 4:
92:                        if (bank == MMC_LASTBANK)
9D02C888  54C20004   BNEL A2, V0, 0x9D02C89C
9D02C88C  00031840   SLL V1, V1, 1
93:                           bank = MMC_LAST4KVROM;
9D02C890  00033040   SLL A2, V1, 1
9D02C894  24C6FFFF   ADDIU A2, A2, -1
94:                        ppu_setpage(4, address >> 10, &mmc.cart->vrom[(bank % MMC_4KVROM) << 12] - address);
9D02C898  00031840   SLL V1, V1, 1
9D02C89C  00C3001A   DIV A2, V1
9D02C8A0  006001F4   TEQ V1, ZERO
9D02C8A4  00001010   MFHI V0
9D02C8A8  00021B00   SLL V1, V0, 12
9D02C8AC  00651823   SUBU V1, V1, A1
9D02C8B0  8C860004   LW A2, 4(A0)
9D02C8B4  24040004   ADDIU A0, ZERO, 4
9D02C8B8  00052A82   SRL A1, A1, 10
9D02C8BC  0F4060DF   JAL ppu_setpage
9D02C8C0  00C33021   ADDU A2, A2, V1
95:                        break;
9D02C8C4  0B40B244   J 0x9D02C910
9D02C8C8  8FBF0014   LW RA, 20(SP)
96:                  
97:                     case 8:
98:                        if (bank == MMC_LASTBANK)
99:                           bank = MMC_LAST8KVROM;
9D02C8CC  00062827   NOR A1, ZERO, A2
9D02C8D0  0045300A   MOVZ A2, V0, A1
100:                       ppu_setpage(8, 0, &mmc.cart->vrom[(bank % MMC_8KVROM) << 13]);
9D02C8D4  00C3001A   DIV A2, V1
9D02C8D8  006001F4   TEQ V1, ZERO
9D02C8DC  00001010   MFHI V0
9D02C8E0  00021B40   SLL V1, V0, 13
9D02C8E4  8C860004   LW A2, 4(A0)
9D02C8E8  24040008   ADDIU A0, ZERO, 8
9D02C8EC  00002821   ADDU A1, ZERO, ZERO
9D02C8F0  0F4060DF   JAL ppu_setpage
9D02C8F4  00C33021   ADDU A2, A2, V1
101:                       break;
9D02C8F8  0B40B244   J 0x9D02C910
9D02C8FC  8FBF0014   LW RA, 20(SP)
102:                 
103:                    default:
104:                       log_printf("invalid VROM bank size %d\n", size);
9D02C7D8  0B40B240   J 0x9D02C900
9D02C7DC  3C049D04   LUI A0, -25340
9D02C7F4  0B40B240   J 0x9D02C900
9D02C7F8  3C049D04   LUI A0, -25340
9D02C900  2484A8A0   ADDIU A0, A0, -22368
9D02C904  0F40EEE8   JAL log_printf
9D02C908  00402821   ADDU A1, V0, ZERO
105:                    }
106:                 }
9D02C90C  8FBF0014   LW RA, 20(SP)
9D02C910  03E00008   JR RA
9D02C914  27BD0018   ADDIU SP, SP, 24
107:                 
108:                 /* ROM bankswitching */
109:                 void mmc_bankrom(int size, uint32 address, int bank)
110:                 {
9D02C918  27BDFF80   ADDIU SP, SP, -128
9D02C91C  AFBF007C   SW RA, 124(SP)
9D02C920  AFB20078   SW S2, 120(SP)
9D02C924  AFB10074   SW S1, 116(SP)
9D02C928  AFB00070   SW S0, 112(SP)
9D02C92C  00808821   ADDU S1, A0, ZERO
9D02C930  00A09021   ADDU S2, A1, ZERO
9D02C934  00C08021   ADDU S0, A2, ZERO
111:                    nes6502_context mmc_cpu;
112:                 
113:                    nes6502_getcontext(&mmc_cpu); 
9D02C938  0F40289D   JAL nes6502_getcontext
9D02C93C  27A40010   ADDIU A0, SP, 16
114:                 
115:                    switch (size)
9D02C940  24020010   ADDIU V0, ZERO, 16
9D02C944  1222001F   BEQ S1, V0, 0x9D02C9C4
9D02C948  24020020   ADDIU V0, ZERO, 32
9D02C94C  12220042   BEQ S1, V0, 0x9D02CA58
9D02C950  24020008   ADDIU V0, ZERO, 8
9D02C954  56220063   BNEL S1, V0, 0x9D02CAE4
9D02C958  3C049D04   LUI A0, -25340
116:                    {
117:                    case 8:
118:                       if (bank == MMC_LASTBANK)
9D02C95C  2402FFFF   ADDIU V0, ZERO, -1
9D02C960  16020005   BNE S0, V0, .LBB2
9D02C964  00129302   SRL S2, S2, 12
119:                          bank = MMC_LAST8KROM;
9D02C968  8F8280F4   LW V0, -32524(GP)
9D02C96C  8C500010   LW S0, 16(V0)
9D02C970  00108040   SLL S0, S0, 1
9D02C974  2610FFFF   ADDIU S0, S0, -1
120:                       {
121:                          int page = address >> NES6502_BANKSHIFT;
122:                          mmc_cpu.mem_page[page] = &mmc.cart->rom[(bank % MMC_8KROM) << 13];
9D02C978  8F8280F4   LW V0, -32524(GP)
9D02C97C  8C430010   LW V1, 16(V0)
9D02C980  00031840   SLL V1, V1, 1
9D02C984  0203001A   DIV S0, V1
9D02C988  006001F4   TEQ V1, ZERO
9D02C98C  00002010   MFHI A0
9D02C990  00048340   SLL S0, A0, 13
9D02C994  8C420000   LW V0, 0(V0)
9D02C998  00508021   ADDU S0, V0, S0
9D02C99C  00121080   SLL V0, S2, 2
9D02C9A0  27A30010   ADDIU V1, SP, 16
9D02C9A4  00621021   ADDU V0, V1, V0
9D02C9A8  AC500000   SW S0, 0(V0)
123:                          mmc_cpu.mem_page[page + 1] = mmc_cpu.mem_page[page] + 0x1000;
9D02C9AC  26520001   ADDIU S2, S2, 1
9D02C9B0  00129080   SLL S2, S2, 2
9D02C9B4  00729021   ADDU S2, V1, S2
9D02C9B8  26101000   ADDIU S0, S0, 4096
124:                       }
125:                 
126:                       break;
9D02C9BC  0B40B2BC   J .LVL51
9D02C9C0  AE500000   SW S0, 0(S2)
127:                 
128:                    case 16:
129:                       if (bank == MMC_LASTBANK)
9D02C9C4  2402FFFF   ADDIU V0, ZERO, -1
9D02C9C8  16020004   BNE S0, V0, .LBB3
9D02C9CC  00129302   SRL S2, S2, 12
130:                          bank = MMC_LAST16KROM;
9D02C9D0  8F8280F4   LW V0, -32524(GP)
9D02C9D4  8C500010   LW S0, 16(V0)
9D02C9D8  2610FFFF   ADDIU S0, S0, -1
131:                       {
132:                          int page = address >> NES6502_BANKSHIFT;
133:                          mmc_cpu.mem_page[page] = &mmc.cart->rom[(bank % MMC_16KROM) << 14];
9D02C9DC  8F8280F4   LW V0, -32524(GP)
9D02C9E0  8C430010   LW V1, 16(V0)
9D02C9E4  0203001A   DIV S0, V1
9D02C9E8  006001F4   TEQ V1, ZERO
9D02C9EC  00002010   MFHI A0
9D02C9F0  00048380   SLL S0, A0, 14
9D02C9F4  8C420000   LW V0, 0(V0)
9D02C9F8  00508021   ADDU S0, V0, S0
9D02C9FC  00121080   SLL V0, S2, 2
9D02CA00  27A40010   ADDIU A0, SP, 16
9D02CA04  00821021   ADDU V0, A0, V0
9D02CA08  AC500000   SW S0, 0(V0)
134:                          mmc_cpu.mem_page[page + 1] = mmc_cpu.mem_page[page] + 0x1000;
9D02CA0C  26430001   ADDIU V1, S2, 1
9D02CA10  00031880   SLL V1, V1, 2
9D02CA14  00831821   ADDU V1, A0, V1
9D02CA18  26101000   ADDIU S0, S0, 4096
9D02CA1C  AC700000   SW S0, 0(V1)
135:                          mmc_cpu.mem_page[page + 2] = mmc_cpu.mem_page[page] + 0x2000;
9D02CA20  26430002   ADDIU V1, S2, 2
9D02CA24  00031880   SLL V1, V1, 2
9D02CA28  00831821   ADDU V1, A0, V1
9D02CA2C  8C440000   LW A0, 0(V0)
9D02CA30  24842000   ADDIU A0, A0, 8192
9D02CA34  AC640000   SW A0, 0(V1)
136:                          mmc_cpu.mem_page[page + 3] = mmc_cpu.mem_page[page] + 0x3000;
9D02CA38  26520003   ADDIU S2, S2, 3
9D02CA3C  00129080   SLL S2, S2, 2
9D02CA40  27A30010   ADDIU V1, SP, 16
9D02CA44  00729021   ADDU S2, V1, S2
9D02CA48  8C420000   LW V0, 0(V0)
9D02CA4C  24423000   ADDIU V0, V0, 12288
137:                       }
138:                       break;
9D02CA50  0B40B2BC   J .LVL51
9D02CA54  AE420000   SW V0, 0(S2)
139:                 
140:                    case 32:
141:                       if (bank == MMC_LASTBANK)
9D02CA58  2402FFFF   ADDIU V0, ZERO, -1
9D02CA5C  16020007   BNE S0, V0, 0x9D02CA7C
9D02CA60  8F8280F4   LW V0, -32524(GP)
142:                          bank = MMC_LAST32KROM;
9D02CA64  8C420010   LW V0, 16(V0)
9D02CA68  000287C2   SRL S0, V0, 31
9D02CA6C  02028021   ADDU S0, S0, V0
9D02CA70  00108043   SRA S0, S0, 1
9D02CA74  2610FFFF   ADDIU S0, S0, -1
143:                 
144:                       mmc_cpu.mem_page[8] = &mmc.cart->rom[(bank % MMC_32KROM) << 15];
9D02CA78  8F8280F4   LW V0, -32524(GP)
9D02CA7C  8C430010   LW V1, 16(V0)
9D02CA80  000327C2   SRL A0, V1, 31
9D02CA84  00831821   ADDU V1, A0, V1
9D02CA88  00031843   SRA V1, V1, 1
9D02CA8C  0203001A   DIV S0, V1
9D02CA90  006001F4   TEQ V1, ZERO
9D02CA94  00002010   MFHI A0
9D02CA98  000483C0   SLL S0, A0, 15
9D02CA9C  8C420000   LW V0, 0(V0)
9D02CAA0  00508021   ADDU S0, V0, S0
9D02CAA4  AFB00030   SW S0, 48(SP)
145:                       mmc_cpu.mem_page[9] = mmc_cpu.mem_page[8] + 0x1000;
9D02CAA8  26021000   ADDIU V0, S0, 4096
9D02CAAC  AFA20034   SW V0, 52(SP)
146:                       mmc_cpu.mem_page[10] = mmc_cpu.mem_page[8] + 0x2000;
9D02CAB0  26022000   ADDIU V0, S0, 8192
9D02CAB4  AFA20038   SW V0, 56(SP)
147:                       mmc_cpu.mem_page[11] = mmc_cpu.mem_page[8] + 0x3000;
9D02CAB8  26023000   ADDIU V0, S0, 12288
9D02CABC  AFA2003C   SW V0, 60(SP)
148:                       mmc_cpu.mem_page[12] = mmc_cpu.mem_page[8] + 0x4000;
9D02CAC0  26024000   ADDIU V0, S0, 16384
9D02CAC4  AFA20040   SW V0, 64(SP)
149:                       mmc_cpu.mem_page[13] = mmc_cpu.mem_page[8] + 0x5000;
9D02CAC8  26025000   ADDIU V0, S0, 20480
9D02CACC  AFA20044   SW V0, 68(SP)
150:                       mmc_cpu.mem_page[14] = mmc_cpu.mem_page[8] + 0x6000;
9D02CAD0  26026000   ADDIU V0, S0, 24576
9D02CAD4  AFA20048   SW V0, 72(SP)
151:                       mmc_cpu.mem_page[15] = mmc_cpu.mem_page[8] + 0x7000;
9D02CAD8  26107000   ADDIU S0, S0, 28672
152:                       break;
9D02CADC  0B40B2BC   J .LVL51
9D02CAE0  AFB0004C   SW S0, 76(SP)
153:                 
154:                    default:
155:                       log_printf("invalid ROM bank size %d\n", size);
9D02CAE4  2484A8BC   ADDIU A0, A0, -22340
9D02CAE8  0F40EEE8   JAL log_printf
9D02CAEC  02202821   ADDU A1, S1, ZERO
156:                       break;
157:                    }
158:                 
159:                    nes6502_setcontext(&mmc_cpu);
9D02CAF0  0F402877   JAL nes6502_setcontext
9D02CAF4  27A40010   ADDIU A0, SP, 16
160:                 }
9D02CAF8  8FBF007C   LW RA, 124(SP)
9D02CAFC  8FB20078   LW S2, 120(SP)
9D02CB00  8FB10074   LW S1, 116(SP)
9D02CB04  8FB00070   LW S0, 112(SP)
9D02CB08  03E00008   JR RA
9D02CB0C  27BD0080   ADDIU SP, SP, 128
161:                 
162:                 /* Check to see if this mapper is supported */
163:                 bool mmc_peek(int map_num)
164:                 {
165:                    mapintf_t **map_ptr = mappers;
9D02CB2C  3C02A001   LUI V0, -24575
9D02CB30  0B40B2D0   J 0x9D02CB40
9D02CB34  2442A9B0   ADDIU V0, V0, -22096
166:                 
167:                    while (NULL != *map_ptr)
9D02CB10  3C02A001   LUI V0, -24575
9D02CB14  8C42A9B0   LW V0, -22096(V0)
9D02CB18  1040000F   BEQ V0, ZERO, 0x9D02CB58
9D02CB1C  00000000   NOP
9D02CB44  8C430000   LW V1, 0(V0)
9D02CB48  5460FFFB   BNEL V1, ZERO, 0x9D02CB38
9D02CB4C  8C630000   LW V1, 0(V1)
9D02CB50  03E00008   JR RA
9D02CB54  00001021   ADDU V0, ZERO, ZERO
168:                    {
169:                       if ((*map_ptr)->number == map_num)
9D02CB20  8C420000   LW V0, 0(V0)
9D02CB24  1044000E   BEQ V0, A0, 0x9D02CB60
9D02CB28  00000000   NOP
9D02CB38  1064000B   BEQ V1, A0, 0x9D02CB68
9D02CB3C  00000000   NOP
170:                          return true;
9D02CB60  03E00008   JR RA
9D02CB64  24020001   ADDIU V0, ZERO, 1
171:                       map_ptr++;
9D02CB40  24420004   ADDIU V0, V0, 4
172:                    }
173:                 
174:                    return false;
9D02CB58  03E00008   JR RA
9D02CB5C  00001021   ADDU V0, ZERO, ZERO
175:                 }
9D02CB68  03E00008   JR RA
9D02CB6C  24020001   ADDIU V0, ZERO, 1
176:                 
177:                 static void mmc_setpages(void)
178:                 {
179:                    log_printf("setting up mapper %d\n", mmc.intf->number);
9D02CB78  3C049D04   LUI A0, -25340
9D02CB7C  2484A8D8   ADDIU A0, A0, -22312
9D02CB80  8F8280F0   LW V0, -32528(GP)
9D02CB84  0F40EEE8   JAL log_printf
9D02CB88  8C450000   LW A1, 0(V0)
180:                 
181:                    /* Switch ROM into CPU space, set VROM/VRAM (done for ALL ROMs) */
182:                    mmc_bankrom(16, 0x8000, 0);
9D02CB8C  24040010   ADDIU A0, ZERO, 16
9D02CB90  34058000   ORI A1, ZERO, -32768
9D02CB94  0F40B246   JAL mmc_bankrom
9D02CB98  00003021   ADDU A2, ZERO, ZERO
183:                    mmc_bankrom(16, 0xC000, MMC_LASTBANK);
9D02CB9C  24040010   ADDIU A0, ZERO, 16
9D02CBA0  3405C000   ORI A1, ZERO, -16384
9D02CBA4  0F40B246   JAL mmc_bankrom
9D02CBA8  2406FFFF   ADDIU A2, ZERO, -1
184:                    mmc_bankvrom(8, 0x0000, 0);
9D02CBAC  24040008   ADDIU A0, ZERO, 8
9D02CBB0  00002821   ADDU A1, ZERO, ZERO
9D02CBB4  0F40B1E8   JAL mmc_bankvrom
9D02CBB8  00003021   ADDU A2, ZERO, ZERO
185:                 
186:                    if (mmc.cart->flags & ROM_FLAG_FOURSCREEN)
9D02CBBC  8F8280F4   LW V0, -32524(GP)
9D02CBC0  90430028   LBU V1, 40(V0)
9D02CBC4  30630004   ANDI V1, V1, 4
9D02CBC8  306300FF   ANDI V1, V1, 255
9D02CBCC  50600008   BEQL V1, ZERO, 0x9D02CBF0
9D02CBD0  8C430024   LW V1, 36(V0)
187:                    {
188:                       ppu_mirror(0, 1, 2, 3);
9D02CBD4  00002021   ADDU A0, ZERO, ZERO
9D02CBD8  24050001   ADDIU A1, ZERO, 1
9D02CBDC  24060002   ADDIU A2, ZERO, 2
9D02CBE0  0F406128   JAL ppu_mirror
9D02CBE4  24070003   ADDIU A3, ZERO, 3
189:                    }
190:                    else
191:                    {
192:                       if (MIRROR_VERT == mmc.cart->mirror)
9D02CBF0  24020001   ADDIU V0, ZERO, 1
9D02CBF4  14620007   BNE V1, V0, 0x9D02CC14
9D02CBF8  00002021   ADDU A0, ZERO, ZERO
193:                          ppu_mirror(0, 1, 0, 1);
9D02CBFC  24050001   ADDIU A1, ZERO, 1
9D02CC00  00003021   ADDU A2, ZERO, ZERO
9D02CC04  0F406128   JAL ppu_mirror
9D02CC08  24070001   ADDIU A3, ZERO, 1
194:                       else
195:                          ppu_mirror(0, 0, 1, 1);
9D02CC14  00002821   ADDU A1, ZERO, ZERO
9D02CC18  24060001   ADDIU A2, ZERO, 1
9D02CC1C  0F406128   JAL ppu_mirror
9D02CC20  24070001   ADDIU A3, ZERO, 1
196:                    }
197:                 
198:                    /* if we have no VROM, switch in VRAM */
199:                    /* TODO: fix this hack implementation */
200:                    if (0 == mmc.cart->vrom_banks)
9D02CBE8  0B40B30A   J 0x9D02CC28
9D02CBEC  8F8280F4   LW V0, -32524(GP)
9D02CC0C  0B40B30A   J 0x9D02CC28
9D02CC10  8F8280F4   LW V0, -32524(GP)
9D02CC24  8F8280F4   LW V0, -32524(GP)
9D02CC28  8C430014   LW V1, 20(V0)
9D02CC2C  14600006   BNE V1, ZERO, .LVL69
9D02CC30  24040008   ADDIU A0, ZERO, 8
201:                    {
202:                       ASSERT(mmc.cart->vram);
203:                 
204:                       ppu_setpage(8, 0, mmc.cart->vram);
9D02CC34  00002821   ADDU A1, ZERO, ZERO
9D02CC38  0F4060DF   JAL ppu_setpage
9D02CC3C  8C46000C   LW A2, 12(V0)
205:                       ppu_mirrorhipages();
9D02CC40  0F406119   JAL ppu_mirrorhipages
9D02CC44  00000000   NOP
206:                    }
207:                 }
208:                 
209:                 /* Mapper initialization routine */
210:                 void mmc_reset(void)
211:                 {
9D02CB70  27BDFFE8   ADDIU SP, SP, -24
9D02CB74  AFBF0014   SW RA, 20(SP)
212:                    mmc_setpages();
213:                 
214:                    ppu_setlatchfunc(NULL);
9D02CC48  0F406391   JAL ppu_setlatchfunc
9D02CC4C  00002021   ADDU A0, ZERO, ZERO
215:                    ppu_setvromswitch(NULL);
9D02CC50  0F406394   JAL ppu_setvromswitch
9D02CC54  00002021   ADDU A0, ZERO, ZERO
216:                 
217:                    if (mmc.intf->init)
9D02CC58  8F8280F0   LW V0, -32528(GP)
9D02CC5C  8C420008   LW V0, 8(V0)
9D02CC60  50400004   BEQL V0, ZERO, 0x9D02CC74
9D02CC64  3C049D04   LUI A0, -25340
218:                       mmc.intf->init();
9D02CC68  0040F809   JALR V0
9D02CC6C  00000000   NOP
219:                 
220:                    log_printf("reset memory mapper\n");
9D02CC70  3C049D04   LUI A0, -25340
9D02CC74  0F40EEE8   JAL log_printf
9D02CC78  2484A8F0   ADDIU A0, A0, -22288
221:                 }
9D02CC7C  8FBF0014   LW RA, 20(SP)
9D02CC80  03E00008   JR RA
9D02CC84  27BD0018   ADDIU SP, SP, 24
222:                 
223:                 
224:                 void mmc_destroy(mmc_t **nes_mmc)
225:                 {
9D02CC94  27BDFFE8   ADDIU SP, SP, -24
9D02CC98  AFBF0014   SW RA, 20(SP)
226:                    if (*nes_mmc)
9D02CC88  8C820000   LW V0, 0(A0)
9D02CC8C  10400007   BEQ V0, ZERO, 0x9D02CCAC
9D02CC90  00000000   NOP
227:                       free(*nes_mmc);
9D02CC9C  0F40DB97   JAL _my_free
9D02CCA0  00000000   NOP
228:                 }
9D02CCA4  8FBF0014   LW RA, 20(SP)
9D02CCA8  27BD0018   ADDIU SP, SP, 24
9D02CCAC  03E00008   JR RA
9D02CCB0  00000000   NOP
229:                 
230:                 mmc_t *mmc_create(rominfo_t *rominfo)
231:                 {
9D02CCB4  27BDFFE0   ADDIU SP, SP, -32
9D02CCB8  AFBF001C   SW RA, 28(SP)
9D02CCBC  AFB20018   SW S2, 24(SP)
9D02CCC0  AFB10014   SW S1, 20(SP)
9D02CCC4  AFB00010   SW S0, 16(SP)
232:                    mmc_t *temp;
233:                    mapintf_t **map_ptr;
234:                   
235:                    for (map_ptr = mappers; (*map_ptr)->number != rominfo->mapper_number; map_ptr++)
9D02CCC8  3C02A001   LUI V0, -24575
9D02CCCC  8C42A9B0   LW V0, -22096(V0)
9D02CCD0  8C850020   LW A1, 32(A0)
9D02CCD4  8C430000   LW V1, 0(V0)
9D02CCD8  1065000E   BEQ V1, A1, 0x9D02CD14
9D02CCDC  00809021   ADDU S2, A0, ZERO
9D02CCE8  0B40B33E   J 0x9D02CCF8
9D02CCEC  2610A9B0   ADDIU S0, S0, -22096
9D02CCF8  26100004   ADDIU S0, S0, 4
9D02CCFC  8E020000   LW V0, 0(S0)
9D02CD00  8C430000   LW V1, 0(V0)
9D02CD04  1465FFFA   BNE V1, A1, 0x9D02CCF0
9D02CD08  00000000   NOP
9D02CD0C  0B40B347   J 0x9D02CD1C
9D02CD10  00000000   NOP
9D02CD14  3C10A001   LUI S0, -24575
9D02CD18  2610A9B0   ADDIU S0, S0, -22096
236:                    {
237:                       if (NULL == *map_ptr)
9D02CCE0  10400026   BEQ V0, ZERO, 0x9D02CD7C
9D02CCE4  3C10A001   LUI S0, -24575
9D02CCF0  10400024   BEQ V0, ZERO, 0x9D02CD84
9D02CCF4  00001021   ADDU V0, ZERO, ZERO
238:                          return NULL; /* Should *never* happen */
9D02CD7C  0B40B361   J 0x9D02CD84
9D02CD80  00001021   ADDU V0, ZERO, ZERO
239:                    }
240:                 
241:                    temp = malloc(sizeof(mmc_t));
9D02CD1C  0F40DB84   JAL _my_malloc
9D02CD20  24040008   ADDIU A0, ZERO, 8
242:                    if (NULL == temp)
9D02CD24  10400017   BEQ V0, ZERO, 0x9D02CD84
9D02CD28  00408821   ADDU S1, V0, ZERO
243:                       return NULL;
244:                 
245:                    memset(temp, 0, sizeof(mmc_t));
9D02CD2C  A0400000   SB ZERO, 0(V0)
9D02CD30  A0400001   SB ZERO, 1(V0)
9D02CD34  A0400002   SB ZERO, 2(V0)
9D02CD38  A0400003   SB ZERO, 3(V0)
9D02CD3C  A0400004   SB ZERO, 4(V0)
9D02CD40  A0400005   SB ZERO, 5(V0)
9D02CD44  A0400006   SB ZERO, 6(V0)
9D02CD48  A0400007   SB ZERO, 7(V0)
246:                 
247:                    temp->intf = *map_ptr;
9D02CD4C  8E020000   LW V0, 0(S0)
9D02CD50  AE220000   SW V0, 0(S1)
248:                    temp->cart = rominfo;
9D02CD54  AE320004   SW S2, 4(S1)
249:                 
250:                    mmc_setcontext(temp);
9D02CD58  0F40B1DE   JAL mmc_setcontext
9D02CD5C  02202021   ADDU A0, S1, ZERO
251:                 
252:                    log_printf("created memory mapper: %s\n", (*map_ptr)->name);
9D02CD60  8E020000   LW V0, 0(S0)
9D02CD64  3C049D04   LUI A0, -25340
9D02CD68  2484A908   ADDIU A0, A0, -22264
9D02CD6C  0F40EEE8   JAL log_printf
9D02CD70  8C450004   LW A1, 4(V0)
253:                 
254:                    return temp;
9D02CD74  0B40B361   J 0x9D02CD84
9D02CD78  02201021   ADDU V0, S1, ZERO
255:                 }
9D02CD84  8FBF001C   LW RA, 28(SP)
9D02CD88  8FB20018   LW S2, 24(SP)
9D02CD8C  8FB10014   LW S1, 20(SP)
9D02CD90  8FB00010   LW S0, 16(SP)
9D02CD94  03E00008   JR RA
9D02CD98  27BD0020   ADDIU SP, SP, 32
256:                 
257:                 
258:                 /*
259:                 ** $Log: nes_mmc.c,v $
260:                 ** Revision 1.2  2001/04/27 14:37:11  neil
261:                 ** wheeee
262:                 **
263:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
264:                 ** initial
265:                 **
266:                 ** Revision 1.4  2000/11/21 13:28:40  matt
267:                 ** take care to zero allocated mem
268:                 **
269:                 ** Revision 1.3  2000/10/27 12:55:58  matt
270:                 ** nes6502 now uses 4kB banks across the boards
271:                 **
272:                 ** Revision 1.2  2000/10/25 00:23:16  matt
273:                 ** makefiles updated for new directory structure
274:                 **
275:                 ** Revision 1.1  2000/10/24 12:20:28  matt
276:                 ** changed directory structure
277:                 **
278:                 ** Revision 1.28  2000/10/22 19:17:24  matt
279:                 ** mapper cleanups galore
280:                 **
281:                 ** Revision 1.27  2000/10/22 15:02:32  matt
282:                 ** simplified mirroring
283:                 **
284:                 ** Revision 1.26  2000/10/21 19:38:56  matt
285:                 ** that two year old crap code *was* flushed
286:                 **
287:                 ** Revision 1.25  2000/10/21 19:26:59  matt
288:                 ** many more cleanups
289:                 **
290:                 ** Revision 1.24  2000/10/17 03:22:57  matt
291:                 ** cleaning up rom module
292:                 **
293:                 ** Revision 1.23  2000/10/10 13:58:15  matt
294:                 ** stroustrup squeezing his way in the door
295:                 **
296:                 ** Revision 1.22  2000/08/16 02:51:55  matt
297:                 ** random cleanups
298:                 **
299:                 ** Revision 1.21  2000/07/31 04:27:59  matt
300:                 ** one million cleanups
301:                 **
302:                 ** Revision 1.20  2000/07/25 02:25:53  matt
303:                 ** safer xxx_destroy calls
304:                 **
305:                 ** Revision 1.19  2000/07/23 15:11:45  matt
306:                 ** removed unused variables
307:                 **
308:                 ** Revision 1.18  2000/07/15 23:50:03  matt
309:                 ** migrated state get/set from nes_mmc.c to state.c
310:                 **
311:                 ** Revision 1.17  2000/07/11 03:15:09  melanson
312:                 ** Added support for mappers 16, 34, and 231
313:                 **
314:                 ** Revision 1.16  2000/07/10 05:27:41  matt
315:                 ** cleaned up mapper-specific callbacks
316:                 **
317:                 ** Revision 1.15  2000/07/10 03:02:49  matt
318:                 ** minor change on loading state
319:                 **
320:                 ** Revision 1.14  2000/07/06 17:38:49  matt
321:                 ** replaced missing string.h include
322:                 **
323:                 ** Revision 1.13  2000/07/06 02:47:11  matt
324:                 ** mapper addition madness
325:                 **
326:                 ** Revision 1.12  2000/07/05 05:04:15  matt
327:                 ** added more mappers
328:                 **
329:                 ** Revision 1.11  2000/07/04 23:12:58  matt
330:                 ** brand spankin' new mapper interface implemented
331:                 **
332:                 ** Revision 1.10  2000/07/04 04:56:36  matt
333:                 ** modifications for new SNSS
334:                 **
335:                 ** Revision 1.9  2000/06/29 14:17:18  matt
336:                 ** uses snsslib now
337:                 **
338:                 ** Revision 1.8  2000/06/29 03:09:24  matt
339:                 ** modified to support new snss code
340:                 **
341:                 ** Revision 1.7  2000/06/26 04:57:54  matt
342:                 ** bugfix - irqs/mmcstate not cleared on reset
343:                 **
344:                 ** Revision 1.6  2000/06/23 11:01:10  matt
345:                 ** updated for new external sound interface
346:                 **
347:                 ** Revision 1.5  2000/06/20 04:04:57  matt
348:                 ** hacked to use new external soundchip struct
349:                 **
350:                 ** Revision 1.4  2000/06/09 15:12:26  matt
351:                 ** initial revision
352:                 **
353:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/nes/nes.c  ---------------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** nes.c
21:                  **
22:                  ** NES hardware related routines
23:                  ** $Id: nes.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <stdio.h>
27:                  #include <string.h>
28:                  #include <stdlib.h>
29:                  #include <noftypes.h>
30:                  #include "nes6502.h"
31:                  #include <log.h>
32:                  #include <osd.h>
33:                  #include <gui.h>
34:                  #include <nes.h>
35:                  #include <nes_apu.h>
36:                  #include <nes_ppu.h>
37:                  #include <nes_rom.h>
38:                  #include <nes_mmc.h>
39:                  #include <vid_drv.h>
40:                  #include <nofrendo.h>
41:                  #include "../../disp.h"
42:                  
43:                  #define  NES_CLOCK_DIVIDER    12
44:                  //#define  NES_MASTER_CLOCK     21477272.727272727272
45:                  #define  NES_MASTER_CLOCK     (236250000 / 11)
46:                  #define  NES_SCANLINE_CYCLES  (1364.0 / NES_CLOCK_DIVIDER)
47:                  #define  NES_FIQ_PERIOD       (NES_MASTER_CLOCK / NES_CLOCK_DIVIDER / 60)
48:                  
49:                  #define  NES_RAMSIZE          0x800
50:                  
51:                  #define  NES_SKIP_LIMIT       (NES_REFRESH_RATE / 5)   /* 12 or 10, depending on PAL/NTSC */
52:                  
53:                  static nes_t nes;
54:                  
55:                  /* find out if a file is ours */
56:                  int nes_isourfile(const char *filename)
57:                  {
9D022B24  27BDFFE8   ADDIU SP, SP, -24
9D022B28  AFBF0014   SW RA, 20(SP)
58:                     return rom_checkmagic(filename);
9D022B2C  0F40AA78   JAL rom_checkmagic
9D022B30  00000000   NOP
59:                  }
9D022B34  8FBF0014   LW RA, 20(SP)
9D022B38  03E00008   JR RA
9D022B3C  27BD0018   ADDIU SP, SP, 24
60:                  
61:                  /* TODO: just asking for problems -- please remove */
62:                  nes_t *nes_getcontextptr(void)
63:                  {
64:                     return &nes;
65:                  }
9D022B40  3C02A001   LUI V0, -24575
9D022B44  03E00008   JR RA
9D022B48  24429870   ADDIU V0, V0, -26512
66:                  
67:                  void nes_getcontext(nes_t *machine)
68:                  {
9D022B4C  27BDFFE0   ADDIU SP, SP, -32
9D022B50  AFBF001C   SW RA, 28(SP)
9D022B54  AFB20018   SW S2, 24(SP)
9D022B58  AFB10014   SW S1, 20(SP)
9D022B5C  AFB00010   SW S0, 16(SP)
9D022B60  00809021   ADDU S2, A0, ZERO
69:                     apu_getcontext(nes.apu);
9D022B64  3C11A001   LUI S1, -24575
9D022B68  26309870   ADDIU S0, S1, -26512
9D022B6C  0F40765D   JAL apu_getcontext
9D022B70  8E040308   LW A0, 776(S0)
70:                     ppu_getcontext(nes.ppu);
9D022B74  0F406093   JAL ppu_getcontext
9D022B78  8E040304   LW A0, 772(S0)
71:                     nes6502_getcontext(nes.cpu);
9D022B7C  0F40289D   JAL nes6502_getcontext
9D022B80  8E249870   LW A0, -26512(S1)
72:                     mmc_getcontext(nes.mmc);
9D022B84  0F40B1E3   JAL mmc_getcontext
9D022B88  8E04030C   LW A0, 780(S0)
73:                  
74:                     *machine = nes;
9D022B8C  02001021   ADDU V0, S0, ZERO
9D022B90  02402021   ADDU A0, S2, ZERO
9D022B94  26100330   ADDIU S0, S0, 816
9D022B98  8C470000   LW A3, 0(V0)
9D022B9C  8C460004   LW A2, 4(V0)
9D022BA0  8C450008   LW A1, 8(V0)
9D022BA4  8C43000C   LW V1, 12(V0)
9D022BA8  AC870000   SW A3, 0(A0)
9D022BAC  AC860004   SW A2, 4(A0)
9D022BB0  AC850008   SW A1, 8(A0)
9D022BB4  AC83000C   SW V1, 12(A0)
9D022BB8  24420010   ADDIU V0, V0, 16
9D022BBC  1450FFF6   BNE V0, S0, 0x9D022B98
9D022BC0  24840010   ADDIU A0, A0, 16
9D022BC4  8C420000   LW V0, 0(V0)
9D022BC8  AC820000   SW V0, 0(A0)
75:                  }
9D022BCC  8FBF001C   LW RA, 28(SP)
9D022BD0  8FB20018   LW S2, 24(SP)
9D022BD4  8FB10014   LW S1, 20(SP)
9D022BD8  8FB00010   LW S0, 16(SP)
9D022BDC  03E00008   JR RA
9D022BE0  27BD0020   ADDIU SP, SP, 32
76:                  
77:                  void nes_setcontext(nes_t *machine)
78:                  {
9D022BE4  27BDFFE8   ADDIU SP, SP, -24
9D022BE8  AFBF0014   SW RA, 20(SP)
9D022BEC  AFB00010   SW S0, 16(SP)
9D022BF0  00808021   ADDU S0, A0, ZERO
79:                     ASSERT(machine);
80:                  
81:                     apu_setcontext(machine->apu);
9D022BF4  0F407647   JAL apu_setcontext
9D022BF8  8C840308   LW A0, 776(A0)
82:                     ppu_setcontext(machine->ppu);
9D022BFC  0F406058   JAL ppu_setcontext
9D022C00  8E040304   LW A0, 772(S0)
83:                     nes6502_setcontext(machine->cpu);
9D022C04  0F402877   JAL nes6502_setcontext
9D022C08  8E040000   LW A0, 0(S0)
84:                     mmc_setcontext(machine->mmc);
9D022C0C  0F40B1DE   JAL mmc_setcontext
9D022C10  8E04030C   LW A0, 780(S0)
85:                  
86:                     nes = *machine;
9D022C14  02001021   ADDU V0, S0, ZERO
9D022C18  3C03A001   LUI V1, -24575
9D022C1C  24639870   ADDIU V1, V1, -26512
9D022C20  26100330   ADDIU S0, S0, 816
9D022C24  8C470000   LW A3, 0(V0)
9D022C28  8C460004   LW A2, 4(V0)
9D022C2C  8C450008   LW A1, 8(V0)
9D022C30  8C44000C   LW A0, 12(V0)
9D022C34  AC670000   SW A3, 0(V1)
9D022C38  AC660004   SW A2, 4(V1)
9D022C3C  AC650008   SW A1, 8(V1)
9D022C40  AC64000C   SW A0, 12(V1)
9D022C44  24420010   ADDIU V0, V0, 16
9D022C48  1450FFF6   BNE V0, S0, 0x9D022C24
9D022C4C  24630010   ADDIU V1, V1, 16
9D022C50  8C420000   LW V0, 0(V0)
9D022C54  AC620000   SW V0, 0(V1)
87:                  }
9D022C58  8FBF0014   LW RA, 20(SP)
9D022C5C  8FB00010   LW S0, 16(SP)
9D022C60  03E00008   JR RA
9D022C64  27BD0018   ADDIU SP, SP, 24
88:                  
89:                  static uint8 ram_read(uint32 address)
90:                  {
91:                     return nes.cpu->mem_page[0][address & (NES_RAMSIZE - 1)];
9D0228A8  3C02A001   LUI V0, -24575
9D0228AC  8C429870   LW V0, -26512(V0)
9D0228B0  308407FF   ANDI A0, A0, 2047
9D0228B4  8C420000   LW V0, 0(V0)
9D0228B8  00442021   ADDU A0, V0, A0
92:                  }
9D0228BC  03E00008   JR RA
9D0228C0  90820000   LBU V0, 0(A0)
93:                  
94:                  static void ram_write(uint32 address, uint8 value)
95:                  {
96:                     nes.cpu->mem_page[0][address & (NES_RAMSIZE - 1)] = value;
9D0228C4  3C02A001   LUI V0, -24575
9D0228C8  8C429870   LW V0, -26512(V0)
9D0228CC  308407FF   ANDI A0, A0, 2047
9D0228D0  8C420000   LW V0, 0(V0)
9D0228D4  00442021   ADDU A0, V0, A0
9D0228D8  03E00008   JR RA
9D0228DC  A0850000   SB A1, 0(A0)
97:                  }
98:                  
99:                  static void write_protect(uint32 address, uint8 value)
100:                 {
9D0228E0  03E00008   JR RA
9D0228E4  00000000   NOP
101:                    /* don't allow write to go through */
102:                    UNUSED(address);
103:                    UNUSED(value);
104:                 }
105:                 
106:                 static uint8 read_protect(uint32 address)
107:                 {
108:                    /* don't allow read to go through */
109:                    UNUSED(address);
110:                 
111:                    return 0xFF;
112:                 }
9D0228E8  03E00008   JR RA
9D0228EC  240200FF   ADDIU V0, ZERO, 255
113:                 
114:                 #define  LAST_MEMORY_HANDLER  { -1, -1, NULL }
115:                 /* read/write handlers for standard NES */
116:                 static nes6502_memread default_readhandler[] =
117:                 {
118:                    { 0x0800, 0x1FFF, ram_read },
119:                    { 0x2000, 0x3FFF, ppu_read },
120:                    { 0x4000, 0x4015, apu_read },
121:                    { 0x4016, 0x4017, ppu_readhigh },
122:                    LAST_MEMORY_HANDLER
123:                 };
124:                 
125:                 static nes6502_memwrite default_writehandler[] =
126:                 {
127:                    { 0x0800, 0x1FFF, ram_write },
128:                    { 0x2000, 0x3FFF, ppu_write },
129:                    { 0x4000, 0x4013, apu_write },
130:                    { 0x4015, 0x4015, apu_write },
131:                    { 0x4014, 0x4017, ppu_writehigh },
132:                    LAST_MEMORY_HANDLER
133:                 };
134:                 
135:                 /* this big nasty boy sets up the address handlers that the CPU uses */
136:                 static void build_address_handlers(nes_t *machine)
137:                 {
138:                    int count, num_handlers = 0;
9D023040  0B408C25   J 0x9D023094
9D023044  00002021   ADDU A0, ZERO, ZERO
139:                    mapintf_t *intf;
140:                    
141:                    ASSERT(machine);
142:                    intf = machine->mmc->intf;
9D023008  8E22030C   LW V0, 780(S1)
9D02300C  8C500000   LW S0, 0(V0)
143:                 
144:                    memset(machine->readhandler, 0, sizeof(machine->readhandler));
9D023010  26240004   ADDIU A0, S1, 4
9D023014  00002821   ADDU A1, ZERO, ZERO
9D023018  0F40E7C9   JAL .Letext0, .LFE0, memset
9D02301C  24060180   ADDIU A2, ZERO, 384
145:                    memset(machine->writehandler, 0, sizeof(machine->writehandler));
9D023020  26240184   ADDIU A0, S1, 388
9D023024  00002821   ADDU A1, ZERO, ZERO
9D023028  0F40E7C9   JAL .Letext0, .LFE0, memset
9D02302C  24060180   ADDIU A2, ZERO, 384
146:                 
147:                    for (count = 0; num_handlers < MAX_MEM_HANDLERS; count++, num_handlers++)
9D023084  24840001   ADDIU A0, A0, 1
9D023088  2442000C   ADDIU V0, V0, 12
9D02308C  0B408C12   J 0x9D023048
9D023090  24A5000C   ADDIU A1, A1, 12
9D0234C4  0B408C12   J 0x9D023048
9D0234C8  24040001   ADDIU A0, ZERO, 1
148:                    {
149:                       if (NULL == default_readhandler[count].read_func)
9D023030  3C02A001   LUI V0, -24575
9D023034  8C42AB14   LW V0, -21740(V0)
9D023038  14400114   BNE V0, ZERO, 0x9D02348C
9D02303C  26220004   ADDIU V0, S1, 4
9D023048  8CA60008   LW A2, 8(A1)
9D02304C  50C00012   BEQL A2, ZERO, 0x9D023098
9D023050  8E020024   LW V0, 36(S0)
150:                          break;
151:                 
152:                       memcpy(&machine->readhandler[num_handlers], &default_readhandler[count],
9D023054  88A70003   LWL A3, 3(A1)
9D023058  98A70000   LWR A3, 0(A1)
9D02305C  88A60007   LWL A2, 7(A1)
9D023060  98A60004   LWR A2, 4(A1)
9D023064  88A8000B   LWL T0, 11(A1)
9D023068  98A80008   LWR T0, 8(A1)
9D02306C  A8470003   SWL A3, 3(V0)
9D023070  B8470000   SWR A3, 0(V0)
9D023074  A8460007   SWL A2, 7(V0)
9D023078  B8460004   SWR A2, 4(V0)
9D02307C  A848000B   SWL T0, 11(V0)
9D023080  B8480008   SWR T0, 8(V0)
9D02348C  3C03A001   LUI V1, -24575
9D023490  8C65AB0C   LW A1, -21748(V1)
9D023494  2463AB0C   ADDIU V1, V1, -21748
9D023498  8C640004   LW A0, 4(V1)
9D02349C  8C630008   LW V1, 8(V1)
9D0234A0  AA250007   SWL A1, 7(S1)
9D0234A4  B8450000   SWR A1, 0(V0)
9D0234A8  A8440007   SWL A0, 7(V0)
9D0234AC  B8440004   SWR A0, 4(V0)
9D0234B0  A843000B   SWL V1, 11(V0)
9D0234B4  B8430008   SWR V1, 8(V0)
9D0234B8  26220010   ADDIU V0, S1, 16
9D0234BC  3C05A001   LUI A1, -24575
9D0234C0  24A5AB18   ADDIU A1, A1, -21736
153:                              sizeof(nes6502_memread));
154:                    }
155:                 
156:                    if (intf->sound_ext)
9D023094  8E020024   LW V0, 36(S0)
9D023098  50400028   BEQL V0, ZERO, 0x9D02313C
9D02309C  8E03001C   LW V1, 28(S0)
157:                    {
158:                       if (NULL != intf->sound_ext->mem_read)
9D0230A0  8C430010   LW V1, 16(V0)
9D0230A4  10600024   BEQ V1, ZERO, 0x9D023138
9D0230A8  28820020   SLTI V0, A0, 32
159:                       {
160:                          for (count = 0; num_handlers < MAX_MEM_HANDLERS; count++, num_handlers++)
9D0230AC  10400046   BEQ V0, ZERO, 0x9D0231C8
9D0230B0  00041080   SLL V0, A0, 2
9D0230D4  0B408C3D   J 0x9D0230F4
9D0230D8  24090020   ADDIU T1, ZERO, 32
9D023124  24840001   ADDIU A0, A0, 1
9D023128  1489FFEC   BNE A0, T1, 0x9D0230DC
9D02312C  B8480008   SWR T0, 8(V0)
9D023130  0B408C72   J 0x9D0231C8
9D023134  00041080   SLL V0, A0, 2
161:                          {
162:                             if (NULL == intf->sound_ext->mem_read[count].read_func)
9D0230B4  8C620008   LW V0, 8(V1)
9D0230B8  10400104   BEQ V0, ZERO, 0x9D0234CC
9D0230BC  00045080   SLL T2, A0, 2
9D0230C0  00041100   SLL V0, A0, 4
9D0230C4  004A5023   SUBU T2, V0, T2
9D0230C8  022A5021   ADDU T2, S1, T2
9D0230CC  2405000C   ADDIU A1, ZERO, 12
9D0230D0  254AFFF8   ADDIU T2, T2, -8
9D0230DC  8E020024   LW V0, 36(S0)
9D0230E0  8C430010   LW V1, 16(V0)
9D0230E4  00651821   ADDU V1, V1, A1
9D0230E8  8C620008   LW V0, 8(V1)
9D0230EC  10400012   BEQ V0, ZERO, 0x9D023138
9D0230F0  24A5000C   ADDIU A1, A1, 12
9D0230F4  01451021   ADDU V0, T2, A1
163:                                break;
164:                 
165:                             memcpy(&machine->readhandler[num_handlers], &intf->sound_ext->mem_read[count],
9D0230F8  88670003   LWL A3, 3(V1)
9D0230FC  98670000   LWR A3, 0(V1)
9D023100  88660007   LWL A2, 7(V1)
9D023104  98660004   LWR A2, 4(V1)
9D023108  8868000B   LWL T0, 11(V1)
9D02310C  98680008   LWR T0, 8(V1)
9D023110  A8470003   SWL A3, 3(V0)
9D023114  B8470000   SWR A3, 0(V0)
9D023118  A8460007   SWL A2, 7(V0)
9D02311C  B8460004   SWR A2, 4(V0)
9D023120  A848000B   SWL T0, 11(V0)
166:                                    sizeof(nes6502_memread));
167:                          }
168:                       }
169:                    }
170:                 
171:                    if (NULL != intf->mem_read)
9D023138  8E03001C   LW V1, 28(S0)
9D02313C  10600021   BEQ V1, ZERO, 0x9D0231C4
9D023140  28820020   SLTI V0, A0, 32
9D0234CC  8E03001C   LW V1, 28(S0)
9D0234D0  5460FF1F   BNEL V1, ZERO, 0x9D023150
9D0234D4  8C620008   LW V0, 8(V1)
9D0234D8  0B408C72   J 0x9D0231C8
9D0234DC  00041080   SLL V0, A0, 2
172:                    {
173:                       for (count = 0; num_handlers < MAX_MEM_HANDLERS; count++, num_handlers++)
9D023144  10400020   BEQ V0, ZERO, 0x9D0231C8
9D023148  00041080   SLL V0, A0, 2
9D02316C  0B408C62   J 0x9D023188
9D023170  24090020   ADDIU T1, ZERO, 32
9D0231B8  24840001   ADDIU A0, A0, 1
9D0231BC  1489FFED   BNE A0, T1, 0x9D023174
9D0231C0  B8480008   SWR T0, 8(V0)
9D0231C4  00041080   SLL V0, A0, 2
9D0231C8  00041900   SLL V1, A0, 4
9D0231CC  00621023   SUBU V0, V1, V0
9D0231D0  02221021   ADDU V0, S1, V0
174:                       {
175:                          if (NULL == intf->mem_read[count].read_func)
9D02314C  8C620008   LW V0, 8(V1)
9D023150  1040001C   BEQ V0, ZERO, 0x9D0231C4
9D023154  00041100   SLL V0, A0, 4
9D023158  00045080   SLL T2, A0, 2
9D02315C  004A5023   SUBU T2, V0, T2
9D023160  022A5021   ADDU T2, S1, T2
9D023164  2405000C   ADDIU A1, ZERO, 12
9D023168  254AFFF8   ADDIU T2, T2, -8
9D023174  8E03001C   LW V1, 28(S0)
9D023178  00651821   ADDU V1, V1, A1
9D02317C  8C620008   LW V0, 8(V1)
9D023180  10400010   BEQ V0, ZERO, 0x9D0231C4
9D023184  24A5000C   ADDIU A1, A1, 12
9D023188  01451021   ADDU V0, T2, A1
176:                             break;
177:                 
178:                          memcpy(&machine->readhandler[num_handlers], &intf->mem_read[count],
9D02318C  88670003   LWL A3, 3(V1)
9D023190  98670000   LWR A3, 0(V1)
9D023194  88660007   LWL A2, 7(V1)
9D023198  98660004   LWR A2, 4(V1)
9D02319C  8868000B   LWL T0, 11(V1)
9D0231A0  98680008   LWR T0, 8(V1)
9D0231A4  A8470003   SWL A3, 3(V0)
9D0231A8  B8470000   SWR A3, 0(V0)
9D0231AC  A8460007   SWL A2, 7(V0)
9D0231B0  B8460004   SWR A2, 4(V0)
9D0231B4  A848000B   SWL T0, 11(V0)
179:                                 sizeof(nes6502_memread));
180:                       }
181:                    }
182:                 
183:                    /* TODO: poof! numbers */
184:                    machine->readhandler[num_handlers].min_range = 0x4018;
9D0231D4  24034018   ADDIU V1, ZERO, 16408
9D0231D8  AC430004   SW V1, 4(V0)
185:                    machine->readhandler[num_handlers].max_range = 0x5FFF;
9D0231DC  24035FFF   ADDIU V1, ZERO, 24575
9D0231E0  AC430008   SW V1, 8(V0)
186:                    machine->readhandler[num_handlers].read_func = read_protect;
9D0231E4  3C039D02   LUI V1, -25342
9D0231E8  246328E8   ADDIU V1, V1, 10472
9D0231EC  AC43000C   SW V1, 12(V0)
187:                    num_handlers++;
9D0231F0  24840001   ADDIU A0, A0, 1
9D0231F4  00041080   SLL V0, A0, 2
9D0231F8  00042100   SLL A0, A0, 4
9D0231FC  00821023   SUBU V0, A0, V0
9D023200  02221021   ADDU V0, S1, V0
188:                    machine->readhandler[num_handlers].min_range = -1;
9D023204  2403FFFF   ADDIU V1, ZERO, -1
9D023208  AC430004   SW V1, 4(V0)
189:                    machine->readhandler[num_handlers].max_range = -1;
9D02320C  AC430008   SW V1, 8(V0)
190:                    machine->readhandler[num_handlers].read_func = NULL;
9D023210  AC40000C   SW ZERO, 12(V0)
191:                    num_handlers++;
192:                    ASSERT(num_handlers <= MAX_MEM_HANDLERS);
193:                 
194:                    num_handlers = 0;
9D023224  0B408C9E   J 0x9D023278
9D023228  00002021   ADDU A0, ZERO, ZERO
195:                 
196:                    for (count = 0; num_handlers < MAX_MEM_HANDLERS; count++, num_handlers++)
9D023268  24840001   ADDIU A0, A0, 1
9D02326C  2442000C   ADDIU V0, V0, 12
9D023270  0B408C8B   J 0x9D02322C
9D023274  24A5000C   ADDIU A1, A1, 12
9D023484  0B408C8B   J 0x9D02322C
9D023488  24040001   ADDIU A0, ZERO, 1
197:                    {
198:                       if (NULL == default_writehandler[count].write_func)
9D023214  3C02A001   LUI V0, -24575
9D023218  8C42AACC   LW V0, -21812(V0)
9D02321C  1440008B   BNE V0, ZERO, 0x9D02344C
9D023220  26220184   ADDIU V0, S1, 388
9D02322C  8CA60008   LW A2, 8(A1)
9D023230  50C00012   BEQL A2, ZERO, 0x9D02327C
9D023234  8E020024   LW V0, 36(S0)
199:                          break;
200:                 
201:                       memcpy(&machine->writehandler[num_handlers], &default_writehandler[count],
9D023238  88A70003   LWL A3, 3(A1)
9D02323C  98A70000   LWR A3, 0(A1)
9D023240  88A60007   LWL A2, 7(A1)
9D023244  98A60004   LWR A2, 4(A1)
9D023248  88A8000B   LWL T0, 11(A1)
9D02324C  98A80008   LWR T0, 8(A1)
9D023250  A8470003   SWL A3, 3(V0)
9D023254  B8470000   SWR A3, 0(V0)
9D023258  A8460007   SWL A2, 7(V0)
9D02325C  B8460004   SWR A2, 4(V0)
9D023260  A848000B   SWL T0, 11(V0)
9D023264  B8480008   SWR T0, 8(V0)
9D02344C  3C03A001   LUI V1, -24575
9D023450  8C65AAC4   LW A1, -21820(V1)
9D023454  2463AAC4   ADDIU V1, V1, -21820
9D023458  8C640004   LW A0, 4(V1)
9D02345C  8C630008   LW V1, 8(V1)
9D023460  AA250187   SWL A1, 391(S1)
9D023464  B8450000   SWR A1, 0(V0)
9D023468  A8440007   SWL A0, 7(V0)
9D02346C  B8440004   SWR A0, 4(V0)
9D023470  A843000B   SWL V1, 11(V0)
9D023474  B8430008   SWR V1, 8(V0)
9D023478  26220190   ADDIU V0, S1, 400
9D02347C  3C05A001   LUI A1, -24575
9D023480  24A5AAD0   ADDIU A1, A1, -21808
202:                              sizeof(nes6502_memwrite));
203:                    }
204:                 
205:                    if (intf->sound_ext)
9D023278  8E020024   LW V0, 36(S0)
9D02327C  50400028   BEQL V0, ZERO, 0x9D023320
9D023280  8E030020   LW V1, 32(S0)
206:                    {
207:                       if (NULL != intf->sound_ext->mem_write)
9D023284  8C430014   LW V1, 20(V0)
9D023288  10600024   BEQ V1, ZERO, 0x9D02331C
9D02328C  28820020   SLTI V0, A0, 32
208:                       {
209:                          for (count = 0; num_handlers < MAX_MEM_HANDLERS; count++, num_handlers++)
9D023290  10400047   BEQ V0, ZERO, 0x9D0233B0
9D023294  00041080   SLL V0, A0, 2
9D0232B8  0B408CB6   J 0x9D0232D8
9D0232BC  24090020   ADDIU T1, ZERO, 32
9D023308  24840001   ADDIU A0, A0, 1
9D02330C  1489FFEC   BNE A0, T1, 0x9D0232C0
9D023310  B8480008   SWR T0, 8(V0)
210:                          {
211:                             if (NULL == intf->sound_ext->mem_write[count].write_func)
9D023298  8C620008   LW V0, 8(V1)
9D02329C  10400090   BEQ V0, ZERO, 0x9D0234E0
9D0232A0  00045080   SLL T2, A0, 2
9D0232A4  00041100   SLL V0, A0, 4
9D0232A8  004A5023   SUBU T2, V0, T2
9D0232AC  022A5021   ADDU T2, S1, T2
9D0232B0  2405000C   ADDIU A1, ZERO, 12
9D0232B4  254A0178   ADDIU T2, T2, 376
9D0232C0  8E020024   LW V0, 36(S0)
9D0232C4  8C430014   LW V1, 20(V0)
9D0232C8  00651821   ADDU V1, V1, A1
9D0232CC  8C620008   LW V0, 8(V1)
9D0232D0  10400012   BEQ V0, ZERO, 0x9D02331C
9D0232D4  24A5000C   ADDIU A1, A1, 12
9D0232D8  01451021   ADDU V0, T2, A1
212:                                break;
213:                 
214:                             memcpy(&machine->writehandler[num_handlers], &intf->sound_ext->mem_write[count],
9D0232DC  88670003   LWL A3, 3(V1)
9D0232E0  98670000   LWR A3, 0(V1)
9D0232E4  88660007   LWL A2, 7(V1)
9D0232E8  98660004   LWR A2, 4(V1)
9D0232EC  8868000B   LWL T0, 11(V1)
9D0232F0  98680008   LWR T0, 8(V1)
9D0232F4  A8470003   SWL A3, 3(V0)
9D0232F8  B8470000   SWR A3, 0(V0)
9D0232FC  A8460007   SWL A2, 7(V0)
9D023300  B8460004   SWR A2, 4(V0)
9D023304  A848000B   SWL T0, 11(V0)
215:                                    sizeof(nes6502_memwrite));
216:                          }
217:                       }
218:                    }
219:                 
220:                    if (NULL != intf->mem_write)
9D02331C  8E030020   LW V1, 32(S0)
9D023320  10600023   BEQ V1, ZERO, 0x9D0233B0
9D023324  00041080   SLL V0, A0, 2
9D0234E0  8E030020   LW V1, 32(S0)
9D0234E4  5460FF94   BNEL V1, ZERO, 0x9D023338
9D0234E8  8C620008   LW V0, 8(V1)
221:                    {
222:                       for (count = 0; num_handlers < MAX_MEM_HANDLERS; count++, num_handlers++)
9D023328  28820020   SLTI V0, A0, 32
9D02332C  10400020   BEQ V0, ZERO, 0x9D0233B0
9D023330  00041080   SLL V0, A0, 2
9D023354  0B408CDC   J 0x9D023370
9D023358  24090020   ADDIU T1, ZERO, 32
9D0233A0  24840001   ADDIU A0, A0, 1
9D0233A4  1489FFED   BNE A0, T1, 0x9D02335C
9D0233A8  B8480008   SWR T0, 8(V0)
223:                       {
224:                          if (NULL == intf->mem_write[count].write_func)
9D023334  8C620008   LW V0, 8(V1)
9D023338  1040001C   BEQ V0, ZERO, 0x9D0233AC
9D02333C  00045080   SLL T2, A0, 2
9D023340  00041100   SLL V0, A0, 4
9D023344  004A5023   SUBU T2, V0, T2
9D023348  022A5021   ADDU T2, S1, T2
9D02334C  2405000C   ADDIU A1, ZERO, 12
9D023350  254A0178   ADDIU T2, T2, 376
9D02335C  8E030020   LW V1, 32(S0)
9D023360  00651821   ADDU V1, V1, A1
9D023364  8C620008   LW V0, 8(V1)
9D023368  10400010   BEQ V0, ZERO, 0x9D0233AC
9D02336C  24A5000C   ADDIU A1, A1, 12
9D023370  01451021   ADDU V0, T2, A1
225:                             break;
226:                 
227:                          memcpy(&machine->writehandler[num_handlers], &intf->mem_write[count],
9D023374  88670003   LWL A3, 3(V1)
9D023378  98670000   LWR A3, 0(V1)
9D02337C  88660007   LWL A2, 7(V1)
9D023380  98660004   LWR A2, 4(V1)
9D023384  8868000B   LWL T0, 11(V1)
9D023388  98680008   LWR T0, 8(V1)
9D02338C  A8470003   SWL A3, 3(V0)
9D023390  B8470000   SWR A3, 0(V0)
9D023394  A8460007   SWL A2, 7(V0)
9D023398  B8460004   SWR A2, 4(V0)
9D02339C  A848000B   SWL T0, 11(V0)
228:                                 sizeof(nes6502_memwrite));
229:                       }
230:                    }
231:                 
232:                    /* catch-all for bad writes */
233:                    /* TODO: poof! numbers */
234:                    machine->writehandler[num_handlers].min_range = 0x4018;
9D023314  0B408CEC   J 0x9D0233B0
9D023318  00041080   SLL V0, A0, 2
9D0233AC  00041080   SLL V0, A0, 2
9D0233B0  00041900   SLL V1, A0, 4
9D0233B4  00621023   SUBU V0, V1, V0
9D0233B8  02221021   ADDU V0, S1, V0
9D0233BC  24034018   ADDIU V1, ZERO, 16408
9D0233C0  AC430184   SW V1, 388(V0)
9D0234EC  0B408CEC   J 0x9D0233B0
9D0234F0  00041080   SLL V0, A0, 2
235:                    machine->writehandler[num_handlers].max_range = 0x5FFF;
9D0233C4  24035FFF   ADDIU V1, ZERO, 24575
9D0233C8  AC430188   SW V1, 392(V0)
236:                    machine->writehandler[num_handlers].write_func = write_protect;
9D0233CC  3C039D02   LUI V1, -25342
9D0233D0  246328E0   ADDIU V1, V1, 10464
9D0233D4  AC43018C   SW V1, 396(V0)
237:                    num_handlers++;
9D0233D8  24850001   ADDIU A1, A0, 1
238:                    machine->writehandler[num_handlers].min_range = 0x8000;
9D0233DC  00051080   SLL V0, A1, 2
9D0233E0  00052900   SLL A1, A1, 4
9D0233E4  00A21023   SUBU V0, A1, V0
9D0233E8  02221021   ADDU V0, S1, V0
9D0233EC  34058000   ORI A1, ZERO, -32768
9D0233F0  AC450184   SW A1, 388(V0)
239:                    machine->writehandler[num_handlers].max_range = 0xFFFF;
9D0233F4  3405FFFF   ORI A1, ZERO, -1
9D0233F8  AC450188   SW A1, 392(V0)
240:                    machine->writehandler[num_handlers].write_func = write_protect;
9D0233FC  AC43018C   SW V1, 396(V0)
241:                    num_handlers++;
9D023400  24840002   ADDIU A0, A0, 2
242:                    machine->writehandler[num_handlers].min_range = -1;
9D023404  00041080   SLL V0, A0, 2
9D023408  00042100   SLL A0, A0, 4
9D02340C  00822023   SUBU A0, A0, V0
9D023410  02248821   ADDU S1, S1, A0
9D023414  2402FFFF   ADDIU V0, ZERO, -1
9D023418  AE220184   SW V0, 388(S1)
243:                    machine->writehandler[num_handlers].max_range = -1;
9D02341C  AE220188   SW V0, 392(S1)
244:                    machine->writehandler[num_handlers].write_func = NULL;
9D023420  AE20018C   SW ZERO, 396(S1)
245:                    num_handlers++;
246:                    ASSERT(num_handlers <= MAX_MEM_HANDLERS);
247:                 }
248:                 
249:                 /* raise an IRQ */
250:                 void nes_irq(void)
251:                 {
9D022918  27BDFFE8   ADDIU SP, SP, -24
9D02291C  AFBF0014   SW RA, 20(SP)
252:                 #ifdef NOFRENDO_DEBUG
253:                 //   if (nes.scanline <= NES_SCREEN_HEIGHT)
254:                 //      memset(nes.vidbuf->line[nes.scanline - 1], GUI_RED, NES_SCREEN_WIDTH);
255:                 #endif /* NOFRENDO_DEBUG */
256:                 
257:                    nes6502_irq();
9D022920  0F404E36   JAL nes6502_irq
9D022924  00000000   NOP
258:                 }
9D022928  8FBF0014   LW RA, 20(SP)
9D02292C  03E00008   JR RA
9D022930  27BD0018   ADDIU SP, SP, 24
259:                 
260:                 static uint8 nes_clearfiq(void)
261:                 {
262:                    if (nes.fiq_occurred)
9D0228F0  3C02A001   LUI V0, -24575
9D0228F4  8C429B84   LW V0, -25724(V0)
9D0228F8  10400005   BEQ V0, ZERO, 0x9D022910
9D0228FC  00000000   NOP
263:                    {
264:                       nes.fiq_occurred = false;
9D022900  3C02A001   LUI V0, -24575
9D022904  AC409B84   SW ZERO, -25724(V0)
265:                       return 0x40;
9D022908  03E00008   JR RA
9D02290C  24020040   ADDIU V0, ZERO, 64
266:                    }
267:                 
268:                    return 0;
269:                 }
9D022910  03E00008   JR RA
9D022914  00001021   ADDU V0, ZERO, ZERO
270:                 
271:                 void nes_setfiq(uint8 value)
272:                 {
273:                    nes.fiq_state = value;
9D022C68  3C02A001   LUI V0, -24575
9D022C6C  24429870   ADDIU V0, V0, -26512
9D022C70  A0440318   SB A0, 792(V0)
274:                    nes.fiq_cycles = (int) NES_FIQ_PERIOD;
9D022C74  24037485   ADDIU V1, ZERO, 29829
9D022C78  03E00008   JR RA
9D022C7C  AC43031C   SW V1, 796(V0)
275:                 }
276:                 
277:                 static void nes_checkfiq(int cycles)
278:                 {
9D022970  27BDFFE8   ADDIU SP, SP, -24
9D022974  AFBF0014   SW RA, 20(SP)
279:                    nes.fiq_cycles -= cycles;
9D022934  3C02A001   LUI V0, -24575
9D022938  8C429B8C   LW V0, -25716(V0)
9D02293C  00442023   SUBU A0, V0, A0
9D022948  03E00008   JR RA
9D02294C  AC449B8C   SW A0, -25716(V0)
280:                    if (nes.fiq_cycles <= 0)
9D022940  18800003   BLEZ A0, 0x9D022950
9D022944  3C02A001   LUI V0, -24575
281:                    {
282:                       nes.fiq_cycles += (int) NES_FIQ_PERIOD;
9D022950  3C02A001   LUI V0, -24575
9D022954  24429870   ADDIU V0, V0, -26512
9D022958  24847485   ADDIU A0, A0, 29829
9D02295C  AC44031C   SW A0, 796(V0)
283:                       if (0 == (nes.fiq_state & 0xC0))
9D022960  90420318   LBU V0, 792(V0)
9D022964  304200C0   ANDI V0, V0, 192
9D022968  14400008   BNE V0, ZERO, 0x9D02298C
9D02296C  24030001   ADDIU V1, ZERO, 1
284:                       {
285:                          nes.fiq_occurred = true;
9D022978  3C02A001   LUI V0, -24575
286:                          nes6502_irq();
9D02297C  0F404E36   JAL nes6502_irq
9D022980  AC439B84   SW V1, -25724(V0)
287:                       }
288:                    }
289:                 }
9D022984  8FBF0014   LW RA, 20(SP)
9D022988  27BD0018   ADDIU SP, SP, 24
9D02298C  03E00008   JR RA
9D022990  00000000   NOP
290:                 
291:                 void nes_nmi(void)
292:                 {
9D022C80  27BDFFE8   ADDIU SP, SP, -24
9D022C84  AFBF0014   SW RA, 20(SP)
293:                    nes6502_nmi();
9D022C88  0F404DDE   JAL nes6502_nmi
9D022C8C  00000000   NOP
294:                 }
9D022C90  8FBF0014   LW RA, 20(SP)
9D022C94  03E00008   JR RA
9D022C98  27BD0018   ADDIU SP, SP, 24
295:                 
296:                 int tsting = 0, tsti = 0;
297:                 static void nes_renderframe(bool draw_flag)
298:                 {
9D022994  27BDFFC8   ADDIU SP, SP, -56
9D022998  AFBF0034   SW RA, 52(SP)
9D02299C  AFBE0030   SW FP, 48(SP)
9D0229A0  AFB7002C   SW S7, 44(SP)
9D0229A4  AFB60028   SW S6, 40(SP)
9D0229A8  AFB50024   SW S5, 36(SP)
9D0229AC  AFB40020   SW S4, 32(SP)
9D0229B0  AFB3001C   SW S3, 28(SP)
9D0229B4  AFB20018   SW S2, 24(SP)
9D0229B8  AFB10014   SW S1, 20(SP)
9D0229BC  AFB00010   SW S0, 16(SP)
9D0229C0  0080B021   ADDU S6, A0, ZERO
299:                    int elapsed_cycles;
300:                    mapintf_t *mapintf = nes.mmc->intf;
9D0229C4  3C02A001   LUI V0, -24575
9D0229C8  8C429B7C   LW V0, -25732(V0)
9D0229CC  8C530000   LW S3, 0(V0)
301:                    int in_vblank = 0;
9D0229D0  0000B821   ADDU S7, ZERO, ZERO
302:                 
303:                    while (262 != nes.scanline)
9D0229D4  3C11A001   LUI S1, -24575
9D0229D8  24140106   ADDIU S4, ZERO, 262
9D0229E4  0B408AB8   J 0x9D022AE0
9D0229E8  8C55BFA4   LW S5, -16476(V0)
9D022AE0  26229870   ADDIU V0, S1, -26512
9D022AE4  8C420320   LW V0, 800(V0)
9D022AE8  1454FFC0   BNE V0, S4, 0x9D0229EC
9D022AEC  3C02A001   LUI V0, -24575
304:                    {
305:                 //      ppu_scanline(nes.vidbuf, nes.scanline, draw_flag);
306:                 		ppu_scanline(vid_getbuffer(), nes.scanline, draw_flag);
9D0229EC  0F40B89E   JAL vid_getbuffer
9D0229F0  26309870   ADDIU S0, S1, -26512
9D0229F4  00402021   ADDU A0, V0, ZERO
9D0229F8  8E050320   LW A1, 800(S0)
9D0229FC  0F4063D5   JAL ppu_scanline
9D022A00  02C03021   ADDU A2, S6, ZERO
307:                 
308:                       if (241 == nes.scanline)
9D0229DC  241200F1   ADDIU S2, ZERO, 241
9D022A04  8E020320   LW V0, 800(S0)
9D022A08  54520017   BNEL V0, S2, 0x9D022A68
9D022A0C  8E620010   LW V0, 16(S3)
309:                       {
310:                          /* 7-9 cycle delay between when VINT flag goes up and NMI is taken */
311:                          elapsed_cycles = nes6502_execute(7);
9D022A10  0F4028CF   JAL nes6502_execute
9D022A14  24040007   ADDIU A0, ZERO, 7
9D022A18  00408021   ADDU S0, V0, ZERO
312:                          nes.scanline_cycles -= elapsed_cycles;
9D022A1C  26379870   ADDIU S7, S1, -26512
9D022A20  0F40ECB4   JAL sitofp
9D022A24  00402021   ADDU A0, V0, ZERO
9D022A28  8EE40324   LW A0, 804(S7)
9D022A2C  0F40CFF8   JAL __subsf3
9D022A30  00402821   ADDU A1, V0, ZERO
9D022A34  AEE20324   SW V0, 804(S7)
313:                          nes_checkfiq(elapsed_cycles);
9D022A38  0F408A4D   JAL .LFB20, nes_checkfiq, .LFE17
9D022A3C  02002021   ADDU A0, S0, ZERO
314:                 
315:                          ppu_checknmi();
9D022A40  0F4063C9   JAL ppu_checknmi
9D022A44  00000000   NOP
316:                 
317:                          if (mapintf->vblank)
9D022A48  8E62000C   LW V0, 12(S3)
9D022A4C  10400005   BEQ V0, ZERO, 0x9D022A64
9D022A50  24170001   ADDIU S7, ZERO, 1
318:                             mapintf->vblank();
9D022A54  0040F809   JALR V0
9D022A58  00000000   NOP
319:                          in_vblank = 1;
320:                       } 
321:                 
322:                       if (mapintf->hblank)
9D022A5C  0B408A9A   J 0x9D022A68
9D022A60  8E620010   LW V0, 16(S3)
9D022A64  8E620010   LW V0, 16(S3)
9D022A68  10400004   BEQ V0, ZERO, 0x9D022A7C
9D022A6C  26309870   ADDIU S0, S1, -26512
323:                          mapintf->hblank(in_vblank);
9D022A70  0040F809   JALR V0
9D022A74  02E02021   ADDU A0, S7, ZERO
324:                 
325:                       nes.scanline_cycles += (float) NES_SCANLINE_CYCLES;
9D0229E0  3C029D04   LUI V0, -25340
9D022A78  26309870   ADDIU S0, S1, -26512
9D022A7C  8E040324   LW A0, 804(S0)
9D022A80  0F40CFFA   JAL fpadd
9D022A84  02A02821   ADDU A1, S5, ZERO
9D022A88  AE020324   SW V0, 804(S0)
326:                       elapsed_cycles = nes6502_execute((int) nes.scanline_cycles);
9D022A8C  0F40EA89   JAL __fixsfsi
9D022A90  00402021   ADDU A0, V0, ZERO
9D022A94  0F4028CF   JAL nes6502_execute
9D022A98  00402021   ADDU A0, V0, ZERO
9D022A9C  0040F021   ADDU FP, V0, ZERO
327:                       nes.scanline_cycles -= (float) elapsed_cycles;
9D022AA0  0F40ECB4   JAL sitofp
9D022AA4  00402021   ADDU A0, V0, ZERO
9D022AA8  8E040324   LW A0, 804(S0)
9D022AAC  0F40CFF8   JAL __subsf3
9D022AB0  00402821   ADDU A1, V0, ZERO
9D022AB4  AE020324   SW V0, 804(S0)
328:                       nes_checkfiq(elapsed_cycles);
9D022AB8  0F408A4D   JAL .LFB20, nes_checkfiq, .LFE17
9D022ABC  03C02021   ADDU A0, FP, ZERO
329:                 
330:                       ppu_endscanline(nes.scanline);
9D022AC0  0F4063A0   JAL ppu_endscanline
9D022AC4  8E040320   LW A0, 800(S0)
331:                       nes.scanline++;
9D022AC8  8E020320   LW V0, 800(S0)
9D022ACC  24420001   ADDIU V0, V0, 1
9D022AD0  AE020320   SW V0, 800(S0)
332:                       tsting = nes.scanline;
333:                       
334:                       if (tsting == 241)
9D022AD4  14520002   BNE V0, S2, 0x9D022AE0
9D022AD8  AF828118   SW V0, -32488(GP)
335:                       {
336:                           tsti = 0;
9D022ADC  AF808114   SW ZERO, -32492(GP)
337:                       }
338:                    }
339:                 
340:                    nes.scanline = 0;
9D022AF0  AC409B90   SW ZERO, -25712(V0)
341:                 }
9D022AF4  8FBF0034   LW RA, 52(SP)
9D022AF8  8FBE0030   LW FP, 48(SP)
9D022AFC  8FB7002C   LW S7, 44(SP)
9D022B00  8FB60028   LW S6, 40(SP)
9D022B04  8FB50024   LW S5, 36(SP)
9D022B08  8FB40020   LW S4, 32(SP)
9D022B0C  8FB3001C   LW S3, 28(SP)
9D022B10  8FB20018   LW S2, 24(SP)
9D022B14  8FB10014   LW S1, 20(SP)
9D022B18  8FB00010   LW S0, 16(SP)
9D022B1C  03E00008   JR RA
9D022B20  27BD0038   ADDIU SP, SP, 56
342:                 
343:                 int i;
344:                 
345:                 extern bitmap_t *primary_buffer;
346:                 
347:                 static void system_video(bool draw)
348:                 {
349:                    /* TODO: hack */
350:                 //   if (false == draw)
351:                 //   {
352:                 //      //gui_frame(false);
353:                 //      return;
354:                 //   }
355:                 
356:                    /* blit the NES screen to our video surface */
357:                 //   vid_blit(nes.vidbuf, 0, (NES_SCREEN_HEIGHT - NES_VISIBLE_HEIGHT) / 2,
358:                 //            0, 0, NES_SCREEN_WIDTH, NES_VISIBLE_HEIGHT);
359:                 
360:                    /* overlay our GUI on top of it */
361:                    //gui_frame(true);
362:                 
363:                    /* blit to screen */
364:                    //vid_flush();
365:                     //tft_writebuf((const uint8_t **)primary_buffer->line, 256, 240);
366:                    
367:                    //ili9341_write_frame(x, y, DEFAULT_WIDTH, DEFAULT_HEIGHT, (const uint8_t **)bmp->line);
368:                    
369:                 
370:                    /* grab input */
371:                    //osd_getinput();
372:                 }
373:                 
374:                 /* main emulation loop */
375:                 void nes_emulate(void)
376:                 {
9D022C9C  27BDFFD8   ADDIU SP, SP, -40
9D022CA0  AFBF0024   SW RA, 36(SP)
9D022CA4  AFB30020   SW S3, 32(SP)
9D022CA8  AFB2001C   SW S2, 28(SP)
9D022CAC  AFB10018   SW S1, 24(SP)
9D022CB0  AFB00014   SW S0, 20(SP)
377:                    int last_ticks, frames_to_render;
378:                 
379:                    //osd_setsound(nes.apu->process);
380:                 
381:                    last_ticks = nofrendo_ticks;
9D022CB4  8F92816C   LW S2, -32404(GP)
382:                    frames_to_render = 0;
9D022CD0  00008021   ADDU S0, ZERO, ZERO
383:                    nes.scanline_cycles = 0;
9D022CB8  3C02A001   LUI V0, -24575
9D022CBC  24429870   ADDIU V0, V0, -26512
9D022CC0  00001821   ADDU V1, ZERO, ZERO
9D022CC4  AC430324   SW V1, 804(V0)
384:                    nes.fiq_cycles = (int) NES_FIQ_PERIOD;
9D022CC8  24037485   ADDIU V1, ZERO, 29829
9D022CCC  AC43031C   SW V1, 796(V0)
385:                 
386:                    while (false == nes.poweroff)
9D022CD4  3C11A001   LUI S1, -24575
9D022CD8  0B408B58   J 0x9D022D60
9D022CDC  24130001   ADDIU S3, ZERO, 1
9D022D60  26229870   ADDIU V0, S1, -26512
9D022D64  8C42032C   LW V0, 812(V0)
9D022D68  1040FFDD   BEQ V0, ZERO, 0x9D022CE0
9D022D6C  8FBF0024   LW RA, 36(SP)
387:                    {
388:                       if (nofrendo_ticks != last_ticks)
9D022CE0  8F82816C   LW V0, -32404(GP)
9D022CE4  10520007   BEQ V0, S2, 0x9D022D04
9D022CE8  26229870   ADDIU V0, S1, -26512
389:                       {
390:                          int tick_diff = nofrendo_ticks - last_ticks;
9D022CEC  8F84816C   LW A0, -32404(GP)
9D022CF0  00922023   SUBU A0, A0, S2
391:                 
392:                          frames_to_render += tick_diff;
393:                          gui_tick(tick_diff);
9D022CF4  0F408F25   JAL gui_tick
9D022CF8  02048021   ADDU S0, S0, A0
394:                          last_ticks = nofrendo_ticks;
9D022CFC  8F92816C   LW S2, -32404(GP)
395:                       }
396:                 
397:                       if (true == nes.pause)
9D022D00  26229870   ADDIU V0, S1, -26512
9D022D04  8C420330   LW V0, 816(V0)
9D022D08  10530014   BEQ V0, S3, 0x9D022D5C
9D022D0C  2A020002   SLTI V0, S0, 2
398:                       {
399:                          /* TODO: dim the screen, and pause/silence the apu */
400:                          system_video(true);
401:                          frames_to_render = 0;
9D022D5C  00008021   ADDU S0, ZERO, ZERO
402:                       }
403:                       else if (frames_to_render > 1)
9D022D10  14400006   BNE V0, ZERO, 0x9D022D2C
9D022D14  00000000   NOP
404:                       {
405:                          frames_to_render--;
9D022D18  2610FFFF   ADDIU S0, S0, -1
406:                          nes_renderframe(false);
9D022D1C  0F408A65   JAL .LFB22, nes_renderframe, .LFE20
9D022D20  00002021   ADDU A0, ZERO, ZERO
9D022D24  0B408B59   J 0x9D022D64
9D022D28  26229870   ADDIU V0, S1, -26512
407:                          system_video(false);
408:                       }
409:                       else if ((1 == frames_to_render && true == nes.autoframeskip)
9D022D2C  16130004   BNE S0, S3, 0x9D022D40
9D022D30  26229870   ADDIU V0, S1, -26512
9D022D34  8C420328   LW V0, 808(V0)
9D022D38  10530004   BEQ V0, S3, 0x9D022D4C
9D022D3C  26229870   ADDIU V0, S1, -26512
410:                                || false == nes.autoframeskip)
9D022D40  8C420328   LW V0, 808(V0)
9D022D44  14400007   BNE V0, ZERO, 0x9D022D64
9D022D48  26229870   ADDIU V0, S1, -26512
411:                       {
412:                          frames_to_render = 0;
9D022D54  0B408B58   J 0x9D022D60
9D022D58  00008021   ADDU S0, ZERO, ZERO
413:                          nes_renderframe(true);
9D022D4C  0F408A65   JAL .LFB22, nes_renderframe, .LFE20
9D022D50  02602021   ADDU A0, S3, ZERO
414:                          system_video(true);
415:                       }
416:                    }
417:                 }
9D022D70  8FB30020   LW S3, 32(SP)
9D022D74  8FB2001C   LW S2, 28(SP)
9D022D78  8FB10018   LW S1, 24(SP)
9D022D7C  8FB00014   LW S0, 20(SP)
9D022D80  03E00008   JR RA
9D022D84  27BD0028   ADDIU SP, SP, 40
418:                 
419:                 static void mem_trash(uint8 *buffer, int length)
420:                 {
421:                    int i;
422:                 
423:                    for (i = 0; i < length; i++)
9D022DD8  1A20001E   BLEZ S1, 0x9D022E54
9D022DF4  1611FFFB   BNE S0, S1, 0x9D022DE4
424:                       buffer[i] = (uint8) rand();
9D022DE4  0F40ED55   JAL .Letext0, .LFE0, rand
9D022DE8  00000000   NOP
9D022DEC  A2020000   SB V0, 0(S0)
9D022DF0  26100001   ADDIU S0, S0, 1
9D022DF4  1611FFFB   BNE S0, S1, 0x9D022DE4
9D022DF8  00000000   NOP
9D022DFC  0B408B95   J 0x9D022E54
9D022E00  00000000   NOP
425:                 }
426:                 
427:                 /* Reset NES hardware */
428:                 void nes_reset(int reset_type)
429:                 {
9D022D88  27BDFFE0   ADDIU SP, SP, -32
9D022D8C  AFBF001C   SW RA, 28(SP)
9D022D90  AFB10018   SW S1, 24(SP)
9D022D94  AFB00014   SW S0, 20(SP)
430:                    if (HARD_RESET == reset_type)
9D022D98  24020001   ADDIU V0, ZERO, 1
9D022D9C  1482001F   BNE A0, V0, 0x9D022E1C
9D022DA0  00808021   ADDU S0, A0, ZERO
431:                    {
432:                       memset(nes.cpu->mem_page[0], 0, NES_RAMSIZE);
9D022DA4  3C10A001   LUI S0, -24575
9D022DA8  8E029870   LW V0, -26512(S0)
9D022DAC  8C440000   LW A0, 0(V0)
9D022DB0  00002821   ADDU A1, ZERO, ZERO
9D022DB4  0F40E7C9   JAL .Letext0, .LFE0, memset
9D022DB8  24060800   ADDIU A2, ZERO, 2048
433:                       if (nes.rominfo->vram)
9D022DBC  26109870   ADDIU S0, S0, -26512
9D022DC0  8E030310   LW V1, 784(S0)
9D022DC4  8C62000C   LW V0, 12(V1)
9D022DC8  10400022   BEQ V0, ZERO, 0x9D022E54
9D022DCC  00000000   NOP
434:                          mem_trash(nes.rominfo->vram, 0x2000 * nes.rominfo->vram_banks);
9D022DD0  8C71001C   LW S1, 28(V1)
9D022DD4  00118B40   SLL S1, S1, 13
435:                    }
436:                 
437:                    apu_reset();
9D022E1C  0F407826   JAL apu_reset
9D022E20  00000000   NOP
9D022E54  0F407826   JAL apu_reset
9D022E58  00000000   NOP
438:                    ppu_reset(reset_type);
9D022E24  0F40614A   JAL ppu_reset
9D022E28  02002021   ADDU A0, S0, ZERO
9D022E5C  0F40614A   JAL ppu_reset
9D022E60  24040001   ADDIU A0, ZERO, 1
439:                    mmc_reset();
9D022E2C  0F40B2DC   JAL mmc_reset
9D022E30  00000000   NOP
9D022E64  0F40B2DC   JAL mmc_reset
9D022E68  00000000   NOP
440:                    nes6502_reset();
9D022E34  0F404DCB   JAL nes6502_reset
9D022E38  00000000   NOP
9D022E6C  0F404DCB   JAL nes6502_reset
9D022E70  00000000   NOP
441:                 
442:                    nes.scanline = 241;
9D022E3C  240300F1   ADDIU V1, ZERO, 241
9D022E40  3C02A001   LUI V0, -24575
9D022E44  AC439B90   SW V1, -25712(V0)
9D022E74  240300F1   ADDIU V1, ZERO, 241
9D022E78  3C02A001   LUI V0, -24575
9D022E7C  AC439B90   SW V1, -25712(V0)
443:                 
444:                    gui_sendmsg(GUI_GREEN, "NES %s", 
9D022E04  240400C6   ADDIU A0, ZERO, 198
9D022E08  3C059D04   LUI A1, -25340
9D022E0C  0F409020   JAL gui_sendmsg
9D022E10  24A5BF9C   ADDIU A1, A1, -16484
9D022E48  3C069D04   LUI A2, -25340
9D022E4C  0B408B81   J .LBE6, .LBE5
9D022E50  24C6BF94   ADDIU A2, A2, -16492
9D022E80  3C069D04   LUI A2, -25340
9D022E84  0B408B81   J .LBE6, .LBE5
9D022E88  24C6BF88   ADDIU A2, A2, -16504
445:                                (HARD_RESET == reset_type) ? "powered on" : "reset");
446:                 }
9D022E14  0B408BA3   J 0x9D022E8C
9D022E18  8FBF001C   LW RA, 28(SP)
9D022E8C  8FB10018   LW S1, 24(SP)
9D022E90  8FB00014   LW S0, 20(SP)
9D022E94  03E00008   JR RA
9D022E98  27BD0020   ADDIU SP, SP, 32
447:                 
448:                 void nes_destroy(nes_t **machine)
449:                 {
9D022E9C  27BDFFE8   ADDIU SP, SP, -24
9D022EA0  AFBF0014   SW RA, 20(SP)
9D022EA4  AFB00010   SW S0, 16(SP)
9D022EA8  00808021   ADDU S0, A0, ZERO
450:                    if (*machine)
9D022EAC  8C840000   LW A0, 0(A0)
9D022EB0  1080001B   BEQ A0, ZERO, 0x9D022F20
9D022EB4  8FBF0014   LW RA, 20(SP)
451:                    {
452:                       rom_free(&(*machine)->rominfo);
9D022EB8  0F40AB19   JAL rom_free
9D022EBC  24840310   ADDIU A0, A0, 784
453:                       mmc_destroy(&(*machine)->mmc);
9D022EC0  8E040000   LW A0, 0(S0)
9D022EC4  0F40B322   JAL mmc_destroy
9D022EC8  2484030C   ADDIU A0, A0, 780
454:                       ppu_destroy(&(*machine)->ppu);
9D022ECC  8E040000   LW A0, 0(S0)
9D022ED0  0F4060D2   JAL ppu_destroy
9D022ED4  24840304   ADDIU A0, A0, 772
455:                       apu_destroy(&(*machine)->apu);
9D022ED8  8E040000   LW A0, 0(S0)
9D022EDC  0F4078E1   JAL apu_destroy
9D022EE0  24840308   ADDIU A0, A0, 776
456:                 //      bmp_destroy(&(*machine)->vidbuf);
457:                       if ((*machine)->cpu)
9D022EE4  8E020000   LW V0, 0(S0)
9D022EE8  8C440000   LW A0, 0(V0)
9D022EEC  10800008   BEQ A0, ZERO, .LVL92
9D022EF0  00000000   NOP
458:                       {
459:                          if ((*machine)->cpu->mem_page[0])
9D022EF4  8C820000   LW V0, 0(A0)
9D022EF8  10400003   BEQ V0, ZERO, .LVL91
9D022EFC  00000000   NOP
460:                             free((*machine)->cpu->mem_page[0]);
9D022F00  0F40DB97   JAL _my_free
9D022F04  00000000   NOP
461:                          free((*machine)->cpu);
9D022F08  0F40DB97   JAL _my_free
9D022F0C  8E040000   LW A0, 0(S0)
462:                       }
463:                 
464:                       free(*machine);
9D022F10  0F40DB97   JAL _my_free
9D022F14  02002021   ADDU A0, S0, ZERO
465:                       *machine = NULL;
9D022F18  AE000000   SW ZERO, 0(S0)
466:                    }
467:                 }
9D022F1C  8FBF0014   LW RA, 20(SP)
9D022F20  8FB00010   LW S0, 16(SP)
9D022F24  03E00008   JR RA
9D022F28  27BD0018   ADDIU SP, SP, 24
468:                 
469:                 void nes_poweroff(void)
470:                 {
471:                    nes.poweroff = true;
9D022F2C  24030001   ADDIU V1, ZERO, 1
9D022F30  3C02A001   LUI V0, -24575
9D022F34  03E00008   JR RA
9D022F38  AC439B9C   SW V1, -25700(V0)
472:                 }
473:                 
474:                 void nes_togglepause(void)
475:                 {
476:                    nes.pause ^= true;
9D022F3C  3C02A001   LUI V0, -24575
9D022F40  24429870   ADDIU V0, V0, -26512
9D022F44  8C430330   LW V1, 816(V0)
9D022F48  38630001   XORI V1, V1, 1
9D022F4C  03E00008   JR RA
9D022F50  AC430330   SW V1, 816(V0)
477:                 }
478:                 
479:                 /* insert a cart into the NES */
480:                 int nes_insertcart(const char *file_ptr, nes_t *machine)
481:                 {
9D022F54  27BDFFE0   ADDIU SP, SP, -32
9D022F58  AFBF001C   SW RA, 28(SP)
9D022F5C  AFB10018   SW S1, 24(SP)
9D022F60  AFB00014   SW S0, 20(SP)
9D022F64  00808821   ADDU S1, A0, ZERO
9D022F68  AFA50024   SW A1, 36(SP)
482:                    nes6502_setcontext(machine->cpu);
9D022F6C  0F402877   JAL nes6502_setcontext
9D022F70  8CA40000   LW A0, 0(A1)
483:                 
484:                    /* rom file */
485:                    machine->rominfo = rom_load(file_ptr);
9D022F74  8FB00024   LW S0, 36(SP)
9D022F78  0F40AB55   JAL rom_load
9D022F7C  02202021   ADDU A0, S1, ZERO
9D022F80  AE020310   SW V0, 784(S0)
486:                    if (NULL == machine->rominfo)
9D022F84  8FB00024   LW S0, 36(SP)
9D022F88  8E020310   LW V0, 784(S0)
9D022F8C  1040012B   BEQ V0, ZERO, .L69
9D022F90  00000000   NOP
487:                       goto _fail;
488:                 
489:                    /* map cart's SRAM to CPU $6000-$7FFF */
490:                    if (machine->rominfo->sram)
9D022F94  8C420008   LW V0, 8(V0)
9D022F98  10400008   BEQ V0, ZERO, 0x9D022FBC
9D022F9C  00000000   NOP
491:                    {
492:                       machine->cpu->mem_page[6] = machine->rominfo->sram;
9D022FA0  8E030000   LW V1, 0(S0)
9D022FA4  AC620018   SW V0, 24(V1)
493:                       machine->cpu->mem_page[7] = machine->rominfo->sram + 0x1000;
9D022FA8  8E020000   LW V0, 0(S0)
9D022FAC  8E030310   LW V1, 784(S0)
9D022FB0  8C630008   LW V1, 8(V1)
9D022FB4  24631000   ADDIU V1, V1, 4096
9D022FB8  AC43001C   SW V1, 28(V0)
494:                    }
495:                 
496:                    /* mapper */
497:                    machine->mmc = mmc_create(machine->rominfo);
9D022FBC  0F40B32D   JAL mmc_create
9D022FC0  8E040310   LW A0, 784(S0)
9D022FC4  AE02030C   SW V0, 780(S0)
498:                    if (NULL == machine->mmc)
9D022FC8  8FA20024   LW V0, 36(SP)
9D022FCC  8C43030C   LW V1, 780(V0)
9D022FD0  1060011A   BEQ V1, ZERO, .L69
9D022FD4  00000000   NOP
499:                       goto _fail;
500:                 
501:                    /* if there's VRAM, let the PPU know */
502:                    if (NULL != machine->rominfo->vram)
9D022FD8  8C430310   LW V1, 784(V0)
9D022FDC  8C63000C   LW V1, 12(V1)
9D022FE0  10600003   BEQ V1, ZERO, 0x9D022FF0
9D022FE4  24040001   ADDIU A0, ZERO, 1
503:                       machine->ppu->vram_present = true;
9D022FE8  8C430304   LW V1, 772(V0)
9D022FEC  AC641DB0   SW A0, 7600(V1)
504:                    
505:                    apu_setext(machine->apu, machine->mmc->intf->sound_ext);
9D022FF0  8C43030C   LW V1, 780(V0)
9D022FF4  8C630000   LW V1, 0(V1)
9D022FF8  8C440308   LW A0, 776(V0)
9D022FFC  0F4078F6   JAL apu_setext
9D023000  8C650024   LW A1, 36(V1)
506:                    
507:                    build_address_handlers(machine);
9D023004  8FB10024   LW S1, 36(SP)
508:                 
509:                    nes_setcontext(machine);
9D023424  0F408AF9   JAL nes_setcontext
9D023428  8FA40024   LW A0, 36(SP)
510:                 
511:                    nes_reset(HARD_RESET);
9D02342C  0F408B62   JAL nes_reset
9D023430  24040001   ADDIU A0, ZERO, 1
512:                    return 0;
9D023434  0B408D3D   J 0x9D0234F4
9D023438  00001021   ADDU V0, ZERO, ZERO
513:                 
514:                 _fail:
515:                    nes_destroy(&machine);
9D02343C  0F408BA7   JAL nes_destroy
9D023440  27A40024   ADDIU A0, SP, 36
516:                    return -1;
9D023444  0B408D3D   J 0x9D0234F4
9D023448  2402FFFF   ADDIU V0, ZERO, -1
517:                 }
9D0234F4  8FBF001C   LW RA, 28(SP)
9D0234F8  8FB10018   LW S1, 24(SP)
9D0234FC  8FB00014   LW S0, 20(SP)
9D023500  03E00008   JR RA
9D023504  27BD0020   ADDIU SP, SP, 32
518:                 
519:                 
520:                 /* Initialize NES CPU, hardware, etc. */
521:                 nes_t *nes_create(void)
522:                 {
9D023508  27BDFFD8   ADDIU SP, SP, -40
9D02350C  AFBF0024   SW RA, 36(SP)
9D023510  AFB00020   SW S0, 32(SP)
523:                    nes_t *machine;
524:                    sndinfo_t osd_sound;
525:                    int i;
526:                 
527:                    int sizee = sizeof(nes_t);
528:                    
529:                    machine = malloc(sizee);
9D023514  0F40DB84   JAL _my_malloc
9D023518  24040334   ADDIU A0, ZERO, 820
530:                    if (NULL == machine)
9D02351C  10400047   BEQ V0, ZERO, 0x9D02363C
9D023520  AFA20010   SW V0, 16(SP)
531:                       return NULL;
9D02363C  00001021   ADDU V0, ZERO, ZERO
532:                 
533:                    memset(machine, 0, sizeof(nes_t));
9D023524  00402021   ADDU A0, V0, ZERO
9D023528  00002821   ADDU A1, ZERO, ZERO
9D02352C  0F40E7C9   JAL .Letext0, .LFE0, memset
9D023530  24060334   ADDIU A2, ZERO, 820
534:                 
535:                    /* bitmap */
536:                    /* 8 pixel overdraw */
537:                 //   machine->vidbuf = bmp_create(NES_SCREEN_WIDTH, NES_SCREEN_HEIGHT, 8);
538:                 //   if (NULL == machine->vidbuf)
539:                 //      goto _fail;
540:                 
541:                    machine->autoframeskip = true;
9D023534  8FB00010   LW S0, 16(SP)
9D023538  24020001   ADDIU V0, ZERO, 1
9D02353C  AE020328   SW V0, 808(S0)
542:                 
543:                    /* cpu */
544:                    machine->cpu = malloc(sizeof(nes6502_context));
9D023540  0F40DB84   JAL _my_malloc
9D023544  2404005C   ADDIU A0, ZERO, 92
9D023548  AE020000   SW V0, 0(S0)
545:                    if (NULL == machine->cpu)
9D02354C  8FA20010   LW V0, 16(SP)
9D023550  8C440000   LW A0, 0(V0)
9D023554  10800035   BEQ A0, ZERO, .L115
9D023558  00002821   ADDU A1, ZERO, ZERO
546:                       goto _fail;
547:                 
548:                    memset(machine->cpu, 0, sizeof(nes6502_context));
9D02355C  0F40E7C9   JAL .Letext0, .LFE0, memset
9D023560  2406005C   ADDIU A2, ZERO, 92
549:                    
550:                    /* allocate 2kB RAM */
551:                    machine->cpu->mem_page[0] = malloc(NES_RAMSIZE);
9D023564  8FA20010   LW V0, 16(SP)
9D023568  8C500000   LW S0, 0(V0)
9D02356C  0F40DB84   JAL _my_malloc
9D023570  24040800   ADDIU A0, ZERO, 2048
9D023574  AE020000   SW V0, 0(S0)
552:                    if (NULL == machine->cpu->mem_page[0])
9D023578  8FA20010   LW V0, 16(SP)
9D02357C  8C420000   LW V0, 0(V0)
9D023580  8C420000   LW V0, 0(V0)
9D023584  10400029   BEQ V0, ZERO, .L115
9D023588  24050010   ADDIU A1, ZERO, 16
9D02358C  24020001   ADDIU V0, ZERO, 1
553:                       goto _fail;
554:                 
555:                    /* point all pages at NULL for now */
556:                    for (i = 1; i < NES6502_NUMBANKS; i++)
9D0235A0  24420001   ADDIU V0, V0, 1
9D0235A4  1445FFFA   BNE V0, A1, 0x9D023590
9D0235A8  AC600000   SW ZERO, 0(V1)
557:                       machine->cpu->mem_page[i] = NULL;
9D023590  8FA30010   LW V1, 16(SP)
9D023594  8C640000   LW A0, 0(V1)
9D023598  00021880   SLL V1, V0, 2
9D02359C  00831821   ADDU V1, A0, V1
558:                 
559:                    machine->cpu->read_handler = machine->readhandler;
9D0235AC  8FB00010   LW S0, 16(SP)
9D0235B0  8E020000   LW V0, 0(S0)
9D0235B4  26030004   ADDIU V1, S0, 4
9D0235B8  AC430040   SW V1, 64(V0)
560:                    machine->cpu->write_handler = machine->writehandler;
9D0235BC  8E020000   LW V0, 0(S0)
9D0235C0  26030184   ADDIU V1, S0, 388
9D0235C4  AC430044   SW V1, 68(V0)
561:                 
562:                    /* apu */
563:                    //osd_getsoundinfo(&osd_sound);
564:                    machine->apu = apu_create(0, osd_sound.sample_rate, NES_REFRESH_RATE, osd_sound.bps);
9D0235C8  00002021   ADDU A0, ZERO, ZERO
9D0235CC  8FA50014   LW A1, 20(SP)
9D0235D0  2406003C   ADDIU A2, ZERO, 60
9D0235D4  0F4078AC   JAL apu_create
9D0235D8  8FA70018   LW A3, 24(SP)
9D0235DC  AE020308   SW V0, 776(S0)
565:                 
566:                    if (NULL == machine->apu)
9D0235E0  8FB00010   LW S0, 16(SP)
9D0235E4  8E020308   LW V0, 776(S0)
9D0235E8  10400010   BEQ V0, ZERO, .L115
9D0235EC  3C039D02   LUI V1, -25342
567:                       goto _fail;
568:                 
569:                    /* set the IRQ routines */
570:                    machine->apu->irq_callback = nes_irq;
9D0235F0  24632918   ADDIU V1, V1, 10520
9D0235F4  AC430160   SW V1, 352(V0)
571:                    machine->apu->irqclear_callback = nes_clearfiq;
9D0235F8  8E020308   LW V0, 776(S0)
9D0235FC  3C039D02   LUI V1, -25342
9D023600  246328F0   ADDIU V1, V1, 10480
572:                 
573:                    /* ppu */
574:                    machine->ppu = ppu_create();
9D023604  0F406374   JAL ppu_create
9D023608  AC430164   SW V1, 356(V0)
9D02360C  AE020304   SW V0, 772(S0)
575:                    if (NULL == machine->ppu)
9D023610  8FA20010   LW V0, 16(SP)
9D023614  8C430304   LW V1, 772(V0)
9D023618  10600004   BEQ V1, ZERO, .L115
9D02361C  00000000   NOP
576:                       goto _fail;
577:                 
578:                    machine->poweroff = false;
9D023620  AC40032C   SW ZERO, 812(V0)
579:                    machine->pause = false;
580:                 
581:                    return machine;
9D023624  0B408D90   J 0x9D023640
9D023628  AC400330   SW ZERO, 816(V0)
582:                 
583:                 _fail:
584:                    nes_destroy(&machine);
9D02362C  0F408BA7   JAL nes_destroy
9D023630  27A40010   ADDIU A0, SP, 16
585:                    return NULL;
9D023634  0B408D90   J 0x9D023640
9D023638  00001021   ADDU V0, ZERO, ZERO
586:                 }
9D023640  8FBF0024   LW RA, 36(SP)
9D023644  8FB00020   LW S0, 32(SP)
9D023648  03E00008   JR RA
9D02364C  27BD0028   ADDIU SP, SP, 40
587:                 
588:                 /*
589:                 ** $Log: nes.c,v $
590:                 ** Revision 1.2  2001/04/27 14:37:11  neil
591:                 ** wheeee
592:                 **
593:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
594:                 ** initial
595:                 **
596:                 ** Revision 1.18  2000/11/29 12:58:23  matt
597:                 ** timing/fiq fixes
598:                 **
599:                 ** Revision 1.17  2000/11/27 19:36:15  matt
600:                 ** more timing fixes
601:                 **
602:                 ** Revision 1.16  2000/11/26 16:13:13  matt
603:                 ** slight fix (?) to nes_fiq
604:                 **
605:                 ** Revision 1.15  2000/11/26 15:51:13  matt
606:                 ** frame IRQ emulation
607:                 **
608:                 ** Revision 1.14  2000/11/25 20:30:39  matt
609:                 ** scanline emulation simplifications/timing fixes
610:                 **
611:                 ** Revision 1.13  2000/11/25 01:53:42  matt
612:                 ** bool stinks sometimes
613:                 **
614:                 ** Revision 1.12  2000/11/21 13:28:40  matt
615:                 ** take care to zero allocated mem
616:                 **
617:                 ** Revision 1.11  2000/11/20 13:23:32  matt
618:                 ** nofrendo.c now handles timer
619:                 **
620:                 ** Revision 1.10  2000/11/09 14:07:27  matt
621:                 ** state load fixed, state save mostly fixed
622:                 **
623:                 ** Revision 1.9  2000/11/05 22:19:37  matt
624:                 ** pause buglet fixed
625:                 **
626:                 ** Revision 1.8  2000/11/05 06:27:09  matt
627:                 ** thinlib spawns changes
628:                 **
629:                 ** Revision 1.7  2000/10/29 14:36:45  matt
630:                 ** nes_clearframeirq is static
631:                 **
632:                 ** Revision 1.6  2000/10/28 15:20:41  matt
633:                 ** irq callbacks in nes_apu
634:                 **
635:                 ** Revision 1.5  2000/10/27 12:55:58  matt
636:                 ** nes6502 now uses 4kB banks across the boards
637:                 **
638:                 ** Revision 1.4  2000/10/25 13:44:02  matt
639:                 ** no more silly define names
640:                 **
641:                 ** Revision 1.3  2000/10/25 01:23:08  matt
642:                 ** basic system autodetection
643:                 **
644:                 ** Revision 1.2  2000/10/25 00:23:16  matt
645:                 ** makefiles updated for new directory structure
646:                 **
647:                 ** Revision 1.1  2000/10/24 12:20:28  matt
648:                 ** changed directory structure
649:                 **
650:                 ** Revision 1.50  2000/10/23 17:51:09  matt
651:                 ** adding fds support
652:                 **
653:                 ** Revision 1.49  2000/10/23 15:53:08  matt
654:                 ** better system handling
655:                 **
656:                 ** Revision 1.48  2000/10/22 20:02:29  matt
657:                 ** autoframeskip bugfix
658:                 **
659:                 ** Revision 1.47  2000/10/22 19:16:15  matt
660:                 ** more sane timer ISR / autoframeskip
661:                 **
662:                 ** Revision 1.46  2000/10/21 19:26:59  matt
663:                 ** many more cleanups
664:                 **
665:                 ** Revision 1.45  2000/10/17 12:00:56  matt
666:                 ** selectable apu base frequency
667:                 **
668:                 ** Revision 1.44  2000/10/10 13:58:14  matt
669:                 ** stroustrup squeezing his way in the door
670:                 **
671:                 ** Revision 1.43  2000/10/10 13:05:30  matt
672:                 ** Mr. Clean makes a guest appearance
673:                 **
674:                 ** Revision 1.42  2000/10/08 17:53:37  matt
675:                 ** minor accuracy changes
676:                 **
677:                 ** Revision 1.41  2000/09/18 02:09:12  matt
678:                 ** -pedantic is your friend
679:                 **
680:                 ** Revision 1.40  2000/09/15 13:38:39  matt
681:                 ** changes for optimized apu core
682:                 **
683:                 ** Revision 1.39  2000/09/15 04:58:07  matt
684:                 ** simplifying and optimizing APU core
685:                 **
686:                 ** Revision 1.38  2000/09/08 11:57:29  matt
687:                 ** no more nes_fiq
688:                 **
689:                 ** Revision 1.37  2000/08/31 02:39:01  matt
690:                 ** moved dos stuff in here (temp)
691:                 **
692:                 ** Revision 1.36  2000/08/16 02:51:55  matt
693:                 ** random cleanups
694:                 **
695:                 ** Revision 1.35  2000/08/11 02:43:50  matt
696:                 ** moved frame irq stuff out of APU into here
697:                 **
698:                 ** Revision 1.34  2000/08/11 01:42:43  matt
699:                 ** change to OSD sound info interface
700:                 **
701:                 ** Revision 1.33  2000/07/31 04:27:59  matt
702:                 ** one million cleanups
703:                 **
704:                 ** Revision 1.32  2000/07/30 04:32:32  matt
705:                 ** emulation of the NES frame IRQ
706:                 **
707:                 ** Revision 1.31  2000/07/27 04:07:14  matt
708:                 ** cleaned up the neighborhood lawns
709:                 **
710:                 ** Revision 1.30  2000/07/27 03:59:52  neil
711:                 ** pausing tweaks, during fullscreen toggles
712:                 **
713:                 ** Revision 1.29  2000/07/27 03:19:22  matt
714:                 ** just a little cleaner, that's all
715:                 **
716:                 ** Revision 1.28  2000/07/27 02:55:23  matt
717:                 ** nes_emulate went through detox
718:                 **
719:                 ** Revision 1.27  2000/07/27 02:49:18  matt
720:                 ** cleaner flow in nes_emulate
721:                 **
722:                 ** Revision 1.26  2000/07/27 01:17:09  matt
723:                 ** nes_insertrom -> nes_insertcart
724:                 **
725:                 ** Revision 1.25  2000/07/26 21:36:14  neil
726:                 ** Big honkin' change -- see the mailing list
727:                 **
728:                 ** Revision 1.24  2000/07/25 02:25:53  matt
729:                 ** safer xxx_destroy calls
730:                 **
731:                 ** Revision 1.23  2000/07/24 04:32:40  matt
732:                 ** autoframeskip bugfix
733:                 **
734:                 ** Revision 1.22  2000/07/23 15:13:48  matt
735:                 ** apu API change, autoframeskip part of nes_t struct
736:                 **
737:                 ** Revision 1.21  2000/07/21 02:44:41  matt
738:                 ** merged osd_getinput and osd_gethostinput
739:                 **
740:                 ** Revision 1.20  2000/07/17 05:12:55  matt
741:                 ** nes_ppu.c is no longer a scary place to be-- cleaner & faster
742:                 **
743:                 ** Revision 1.19  2000/07/17 01:52:28  matt
744:                 ** made sure last line of all source files is a newline
745:                 **
746:                 ** Revision 1.18  2000/07/15 23:51:23  matt
747:                 ** hack for certain filthy NES titles
748:                 **
749:                 ** Revision 1.17  2000/07/11 04:31:54  matt
750:                 ** less magic number nastiness for screen dimensions
751:                 **
752:                 ** Revision 1.16  2000/07/11 02:38:25  matt
753:                 ** encapsulated memory address handlers into nes/nsf
754:                 **
755:                 ** Revision 1.15  2000/07/10 13:50:49  matt
756:                 ** added function nes_irq()
757:                 **
758:                 ** Revision 1.14  2000/07/10 05:27:55  matt
759:                 ** cleaned up mapper-specific callbacks
760:                 **
761:                 ** Revision 1.13  2000/07/09 03:43:26  matt
762:                 ** minor changes to gui handling
763:                 **
764:                 ** Revision 1.12  2000/07/06 16:42:23  matt
765:                 ** updated for new video driver
766:                 **
767:                 ** Revision 1.11  2000/07/05 19:57:36  neil
768:                 ** __GNUC -> __DJGPP in nes.c
769:                 **
770:                 ** Revision 1.10  2000/07/05 12:23:03  matt
771:                 ** removed unnecessary references
772:                 **
773:                 ** Revision 1.9  2000/07/04 23:12:34  matt
774:                 ** memory protection handlers
775:                 **
776:                 ** Revision 1.8  2000/07/04 04:58:29  matt
777:                 ** dynamic memory range handlers
778:                 **
779:                 ** Revision 1.7  2000/06/26 04:58:51  matt
780:                 ** minor bugfix
781:                 **
782:                 ** Revision 1.6  2000/06/20 20:42:12  matt
783:                 ** fixed some NULL pointer problems
784:                 **
785:                 ** Revision 1.5  2000/06/09 15:12:26  matt
786:                 ** initial revision
787:                 **
788:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/memguard.c  --------------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** memguard.c
21:                  **
22:                  ** memory allocation wrapper routines
23:                  **
24:                  ** NOTE: based on code (c) 1998 the Retrocade group
25:                  ** $Id: memguard.c,v 1.2 2001/04/27 14:37:11 neil Exp $
26:                  */
27:                  
28:                  #include <noftypes.h>
29:                  #include <memguard.h>
30:                  
31:                  /* undefine macro definitions, so we get real calls */
32:                  #undef malloc
33:                  #undef free
34:                  #undef strdup
35:                  
36:                  #include <string.h>
37:                  #include <stdlib.h>
38:                  #include <log.h>
39:                  
40:                  
41:                  /* Maximum number of allocated blocks at any one time */
42:                  #define  MAX_BLOCKS        4096
43:                  
44:                  /* Memory block structure */
45:                  typedef struct memblock_s
46:                  {
47:                     void  *block_addr;
48:                     int   block_size;
49:                     char  *file_name;
50:                     int   line_num;
51:                  } memblock_t;
52:                  
53:                  /* debugging flag */
54:                  bool mem_debug = true;
55:                  
56:                  
57:                  #ifdef NOFRENDO_DEBUG
58:                  
59:                  static int mem_blockcount = 0;   /* allocated block count */
60:                  static memblock_t *mem_record = NULL;
61:                  
62:                  #define  GUARD_STRING   "GgUuAaRrDdSsTtRrIiNnGgBbLlOoCcKk"
63:                  #define  GUARD_LENGTH   256         /* before and after allocated block */
64:                  
65:                  
66:                  /*
67:                  ** Check the memory guard to make sure out of bounds writes have not
68:                  ** occurred.
69:                  */
70:                  static int mem_checkguardblock(void *data, int guard_size)
71:                  {
72:                     char *check, *block;
73:                     int i, alloc_size;
74:                  
75:                     /* get the original pointer */
76:                     block = ((char *) data) - guard_size;
77:                  
78:                     /* get the size */
79:                     alloc_size = *((uint32 *) block);
80:                     block+=4;
81:                  
82:                     /* check leading guard string */
83:                     check = GUARD_STRING;
84:                     for (i = sizeof(uint32); i < guard_size; i++)
85:                     {
86:                        /* wrap */
87:                        if ('\0' == *check)
88:                           check = GUARD_STRING;
89:                        
90:                        if (*block++ != *check++)
91:                           return -1;
92:                     }
93:                  
94:                     /* check end of block */
95:                     check = GUARD_STRING;
96:                     block = ((char *) data) + alloc_size;
97:                     for (i = 0; i < guard_size; i++)
98:                     {
99:                        /* wrap */
100:                       if ('\0' == *check)
101:                          check = GUARD_STRING;
102:                       if (*block++ != *check++)
103:                          return -1;
104:                    }
105:                 
106:                    /* we're okay! */
107:                    return 0;
108:                 }
109:                 
110:                 /* free a guard block */
111:                 static void mem_freeguardblock(void *data, int guard_size)
112:                 {
113:                    char *orig = ((char *) data) - guard_size;
114:                 
115:                    free(orig);
116:                 }
117:                 
118:                 /* allocate memory, guarding with a guard block in front and behind */
119:                 static void *mem_guardalloc(int alloc_size, int guard_size)
120:                 {
121:                    void *orig;
122:                    char *block, *check;
123:                    uint32 *ptr;
124:                    int i;
125:                 
126:                    /* pad it up to a 32-bit multiple */
127:                    alloc_size = (alloc_size + 3) & ~3;
128:                 
129:                    /* allocate memory */
130:                    orig = malloc(alloc_size + (guard_size * 2));
131:                    if (NULL == orig)
132:                       return NULL;
133:                 
134:                    block = (char *) orig;
135:                    
136:                    /* get it to the pointer we will actually return */
137:                    orig = (void *) ((char *) orig + guard_size);
138:                 
139:                    /* trash it all */
140:                    ptr = (uint32 *) orig;
141:                    for (i = alloc_size / 4; i; i--)
142:                       *ptr++ = 0xDEADBEEF;
143:                    
144:                    /* store the size of the newly allocated block*/
145:                    *((uint32 *) block) = alloc_size;
146:                 	block+=4;
147:                 
148:                    /* put guard string at beginning of block */
149:                    check = GUARD_STRING;
150:                    for (i = sizeof(uint32); i < guard_size; i++)
151:                    {
152:                       /* wrap */
153:                       if ('\0' == *check)
154:                          check = GUARD_STRING;
155:                 
156:                       *block++ = *check++;
157:                    }
158:                 
159:                    /* put at end of block */
160:                    check = GUARD_STRING;
161:                    block = (char *) orig + alloc_size;
162:                    for (i = 0; i < guard_size; i++)
163:                    {
164:                       /* wrap */
165:                       if ('\0' == *check)
166:                          check = GUARD_STRING;
167:                       
168:                       *block++ = *check++;
169:                    }
170:                 
171:                    return orig;
172:                 }
173:                 
174:                 
175:                 /* Free up the space used by the memory block manager */
176:                 void mem_cleanup(void)
177:                 {
178:                    if (mem_record)
179:                    {
180:                       free(mem_record);
181:                       mem_record = NULL;
182:                    }
183:                 }
184:                 
185:                 
186:                 /* Allocate a bunch of memory to keep track of all memory blocks */
187:                 static void mem_init(void)
188:                 {
189:                    mem_cleanup();
190:                 
191:                    mem_blockcount = 0;
192:                 
193:                    mem_record = malloc(MAX_BLOCKS * sizeof(memblock_t));
194:                    ASSERT(mem_record);
195:                    memset(mem_record, 0, MAX_BLOCKS * sizeof(memblock_t));
196:                 }
197:                 
198:                 
199:                 /* add a block of memory to the master record */
200:                 static void mem_addblock(void *data, int block_size, char *file, int line)
201:                 {
202:                    int i;
203:                 
204:                    for (i = 0; i < MAX_BLOCKS; i++)
205:                    {
206:                       if (NULL == mem_record[i].block_addr)
207:                       {
208:                          mem_record[i].block_addr = data;
209:                          mem_record[i].block_size = block_size;
210:                          mem_record[i].file_name = file;
211:                          mem_record[i].line_num = line;
212:                          return;
213:                       }
214:                    }
215:                 
216:                    ASSERT_MSG("out of memory blocks.");
217:                 }
218:                 
219:                 /* find an entry in the block record and delete it */
220:                 static void mem_deleteblock(void *data, char *file, int line)
221:                 {
222:                    int i;
223:                    char fail[256];
224:                 
225:                    for (i = 0; i < MAX_BLOCKS; i++)
226:                    {
227:                       if (data == mem_record[i].block_addr)
228:                       {
229:                          if (mem_checkguardblock(mem_record[i].block_addr, GUARD_LENGTH))
230:                          {
231:                             sprintf(fail, "mem_deleteblock 0x%08X at line %d of %s -- block corrupt",
232:                                     (uint32) data, line, file);
233:                             ASSERT_MSG(fail);
234:                          }
235:                 
236:                          memset(&mem_record[i], 0, sizeof(memblock_t));
237:                          return;
238:                       }
239:                    }
240:                 
241:                    sprintf(fail, "mem_deleteblock 0x%08X at line %d of %s -- block not found",
242:                            (uint32) data, line, file);
243:                    ASSERT_MSG(fail);
244:                 }
245:                 #endif /* NOFRENDO_DEBUG */
246:                 
247:                 /* debugger-friendly versions of calls */
248:                 #ifdef NOFRENDO_DEBUG
249:                 
250:                 /* allocates memory and clears it */
251:                 void *_my_malloc(int size, char *file, int line)
252:                 {
253:                    void *temp;
254:                    char fail[256];
255:                 
256:                    if (NULL == mem_record && false != mem_debug)
257:                       mem_init();
258:                 
259:                    if (false != mem_debug)
260:                       temp = mem_guardalloc(size, GUARD_LENGTH);
261:                    else
262:                       temp = malloc(size);
263:                 
264:                    printf("Malloc: %d at %s:%d\n", size, file, line);
265:                    if (NULL == temp)
266:                    {
267:                       sprintf(fail, "malloc: out of memory at line %d of %s.  block size: %d\n",
268:                               line, file, size);
269:                       ASSERT_MSG(fail);
270:                    }
271:                 
272:                    if (false != mem_debug)
273:                       mem_addblock(temp, size, file, line);
274:                 
275:                    mem_blockcount++;
276:                 
277:                    return temp;
278:                 }
279:                 
280:                 /* free a pointer allocated with my_malloc */
281:                 void _my_free(void **data, char *file, int line)
282:                 {
283:                    char fail[256];
284:                 
285:                    if (NULL == data || NULL == *data)
286:                    {
287:                       sprintf(fail, "free: attempted to free NULL pointer at line %d of %s\n",
288:                               line, file);
289:                       ASSERT_MSG(fail);
290:                    }
291:                 
292:                    /* if this is true, we are in REAL trouble */
293:                    if (0 == mem_blockcount)
294:                    {
295:                       ASSERT_MSG("free: attempted to free memory when no blocks available");
296:                    }
297:                 
298:                    mem_blockcount--; /* dec our block count */
299:                 
300:                    if (false != mem_debug)
301:                    {
302:                       mem_deleteblock(*data, file, line);
303:                       mem_freeguardblock(*data, GUARD_LENGTH);
304:                    }
305:                    else
306:                    {
307:                       free(*data);
308:                    }
309:                 
310:                    *data = NULL; /* NULL our source */
311:                 }
312:                 
313:                 char *_my_strdup(const char *string, char *file, int line)
314:                 {
315:                    char *temp;
316:                 
317:                    if (NULL == string)
318:                       return NULL;
319:                 
320:                    temp = (char *) _my_malloc(strlen(string) + 1, file, line);
321:                    if (NULL == temp)
322:                       return NULL;
323:                 
324:                    strcpy(temp, string);
325:                 
326:                    return temp;
327:                 }
328:                 
329:                 #else /* !NOFRENDO_DEBUG */
330:                 
331:                 /* allocates memory and clears it */
332:                 void *_my_malloc(int size)
333:                 {
9D036E10  27BDFEE0   ADDIU SP, SP, -288
9D036E14  AFBF011C   SW RA, 284(SP)
9D036E18  AFB10118   SW S1, 280(SP)
9D036E1C  AFB00114   SW S0, 276(SP)
334:                    void *temp;
335:                    char fail[256];
336:                 
337:                    temp = malloc(size);
9D036E20  0F40AC40   JAL .Letext0, .LFE16, malloc
9D036E24  00808821   ADDU S1, A0, ZERO
338:                 
339:                    if (NULL == temp)
9D036E28  14400006   BNE V0, ZERO, .LVL2
9D036E2C  00408021   ADDU S0, V0, ZERO
340:                    {
341:                       sprintf(fail, "malloc: out of memory.  block size: %d\n", size);
9D036E30  27A40010   ADDIU A0, SP, 16
9D036E34  3C059D04   LUI A1, -25340
9D036E38  24A5B6A0   ADDIU A1, A1, -18784
9D036E3C  0F40EBB1   JAL _sprintf_cdnopuxX, _sprintf_cdnopsuxX
9D036E40  02203021   ADDU A2, S1, ZERO
342:                       ASSERT_MSG(fail);
343:                    }
344:                 
345:                    return temp;
346:                 }
9D036E44  02001021   ADDU V0, S0, ZERO
9D036E48  8FBF011C   LW RA, 284(SP)
9D036E4C  8FB10118   LW S1, 280(SP)
9D036E50  8FB00114   LW S0, 276(SP)
9D036E54  03E00008   JR RA
9D036E58  27BD0120   ADDIU SP, SP, 288
347:                 
348:                 /* free a pointer allocated with my_malloc */
349:                 void _my_free(void **data)
350:                 {
9D036E5C  27BDFEE8   ADDIU SP, SP, -280
9D036E60  AFBF0114   SW RA, 276(SP)
9D036E64  AFB00110   SW S0, 272(SP)
351:                    char fail[256];
352:                 
353:                    if (NULL == data || NULL == *data)
9D036E68  10800004   BEQ A0, ZERO, 0x9D036E7C
9D036E6C  00808021   ADDU S0, A0, ZERO
9D036E70  8C820000   LW V0, 0(A0)
9D036E74  14400016   BNE V0, ZERO, 0x9D036ED0
9D036E78  00000000   NOP
354:                    {
355:                       sprintf(fail, "free: attempted to free NULL pointer.\n");
9D036E7C  3C029D04   LUI V0, -25340
9D036E80  2442B6C8   ADDIU V0, V0, -18744
9D036E84  27A30010   ADDIU V1, SP, 16
9D036E88  24440020   ADDIU A0, V0, 32
9D036E8C  8C480000   LW T0, 0(V0)
9D036E90  8C470004   LW A3, 4(V0)
9D036E94  8C460008   LW A2, 8(V0)
9D036E98  8C45000C   LW A1, 12(V0)
9D036E9C  AC680000   SW T0, 0(V1)
9D036EA0  AC670004   SW A3, 4(V1)
9D036EA4  AC660008   SW A2, 8(V1)
9D036EA8  AC65000C   SW A1, 12(V1)
9D036EAC  24420010   ADDIU V0, V0, 16
9D036EB0  1444FFF6   BNE V0, A0, 0x9D036E8C
9D036EB4  24630010   ADDIU V1, V1, 16
9D036EB8  8C440000   LW A0, 0(V0)
9D036EBC  AC640000   SW A0, 0(V1)
9D036EC0  94440004   LHU A0, 4(V0)
9D036EC4  A4640004   SH A0, 4(V1)
9D036EC8  90420006   LBU V0, 6(V0)
9D036ECC  A0620006   SB V0, 6(V1)
356:                       ASSERT_MSG(fail);
357:                    }
358:                 
359:                    free(*data);
9D036ED0  0F40CEBA   JAL free
9D036ED4  8E040000   LW A0, 0(S0)
360:                    *data = NULL; /* NULL our source */
9D036ED8  AE000000   SW ZERO, 0(S0)
361:                 }
9D036EDC  8FBF0114   LW RA, 276(SP)
9D036EE0  8FB00110   LW S0, 272(SP)
9D036EE4  03E00008   JR RA
9D036EE8  27BD0118   ADDIU SP, SP, 280
362:                 
363:                 char *_my_strdup(const char *string)
364:                 {
9D036EEC  27BDFFE0   ADDIU SP, SP, -32
9D036EF0  AFBF001C   SW RA, 28(SP)
9D036EF4  AFB10018   SW S1, 24(SP)
9D036EF8  AFB00014   SW S0, 20(SP)
365:                    char *temp;
366:                 
367:                    if (NULL == string)
9D036EFC  1080000C   BEQ A0, ZERO, 0x9D036F30
9D036F00  00808021   ADDU S0, A0, ZERO
368:                       return NULL;
9D036F30  0B40DBCE   J 0x9D036F38
9D036F34  00001021   ADDU V0, ZERO, ZERO
369:                 
370:                    /* will ASSERT for us */
371:                    temp = (char *) _my_malloc(strlen(string) + 1);
9D036F04  0F40D9CB   JAL strlen
9D036F08  00000000   NOP
9D036F0C  0F40DB84   JAL _my_malloc
9D036F10  24440001   ADDIU A0, V0, 1
372:                    if (NULL == temp)
9D036F14  10400008   BEQ V0, ZERO, 0x9D036F38
9D036F18  00408821   ADDU S1, V0, ZERO
373:                       return NULL;
374:                 
375:                    strcpy(temp, string);
9D036F1C  00402021   ADDU A0, V0, ZERO
9D036F20  0F40D714   JAL .LFE23, strcpy
9D036F24  02002821   ADDU A1, S0, ZERO
376:                 
377:                    return temp;
9D036F28  0B40DBCE   J 0x9D036F38
9D036F2C  02201021   ADDU V0, S1, ZERO
378:                 }
9D036F38  8FBF001C   LW RA, 28(SP)
9D036F3C  8FB10018   LW S1, 24(SP)
9D036F40  8FB00014   LW S0, 20(SP)
9D036F44  03E00008   JR RA
9D036F48  27BD0020   ADDIU SP, SP, 32
379:                 
380:                 #endif /* !NOFRENDO_DEBUG */
381:                 
382:                 /* check for orphaned memory handles */
383:                 void mem_checkleaks(void)
384:                 {
9D036F4C  03E00008   JR RA
9D036F50  00000000   NOP
385:                 #ifdef NOFRENDO_DEBUG
386:                    int i;
387:                 
388:                    if (false == mem_debug || NULL == mem_record)
389:                       return;
390:                 
391:                    if (mem_blockcount)
392:                    {
393:                       log_printf("memory leak - %d unfreed block%s\n\n", mem_blockcount, 
394:                          mem_blockcount == 1 ? "" : "s");
395:                 
396:                       for (i = 0; i < MAX_BLOCKS; i++)
397:                       {
398:                          if (mem_record[i].block_addr)
399:                          {
400:                             log_printf("addr: 0x%08X, size: %d, line %d of %s%s\n",
401:                                     (uint32) mem_record[i].block_addr,
402:                                     mem_record[i].block_size,
403:                                     mem_record[i].line_num,
404:                                     mem_record[i].file_name,
405:                                     (mem_checkguardblock(mem_record[i].block_addr, GUARD_LENGTH))
406:                                     ? " -- block corrupt" : "");
407:                          }
408:                       }
409:                    }
410:                    else
411:                       log_printf("no memory leaks\n");
412:                 #endif /* NOFRENDO_DEBUG */
413:                 }
414:                 
415:                 void mem_checkblocks(void)
416:                 {
9D036F54  03E00008   JR RA
417:                 #ifdef NOFRENDO_DEBUG
418:                    int i;
419:                 
420:                    if (false == mem_debug || NULL == mem_record)
421:                       return;
422:                 
423:                    for (i = 0; i < MAX_BLOCKS; i++)
424:                    {
425:                       if (mem_record[i].block_addr)
426:                       {
427:                          if (mem_checkguardblock(mem_record[i].block_addr, GUARD_LENGTH))
428:                          {
429:                             log_printf("addr: 0x%08X, size: %d, line %d of %s -- block corrupt\n",
430:                                     (uint32) mem_record[i].block_addr,
431:                                     mem_record[i].block_size,
432:                                     mem_record[i].line_num,
433:                                     mem_record[i].file_name);
434:                          }
435:                       }
436:                    }
437:                 #endif /* NOFRENDO_DEBUG */
438:                 }
439:                 
440:                 /*
441:                 ** $Log: memguard.c,v $
442:                 ** Revision 1.2  2001/04/27 14:37:11  neil
443:                 ** wheeee
444:                 **
445:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
446:                 ** initial
447:                 **
448:                 ** Revision 1.23  2000/11/24 21:42:48  matt
449:                 ** vc complaints
450:                 **
451:                 ** Revision 1.22  2000/11/21 13:27:30  matt
452:                 ** trash all newly allocated memory
453:                 **
454:                 ** Revision 1.21  2000/11/21 13:22:30  matt
455:                 ** memory guard shouldn't zero memory for us
456:                 **
457:                 ** Revision 1.20  2000/10/28 14:01:53  matt
458:                 ** memguard.h was being included in the wrong place
459:                 **
460:                 ** Revision 1.19  2000/10/26 22:48:33  matt
461:                 ** strdup'ing a NULL ptr returns NULL
462:                 **
463:                 ** Revision 1.18  2000/10/25 13:41:29  matt
464:                 ** added strdup
465:                 **
466:                 ** Revision 1.17  2000/10/10 13:58:13  matt
467:                 ** stroustrup squeezing his way in the door
468:                 **
469:                 ** Revision 1.16  2000/10/10 13:03:54  matt
470:                 ** Mr. Clean makes a guest appearance
471:                 **
472:                 ** Revision 1.15  2000/09/18 02:06:48  matt
473:                 ** -pedantic is your friend
474:                 **
475:                 ** Revision 1.14  2000/08/11 01:45:48  matt
476:                 ** hearing about no corrupt blocks every 10 seconds really was annoying
477:                 **
478:                 ** Revision 1.13  2000/07/31 04:28:46  matt
479:                 ** one million cleanups
480:                 **
481:                 ** Revision 1.12  2000/07/24 04:31:07  matt
482:                 ** mem_checkblocks now gives feedback
483:                 **
484:                 ** Revision 1.11  2000/07/06 17:20:52  matt
485:                 ** block manager space itself wasn't being freed - d'oh!
486:                 **
487:                 ** Revision 1.10  2000/07/06 17:15:43  matt
488:                 ** false isn't NULL, Neil... =)
489:                 **
490:                 ** Revision 1.9  2000/07/05 23:10:01  neil
491:                 ** It's a shame if the memguard segfaults
492:                 **
493:                 ** Revision 1.8  2000/06/26 04:54:48  matt
494:                 ** simplified and made more robust
495:                 **
496:                 ** Revision 1.7  2000/06/12 01:11:41  matt
497:                 ** cleaned up some error output for win32
498:                 **
499:                 ** Revision 1.6  2000/06/09 15:12:25  matt
500:                 ** initial revision
501:                 **
502:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/mapvrc.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map_vrc.c
21:                  **
22:                  ** VRC mapper interface
23:                  ** $Id: mapvrc.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes.h>
29:                  #include <log.h>
30:                  
31:                  #define VRC_VBANK(bank, value, high) \
32:                  { \
33:                     if ((high)) \
34:                        highnybbles[(bank)] = (value) & 0x0F; \
35:                     else \
36:                        lownybbles[(bank)] = (value) & 0x0F; \
37:                     mmc_bankvrom(1, (bank) << 10, (highnybbles[(bank)] << 4)+lownybbles[(bank)]); \
38:                  }
39:                  
40:                  static struct
41:                  {
42:                     int counter, enabled;
43:                     int latch, wait_state;
44:                  } irq;
45:                  
46:                  static int select_c000 = 0;
47:                  static uint8 lownybbles[8];
48:                  static uint8 highnybbles[8];
49:                  
50:                  static void vrc_init(void)
51:                  {
52:                     irq.counter = irq.enabled = 0;
9D0219B8  3C03A001   LUI V1, -24575
9D0219BC  2462B8C4   ADDIU V0, V1, -18236
9D0219C0  AC400004   SW ZERO, 4(V0)
9D0219C4  AC60B8C4   SW ZERO, -18236(V1)
53:                     irq.latch = irq.wait_state = 0;
9D0219C8  AC40000C   SW ZERO, 12(V0)
9D0219CC  03E00008   JR RA
9D0219D0  AC400008   SW ZERO, 8(V0)
54:                  }
55:                  
56:                  static void map21_write(uint32 address, uint8 value)
57:                  {
9D021A0C  27BDFFE8   ADDIU SP, SP, -24
9D021A10  AFBF0014   SW RA, 20(SP)
58:                     switch (address)
9D021A14  3402D002   ORI V0, ZERO, -12286
9D021A18  10820151   BEQ A0, V0, 0x9D021F60
9D021A1C  00A03021   ADDU A2, A1, ZERO
9D021A20  3402D003   ORI V0, ZERO, -12285
9D021A24  0082102B   SLTU V0, A0, V0
9D021A28  10400061   BEQ V0, ZERO, 0x9D021BB0
9D021A2C  3402B080   ORI V0, ZERO, -20352
9D021A30  10820108   BEQ A0, V0, 0x9D021E54
9D021A34  3402B081   ORI V0, ZERO, -20351
9D021A38  0082102B   SLTU V0, A0, V0
9D021A3C  1040002C   BEQ V0, ZERO, 0x9D021AF0
9D021A40  3402B001   ORI V0, ZERO, -20479
9D021A44  10820103   BEQ A0, V0, 0x9D021E54
9D021A48  3402B002   ORI V0, ZERO, -20478
9D021A4C  0082102B   SLTU V0, A0, V0
9D021A50  10400013   BEQ V0, ZERO, 0x9D021AA0
9D021A54  34029002   ORI V0, ZERO, -28670
9D021A58  108200E4   BEQ A0, V0, 0x9D021DEC
9D021A5C  34029003   ORI V0, ZERO, -28669
9D021A60  0082102B   SLTU V0, A0, V0
9D021A64  10400008   BEQ V0, ZERO, 0x9D021A88
9D021A68  3402A000   ORI V0, ZERO, -24576
9D021A6C  34028000   ORI V0, ZERO, -32768
9D021A70  108200B0   BEQ A0, V0, 0x9D021D34
9D021A74  34029000   ORI V0, ZERO, -28672
9D021A78  508200B9   BEQL A0, V0, 0x9D021D60
9D021A7C  30A60003   ANDI A2, A1, 3
9D021A88  108200DB   BEQ A0, V0, 0x9D021DF8
9D021A8C  3402B000   ORI V0, ZERO, -20480
9D021A90  508200DE   BEQL A0, V0, 0x9D021E0C
9D021A94  30A6000F   ANDI A2, A1, 15
9D021AA0  3402B004   ORI V0, ZERO, -20476
9D021AA4  108200EB   BEQ A0, V0, 0x9D021E54
9D021AA8  3402B005   ORI V0, ZERO, -20475
9D021AAC  0082102B   SLTU V0, A0, V0
9D021AB0  10400009   BEQ V0, ZERO, 0x9D021AD8
9D021AB4  3402B006   ORI V0, ZERO, -20474
9D021AB8  3402B002   ORI V0, ZERO, -20478
9D021ABC  508200DC   BEQL A0, V0, 0x9D021E30
9D021AC0  30C6000F   ANDI A2, A2, 15
9D021AC4  3402B003   ORI V0, ZERO, -20477
9D021AC8  508200ED   BEQL A0, V0, 0x9D021E80
9D021ACC  30C6000F   ANDI A2, A2, 15
9D021AD8  108200E8   BEQ A0, V0, 0x9D021E7C
9D021ADC  3402B040   ORI V0, ZERO, -20416
9D021AE0  508200D3   BEQL A0, V0, 0x9D021E30
9D021AE4  30C6000F   ANDI A2, A2, 15
9D021AF0  3402C004   ORI V0, ZERO, -16380
9D021AF4  108200FD   BEQ A0, V0, 0x9D021EEC
9D021AF8  3402C005   ORI V0, ZERO, -16379
9D021AFC  0082102B   SLTU V0, A0, V0
9D021B00  10400015   BEQ V0, ZERO, 0x9D021B58
9D021B04  3402C080   ORI V0, ZERO, -16256
9D021B08  3402C001   ORI V0, ZERO, -16383
9D021B0C  108200F7   BEQ A0, V0, 0x9D021EEC
9D021B10  3402C002   ORI V0, ZERO, -16382
9D021B14  0082102B   SLTU V0, A0, V0
9D021B18  10400007   BEQ V0, ZERO, 0x9D021B38
9D021B1C  3402B0C0   ORI V0, ZERO, -20288
9D021B20  108200D6   BEQ A0, V0, 0x9D021E7C
9D021B24  3402C000   ORI V0, ZERO, -16384
9D021B28  508200DE   BEQL A0, V0, 0x9D021EA4
9D021B2C  30A6000F   ANDI A2, A1, 15
9D021B38  3402C002   ORI V0, ZERO, -16382
9D021B3C  508200E2   BEQL A0, V0, 0x9D021EC8
9D021B40  30C6000F   ANDI A2, A2, 15
9D021B44  3402C003   ORI V0, ZERO, -16381
9D021B48  508200F3   BEQL A0, V0, 0x9D021F18
9D021B4C  30C6000F   ANDI A2, A2, 15
9D021B58  108200E4   BEQ A0, V0, 0x9D021EEC
9D021B5C  3402C081   ORI V0, ZERO, -16255
9D021B60  0082102B   SLTU V0, A0, V0
9D021B64  10400008   BEQ V0, ZERO, 0x9D021B88
9D021B68  3402D000   ORI V0, ZERO, -12288
9D021B6C  3402C006   ORI V0, ZERO, -16378
9D021B70  108200E8   BEQ A0, V0, 0x9D021F14
9D021B74  3402C040   ORI V0, ZERO, -16320
9D021B78  508200D3   BEQL A0, V0, 0x9D021EC8
9D021B7C  30C6000F   ANDI A2, A2, 15
9D021B88  508200EC   BEQL A0, V0, 0x9D021F3C
9D021B8C  30A6000F   ANDI A2, A1, 15
9D021B90  3402D001   ORI V0, ZERO, -12287
9D021B94  0082102B   SLTU V0, A0, V0
9D021B98  104000FB   BEQ V0, ZERO, 0x9D021F88
9D021B9C  3402C0C0   ORI V0, ZERO, -16192
9D021BA0  508200DD   BEQL A0, V0, 0x9D021F18
9D021BA4  30C6000F   ANDI A2, A2, 15
9D021BB0  3402E006   ORI V0, ZERO, -8186
9D021BB4  10820124   BEQ A0, V0, 0x9D022048
9D021BB8  3402E007   ORI V0, ZERO, -8185
9D021BBC  0082102B   SLTU V0, A0, V0
9D021BC0  1040002E   BEQ V0, ZERO, 0x9D021C7C
9D021BC4  3402F002   ORI V0, ZERO, -4094
9D021BC8  3402D0C0   ORI V0, ZERO, -12096
9D021BCC  108200F8   BEQ A0, V0, 0x9D021FB0
9D021BD0  3402D0C1   ORI V0, ZERO, -12095
9D021BD4  0082102B   SLTU V0, A0, V0
9D021BD8  10400015   BEQ V0, ZERO, 0x9D021C30
9D021BDC  3402E002   ORI V0, ZERO, -8190
9D021BE0  3402D006   ORI V0, ZERO, -12282
9D021BE4  108200F2   BEQ A0, V0, 0x9D021FB0
9D021BE8  3402D007   ORI V0, ZERO, -12281
9D021BEC  0082102B   SLTU V0, A0, V0
9D021BF0  10400008   BEQ V0, ZERO, 0x9D021C14
9D021BF4  3402D040   ORI V0, ZERO, -12224
9D021BF8  3402D003   ORI V0, ZERO, -12285
9D021BFC  108200EC   BEQ A0, V0, 0x9D021FB0
9D021C00  3402D004   ORI V0, ZERO, -12284
9D021C04  508200E1   BEQL A0, V0, 0x9D021F8C
9D021C08  30C6000F   ANDI A2, A2, 15
9D021C14  508200D3   BEQL A0, V0, 0x9D021F64
9D021C18  30C6000F   ANDI A2, A2, 15
9D021C1C  3402D080   ORI V0, ZERO, -12160
9D021C20  508200DA   BEQL A0, V0, 0x9D021F8C
9D021C24  30C6000F   ANDI A2, A2, 15
9D021C30  108200F2   BEQ A0, V0, 0x9D021FFC
9D021C34  3402E003   ORI V0, ZERO, -8189
9D021C38  0082102B   SLTU V0, A0, V0
9D021C3C  10400008   BEQ V0, ZERO, 0x9D021C60
9D021C40  3402E000   ORI V0, ZERO, -8192
9D021C44  508200E4   BEQL A0, V0, 0x9D021FD8
9D021C48  30A6000F   ANDI A2, A1, 15
9D021C4C  3402E001   ORI V0, ZERO, -8191
9D021C50  508200F4   BEQL A0, V0, 0x9D022024
9D021C54  30C6000F   ANDI A2, A2, 15
9D021C60  3402E003   ORI V0, ZERO, -8189
9D021C64  108200F8   BEQ A0, V0, 0x9D022048
9D021C68  3402E004   ORI V0, ZERO, -8188
9D021C6C  508200ED   BEQL A0, V0, 0x9D022024
9D021C70  30C6000F   ANDI A2, A2, 15
9D021C7C  10820103   BEQ A0, V0, 0x9D02208C
9D021C80  3402F003   ORI V0, ZERO, -4093
9D021C84  0082102B   SLTU V0, A0, V0
9D021C88  10400015   BEQ V0, ZERO, 0x9D021CE0
9D021C8C  3402E0C0   ORI V0, ZERO, -8000
9D021C90  108200ED   BEQ A0, V0, 0x9D022048
9D021C94  3402E0C1   ORI V0, ZERO, -7999
9D021C98  0082102B   SLTU V0, A0, V0
9D021C9C  10400009   BEQ V0, ZERO, 0x9D021CC4
9D021CA0  3402F000   ORI V0, ZERO, -4096
9D021CA4  3402E040   ORI V0, ZERO, -8128
9D021CA8  508200D5   BEQL A0, V0, 0x9D022000
9D021CAC  30C6000F   ANDI A2, A2, 15
9D021CB0  3402E080   ORI V0, ZERO, -8064
9D021CB4  508200DB   BEQL A0, V0, 0x9D022024
9D021CB8  30C6000F   ANDI A2, A2, 15
9D021CC4  108200EA   BEQ A0, V0, 0x9D022070
9D021CC8  3C02A001   LUI V0, -24575
9D021CCC  3402F001   ORI V0, ZERO, -4095
9D021CD0  108200F8   BEQ A0, V0, 0x9D0220B4
9D021CD4  3C03A001   LUI V1, -24575
9D021CE0  3402F006   ORI V0, ZERO, -4090
9D021CE4  108200FB   BEQ A0, V0, 0x9D0220D4
9D021CE8  3402F007   ORI V0, ZERO, -4089
9D021CEC  0082102B   SLTU V0, A0, V0
9D021CF0  10400008   BEQ V0, ZERO, 0x9D021D14
9D021CF4  3402F080   ORI V0, ZERO, -3968
9D021CF8  3402F003   ORI V0, ZERO, -4093
9D021CFC  108200F5   BEQ A0, V0, 0x9D0220D4
9D021D00  3402F004   ORI V0, ZERO, -4092
9D021D04  108200EB   BEQ A0, V0, 0x9D0220B4
9D021D08  3C03A001   LUI V1, -24575
9D021D14  108200E6   BEQ A0, V0, 0x9D0220B0
9D021D18  3402F0C0   ORI V0, ZERO, -3904
9D021D1C  108200ED   BEQ A0, V0, 0x9D0220D4
9D021D20  3402F040   ORI V0, ZERO, -4032
9D021D24  108200DA   BEQ A0, V0, 0x9D022090
9D021D28  3C02A001   LUI V0, -24575
59:                     {
60:                     case 0x8000:
61:                        if (select_c000) 
9D021D34  8F8280D0   LW V0, -32560(GP)
9D021D38  10400005   BEQ V0, ZERO, 0x9D021D50
9D021D3C  24040008   ADDIU A0, ZERO, 8
62:                           mmc_bankrom(8, 0xC000,value);
9D021D40  0F40B246   JAL mmc_bankrom
9D021D44  3405C000   ORI A1, ZERO, -16384
9D021D48  0B40883A   J 0x9D0220E8
9D021D4C  8FBF0014   LW RA, 20(SP)
63:                        else
64:                           mmc_bankrom(8, 0x8000,value);
9D021D50  0F40B246   JAL mmc_bankrom
9D021D54  34058000   ORI A1, ZERO, -32768
65:                        break;
66:                  
67:                     case 0x9000:
68:                        switch (value & 3)
9D021D60  24020001   ADDIU V0, ZERO, 1
9D021D64  10C2000F   BEQ A2, V0, 0x9D021DA4
9D021D68  00002021   ADDU A0, ZERO, ZERO
9D021D6C  10C00007   BEQ A2, ZERO, 0x9D021D8C
9D021D70  24020002   ADDIU V0, ZERO, 2
9D021D74  10C20011   BEQ A2, V0, 0x9D021DBC
9D021D78  24020003   ADDIU V0, ZERO, 3
9D021D7C  10C20015   BEQ A2, V0, 0x9D021DD4
9D021D80  24040001   ADDIU A0, ZERO, 1
69:                        {
70:                        case 0:
71:                           ppu_mirror(0, 1, 0, 1); /* vertical */
9D021D8C  24050001   ADDIU A1, ZERO, 1
9D021D90  00003021   ADDU A2, ZERO, ZERO
9D021D94  0F406128   JAL ppu_mirror
9D021D98  24070001   ADDIU A3, ZERO, 1
72:                           break;
9D021D9C  0B40883A   J 0x9D0220E8
9D021DA0  8FBF0014   LW RA, 20(SP)
73:                  
74:                        case 1: 
75:                           ppu_mirror(0, 0, 1, 1); /* horizontal */
9D021DA4  00002821   ADDU A1, ZERO, ZERO
9D021DA8  24060001   ADDIU A2, ZERO, 1
9D021DAC  0F406128   JAL ppu_mirror
9D021DB0  24070001   ADDIU A3, ZERO, 1
76:                           break;
9D021DB4  0B40883A   J 0x9D0220E8
9D021DB8  8FBF0014   LW RA, 20(SP)
77:                  
78:                        case 2: 
79:                           ppu_mirror(0, 0, 0, 0); 
9D021DBC  00002821   ADDU A1, ZERO, ZERO
9D021DC0  00003021   ADDU A2, ZERO, ZERO
9D021DC4  0F406128   JAL ppu_mirror
9D021DC8  00003821   ADDU A3, ZERO, ZERO
80:                           break;
9D021DCC  0B40883A   J 0x9D0220E8
9D021DD0  8FBF0014   LW RA, 20(SP)
81:                  
82:                        case 3: 
83:                           ppu_mirror(1, 1, 1, 1); 
9D021DD4  24050001   ADDIU A1, ZERO, 1
9D021DD8  24060001   ADDIU A2, ZERO, 1
9D021DDC  0F406128   JAL ppu_mirror
9D021DE0  24070001   ADDIU A3, ZERO, 1
84:                           break;
9D021DE4  0B40883A   J 0x9D0220E8
9D021DE8  8FBF0014   LW RA, 20(SP)
85:                  
86:                        default: 
87:                           break;
88:                        }
89:                        break;
90:                     case 0x9002: select_c000=(value&0x02)>>1; break;
9D021DEC  7CA60040   EXT A2, A1, 1, 1
9D021DF0  0B408839   J 0x9D0220E4
9D021DF4  AF8680D0   SW A2, -32560(GP)
91:                     case 0xA000: mmc_bankrom(8, 0xA000,value); break;
9D021DF8  24040008   ADDIU A0, ZERO, 8
9D021DFC  0F40B246   JAL mmc_bankrom
9D021E00  3405A000   ORI A1, ZERO, -24576
9D021E04  0B40883A   J 0x9D0220E8
9D021E08  8FBF0014   LW RA, 20(SP)
92:                  
93:                     case 0xB000: VRC_VBANK(0,value,0); break;
9D021E0C  A38680C8   SB A2, -32568(GP)
9D021E10  938280C0   LBU V0, -32576(GP)
9D021E14  00021100   SLL V0, V0, 4
9D021E18  24040001   ADDIU A0, ZERO, 1
9D021E1C  00002821   ADDU A1, ZERO, ZERO
9D021E20  0F40B1E8   JAL mmc_bankvrom
9D021E24  00463021   ADDU A2, V0, A2
9D021E28  0B40883A   J 0x9D0220E8
9D021E2C  8FBF0014   LW RA, 20(SP)
94:                     case 0xB002:
95:                     case 0xB040: VRC_VBANK(0,value,1); break;
9D021E30  A38680C0   SB A2, -32576(GP)
9D021E34  00063100   SLL A2, A2, 4
9D021E38  938280C8   LBU V0, -32568(GP)
9D021E3C  24040001   ADDIU A0, ZERO, 1
9D021E40  00002821   ADDU A1, ZERO, ZERO
9D021E44  0F40B1E8   JAL mmc_bankvrom
9D021E48  00C23021   ADDU A2, A2, V0
9D021E4C  0B40883A   J 0x9D0220E8
9D021E50  8FBF0014   LW RA, 20(SP)
96:                     case 0xB001:
97:                     case 0xB004:
98:                     case 0xB080: VRC_VBANK(1,value,0); break;
9D021E54  30C6000F   ANDI A2, A2, 15
9D021E58  A38680C9   SB A2, -32567(GP)
9D021E5C  938280C1   LBU V0, -32575(GP)
9D021E60  00021100   SLL V0, V0, 4
9D021E64  24040001   ADDIU A0, ZERO, 1
9D021E68  24050400   ADDIU A1, ZERO, 1024
9D021E6C  0F40B1E8   JAL mmc_bankvrom
9D021E70  00463021   ADDU A2, V0, A2
9D021E74  0B40883A   J 0x9D0220E8
9D021E78  8FBF0014   LW RA, 20(SP)
99:                     case 0xB003:
100:                    case 0xB006:
101:                    case 0xB0C0: VRC_VBANK(1,value,1); break;
9D021E7C  30C6000F   ANDI A2, A2, 15
9D021E80  A38680C1   SB A2, -32575(GP)
9D021E84  00063100   SLL A2, A2, 4
9D021E88  938280C9   LBU V0, -32567(GP)
9D021E8C  24040001   ADDIU A0, ZERO, 1
9D021E90  24050400   ADDIU A1, ZERO, 1024
9D021E94  0F40B1E8   JAL mmc_bankvrom
9D021E98  00C23021   ADDU A2, A2, V0
9D021E9C  0B40883A   J 0x9D0220E8
9D021EA0  8FBF0014   LW RA, 20(SP)
102:                    case 0xC000: VRC_VBANK(2,value,0); break;
9D021EA4  A38680CA   SB A2, -32566(GP)
9D021EA8  938280C2   LBU V0, -32574(GP)
9D021EAC  00021100   SLL V0, V0, 4
9D021EB0  24040001   ADDIU A0, ZERO, 1
9D021EB4  24050800   ADDIU A1, ZERO, 2048
9D021EB8  0F40B1E8   JAL mmc_bankvrom
9D021EBC  00463021   ADDU A2, V0, A2
9D021EC0  0B40883A   J 0x9D0220E8
9D021EC4  8FBF0014   LW RA, 20(SP)
103:                    case 0xC002:
104:                    case 0xC040: VRC_VBANK(2,value,1); break;
9D021EC8  A38680C2   SB A2, -32574(GP)
9D021ECC  00063100   SLL A2, A2, 4
9D021ED0  938280CA   LBU V0, -32566(GP)
9D021ED4  24040001   ADDIU A0, ZERO, 1
9D021ED8  24050800   ADDIU A1, ZERO, 2048
9D021EDC  0F40B1E8   JAL mmc_bankvrom
9D021EE0  00C23021   ADDU A2, A2, V0
9D021EE4  0B40883A   J 0x9D0220E8
9D021EE8  8FBF0014   LW RA, 20(SP)
105:                    case 0xC001:
106:                    case 0xC004:
107:                    case 0xC080: VRC_VBANK(3,value,0); break;
9D021EEC  30C6000F   ANDI A2, A2, 15
9D021EF0  A38680CB   SB A2, -32565(GP)
9D021EF4  938280C3   LBU V0, -32573(GP)
9D021EF8  00021100   SLL V0, V0, 4
9D021EFC  24040001   ADDIU A0, ZERO, 1
9D021F00  24050C00   ADDIU A1, ZERO, 3072
9D021F04  0F40B1E8   JAL mmc_bankvrom
9D021F08  00463021   ADDU A2, V0, A2
9D021F0C  0B40883A   J 0x9D0220E8
9D021F10  8FBF0014   LW RA, 20(SP)
108:                    case 0xC003:
109:                    case 0xC006:
110:                    case 0xC0C0: VRC_VBANK(3,value,1); break;
9D021F14  30C6000F   ANDI A2, A2, 15
9D021F18  A38680C3   SB A2, -32573(GP)
9D021F1C  00063100   SLL A2, A2, 4
9D021F20  938280CB   LBU V0, -32565(GP)
9D021F24  24040001   ADDIU A0, ZERO, 1
9D021F28  24050C00   ADDIU A1, ZERO, 3072
9D021F2C  0F40B1E8   JAL mmc_bankvrom
9D021F30  00C23021   ADDU A2, A2, V0
9D021F34  0B40883A   J 0x9D0220E8
9D021F38  8FBF0014   LW RA, 20(SP)
111:                    case 0xD000: VRC_VBANK(4,value,0); break;
9D021F3C  A38680CC   SB A2, -32564(GP)
9D021F40  938280C4   LBU V0, -32572(GP)
9D021F44  00021100   SLL V0, V0, 4
9D021F48  24040001   ADDIU A0, ZERO, 1
9D021F4C  24051000   ADDIU A1, ZERO, 4096
9D021F50  0F40B1E8   JAL mmc_bankvrom
9D021F54  00463021   ADDU A2, V0, A2
9D021F58  0B40883A   J 0x9D0220E8
9D021F5C  8FBF0014   LW RA, 20(SP)
112:                    case 0xD002:
113:                    case 0xD040: VRC_VBANK(4,value,1); break;
9D021F60  30C6000F   ANDI A2, A2, 15
9D021F64  A38680C4   SB A2, -32572(GP)
9D021F68  00063100   SLL A2, A2, 4
9D021F6C  938280CC   LBU V0, -32564(GP)
9D021F70  24040001   ADDIU A0, ZERO, 1
9D021F74  24051000   ADDIU A1, ZERO, 4096
9D021F78  0F40B1E8   JAL mmc_bankvrom
9D021F7C  00C23021   ADDU A2, A2, V0
9D021F80  0B40883A   J 0x9D0220E8
9D021F84  8FBF0014   LW RA, 20(SP)
114:                    case 0xD001:
115:                    case 0xD004:
116:                    case 0xD080: VRC_VBANK(5,value,0); break;
9D021F88  30C6000F   ANDI A2, A2, 15
9D021F8C  A38680CD   SB A2, -32563(GP)
9D021F90  938280C5   LBU V0, -32571(GP)
9D021F94  00021100   SLL V0, V0, 4
9D021F98  24040001   ADDIU A0, ZERO, 1
9D021F9C  24051400   ADDIU A1, ZERO, 5120
9D021FA0  0F40B1E8   JAL mmc_bankvrom
9D021FA4  00463021   ADDU A2, V0, A2
9D021FA8  0B40883A   J 0x9D0220E8
9D021FAC  8FBF0014   LW RA, 20(SP)
117:                    case 0xD003:
118:                    case 0xD006:
119:                    case 0xD0C0: VRC_VBANK(5,value,1); break;
9D021FB0  30C6000F   ANDI A2, A2, 15
9D021FB4  A38680C5   SB A2, -32571(GP)
9D021FB8  00063100   SLL A2, A2, 4
9D021FBC  938280CD   LBU V0, -32563(GP)
9D021FC0  24040001   ADDIU A0, ZERO, 1
9D021FC4  24051400   ADDIU A1, ZERO, 5120
9D021FC8  0F40B1E8   JAL mmc_bankvrom
9D021FCC  00C23021   ADDU A2, A2, V0
9D021FD0  0B40883A   J 0x9D0220E8
9D021FD4  8FBF0014   LW RA, 20(SP)
120:                    case 0xE000: VRC_VBANK(6,value,0); break;
9D021FD8  A38680CE   SB A2, -32562(GP)
9D021FDC  938280C6   LBU V0, -32570(GP)
9D021FE0  00021100   SLL V0, V0, 4
9D021FE4  24040001   ADDIU A0, ZERO, 1
9D021FE8  24051800   ADDIU A1, ZERO, 6144
9D021FEC  0F40B1E8   JAL mmc_bankvrom
9D021FF0  00463021   ADDU A2, V0, A2
9D021FF4  0B40883A   J 0x9D0220E8
9D021FF8  8FBF0014   LW RA, 20(SP)
121:                    case 0xE002:
122:                    case 0xE040: VRC_VBANK(6,value,1); break;
9D021FFC  30C6000F   ANDI A2, A2, 15
9D022000  A38680C6   SB A2, -32570(GP)
9D022004  00063100   SLL A2, A2, 4
9D022008  938280CE   LBU V0, -32562(GP)
9D02200C  24040001   ADDIU A0, ZERO, 1
9D022010  24051800   ADDIU A1, ZERO, 6144
9D022014  0F40B1E8   JAL mmc_bankvrom
9D022018  00C23021   ADDU A2, A2, V0
9D02201C  0B40883A   J 0x9D0220E8
9D022020  8FBF0014   LW RA, 20(SP)
123:                    case 0xE001:
124:                    case 0xE004:
125:                    case 0xE080: VRC_VBANK(7,value,0); break;
9D022024  A38680CF   SB A2, -32561(GP)
9D022028  938280C7   LBU V0, -32569(GP)
9D02202C  00021100   SLL V0, V0, 4
9D022030  24040001   ADDIU A0, ZERO, 1
9D022034  24051C00   ADDIU A1, ZERO, 7168
9D022038  0F40B1E8   JAL mmc_bankvrom
9D02203C  00463021   ADDU A2, V0, A2
9D022040  0B40883A   J 0x9D0220E8
9D022044  8FBF0014   LW RA, 20(SP)
126:                    case 0xE003:
127:                    case 0xE006:
128:                    case 0xE0C0: VRC_VBANK(7,value,1); break;
9D022048  30C6000F   ANDI A2, A2, 15
9D02204C  A38680C7   SB A2, -32569(GP)
9D022050  00063100   SLL A2, A2, 4
9D022054  938280CF   LBU V0, -32561(GP)
9D022058  24040001   ADDIU A0, ZERO, 1
9D02205C  24051C00   ADDIU A1, ZERO, 7168
9D022060  0F40B1E8   JAL mmc_bankvrom
9D022064  00C23021   ADDU A2, A2, V0
9D022068  0B40883A   J 0x9D0220E8
9D02206C  8FBF0014   LW RA, 20(SP)
129:                 
130:                    case 0xF000:
131:                       irq.latch &= 0xF0;
9D022078  8C430008   LW V1, 8(V0)
9D02207C  306300F0   ANDI V1, V1, 240
132:                       irq.latch |= (value & 0x0F);
9D022070  2442B8C4   ADDIU V0, V0, -18236
9D022074  30A6000F   ANDI A2, A1, 15
9D022080  00C33025   OR A2, A2, V1
133:                       break;
9D022084  0B408839   J 0x9D0220E4
9D022088  AC460008   SW A2, 8(V0)
134:                    case 0xF002:
135:                    case 0xF040:
136:                       irq.latch &= 0x0F;
9D02209C  8C430008   LW V1, 8(V0)
9D0220A0  3063000F   ANDI V1, V1, 15
137:                       irq.latch |= ((value & 0x0F) << 4);
9D02208C  3C02A001   LUI V0, -24575
9D022090  2442B8C4   ADDIU V0, V0, -18236
9D022094  00063100   SLL A2, A2, 4
9D022098  30C600FF   ANDI A2, A2, 255
9D0220A4  00C31825   OR V1, A2, V1
138:                       break;
9D0220A8  0B408839   J 0x9D0220E4
9D0220AC  AC430008   SW V1, 8(V0)
139:                    case 0xF004:
140:                    case 0xF001:
141:                    case 0xF080:
142:                       irq.enabled = (value >> 1) & 0x01;
9D0220B0  3C03A001   LUI V1, -24575
9D0220B4  2462B8C4   ADDIU V0, V1, -18236
9D0220B8  7CC40040   EXT A0, A2, 1, 1
9D0220BC  AC440004   SW A0, 4(V0)
143:                       irq.wait_state = value & 0x01;
9D0220C0  30C60001   ANDI A2, A2, 1
9D0220C4  AC46000C   SW A2, 12(V0)
144:                       irq.counter = irq.latch;
9D0220C8  8C420008   LW V0, 8(V0)
145:                       break;
9D0220CC  0B408839   J 0x9D0220E4
9D0220D0  AC62B8C4   SW V0, -18236(V1)
146:                    case 0xF006:
147:                    case 0xF003:
148:                    case 0xF0C0:
149:                       irq.enabled = irq.wait_state;
9D0220D4  3C02A001   LUI V0, -24575
9D0220D8  2442B8C4   ADDIU V0, V0, -18236
9D0220DC  8C43000C   LW V1, 12(V0)
9D0220E0  AC430004   SW V1, 4(V0)
150:                       break;
151:                 
152:                    default:
153:                 #ifdef NOFRENDO_DEBUG
154:                       log_printf("wrote $%02X to $%04X", value, address);
155:                 #endif
156:                       break;
157:                    }
158:                 }
9D021A80  0B40883A   J 0x9D0220E8
9D021A84  8FBF0014   LW RA, 20(SP)
9D021A98  0B40883A   J 0x9D0220E8
9D021A9C  8FBF0014   LW RA, 20(SP)
9D021AD0  0B40883A   J 0x9D0220E8
9D021AD4  8FBF0014   LW RA, 20(SP)
9D021AE8  0B40883A   J 0x9D0220E8
9D021AEC  8FBF0014   LW RA, 20(SP)
9D021B30  0B40883A   J 0x9D0220E8
9D021B34  8FBF0014   LW RA, 20(SP)
9D021B50  0B40883A   J 0x9D0220E8
9D021B54  8FBF0014   LW RA, 20(SP)
9D021B80  0B40883A   J 0x9D0220E8
9D021B84  8FBF0014   LW RA, 20(SP)
9D021BA8  0B40883A   J 0x9D0220E8
9D021BAC  8FBF0014   LW RA, 20(SP)
9D021C0C  0B40883A   J 0x9D0220E8
9D021C10  8FBF0014   LW RA, 20(SP)
9D021C28  0B40883A   J 0x9D0220E8
9D021C2C  8FBF0014   LW RA, 20(SP)
9D021C58  0B40883A   J 0x9D0220E8
9D021C5C  8FBF0014   LW RA, 20(SP)
9D021C74  0B40883A   J 0x9D0220E8
9D021C78  8FBF0014   LW RA, 20(SP)
9D021CBC  0B40883A   J 0x9D0220E8
9D021CC0  8FBF0014   LW RA, 20(SP)
9D021CD8  0B40883A   J 0x9D0220E8
9D021CDC  8FBF0014   LW RA, 20(SP)
9D021D0C  0B40883A   J 0x9D0220E8
9D021D10  8FBF0014   LW RA, 20(SP)
9D021D2C  0B40883A   J 0x9D0220E8
9D021D30  8FBF0014   LW RA, 20(SP)
9D021D58  0B40883A   J 0x9D0220E8
9D021D5C  8FBF0014   LW RA, 20(SP)
9D021D84  0B40883A   J 0x9D0220E8
9D021D88  8FBF0014   LW RA, 20(SP)
9D0220E4  8FBF0014   LW RA, 20(SP)
9D0220E8  03E00008   JR RA
9D0220EC  27BD0018   ADDIU SP, SP, 24
159:                 
160:                 static void map22_write(uint32 address, uint8 value)
161:                 {
9D0220F0  27BDFFE8   ADDIU SP, SP, -24
162:                    int reg = address >> 12;
9D0220F4  00041B02   SRL V1, A0, 12
163:                    
164:                    switch (reg)
9D0220F8  2462FFF8   ADDIU V0, V1, -8
9D0220FC  2C470007   SLTIU A3, V0, 7
9D022100  10E00046   BEQ A3, ZERO, .LVL112, .LBE2
9D022104  AFBF0014   SW RA, 20(SP)
9D022108  00A03021   ADDU A2, A1, ZERO
9D02210C  00021080   SLL V0, V0, 2
9D022110  3C059D02   LUI A1, -25342
9D022114  24A52128   ADDIU A1, A1, 8488
9D022118  00A21021   ADDU V0, A1, V0
9D02211C  8C420000   LW V0, 0(V0)
9D022120  00400008   JR V0
9D022124  00000000   NOP
165:                    {
166:                    case 0x8:
167:                       mmc_bankrom(8, 0x8000, value);
9D022144  24040008   ADDIU A0, ZERO, 8
9D022148  0F40B246   JAL mmc_bankrom
9D02214C  34058000   ORI A1, ZERO, -32768
168:                       break;
9D022150  0B408888   J 0x9D022220
9D022154  8FBF0014   LW RA, 20(SP)
169:                    
170:                    case 0xA:
171:                       mmc_bankrom(8, 0xA000, value);
9D022158  24040008   ADDIU A0, ZERO, 8
9D02215C  0F40B246   JAL mmc_bankrom
9D022160  3405A000   ORI A1, ZERO, -24576
172:                       break;
9D022164  0B408888   J 0x9D022220
9D022168  8FBF0014   LW RA, 20(SP)
173:                 
174:                    case 0x9:
175:                       switch (value & 3)
9D02216C  30C60003   ANDI A2, A2, 3
9D022170  24020001   ADDIU V0, ZERO, 1
9D022174  10C2000F   BEQ A2, V0, 0x9D0221B4
9D022178  00002021   ADDU A0, ZERO, ZERO
9D02217C  10C00007   BEQ A2, ZERO, 0x9D02219C
9D022180  24020002   ADDIU V0, ZERO, 2
9D022184  10C20011   BEQ A2, V0, 0x9D0221CC
9D022188  24020003   ADDIU V0, ZERO, 3
9D02218C  10C20016   BEQ A2, V0, 0x9D0221E8
9D022190  00002821   ADDU A1, ZERO, ZERO
176:                       {
177:                       case 0:
178:                          ppu_mirror(0, 1, 0, 1); /* vertical */
9D02219C  24050001   ADDIU A1, ZERO, 1
9D0221A0  00003021   ADDU A2, ZERO, ZERO
9D0221A4  0F406128   JAL ppu_mirror
9D0221A8  24070001   ADDIU A3, ZERO, 1
179:                          break;
9D0221AC  0B408888   J 0x9D022220
9D0221B0  8FBF0014   LW RA, 20(SP)
180:                 
181:                       case 1: 
182:                          ppu_mirror(0, 0, 1, 1); /* horizontal */
9D0221B4  00002821   ADDU A1, ZERO, ZERO
9D0221B8  24060001   ADDIU A2, ZERO, 1
9D0221BC  0F406128   JAL ppu_mirror
9D0221C0  24070001   ADDIU A3, ZERO, 1
183:                          break;
9D0221C4  0B408888   J 0x9D022220
9D0221C8  8FBF0014   LW RA, 20(SP)
184:                 
185:                       case 2:
186:                          ppu_mirror(1, 1, 1, 1);
9D0221CC  24040001   ADDIU A0, ZERO, 1
9D0221D0  24050001   ADDIU A1, ZERO, 1
9D0221D4  24060001   ADDIU A2, ZERO, 1
9D0221D8  0F406128   JAL ppu_mirror
9D0221DC  24070001   ADDIU A3, ZERO, 1
187:                          break;
9D0221E0  0B408888   J 0x9D022220
9D0221E4  8FBF0014   LW RA, 20(SP)
188:                 
189:                       case 3:
190:                          ppu_mirror(0, 0, 0, 0);
9D0221E8  00003021   ADDU A2, ZERO, ZERO
9D0221EC  0F406128   JAL ppu_mirror
9D0221F0  00003821   ADDU A3, ZERO, ZERO
191:                          break;
9D0221F4  0B408888   J 0x9D022220
9D0221F8  8FBF0014   LW RA, 20(SP)
192:                       }
193:                       break;
194:                 
195:                    case 0xB:
196:                    case 0xC:
197:                    case 0xD:
198:                    case 0xE:
199:                       {
200:                          int loc = (((reg - 0xB) << 1) + (address & 1)) << 10;
9D0221FC  2465FFF5   ADDIU A1, V1, -11
9D022200  00052840   SLL A1, A1, 1
9D022204  30840001   ANDI A0, A0, 1
9D022208  00A42821   ADDU A1, A1, A0
201:                          mmc_bankvrom(1, loc, value >> 1);
9D02220C  24040001   ADDIU A0, ZERO, 1
9D022210  00052A80   SLL A1, A1, 10
9D022214  0F40B1E8   JAL mmc_bankvrom
9D022218  00063042   SRL A2, A2, 1
202:                       }
203:                       break;
204:                 
205:                    default:
206:                       break;
207:                    }
208:                 }
9D022194  0B408888   J 0x9D022220
9D022198  8FBF0014   LW RA, 20(SP)
9D02221C  8FBF0014   LW RA, 20(SP)
9D022220  03E00008   JR RA
9D022224  27BD0018   ADDIU SP, SP, 24
209:                 
210:                 static void map23_write(uint32 address, uint8 value)
211:                 {
9D022228  27BDFFE8   ADDIU SP, SP, -24
9D02222C  AFBF0014   SW RA, 20(SP)
212:                    switch (address)
9D022230  3402C008   ORI V0, ZERO, -16376
9D022234  10820102   BEQ A0, V0, 0x9D022640
9D022238  00A03021   ADDU A2, A1, ZERO
9D02223C  3402C009   ORI V0, ZERO, -16375
9D022240  0082102B   SLTU V0, A0, V0
9D022244  10400049   BEQ V0, ZERO, 0x9D02236C
9D022248  3402E001   ORI V0, ZERO, -8191
9D02224C  3402B002   ORI V0, ZERO, -20478
9D022250  108200D3   BEQ A0, V0, 0x9D0225A0
9D022254  3402B003   ORI V0, ZERO, -20477
9D022258  0082102B   SLTU V0, A0, V0
9D02225C  10400029   BEQ V0, ZERO, 0x9D022304
9D022260  3402C000   ORI V0, ZERO, -16384
9D022264  34029008   ORI V0, ZERO, -28664
9D022268  10820096   BEQ A0, V0, 0x9D0224C4
9D02226C  34029009   ORI V0, ZERO, -28663
9D022270  0082102B   SLTU V0, A0, V0
9D022274  10400012   BEQ V0, ZERO, 0x9D0222C0
9D022278  3402AFFF   ORI V0, ZERO, -20481
9D02227C  34028FFF   ORI V0, ZERO, -28673
9D022280  10820086   BEQ A0, V0, 0x9D02249C
9D022284  34029000   ORI V0, ZERO, -28672
9D022288  0082102B   SLTU V0, A0, V0
9D02228C  10400006   BEQ V0, ZERO, 0x9D0222A8
9D022290  34029000   ORI V0, ZERO, -28672
9D022294  34028000   ORI V0, ZERO, -32768
9D022298  10820081   BEQ A0, V0, 0x9D0224A0
9D02229C  24040008   ADDIU A0, ZERO, 8
9D0222A8  10820086   BEQ A0, V0, 0x9D0224C4
9D0222AC  34029004   ORI V0, ZERO, -28668
9D0222B0  50820085   BEQL A0, V0, 0x9D0224C8
9D0222B4  30C60003   ANDI A2, A2, 3
9D0222C0  1082007B   BEQ A0, V0, 0x9D0224B0
9D0222C4  3402B000   ORI V0, ZERO, -20480
9D0222C8  0082102B   SLTU V0, A0, V0
9D0222CC  10400006   BEQ V0, ZERO, 0x9D0222E8
9D0222D0  3402B000   ORI V0, ZERO, -20480
9D0222D4  3402A000   ORI V0, ZERO, -24576
9D0222D8  10820076   BEQ A0, V0, 0x9D0224B4
9D0222DC  24040008   ADDIU A0, ZERO, 8
9D0222E8  5082009A   BEQL A0, V0, 0x9D022554
9D0222EC  30A6000F   ANDI A2, A1, 15
9D0222F0  3402B001   ORI V0, ZERO, -20479
9D0222F4  508200A1   BEQL A0, V0, 0x9D02257C
9D0222F8  30C6000F   ANDI A2, A2, 15
9D022304  108200BA   BEQ A0, V0, 0x9D0225F0
9D022308  3402C001   ORI V0, ZERO, -16383
9D02230C  0082102B   SLTU V0, A0, V0
9D022310  1040000C   BEQ V0, ZERO, 0x9D022344
9D022314  3402C002   ORI V0, ZERO, -16382
9D022318  3402B004   ORI V0, ZERO, -20476
9D02231C  10820096   BEQ A0, V0, 0x9D022578
9D022320  0082102B   SLTU V0, A0, V0
9D022324  144000A8   BNE V0, ZERO, 0x9D0225C8
9D022328  3402B008   ORI V0, ZERO, -20472
9D02232C  1082009C   BEQ A0, V0, 0x9D0225A0
9D022330  3402B00C   ORI V0, ZERO, -20468
9D022334  508200A5   BEQL A0, V0, 0x9D0225CC
9D022338  30C6000F   ANDI A2, A2, 15
9D022344  108200BE   BEQ A0, V0, 0x9D022640
9D022348  0082102B   SLTU V0, A0, V0
9D02234C  144000B2   BNE V0, ZERO, 0x9D022618
9D022350  3402C003   ORI V0, ZERO, -16381
9D022354  108200C4   BEQ A0, V0, 0x9D022668
9D022358  3402C004   ORI V0, ZERO, -16380
9D02235C  508200AF   BEQL A0, V0, 0x9D02261C
9D022360  30C6000F   ANDI A2, A2, 15
9D02236C  108200F9   BEQ A0, V0, 0x9D022754
9D022370  3402E002   ORI V0, ZERO, -8190
9D022374  0082102B   SLTU V0, A0, V0
9D022378  10400028   BEQ V0, ZERO, 0x9D02241C
9D02237C  3402E00C   ORI V0, ZERO, -8180
9D022380  3402D003   ORI V0, ZERO, -12285
9D022384  108200E0   BEQ A0, V0, 0x9D022708
9D022388  3402D004   ORI V0, ZERO, -12284
9D02238C  0082102B   SLTU V0, A0, V0
9D022390  10400012   BEQ V0, ZERO, 0x9D0223DC
9D022394  3402D008   ORI V0, ZERO, -12280
9D022398  3402D000   ORI V0, ZERO, -12288
9D02239C  108200BC   BEQ A0, V0, 0x9D022690
9D0223A0  3402D001   ORI V0, ZERO, -12287
9D0223A4  0082102B   SLTU V0, A0, V0
9D0223A8  10400006   BEQ V0, ZERO, 0x9D0223C4
9D0223AC  3402D001   ORI V0, ZERO, -12287
9D0223B0  3402C00C   ORI V0, ZERO, -16372
9D0223B4  508200AD   BEQL A0, V0, 0x9D02266C
9D0223B8  30C6000F   ANDI A2, A2, 15
9D0223C4  108200BC   BEQ A0, V0, 0x9D0226B8
9D0223C8  3402D002   ORI V0, ZERO, -12286
9D0223CC  508200C5   BEQL A0, V0, 0x9D0226E4
9D0223D0  30C6000F   ANDI A2, A2, 15
9D0223DC  108200C0   BEQ A0, V0, 0x9D0226E0
9D0223E0  3402D009   ORI V0, ZERO, -12279
9D0223E4  0082102B   SLTU V0, A0, V0
9D0223E8  10400006   BEQ V0, ZERO, 0x9D022404
9D0223EC  3402D00C   ORI V0, ZERO, -12276
9D0223F0  3402D004   ORI V0, ZERO, -12284
9D0223F4  508200B1   BEQL A0, V0, 0x9D0226BC
9D0223F8  30C6000F   ANDI A2, A2, 15
9D022404  108200C0   BEQ A0, V0, 0x9D022708
9D022408  3402E000   ORI V0, ZERO, -8192
9D02240C  508200C8   BEQL A0, V0, 0x9D022730
9D022410  30A6000F   ANDI A2, A1, 15
9D02241C  108200E1   BEQ A0, V0, 0x9D0227A4
9D022420  3402E00D   ORI V0, ZERO, -8179
9D022424  0082102B   SLTU V0, A0, V0
9D022428  1040000C   BEQ V0, ZERO, 0x9D02245C
9D02242C  3402F004   ORI V0, ZERO, -4092
9D022430  3402E003   ORI V0, ZERO, -8189
9D022434  108200DB   BEQ A0, V0, 0x9D0227A4
9D022438  0082102B   SLTU V0, A0, V0
9D02243C  144000CF   BNE V0, ZERO, 0x9D02277C
9D022440  3402E004   ORI V0, ZERO, -8188
9D022444  108200C3   BEQ A0, V0, 0x9D022754
9D022448  3402E008   ORI V0, ZERO, -8184
9D02244C  508200CC   BEQL A0, V0, 0x9D022780
9D022450  30C6000F   ANDI A2, A2, 15
9D02245C  108200E2   BEQ A0, V0, 0x9D0227E8
9D022460  3402F005   ORI V0, ZERO, -4091
9D022464  0082102B   SLTU V0, A0, V0
9D022468  10400006   BEQ V0, ZERO, 0x9D022484
9D02246C  3402F008   ORI V0, ZERO, -4088
9D022470  3402F000   ORI V0, ZERO, -4096
9D022474  108200D5   BEQ A0, V0, 0x9D0227CC
9D022478  3C02A001   LUI V0, -24575
9D022484  108200E1   BEQ A0, V0, 0x9D02280C
9D022488  3402F00C   ORI V0, ZERO, -4084
9D02248C  108200E8   BEQ A0, V0, 0x9D022830
9D022490  3C02A001   LUI V0, -24575
213:                    {
214:                    case 0x8000:
215:                    case 0x8FFF:
216:                       mmc_bankrom(8, 0x8000, value);
9D02249C  24040008   ADDIU A0, ZERO, 8
9D0224A0  0F40B246   JAL mmc_bankrom
9D0224A4  34058000   ORI A1, ZERO, -32768
217:                       break;
9D0224A8  0B408A10   J 0x9D022840
9D0224AC  8FBF0014   LW RA, 20(SP)
218:                 
219:                    case 0xA000:
220:                    case 0xAFFF:
221:                       mmc_bankrom(8, 0xA000, value);
9D0224B0  24040008   ADDIU A0, ZERO, 8
9D0224B4  0F40B246   JAL mmc_bankrom
9D0224B8  3405A000   ORI A1, ZERO, -24576
222:                       break;
9D0224BC  0B408A10   J 0x9D022840
9D0224C0  8FBF0014   LW RA, 20(SP)
223:                    
224:                    case 0x9000:
225:                    case 0x9004:
226:                    case 0x9008:
227:                       switch(value & 3)
9D0224C4  30C60003   ANDI A2, A2, 3
9D0224C8  24020001   ADDIU V0, ZERO, 1
9D0224CC  10C2000F   BEQ A2, V0, 0x9D02250C
9D0224D0  00002021   ADDU A0, ZERO, ZERO
9D0224D4  10C00007   BEQ A2, ZERO, 0x9D0224F4
9D0224D8  24020002   ADDIU V0, ZERO, 2
9D0224DC  10C20011   BEQ A2, V0, 0x9D022524
9D0224E0  24020003   ADDIU V0, ZERO, 3
9D0224E4  10C20015   BEQ A2, V0, 0x9D02253C
9D0224E8  24040001   ADDIU A0, ZERO, 1
228:                       {
229:                       case 0:
230:                          ppu_mirror(0, 1, 0, 1); /* vertical */
9D0224F4  24050001   ADDIU A1, ZERO, 1
9D0224F8  00003021   ADDU A2, ZERO, ZERO
9D0224FC  0F406128   JAL ppu_mirror
9D022500  24070001   ADDIU A3, ZERO, 1
231:                          break;
9D022504  0B408A10   J 0x9D022840
9D022508  8FBF0014   LW RA, 20(SP)
232:                 
233:                       case 1: 
234:                          ppu_mirror(0, 0, 1, 1); /* horizontal */
9D02250C  00002821   ADDU A1, ZERO, ZERO
9D022510  24060001   ADDIU A2, ZERO, 1
9D022514  0F406128   JAL ppu_mirror
9D022518  24070001   ADDIU A3, ZERO, 1
235:                          break;
9D02251C  0B408A10   J 0x9D022840
9D022520  8FBF0014   LW RA, 20(SP)
236:                 
237:                       case 2:
238:                          ppu_mirror(0, 0, 0, 0);
9D022524  00002821   ADDU A1, ZERO, ZERO
9D022528  00003021   ADDU A2, ZERO, ZERO
9D02252C  0F406128   JAL ppu_mirror
9D022530  00003821   ADDU A3, ZERO, ZERO
239:                          break;
9D022534  0B408A10   J 0x9D022840
9D022538  8FBF0014   LW RA, 20(SP)
240:                 
241:                       case 3:
242:                          ppu_mirror(1, 1, 1, 1);
9D02253C  24050001   ADDIU A1, ZERO, 1
9D022540  24060001   ADDIU A2, ZERO, 1
9D022544  0F406128   JAL ppu_mirror
9D022548  24070001   ADDIU A3, ZERO, 1
243:                          break;
9D02254C  0B408A10   J 0x9D022840
9D022550  8FBF0014   LW RA, 20(SP)
244:                       }
245:                       break;
246:                 
247:                    case 0xB000: VRC_VBANK(0,value,0); break;
9D022554  A38680C8   SB A2, -32568(GP)
9D022558  938280C0   LBU V0, -32576(GP)
9D02255C  00021100   SLL V0, V0, 4
9D022560  24040001   ADDIU A0, ZERO, 1
9D022564  00002821   ADDU A1, ZERO, ZERO
9D022568  0F40B1E8   JAL mmc_bankvrom
9D02256C  00463021   ADDU A2, V0, A2
9D022570  0B408A10   J 0x9D022840
9D022574  8FBF0014   LW RA, 20(SP)
248:                    case 0xB001:
249:                    case 0xB004: VRC_VBANK(0,value,1); break;
9D022578  30C6000F   ANDI A2, A2, 15
9D02257C  A38680C0   SB A2, -32576(GP)
9D022580  00063100   SLL A2, A2, 4
9D022584  938280C8   LBU V0, -32568(GP)
9D022588  24040001   ADDIU A0, ZERO, 1
9D02258C  00002821   ADDU A1, ZERO, ZERO
9D022590  0F40B1E8   JAL mmc_bankvrom
9D022594  00C23021   ADDU A2, A2, V0
9D022598  0B408A10   J 0x9D022840
9D02259C  8FBF0014   LW RA, 20(SP)
250:                    case 0xB002:
251:                    case 0xB008: VRC_VBANK(1,value,0); break;
9D0225A0  30C6000F   ANDI A2, A2, 15
9D0225A4  A38680C9   SB A2, -32567(GP)
9D0225A8  938280C1   LBU V0, -32575(GP)
9D0225AC  00021100   SLL V0, V0, 4
9D0225B0  24040001   ADDIU A0, ZERO, 1
9D0225B4  24050400   ADDIU A1, ZERO, 1024
9D0225B8  0F40B1E8   JAL mmc_bankvrom
9D0225BC  00463021   ADDU A2, V0, A2
9D0225C0  0B408A10   J 0x9D022840
9D0225C4  8FBF0014   LW RA, 20(SP)
252:                    case 0xB003:
253:                    case 0xB00C: VRC_VBANK(1,value,1); break;
9D0225C8  30C6000F   ANDI A2, A2, 15
9D0225CC  A38680C1   SB A2, -32575(GP)
9D0225D0  00063100   SLL A2, A2, 4
9D0225D4  938280C9   LBU V0, -32567(GP)
9D0225D8  24040001   ADDIU A0, ZERO, 1
9D0225DC  24050400   ADDIU A1, ZERO, 1024
9D0225E0  0F40B1E8   JAL mmc_bankvrom
9D0225E4  00C23021   ADDU A2, A2, V0
9D0225E8  0B408A10   J 0x9D022840
9D0225EC  8FBF0014   LW RA, 20(SP)
254:                    case 0xC000: VRC_VBANK(2,value,0); break;
9D0225F0  30A6000F   ANDI A2, A1, 15
9D0225F4  A38680CA   SB A2, -32566(GP)
9D0225F8  938280C2   LBU V0, -32574(GP)
9D0225FC  00021100   SLL V0, V0, 4
9D022600  24040001   ADDIU A0, ZERO, 1
9D022604  24050800   ADDIU A1, ZERO, 2048
9D022608  0F40B1E8   JAL mmc_bankvrom
9D02260C  00463021   ADDU A2, V0, A2
9D022610  0B408A10   J 0x9D022840
9D022614  8FBF0014   LW RA, 20(SP)
255:                    case 0xC001:
256:                    case 0xC004: VRC_VBANK(2,value,1); break;
9D022618  30C6000F   ANDI A2, A2, 15
9D02261C  A38680C2   SB A2, -32574(GP)
9D022620  00063100   SLL A2, A2, 4
9D022624  938280CA   LBU V0, -32566(GP)
9D022628  24040001   ADDIU A0, ZERO, 1
9D02262C  24050800   ADDIU A1, ZERO, 2048
9D022630  0F40B1E8   JAL mmc_bankvrom
9D022634  00C23021   ADDU A2, A2, V0
9D022638  0B408A10   J 0x9D022840
9D02263C  8FBF0014   LW RA, 20(SP)
257:                    case 0xC002:
258:                    case 0xC008: VRC_VBANK(3,value,0); break;
9D022640  30C6000F   ANDI A2, A2, 15
9D022644  A38680CB   SB A2, -32565(GP)
9D022648  938280C3   LBU V0, -32573(GP)
9D02264C  00021100   SLL V0, V0, 4
9D022650  24040001   ADDIU A0, ZERO, 1
9D022654  24050C00   ADDIU A1, ZERO, 3072
9D022658  0F40B1E8   JAL mmc_bankvrom
9D02265C  00463021   ADDU A2, V0, A2
9D022660  0B408A10   J 0x9D022840
9D022664  8FBF0014   LW RA, 20(SP)
259:                    case 0xC003:
260:                    case 0xC00C: VRC_VBANK(3,value,1); break;
9D022668  30C6000F   ANDI A2, A2, 15
9D02266C  A38680C3   SB A2, -32573(GP)
9D022670  00063100   SLL A2, A2, 4
9D022674  938280CB   LBU V0, -32565(GP)
9D022678  24040001   ADDIU A0, ZERO, 1
9D02267C  24050C00   ADDIU A1, ZERO, 3072
9D022680  0F40B1E8   JAL mmc_bankvrom
9D022684  00C23021   ADDU A2, A2, V0
9D022688  0B408A10   J 0x9D022840
9D02268C  8FBF0014   LW RA, 20(SP)
261:                    case 0xD000: VRC_VBANK(4,value,0); break;
9D022690  30A6000F   ANDI A2, A1, 15
9D022694  A38680CC   SB A2, -32564(GP)
9D022698  938280C4   LBU V0, -32572(GP)
9D02269C  00021100   SLL V0, V0, 4
9D0226A0  24040001   ADDIU A0, ZERO, 1
9D0226A4  24051000   ADDIU A1, ZERO, 4096
9D0226A8  0F40B1E8   JAL mmc_bankvrom
9D0226AC  00463021   ADDU A2, V0, A2
9D0226B0  0B408A10   J 0x9D022840
9D0226B4  8FBF0014   LW RA, 20(SP)
262:                    case 0xD001:
263:                    case 0xD004: VRC_VBANK(4,value,1); break;
9D0226B8  30C6000F   ANDI A2, A2, 15
9D0226BC  A38680C4   SB A2, -32572(GP)
9D0226C0  00063100   SLL A2, A2, 4
9D0226C4  938280CC   LBU V0, -32564(GP)
9D0226C8  24040001   ADDIU A0, ZERO, 1
9D0226CC  24051000   ADDIU A1, ZERO, 4096
9D0226D0  0F40B1E8   JAL mmc_bankvrom
9D0226D4  00C23021   ADDU A2, A2, V0
9D0226D8  0B408A10   J 0x9D022840
9D0226DC  8FBF0014   LW RA, 20(SP)
264:                    case 0xD002:
265:                    case 0xD008: VRC_VBANK(5,value,0); break;
9D0226E0  30C6000F   ANDI A2, A2, 15
9D0226E4  A38680CD   SB A2, -32563(GP)
9D0226E8  938280C5   LBU V0, -32571(GP)
9D0226EC  00021100   SLL V0, V0, 4
9D0226F0  24040001   ADDIU A0, ZERO, 1
9D0226F4  24051400   ADDIU A1, ZERO, 5120
9D0226F8  0F40B1E8   JAL mmc_bankvrom
9D0226FC  00463021   ADDU A2, V0, A2
9D022700  0B408A10   J 0x9D022840
9D022704  8FBF0014   LW RA, 20(SP)
266:                    case 0xD003:
267:                    case 0xD00C: VRC_VBANK(5,value,1); break;
9D022708  30C6000F   ANDI A2, A2, 15
9D02270C  A38680C5   SB A2, -32571(GP)
9D022710  00063100   SLL A2, A2, 4
9D022714  938280CD   LBU V0, -32563(GP)
9D022718  24040001   ADDIU A0, ZERO, 1
9D02271C  24051400   ADDIU A1, ZERO, 5120
9D022720  0F40B1E8   JAL mmc_bankvrom
9D022724  00C23021   ADDU A2, A2, V0
9D022728  0B408A10   J 0x9D022840
9D02272C  8FBF0014   LW RA, 20(SP)
268:                    case 0xE000: VRC_VBANK(6,value,0); break;
9D022730  A38680CE   SB A2, -32562(GP)
9D022734  938280C6   LBU V0, -32570(GP)
9D022738  00021100   SLL V0, V0, 4
9D02273C  24040001   ADDIU A0, ZERO, 1
9D022740  24051800   ADDIU A1, ZERO, 6144
9D022744  0F40B1E8   JAL mmc_bankvrom
9D022748  00463021   ADDU A2, V0, A2
9D02274C  0B408A10   J 0x9D022840
9D022750  8FBF0014   LW RA, 20(SP)
269:                    case 0xE001:
270:                    case 0xE004: VRC_VBANK(6,value,1); break;
9D022754  30C6000F   ANDI A2, A2, 15
9D022758  A38680C6   SB A2, -32570(GP)
9D02275C  00063100   SLL A2, A2, 4
9D022760  938280CE   LBU V0, -32562(GP)
9D022764  24040001   ADDIU A0, ZERO, 1
9D022768  24051800   ADDIU A1, ZERO, 6144
9D02276C  0F40B1E8   JAL mmc_bankvrom
9D022770  00C23021   ADDU A2, A2, V0
9D022774  0B408A10   J 0x9D022840
9D022778  8FBF0014   LW RA, 20(SP)
271:                    case 0xE002:
272:                    case 0xE008: VRC_VBANK(7,value,0); break;
9D02277C  30C6000F   ANDI A2, A2, 15
9D022780  A38680CF   SB A2, -32561(GP)
9D022784  938280C7   LBU V0, -32569(GP)
9D022788  00021100   SLL V0, V0, 4
9D02278C  24040001   ADDIU A0, ZERO, 1
9D022790  24051C00   ADDIU A1, ZERO, 7168
9D022794  0F40B1E8   JAL mmc_bankvrom
9D022798  00463021   ADDU A2, V0, A2
9D02279C  0B408A10   J 0x9D022840
9D0227A0  8FBF0014   LW RA, 20(SP)
273:                    case 0xE003:
274:                    case 0xE00C: VRC_VBANK(7,value,1); break;
9D0227A4  30C6000F   ANDI A2, A2, 15
9D0227A8  A38680C7   SB A2, -32569(GP)
9D0227AC  00063100   SLL A2, A2, 4
9D0227B0  938280CF   LBU V0, -32561(GP)
9D0227B4  24040001   ADDIU A0, ZERO, 1
9D0227B8  24051C00   ADDIU A1, ZERO, 7168
9D0227BC  0F40B1E8   JAL mmc_bankvrom
9D0227C0  00C23021   ADDU A2, A2, V0
9D0227C4  0B408A10   J 0x9D022840
9D0227C8  8FBF0014   LW RA, 20(SP)
275:                 
276:                    case 0xF000: 
277:                       irq.latch &= 0xF0;
9D0227D4  8C430008   LW V1, 8(V0)
9D0227D8  306300F0   ANDI V1, V1, 240
278:                       irq.latch |= (value & 0x0F);
9D0227CC  2442B8C4   ADDIU V0, V0, -18236
9D0227D0  30A6000F   ANDI A2, A1, 15
9D0227DC  00C33025   OR A2, A2, V1
279:                       break;
9D0227E0  0B408A0F   J 0x9D02283C
9D0227E4  AC460008   SW A2, 8(V0)
280:                 
281:                    case 0xF004: 
282:                       irq.latch &= 0x0F;
9D0227F8  8C430008   LW V1, 8(V0)
9D0227FC  3063000F   ANDI V1, V1, 15
283:                       irq.latch |= ((value & 0x0F) << 4);
9D0227E8  3C02A001   LUI V0, -24575
9D0227EC  2442B8C4   ADDIU V0, V0, -18236
9D0227F0  00053100   SLL A2, A1, 4
9D0227F4  30C600FF   ANDI A2, A2, 255
9D022800  00C31825   OR V1, A2, V1
284:                       break;
9D022804  0B408A0F   J 0x9D02283C
9D022808  AC430008   SW V1, 8(V0)
285:                 
286:                    case 0xF008:
287:                       irq.enabled = (value >> 1) & 0x01;
9D02280C  3C03A001   LUI V1, -24575
9D022810  2462B8C4   ADDIU V0, V1, -18236
9D022814  7CA40040   EXT A0, A1, 1, 1
9D022818  AC440004   SW A0, 4(V0)
288:                       irq.wait_state = value & 0x01;
9D02281C  30A60001   ANDI A2, A1, 1
9D022820  AC46000C   SW A2, 12(V0)
289:                       irq.counter = irq.latch;
9D022824  8C420008   LW V0, 8(V0)
290:                       break;
9D022828  0B408A0F   J 0x9D02283C
9D02282C  AC62B8C4   SW V0, -18236(V1)
291:                 
292:                    case 0xF00C:
293:                       irq.enabled = irq.wait_state;
9D022830  2442B8C4   ADDIU V0, V0, -18236
9D022834  8C43000C   LW V1, 12(V0)
9D022838  AC430004   SW V1, 4(V0)
294:                       break;
295:                 
296:                    default:
297:                 #ifdef NOFRENDO_DEBUG
298:                       log_printf("wrote $%02X to $%04X",value,address);
299:                 #endif
300:                       break;
301:                    }
302:                 }
9D0222A0  0B408A10   J 0x9D022840
9D0222A4  8FBF0014   LW RA, 20(SP)
9D0222B8  0B408A10   J 0x9D022840
9D0222BC  8FBF0014   LW RA, 20(SP)
9D0222E0  0B408A10   J 0x9D022840
9D0222E4  8FBF0014   LW RA, 20(SP)
9D0222FC  0B408A10   J 0x9D022840
9D022300  8FBF0014   LW RA, 20(SP)
9D02233C  0B408A10   J 0x9D022840
9D022340  8FBF0014   LW RA, 20(SP)
9D022364  0B408A10   J 0x9D022840
9D022368  8FBF0014   LW RA, 20(SP)
9D0223BC  0B408A10   J 0x9D022840
9D0223C0  8FBF0014   LW RA, 20(SP)
9D0223D4  0B408A10   J 0x9D022840
9D0223D8  8FBF0014   LW RA, 20(SP)
9D0223FC  0B408A10   J 0x9D022840
9D022400  8FBF0014   LW RA, 20(SP)
9D022414  0B408A10   J 0x9D022840
9D022418  8FBF0014   LW RA, 20(SP)
9D022454  0B408A10   J 0x9D022840
9D022458  8FBF0014   LW RA, 20(SP)
9D02247C  0B408A10   J 0x9D022840
9D022480  8FBF0014   LW RA, 20(SP)
9D022494  0B408A10   J 0x9D022840
9D022498  8FBF0014   LW RA, 20(SP)
9D0224EC  0B408A10   J 0x9D022840
9D0224F0  8FBF0014   LW RA, 20(SP)
9D02283C  8FBF0014   LW RA, 20(SP)
9D022840  03E00008   JR RA
9D022844  27BD0018   ADDIU SP, SP, 24
303:                 
304:                 static void vrc_hblank(int vblank) 
305:                 {
9D022870  27BDFFE8   ADDIU SP, SP, -24
9D022874  AFBF0014   SW RA, 20(SP)
9D022878  AFB00010   SW S0, 16(SP)
306:                    UNUSED(vblank);
307:                 
308:                    if (irq.enabled)
9D022848  3C02A001   LUI V0, -24575
9D02284C  8C42B8C8   LW V0, -18232(V0)
9D022850  10400013   BEQ V0, ZERO, 0x9D0228A0
9D022854  3C03A001   LUI V1, -24575
309:                    {
310:                       if (256 == ++irq.counter)
9D022858  8C62B8C4   LW V0, -18236(V1)
9D02285C  24420001   ADDIU V0, V0, 1
9D022860  AC62B8C4   SW V0, -18236(V1)
9D022864  24030100   ADDIU V1, ZERO, 256
9D022868  1443000D   BNE V0, V1, 0x9D0228A0
9D02286C  3C02A001   LUI V0, -24575
311:                       {
312:                          irq.counter = irq.latch;
9D02287C  2450B8C4   ADDIU S0, V0, -18236
9D022880  8E030008   LW V1, 8(S0)
313:                          nes_irq();
9D022884  0F408A46   JAL nes_irq
9D022888  AC43B8C4   SW V1, -18236(V0)
314:                          //irq.enabled = false;
315:                          irq.enabled = irq.wait_state;
9D02288C  8E02000C   LW V0, 12(S0)
9D022890  AE020004   SW V0, 4(S0)
316:                       }
317:                    }
318:                 }
9D022894  8FBF0014   LW RA, 20(SP)
9D022898  8FB00010   LW S0, 16(SP)
9D02289C  27BD0018   ADDIU SP, SP, 24
9D0228A0  03E00008   JR RA
9D0228A4  00000000   NOP
319:                 
320:                 
321:                 
322:                 static map_memwrite map21_memwrite[] =
323:                 {
324:                    { 0x8000, 0xFFFF, map21_write },
325:                    {     -1,     -1, NULL }
326:                 };
327:                 
328:                 static map_memwrite map22_memwrite[] =
329:                 {
330:                    { 0x8000, 0xFFFF, map22_write },
331:                    {     -1,     -1, NULL }
332:                 };
333:                 
334:                 static map_memwrite map23_memwrite[] =
335:                 {
336:                    { 0x8000, 0xFFFF, map23_write },
337:                    {     -1,     -1, NULL }
338:                 };
339:                 
340:                 static void map21_getstate(SnssMapperBlock *state)
341:                 {
342:                    state->extraData.mapper21.irqCounter = irq.counter;
9D0219D4  3C02A001   LUI V0, -24575
9D0219D8  8C43B8C4   LW V1, -18236(V0)
9D0219DC  A0830018   SB V1, 24(A0)
343:                    state->extraData.mapper21.irqCounterEnabled = irq.enabled;
9D0219E0  2442B8C4   ADDIU V0, V0, -18236
9D0219E4  8C420004   LW V0, 4(V0)
9D0219E8  03E00008   JR RA
9D0219EC  A0820019   SB V0, 25(A0)
344:                 }
345:                 
346:                 static void map21_setstate(SnssMapperBlock *state)
347:                 {
348:                    irq.counter = state->extraData.mapper21.irqCounter;
9D0219F0  3C02A001   LUI V0, -24575
9D0219F4  90830018   LBU V1, 24(A0)
9D0219F8  AC43B8C4   SW V1, -18236(V0)
349:                    irq.enabled = state->extraData.mapper21.irqCounterEnabled;
9D0219FC  2442B8C4   ADDIU V0, V0, -18236
9D021A00  90830019   LBU V1, 25(A0)
9D021A04  03E00008   JR RA
9D021A08  AC430004   SW V1, 4(V0)
350:                 }
351:                 
352:                 mapintf_t map21_intf =
353:                 {
354:                    21, /* mapper number */
355:                    "Konami VRC4 A", /* mapper name */
356:                    vrc_init, /* init routine */
357:                    NULL, /* vblank callback */
358:                    vrc_hblank, /* hblank callback */
359:                    map21_getstate, /* get state (snss) */
360:                    map21_setstate, /* set state (snss) */
361:                    NULL, /* memory read structure */
362:                    map21_memwrite, /* memory write structure */
363:                    NULL /* external sound device */
364:                 };
365:                 
366:                 mapintf_t map22_intf =
367:                 {
368:                    22, /* mapper number */
369:                    "Konami VRC2 A", /* mapper name */
370:                    vrc_init, /* init routine */
371:                    NULL, /* vblank callback */
372:                    NULL, /* hblank callback */
373:                    NULL, /* get state (snss) */
374:                    NULL, /* set state (snss) */
375:                    NULL, /* memory read structure */
376:                    map22_memwrite, /* memory write structure */
377:                    NULL /* external sound device */
378:                 };
379:                 
380:                 mapintf_t map23_intf =
381:                 {
382:                    23, /* mapper number */
383:                    "Konami VRC2 B", /* mapper name */
384:                    vrc_init, /* init routine */
385:                    NULL, /* vblank callback */
386:                    vrc_hblank, /* hblank callback */
387:                    NULL, /* get state (snss) */
388:                    NULL, /* set state (snss) */
389:                    NULL, /* memory read structure */
390:                    map23_memwrite, /* memory write structure */
391:                    NULL /* external sound device */
392:                 };
393:                 
394:                 mapintf_t map25_intf =
395:                 {
396:                    25, /* mapper number */
397:                    "Konami VRC4 B", /* mapper name */
398:                    NULL, /* init routine */
399:                    NULL, /* vblank callback */
400:                    vrc_hblank, /* hblank callback */
401:                    NULL, /* get state (snss) */
402:                    NULL, /* set state (snss) */
403:                    NULL, /* memory read structure */
404:                    map21_memwrite, /* memory write structure */
405:                    NULL /* external sound device */
406:                 };
407:                 
408:                 /*
409:                 ** $Log: mapvrc.c,v $
410:                 ** Revision 1.2  2001/04/27 14:37:11  neil
411:                 ** wheeee
412:                 **
413:                 ** Revision 1.1  2001/04/27 12:54:40  neil
414:                 ** blah
415:                 **
416:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
417:                 ** initial
418:                 **
419:                 ** Revision 1.1  2000/10/24 12:19:33  matt
420:                 ** changed directory structure
421:                 **
422:                 ** Revision 1.10  2000/10/22 19:17:46  matt
423:                 ** mapper cleanups galore
424:                 **
425:                 ** Revision 1.9  2000/10/22 15:03:14  matt
426:                 ** simplified mirroring
427:                 **
428:                 ** Revision 1.8  2000/10/21 19:33:38  matt
429:                 ** many more cleanups
430:                 **
431:                 ** Revision 1.7  2000/10/10 13:58:17  matt
432:                 ** stroustrup squeezing his way in the door
433:                 **
434:                 ** Revision 1.6  2000/08/16 02:50:11  matt
435:                 ** random mapper cleanups
436:                 **
437:                 ** Revision 1.5  2000/07/15 23:52:20  matt
438:                 ** rounded out a bunch more mapper interfaces
439:                 **
440:                 ** Revision 1.4  2000/07/10 13:51:25  matt
441:                 ** using generic nes_irq() routine now
442:                 **
443:                 ** Revision 1.3  2000/07/10 05:29:03  matt
444:                 ** cleaned up some mirroring issues
445:                 **
446:                 ** Revision 1.2  2000/07/06 02:48:43  matt
447:                 ** clearly labelled structure members
448:                 **
449:                 ** Revision 1.1  2000/07/06 01:01:56  matt
450:                 ** initial revision
451:                 **
452:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map231.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map231.c
21:                  **
22:                  ** mapper 231 interface
23:                  ** $Id: map231.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  
29:                  /* mapper 231: NINA-07, used in Wally Bear and the NO! Gang */
30:                  
31:                  static void map231_init(void)
32:                  {
9D03ADE4  27BDFFE8   ADDIU SP, SP, -24
9D03ADE8  AFBF0014   SW RA, 20(SP)
33:                     mmc_bankrom(32, 0x8000, MMC_LASTBANK);
9D03ADEC  24040020   ADDIU A0, ZERO, 32
9D03ADF0  34058000   ORI A1, ZERO, -32768
9D03ADF4  0F40B246   JAL mmc_bankrom
9D03ADF8  2406FFFF   ADDIU A2, ZERO, -1
34:                  }
9D03ADFC  8FBF0014   LW RA, 20(SP)
9D03AE00  03E00008   JR RA
9D03AE04  27BD0018   ADDIU SP, SP, 24
35:                  
36:                  static void map231_write(uint32 address, uint8 value)
37:                  {
9D03AE08  27BDFFE8   ADDIU SP, SP, -24
9D03AE0C  AFBF0014   SW RA, 20(SP)
9D03AE10  AFB00010   SW S0, 16(SP)
9D03AE14  00A08021   ADDU S0, A1, ZERO
38:                     int bank, vbank;
39:                     UNUSED(address);
40:                  
41:                     bank = ((value & 0x80) >> 5) | (value & 0x03);
9D03AE18  30A60080   ANDI A2, A1, 128
9D03AE1C  00063143   SRA A2, A2, 5
9D03AE20  30A20003   ANDI V0, A1, 3
42:                     vbank = (value >> 4) & 0x07;
43:                  
44:                     mmc_bankrom(32, 0x8000, bank);
9D03AE24  24040020   ADDIU A0, ZERO, 32
9D03AE28  34058000   ORI A1, ZERO, -32768
9D03AE2C  0F40B246   JAL mmc_bankrom
9D03AE30  00C23025   OR A2, A2, V0
45:                     mmc_bankvrom(8, 0x0000, vbank);
9D03AE34  24040008   ADDIU A0, ZERO, 8
9D03AE38  00002821   ADDU A1, ZERO, ZERO
9D03AE3C  0F40B1E8   JAL mmc_bankvrom
9D03AE40  7E061100   EXT A2, S0, 4, 3
46:                  }
9D03AE44  8FBF0014   LW RA, 20(SP)
9D03AE48  8FB00010   LW S0, 16(SP)
9D03AE4C  03E00008   JR RA
9D03AE50  27BD0018   ADDIU SP, SP, 24
47:                  
48:                  static map_memwrite map231_memwrite[] =
49:                  {
50:                     { 0x8000, 0xFFFF, map231_write },
51:                     {     -1,     -1, NULL }
52:                  };
53:                  
54:                  mapintf_t map231_intf = 
55:                  {
56:                     231, /* mapper number */
57:                     "NINA-07", /* mapper name */
58:                     map231_init, /* init routine */
59:                     NULL, /* vblank callback */
60:                     NULL, /* hblank callback */
61:                     NULL, /* get state (snss) */
62:                     NULL, /* set state (snss) */
63:                     NULL, /* memory read structure */
64:                     map231_memwrite, /* memory write structure */
65:                     NULL /* external sound device */
66:                  };
67:                  
68:                  /*
69:                  ** $Log: map231.c,v $
70:                  ** Revision 1.2  2001/04/27 14:37:11  neil
71:                  ** wheeee
72:                  **
73:                  ** Revision 1.1  2001/04/27 12:54:40  neil
74:                  ** blah
75:                  **
76:                  ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
77:                  ** initial
78:                  **
79:                  ** Revision 1.1  2000/10/24 12:19:33  matt
80:                  ** changed directory structure
81:                  **
82:                  ** Revision 1.4  2000/10/22 19:17:46  matt
83:                  ** mapper cleanups galore
84:                  **
85:                  ** Revision 1.3  2000/10/21 19:33:38  matt
86:                  ** many more cleanups
87:                  **
88:                  ** Revision 1.2  2000/08/16 02:50:11  matt
89:                  ** random mapper cleanups
90:                  **
91:                  ** Revision 1.1  2000/07/11 03:14:18  melanson
92:                  ** Initial commit for mappers 16, 34, and 231
93:                  **
94:                  **
95:                  */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map229.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map229.c
21:                  **
22:                  ** Mapper #229 (31 in 1)
23:                  ** Implementation by Firebug
24:                  ** Mapper information courtesy of Mark Knibbs
25:                  ** $Id: map229.c,v 1.2 2001/04/27 14:37:11 neil Exp $
26:                  **
27:                  */
28:                  
29:                  #include <noftypes.h>
30:                  #include <nes_mmc.h>
31:                  #include <nes.h>
32:                  #include <libsnss.h>
33:                  #include <log.h>
34:                  
35:                  /************************/
36:                  /* Mapper #229: 31 in 1 */
37:                  /************************/
38:                  static void map229_init (void)
39:                  {
9D038D60  27BDFFE8   ADDIU SP, SP, -24
9D038D64  AFBF0014   SW RA, 20(SP)
40:                    /* On reset, PRG is set to first 32K and CHR to first 8K */
41:                    mmc_bankrom (32, 0x8000, 0x00);
9D038D68  24040020   ADDIU A0, ZERO, 32
9D038D6C  34058000   ORI A1, ZERO, -32768
9D038D70  0F40B246   JAL mmc_bankrom
9D038D74  00003021   ADDU A2, ZERO, ZERO
42:                    mmc_bankvrom (8, 0x0000, 0x00);
9D038D78  24040008   ADDIU A0, ZERO, 8
9D038D7C  00002821   ADDU A1, ZERO, ZERO
9D038D80  0F40B1E8   JAL mmc_bankvrom
9D038D84  00003021   ADDU A2, ZERO, ZERO
43:                  
44:                    /* Done */
45:                    return;
46:                  }
9D038D88  8FBF0014   LW RA, 20(SP)
9D038D8C  03E00008   JR RA
9D038D90  27BD0018   ADDIU SP, SP, 24
47:                  
48:                  /*******************************************/
49:                  /* Mapper #229 write handler ($8000-$FFFF) */
50:                  /*******************************************/
51:                  static void map229_write (uint32 address, uint8 value)
52:                  {
9D038D94  27BDFFE0   ADDIU SP, SP, -32
9D038D98  AFBF001C   SW RA, 28(SP)
9D038D9C  AFB10018   SW S1, 24(SP)
9D038DA0  AFB00014   SW S0, 20(SP)
9D038DA4  00808021   ADDU S0, A0, ZERO
53:                    /* Value written is irrelevant */
54:                    UNUSED (value);
55:                  
56:                    /* A4-A0 sets 8K CHR page */
57:                    mmc_bankvrom (8, 0x0000, (uint8) (address & 0x1F));
9D038DA8  3091001F   ANDI S1, A0, 31
9D038DAC  24040008   ADDIU A0, ZERO, 8
9D038DB0  00002821   ADDU A1, ZERO, ZERO
9D038DB4  0F40B1E8   JAL mmc_bankvrom
9D038DB8  02203021   ADDU A2, S1, ZERO
58:                  
59:                    /* If A4-A1 are all low then select the first 32K,     */
60:                    /* otherwise select a 16K bank at both $8000 and $C000 */
61:                    if ((address & 0x1E) == 0x00)
9D038DBC  3202001E   ANDI V0, S0, 30
9D038DC0  14400007   BNE V0, ZERO, 0x9D038DE0
9D038DC4  24040010   ADDIU A0, ZERO, 16
62:                    {
63:                      mmc_bankrom (32, 0x8000, 0x00);
9D038DC8  24040020   ADDIU A0, ZERO, 32
9D038DCC  34058000   ORI A1, ZERO, -32768
9D038DD0  0F40B246   JAL mmc_bankrom
9D038DD4  00003021   ADDU A2, ZERO, ZERO
9D038DD8  0B40E380   J 0x9D038E00
9D038DDC  32100020   ANDI S0, S0, 32
64:                    }
65:                    else
66:                    {
67:                      mmc_bankrom (16, 0x8000, (uint8) (address & 0x1F));
9D038DE0  34058000   ORI A1, ZERO, -32768
9D038DE4  0F40B246   JAL mmc_bankrom
9D038DE8  02203021   ADDU A2, S1, ZERO
68:                      mmc_bankrom (16, 0xC000, (uint8) (address & 0x1F));
9D038DEC  24040010   ADDIU A0, ZERO, 16
9D038DF0  3405C000   ORI A1, ZERO, -16384
9D038DF4  0F40B246   JAL mmc_bankrom
9D038DF8  02203021   ADDU A2, S1, ZERO
69:                    }
70:                  
71:                    /* A5: mirroring (low = vertical, high = horizontal) */
72:                    if (address & 0x20) ppu_mirror(0, 0, 1, 1);
9D038DFC  32100020   ANDI S0, S0, 32
9D038E00  12000007   BEQ S0, ZERO, 0x9D038E20
9D038E04  00002021   ADDU A0, ZERO, ZERO
9D038E08  00002821   ADDU A1, ZERO, ZERO
9D038E0C  24060001   ADDIU A2, ZERO, 1
9D038E10  0F406128   JAL ppu_mirror
9D038E14  24070001   ADDIU A3, ZERO, 1
9D038E18  0B40E38D   J 0x9D038E34
9D038E1C  8FBF001C   LW RA, 28(SP)
73:                    else                ppu_mirror(0, 1, 0, 1);
9D038E20  24050001   ADDIU A1, ZERO, 1
9D038E24  00003021   ADDU A2, ZERO, ZERO
9D038E28  0F406128   JAL ppu_mirror
9D038E2C  24070001   ADDIU A3, ZERO, 1
74:                  
75:                    /* Done */
76:                    return;
77:                  }
9D038E30  8FBF001C   LW RA, 28(SP)
9D038E34  8FB10018   LW S1, 24(SP)
9D038E38  8FB00014   LW S0, 20(SP)
9D038E3C  03E00008   JR RA
9D038E40  27BD0020   ADDIU SP, SP, 32
78:                  
79:                  static map_memwrite map229_memwrite [] =
80:                  {
81:                     { 0x8000, 0xFFFF, map229_write },
82:                     {     -1,     -1, NULL }
83:                  };
84:                  
85:                  mapintf_t map229_intf =
86:                  {
87:                     229,                              /* Mapper number */
88:                     "31 in 1 (bootleg)",              /* Mapper name */
89:                     map229_init,                      /* Initialization routine */
90:                     NULL,                             /* VBlank callback */
91:                     NULL,                             /* HBlank callback */
92:                     NULL,                             /* Get state (SNSS) */
93:                     NULL,                             /* Set state (SNSS) */
94:                     NULL,                             /* Memory read structure */
95:                     map229_memwrite,                  /* Memory write structure */
96:                     NULL                              /* External sound device */
97:                  };
98:                  
99:                  /*
100:                 ** $Log: map229.c,v $
101:                 ** Revision 1.2  2001/04/27 14:37:11  neil
102:                 ** wheeee
103:                 **
104:                 ** Revision 1.1  2001/04/27 12:54:40  neil
105:                 ** blah
106:                 **
107:                 ** Revision 1.1  2001/04/27 10:57:41  neil
108:                 ** wheee
109:                 **
110:                 ** Revision 1.1  2000/12/30 06:34:31  firebug
111:                 ** Initial revision
112:                 **
113:                 **
114:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map160.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map160.c
21:                  **
22:                  ** mapper 160 interface
23:                  ** $Id: map160.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes_ppu.h>
29:                  #include <nes.h>
30:                  
31:                  static struct
32:                  {
33:                     bool enabled, expired;
34:                     int counter;
35:                     int latch_c005, latch_c003;
36:                  } irq;
37:                  
38:                  static void map160_write(uint32 address, uint8 value)
39:                  {
9D036464  27BDFFE8   ADDIU SP, SP, -24
9D036468  AFBF0014   SW RA, 20(SP)
40:                     if (address >= 0x8000 && address <= 0x8003)
9D03646C  24828000   ADDIU V0, A0, -32768
9D036470  2C420004   SLTIU V0, V0, 4
9D036474  10400008   BEQ V0, ZERO, 0x9D036498
9D036478  00A03021   ADDU A2, A1, ZERO
41:                     {
42:                        mmc_bankrom(8, 0x8000 + 0x2000 * (address & 3), value);
9D03647C  30840003   ANDI A0, A0, 3
9D036480  24850004   ADDIU A1, A0, 4
9D036484  24040008   ADDIU A0, ZERO, 8
9D036488  0F40B246   JAL mmc_bankrom
9D03648C  00052B40   SLL A1, A1, 13
9D036490  0B40D951   J 0x9D036544
9D036494  8FBF0014   LW RA, 20(SP)
43:                     }
44:                     else if (address >= 0x9000 && address <= 0x9007)
9D036498  3C02FFFF   LUI V0, -1
9D03649C  24427000   ADDIU V0, V0, 28672
9D0364A0  00821021   ADDU V0, A0, V0
9D0364A4  2C420008   SLTIU V0, V0, 8
9D0364A8  10400007   BEQ V0, ZERO, 0x9D0364C8
9D0364AC  3402C002   ORI V0, ZERO, -16382
45:                     {
46:                        mmc_bankvrom(1, 0x400 * (address & 7), value);
9D0364B0  30850007   ANDI A1, A0, 7
9D0364B4  24040001   ADDIU A0, ZERO, 1
9D0364B8  0F40B1E8   JAL mmc_bankvrom
9D0364BC  00052A80   SLL A1, A1, 10
9D0364C0  0B40D951   J 0x9D036544
9D0364C4  8FBF0014   LW RA, 20(SP)
47:                     }
48:                     else if (0xC002 == address)
9D0364C8  14820007   BNE A0, V0, 0x9D0364E8
9D0364CC  3402C003   ORI V0, ZERO, -16381
49:                     {
50:                        irq.enabled = false;
9D0364D0  3C02A001   LUI V0, -24575
9D0364D4  AC40B870   SW ZERO, -18320(V0)
51:                        irq.latch_c005 = irq.latch_c003;
9D0364D8  2442B870   ADDIU V0, V0, -18320
9D0364DC  8C430010   LW V1, 16(V0)
9D0364E0  0B40D950   J 0x9D036540
9D0364E4  AC43000C   SW V1, 12(V0)
52:                     }
53:                     else if (0xC003 == address)
9D0364E8  1482000F   BNE A0, V0, 0x9D036528
9D0364EC  3402C005   ORI V0, ZERO, -16379
54:                     {
55:                        if (false == irq.expired)
9D0364F0  3C02A001   LUI V0, -24575
9D0364F4  8C42B874   LW V0, -18316(V0)
9D0364F8  14400004   BNE V0, ZERO, 0x9D03650C
9D0364FC  3C03A001   LUI V1, -24575
56:                        {
57:                           irq.counter = value;
9D036500  3C02A001   LUI V0, -24575
9D036504  0B40D950   J 0x9D036540
9D036508  AC45B878   SW A1, -18312(V0)
58:                        }
59:                        else
60:                        {
61:                           irq.expired = false;
9D03650C  2462B870   ADDIU V0, V1, -18320
9D036510  AC400004   SW ZERO, 4(V0)
62:                           irq.enabled = true;
9D036514  24040001   ADDIU A0, ZERO, 1
9D036518  AC64B870   SW A0, -18320(V1)
63:                           irq.counter = irq.latch_c005;
9D03651C  8C43000C   LW V1, 12(V0)
9D036520  0B40D950   J 0x9D036540
9D036524  AC430008   SW V1, 8(V0)
64:                        }
65:                     }
66:                     else if (0xC005 == address)
9D036528  14820006   BNE A0, V0, 0x9D036544
9D03652C  8FBF0014   LW RA, 20(SP)
67:                     {
68:                        irq.latch_c005 = value;
9D036530  3C02A001   LUI V0, -24575
9D036534  2442B870   ADDIU V0, V0, -18320
9D036538  AC45000C   SW A1, 12(V0)
69:                        irq.counter = value;
9D03653C  AC450008   SW A1, 8(V0)
70:                     }
71:                  #ifdef NOFRENDO_DEBUG
72:                     else
73:                     {
74:                        log_printf("mapper 160: untrapped write $%02X to $%04X\n", value, address);
75:                     }
76:                  #endif /* NOFRENDO_DEBUG */
77:                  }
9D036540  8FBF0014   LW RA, 20(SP)
9D036544  03E00008   JR RA
9D036548  27BD0018   ADDIU SP, SP, 24
78:                  
79:                  static void map160_hblank(int vblank)
80:                  {
9D036554  27BDFFE8   ADDIU SP, SP, -24
9D036558  AFBF0014   SW RA, 20(SP)
81:                     if (!vblank)
9D03654C  1480001B   BNE A0, ZERO, 0x9D0365BC
9D036550  00000000   NOP
82:                     {
83:                        if (ppu_enabled() && irq.enabled)
9D03655C  0F406397   JAL ppu_enabled
9D036560  00000000   NOP
9D036564  10400013   BEQ V0, ZERO, 0x9D0365B4
9D036568  3C02A001   LUI V0, -24575
9D03656C  8C42B870   LW V0, -18320(V0)
9D036570  10400010   BEQ V0, ZERO, 0x9D0365B4
9D036574  3C02A001   LUI V0, -24575
84:                        {
85:                           if (0 == irq.counter && false == irq.expired)
9D036578  8C42B878   LW V0, -18312(V0)
9D03657C  1440000B   BNE V0, ZERO, 0x9D0365AC
9D036580  2442FFFF   ADDIU V0, V0, -1
9D036584  3C03A001   LUI V1, -24575
9D036588  8C63B874   LW V1, -18316(V1)
9D03658C  14600008   BNE V1, ZERO, 0x9D0365B0
9D036590  3C03A001   LUI V1, -24575
86:                           {
87:                              irq.expired = true;
9D036594  24030001   ADDIU V1, ZERO, 1
9D036598  3C02A001   LUI V0, -24575
88:                              nes_irq();
9D03659C  0F408A46   JAL nes_irq
9D0365A0  AC43B874   SW V1, -18316(V0)
9D0365A4  0B40D96E   J 0x9D0365B8
9D0365A8  8FBF0014   LW RA, 20(SP)
89:                           }
90:                           else
91:                           {
92:                              irq.counter--;
9D0365AC  3C03A001   LUI V1, -24575
9D0365B0  AC62B878   SW V0, -18312(V1)
93:                           }
94:                        }
95:                     }
96:                  }
9D0365B4  8FBF0014   LW RA, 20(SP)
9D0365B8  27BD0018   ADDIU SP, SP, 24
9D0365BC  03E00008   JR RA
9D0365C0  00000000   NOP
97:                  
98:                  static void map160_init(void)
99:                  {
100:                    irq.enabled = false;
9D036444  3C02A001   LUI V0, -24575
9D036448  AC40B870   SW ZERO, -18320(V0)
101:                    irq.expired = false;
9D03644C  2442B870   ADDIU V0, V0, -18320
9D036450  AC400004   SW ZERO, 4(V0)
102:                    irq.counter = 0;
9D036454  AC400008   SW ZERO, 8(V0)
103:                    irq.latch_c003 = irq.latch_c005 = 0;
9D036458  AC40000C   SW ZERO, 12(V0)
9D03645C  03E00008   JR RA
9D036460  AC400010   SW ZERO, 16(V0)
104:                 }
105:                 
106:                 static map_memwrite map160_memwrite[] =
107:                 {
108:                    { 0x8000, 0xFFFF, map160_write },
109:                    {     -1,     -1, NULL }
110:                 };
111:                 
112:                 mapintf_t map160_intf =
113:                 {
114:                    160, /* mapper number */
115:                    "Aladdin (pirate)", /* mapper name */
116:                    map160_init, /* init routine */
117:                    NULL, /* vblank callback */
118:                    map160_hblank, /* hblank callback */
119:                    NULL, /* get state (snss) */
120:                    NULL, /* set state (snss) */
121:                    NULL, /* memory read structure */
122:                    map160_memwrite, /* memory write structure */
123:                    NULL /* external sound device */
124:                 };
125:                 
126:                 /*
127:                 ** $Log: map160.c,v $
128:                 ** Revision 1.2  2001/04/27 14:37:11  neil
129:                 ** wheeee
130:                 **
131:                 ** Revision 1.1  2001/04/27 12:54:40  neil
132:                 ** blah
133:                 **
134:                 ** Revision 1.1  2001/04/27 10:57:41  neil
135:                 ** wheee
136:                 **
137:                 ** Revision 1.1  2000/12/27 04:24:46  matt
138:                 ** initial revision
139:                 **
140:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map099.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map99.c
21:                  **
22:                  ** mapper 99 interface
23:                  ** $Id: map099.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes_ppu.h>
29:                  
30:                  /* Switch VROM for VS games */
31:                  static void map99_vromswitch(uint8 value)
32:                  {
9D03B530  27BDFFE8   ADDIU SP, SP, -24
9D03B534  AFBF0014   SW RA, 20(SP)
33:                     int bank = (value & 0x04) >> 2;
9D03B538  7C860080   EXT A2, A0, 2, 1
34:                     mmc_bankvrom(8, 0x0000, bank);
9D03B53C  24040008   ADDIU A0, ZERO, 8
9D03B540  0F40B1E8   JAL mmc_bankvrom
9D03B544  00002821   ADDU A1, ZERO, ZERO
35:                  }
9D03B548  8FBF0014   LW RA, 20(SP)
9D03B54C  03E00008   JR RA
9D03B550  27BD0018   ADDIU SP, SP, 24
36:                  
37:                  /* mapper 99: VS. System */
38:                  static void map99_init(void)
39:                  {
9D03B4FC  27BDFFE8   ADDIU SP, SP, -24
9D03B500  AFBF0014   SW RA, 20(SP)
40:                     ppu_mirror(0, 1, 2, 3);
9D03B504  00002021   ADDU A0, ZERO, ZERO
9D03B508  24050001   ADDIU A1, ZERO, 1
9D03B50C  24060002   ADDIU A2, ZERO, 2
9D03B510  0F406128   JAL ppu_mirror
9D03B514  24070003   ADDIU A3, ZERO, 3
41:                     ppu_setvromswitch(map99_vromswitch);
9D03B518  3C049D04   LUI A0, -25340
9D03B51C  0F406394   JAL ppu_setvromswitch
9D03B520  2484B530   ADDIU A0, A0, -19152
42:                  }
9D03B524  8FBF0014   LW RA, 20(SP)
9D03B528  03E00008   JR RA
9D03B52C  27BD0018   ADDIU SP, SP, 24
43:                  
44:                  mapintf_t map99_intf =
45:                  {
46:                     99, /* mapper number */
47:                     "VS. System", /* mapper name */
48:                     map99_init, /* init routine */
49:                     NULL, /* vblank callback */
50:                     NULL, /* hblank callback */
51:                     NULL, /* get state (snss) */
52:                     NULL, /* set state (snss) */
53:                     NULL, /* memory read structure */
54:                     NULL, /* memory write structure */
55:                     NULL /* external sound device */
56:                  };
57:                  
58:                  /*
59:                  ** $Log: map099.c,v $
60:                  ** Revision 1.2  2001/04/27 14:37:11  neil
61:                  ** wheeee
62:                  **
63:                  ** Revision 1.1  2001/04/27 12:54:40  neil
64:                  ** blah
65:                  **
66:                  ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
67:                  ** initial
68:                  **
69:                  ** Revision 1.1  2000/10/24 12:19:33  matt
70:                  ** changed directory structure
71:                  **
72:                  ** Revision 1.6  2000/10/22 19:17:47  matt
73:                  ** mapper cleanups galore
74:                  **
75:                  ** Revision 1.5  2000/10/21 19:33:38  matt
76:                  ** many more cleanups
77:                  **
78:                  ** Revision 1.4  2000/10/10 13:58:17  matt
79:                  ** stroustrup squeezing his way in the door
80:                  **
81:                  ** Revision 1.3  2000/07/10 05:29:03  matt
82:                  ** cleaned up some mirroring issues
83:                  **
84:                  ** Revision 1.2  2000/07/06 02:48:43  matt
85:                  ** clearly labelled structure members
86:                  **
87:                  ** Revision 1.1  2000/07/05 05:05:18  matt
88:                  ** initial revision
89:                  **
90:                  */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map094.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map94.c
21:                  **
22:                  ** mapper 94 interface
23:                  ** $Id: map094.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  
29:                  /* mapper 94: Senjou no Ookami */
30:                  static void map94_write(uint32 address, uint8 value)
31:                  {
9D03BE90  27BDFFE8   ADDIU SP, SP, -24
9D03BE94  AFBF0014   SW RA, 20(SP)
32:                     UNUSED(address);
33:                  
34:                     /* ($8000-$FFFF) D7-D2 = switch $8000-$BFFF */
35:                     mmc_bankrom(16, 0x8000, value >> 2);
9D03BE98  00053082   SRL A2, A1, 2
9D03BE9C  24040010   ADDIU A0, ZERO, 16
9D03BEA0  0F40B246   JAL mmc_bankrom
9D03BEA4  34058000   ORI A1, ZERO, -32768
36:                  }
9D03BEA8  8FBF0014   LW RA, 20(SP)
9D03BEAC  03E00008   JR RA
9D03BEB0  27BD0018   ADDIU SP, SP, 24
37:                  
38:                  static map_memwrite map94_memwrite[] =
39:                  {
40:                     { 0x8000, 0xFFFF, map94_write },
41:                     {     -1,     -1, NULL }
42:                  };
43:                  
44:                  mapintf_t map94_intf =
45:                  {
46:                     94, /* mapper number */
47:                     "Mapper 94", /* mapper name */
48:                     NULL, /* init routine */
49:                     NULL, /* vblank callback */
50:                     NULL, /* hblank callback */
51:                     NULL, /* get state (snss) */
52:                     NULL, /* set state (snss) */
53:                     NULL, /* memory read structure */
54:                     map94_memwrite, /* memory write structure */
55:                     NULL /* external sound device */
56:                  };
57:                  
58:                  /*
59:                  ** $Log: map094.c,v $
60:                  ** Revision 1.2  2001/04/27 14:37:11  neil
61:                  ** wheeee
62:                  **
63:                  ** Revision 1.1  2001/04/27 12:54:40  neil
64:                  ** blah
65:                  **
66:                  ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
67:                  ** initial
68:                  **
69:                  ** Revision 1.1  2000/10/24 12:19:33  matt
70:                  ** changed directory structure
71:                  **
72:                  ** Revision 1.5  2000/10/22 19:17:47  matt
73:                  ** mapper cleanups galore
74:                  **
75:                  ** Revision 1.4  2000/10/21 19:33:38  matt
76:                  ** many more cleanups
77:                  **
78:                  ** Revision 1.3  2000/08/16 02:50:11  matt
79:                  ** random mapper cleanups
80:                  **
81:                  ** Revision 1.2  2000/07/06 02:48:43  matt
82:                  ** clearly labelled structure members
83:                  **
84:                  ** Revision 1.1  2000/07/06 01:01:56  matt
85:                  ** initial revision
86:                  **
87:                  */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map093.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map93.c
21:                  **
22:                  ** mapper 93 interface
23:                  ** $Id: map093.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes_ppu.h>
29:                  
30:                  static void map93_write(uint32 address, uint8 value)
31:                  {
9D03B1A4  27BDFFE8   ADDIU SP, SP, -24
9D03B1A8  AFBF0014   SW RA, 20(SP)
9D03B1AC  AFB00010   SW S0, 16(SP)
9D03B1B0  00A08021   ADDU S0, A1, ZERO
32:                     UNUSED(address);
33:                  
34:                     /* ($8000-$FFFF) D7-D4 = switch $8000-$BFFF D0: mirror */
35:                     mmc_bankrom(16, 0x8000, value >> 4);
9D03B1B4  24040010   ADDIU A0, ZERO, 16
9D03B1B8  34058000   ORI A1, ZERO, -32768
9D03B1BC  0F40B246   JAL mmc_bankrom
9D03B1C0  00103102   SRL A2, S0, 4
36:                  
37:                     if (value & 1)
9D03B1C4  32100001   ANDI S0, S0, 1
9D03B1C8  12000007   BEQ S0, ZERO, 0x9D03B1E8
9D03B1CC  00002021   ADDU A0, ZERO, ZERO
38:                        ppu_mirror(0, 1, 0, 1); /* vert */
9D03B1D0  24050001   ADDIU A1, ZERO, 1
9D03B1D4  00003021   ADDU A2, ZERO, ZERO
9D03B1D8  0F406128   JAL ppu_mirror
9D03B1DC  24070001   ADDIU A3, ZERO, 1
9D03B1E0  0B40EC7F   J 0x9D03B1FC
9D03B1E4  8FBF0014   LW RA, 20(SP)
39:                     else
40:                        ppu_mirror(0, 0, 1, 1); /* horiz */
9D03B1E8  00002821   ADDU A1, ZERO, ZERO
9D03B1EC  24060001   ADDIU A2, ZERO, 1
9D03B1F0  0F406128   JAL ppu_mirror
9D03B1F4  24070001   ADDIU A3, ZERO, 1
41:                  }
9D03B1F8  8FBF0014   LW RA, 20(SP)
9D03B1FC  8FB00010   LW S0, 16(SP)
9D03B200  03E00008   JR RA
9D03B204  27BD0018   ADDIU SP, SP, 24
42:                  
43:                  static map_memwrite map93_memwrite[] =
44:                  {
45:                     { 0x8000, 0xFFFF, map93_write },
46:                     {     -1,     -1, NULL }
47:                  };
48:                  
49:                  mapintf_t map93_intf =
50:                  {
51:                     93, /* mapper number */
52:                     "Mapper 93", /* mapper name */
53:                     NULL, /* init routine */
54:                     NULL, /* vblank callback */
55:                     NULL, /* hblank callback */
56:                     NULL, /* get state (snss) */
57:                     NULL, /* set state (snss) */
58:                     NULL, /* memory read structure */
59:                     map93_memwrite, /* memory write structure */
60:                     NULL /* external sound device */
61:                  };
62:                  
63:                  /*
64:                  ** $Log: map093.c,v $
65:                  ** Revision 1.2  2001/04/27 14:37:11  neil
66:                  ** wheeee
67:                  **
68:                  ** Revision 1.1  2001/04/27 12:54:40  neil
69:                  ** blah
70:                  **
71:                  ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
72:                  ** initial
73:                  **
74:                  ** Revision 1.1  2000/12/11 12:33:48  matt
75:                  ** initial revision
76:                  **
77:                  */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map087.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map087.c
21:                  **
22:                  ** Mapper #87 (16K VROM switch)
23:                  ** Implementation by Firebug
24:                  ** $Id: map087.c,v 1.2 2001/04/27 14:37:11 neil Exp $
25:                  **
26:                  */
27:                  
28:                  #include <noftypes.h>
29:                  #include <nes_mmc.h>
30:                  #include <nes.h>
31:                  #include <libsnss.h>
32:                  #include <log.h>
33:                  
34:                  /******************************************/
35:                  /* Mapper #87 write handler ($6000-$7FFF) */
36:                  /******************************************/
37:                  static void map87_write (uint32 address, uint8 value)
38:                  {
9D03B78C  27BDFFE8   ADDIU SP, SP, -24
39:                    /* Within range, address written to is irrelevant */
40:                    UNUSED (address);
41:                  
42:                    /* Very simple: 8K CHR page is selected by D1 */
43:                    if (value & 0x02) mmc_bankvrom (8, 0x0000, 0x01);
9D03B790  30A50002   ANDI A1, A1, 2
9D03B794  30A500FF   ANDI A1, A1, 255
9D03B798  10A00007   BEQ A1, ZERO, 0x9D03B7B8
9D03B79C  AFBF0014   SW RA, 20(SP)
9D03B7A0  24040008   ADDIU A0, ZERO, 8
9D03B7A4  00002821   ADDU A1, ZERO, ZERO
9D03B7A8  0F40B1E8   JAL mmc_bankvrom
9D03B7AC  24060001   ADDIU A2, ZERO, 1
9D03B7B0  0B40EDF3   J 0x9D03B7CC
9D03B7B4  8FBF0014   LW RA, 20(SP)
44:                    else              mmc_bankvrom (8, 0x0000, 0x00);
9D03B7B8  24040008   ADDIU A0, ZERO, 8
9D03B7BC  00002821   ADDU A1, ZERO, ZERO
9D03B7C0  0F40B1E8   JAL mmc_bankvrom
9D03B7C4  00003021   ADDU A2, ZERO, ZERO
45:                  
46:                    /* Done */
47:                    return;
48:                  }
9D03B7C8  8FBF0014   LW RA, 20(SP)
9D03B7CC  03E00008   JR RA
9D03B7D0  27BD0018   ADDIU SP, SP, 24
49:                  
50:                  static map_memwrite map87_memwrite [] =
51:                  {
52:                     { 0x6000, 0x7FFF, map87_write },
53:                     {     -1,     -1, NULL }
54:                  };
55:                  
56:                  mapintf_t map87_intf =
57:                  {
58:                     87,                               /* Mapper number */
59:                     "16K VROM switch",                /* Mapper name */
60:                     NULL,                             /* Initialization routine */
61:                     NULL,                             /* VBlank callback */
62:                     NULL,                             /* HBlank callback */
63:                     NULL,                             /* Get state (SNSS) */
64:                     NULL,                             /* Set state (SNSS) */
65:                     NULL,                             /* Memory read structure */
66:                     map87_memwrite,                   /* Memory write structure */
67:                     NULL                              /* External sound device */
68:                  };
69:                  
70:                  /*
71:                  ** $Log: map087.c,v $
72:                  ** Revision 1.2  2001/04/27 14:37:11  neil
73:                  ** wheeee
74:                  **
75:                  ** Revision 1.1  2001/04/27 12:54:40  neil
76:                  ** blah
77:                  **
78:                  ** Revision 1.1  2001/04/27 10:57:41  neil
79:                  ** wheee
80:                  **
81:                  ** Revision 1.1  2000/12/30 06:34:44  firebug
82:                  ** Initial revision
83:                  **
84:                  **
85:                  */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map085.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map85.c
21:                  **
22:                  ** mapper 85 interface
23:                  ** $Id: map085.c,v 1.3 2001/05/06 01:42:03 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes.h>
29:                  #include <log.h>
30:                  
31:                  static struct
32:                  {
33:                     int counter, latch;
34:                     int wait_state;
35:                     bool enabled;
36:                  } irq;
37:                  
38:                  /* mapper 85: Konami VRC7 */
39:                  static void map85_write(uint32 address, uint8 value)
40:                  {
9D032644  27BDFFE8   ADDIU SP, SP, -24
41:                     uint8 bank = address >> 12;
42:                     uint8 reg = (address & 0x10) | ((address & 0x08) << 1);
9D032648  308200FF   ANDI V0, A0, 255
9D03264C  30430008   ANDI V1, V0, 8
9D032650  00031840   SLL V1, V1, 1
9D032654  30420010   ANDI V0, V0, 16
9D032658  00621025   OR V0, V1, V0
9D03265C  7C843B00   EXT A0, A0, 12, 8
43:                  
44:                     switch (bank)
9D032660  2484FFF8   ADDIU A0, A0, -8
9D032664  2C830008   SLTIU V1, A0, 8
9D032668  1060007F   BEQ V1, ZERO, 0x9D032868
9D03266C  AFBF0014   SW RA, 20(SP)
9D032670  00042080   SLL A0, A0, 2
9D032674  3C039D03   LUI V1, -25341
9D032678  2463268C   ADDIU V1, V1, 9868
9D03267C  00642021   ADDU A0, V1, A0
9D032680  8C830000   LW V1, 0(A0)
9D032684  00600008   JR V1
9D032688  00A03021   ADDU A2, A1, ZERO
45:                     {
46:                     case 0x08:
47:                        if (0x10 == reg)
9D0326AC  10400005   BEQ V0, ZERO, 0x9D0326C4
9D0326B0  24040008   ADDIU A0, ZERO, 8
48:                           mmc_bankrom(8, 0xA000, value);
9D0326B4  0F40B246   JAL mmc_bankrom
9D0326B8  3405A000   ORI A1, ZERO, -24576
9D0326BC  0B40CA1B   J 0x9D03286C
9D0326C0  8FBF0014   LW RA, 20(SP)
49:                        else
50:                           mmc_bankrom(8, 0x8000, value);
9D0326C4  0F40B246   JAL mmc_bankrom
9D0326C8  34058000   ORI A1, ZERO, -32768
51:                        break;
52:                  
53:                     case 0x09:
54:                        /* 0x10 & 0x30 should be trapped by sound emulation */
55:                        mmc_bankrom(8, 0xC000, value);
9D0326D4  24040008   ADDIU A0, ZERO, 8
9D0326D8  0F40B246   JAL mmc_bankrom
9D0326DC  3405C000   ORI A1, ZERO, -16384
56:                        break;
9D0326E0  0B40CA1B   J 0x9D03286C
9D0326E4  8FBF0014   LW RA, 20(SP)
57:                  
58:                     case 0x0A:
59:                        if (0x10 == reg)
9D0326E8  10400005   BEQ V0, ZERO, 0x9D032700
9D0326EC  24040001   ADDIU A0, ZERO, 1
60:                           mmc_bankvrom(1, 0x0400, value);
9D0326F0  0F40B1E8   JAL mmc_bankvrom
9D0326F4  24050400   ADDIU A1, ZERO, 1024
9D0326F8  0B40CA1B   J 0x9D03286C
9D0326FC  8FBF0014   LW RA, 20(SP)
61:                        else
62:                           mmc_bankvrom(1, 0x0000, value);
9D032700  0F40B1E8   JAL mmc_bankvrom
9D032704  00002821   ADDU A1, ZERO, ZERO
63:                        break;
64:                  
65:                     case 0x0B:
66:                        if (0x10 == reg)
9D032710  10400005   BEQ V0, ZERO, 0x9D032728
9D032714  24040001   ADDIU A0, ZERO, 1
67:                           mmc_bankvrom(1, 0x0C00, value);
9D032718  0F40B1E8   JAL mmc_bankvrom
9D03271C  24050C00   ADDIU A1, ZERO, 3072
9D032720  0B40CA1B   J 0x9D03286C
9D032724  8FBF0014   LW RA, 20(SP)
68:                        else
69:                           mmc_bankvrom(1, 0x0800, value);
9D032728  0F40B1E8   JAL mmc_bankvrom
9D03272C  24050800   ADDIU A1, ZERO, 2048
70:                        break;
71:                  
72:                     case 0x0C:
73:                        if (0x10 == reg)
9D032738  10400005   BEQ V0, ZERO, 0x9D032750
9D03273C  24040001   ADDIU A0, ZERO, 1
74:                           mmc_bankvrom(1, 0x1400, value);
9D032740  0F40B1E8   JAL mmc_bankvrom
9D032744  24051400   ADDIU A1, ZERO, 5120
9D032748  0B40CA1B   J 0x9D03286C
9D03274C  8FBF0014   LW RA, 20(SP)
75:                        else
76:                           mmc_bankvrom(1, 0x1000, value);
9D032750  0F40B1E8   JAL mmc_bankvrom
9D032754  24051000   ADDIU A1, ZERO, 4096
77:                        break;
78:                  
79:                     case 0x0D:
80:                        if (0x10 == reg)
9D032760  10400005   BEQ V0, ZERO, 0x9D032778
9D032764  24040001   ADDIU A0, ZERO, 1
81:                           mmc_bankvrom(1, 0x1C00, value);
9D032768  0F40B1E8   JAL mmc_bankvrom
9D03276C  24051C00   ADDIU A1, ZERO, 7168
9D032770  0B40CA1B   J 0x9D03286C
9D032774  8FBF0014   LW RA, 20(SP)
82:                        else
83:                           mmc_bankvrom(1, 0x1800, value);
9D032778  0F40B1E8   JAL mmc_bankvrom
9D03277C  24051800   ADDIU A1, ZERO, 6144
84:                        break;
85:                  
86:                     case 0x0E:
87:                        if (0x10 == reg)
9D032788  10400004   BEQ V0, ZERO, 0x9D03279C
9D03278C  30A60003   ANDI A2, A1, 3
88:                        {
89:                           irq.latch = value;
9D032790  3C02A001   LUI V0, -24575
9D032794  0B40CA1A   J 0x9D032868
9D032798  AC45B8A8   SW A1, -18264(V0)
90:                        }
91:                        else
92:                        {
93:                           switch (value & 3)
9D03279C  24020001   ADDIU V0, ZERO, 1
9D0327A0  10C2000F   BEQ A2, V0, 0x9D0327E0
9D0327A4  00002021   ADDU A0, ZERO, ZERO
9D0327A8  10C00007   BEQ A2, ZERO, 0x9D0327C8
9D0327AC  24020002   ADDIU V0, ZERO, 2
9D0327B0  10C20011   BEQ A2, V0, 0x9D0327F8
9D0327B4  24020003   ADDIU V0, ZERO, 3
9D0327B8  10C20015   BEQ A2, V0, 0x9D032810
9D0327BC  24040001   ADDIU A0, ZERO, 1
94:                           {
95:                           case 0:
96:                              ppu_mirror(0, 1, 0, 1); /* vertical */
9D0327C8  24050001   ADDIU A1, ZERO, 1
9D0327CC  00003021   ADDU A2, ZERO, ZERO
9D0327D0  0F406128   JAL ppu_mirror
9D0327D4  24070001   ADDIU A3, ZERO, 1
97:                              break;
9D0327D8  0B40CA1B   J 0x9D03286C
9D0327DC  8FBF0014   LW RA, 20(SP)
98:                  
99:                           case 1:
100:                             ppu_mirror(0, 0, 1, 1); /* horizontal */
9D0327E0  00002821   ADDU A1, ZERO, ZERO
9D0327E4  24060001   ADDIU A2, ZERO, 1
9D0327E8  0F406128   JAL ppu_mirror
9D0327EC  24070001   ADDIU A3, ZERO, 1
101:                             break;
9D0327F0  0B40CA1B   J 0x9D03286C
9D0327F4  8FBF0014   LW RA, 20(SP)
102:                 
103:                          case 2:
104:                             ppu_mirror(0, 0, 0, 0);
9D0327F8  00002821   ADDU A1, ZERO, ZERO
9D0327FC  00003021   ADDU A2, ZERO, ZERO
9D032800  0F406128   JAL ppu_mirror
9D032804  00003821   ADDU A3, ZERO, ZERO
105:                             break;
9D032808  0B40CA1B   J 0x9D03286C
9D03280C  8FBF0014   LW RA, 20(SP)
106:                 
107:                          case 3:
108:                             ppu_mirror(1, 1, 1, 1);
9D032810  24050001   ADDIU A1, ZERO, 1
9D032814  24060001   ADDIU A2, ZERO, 1
9D032818  0F406128   JAL ppu_mirror
9D03281C  24070001   ADDIU A3, ZERO, 1
109:                             break;
9D032820  0B40CA1B   J 0x9D03286C
9D032824  8FBF0014   LW RA, 20(SP)
110:                          }
111:                       }
112:                       break;
113:                 
114:                    case 0x0F:
115:                       if (0x10 == reg)
9D032828  10400005   BEQ V0, ZERO, 0x9D032840
9D03282C  3C02A001   LUI V0, -24575
116:                       {
117:                          irq.enabled = irq.wait_state;
9D032830  2442B8A4   ADDIU V0, V0, -18268
9D032834  8C430008   LW V1, 8(V0)
9D032838  0B40CA1A   J 0x9D032868
9D03283C  AC43000C   SW V1, 12(V0)
118:                       }
119:                       else
120:                       {
121:                          irq.wait_state = value & 0x01;
9D032840  2442B8A4   ADDIU V0, V0, -18268
9D032844  30A30001   ANDI V1, A1, 1
9D032848  AC430008   SW V1, 8(V0)
122:                          irq.enabled = (value & 0x02) ? true : false;
9D03284C  7CA60040   EXT A2, A1, 1, 1
123:                          if (true == irq.enabled)
9D032850  10C00005   BEQ A2, ZERO, 0x9D032868
9D032854  AC46000C   SW A2, 12(V0)
124:                             irq.counter = irq.latch;
9D032858  3C02A001   LUI V0, -24575
9D03285C  2443B8A4   ADDIU V1, V0, -18268
9D032860  8C630004   LW V1, 4(V1)
9D032864  AC43B8A4   SW V1, -18268(V0)
125:                       }
126:                       break;
127:                 
128:                    default:
129:                 #ifdef NOFRENDO_DEBUG
130:                       log_printf("unhandled vrc7 write: $%02X to $%04X\n", value, address);
131:                 #endif /* NOFRENDO_DEBUG */
132:                       break;
133:                    }
134:                 }
9D0326CC  0B40CA1B   J 0x9D03286C
9D0326D0  8FBF0014   LW RA, 20(SP)
9D032708  0B40CA1B   J 0x9D03286C
9D03270C  8FBF0014   LW RA, 20(SP)
9D032730  0B40CA1B   J 0x9D03286C
9D032734  8FBF0014   LW RA, 20(SP)
9D032758  0B40CA1B   J 0x9D03286C
9D03275C  8FBF0014   LW RA, 20(SP)
9D032780  0B40CA1B   J 0x9D03286C
9D032784  8FBF0014   LW RA, 20(SP)
9D0327C0  0B40CA1B   J 0x9D03286C
9D0327C4  8FBF0014   LW RA, 20(SP)
9D032868  8FBF0014   LW RA, 20(SP)
9D03286C  03E00008   JR RA
9D032870  27BD0018   ADDIU SP, SP, 24
135:                 
136:                 static void map85_hblank(int vblank)
137:                 {
9D03289C  27BDFFE8   ADDIU SP, SP, -24
9D0328A0  AFBF0014   SW RA, 20(SP)
138:                    UNUSED(vblank);
139:                 
140:                    if (irq.enabled)
9D032874  3C02A001   LUI V0, -24575
9D032878  8C42B8B0   LW V0, -18256(V0)
9D03287C  1040000F   BEQ V0, ZERO, 0x9D0328BC
9D032880  3C03A001   LUI V1, -24575
141:                    {
142:                       if (++irq.counter > 0xFF)
9D032884  8C62B8A4   LW V0, -18268(V1)
9D032888  24420001   ADDIU V0, V0, 1
9D03288C  AC62B8A4   SW V0, -18268(V1)
9D032890  28420100   SLTI V0, V0, 256
9D032894  14400009   BNE V0, ZERO, 0x9D0328BC
9D032898  00601021   ADDU V0, V1, ZERO
143:                       {
144:                          irq.counter = irq.latch;
9D0328A4  2463B8A4   ADDIU V1, V1, -18268
9D0328A8  8C630004   LW V1, 4(V1)
145:                          nes_irq();
9D0328AC  0F408A46   JAL nes_irq
9D0328B0  AC43B8A4   SW V1, -18268(V0)
146:                 
147:                          //return;
148:                       }
149:                       //irq.counter++;
150:                    }
151:                 }
9D0328B4  8FBF0014   LW RA, 20(SP)
9D0328B8  27BD0018   ADDIU SP, SP, 24
9D0328BC  03E00008   JR RA
9D0328C0  00000000   NOP
152:                 
153:                 static map_memwrite map85_memwrite[] =
154:                 {
155:                    { 0x8000, 0xFFFF, map85_write },
156:                    {     -1,     -1, NULL }
157:                 };
158:                 
159:                 static void map85_init(void)
160:                 {
9D0325E8  27BDFFE8   ADDIU SP, SP, -24
9D0325EC  AFBF0014   SW RA, 20(SP)
161:                    mmc_bankrom(16, 0x8000, 0);
9D0325F0  24040010   ADDIU A0, ZERO, 16
9D0325F4  34058000   ORI A1, ZERO, -32768
9D0325F8  0F40B246   JAL mmc_bankrom
9D0325FC  00003021   ADDU A2, ZERO, ZERO
162:                    mmc_bankrom(16, 0xC000, MMC_LASTBANK);
9D032600  24040010   ADDIU A0, ZERO, 16
9D032604  3405C000   ORI A1, ZERO, -16384
9D032608  0F40B246   JAL mmc_bankrom
9D03260C  2406FFFF   ADDIU A2, ZERO, -1
163:                    
164:                    mmc_bankvrom(8, 0x0000, 0);
9D032610  24040008   ADDIU A0, ZERO, 8
9D032614  00002821   ADDU A1, ZERO, ZERO
9D032618  0F40B1E8   JAL mmc_bankvrom
9D03261C  00003021   ADDU A2, ZERO, ZERO
165:                 
166:                    irq.counter = irq.latch = 0;
9D032620  3C03A001   LUI V1, -24575
9D032624  2462B8A4   ADDIU V0, V1, -18268
9D032628  AC400004   SW ZERO, 4(V0)
9D03262C  AC60B8A4   SW ZERO, -18268(V1)
167:                    irq.wait_state = 0;
9D032630  AC400008   SW ZERO, 8(V0)
168:                    irq.enabled = false;
9D032634  AC40000C   SW ZERO, 12(V0)
169:                 }
9D032638  8FBF0014   LW RA, 20(SP)
9D03263C  03E00008   JR RA
9D032640  27BD0018   ADDIU SP, SP, 24
170:                 
171:                 mapintf_t map85_intf = 
172:                 {
173:                    85, /* mapper number */
174:                    "Konami VRC7", /* mapper name */
175:                    map85_init, /* init routine */
176:                    NULL, /* vblank callback */
177:                    map85_hblank, /* hblank callback */
178:                    NULL, /* get state (snss) */
179:                    NULL, /* set state (snss) */
180:                    NULL, /* memory read structure */
181:                    map85_memwrite, /* memory write structure */
182:                    NULL
183:                 };
184:                 
185:                 /*
186:                 ** $Log: map085.c,v $
187:                 ** Revision 1.3  2001/05/06 01:42:03  neil
188:                 ** boooo
189:                 **
190:                 ** Revision 1.2  2001/04/27 14:37:11  neil
191:                 ** wheeee
192:                 **
193:                 ** Revision 1.1  2001/04/27 12:54:40  neil
194:                 ** blah
195:                 **
196:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
197:                 ** initial
198:                 **
199:                 ** Revision 1.1  2000/10/24 12:19:33  matt
200:                 ** changed directory structure
201:                 **
202:                 ** Revision 1.10  2000/10/22 19:17:46  matt
203:                 ** mapper cleanups galore
204:                 **
205:                 ** Revision 1.9  2000/10/22 15:03:14  matt
206:                 ** simplified mirroring
207:                 **
208:                 ** Revision 1.8  2000/10/21 19:33:38  matt
209:                 ** many more cleanups
210:                 **
211:                 ** Revision 1.7  2000/10/10 13:58:17  matt
212:                 ** stroustrup squeezing his way in the door
213:                 **
214:                 ** Revision 1.6  2000/08/16 02:50:11  matt
215:                 ** random mapper cleanups
216:                 **
217:                 ** Revision 1.5  2000/07/23 14:37:21  matt
218:                 ** added a break statement
219:                 **
220:                 ** Revision 1.4  2000/07/15 23:52:19  matt
221:                 ** rounded out a bunch more mapper interfaces
222:                 **
223:                 ** Revision 1.3  2000/07/10 13:51:25  matt
224:                 ** using generic nes_irq() routine now
225:                 **
226:                 ** Revision 1.2  2000/07/10 05:29:03  matt
227:                 ** cleaned up some mirroring issues
228:                 **
229:                 ** Revision 1.1  2000/07/06 02:47:47  matt
230:                 ** initial revision
231:                 **
232:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map079.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map78.c
21:                  **
22:                  ** mapper 78 interface
23:                  ** $Id: map079.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  
29:                  /* mapper 79: NINA-03/06 */
30:                  static void map79_write(uint32 address, uint8 value)
31:                  {
9D03A7A8  27BDFFE8   ADDIU SP, SP, -24
9D03A7AC  AFBF0014   SW RA, 20(SP)
9D03A7B0  AFB00010   SW S0, 16(SP)
9D03A7B4  00A08021   ADDU S0, A1, ZERO
32:                     if ((address & 0x5100) == 0x4100)
9D03A798  30845100   ANDI A0, A0, 20736
9D03A79C  24024100   ADDIU V0, ZERO, 16640
9D03A7A0  1482000F   BNE A0, V0, 0x9D03A7E0
9D03A7A4  24040020   ADDIU A0, ZERO, 32
33:                     {
34:                        mmc_bankrom(32, 0x8000, (value >> 3) & 1);
9D03A7B8  34058000   ORI A1, ZERO, -32768
9D03A7BC  0F40B246   JAL mmc_bankrom
9D03A7C0  7E0600C0   EXT A2, S0, 3, 1
35:                        mmc_bankvrom(8, 0x0000, value & 7);
9D03A7C4  24040008   ADDIU A0, ZERO, 8
9D03A7C8  00002821   ADDU A1, ZERO, ZERO
9D03A7CC  0F40B1E8   JAL mmc_bankvrom
9D03A7D0  32060007   ANDI A2, S0, 7
36:                     }
37:                  }
9D03A7D4  8FBF0014   LW RA, 20(SP)
9D03A7D8  8FB00010   LW S0, 16(SP)
9D03A7DC  27BD0018   ADDIU SP, SP, 24
9D03A7E0  03E00008   JR RA
9D03A7E4  00000000   NOP
38:                  
39:                  static void map79_init(void)
40:                  {
9D03A7E8  27BDFFE8   ADDIU SP, SP, -24
9D03A7EC  AFBF0014   SW RA, 20(SP)
41:                     mmc_bankrom(32, 0x8000, 0);
9D03A7F0  24040020   ADDIU A0, ZERO, 32
9D03A7F4  34058000   ORI A1, ZERO, -32768
9D03A7F8  0F40B246   JAL mmc_bankrom
9D03A7FC  00003021   ADDU A2, ZERO, ZERO
42:                     mmc_bankvrom(8, 0x0000, 0);
9D03A800  24040008   ADDIU A0, ZERO, 8
9D03A804  00002821   ADDU A1, ZERO, ZERO
9D03A808  0F40B1E8   JAL mmc_bankvrom
9D03A80C  00003021   ADDU A2, ZERO, ZERO
43:                  }
9D03A810  8FBF0014   LW RA, 20(SP)
9D03A814  03E00008   JR RA
9D03A818  27BD0018   ADDIU SP, SP, 24
44:                  
45:                  static map_memwrite map79_memwrite[] =
46:                  {
47:                     { 0x4100, 0x5FFF, map79_write }, /* ????? incorrect range ??? */
48:                     {     -1,     -1, NULL }
49:                  };
50:                  
51:                  mapintf_t map79_intf =
52:                  {
53:                     79, /* mapper number */
54:                     "NINA-03/06", /* mapper name */
55:                     map79_init, /* init routine */
56:                     NULL, /* vblank callback */
57:                     NULL, /* hblank callback */
58:                     NULL, /* get state (snss) */
59:                     NULL, /* set state (snss) */
60:                     NULL, /* memory read structure */
61:                     map79_memwrite, /* memory write structure */
62:                     NULL /* external sound device */
63:                  };
64:                  
65:                  /*
66:                  ** $Log: map079.c,v $
67:                  ** Revision 1.2  2001/04/27 14:37:11  neil
68:                  ** wheeee
69:                  **
70:                  ** Revision 1.1  2001/04/27 12:54:40  neil
71:                  ** blah
72:                  **
73:                  ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
74:                  ** initial
75:                  **
76:                  ** Revision 1.1  2000/10/24 12:19:33  matt
77:                  ** changed directory structure
78:                  **
79:                  ** Revision 1.4  2000/10/22 19:17:47  matt
80:                  ** mapper cleanups galore
81:                  **
82:                  ** Revision 1.3  2000/10/21 19:33:38  matt
83:                  ** many more cleanups
84:                  **
85:                  ** Revision 1.2  2000/07/06 02:48:43  matt
86:                  ** clearly labelled structure members
87:                  **
88:                  ** Revision 1.1  2000/07/06 01:01:56  matt
89:                  ** initial revision
90:                  **
91:                  */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map078.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map78.c
21:                  **
22:                  ** mapper 78 interface
23:                  ** $Id: map078.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes_ppu.h>
29:                  
30:                  /* mapper 78: Holy Diver, Cosmo Carrier */
31:                  /* ($8000-$FFFF) D2-D0 = switch $8000-$BFFF */
32:                  /* ($8000-$FFFF) D7-D4 = switch PPU $0000-$1FFF */
33:                  /* ($8000-$FFFF) D3 = switch mirroring */
34:                  static void map78_write(uint32 address, uint8 value)
35:                  {
9D039BCC  27BDFFE8   ADDIU SP, SP, -24
9D039BD0  AFBF0014   SW RA, 20(SP)
9D039BD4  AFB00010   SW S0, 16(SP)
9D039BD8  00A08021   ADDU S0, A1, ZERO
36:                     UNUSED(address);
37:                  
38:                     mmc_bankrom(16, 0x8000, value & 7);
9D039BDC  24040010   ADDIU A0, ZERO, 16
9D039BE0  34058000   ORI A1, ZERO, -32768
9D039BE4  0F40B246   JAL mmc_bankrom
9D039BE8  32060007   ANDI A2, S0, 7
39:                     mmc_bankvrom(8, 0x0000, (value >> 4) & 0x0F);
9D039BEC  24040008   ADDIU A0, ZERO, 8
9D039BF0  00002821   ADDU A1, ZERO, ZERO
9D039BF4  0F40B1E8   JAL mmc_bankvrom
9D039BF8  00103102   SRL A2, S0, 4
40:                  
41:                     /* Ugh! Same abuse of the 4-screen bit as with Mapper #70 */
42:                     if (mmc_getinfo()->flags & ROM_FLAG_FOURSCREEN)
9D039BFC  0F40B1DC   JAL mmc_getinfo
9D039C00  00000000   NOP
9D039C04  90420028   LBU V0, 40(V0)
9D039C08  30420004   ANDI V0, V0, 4
9D039C0C  304200FF   ANDI V0, V0, 255
9D039C10  10400011   BEQ V0, ZERO, .LBB2
9D039C14  7E0700C0   EXT A3, S0, 3, 1
43:                     {
44:                        if (value & 0x08)
9D039C18  32100008   ANDI S0, S0, 8
9D039C1C  321000FF   ANDI S0, S0, 255
9D039C20  12000007   BEQ S0, ZERO, 0x9D039C40
9D039C24  00002021   ADDU A0, ZERO, ZERO
45:                           ppu_mirror(0, 1, 0, 1); /* vert */
9D039C28  24050001   ADDIU A1, ZERO, 1
9D039C2C  00003021   ADDU A2, ZERO, ZERO
9D039C30  0F406128   JAL ppu_mirror
9D039C34  24070001   ADDIU A3, ZERO, 1
9D039C38  0B40E71B   J 0x9D039C6C
9D039C3C  8FBF0014   LW RA, 20(SP)
46:                        else
47:                           ppu_mirror(0, 0, 1, 1); /* horiz */
9D039C40  00002821   ADDU A1, ZERO, ZERO
9D039C44  24060001   ADDIU A2, ZERO, 1
9D039C48  0F406128   JAL ppu_mirror
9D039C4C  24070001   ADDIU A3, ZERO, 1
48:                     }
49:                     else
50:                     {
51:                        int mirror = (value >> 3) & 1;
52:                        ppu_mirror(mirror, mirror, mirror, mirror);
9D039C58  00E02021   ADDU A0, A3, ZERO
9D039C5C  00E02821   ADDU A1, A3, ZERO
9D039C60  0F406128   JAL ppu_mirror
9D039C64  00E03021   ADDU A2, A3, ZERO
53:                     }
54:                  }
9D039C50  0B40E71B   J 0x9D039C6C
9D039C54  8FBF0014   LW RA, 20(SP)
9D039C68  8FBF0014   LW RA, 20(SP)
9D039C6C  8FB00010   LW S0, 16(SP)
9D039C70  03E00008   JR RA
9D039C74  27BD0018   ADDIU SP, SP, 24
55:                  
56:                  static map_memwrite map78_memwrite[] =
57:                  {
58:                     { 0x8000, 0xFFFF, map78_write },
59:                     {     -1,     -1, NULL }
60:                  };
61:                  
62:                  mapintf_t map78_intf =
63:                  {
64:                     78, /* mapper number */
65:                     "Mapper 78", /* mapper name */
66:                     NULL, /* init routine */
67:                     NULL, /* vblank callback */
68:                     NULL, /* hblank callback */
69:                     NULL, /* get state (snss) */
70:                     NULL, /* set state (snss) */
71:                     NULL, /* memory read structure */
72:                     map78_memwrite, /* memory write structure */
73:                     NULL /* external sound device */
74:                  };
75:                  
76:                  /*
77:                  ** $Log: map078.c,v $
78:                  ** Revision 1.2  2001/04/27 14:37:11  neil
79:                  ** wheeee
80:                  **
81:                  ** Revision 1.1  2001/04/27 12:54:40  neil
82:                  ** blah
83:                  **
84:                  ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
85:                  ** initial
86:                  **
87:                  ** Revision 1.1  2000/10/24 12:19:33  matt
88:                  ** changed directory structure
89:                  **
90:                  ** Revision 1.7  2000/10/22 19:17:46  matt
91:                  ** mapper cleanups galore
92:                  **
93:                  ** Revision 1.6  2000/10/22 15:03:14  matt
94:                  ** simplified mirroring
95:                  **
96:                  ** Revision 1.5  2000/10/21 19:33:38  matt
97:                  ** many more cleanups
98:                  **
99:                  ** Revision 1.4  2000/08/16 02:50:11  matt
100:                 ** random mapper cleanups
101:                 **
102:                 ** Revision 1.3  2000/07/10 05:29:03  matt
103:                 ** cleaned up some mirroring issues
104:                 **
105:                 ** Revision 1.2  2000/07/06 02:48:43  matt
106:                 ** clearly labelled structure members
107:                 **
108:                 ** Revision 1.1  2000/07/06 01:01:56  matt
109:                 ** initial revision
110:                 **
111:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map075.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map75.c
21:                  **
22:                  ** mapper 75 interface
23:                  ** $Id: map075.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes_ppu.h>
29:                  
30:                  
31:                  static uint8 latch[2];
32:                  static uint8 hibits;
33:                  
34:                  /* mapper 75: Konami VRC1 */
35:                  static void map75_write(uint32 address, uint8 value)
36:                  {
9D035FA0  27BDFFE8   ADDIU SP, SP, -24
9D035FA4  AFBF0014   SW RA, 20(SP)
9D035FA8  AFB00010   SW S0, 16(SP)
37:                     switch ((address & 0xF000) >> 12)
9D035F8C  7C841B00   EXT A0, A0, 12, 4
9D035F90  2484FFF8   ADDIU A0, A0, -8
9D035F94  2C820008   SLTIU V0, A0, 8
9D035F98  1040005F   BEQ V0, ZERO, 0x9D036118
9D035F9C  00042080   SLL A0, A0, 2
9D035FAC  3C029D03   LUI V0, -25341
9D035FB0  24425FC4   ADDIU V0, V0, 24516
9D035FB4  00442021   ADDU A0, V0, A0
9D035FB8  8C820000   LW V0, 0(A0)
9D035FBC  00400008   JR V0
9D035FC0  00A08021   ADDU S0, A1, ZERO
38:                     {
39:                     case 0x8:
40:                        mmc_bankrom(8, 0x8000, value);
9D035FE4  24040008   ADDIU A0, ZERO, 8
9D035FE8  34058000   ORI A1, ZERO, -32768
9D035FEC  0F40B246   JAL mmc_bankrom
9D035FF0  02003021   ADDU A2, S0, ZERO
41:                        break;
9D035FF4  0B40D844   J 0x9D036110
9D035FF8  8FBF0014   LW RA, 20(SP)
42:                  
43:                     case 0x9:
44:                        hibits = (value & 0x06);
9D035FFC  30A20006   ANDI V0, A1, 6
9D036000  A382805C   SB V0, -32676(GP)
45:                        
46:                        mmc_bankvrom(4, 0x0000, ((hibits & 0x02) << 3) | latch[0]);
9D036004  30A60002   ANDI A2, A1, 2
9D036008  30C600FF   ANDI A2, A2, 255
9D03600C  000630C0   SLL A2, A2, 3
9D036010  93828060   LBU V0, -32672(GP)
9D036014  24040004   ADDIU A0, ZERO, 4
9D036018  00002821   ADDU A1, ZERO, ZERO
9D03601C  0F40B1E8   JAL mmc_bankvrom
9D036020  00C23025   OR A2, A2, V0
47:                        mmc_bankvrom(4, 0x1000, ((hibits & 0x04) << 2) | latch[1]);
9D036024  9386805C   LBU A2, -32676(GP)
9D036028  30C60004   ANDI A2, A2, 4
9D03602C  30C600FF   ANDI A2, A2, 255
9D036030  00063080   SLL A2, A2, 2
9D036034  93828061   LBU V0, -32671(GP)
9D036038  24040004   ADDIU A0, ZERO, 4
9D03603C  24051000   ADDIU A1, ZERO, 4096
9D036040  0F40B1E8   JAL mmc_bankvrom
9D036044  00C23025   OR A2, A2, V0
48:                  
49:                        if (value & 1)
9D036048  32100001   ANDI S0, S0, 1
9D03604C  12000007   BEQ S0, ZERO, 0x9D03606C
9D036050  00002021   ADDU A0, ZERO, ZERO
50:                           ppu_mirror(0, 1, 0, 1); /* vert */
9D036054  24050001   ADDIU A1, ZERO, 1
9D036058  00003021   ADDU A2, ZERO, ZERO
9D03605C  0F406128   JAL ppu_mirror
9D036060  24070001   ADDIU A3, ZERO, 1
9D036064  0B40D844   J 0x9D036110
9D036068  8FBF0014   LW RA, 20(SP)
51:                        else
52:                           ppu_mirror(0, 0, 1, 1); /* horiz */
9D03606C  00002821   ADDU A1, ZERO, ZERO
9D036070  24060001   ADDIU A2, ZERO, 1
9D036074  0F406128   JAL ppu_mirror
9D036078  24070001   ADDIU A3, ZERO, 1
53:                  
54:                        break;
55:                  
56:                     case 0xA:
57:                        mmc_bankrom(8, 0xA000, value);
9D036084  24040008   ADDIU A0, ZERO, 8
9D036088  3405A000   ORI A1, ZERO, -24576
9D03608C  0F40B246   JAL mmc_bankrom
9D036090  02003021   ADDU A2, S0, ZERO
58:                        break;
9D036094  0B40D844   J 0x9D036110
9D036098  8FBF0014   LW RA, 20(SP)
59:                  
60:                     case 0xC:
61:                        mmc_bankrom(8, 0xC000, value);
9D03609C  24040008   ADDIU A0, ZERO, 8
9D0360A0  3405C000   ORI A1, ZERO, -16384
9D0360A4  0F40B246   JAL mmc_bankrom
9D0360A8  02003021   ADDU A2, S0, ZERO
62:                        break;
9D0360AC  0B40D844   J 0x9D036110
9D0360B0  8FBF0014   LW RA, 20(SP)
63:                  
64:                     case 0xE:
65:                        latch[0] = (value & 0x0F);
9D0360B4  30B0000F   ANDI S0, A1, 15
9D0360B8  A3908060   SB S0, -32672(GP)
66:                        mmc_bankvrom(4, 0x0000, ((hibits & 0x02) << 3) | latch[0]);
9D0360BC  9386805C   LBU A2, -32676(GP)
9D0360C0  30C60002   ANDI A2, A2, 2
9D0360C4  30C600FF   ANDI A2, A2, 255
9D0360C8  000630C0   SLL A2, A2, 3
9D0360CC  24040004   ADDIU A0, ZERO, 4
9D0360D0  00002821   ADDU A1, ZERO, ZERO
9D0360D4  0F40B1E8   JAL mmc_bankvrom
9D0360D8  02063025   OR A2, S0, A2
67:                        break;
9D0360DC  0B40D844   J 0x9D036110
9D0360E0  8FBF0014   LW RA, 20(SP)
68:                  
69:                     case 0xF:
70:                        latch[1] = (value & 0x0F);
9D0360E4  30B0000F   ANDI S0, A1, 15
9D0360E8  A3908061   SB S0, -32671(GP)
71:                        mmc_bankvrom(4, 0x1000, ((hibits & 0x04) << 2) | latch[1]);
9D0360EC  9386805C   LBU A2, -32676(GP)
9D0360F0  30C60004   ANDI A2, A2, 4
9D0360F4  30C600FF   ANDI A2, A2, 255
9D0360F8  00063080   SLL A2, A2, 2
9D0360FC  24040004   ADDIU A0, ZERO, 4
9D036100  24051000   ADDIU A1, ZERO, 4096
9D036104  0F40B1E8   JAL mmc_bankvrom
9D036108  02063025   OR A2, S0, A2
72:                        break;
73:                  
74:                     default:
75:                        break;
76:                     }
77:                  }
9D03607C  0B40D844   J 0x9D036110
9D036080  8FBF0014   LW RA, 20(SP)
9D03610C  8FBF0014   LW RA, 20(SP)
9D036110  8FB00010   LW S0, 16(SP)
9D036114  27BD0018   ADDIU SP, SP, 24
9D036118  03E00008   JR RA
9D03611C  00000000   NOP
78:                  
79:                  static map_memwrite map75_memwrite[] =
80:                  {
81:                     { 0x8000, 0xFFFF, map75_write },
82:                     {     -1,     -1, NULL }
83:                  };
84:                  
85:                  mapintf_t map75_intf =
86:                  {
87:                     75, /* mapper number */
88:                     "Konami VRC1", /* mapper name */
89:                     NULL, /* init routine */
90:                     NULL, /* vblank callback */
91:                     NULL, /* hblank callback */
92:                     NULL, /* get state (snss) */
93:                     NULL, /* set state (snss) */
94:                     NULL, /* memory read structure */
95:                     map75_memwrite, /* memory write structure */
96:                     NULL /* external sound device */
97:                  };
98:                  
99:                  /*
100:                 ** $Log: map075.c,v $
101:                 ** Revision 1.2  2001/04/27 14:37:11  neil
102:                 ** wheeee
103:                 **
104:                 ** Revision 1.1  2001/04/27 12:54:40  neil
105:                 ** blah
106:                 **
107:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
108:                 ** initial
109:                 **
110:                 ** Revision 1.1  2000/10/24 12:19:33  matt
111:                 ** changed directory structure
112:                 **
113:                 ** Revision 1.6  2000/10/22 19:17:46  matt
114:                 ** mapper cleanups galore
115:                 **
116:                 ** Revision 1.5  2000/10/22 15:03:14  matt
117:                 ** simplified mirroring
118:                 **
119:                 ** Revision 1.4  2000/10/21 19:33:38  matt
120:                 ** many more cleanups
121:                 **
122:                 ** Revision 1.3  2000/07/10 05:29:03  matt
123:                 ** cleaned up some mirroring issues
124:                 **
125:                 ** Revision 1.2  2000/07/06 02:48:43  matt
126:                 ** clearly labelled structure members
127:                 **
128:                 ** Revision 1.1  2000/07/06 01:01:56  matt
129:                 ** initial revision
130:                 **
131:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map073.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map073.c
21:                  **
22:                  ** Mapper #73 (Konami VRC3)
23:                  ** Implementation by Firebug
24:                  ** $Id: map073.c,v 1.2 2001/04/27 14:37:11 neil Exp $
25:                  **
26:                  */
27:                  
28:                  #include <noftypes.h>
29:                  #include <nes_mmc.h>
30:                  #include <nes.h>
31:                  #include <libsnss.h>
32:                  #include <log.h>
33:                  
34:                  static struct
35:                  {
36:                    bool enabled;
37:                    uint32 counter;
38:                  } irq;
39:                  
40:                  /**************************/
41:                  /* Mapper #73: Salamander */
42:                  /**************************/
43:                  static void map73_init (void)
44:                  {
45:                    /* Turn off IRQs */
46:                    irq.enabled = false;
9D036B5C  AF80808C   SW ZERO, -32628(GP)
47:                    irq.counter = 0x0000;
9D036B60  03E00008   JR RA
9D036B64  AF808090   SW ZERO, -32624(GP)
48:                  
49:                    /* Done */
50:                    return;
51:                  }
52:                  
53:                  /****************************************/
54:                  /* Mapper #73 callback for IRQ handling */
55:                  /****************************************/
56:                  static void map73_hblank (int vblank)
57:                  {
9D036C74  27BDFFE8   ADDIU SP, SP, -24
9D036C78  AFBF0014   SW RA, 20(SP)
58:                     /* Counter is M2 based so it doesn't matter whether */
59:                     /* the PPU is in its VBlank period or not           */
60:                     UNUSED (vblank);
61:                  
62:                     /* Increment the counter if it is enabled and check for strike */
63:                     if (irq.enabled)
9D036C7C  8F82808C   LW V0, -32628(GP)
9D036C80  1040000A   BEQ V0, ZERO, 0x9D036CAC
9D036C84  8F828090   LW V0, -32624(GP)
64:                     {
65:                       /* Is there a constant for cycles per scanline? */
66:                       /* If so, someone ought to substitute it here   */
67:                       irq.counter = irq.counter + 114;
9D036C88  24420072   ADDIU V0, V0, 114
9D036C98  0B40DB2B   J 0x9D036CAC
9D036C9C  AF828090   SW V0, -32624(GP)
68:                  
69:                       /* Counter triggered on overflow into Q16 */
70:                       if (irq.counter & 0x10000)
9D036C8C  7C430400   EXT V1, V0, 16, 1
9D036C90  54600003   BNEL V1, ZERO, 0x9D036CA0
9D036C94  3042FFFF   ANDI V0, V0, -1
71:                       {
72:                         /* Clip to sixteen-bit word */
73:                         irq.counter &= 0xFFFF;
74:                  
75:                         /* Trigger the IRQ */
76:                         nes_irq ();
9D036CA0  0F408A46   JAL nes_irq
9D036CA4  AF828090   SW V0, -32624(GP)
77:                  
78:                         /* Shut off IRQ counter */
79:                         irq.enabled = false;
9D036CA8  AF80808C   SW ZERO, -32628(GP)
80:                       }
81:                     }
82:                  }
9D036CAC  8FBF0014   LW RA, 20(SP)
9D036CB0  03E00008   JR RA
9D036CB4  27BD0018   ADDIU SP, SP, 24
83:                  
84:                  /******************************************/
85:                  /* Mapper #73 write handler ($8000-$FFFF) */
86:                  /******************************************/
87:                  static void map73_write (uint32 address, uint8 value)
88:                  {
9D036B78  27BDFFE8   ADDIU SP, SP, -24
9D036B7C  AFBF0014   SW RA, 20(SP)
89:                    switch (address & 0xF000)
9D036B80  3084F000   ANDI A0, A0, -4096
9D036B84  3402A000   ORI V0, ZERO, -24576
9D036B88  10820020   BEQ A0, V0, 0x9D036C0C
9D036B8C  00A03021   ADDU A2, A1, ZERO
9D036B90  3402A001   ORI V0, ZERO, -24575
9D036B94  0082102B   SLTU V0, A0, V0
9D036B98  10400008   BEQ V0, ZERO, 0x9D036BBC
9D036B9C  3402C000   ORI V0, ZERO, -16384
9D036BA0  34028000   ORI V0, ZERO, -32768
9D036BA4  1082000D   BEQ A0, V0, 0x9D036BDC
9D036BA8  34029000   ORI V0, ZERO, -28672
9D036BAC  10820011   BEQ A0, V0, 0x9D036BF4
9D036BB0  27828090   ADDIU V0, GP, -32624
9D036BBC  10820020   BEQ A0, V0, 0x9D036C40
9D036BC0  3402F000   ORI V0, ZERO, -4096
9D036BC4  10820025   BEQ A0, V0, 0x9D036C5C
9D036BC8  3402B000   ORI V0, ZERO, -20480
9D036BCC  14820027   BNE A0, V0, 0x9D036C6C
9D036BD0  8FBF0014   LW RA, 20(SP)
90:                    {
91:                      case 0x8000: irq.counter &= 0xFFF0;
9D036BE0  8C430000   LW V1, 0(V0)
9D036BE4  3063FFF0   ANDI V1, V1, -16
92:                                   irq.counter |= (uint32) (value);
9D036BDC  27828090   ADDIU V0, GP, -32624
9D036BE8  00A33025   OR A2, A1, V1
93:                                   break;
9D036BEC  0B40DB1A   J .LVL5
9D036BF0  AC460000   SW A2, 0(V0)
94:                      case 0x9000: irq.counter &= 0xFF0F;
9D036BF8  8C430000   LW V1, 0(V0)
9D036BFC  3063FF0F   ANDI V1, V1, -241
95:                                   irq.counter |= (uint32) (value << 4);
9D036BF4  00053100   SLL A2, A1, 4
9D036C00  00C33025   OR A2, A2, V1
96:                                   break;
9D036C04  0B40DB1A   J .LVL5
9D036C08  AC460000   SW A2, 0(V0)
97:                      case 0xA000: irq.counter &= 0xF0FF;
9D036C14  8C430000   LW V1, 0(V0)
9D036C18  3063F0FF   ANDI V1, V1, -3841
98:                                   irq.counter |= (uint32) (value << 8);
9D036C0C  27828090   ADDIU V0, GP, -32624
9D036C10  00053200   SLL A2, A1, 8
9D036C1C  00C33025   OR A2, A2, V1
99:                                   break;
9D036C20  0B40DB1A   J .LVL5
9D036C24  AC460000   SW A2, 0(V0)
100:                     case 0xB000: irq.counter &= 0x0FFF;
9D036C2C  8C430000   LW V1, 0(V0)
9D036C30  30630FFF   ANDI V1, V1, 4095
101:                                  irq.counter |= (uint32) (value << 12);
9D036BD4  0B40DB0A   J 0x9D036C28
9D036BD8  27828090   ADDIU V0, GP, -32624
9D036C28  00053300   SLL A2, A1, 12
9D036C34  00C33025   OR A2, A2, V1
102:                                  break;
9D036C38  0B40DB1A   J .LVL5
9D036C3C  AC460000   SW A2, 0(V0)
103:                     case 0xC000: if (value & 0x02) irq.enabled = true;
9D036C40  30A60002   ANDI A2, A1, 2
9D036C44  30C600FF   ANDI A2, A2, 255
9D036C48  50C00007   BEQL A2, ZERO, .LVL5
9D036C4C  AF80808C   SW ZERO, -32628(GP)
9D036C50  24020001   ADDIU V0, ZERO, 1
9D036C54  0B40DB1A   J .LVL5
9D036C58  AF82808C   SW V0, -32628(GP)
104:                                  else              irq.enabled = false;
105:                                  break;
106:                     case 0xF000: mmc_bankrom (16, 0x8000, value);
9D036C5C  24040010   ADDIU A0, ZERO, 16
9D036C60  0F40B246   JAL mmc_bankrom
9D036C64  34058000   ORI A1, ZERO, -32768
107:                     default:     break;
108:                   }
109:                 
110:                   /* Done */
111:                   return;
112:                 }
9D036BB4  0B40DB1B   J 0x9D036C6C
9D036BB8  8FBF0014   LW RA, 20(SP)
9D036C68  8FBF0014   LW RA, 20(SP)
9D036C6C  03E00008   JR RA
9D036C70  27BD0018   ADDIU SP, SP, 24
113:                 
114:                 /****************************************************/
115:                 /* Shove extra mapper information into a SNSS block */
116:                 /****************************************************/
117:                 static void map73_setstate (SnssMapperBlock *state)
118:                 {
9D036B68  03E00008   JR RA
9D036B6C  00000000   NOP
119:                   /* TODO: Store SNSS information */
120:                   UNUSED (state);
121:                 
122:                   /* Done */
123:                   return;
124:                 }
125:                 
126:                 /*****************************************************/
127:                 /* Pull extra mapper information out of a SNSS block */
128:                 /*****************************************************/
129:                 static void map73_getstate (SnssMapperBlock *state)
130:                 {
9D036B70  03E00008   JR RA
9D036B74  00000000   NOP
131:                   /* TODO: Retrieve SNSS information */
132:                   UNUSED (state);
133:                 
134:                   /* Done */
135:                   return;
136:                 }
137:                 
138:                 static map_memwrite map73_memwrite [] =
139:                 {
140:                    { 0x8000, 0xFFFF, map73_write },
141:                    {     -1,     -1, NULL }
142:                 };
143:                 
144:                 mapintf_t map73_intf =
145:                 {
146:                    73,                               /* Mapper number */
147:                    "Konami VRC3",                    /* Mapper name */
148:                    map73_init,                       /* Initialization routine */
149:                    NULL,                             /* VBlank callback */
150:                    map73_hblank,                     /* HBlank callback */
151:                    map73_getstate,                   /* Get state (SNSS) */
152:                    map73_setstate,                   /* Set state (SNSS) */
153:                    NULL,                             /* Memory read structure */
154:                    map73_memwrite,                   /* Memory write structure */
155:                    NULL                              /* External sound device */
156:                 };
157:                 
158:                 /*
159:                 ** $Log: map073.c,v $
160:                 ** Revision 1.2  2001/04/27 14:37:11  neil
161:                 ** wheeee
162:                 **
163:                 ** Revision 1.1  2001/04/27 12:54:40  neil
164:                 ** blah
165:                 **
166:                 ** Revision 1.1  2001/04/27 10:57:41  neil
167:                 ** wheee
168:                 **
169:                 ** Revision 1.1  2000/12/30 06:35:05  firebug
170:                 ** Initial revision
171:                 **
172:                 **
173:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map070.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map70.c
21:                  **
22:                  ** mapper 70 interface
23:                  ** $Id: map070.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes_ppu.h>
29:                  
30:                  /* mapper 70: Arkanoid II, Kamen Rider Club, etc. */
31:                  /* ($8000-$FFFF) D6-D4 = switch $8000-$BFFF */
32:                  /* ($8000-$FFFF) D3-D0 = switch PPU $0000-$1FFF */
33:                  /* ($8000-$FFFF) D7 = switch mirroring */
34:                  static void map70_write(uint32 address, uint8 value)
35:                  {
9D039E7C  27BDFFE8   ADDIU SP, SP, -24
9D039E80  AFBF0014   SW RA, 20(SP)
9D039E84  AFB00010   SW S0, 16(SP)
9D039E88  00A08021   ADDU S0, A1, ZERO
36:                     UNUSED(address);
37:                  
38:                     mmc_bankrom(16, 0x8000, (value >> 4) & 0x07);
9D039E8C  24040010   ADDIU A0, ZERO, 16
9D039E90  34058000   ORI A1, ZERO, -32768
9D039E94  0F40B246   JAL mmc_bankrom
9D039E98  7E061100   EXT A2, S0, 4, 3
39:                     mmc_bankvrom(8, 0x0000, value & 0x0F);
9D039E9C  24040008   ADDIU A0, ZERO, 8
9D039EA0  00002821   ADDU A1, ZERO, ZERO
9D039EA4  0F40B1E8   JAL mmc_bankvrom
9D039EA8  3206000F   ANDI A2, S0, 15
40:                  
41:                     /* Argh! FanWen used the 4-screen bit to determine
42:                     ** whether the game uses D7 to switch between
43:                     ** horizontal and vertical mirroring, or between
44:                     ** one-screen mirroring from $2000 or $2400.
45:                     */
46:                     if (mmc_getinfo()->flags & ROM_FLAG_FOURSCREEN)
9D039EAC  0F40B1DC   JAL mmc_getinfo
9D039EB0  00000000   NOP
9D039EB4  90420028   LBU V0, 40(V0)
9D039EB8  30420004   ANDI V0, V0, 4
9D039EBC  304200FF   ANDI V0, V0, 255
9D039EC0  10400010   BEQ V0, ZERO, .LBB2
9D039EC4  001039C2   SRL A3, S0, 7
47:                     {
48:                        if (value & 0x80)
9D039EC8  7C108420   SEB S0, S0
9D039ECC  06010007   BGEZ S0, 0x9D039EEC
9D039ED0  00002021   ADDU A0, ZERO, ZERO
49:                           ppu_mirror(0, 0, 1, 1); /* horiz */
9D039ED4  00002821   ADDU A1, ZERO, ZERO
9D039ED8  24060001   ADDIU A2, ZERO, 1
9D039EDC  0F406128   JAL ppu_mirror
9D039EE0  24070001   ADDIU A3, ZERO, 1
9D039EE4  0B40E7C6   J 0x9D039F18
9D039EE8  8FBF0014   LW RA, 20(SP)
50:                        else
51:                           ppu_mirror(0, 1, 0, 1); /* vert */
9D039EEC  24050001   ADDIU A1, ZERO, 1
9D039EF0  00003021   ADDU A2, ZERO, ZERO
9D039EF4  0F406128   JAL ppu_mirror
9D039EF8  24070001   ADDIU A3, ZERO, 1
52:                     }
53:                     else
54:                     {
55:                        int mirror = (value & 0x80) >> 7;
56:                        ppu_mirror(mirror, mirror, mirror, mirror);
9D039F04  00E02021   ADDU A0, A3, ZERO
9D039F08  00E02821   ADDU A1, A3, ZERO
9D039F0C  0F406128   JAL ppu_mirror
9D039F10  00E03021   ADDU A2, A3, ZERO
57:                     }
58:                  }
9D039EFC  0B40E7C6   J 0x9D039F18
9D039F00  8FBF0014   LW RA, 20(SP)
9D039F14  8FBF0014   LW RA, 20(SP)
9D039F18  8FB00010   LW S0, 16(SP)
9D039F1C  03E00008   JR RA
9D039F20  27BD0018   ADDIU SP, SP, 24
59:                  
60:                  static map_memwrite map70_memwrite[] =
61:                  {
62:                     { 0x8000, 0xFFFF, map70_write },
63:                     {     -1,     -1, NULL }
64:                  };
65:                  
66:                  mapintf_t map70_intf =
67:                  {
68:                     70, /* mapper number */
69:                     "Mapper 70", /* mapper name */
70:                     NULL, /* init routine */
71:                     NULL, /* vblank callback */
72:                     NULL, /* hblank callback */
73:                     NULL, /* get state (snss) */
74:                     NULL, /* set state (snss) */
75:                     NULL, /* memory read structure */
76:                     map70_memwrite, /* memory write structure */
77:                     NULL /* external sound device */
78:                  };
79:                  
80:                  /*
81:                  ** $Log: map070.c,v $
82:                  ** Revision 1.2  2001/04/27 14:37:11  neil
83:                  ** wheeee
84:                  **
85:                  ** Revision 1.1  2001/04/27 12:54:40  neil
86:                  ** blah
87:                  **
88:                  ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
89:                  ** initial
90:                  **
91:                  ** Revision 1.1  2000/10/24 12:19:33  matt
92:                  ** changed directory structure
93:                  **
94:                  ** Revision 1.7  2000/10/22 19:17:46  matt
95:                  ** mapper cleanups galore
96:                  **
97:                  ** Revision 1.6  2000/10/22 15:03:13  matt
98:                  ** simplified mirroring
99:                  **
100:                 ** Revision 1.5  2000/10/21 19:33:38  matt
101:                 ** many more cleanups
102:                 **
103:                 ** Revision 1.4  2000/08/16 02:50:11  matt
104:                 ** random mapper cleanups
105:                 **
106:                 ** Revision 1.3  2000/07/10 05:29:03  matt
107:                 ** cleaned up some mirroring issues
108:                 **
109:                 ** Revision 1.2  2000/07/06 02:48:43  matt
110:                 ** clearly labelled structure members
111:                 **
112:                 ** Revision 1.1  2000/07/06 01:01:56  matt
113:                 ** initial revision
114:                 **
115:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map066.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map66.c
21:                  **
22:                  ** mapper 66 interface
23:                  ** $Id: map066.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  
29:                  /* mapper 66: GNROM */
30:                  static void map66_write(uint32 address, uint8 value)
31:                  {
9D03AC88  27BDFFE8   ADDIU SP, SP, -24
9D03AC8C  AFBF0014   SW RA, 20(SP)
9D03AC90  AFB00010   SW S0, 16(SP)
9D03AC94  00A08021   ADDU S0, A1, ZERO
32:                     UNUSED(address);
33:                  
34:                     mmc_bankrom(32, 0x8000, (value >> 4) & 3);
9D03AC98  24040020   ADDIU A0, ZERO, 32
9D03AC9C  34058000   ORI A1, ZERO, -32768
9D03ACA0  0F40B246   JAL mmc_bankrom
9D03ACA4  7E060900   EXT A2, S0, 4, 2
35:                     mmc_bankvrom(8, 0x0000, value & 3);
9D03ACA8  24040008   ADDIU A0, ZERO, 8
9D03ACAC  00002821   ADDU A1, ZERO, ZERO
9D03ACB0  0F40B1E8   JAL mmc_bankvrom
9D03ACB4  32060003   ANDI A2, S0, 3
36:                  }
9D03ACB8  8FBF0014   LW RA, 20(SP)
9D03ACBC  8FB00010   LW S0, 16(SP)
9D03ACC0  03E00008   JR RA
9D03ACC4  27BD0018   ADDIU SP, SP, 24
37:                  
38:                  static void map66_init(void)
39:                  {
9D03ACC8  27BDFFE8   ADDIU SP, SP, -24
9D03ACCC  AFBF0014   SW RA, 20(SP)
40:                     mmc_bankrom(32, 0x8000, 0);
9D03ACD0  24040020   ADDIU A0, ZERO, 32
9D03ACD4  34058000   ORI A1, ZERO, -32768
9D03ACD8  0F40B246   JAL mmc_bankrom
9D03ACDC  00003021   ADDU A2, ZERO, ZERO
41:                     mmc_bankvrom(8, 0x0000, 0);
9D03ACE0  24040008   ADDIU A0, ZERO, 8
9D03ACE4  00002821   ADDU A1, ZERO, ZERO
9D03ACE8  0F40B1E8   JAL mmc_bankvrom
9D03ACEC  00003021   ADDU A2, ZERO, ZERO
42:                  }
9D03ACF0  8FBF0014   LW RA, 20(SP)
9D03ACF4  03E00008   JR RA
9D03ACF8  27BD0018   ADDIU SP, SP, 24
43:                  
44:                  
45:                  static map_memwrite map66_memwrite[] =
46:                  {
47:                     { 0x8000, 0xFFFF, map66_write },
48:                     {     -1,     -1, NULL }
49:                  };
50:                  
51:                  mapintf_t map66_intf =
52:                  {
53:                     66, /* mapper number */
54:                     "GNROM", /* mapper name */
55:                     map66_init, /* init routine */
56:                     NULL, /* vblank callback */
57:                     NULL, /* hblank callback */
58:                     NULL, /* get state (snss) */
59:                     NULL, /* set state (snss) */
60:                     NULL, /* memory read structure */
61:                     map66_memwrite, /* memory write structure */
62:                     NULL /* external sound device */
63:                  };
64:                  
65:                  /*
66:                  ** $Log: map066.c,v $
67:                  ** Revision 1.2  2001/04/27 14:37:11  neil
68:                  ** wheeee
69:                  **
70:                  ** Revision 1.1  2001/04/27 12:54:40  neil
71:                  ** blah
72:                  **
73:                  ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
74:                  ** initial
75:                  **
76:                  ** Revision 1.1  2000/10/24 12:19:33  matt
77:                  ** changed directory structure
78:                  **
79:                  ** Revision 1.5  2000/10/22 19:17:46  matt
80:                  ** mapper cleanups galore
81:                  **
82:                  ** Revision 1.4  2000/10/21 19:33:38  matt
83:                  ** many more cleanups
84:                  **
85:                  ** Revision 1.3  2000/08/16 02:50:11  matt
86:                  ** random mapper cleanups
87:                  **
88:                  ** Revision 1.2  2000/07/06 02:48:43  matt
89:                  ** clearly labelled structure members
90:                  **
91:                  ** Revision 1.1  2000/07/05 05:05:18  matt
92:                  ** initial revision
93:                  **
94:                  */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map065.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map65.c
21:                  **
22:                  ** mapper 65 interface
23:                  ** $Id: map065.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes_ppu.h>
29:                  
30:                  static struct
31:                  {
32:                     int counter;
33:                     bool enabled;
34:                     int cycles;
35:                     uint8 low, high;
36:                  } irq;
37:                  
38:                  static void map65_init(void)
39:                  {
40:                     irq.counter = 0;
9D037578  3C02A001   LUI V0, -24575
9D03757C  AC40B894   SW ZERO, -18284(V0)
41:                     irq.enabled = false;
9D037580  2442B894   ADDIU V0, V0, -18284
9D037584  AC400004   SW ZERO, 4(V0)
42:                     irq.low = irq.high = 0;
9D037588  A040000D   SB ZERO, 13(V0)
9D03758C  A040000C   SB ZERO, 12(V0)
43:                     irq.cycles = 0;
9D037590  03E00008   JR RA
9D037594  AC400008   SW ZERO, 8(V0)
44:                  }
45:                  
46:                  /* TODO: shouldn't there be some kind of HBlank callback??? */
47:                  
48:                  /* mapper 65: Irem H-3001*/
49:                  static void map65_write(uint32 address, uint8 value)
50:                  {
9D037598  27BDFFE8   ADDIU SP, SP, -24
9D03759C  AFBF0014   SW RA, 20(SP)
9D0375A0  00A03021   ADDU A2, A1, ZERO
51:                     int range = address & 0xF000;
9D0375A4  3082F000   ANDI V0, A0, -4096
52:                     int reg = address & 7;
53:                  
54:                     switch (range)
9D0375A8  3403A000   ORI V1, ZERO, -24576
9D0375AC  10430011   BEQ V0, V1, 0x9D0375F4
9D0375B0  30850007   ANDI A1, A0, 7
9D0375B4  3403A001   ORI V1, ZERO, -24575
9D0375B8  0043182A   SLT V1, V0, V1
9D0375BC  10600008   BEQ V1, ZERO, 0x9D0375E0
9D0375C0  3403B000   ORI V1, ZERO, -20480
9D0375C4  34038000   ORI V1, ZERO, -32768
9D0375C8  1043000A   BEQ V0, V1, 0x9D0375F4
9D0375CC  34039000   ORI V1, ZERO, -28672
9D0375D0  10430011   BEQ V0, V1, 0x9D037618
9D0375D4  24020005   ADDIU V0, ZERO, 5
9D0375E0  10430009   BEQ V0, V1, 0x9D037608
9D0375E4  24040001   ADDIU A0, ZERO, 1
9D0375E8  3403C000   ORI V1, ZERO, -16384
9D0375EC  54430029   BNEL V0, V1, 0x9D037694
9D0375F0  8FBF0014   LW RA, 20(SP)
55:                     {
56:                     case 0x8000:
57:                     case 0xA000:
58:                     case 0xC000:
59:                        mmc_bankrom(8, range, value);
9D0375F4  24040008   ADDIU A0, ZERO, 8
9D0375F8  0F40B246   JAL mmc_bankrom
9D0375FC  00402821   ADDU A1, V0, ZERO
60:                        break;
9D037600  0B40DDA5   J 0x9D037694
9D037604  8FBF0014   LW RA, 20(SP)
61:                  
62:                     case 0xB000:
63:                        mmc_bankvrom(1, reg << 10, value);
9D037608  0F40B1E8   JAL mmc_bankvrom
9D03760C  00052A80   SLL A1, A1, 10
64:                        break;
9D037610  0B40DDA5   J 0x9D037694
9D037614  8FBF0014   LW RA, 20(SP)
65:                  
66:                     case 0x9000:
67:                        switch (reg)
9D037618  10A2000A   BEQ A1, V0, 0x9D037644
9D03761C  24020006   ADDIU V0, ZERO, 6
9D037620  10A20012   BEQ A1, V0, 0x9D03766C
9D037624  24020004   ADDIU V0, ZERO, 4
9D037628  14A2001A   BNE A1, V0, 0x9D037694
9D03762C  8FBF0014   LW RA, 20(SP)
68:                        {
69:                        case 4:
70:                           irq.enabled = (value & 0x01) ? false : true;
9D037630  38C60001   XORI A2, A2, 1
9D037634  30C60001   ANDI A2, A2, 1
9D037638  3C02A001   LUI V0, -24575
71:                           break;
9D03763C  0B40DDA4   J 0x9D037690
9D037640  AC46B898   SW A2, -18280(V0)
72:                  
73:                        case 5:
74:                           irq.high = value;
9D037644  3C03A001   LUI V1, -24575
9D037648  2462B894   ADDIU V0, V1, -18284
9D03764C  A046000D   SB A2, 13(V0)
75:                           irq.cycles = (irq.high << 8) | irq.low;
9D037650  00063200   SLL A2, A2, 8
9D037654  9044000C   LBU A0, 12(V0)
9D037658  00C43025   OR A2, A2, A0
9D03765C  AC460008   SW A2, 8(V0)
76:                           irq.counter = (uint8)(irq.cycles / 128);
9D037660  7CC639C0   EXT A2, A2, 7, 8
77:                           break;
9D037664  0B40DDA4   J 0x9D037690
9D037668  AC66B894   SW A2, -18284(V1)
78:                  
79:                        case 6:
80:                           irq.low = value;
9D03766C  3C03A001   LUI V1, -24575
9D037670  2462B894   ADDIU V0, V1, -18284
9D037674  A046000C   SB A2, 12(V0)
81:                           irq.cycles = (irq.high << 8) | irq.low;
9D037678  9044000D   LBU A0, 13(V0)
9D03767C  00042200   SLL A0, A0, 8
9D037680  00C43025   OR A2, A2, A0
9D037684  AC460008   SW A2, 8(V0)
82:                           irq.counter = (uint8)(irq.cycles / 128);
9D037688  7CC639C0   EXT A2, A2, 7, 8
9D03768C  AC66B894   SW A2, -18284(V1)
83:                           break;
84:                  
85:                        default:
86:                           break;
87:                        }
88:                        break;
89:                  
90:                     default:
91:                        break;
92:                     }
93:                  }
9D0375D8  0B40DDA5   J 0x9D037694
9D0375DC  8FBF0014   LW RA, 20(SP)
9D037690  8FBF0014   LW RA, 20(SP)
9D037694  03E00008   JR RA
9D037698  27BD0018   ADDIU SP, SP, 24
94:                  
95:                  static map_memwrite map65_memwrite[] =
96:                  {
97:                     { 0x8000, 0xFFFF, map65_write },
98:                     {     -1,     -1, NULL }
99:                  };
100:                 
101:                 mapintf_t map65_intf =
102:                 {
103:                    65, /* mapper number */
104:                    "Irem H-3001", /* mapper name */
105:                    map65_init, /* init routine */
106:                    NULL, /* vblank callback */
107:                    NULL, /* hblank callback */
108:                    NULL, /* get state (snss) */
109:                    NULL, /* set state (snss) */
110:                    NULL, /* memory read structure */
111:                    map65_memwrite, /* memory write structure */
112:                    NULL /* external sound device */
113:                 };
114:                 
115:                 /*
116:                 ** $Log: map065.c,v $
117:                 ** Revision 1.2  2001/04/27 14:37:11  neil
118:                 ** wheeee
119:                 **
120:                 ** Revision 1.1  2001/04/27 12:54:40  neil
121:                 ** blah
122:                 **
123:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
124:                 ** initial
125:                 **
126:                 ** Revision 1.1  2000/10/24 12:19:33  matt
127:                 ** changed directory structure
128:                 **
129:                 ** Revision 1.5  2000/10/22 19:17:46  matt
130:                 ** mapper cleanups galore
131:                 **
132:                 ** Revision 1.4  2000/10/21 19:33:38  matt
133:                 ** many more cleanups
134:                 **
135:                 ** Revision 1.3  2000/10/10 13:58:17  matt
136:                 ** stroustrup squeezing his way in the door
137:                 **
138:                 ** Revision 1.2  2000/07/06 02:48:43  matt
139:                 ** clearly labelled structure members
140:                 **
141:                 ** Revision 1.1  2000/07/06 01:01:56  matt
142:                 ** initial revision
143:                 **
144:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map064.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map64.c
21:                  **
22:                  ** mapper 64 interface
23:                  ** $Id: map064.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes.h>
29:                  #include <log.h>
30:                  
31:                  static struct
32:                  {
33:                     int counter, latch;
34:                     bool enabled, reset;
35:                  } irq;
36:                  
37:                  static uint8 command = 0;
38:                  static uint16 vrombase = 0x0000;
39:                  
40:                  static void map64_hblank(int vblank)
41:                  {
9D030374  27BDFFE8   ADDIU SP, SP, -24
9D030378  AFBF0014   SW RA, 20(SP)
42:                     if (vblank)
9D03036C  14800019   BNE A0, ZERO, 0x9D0303D4
9D030370  3C02A001   LUI V0, -24575
43:                        return;
44:                  
45:                     irq.reset = false;
46:                  
47:                     if (ppu_enabled())
9D03037C  0F406397   JAL ppu_enabled
9D030380  AC40B8E0   SW ZERO, -18208(V0)
9D030384  10400011   BEQ V0, ZERO, 0x9D0303CC
9D030388  3C03A001   LUI V1, -24575
48:                     {
49:                        if (0 == irq.counter--)
9D03038C  8C62B8D4   LW V0, -18220(V1)
9D030390  2444FFFF   ADDIU A0, V0, -1
9D030394  1440000D   BNE V0, ZERO, 0x9D0303CC
9D030398  AC64B8D4   SW A0, -18220(V1)
50:                        {
51:                           irq.counter = irq.latch;
9D03039C  2462B8D4   ADDIU V0, V1, -18220
9D0303A0  8C440004   LW A0, 4(V0)
9D0303A4  AC64B8D4   SW A0, -18220(V1)
52:                         
53:                           if (true == irq.enabled)
9D0303A8  8C430008   LW V1, 8(V0)
9D0303AC  24020001   ADDIU V0, ZERO, 1
9D0303B0  14620004   BNE V1, V0, 0x9D0303C4
9D0303B4  24030001   ADDIU V1, ZERO, 1
54:                              nes_irq();
9D0303B8  0F408A46   JAL nes_irq
9D0303BC  00000000   NOP
55:                  
56:                           irq.reset = true;
9D0303C0  24030001   ADDIU V1, ZERO, 1
9D0303C4  3C02A001   LUI V0, -24575
9D0303C8  AC43B8E0   SW V1, -18208(V0)
57:                        }
58:                     }
59:                  }
9D0303CC  8FBF0014   LW RA, 20(SP)
9D0303D0  27BD0018   ADDIU SP, SP, 24
9D0303D4  03E00008   JR RA
9D0303D8  00000000   NOP
60:                  
61:                  /* mapper 64: Tengen RAMBO-1 */
62:                  static void map64_write(uint32 address, uint8 value)
63:                  {
9D030064  27BDFFE8   ADDIU SP, SP, -24
9D030068  AFBF0014   SW RA, 20(SP)
9D03006C  AFB00010   SW S0, 16(SP)
64:                     switch (address & 0xE001)
9D030070  3084E001   ANDI A0, A0, -8191
9D030074  3402C000   ORI V0, ZERO, -16384
9D030078  108200A3   BEQ A0, V0, 0x9D030308
9D03007C  00A08021   ADDU S0, A1, ZERO
9D030080  3402C001   ORI V0, ZERO, -16383
9D030084  0082102B   SLTU V0, A0, V0
9D030088  1040000A   BEQ V0, ZERO, 0x9D0300B4
9D03008C  3402E000   ORI V0, ZERO, -8192
9D030090  34028001   ORI V0, ZERO, -32767
9D030094  10820014   BEQ A0, V0, 0x9D0300E8
9D030098  3402A000   ORI V0, ZERO, -24576
9D03009C  1082008B   BEQ A0, V0, 0x9D0302CC
9D0300A0  34028000   ORI V0, ZERO, -32768
9D0300A4  148200A5   BNE A0, V0, 0x9D03033C
9D0300A8  3C02A001   LUI V0, -24575
9D0300B4  1082009A   BEQ A0, V0, 0x9D030320
9D0300B8  3402E001   ORI V0, ZERO, -8191
9D0300BC  1082009B   BEQ A0, V0, 0x9D03032C
9D0300C0  3402C001   ORI V0, ZERO, -16383
9D0300C4  1482009D   BNE A0, V0, 0x9D03033C
9D0300C8  3C02A001   LUI V0, -24575
65:                     {
66:                     case 0x8000:
67:                        command = value;
9D0300AC  0B40C035   J 0x9D0300D4
9D0300B0  A38580D6   SB A1, -32554(GP)
68:                        vrombase = (value & 0x80) ? 0x1000 : 0x0000;
9D0300D4  000581C2   SRL S0, A1, 7
9D0300D8  24021000   ADDIU V0, ZERO, 4096
9D0300DC  0010100A   MOVZ V0, ZERO, S0
69:                        break;
9D0300E0  0B40C0CE   J 0x9D030338
9D0300E4  A78280D4   SH V0, -32556(GP)
70:                  
71:                     case 0x8001:
72:                        switch (command & 0xF)
9D0300E8  938280D6   LBU V0, -32554(GP)
9D0300EC  3044000F   ANDI A0, V0, 15
9D0300F0  00042080   SLL A0, A0, 2
9D0300F4  3C039D03   LUI V1, -25341
9D0300F8  2463010C   ADDIU V1, V1, 268
9D0300FC  00641821   ADDU V1, V1, A0
9D030100  8C630000   LW V1, 0(V1)
9D030104  00600008   JR V1
9D030108  00000000   NOP
73:                        {
74:                        case 0:
75:                           mmc_bankvrom(1, 0x0000 ^ vrombase, value);
9D03014C  24040001   ADDIU A0, ZERO, 1
9D030150  978580D4   LHU A1, -32556(GP)
9D030154  0F40B1E8   JAL mmc_bankvrom
9D030158  02003021   ADDU A2, S0, ZERO
76:                           mmc_bankvrom(1, 0x0400 ^ vrombase, value);
9D03015C  978580D4   LHU A1, -32556(GP)
9D030160  24040001   ADDIU A0, ZERO, 1
9D030164  38A50400   XORI A1, A1, 1024
9D030168  0F40B1E8   JAL mmc_bankvrom
9D03016C  02003021   ADDU A2, S0, ZERO
77:                           break;
9D030170  0B40C0CF   J 0x9D03033C
9D030174  3C02A001   LUI V0, -24575
78:                  
79:                        case 1:
80:                           mmc_bankvrom(1, 0x0800 ^ vrombase, value);
9D030178  978580D4   LHU A1, -32556(GP)
9D03017C  24040001   ADDIU A0, ZERO, 1
9D030180  38A50800   XORI A1, A1, 2048
9D030184  0F40B1E8   JAL mmc_bankvrom
9D030188  02003021   ADDU A2, S0, ZERO
81:                           mmc_bankvrom(1, 0x0C00 ^ vrombase, value);
9D03018C  978580D4   LHU A1, -32556(GP)
9D030190  24040001   ADDIU A0, ZERO, 1
9D030194  38A50C00   XORI A1, A1, 3072
9D030198  0F40B1E8   JAL mmc_bankvrom
9D03019C  02003021   ADDU A2, S0, ZERO
82:                           break;
9D0301A0  0B40C0CF   J 0x9D03033C
9D0301A4  3C02A001   LUI V0, -24575
83:                  
84:                        case 2:
85:                           mmc_bankvrom(1, 0x1000 ^ vrombase, value);
9D0301A8  978580D4   LHU A1, -32556(GP)
9D0301AC  24040001   ADDIU A0, ZERO, 1
9D0301B0  38A51000   XORI A1, A1, 4096
9D0301B4  0F40B1E8   JAL mmc_bankvrom
9D0301B8  02003021   ADDU A2, S0, ZERO
86:                           break;
9D0301BC  0B40C0CF   J 0x9D03033C
9D0301C0  3C02A001   LUI V0, -24575
87:                  
88:                        case 3:
89:                           mmc_bankvrom(1, 0x1400 ^ vrombase, value);
9D0301C4  978580D4   LHU A1, -32556(GP)
9D0301C8  24040001   ADDIU A0, ZERO, 1
9D0301CC  38A51400   XORI A1, A1, 5120
9D0301D0  0F40B1E8   JAL mmc_bankvrom
9D0301D4  02003021   ADDU A2, S0, ZERO
90:                           break;
9D0301D8  0B40C0CF   J 0x9D03033C
9D0301DC  3C02A001   LUI V0, -24575
91:                  
92:                        case 4:
93:                           mmc_bankvrom(1, 0x1800 ^ vrombase, value);
9D0301E0  978580D4   LHU A1, -32556(GP)
9D0301E4  24040001   ADDIU A0, ZERO, 1
9D0301E8  38A51800   XORI A1, A1, 6144
9D0301EC  0F40B1E8   JAL mmc_bankvrom
9D0301F0  02003021   ADDU A2, S0, ZERO
94:                           break;
9D0301F4  0B40C0CF   J 0x9D03033C
9D0301F8  3C02A001   LUI V0, -24575
95:                  
96:                        case 5:
97:                           mmc_bankvrom(1, 0x1C00 ^ vrombase, value);
9D0301FC  978580D4   LHU A1, -32556(GP)
9D030200  24040001   ADDIU A0, ZERO, 1
9D030204  38A51C00   XORI A1, A1, 7168
9D030208  0F40B1E8   JAL mmc_bankvrom
9D03020C  02003021   ADDU A2, S0, ZERO
98:                           break;
9D030210  0B40C0CF   J 0x9D03033C
9D030214  3C02A001   LUI V0, -24575
99:                  
100:                       case 6:
101:                          mmc_bankrom(8, (command & 0x40) ? 0xA000 : 0x8000, value);
9D030218  30420040   ANDI V0, V0, 64
9D03021C  304500FF   ANDI A1, V0, 255
9D030220  24040008   ADDIU A0, ZERO, 8
9D030224  3402A000   ORI V0, ZERO, -24576
9D030228  34038000   ORI V1, ZERO, -32768
9D03022C  0065100A   MOVZ V0, V1, A1
9D030230  00402821   ADDU A1, V0, ZERO
9D030234  0F40B246   JAL mmc_bankrom
9D030238  02003021   ADDU A2, S0, ZERO
102:                          break;
9D03023C  0B40C0CF   J 0x9D03033C
9D030240  3C02A001   LUI V0, -24575
103:                 
104:                       case 7:
105:                          mmc_bankrom(8, (command & 0x40) ? 0xC000 : 0xA000, value);
9D030244  30420040   ANDI V0, V0, 64
9D030248  304500FF   ANDI A1, V0, 255
9D03024C  24040008   ADDIU A0, ZERO, 8
9D030250  3402C000   ORI V0, ZERO, -16384
9D030254  3403A000   ORI V1, ZERO, -24576
9D030258  0065100A   MOVZ V0, V1, A1
9D03025C  00402821   ADDU A1, V0, ZERO
9D030260  0F40B246   JAL mmc_bankrom
9D030264  02003021   ADDU A2, S0, ZERO
106:                          break;
9D030268  0B40C0CF   J 0x9D03033C
9D03026C  3C02A001   LUI V0, -24575
107:                 
108:                       case 8:
109:                          mmc_bankvrom(1, 0x0400, value);
9D030270  24040001   ADDIU A0, ZERO, 1
9D030274  24050400   ADDIU A1, ZERO, 1024
9D030278  0F40B1E8   JAL mmc_bankvrom
9D03027C  02003021   ADDU A2, S0, ZERO
110:                          break;
9D030280  0B40C0CF   J 0x9D03033C
9D030284  3C02A001   LUI V0, -24575
111:                 
112:                       case 9:
113:                          mmc_bankvrom(1, 0x0C00, value);
9D030288  24040001   ADDIU A0, ZERO, 1
9D03028C  24050C00   ADDIU A1, ZERO, 3072
9D030290  0F40B1E8   JAL mmc_bankvrom
9D030294  02003021   ADDU A2, S0, ZERO
114:                          break;
9D030298  0B40C0CF   J 0x9D03033C
9D03029C  3C02A001   LUI V0, -24575
115:                 
116:                       case 15:
117:                          mmc_bankrom(8, (command & 0x40) ? 0x8000 : 0xC000, value);
9D0302A0  30420040   ANDI V0, V0, 64
9D0302A4  304500FF   ANDI A1, V0, 255
9D0302A8  24040008   ADDIU A0, ZERO, 8
9D0302AC  34028000   ORI V0, ZERO, -32768
9D0302B0  3403C000   ORI V1, ZERO, -16384
9D0302B4  0065100A   MOVZ V0, V1, A1
9D0302B8  00402821   ADDU A1, V0, ZERO
9D0302BC  0F40B246   JAL mmc_bankrom
9D0302C0  02003021   ADDU A2, S0, ZERO
118:                          break;
9D0302C4  0B40C0CF   J 0x9D03033C
9D0302C8  3C02A001   LUI V0, -24575
119:                 
120:                       default:
121:                 #ifdef NOFRENDO_DEBUG
122:                          log_printf("mapper 64: unknown command #%d", command & 0xF);
123:                 #endif
124:                          break;
125:                       }
126:                       break;
127:                    
128:                    case 0xA000:
129:                       if (value & 1)
9D0302CC  30B00001   ANDI S0, A1, 1
9D0302D0  12000007   BEQ S0, ZERO, 0x9D0302F0
9D0302D4  00002021   ADDU A0, ZERO, ZERO
130:                          ppu_mirror(0, 0, 1, 1);
9D0302D8  00002821   ADDU A1, ZERO, ZERO
9D0302DC  24060001   ADDIU A2, ZERO, 1
9D0302E0  0F406128   JAL ppu_mirror
9D0302E4  24070001   ADDIU A3, ZERO, 1
9D0302E8  0B40C0CF   J 0x9D03033C
9D0302EC  3C02A001   LUI V0, -24575
131:                       else
132:                          ppu_mirror(0, 1, 0, 1);
9D0302F0  24050001   ADDIU A1, ZERO, 1
9D0302F4  00003021   ADDU A2, ZERO, ZERO
9D0302F8  0F406128   JAL ppu_mirror
9D0302FC  24070001   ADDIU A3, ZERO, 1
133:                       break;
134:                    
135:                    case 0xC000:
136:                       //irq.counter = value;
137:                       irq.latch = value;
9D030308  3C02A001   LUI V0, -24575
138:                       break;
9D03030C  0B40C0CE   J 0x9D030338
9D030310  AC45B8D8   SW A1, -18216(V0)
139:                    
140:                    case 0xC001:
141:                       //irq.latch = value;
142:                       irq.reset = true;
9D0300CC  0B40C0C5   J 0x9D030314
9D0300D0  24030001   ADDIU V1, ZERO, 1
9D030314  3C02A001   LUI V0, -24575
9D030318  0B40C0D3   J 0x9D03034C
9D03031C  AC43B8E0   SW V1, -18208(V0)
143:                       break;
144:                    
145:                    case 0xE000:
146:                       //irq.counter = irq.latch;
147:                       irq.enabled = false;
9D030320  3C02A001   LUI V0, -24575
148:                       break;
9D030324  0B40C0CE   J 0x9D030338
9D030328  AC40B8DC   SW ZERO, -18212(V0)
149:                    
150:                    case 0xE001:
151:                       irq.enabled = true;
9D03032C  24030001   ADDIU V1, ZERO, 1
9D030330  3C02A001   LUI V0, -24575
9D030334  AC43B8DC   SW V1, -18212(V0)
152:                       break;
153:                    
154:                    default:
155:                 #ifdef NOFRENDO_DEBUG
156:                       log_printf("mapper 64: Wrote $%02X to $%04X", value, address);
157:                 #endif
158:                       break;
159:                    }
160:                 
161:                    if (true == irq.reset)
9D030300  0B40C0CF   J 0x9D03033C
9D030304  3C02A001   LUI V0, -24575
9D030338  3C02A001   LUI V0, -24575
9D03033C  8C43B8E0   LW V1, -18208(V0)
9D030340  24020001   ADDIU V0, ZERO, 1
9D030344  14620006   BNE V1, V0, 0x9D030360
9D030348  8FBF0014   LW RA, 20(SP)
162:                       irq.counter = irq.latch;
9D03034C  3C02A001   LUI V0, -24575
9D030350  2443B8D4   ADDIU V1, V0, -18220
9D030354  8C630004   LW V1, 4(V1)
9D030358  AC43B8D4   SW V1, -18220(V0)
163:                 }
9D03035C  8FBF0014   LW RA, 20(SP)
9D030360  8FB00010   LW S0, 16(SP)
9D030364  03E00008   JR RA
9D030368  27BD0018   ADDIU SP, SP, 24
164:                 
165:                 static void map64_init(void)
166:                 {
9D02FFF8  27BDFFE8   ADDIU SP, SP, -24
9D02FFFC  AFBF0014   SW RA, 20(SP)
167:                    mmc_bankrom(8, 0x8000, MMC_LASTBANK);
9D030000  24040008   ADDIU A0, ZERO, 8
9D030004  34058000   ORI A1, ZERO, -32768
9D030008  0F40B246   JAL mmc_bankrom
9D03000C  2406FFFF   ADDIU A2, ZERO, -1
168:                    mmc_bankrom(8, 0xA000, MMC_LASTBANK);
9D030010  24040008   ADDIU A0, ZERO, 8
9D030014  3405A000   ORI A1, ZERO, -24576
9D030018  0F40B246   JAL mmc_bankrom
9D03001C  2406FFFF   ADDIU A2, ZERO, -1
169:                    mmc_bankrom(8, 0xC000, MMC_LASTBANK);
9D030020  24040008   ADDIU A0, ZERO, 8
9D030024  3405C000   ORI A1, ZERO, -16384
9D030028  0F40B246   JAL mmc_bankrom
9D03002C  2406FFFF   ADDIU A2, ZERO, -1
170:                    mmc_bankrom(8, 0xE000, MMC_LASTBANK);
9D030030  24040008   ADDIU A0, ZERO, 8
9D030034  3405E000   ORI A1, ZERO, -8192
9D030038  0F40B246   JAL mmc_bankrom
9D03003C  2406FFFF   ADDIU A2, ZERO, -1
171:                 
172:                    irq.counter = irq.latch = 0;
9D030040  3C03A001   LUI V1, -24575
9D030044  2462B8D4   ADDIU V0, V1, -18220
9D030048  AC400004   SW ZERO, 4(V0)
9D03004C  AC60B8D4   SW ZERO, -18220(V1)
173:                    irq.reset = irq.enabled = false;
9D030050  AC400008   SW ZERO, 8(V0)
9D030054  AC40000C   SW ZERO, 12(V0)
174:                 }
9D030058  8FBF0014   LW RA, 20(SP)
9D03005C  03E00008   JR RA
9D030060  27BD0018   ADDIU SP, SP, 24
175:                 
176:                 static map_memwrite map64_memwrite[] =
177:                 {
178:                    { 0x8000, 0xFFFF, map64_write },
179:                    {     -1,     -1, NULL }
180:                 };
181:                 
182:                 mapintf_t map64_intf =
183:                 {
184:                    64, /* mapper number */
185:                    "Tengen RAMBO-1", /* mapper name */
186:                    map64_init, /* init routine */
187:                    NULL, /* vblank callback */
188:                    map64_hblank, /* hblank callback */
189:                    NULL, /* get state (snss) */
190:                    NULL, /* set state (snss) */
191:                    NULL, /* memory read structure */
192:                    map64_memwrite, /* memory write structure */
193:                    NULL /* external sound device */
194:                 };
195:                 
196:                 /*
197:                 ** $Log: map064.c,v $
198:                 ** Revision 1.2  2001/04/27 14:37:11  neil
199:                 ** wheeee
200:                 **
201:                 ** Revision 1.1  2001/04/27 12:54:40  neil
202:                 ** blah
203:                 **
204:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
205:                 ** initial
206:                 **
207:                 ** Revision 1.1  2000/10/24 12:19:33  matt
208:                 ** changed directory structure
209:                 **
210:                 ** Revision 1.8  2000/10/22 19:17:46  matt
211:                 ** mapper cleanups galore
212:                 **
213:                 ** Revision 1.7  2000/10/22 15:03:13  matt
214:                 ** simplified mirroring
215:                 **
216:                 ** Revision 1.6  2000/10/21 19:33:38  matt
217:                 ** many more cleanups
218:                 **
219:                 ** Revision 1.5  2000/10/10 13:58:17  matt
220:                 ** stroustrup squeezing his way in the door
221:                 **
222:                 ** Revision 1.4  2000/07/10 13:51:25  matt
223:                 ** using generic nes_irq() routine now
224:                 **
225:                 ** Revision 1.3  2000/07/10 05:29:03  matt
226:                 ** cleaned up some mirroring issues
227:                 **
228:                 ** Revision 1.2  2000/07/06 02:48:43  matt
229:                 ** clearly labelled structure members
230:                 **
231:                 ** Revision 1.1  2000/07/05 05:05:18  matt
232:                 ** initial revision
233:                 **
234:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map050.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map050.c
21:                  **
22:                  ** Mapper #50 (SMB2j - 3rd discovered variation)
23:                  ** Implementation by Firebug
24:                  ** Mapper information courtesy of Kevin Horton
25:                  ** $Id: map050.c,v 1.2 2001/04/27 14:37:11 neil Exp $
26:                  **
27:                  */
28:                  
29:                  #include <noftypes.h>
30:                  #include <nes_mmc.h>
31:                  #include <nes.h>
32:                  #include <libsnss.h>
33:                  #include <log.h>
34:                  
35:                  static struct
36:                  {
37:                    bool enabled;
38:                    uint32 counter;
39:                  } irq;
40:                  
41:                  /********************************/
42:                  /* Mapper #50 IRQ reset routine */
43:                  /********************************/
44:                  static void map50_irq_reset (void)
45:                  {
46:                    /* Turn off IRQs */
47:                    irq.enabled = false;
9D036F9C  AF808064   SW ZERO, -32668(GP)
9D03702C  AF808064   SW ZERO, -32668(GP)
9D037088  AF808064   SW ZERO, -32668(GP)
48:                    irq.counter = 0x0000;
9D036FA0  0B40DBFA   J .LVL11
9D036FA4  AF808068   SW ZERO, -32664(GP)
9D037030  AF808068   SW ZERO, -32664(GP)
9D03708C  AF808068   SW ZERO, -32664(GP)
49:                  
50:                    /* Done */
51:                    return;
52:                  }
53:                  
54:                  /**************************************************************/
55:                  /* Mapper #50: 3rd discovered variation of SMB2j cart bootleg */
56:                  /**************************************************************/
57:                  static void map50_init (void)
58:                  {
9D037040  27BDFFE8   ADDIU SP, SP, -24
9D037044  AFBF0014   SW RA, 20(SP)
59:                    /* Set the hardwired pages */
60:                    mmc_bankrom (8, 0x6000, 0x0F);
9D037048  24040008   ADDIU A0, ZERO, 8
9D03704C  24056000   ADDIU A1, ZERO, 24576
9D037050  0F40B246   JAL mmc_bankrom
9D037054  2406000F   ADDIU A2, ZERO, 15
61:                    mmc_bankrom (8, 0x8000, 0x08);
9D037058  24040008   ADDIU A0, ZERO, 8
9D03705C  34058000   ORI A1, ZERO, -32768
9D037060  0F40B246   JAL mmc_bankrom
9D037064  24060008   ADDIU A2, ZERO, 8
62:                    mmc_bankrom (8, 0xA000, 0x09);
9D037068  24040008   ADDIU A0, ZERO, 8
9D03706C  3405A000   ORI A1, ZERO, -24576
9D037070  0F40B246   JAL mmc_bankrom
9D037074  24060009   ADDIU A2, ZERO, 9
63:                    mmc_bankrom (8, 0xE000, 0x0B);
9D037078  24040008   ADDIU A0, ZERO, 8
9D03707C  3405E000   ORI A1, ZERO, -8192
9D037080  0F40B246   JAL mmc_bankrom
9D037084  2406000B   ADDIU A2, ZERO, 11
64:                  
65:                    /* Reset the IRQ counter */
66:                    map50_irq_reset ();
67:                  
68:                    /* Done */
69:                    return;
70:                  }
9D037090  8FBF0014   LW RA, 20(SP)
9D037094  03E00008   JR RA
9D037098  27BD0018   ADDIU SP, SP, 24
71:                  
72:                  /****************************************/
73:                  /* Mapper #50 callback for IRQ handling */
74:                  /****************************************/
75:                  static void map50_hblank (int vblank)
76:                  {
9D036FF8  27BDFFE8   ADDIU SP, SP, -24
9D036FFC  AFBF0014   SW RA, 20(SP)
77:                     /* Counter is M2 based so it doesn't matter whether */
78:                     /* the PPU is in its VBlank period or not           */
79:                     UNUSED(vblank);
80:                  
81:                     /* Increment the counter if it is enabled and check for strike */
82:                     if (irq.enabled)
9D037000  8F828064   LW V0, -32668(GP)
9D037004  1040000B   BEQ V0, ZERO, .LBE8
9D037008  27838068   ADDIU V1, GP, -32664
83:                     {
84:                       /* Is there a constant for cycles per scanline? */
85:                       /* If so, someone ought to substitute it here   */
86:                       irq.counter = irq.counter + 114;
9D03700C  8C620000   LW V0, 0(V1)
9D037010  24420072   ADDIU V0, V0, 114
9D037014  AC620000   SW V0, 0(V1)
87:                  
88:                       /* IRQ line is hooked to Q12 of the counter */
89:                       if (irq.counter & 0x1000)
9D037018  30421000   ANDI V0, V0, 4096
9D03701C  10400006   BEQ V0, ZERO, 0x9D037038
9D037020  8FBF0014   LW RA, 20(SP)
90:                       {
91:                         /* Trigger the IRQ */
92:                         nes_irq ();
9D037024  0F408A46   JAL nes_irq
9D037028  00000000   NOP
93:                  
94:                         /* Reset the counter */
95:                         map50_irq_reset ();
96:                       }
97:                     }
98:                  }
9D037034  8FBF0014   LW RA, 20(SP)
9D037038  03E00008   JR RA
9D03703C  27BD0018   ADDIU SP, SP, 24
99:                  
100:                 /******************************************/
101:                 /* Mapper #50 write handler ($4000-$5FFF) */
102:                 /******************************************/
103:                 static void map50_write (uint32 address, uint8 value)
104:                 {
9D036F7C  27BDFFE8   ADDIU SP, SP, -24
105:                   uint8 selectable_bank;
106:                 
107:                   /* For address to be decoded, A5 must be high and A6 low */
108:                   if ((address & 0x60) != 0x20) return;
9D036F6C  30830060   ANDI V1, A0, 96
9D036F70  24020020   ADDIU V0, ZERO, 32
9D036F74  1462001E   BNE V1, V0, 0x9D036FF0
9D036F78  30840100   ANDI A0, A0, 256
109:                 
110:                   /* A8 low  = $C000-$DFFF page selection */
111:                   /* A8 high = IRQ timer toggle */
112:                   if (address & 0x100)
9D036F80  10800009   BEQ A0, ZERO, 0x9D036FA8
9D036F84  AFBF0014   SW RA, 20(SP)
113:                   {
114:                     /* IRQ settings */
115:                     if (value & 0x01) irq.enabled = true;
9D036F88  30A50001   ANDI A1, A1, 1
9D036F8C  10A00003   BEQ A1, ZERO, .LBB4
9D036F90  24020001   ADDIU V0, ZERO, 1
9D036F94  0B40DBFA   J .LVL11
9D036F98  AF828064   SW V0, -32668(GP)
116:                     else              map50_irq_reset ();
117:                   }
118:                   else
119:                   {
120:                     /* Stupid data line swapping */
121:                     selectable_bank = 0x00;
122:                     if (value & 0x08) selectable_bank |= 0x08;
123:                     if (value & 0x04) selectable_bank |= 0x02;
9D036FA8  30A20004   ANDI V0, A1, 4
9D036FAC  304200FF   ANDI V0, V0, 255
9D036FB0  10400003   BEQ V0, ZERO, 0x9D036FC0
9D036FB4  30A60008   ANDI A2, A1, 8
9D036FB8  34C60002   ORI A2, A2, 2
9D036FBC  30C600FF   ANDI A2, A2, 255
124:                     if (value & 0x02) selectable_bank |= 0x01;
9D036FC0  30A30002   ANDI V1, A1, 2
9D036FC4  306300FF   ANDI V1, V1, 255
9D036FC8  34C20001   ORI V0, A2, 1
9D036FCC  0043300B   MOVN A2, V0, V1
125:                     if (value & 0x01) selectable_bank |= 0x04;
9D036FD0  30A50001   ANDI A1, A1, 1
9D036FD4  34C20004   ORI V0, A2, 4
9D036FD8  0045300B   MOVN A2, V0, A1
126:                     mmc_bankrom (8, 0xC000, selectable_bank);
9D036FDC  24040008   ADDIU A0, ZERO, 8
9D036FE0  0F40B246   JAL mmc_bankrom
9D036FE4  3405C000   ORI A1, ZERO, -16384
127:                   }
128:                 
129:                   /* Done */
130:                   return;
131:                 }
9D036FE8  8FBF0014   LW RA, 20(SP)
9D036FEC  27BD0018   ADDIU SP, SP, 24
9D036FF0  03E00008   JR RA
9D036FF4  00000000   NOP
132:                 
133:                 /****************************************************/
134:                 /* Shove extra mapper information into a SNSS block */
135:                 /****************************************************/
136:                 static void map50_setstate (SnssMapperBlock *state)
137:                 {
9D036F5C  03E00008   JR RA
9D036F60  00000000   NOP
138:                   /* TODO: Store SNSS information */
139:                   UNUSED (state);
140:                 
141:                   /* Done */
142:                   return;
143:                 }
144:                 
145:                 /*****************************************************/
146:                 /* Pull extra mapper information out of a SNSS block */
147:                 /*****************************************************/
148:                 static void map50_getstate (SnssMapperBlock *state)
149:                 {
9D036F64  03E00008   JR RA
9D036F68  00000000   NOP
150:                   /* TODO: Retrieve SNSS information */
151:                   UNUSED (state);
152:                 
153:                   /* Done */
154:                   return;
155:                 }
156:                 
157:                 static map_memwrite map50_memwrite [] =
158:                 {
159:                    { 0x4000, 0x5FFF, map50_write },
160:                    {     -1,     -1, NULL }
161:                 };
162:                 
163:                 mapintf_t map50_intf =
164:                 {
165:                    50,                               /* Mapper number */
166:                    "SMB2j (3rd discovered variant)", /* Mapper name */
167:                    map50_init,                       /* Initialization routine */
168:                    NULL,                             /* VBlank callback */
169:                    map50_hblank,                     /* HBlank callback */
170:                    map50_getstate,                   /* Get state (SNSS) */
171:                    map50_setstate,                   /* Set state (SNSS) */
172:                    NULL,                             /* Memory read structure */
173:                    map50_memwrite,                   /* Memory write structure */
174:                    NULL                              /* External sound device */
175:                 };
176:                 
177:                 /*
178:                 ** $Log: map050.c,v $
179:                 ** Revision 1.2  2001/04/27 14:37:11  neil
180:                 ** wheeee
181:                 **
182:                 ** Revision 1.1  2001/04/27 12:54:40  neil
183:                 ** blah
184:                 **
185:                 ** Revision 1.1  2001/04/27 10:57:41  neil
186:                 ** wheee
187:                 **
188:                 ** Revision 1.1  2000/12/27 19:22:13  firebug
189:                 ** initial revision
190:                 **
191:                 **
192:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map046.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map046.c
21:                  **
22:                  ** Mapper #46 (Pelican Game Station)
23:                  ** Implementation by Firebug
24:                  ** Mapper information courtesy of Kevin Horton
25:                  ** $Id: map046.c,v 1.2 2001/04/27 14:37:11 neil Exp $
26:                  **
27:                  */
28:                  
29:                  #include <noftypes.h>
30:                  #include <nes_mmc.h>
31:                  #include <nes.h>
32:                  #include <libsnss.h>
33:                  #include <log.h>
34:                  
35:                  static uint8 prg_low_bank;
36:                  static uint8 chr_low_bank;
37:                  static uint8 prg_high_bank;
38:                  static uint8 chr_high_bank;
39:                  
40:                  /*************************************************/
41:                  /* Set banks from the combined register values   */
42:                  /*************************************************/
43:                  static void map46_set_banks (void)
44:                  {
9D0396BC  27BDFFE8   ADDIU SP, SP, -24
9D0396C0  AFBF0014   SW RA, 20(SP)
45:                    /* Set the PRG and CHR pages */
46:                    mmc_bankrom (32, 0x8000, (prg_high_bank << 1) | (prg_low_bank));
9D0396C4  938680BD   LBU A2, -32579(GP)
9D0396C8  00063040   SLL A2, A2, 1
9D0396CC  938280BF   LBU V0, -32577(GP)
9D0396D0  24040020   ADDIU A0, ZERO, 32
9D0396D4  34058000   ORI A1, ZERO, -32768
9D0396D8  0F40B246   JAL mmc_bankrom
9D0396DC  00C23025   OR A2, A2, V0
47:                    mmc_bankvrom (8, 0x0000, (chr_high_bank << 3) | (chr_low_bank));
9D0396E0  938680BC   LBU A2, -32580(GP)
9D0396E4  000630C0   SLL A2, A2, 3
9D0396E8  938280BE   LBU V0, -32578(GP)
9D0396EC  24040008   ADDIU A0, ZERO, 8
9D0396F0  00002821   ADDU A1, ZERO, ZERO
9D0396F4  0F40B1E8   JAL mmc_bankvrom
9D0396F8  00C23025   OR A2, A2, V0
48:                  
49:                    /* Done */
50:                    return;
51:                  }
9D0396FC  8FBF0014   LW RA, 20(SP)
9D039700  03E00008   JR RA
9D039704  27BD0018   ADDIU SP, SP, 24
52:                  
53:                  /*********************************************************/
54:                  /* Mapper #46: Pelican Game Station (aka Rumble Station) */
55:                  /*********************************************************/
56:                  static void map46_init (void)
57:                  {
9D039754  27BDFFE8   ADDIU SP, SP, -24
9D039758  AFBF0014   SW RA, 20(SP)
58:                    /* High bank switch register is set to zero on reset */
59:                    prg_high_bank = 0x00;
9D03975C  A38080BD   SB ZERO, -32579(GP)
60:                    chr_high_bank = 0x00;
61:                    map46_set_banks ();
9D039760  0F40E5AF   JAL .LFB0, map46_set_banks, .LFE4
9D039764  A38080BC   SB ZERO, -32580(GP)
62:                  
63:                    /* Done */
64:                    return;
65:                  }
9D039768  8FBF0014   LW RA, 20(SP)
9D03976C  03E00008   JR RA
9D039770  27BD0018   ADDIU SP, SP, 24
66:                  
67:                  /******************************************/
68:                  /* Mapper #46 write handler ($6000-$FFFF) */
69:                  /******************************************/
70:                  static void map46_write (uint32 address, uint8 value)
71:                  {
9D039708  27BDFFE8   ADDIU SP, SP, -24
72:                    /* $8000-$FFFF: D6-D4 = lower three bits of CHR bank */
73:                    /*              D0    = low bit of PRG bank          */
74:                    /* $6000-$7FFF: D7-D4 = high four bits of CHR bank   */
75:                    /*              D3-D0 = high four bits of PRG bank   */
76:                    if (address & 0x8000)
9D03970C  30848000   ANDI A0, A0, -32768
9D039710  10800008   BEQ A0, ZERO, 0x9D039734
9D039714  AFBF0014   SW RA, 20(SP)
77:                    {
78:                      prg_low_bank = value & 0x01;
9D039718  30A20001   ANDI V0, A1, 1
9D03971C  A38280BF   SB V0, -32577(GP)
79:                      chr_low_bank = (value >> 4) & 0x07;
9D039720  7CA51100   EXT A1, A1, 4, 3
80:                      map46_set_banks ();
9D039724  0F40E5AF   JAL .LFB0, map46_set_banks, .LFE4
9D039728  A38580BE   SB A1, -32578(GP)
9D03972C  0B40E5D3   J 0x9D03974C
9D039730  8FBF0014   LW RA, 20(SP)
81:                    }
82:                    else
83:                    {
84:                      prg_high_bank = value & 0x0F;
9D039734  30A2000F   ANDI V0, A1, 15
9D039738  A38280BD   SB V0, -32579(GP)
85:                      chr_high_bank = (value >> 4) & 0x0F;
9D03973C  00052902   SRL A1, A1, 4
86:                      map46_set_banks ();
9D039740  0F40E5AF   JAL .LFB0, map46_set_banks, .LFE4
9D039744  A38580BC   SB A1, -32580(GP)
87:                    }
88:                  
89:                    /* Done */
90:                    return;
91:                  }
9D039748  8FBF0014   LW RA, 20(SP)
9D03974C  03E00008   JR RA
9D039750  27BD0018   ADDIU SP, SP, 24
92:                  
93:                  /****************************************************/
94:                  /* Shove extra mapper information into a SNSS block */
95:                  /****************************************************/
96:                  static void map46_setstate (SnssMapperBlock *state)
97:                  {
9D0396AC  03E00008   JR RA
9D0396B0  00000000   NOP
98:                    /* TODO: Store SNSS information */
99:                    UNUSED (state);
100:                 
101:                   /* Done */
102:                   return;
103:                 }
104:                 
105:                 /*****************************************************/
106:                 /* Pull extra mapper information out of a SNSS block */
107:                 /*****************************************************/
108:                 static void map46_getstate (SnssMapperBlock *state)
109:                 {
9D0396B4  03E00008   JR RA
9D0396B8  00000000   NOP
110:                   /* TODO: Retrieve SNSS information */
111:                   UNUSED (state);
112:                 
113:                   /* Done */
114:                   return;
115:                 }
116:                 
117:                 static map_memwrite map46_memwrite [] =
118:                 {
119:                    { 0x6000, 0xFFFF, map46_write },
120:                    {     -1,     -1, NULL }
121:                 };
122:                 
123:                 mapintf_t map46_intf =
124:                 {
125:                    46,                               /* Mapper number */
126:                    "Pelican Game Station",           /* Mapper name */
127:                    map46_init,                       /* Initialization routine */
128:                    NULL,                             /* VBlank callback */
129:                    NULL,                             /* HBlank callback */
130:                    map46_getstate,                   /* Get state (SNSS) */
131:                    map46_setstate,                   /* Set state (SNSS) */
132:                    NULL,                             /* Memory read structure */
133:                    map46_memwrite,                   /* Memory write structure */
134:                    NULL                              /* External sound device */
135:                 };
136:                 
137:                 /*
138:                 ** $Log: map046.c,v $
139:                 ** Revision 1.2  2001/04/27 14:37:11  neil
140:                 ** wheeee
141:                 **
142:                 ** Revision 1.1  2001/04/27 12:54:40  neil
143:                 ** blah
144:                 **
145:                 ** Revision 1.1  2001/04/27 10:57:41  neil
146:                 ** wheee
147:                 **
148:                 ** Revision 1.1  2000/12/27 19:23:05  firebug
149:                 ** initial revision
150:                 **
151:                 **
152:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map042.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map042.c
21:                  **
22:                  ** Mapper #42 (Baby Mario bootleg)
23:                  ** Implementation by Firebug
24:                  ** Mapper information courtesy of Kevin Horton
25:                  ** $Id: map042.c,v 1.2 2001/04/27 14:37:11 neil Exp $
26:                  **
27:                  */
28:                  
29:                  #include <noftypes.h>
30:                  #include <nes_mmc.h>
31:                  #include <nes.h>
32:                  #include <libsnss.h>
33:                  #include <log.h>
34:                  
35:                  static struct
36:                  {
37:                    bool enabled;
38:                    uint32 counter;
39:                  } irq;
40:                  
41:                  /********************************/
42:                  /* Mapper #42 IRQ reset routine */
43:                  /********************************/
44:                  static void map42_irq_reset (void)
45:                  {
46:                    /* Turn off IRQs */
47:                    irq.enabled = false;
9D0368EC  AF8080B4   SW ZERO, -32588(GP)
9D036934  AF8080B4   SW ZERO, -32588(GP)
9D0369E4  AF8080B4   SW ZERO, -32588(GP)
48:                    irq.counter = 0x0000;
9D0368F0  AF8080B8   SW ZERO, -32584(GP)
9D036938  AF8080B8   SW ZERO, -32584(GP)
9D0369E8  AF8080B8   SW ZERO, -32584(GP)
49:                  
50:                    /* Done */
51:                    return;
52:                  }
53:                  
54:                  /********************************************/
55:                  /* Mapper #42: Baby Mario bootleg cartridge */
56:                  /********************************************/
57:                  static void map42_init (void)
58:                  {
9D0368A4  27BDFFE8   ADDIU SP, SP, -24
9D0368A8  AFBF0014   SW RA, 20(SP)
59:                    /* Set the hardwired pages */
60:                    mmc_bankrom (8, 0x8000, 0x0C);
9D0368AC  24040008   ADDIU A0, ZERO, 8
9D0368B0  34058000   ORI A1, ZERO, -32768
9D0368B4  0F40B246   JAL mmc_bankrom
9D0368B8  2406000C   ADDIU A2, ZERO, 12
61:                    mmc_bankrom (8, 0xA000, 0x0D);
9D0368BC  24040008   ADDIU A0, ZERO, 8
9D0368C0  3405A000   ORI A1, ZERO, -24576
9D0368C4  0F40B246   JAL mmc_bankrom
9D0368C8  2406000D   ADDIU A2, ZERO, 13
62:                    mmc_bankrom (8, 0xC000, 0x0E);
9D0368CC  24040008   ADDIU A0, ZERO, 8
9D0368D0  3405C000   ORI A1, ZERO, -16384
9D0368D4  0F40B246   JAL mmc_bankrom
9D0368D8  2406000E   ADDIU A2, ZERO, 14
63:                    mmc_bankrom (8, 0xE000, 0x0F);
9D0368DC  24040008   ADDIU A0, ZERO, 8
9D0368E0  3405E000   ORI A1, ZERO, -8192
9D0368E4  0F40B246   JAL mmc_bankrom
9D0368E8  2406000F   ADDIU A2, ZERO, 15
64:                  
65:                    /* Reset the IRQ counter */
66:                    map42_irq_reset ();
67:                  
68:                    /* Done */
69:                    return;
70:                  }
9D0368F4  8FBF0014   LW RA, 20(SP)
9D0368F8  03E00008   JR RA
9D0368FC  27BD0018   ADDIU SP, SP, 24
71:                  
72:                  /****************************************/
73:                  /* Mapper #42 callback for IRQ handling */
74:                  /****************************************/
75:                  static void map42_hblank (int vblank)
76:                  {
9D036900  27BDFFE8   ADDIU SP, SP, -24
9D036904  AFBF0014   SW RA, 20(SP)
77:                     /* Counter is M2 based so it doesn't matter whether */
78:                     /* the PPU is in its VBlank period or not           */
79:                     UNUSED(vblank);
80:                  
81:                     /* Increment the counter if it is enabled and check for strike */
82:                     if (irq.enabled)
9D036908  8F8280B4   LW V0, -32588(GP)
9D03690C  1040000B   BEQ V0, ZERO, .LBE8
9D036910  278380B8   ADDIU V1, GP, -32584
83:                     {
84:                       /* Is there a constant for cycles per scanline? */
85:                       /* If so, someone ought to substitute it here   */
86:                       irq.counter = irq.counter + 114;
9D036914  8C620000   LW V0, 0(V1)
9D036918  24420072   ADDIU V0, V0, 114
9D03691C  AC620000   SW V0, 0(V1)
87:                  
88:                       /* IRQ is triggered after 24576 M2 cycles */
89:                       if (irq.counter >= 0x6000)
9D036920  2C426000   SLTIU V0, V0, 24576
9D036924  14400006   BNE V0, ZERO, 0x9D036940
9D036928  8FBF0014   LW RA, 20(SP)
90:                       {
91:                         /* Trigger the IRQ */
92:                         nes_irq ();
9D03692C  0F408A46   JAL nes_irq
9D036930  00000000   NOP
93:                  
94:                         /* Reset the counter */
95:                         map42_irq_reset ();
96:                       }
97:                     }
98:                  }
9D03693C  8FBF0014   LW RA, 20(SP)
9D036940  03E00008   JR RA
9D036944  27BD0018   ADDIU SP, SP, 24
99:                  
100:                 /******************************************/
101:                 /* Mapper #42 write handler ($E000-$FFFF) */
102:                 /******************************************/
103:                 static void map42_write (uint32 address, uint8 value)
104:                 {
9D036948  27BDFFE8   ADDIU SP, SP, -24
9D03694C  AFBF0014   SW RA, 20(SP)
105:                   switch (address & 0x03)
9D036950  30840003   ANDI A0, A0, 3
9D036954  24020001   ADDIU V0, ZERO, 1
9D036958  1082000D   BEQ A0, V0, 0x9D036990
9D03695C  00A03021   ADDU A2, A1, ZERO
9D036960  10800005   BEQ A0, ZERO, 0x9D036978
9D036964  24020002   ADDIU V0, ZERO, 2
9D036968  50820019   BEQL A0, V0, 0x9D0369D0
9D03696C  30A60002   ANDI A2, A1, 2
106:                   {
107:                     /* Register 0: Select ROM page at $6000-$7FFF */
108:                     case 0x00: mmc_bankrom (8, 0x6000, value & 0x0F);
9D036978  24040008   ADDIU A0, ZERO, 8
9D03697C  24056000   ADDIU A1, ZERO, 24576
9D036980  0F40B246   JAL mmc_bankrom
9D036984  30C6000F   ANDI A2, A2, 15
109:                                break;
9D036988  0B40DA7C   J 0x9D0369F0
9D03698C  8FBF0014   LW RA, 20(SP)
110:                 
111:                     /* Register 1: mirroring */
112:                     case 0x01: if (value & 0x08) ppu_mirror(0, 0, 1, 1); /* horizontal */
9D036990  30A60008   ANDI A2, A1, 8
9D036994  30C600FF   ANDI A2, A2, 255
9D036998  10C00007   BEQ A2, ZERO, 0x9D0369B8
9D03699C  00002021   ADDU A0, ZERO, ZERO
9D0369A0  00002821   ADDU A1, ZERO, ZERO
9D0369A4  24060001   ADDIU A2, ZERO, 1
9D0369A8  0F406128   JAL ppu_mirror
9D0369AC  24070001   ADDIU A3, ZERO, 1
9D0369B0  0B40DA7C   J 0x9D0369F0
9D0369B4  8FBF0014   LW RA, 20(SP)
113:                                else              ppu_mirror(0, 1, 0, 1); /* vertical   */
9D0369B8  24050001   ADDIU A1, ZERO, 1
9D0369BC  00003021   ADDU A2, ZERO, ZERO
9D0369C0  0F406128   JAL ppu_mirror
9D0369C4  24070001   ADDIU A3, ZERO, 1
114:                                break;
115:                 
116:                     /* Register 2: IRQ */
117:                     case 0x02: if (value & 0x02) irq.enabled = true;
9D0369D0  30C600FF   ANDI A2, A2, 255
9D0369D4  10C00003   BEQ A2, ZERO, .LBB12
9D0369D8  24020001   ADDIU V0, ZERO, 1
9D0369DC  0B40DA7B   J .LBE12
9D0369E0  AF8280B4   SW V0, -32588(GP)
118:                                else              map42_irq_reset ();
119:                                break;
120:                 
121:                     /* Register 3: unused */
122:                     default:   break;
123:                   }
124:                 
125:                   /* Done */
126:                   return;
127:                 }
9D036970  0B40DA7C   J 0x9D0369F0
9D036974  8FBF0014   LW RA, 20(SP)
9D0369C8  0B40DA7C   J 0x9D0369F0
9D0369CC  8FBF0014   LW RA, 20(SP)
9D0369EC  8FBF0014   LW RA, 20(SP)
9D0369F0  03E00008   JR RA
9D0369F4  27BD0018   ADDIU SP, SP, 24
128:                 
129:                 /****************************************************/
130:                 /* Shove extra mapper information into a SNSS block */
131:                 /****************************************************/
132:                 static void map42_setstate (SnssMapperBlock *state)
133:                 {
9D036894  03E00008   JR RA
9D036898  00000000   NOP
134:                   /* TODO: Store SNSS information */
135:                   UNUSED (state);
136:                 
137:                   /* Done */
138:                   return;
139:                 }
140:                 
141:                 /*****************************************************/
142:                 /* Pull extra mapper information out of a SNSS block */
143:                 /*****************************************************/
144:                 static void map42_getstate (SnssMapperBlock *state)
145:                 {
9D03689C  03E00008   JR RA
9D0368A0  00000000   NOP
146:                   /* TODO: Retrieve SNSS information */
147:                   UNUSED (state);
148:                 
149:                   /* Done */
150:                   return;
151:                 }
152:                 
153:                 static map_memwrite map42_memwrite [] =
154:                 {
155:                    { 0xE000, 0xFFFF, map42_write },
156:                    {     -1,     -1, NULL }
157:                 };
158:                 
159:                 mapintf_t map42_intf =
160:                 {
161:                    42,                               /* Mapper number */
162:                    "Baby Mario (bootleg)",           /* Mapper name */
163:                    map42_init,                       /* Initialization routine */
164:                    NULL,                             /* VBlank callback */
165:                    map42_hblank,                     /* HBlank callback */
166:                    map42_getstate,                   /* Get state (SNSS) */
167:                    map42_setstate,                   /* Set state (SNSS) */
168:                    NULL,                             /* Memory read structure */
169:                    map42_memwrite,                   /* Memory write structure */
170:                    NULL                              /* External sound device */
171:                 };
172:                 
173:                 /*
174:                 ** $Log: map042.c,v $
175:                 ** Revision 1.2  2001/04/27 14:37:11  neil
176:                 ** wheeee
177:                 **
178:                 ** Revision 1.1  2001/04/27 12:54:40  neil
179:                 ** blah
180:                 **
181:                 ** Revision 1.1  2001/04/27 10:57:41  neil
182:                 ** wheee
183:                 **
184:                 ** Revision 1.1  2000/12/27 19:23:30  firebug
185:                 ** initial revision
186:                 **
187:                 **
188:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map041.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map041.c
21:                  **
22:                  ** Mapper #41 (Caltron 6 in 1)
23:                  ** Implementation by Firebug
24:                  ** Mapper information courtesy of Kevin Horton
25:                  ** $Id: map041.c,v 1.2 2001/04/27 14:37:11 neil Exp $
26:                  **
27:                  */
28:                  
29:                  #include <noftypes.h>
30:                  #include <nes_mmc.h>
31:                  #include <nes.h>
32:                  #include <libsnss.h>
33:                  #include <log.h>
34:                  
35:                  static uint8 register_low;
36:                  static uint8 register_high;
37:                  
38:                  /*****************************************************/
39:                  /* Set 8K CHR bank from the combined register values */
40:                  /*****************************************************/
41:                  static void map41_set_chr (void)
42:                  {
9D0377D0  27BDFFE8   ADDIU SP, SP, -24
9D0377D4  AFBF0014   SW RA, 20(SP)
43:                    /* Set the CHR bank from the appropriate register bits */
44:                    mmc_bankvrom (8, 0x0000, ((register_low >> 1) & 0x0C) | (register_high));
9D0377D8  938680D9   LBU A2, -32551(GP)
9D0377DC  00063042   SRL A2, A2, 1
9D0377E0  30C6000C   ANDI A2, A2, 12
9D0377E4  938280D8   LBU V0, -32552(GP)
9D0377E8  24040008   ADDIU A0, ZERO, 8
9D0377EC  00002821   ADDU A1, ZERO, ZERO
9D0377F0  0F40B1E8   JAL mmc_bankvrom
9D0377F4  00C23025   OR A2, A2, V0
45:                  
46:                    /* Done */
47:                    return;
48:                  }
9D0377F8  8FBF0014   LW RA, 20(SP)
9D0377FC  03E00008   JR RA
9D037800  27BD0018   ADDIU SP, SP, 24
49:                  
50:                  /******************************/
51:                  /* Mapper #41: Caltron 6 in 1 */
52:                  /******************************/
53:                  static void map41_init (void)
54:                  {
9D037838  27BDFFE8   ADDIU SP, SP, -24
9D03783C  AFBF0014   SW RA, 20(SP)
55:                    /* Both registers set to zero at power on */
56:                    /* TODO: Registers should also be cleared on a soft reset */
57:                    register_low = 0x00;
9D037840  A38080D9   SB ZERO, -32551(GP)
58:                    register_high = 0x00;
9D037844  A38080D8   SB ZERO, -32552(GP)
59:                    mmc_bankrom (32, 0x8000, 0x00);
9D037848  24040020   ADDIU A0, ZERO, 32
9D03784C  34058000   ORI A1, ZERO, -32768
9D037850  0F40B246   JAL mmc_bankrom
9D037854  00003021   ADDU A2, ZERO, ZERO
60:                    map41_set_chr ();
9D037858  0F40DDF4   JAL .LFB0, map41_set_chr, .LFE5
9D03785C  00000000   NOP
61:                  
62:                    /* Done */
63:                    return;
64:                  }
9D037860  8FBF0014   LW RA, 20(SP)
9D037864  03E00008   JR RA
9D037868  27BD0018   ADDIU SP, SP, 24
65:                  
66:                  /******************************************/
67:                  /* Mapper #41 write handler ($6000-$67FF) */
68:                  /******************************************/
69:                  static void map41_low_write (uint32 address, uint8 value)
70:                  {
9D03786C  27BDFFE8   ADDIU SP, SP, -24
9D037870  AFBF0014   SW RA, 20(SP)
71:                    /* Within this range the value written is irrelevant */
72:                    UNUSED (value);
73:                  
74:                    /* $6000-$67FF: A5    = mirroring (1=horizontal, 0=vertical)      */
75:                    /*              A4-A3 = high two bits of 8K CHR bank              */
76:                    /*              A2    = register 1 enable (0=disabled, 1=enabled) */
77:                    /*              A2-A0 = 32K PRG bank                              */
78:                    register_low = (uint8) (address & 0x3F);
9D037874  308600FF   ANDI A2, A0, 255
9D037878  30C2003F   ANDI V0, A2, 63
9D03787C  A38280D9   SB V0, -32551(GP)
79:                    mmc_bankrom (32, 0x8000, register_low & 0x07);
9D037880  24040020   ADDIU A0, ZERO, 32
9D037884  34058000   ORI A1, ZERO, -32768
9D037888  0F40B246   JAL mmc_bankrom
9D03788C  30C60007   ANDI A2, A2, 7
80:                    map41_set_chr ();
9D037890  0F40DDF4   JAL .LFB0, map41_set_chr, .LFE5
9D037894  00000000   NOP
81:                    if (register_low & 0x20) ppu_mirror(0, 0, 1, 1); /* horizontal */
9D037898  938280D9   LBU V0, -32551(GP)
9D03789C  30420020   ANDI V0, V0, 32
9D0378A0  304200FF   ANDI V0, V0, 255
9D0378A4  10400007   BEQ V0, ZERO, 0x9D0378C4
9D0378A8  00002021   ADDU A0, ZERO, ZERO
9D0378AC  00002821   ADDU A1, ZERO, ZERO
9D0378B0  24060001   ADDIU A2, ZERO, 1
9D0378B4  0F406128   JAL ppu_mirror
9D0378B8  24070001   ADDIU A3, ZERO, 1
9D0378BC  0B40DE36   J 0x9D0378D8
9D0378C0  8FBF0014   LW RA, 20(SP)
82:                    else                     ppu_mirror(0, 1, 0, 1); /* vertical */
9D0378C4  24050001   ADDIU A1, ZERO, 1
9D0378C8  00003021   ADDU A2, ZERO, ZERO
9D0378CC  0F406128   JAL ppu_mirror
9D0378D0  24070001   ADDIU A3, ZERO, 1
83:                  
84:                    /* Done */
85:                    return;
86:                  }
9D0378D4  8FBF0014   LW RA, 20(SP)
9D0378D8  03E00008   JR RA
9D0378DC  27BD0018   ADDIU SP, SP, 24
87:                  
88:                  /******************************************/
89:                  /* Mapper #41 write handler ($8000-$FFFF) */
90:                  /******************************************/
91:                  static void map41_high_write (uint32 address, uint8 value)
92:                  {
9D037804  27BDFFE8   ADDIU SP, SP, -24
9D037808  AFBF0014   SW RA, 20(SP)
93:                    /* Address doesn't matter within this range */
94:                    UNUSED (address);
95:                  
96:                    /* $8000-$FFFF: D1-D0 = low two bits of 8K CHR bank */
97:                    if (register_low & 0x04)
9D03780C  938280D9   LBU V0, -32551(GP)
9D037810  30420004   ANDI V0, V0, 4
9D037814  304200FF   ANDI V0, V0, 255
9D037818  10400005   BEQ V0, ZERO, 0x9D037830
9D03781C  8FBF0014   LW RA, 20(SP)
98:                    {
99:                      register_high = value & 0x03;
9D037820  30A50003   ANDI A1, A1, 3
100:                     map41_set_chr ();
9D037824  0F40DDF4   JAL .LFB0, map41_set_chr, .LFE5
9D037828  A38580D8   SB A1, -32552(GP)
101:                   }
102:                 
103:                   /* Done */
104:                   return;
105:                 }
9D03782C  8FBF0014   LW RA, 20(SP)
9D037830  03E00008   JR RA
9D037834  27BD0018   ADDIU SP, SP, 24
106:                 
107:                 /****************************************************/
108:                 /* Shove extra mapper information into a SNSS block */
109:                 /****************************************************/
110:                 static void map41_setstate (SnssMapperBlock *state)
111:                 {
9D0377C0  03E00008   JR RA
9D0377C4  00000000   NOP
112:                   /* TODO: Store SNSS information */
113:                   UNUSED (state);
114:                 
115:                   /* Done */
116:                   return;
117:                 }
118:                 
119:                 /*****************************************************/
120:                 /* Pull extra mapper information out of a SNSS block */
121:                 /*****************************************************/
122:                 static void map41_getstate (SnssMapperBlock *state)
123:                 {
9D0377C8  03E00008   JR RA
9D0377CC  00000000   NOP
124:                   /* TODO: Retrieve SNSS information */
125:                   UNUSED (state);
126:                 
127:                   /* Done */
128:                   return;
129:                 }
130:                 
131:                 static map_memwrite map41_memwrite [] =
132:                 {
133:                    { 0x6000, 0x67FF, map41_low_write },
134:                    { 0x8000, 0xFFFF, map41_high_write },
135:                    {     -1,     -1, NULL }
136:                 };
137:                 
138:                 mapintf_t map41_intf =
139:                 {
140:                    41,                               /* Mapper number */
141:                    "Caltron 6 in 1",                 /* Mapper name */
142:                    map41_init,                       /* Initialization routine */
143:                    NULL,                             /* VBlank callback */
144:                    NULL,                             /* HBlank callback */
145:                    map41_getstate,                   /* Get state (SNSS) */
146:                    map41_setstate,                   /* Set state (SNSS) */
147:                    NULL,                             /* Memory read structure */
148:                    map41_memwrite,                   /* Memory write structure */
149:                    NULL                              /* External sound device */
150:                 };
151:                 
152:                 /*
153:                 ** $Log: map041.c,v $
154:                 ** Revision 1.2  2001/04/27 14:37:11  neil
155:                 ** wheeee
156:                 **
157:                 ** Revision 1.1  2001/04/27 12:54:40  neil
158:                 ** blah
159:                 **
160:                 ** Revision 1.1  2001/04/27 10:57:41  neil
161:                 ** wheee
162:                 **
163:                 ** Revision 1.1  2000/12/30 00:33:15  firebug
164:                 ** initial revision
165:                 **
166:                 **
167:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map040.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map40.c
21:                  **
22:                  ** mapper 40 interface
23:                  ** $Id: map040.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes.h>
29:                  #include <libsnss.h>
30:                  #include <log.h>
31:                  
32:                  #define  MAP40_IRQ_PERIOD  (4096 / 113.666666)
33:                  
34:                  static struct
35:                  {
36:                     int enabled, counter;
37:                  } irq;
38:                  
39:                  /* mapper 40: SMB 2j (hack) */
40:                  static void map40_init(void)
41:                  {
9D037724  27BDFFE8   ADDIU SP, SP, -24
9D037728  AFBF0014   SW RA, 20(SP)
42:                     mmc_bankrom(8, 0x6000, 6);
9D03772C  24040008   ADDIU A0, ZERO, 8
9D037730  24056000   ADDIU A1, ZERO, 24576
9D037734  0F40B246   JAL mmc_bankrom
9D037738  24060006   ADDIU A2, ZERO, 6
43:                     mmc_bankrom(8, 0x8000, 4);
9D03773C  24040008   ADDIU A0, ZERO, 8
9D037740  34058000   ORI A1, ZERO, -32768
9D037744  0F40B246   JAL mmc_bankrom
9D037748  24060004   ADDIU A2, ZERO, 4
44:                     mmc_bankrom(8, 0xA000, 5);
9D03774C  24040008   ADDIU A0, ZERO, 8
9D037750  3405A000   ORI A1, ZERO, -24576
9D037754  0F40B246   JAL mmc_bankrom
9D037758  24060005   ADDIU A2, ZERO, 5
45:                     mmc_bankrom(8, 0xE000, 7);
9D03775C  24040008   ADDIU A0, ZERO, 8
9D037760  3405E000   ORI A1, ZERO, -8192
9D037764  0F40B246   JAL mmc_bankrom
9D037768  24060007   ADDIU A2, ZERO, 7
46:                  
47:                     irq.enabled = false;
9D03776C  AF808070   SW ZERO, -32656(GP)
48:                     irq.counter = (int) MAP40_IRQ_PERIOD;
9D037770  24020024   ADDIU V0, ZERO, 36
9D037774  AF828074   SW V0, -32652(GP)
49:                  }
9D037778  8FBF0014   LW RA, 20(SP)
9D03777C  03E00008   JR RA
9D037780  27BD0018   ADDIU SP, SP, 24
50:                  
51:                  static void map40_hblank(int vblank)
52:                  {
9D037784  27BDFFE8   ADDIU SP, SP, -24
9D037788  AFBF0014   SW RA, 20(SP)
53:                     UNUSED(vblank);
54:                  
55:                     if (irq.enabled && irq.counter)
9D03778C  8F828070   LW V0, -32656(GP)
9D037790  10400008   BEQ V0, ZERO, 0x9D0377B4
9D037794  8F828074   LW V0, -32652(GP)
9D037798  10400006   BEQ V0, ZERO, 0x9D0377B4
9D03779C  2442FFFF   ADDIU V0, V0, -1
56:                     {
57:                        irq.counter--;
58:                        if (0 == irq.counter)
9D0377A0  14400004   BNE V0, ZERO, 0x9D0377B4
9D0377A4  AF828074   SW V0, -32652(GP)
59:                        {
60:                           nes_irq();
9D0377A8  0F408A46   JAL nes_irq
9D0377AC  00000000   NOP
61:                           irq.enabled = false;
9D0377B0  AF808070   SW ZERO, -32656(GP)
62:                        }
63:                     }
64:                  }
9D0377B4  8FBF0014   LW RA, 20(SP)
9D0377B8  03E00008   JR RA
9D0377BC  27BD0018   ADDIU SP, SP, 24
65:                  
66:                  static void map40_write(uint32 address, uint8 value)
67:                  {
9D0376C4  27BDFFE8   ADDIU SP, SP, -24
68:                     int range = (address >> 13) - 4;
9D0376C8  00042342   SRL A0, A0, 13
9D0376CC  2484FFFC   ADDIU A0, A0, -4
69:                  
70:                     switch (range)
9D0376D0  24020001   ADDIU V0, ZERO, 1
9D0376D4  1082000A   BEQ A0, V0, 0x9D037700
9D0376D8  AFBF0014   SW RA, 20(SP)
9D0376DC  24020003   ADDIU V0, ZERO, 3
9D0376E0  10820009   BEQ A0, V0, 0x9D037708
9D0376E4  00A03021   ADDU A2, A1, ZERO
9D0376E8  1480000C   BNE A0, ZERO, 0x9D03771C
9D0376EC  8FBF0014   LW RA, 20(SP)
71:                     {
72:                     case 0: /* 0x8000-0x9FFF */
73:                        irq.enabled = false;
9D0376F0  AF808070   SW ZERO, -32656(GP)
74:                        irq.counter = (int) MAP40_IRQ_PERIOD;
9D0376F4  24020024   ADDIU V0, ZERO, 36
75:                        break;
9D0376F8  0B40DDC6   J .LVL8
9D0376FC  AF828074   SW V0, -32652(GP)
76:                  
77:                     case 1: /* 0xA000-0xBFFF */
78:                        irq.enabled = true;
79:                        break;
9D037700  0B40DDC6   J .LVL8
9D037704  AF828070   SW V0, -32656(GP)
80:                  
81:                     case 3: /* 0xE000-0xFFFF */
82:                        mmc_bankrom(8, 0xC000, value & 7);
9D037708  24040008   ADDIU A0, ZERO, 8
9D03770C  3405C000   ORI A1, ZERO, -16384
9D037710  0F40B246   JAL mmc_bankrom
9D037714  30C60007   ANDI A2, A2, 7
83:                        break;
84:                  
85:                     default:
86:                        break;
87:                     }
88:                  }
9D037718  8FBF0014   LW RA, 20(SP)
9D03771C  03E00008   JR RA
9D037720  27BD0018   ADDIU SP, SP, 24
89:                  
90:                  static void map40_getstate(SnssMapperBlock *state)
91:                  {
92:                     state->extraData.mapper40.irqCounter = irq.counter;
9D03769C  8F828074   LW V0, -32652(GP)
9D0376A0  A0820018   SB V0, 24(A0)
93:                     state->extraData.mapper40.irqCounterEnabled = irq.enabled;
9D0376A4  8F828070   LW V0, -32656(GP)
9D0376A8  03E00008   JR RA
9D0376AC  A0820019   SB V0, 25(A0)
94:                  }
95:                  
96:                  static void map40_setstate(SnssMapperBlock *state)
97:                  {
98:                     irq.counter = state->extraData.mapper40.irqCounter;
9D0376B0  90820018   LBU V0, 24(A0)
9D0376B4  AF828074   SW V0, -32652(GP)
99:                     irq.enabled = state->extraData.mapper40.irqCounterEnabled;
9D0376B8  90820019   LBU V0, 25(A0)
9D0376BC  03E00008   JR RA
9D0376C0  AF828070   SW V0, -32656(GP)
100:                 }
101:                 
102:                 static map_memwrite map40_memwrite[] =
103:                 {
104:                    { 0x8000, 0xFFFF, map40_write },
105:                    {     -1,     -1, NULL }
106:                 };
107:                 
108:                 mapintf_t map40_intf =
109:                 {
110:                    40, /* mapper number */
111:                    "SMB 2j (pirate)", /* mapper name */
112:                    map40_init, /* init routine */
113:                    NULL, /* vblank callback */
114:                    map40_hblank, /* hblank callback */
115:                    map40_getstate, /* get state (snss) */
116:                    map40_setstate, /* set state (snss) */
117:                    NULL, /* memory read structure */
118:                    map40_memwrite, /* memory write structure */
119:                    NULL /* external sound device */
120:                 };
121:                 
122:                 /*
123:                 ** $Log: map040.c,v $
124:                 ** Revision 1.2  2001/04/27 14:37:11  neil
125:                 ** wheeee
126:                 **
127:                 ** Revision 1.1  2001/04/27 12:54:40  neil
128:                 ** blah
129:                 **
130:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
131:                 ** initial
132:                 **
133:                 ** Revision 1.1  2000/10/24 12:19:33  matt
134:                 ** changed directory structure
135:                 **
136:                 ** Revision 1.9  2000/10/23 15:53:27  matt
137:                 ** suppressed warnings
138:                 **
139:                 ** Revision 1.8  2000/10/22 19:17:46  matt
140:                 ** mapper cleanups galore
141:                 **
142:                 ** Revision 1.7  2000/10/21 19:33:38  matt
143:                 ** many more cleanups
144:                 **
145:                 ** Revision 1.6  2000/10/10 13:58:17  matt
146:                 ** stroustrup squeezing his way in the door
147:                 **
148:                 ** Revision 1.5  2000/08/16 02:50:11  matt
149:                 ** random mapper cleanups
150:                 **
151:                 ** Revision 1.4  2000/07/15 23:52:19  matt
152:                 ** rounded out a bunch more mapper interfaces
153:                 **
154:                 ** Revision 1.3  2000/07/10 13:51:25  matt
155:                 ** using generic nes_irq() routine now
156:                 **
157:                 ** Revision 1.2  2000/07/06 02:48:43  matt
158:                 ** clearly labelled structure members
159:                 **
160:                 ** Revision 1.1  2000/07/05 05:05:18  matt
161:                 ** initial revision
162:                 **
163:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map034.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map34.c
21:                  **
22:                  ** mapper 34 interface
23:                  ** $Id: map034.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  
29:                  static void map34_init(void)
30:                  {
9D03A5F4  27BDFFE8   ADDIU SP, SP, -24
9D03A5F8  AFBF0014   SW RA, 20(SP)
31:                     mmc_bankrom(32, 0x8000, MMC_LASTBANK);
9D03A5FC  24040020   ADDIU A0, ZERO, 32
9D03A600  34058000   ORI A1, ZERO, -32768
9D03A604  0F40B246   JAL mmc_bankrom
9D03A608  2406FFFF   ADDIU A2, ZERO, -1
32:                  }
9D03A60C  8FBF0014   LW RA, 20(SP)
9D03A610  03E00008   JR RA
9D03A614  27BD0018   ADDIU SP, SP, 24
33:                  
34:                  static void map34_write(uint32 address, uint8 value)
35:                  {
9D03A618  27BDFFE8   ADDIU SP, SP, -24
9D03A61C  AFBF0014   SW RA, 20(SP)
36:                     if ((address & 0x8000) || (0x7FFD == address))
9D03A620  30828000   ANDI V0, A0, -32768
9D03A624  14400004   BNE V0, ZERO, 0x9D03A638
9D03A628  00A03021   ADDU A2, A1, ZERO
9D03A62C  24027FFD   ADDIU V0, ZERO, 32765
9D03A630  14820006   BNE A0, V0, 0x9D03A64C
9D03A634  24027FFE   ADDIU V0, ZERO, 32766
37:                     {
38:                        mmc_bankrom(32, 0x8000, value);
9D03A638  24040020   ADDIU A0, ZERO, 32
9D03A63C  0F40B246   JAL mmc_bankrom
9D03A640  34058000   ORI A1, ZERO, -32768
9D03A644  0B40E9A0   J 0x9D03A680
9D03A648  8FBF0014   LW RA, 20(SP)
39:                     }
40:                     else if (0x7FFE == address)
9D03A64C  14820006   BNE A0, V0, 0x9D03A668
9D03A650  24027FFF   ADDIU V0, ZERO, 32767
41:                     {
42:                        mmc_bankvrom(4, 0x0000, value);
9D03A654  24040004   ADDIU A0, ZERO, 4
9D03A658  0F40B1E8   JAL mmc_bankvrom
9D03A65C  00002821   ADDU A1, ZERO, ZERO
9D03A660  0B40E9A0   J 0x9D03A680
9D03A664  8FBF0014   LW RA, 20(SP)
43:                     }
44:                     else if (0x7FFF == address)
9D03A668  14820005   BNE A0, V0, 0x9D03A680
9D03A66C  8FBF0014   LW RA, 20(SP)
45:                     {
46:                        mmc_bankvrom(4, 0x1000, value);
9D03A670  24040004   ADDIU A0, ZERO, 4
9D03A674  0F40B1E8   JAL mmc_bankvrom
9D03A678  24051000   ADDIU A1, ZERO, 4096
47:                     }
48:                  }
9D03A67C  8FBF0014   LW RA, 20(SP)
9D03A680  03E00008   JR RA
9D03A684  27BD0018   ADDIU SP, SP, 24
49:                  
50:                  static map_memwrite map34_memwrite[] = 
51:                  {
52:                     { 0x7FFD, 0xFFFF, map34_write },
53:                     { -1, -1, NULL }
54:                  };
55:                  
56:                  mapintf_t map34_intf = 
57:                  {
58:                     34, /* mapper number */
59:                     "Nina-1", /* mapper name */
60:                     map34_init, /* init routine */
61:                     NULL, /* vblank callback */
62:                     NULL, /* hblank callback */
63:                     NULL, /* get state (snss) */
64:                     NULL, /* set state (snss) */
65:                     NULL, /* memory read structure */
66:                     map34_memwrite, /* memory write structure */
67:                     NULL /* external sound device */
68:                  };
69:                  
70:                  /*
71:                  ** $Log: map034.c,v $
72:                  ** Revision 1.2  2001/04/27 14:37:11  neil
73:                  ** wheeee
74:                  **
75:                  ** Revision 1.1  2001/04/27 12:54:40  neil
76:                  ** blah
77:                  **
78:                  ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
79:                  ** initial
80:                  **
81:                  ** Revision 1.1  2000/10/24 12:19:33  matt
82:                  ** changed directory structure
83:                  **
84:                  ** Revision 1.5  2000/10/22 19:17:46  matt
85:                  ** mapper cleanups galore
86:                  **
87:                  ** Revision 1.4  2000/10/21 19:33:38  matt
88:                  ** many more cleanups
89:                  **
90:                  ** Revision 1.3  2000/07/11 05:03:49  matt
91:                  ** value masking isn't necessary for the banking routines
92:                  **
93:                  ** Revision 1.2  2000/07/11 03:35:08  bsittler
94:                  ** Fixes to make mikes new mappers compile.
95:                  **
96:                  ** Revision 1.1  2000/07/11 03:14:18  melanson
97:                  ** Initial commit for mappers 16, 34, and 231
98:                  **
99:                  **
100:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map033.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map33.c
21:                  **
22:                  ** mapper 33 interface
23:                  ** $Id: map033.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes_ppu.h>
29:                  
30:                  /* mapper 33: Taito TC0190*/
31:                  static void map33_write(uint32 address, uint8 value)
32:                  {
9D037E5C  27BDFFE8   ADDIU SP, SP, -24
9D037E60  AFBF0014   SW RA, 20(SP)
33:                     int page = (address >> 13) & 3;
9D037E68  7C840B40   EXT A0, A0, 13, 2
34:                     int reg = address & 3;
9D037E64  30820003   ANDI V0, A0, 3
35:                  
36:                     switch (page)
9D037E6C  24030001   ADDIU V1, ZERO, 1
9D037E70  10830026   BEQ A0, V1, .LBB2
9D037E74  00A03021   ADDU A2, A1, ZERO
9D037E78  28830002   SLTI V1, A0, 2
9D037E7C  50600029   BEQL V1, ZERO, 0x9D037F24
9D037E80  2C420002   SLTIU V0, V0, 2
9D037E84  14800035   BNE A0, ZERO, .LVL23
9D037E88  24030001   ADDIU V1, ZERO, 1
37:                     {
38:                     case 0: /* $800X */
39:                        switch (reg)
9D037E8C  10430011   BEQ V0, V1, 0x9D037ED4
9D037E90  28430002   SLTI V1, V0, 2
9D037E94  50600005   BEQL V1, ZERO, 0x9D037EAC
9D037E98  24030002   ADDIU V1, ZERO, 2
9D037E9C  10400009   BEQ V0, ZERO, 0x9D037EC4
9D037EA0  24040008   ADDIU A0, ZERO, 8
9D037EAC  1043000E   BEQ V0, V1, 0x9D037EE8
9D037EB0  24030003   ADDIU V1, ZERO, 3
9D037EB4  10430011   BEQ V0, V1, 0x9D037EFC
9D037EB8  24040002   ADDIU A0, ZERO, 2
40:                        {
41:                        case 0:
42:                           mmc_bankrom(8, 0x8000, value);
9D037EC4  0F40B246   JAL mmc_bankrom
9D037EC8  34058000   ORI A1, ZERO, -32768
43:                           break;
9D037ECC  0B40DFD8   J 0x9D037F60
9D037ED0  8FBF0014   LW RA, 20(SP)
44:                  
45:                        case 1:
46:                           mmc_bankrom(8, 0xA000, value);
9D037ED4  24040008   ADDIU A0, ZERO, 8
9D037ED8  0F40B246   JAL mmc_bankrom
9D037EDC  3405A000   ORI A1, ZERO, -24576
47:                           break;
9D037EE0  0B40DFD8   J 0x9D037F60
9D037EE4  8FBF0014   LW RA, 20(SP)
48:                  
49:                        case 2:
50:                           mmc_bankvrom(2, 0x0000, value);
9D037EE8  24040002   ADDIU A0, ZERO, 2
9D037EEC  0F40B1E8   JAL mmc_bankvrom
9D037EF0  00002821   ADDU A1, ZERO, ZERO
51:                           break;
9D037EF4  0B40DFD8   J 0x9D037F60
9D037EF8  8FBF0014   LW RA, 20(SP)
52:                  
53:                        case 3:
54:                           mmc_bankvrom(2, 0x0800, value);
9D037EFC  0F40B1E8   JAL mmc_bankvrom
9D037F00  24050800   ADDIU A1, ZERO, 2048
55:                           break;
9D037F04  0B40DFD8   J 0x9D037F60
9D037F08  8FBF0014   LW RA, 20(SP)
56:                        }
57:                        break;
58:                  
59:                     case 1: /* $A00X */
60:                        {
61:                           int loc = 0x1000 + (reg << 10);
9D037F0C  00022A80   SLL A1, V0, 10
62:                           mmc_bankvrom(1, loc, value);
9D037F10  24040001   ADDIU A0, ZERO, 1
9D037F14  0F40B1E8   JAL mmc_bankvrom
9D037F18  24A51000   ADDIU A1, A1, 4096
63:                        }
64:                        break;
9D037F1C  0B40DFD8   J 0x9D037F60
9D037F20  8FBF0014   LW RA, 20(SP)
65:                  
66:                     case 2: /* $C00X */
67:                     case 3: /* $E00X */
68:                        switch (reg)
9D037F24  1040000D   BEQ V0, ZERO, .LVL23
9D037F28  30A60001   ANDI A2, A1, 1
69:                        {
70:                        case 0:
71:                           /* irqs maybe ? */
72:                           //break;
73:                        
74:                        case 1:
75:                           /* this doesn't seem to work just right */
76:                           if (value & 1)
9D037F2C  10C00007   BEQ A2, ZERO, 0x9D037F4C
9D037F30  00002021   ADDU A0, ZERO, ZERO
77:                              ppu_mirror(0, 0, 1, 1); /* horizontal */
9D037F34  00002821   ADDU A1, ZERO, ZERO
9D037F38  24060001   ADDIU A2, ZERO, 1
9D037F3C  0F406128   JAL ppu_mirror
9D037F40  24070001   ADDIU A3, ZERO, 1
9D037F44  0B40DFD8   J 0x9D037F60
9D037F48  8FBF0014   LW RA, 20(SP)
78:                           else
79:                              ppu_mirror(0, 1, 0, 1);
9D037F4C  24050001   ADDIU A1, ZERO, 1
9D037F50  00003021   ADDU A2, ZERO, ZERO
9D037F54  0F406128   JAL ppu_mirror
9D037F58  24070001   ADDIU A3, ZERO, 1
80:                           break;
81:                  
82:                        default:
83:                           break;
84:                        }
85:                        break;
86:                     }
87:                  }
9D037EA4  0B40DFD8   J 0x9D037F60
9D037EA8  8FBF0014   LW RA, 20(SP)
9D037EBC  0B40DFD8   J 0x9D037F60
9D037EC0  8FBF0014   LW RA, 20(SP)
9D037F5C  8FBF0014   LW RA, 20(SP)
9D037F60  03E00008   JR RA
9D037F64  27BD0018   ADDIU SP, SP, 24
88:                  
89:                  
90:                  static map_memwrite map33_memwrite[] =
91:                  {
92:                     { 0x8000, 0xFFFF, map33_write },
93:                     {     -1,     -1, NULL }
94:                  };
95:                  
96:                  mapintf_t map33_intf =
97:                  {
98:                     33, /* mapper number */
99:                     "Taito TC0190", /* mapper name */
100:                    NULL, /* init routine */
101:                    NULL, /* vblank callback */
102:                    NULL, /* hblank callback */
103:                    NULL, /* get state (snss) */
104:                    NULL, /* set state (snss) */
105:                    NULL, /* memory read structure */
106:                    map33_memwrite, /* memory write structure */
107:                    NULL /* external sound device */
108:                 };
109:                 
110:                 /*
111:                 ** $Log: map033.c,v $
112:                 ** Revision 1.2  2001/04/27 14:37:11  neil
113:                 ** wheeee
114:                 **
115:                 ** Revision 1.1  2001/04/27 12:54:40  neil
116:                 ** blah
117:                 **
118:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
119:                 ** initial
120:                 **
121:                 ** Revision 1.1  2000/10/24 12:19:33  matt
122:                 ** changed directory structure
123:                 **
124:                 ** Revision 1.7  2000/10/22 19:17:46  matt
125:                 ** mapper cleanups galore
126:                 **
127:                 ** Revision 1.6  2000/10/22 15:03:13  matt
128:                 ** simplified mirroring
129:                 **
130:                 ** Revision 1.5  2000/10/21 19:33:38  matt
131:                 ** many more cleanups
132:                 **
133:                 ** Revision 1.4  2000/07/15 23:52:19  matt
134:                 ** rounded out a bunch more mapper interfaces
135:                 **
136:                 ** Revision 1.3  2000/07/10 05:29:03  matt
137:                 ** cleaned up some mirroring issues
138:                 **
139:                 ** Revision 1.2  2000/07/06 02:48:43  matt
140:                 ** clearly labelled structure members
141:                 **
142:                 ** Revision 1.1  2000/07/06 01:01:56  matt
143:                 ** initial revision
144:                 **
145:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map032.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map32.c
21:                  **
22:                  ** mapper 32 interface
23:                  ** $Id: map032.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes_ppu.h>
29:                  
30:                  static int select_c000 = 0;
31:                  
32:                  /* mapper 32: Irem G-101 */
33:                  static void map32_write(uint32 address, uint8 value)
34:                  {
9D038890  27BDFFE8   ADDIU SP, SP, -24
9D038894  AFBF0014   SW RA, 20(SP)
9D038898  AFB00010   SW S0, 16(SP)
35:                     switch (address >> 12)
9D03889C  00041302   SRL V0, A0, 12
9D0388A0  24030009   ADDIU V1, ZERO, 9
9D0388A4  1043001B   BEQ V0, V1, 0x9D038914
9D0388A8  00A08021   ADDU S0, A1, ZERO
9D0388AC  2C43000A   SLTIU V1, V0, 10
9D0388B0  10600006   BEQ V1, ZERO, 0x9D0388CC
9D0388B4  2403000A   ADDIU V1, ZERO, 10
9D0388B8  24030008   ADDIU V1, ZERO, 8
9D0388BC  10430009   BEQ V0, V1, 0x9D0388E4
9D0388C0  8F828080   LW V0, -32640(GP)
9D0388CC  10430021   BEQ V0, V1, 0x9D038954
9D0388D0  2403000B   ADDIU V1, ZERO, 11
9D0388D4  10430025   BEQ V0, V1, .LBB2
9D0388D8  30850007   ANDI A1, A0, 7
36:                     {
37:                     case 0x08: 
38:                        if (select_c000)
9D0388E4  10400006   BEQ V0, ZERO, 0x9D038900
9D0388E8  24040008   ADDIU A0, ZERO, 8
39:                           mmc_bankrom(8, 0xC000, value);
9D0388EC  3405C000   ORI A1, ZERO, -16384
9D0388F0  0F40B246   JAL mmc_bankrom
9D0388F4  02003021   ADDU A2, S0, ZERO
9D0388F8  0B40E260   J 0x9D038980
9D0388FC  8FBF0014   LW RA, 20(SP)
40:                        else
41:                           mmc_bankrom(8, 0x8000, value);
9D038900  34058000   ORI A1, ZERO, -32768
9D038904  0F40B246   JAL mmc_bankrom
9D038908  02003021   ADDU A2, S0, ZERO
42:                        break;
43:                  
44:                     case 0x09: 
45:                        if (value & 1)
9D038914  30A20001   ANDI V0, A1, 1
9D038918  10400007   BEQ V0, ZERO, 0x9D038938
9D03891C  00002021   ADDU A0, ZERO, ZERO
46:                           ppu_mirror(0, 0, 1, 1); /* horizontal */
9D038920  00002821   ADDU A1, ZERO, ZERO
9D038924  24060001   ADDIU A2, ZERO, 1
9D038928  0F406128   JAL ppu_mirror
9D03892C  24070001   ADDIU A3, ZERO, 1
9D038930  0B40E253   J 0x9D03894C
9D038934  32100002   ANDI S0, S0, 2
47:                        else
48:                           ppu_mirror(0, 1, 0, 1); /* vertical */
9D038938  24050001   ADDIU A1, ZERO, 1
9D03893C  00003021   ADDU A2, ZERO, ZERO
9D038940  0F406128   JAL ppu_mirror
9D038944  24070001   ADDIU A3, ZERO, 1
49:                     
50:                        select_c000 = (value & 0x02);
9D038948  32100002   ANDI S0, S0, 2
51:                        break;
9D03894C  0B40E25F   J .LVL21, .LBE2
9D038950  AF908080   SW S0, -32640(GP)
52:                  
53:                     case 0x0A: 
54:                        mmc_bankrom(8, 0xA000, value); 
9D038954  24040008   ADDIU A0, ZERO, 8
9D038958  3405A000   ORI A1, ZERO, -24576
9D03895C  0F40B246   JAL mmc_bankrom
9D038960  02003021   ADDU A2, S0, ZERO
55:                        break;
9D038964  0B40E260   J 0x9D038980
9D038968  8FBF0014   LW RA, 20(SP)
56:                  
57:                     case 0x0B: 
58:                        {
59:                           int loc = (address & 0x07) << 10;
60:                           mmc_bankvrom(1, loc, value);
9D03896C  24040001   ADDIU A0, ZERO, 1
9D038970  00052A80   SLL A1, A1, 10
9D038974  0F40B1E8   JAL mmc_bankvrom
9D038978  02003021   ADDU A2, S0, ZERO
61:                        }
62:                        break;
63:                  
64:                     default:
65:                        break;
66:                     }
67:                  }
9D0388C4  0B40E260   J 0x9D038980
9D0388C8  8FBF0014   LW RA, 20(SP)
9D0388DC  0B40E260   J 0x9D038980
9D0388E0  8FBF0014   LW RA, 20(SP)
9D03890C  0B40E260   J 0x9D038980
9D038910  8FBF0014   LW RA, 20(SP)
9D03897C  8FBF0014   LW RA, 20(SP)
9D038980  8FB00010   LW S0, 16(SP)
9D038984  03E00008   JR RA
9D038988  27BD0018   ADDIU SP, SP, 24
68:                  
69:                  static map_memwrite map32_memwrite[] =
70:                  {
71:                     { 0x8000, 0xFFFF, map32_write },
72:                     {     -1,     -1, NULL }
73:                  };
74:                  
75:                  mapintf_t map32_intf =
76:                  {
77:                     32, /* mapper number */
78:                     "Irem G-101", /* mapper name */
79:                     NULL, /* init routine */
80:                     NULL, /* vblank callback */
81:                     NULL, /* hblank callback */
82:                     NULL, /* get state (snss) */
83:                     NULL, /* set state (snss) */
84:                     NULL, /* memory read structure */
85:                     map32_memwrite, /* memory write structure */
86:                     NULL /* external sound device */
87:                  };
88:                  
89:                  /*
90:                  ** $Log: map032.c,v $
91:                  ** Revision 1.2  2001/04/27 14:37:11  neil
92:                  ** wheeee
93:                  **
94:                  ** Revision 1.1  2001/04/27 12:54:40  neil
95:                  ** blah
96:                  **
97:                  ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
98:                  ** initial
99:                  **
100:                 ** Revision 1.1  2000/10/24 12:19:33  matt
101:                 ** changed directory structure
102:                 **
103:                 ** Revision 1.6  2000/10/22 19:17:46  matt
104:                 ** mapper cleanups galore
105:                 **
106:                 ** Revision 1.5  2000/10/22 15:03:13  matt
107:                 ** simplified mirroring
108:                 **
109:                 ** Revision 1.4  2000/10/21 19:33:38  matt
110:                 ** many more cleanups
111:                 **
112:                 ** Revision 1.3  2000/07/10 05:29:03  matt
113:                 ** cleaned up some mirroring issues
114:                 **
115:                 ** Revision 1.2  2000/07/06 02:48:43  matt
116:                 ** clearly labelled structure members
117:                 **
118:                 ** Revision 1.1  2000/07/06 01:01:56  matt
119:                 ** initial revision
120:                 **
121:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map024.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map24.c
21:                  **
22:                  ** mapper 24 interface
23:                  ** $Id: map024.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes.h>
29:                  #include <log.h>
30:                  #include <vrcvisnd.h>
31:                  
32:                  static struct
33:                  {
34:                     int counter, enabled;
35:                     int latch, wait_state;
36:                  } irq;
37:                  
38:                  static void map24_init(void)
39:                  {
40:                     irq.counter = irq.enabled = 0;
9D031934  3C03A001   LUI V1, -24575
9D031938  2462B8F4   ADDIU V0, V1, -18188
9D03193C  AC400004   SW ZERO, 4(V0)
9D031940  AC60B8F4   SW ZERO, -18188(V1)
41:                     irq.latch = irq.wait_state = 0;
9D031944  AC40000C   SW ZERO, 12(V0)
9D031948  03E00008   JR RA
9D03194C  AC400008   SW ZERO, 8(V0)
42:                  }
43:                  
44:                  static void map24_hblank(int vblank) 
45:                  {
9D031C40  27BDFFE8   ADDIU SP, SP, -24
9D031C44  AFBF0014   SW RA, 20(SP)
9D031C48  AFB00010   SW S0, 16(SP)
46:                     UNUSED(vblank);
47:                  
48:                     if (irq.enabled)
9D031C18  3C02A001   LUI V0, -24575
9D031C1C  8C42B8F8   LW V0, -18184(V0)
9D031C20  10400013   BEQ V0, ZERO, 0x9D031C70
9D031C24  3C03A001   LUI V1, -24575
49:                     {
50:                        if (256 == ++irq.counter)
9D031C28  8C62B8F4   LW V0, -18188(V1)
9D031C2C  24420001   ADDIU V0, V0, 1
9D031C30  AC62B8F4   SW V0, -18188(V1)
9D031C34  24030100   ADDIU V1, ZERO, 256
9D031C38  1443000D   BNE V0, V1, 0x9D031C70
9D031C3C  3C02A001   LUI V0, -24575
51:                        {
52:                           irq.counter = irq.latch;
9D031C4C  2450B8F4   ADDIU S0, V0, -18188
9D031C50  8E030008   LW V1, 8(S0)
53:                           nes_irq();
9D031C54  0F408A46   JAL nes_irq
9D031C58  AC43B8F4   SW V1, -18188(V0)
54:                           //irq.enabled = false;
55:                           irq.enabled = irq.wait_state;
9D031C5C  8E02000C   LW V0, 12(S0)
9D031C60  AE020004   SW V0, 4(S0)
56:                        }
57:                     }
58:                  }
9D031C64  8FBF0014   LW RA, 20(SP)
9D031C68  8FB00010   LW S0, 16(SP)
9D031C6C  27BD0018   ADDIU SP, SP, 24
9D031C70  03E00008   JR RA
9D031C74  00000000   NOP
59:                  
60:                  static void map24_write(uint32 address, uint8 value)
61:                  {
9D031988  27BDFFE8   ADDIU SP, SP, -24
9D03198C  AFBF0014   SW RA, 20(SP)
62:                     switch (address & 0xF003)
9D031990  3084F003   ANDI A0, A0, -4093
9D031994  3402D003   ORI V0, ZERO, -12285
9D031998  10820073   BEQ A0, V0, 0x9D031B68
9D03199C  00A03021   ADDU A2, A1, ZERO
9D0319A0  3402D004   ORI V0, ZERO, -12284
9D0319A4  0082102B   SLTU V0, A0, V0
9D0319A8  10400017   BEQ V0, ZERO, 0x9D031A08
9D0319AC  3402E003   ORI V0, ZERO, -8189
9D0319B0  3402C000   ORI V0, ZERO, -16384
9D0319B4  10820059   BEQ A0, V0, 0x9D031B1C
9D0319B8  3402C001   ORI V0, ZERO, -16383
9D0319BC  0082102B   SLTU V0, A0, V0
9D0319C0  10400008   BEQ V0, ZERO, 0x9D0319E4
9D0319C4  3402D001   ORI V0, ZERO, -12287
9D0319C8  34028000   ORI V0, ZERO, -32768
9D0319CC  10820025   BEQ A0, V0, 0x9D031A64
9D0319D0  3402B003   ORI V0, ZERO, -20477
9D0319D4  50820028   BEQL A0, V0, 0x9D031A78
9D0319D8  30A6000C   ANDI A2, A1, 12
9D0319E4  10820056   BEQ A0, V0, 0x9D031B40
9D0319E8  3402D002   ORI V0, ZERO, -12286
9D0319EC  0082102B   SLTU V0, A0, V0
9D0319F0  10400058   BEQ V0, ZERO, 0x9D031B54
9D0319F4  3402D000   ORI V0, ZERO, -12288
9D0319F8  1082004D   BEQ A0, V0, 0x9D031B30
9D0319FC  24040001   ADDIU A0, ZERO, 1
9D031A08  1082006A   BEQ A0, V0, 0x9D031BB4
9D031A0C  3402E004   ORI V0, ZERO, -8188
9D031A10  0082102B   SLTU V0, A0, V0
9D031A14  1040000A   BEQ V0, ZERO, 0x9D031A40
9D031A18  3402E001   ORI V0, ZERO, -8191
9D031A1C  1082005B   BEQ A0, V0, 0x9D031B8C
9D031A20  3402E002   ORI V0, ZERO, -8190
9D031A24  0082102B   SLTU V0, A0, V0
9D031A28  1040005D   BEQ V0, ZERO, 0x9D031BA0
9D031A2C  3402E000   ORI V0, ZERO, -8192
9D031A30  10820052   BEQ A0, V0, 0x9D031B7C
9D031A34  24040001   ADDIU A0, ZERO, 1
9D031A40  3402F001   ORI V0, ZERO, -4095
9D031A44  10820062   BEQ A0, V0, 0x9D031BD0
9D031A48  3402F002   ORI V0, ZERO, -4094
9D031A4C  1082006B   BEQ A0, V0, 0x9D031BFC
9D031A50  3402F000   ORI V0, ZERO, -4096
9D031A54  1482006E   BNE A0, V0, 0x9D031C10
9D031A58  8FBF0014   LW RA, 20(SP)
63:                     {
64:                     case 0x8000:
65:                        mmc_bankrom(16, 0x8000, value);
9D031A64  24040010   ADDIU A0, ZERO, 16
9D031A68  0F40B246   JAL mmc_bankrom
9D031A6C  34058000   ORI A1, ZERO, -32768
66:                        break;
9D031A70  0B40C704   J 0x9D031C10
9D031A74  8FBF0014   LW RA, 20(SP)
67:                  
68:                     case 0x9003:
69:                        /* ??? */
70:                        break;
71:                     
72:                     case 0xB003:
73:                        switch (value & 0x0C)
9D031A78  24020004   ADDIU V0, ZERO, 4
9D031A7C  10C20013   BEQ A2, V0, 0x9D031ACC
9D031A80  2CC20005   SLTIU V0, A2, 5
9D031A84  50400005   BEQL V0, ZERO, 0x9D031A9C
9D031A88  24020008   ADDIU V0, ZERO, 8
9D031A8C  10C00009   BEQ A2, ZERO, 0x9D031AB4
9D031A90  00002021   ADDU A0, ZERO, ZERO
9D031A9C  10C20012   BEQ A2, V0, 0x9D031AE8
9D031AA0  2402000C   ADDIU V0, ZERO, 12
9D031AA4  10C20017   BEQ A2, V0, 0x9D031B04
9D031AA8  24040001   ADDIU A0, ZERO, 1
74:                        {
75:                        case 0x00:
76:                           ppu_mirror(0, 1, 0, 1); /* vertical */
9D031AB4  24050001   ADDIU A1, ZERO, 1
9D031AB8  00003021   ADDU A2, ZERO, ZERO
9D031ABC  0F406128   JAL ppu_mirror
9D031AC0  24070001   ADDIU A3, ZERO, 1
77:                           break;
9D031AC4  0B40C704   J 0x9D031C10
9D031AC8  8FBF0014   LW RA, 20(SP)
78:                        
79:                        case 0x04:
80:                           ppu_mirror(0, 0, 1, 1); /* horizontal */
9D031ACC  00002021   ADDU A0, ZERO, ZERO
9D031AD0  00002821   ADDU A1, ZERO, ZERO
9D031AD4  24060001   ADDIU A2, ZERO, 1
9D031AD8  0F406128   JAL ppu_mirror
9D031ADC  24070001   ADDIU A3, ZERO, 1
81:                           break;
9D031AE0  0B40C704   J 0x9D031C10
9D031AE4  8FBF0014   LW RA, 20(SP)
82:                        
83:                        case 0x08:
84:                           ppu_mirror(0, 0, 0, 0);
9D031AE8  00002021   ADDU A0, ZERO, ZERO
9D031AEC  00002821   ADDU A1, ZERO, ZERO
9D031AF0  00003021   ADDU A2, ZERO, ZERO
9D031AF4  0F406128   JAL ppu_mirror
9D031AF8  00003821   ADDU A3, ZERO, ZERO
85:                           break;
9D031AFC  0B40C704   J 0x9D031C10
9D031B00  8FBF0014   LW RA, 20(SP)
86:                        
87:                        case 0x0C:
88:                           ppu_mirror(1, 1, 1, 1);
9D031B04  24050001   ADDIU A1, ZERO, 1
9D031B08  24060001   ADDIU A2, ZERO, 1
9D031B0C  0F406128   JAL ppu_mirror
9D031B10  24070001   ADDIU A3, ZERO, 1
89:                           break;
9D031B14  0B40C704   J 0x9D031C10
9D031B18  8FBF0014   LW RA, 20(SP)
90:                        
91:                        default:
92:                           break;
93:                        }
94:                        break;
95:                     
96:                  
97:                     case 0xC000:
98:                        mmc_bankrom(8, 0xC000, value);
9D031B1C  24040008   ADDIU A0, ZERO, 8
9D031B20  0F40B246   JAL mmc_bankrom
9D031B24  3405C000   ORI A1, ZERO, -16384
99:                        break;
9D031B28  0B40C704   J 0x9D031C10
9D031B2C  8FBF0014   LW RA, 20(SP)
100:                    
101:                    case 0xD000:
102:                       mmc_bankvrom(1, 0x0000, value);
9D031B30  0F40B1E8   JAL mmc_bankvrom
9D031B34  00002821   ADDU A1, ZERO, ZERO
103:                       break;
9D031B38  0B40C704   J 0x9D031C10
9D031B3C  8FBF0014   LW RA, 20(SP)
104:                    
105:                    case 0xD001:
106:                       mmc_bankvrom(1, 0x0400, value);
9D031B40  24040001   ADDIU A0, ZERO, 1
9D031B44  0F40B1E8   JAL mmc_bankvrom
9D031B48  24050400   ADDIU A1, ZERO, 1024
107:                       break;
9D031B4C  0B40C704   J 0x9D031C10
9D031B50  8FBF0014   LW RA, 20(SP)
108:                    
109:                    case 0xD002:
110:                       mmc_bankvrom(1, 0x0800, value);
9D031B54  24040001   ADDIU A0, ZERO, 1
9D031B58  0F40B1E8   JAL mmc_bankvrom
9D031B5C  24050800   ADDIU A1, ZERO, 2048
111:                       break;
9D031B60  0B40C704   J 0x9D031C10
9D031B64  8FBF0014   LW RA, 20(SP)
112:                    
113:                    case 0xD003:
114:                       mmc_bankvrom(1, 0x0C00, value);
9D031B68  24040001   ADDIU A0, ZERO, 1
9D031B6C  0F40B1E8   JAL mmc_bankvrom
9D031B70  24050C00   ADDIU A1, ZERO, 3072
115:                       break;
9D031B74  0B40C704   J 0x9D031C10
9D031B78  8FBF0014   LW RA, 20(SP)
116:                    
117:                    case 0xE000:
118:                       mmc_bankvrom(1, 0x1000, value);
9D031B7C  0F40B1E8   JAL mmc_bankvrom
9D031B80  24051000   ADDIU A1, ZERO, 4096
119:                       break;
9D031B84  0B40C704   J 0x9D031C10
9D031B88  8FBF0014   LW RA, 20(SP)
120:                    
121:                    case 0xE001:
122:                       mmc_bankvrom(1, 0x1400, value);
9D031B8C  24040001   ADDIU A0, ZERO, 1
9D031B90  0F40B1E8   JAL mmc_bankvrom
9D031B94  24051400   ADDIU A1, ZERO, 5120
123:                       break;
9D031B98  0B40C704   J 0x9D031C10
9D031B9C  8FBF0014   LW RA, 20(SP)
124:                    
125:                    case 0xE002:
126:                       mmc_bankvrom(1, 0x1800, value);
9D031BA0  24040001   ADDIU A0, ZERO, 1
9D031BA4  0F40B1E8   JAL mmc_bankvrom
9D031BA8  24051800   ADDIU A1, ZERO, 6144
127:                       break;
9D031BAC  0B40C704   J 0x9D031C10
9D031BB0  8FBF0014   LW RA, 20(SP)
128:                    
129:                    case 0xE003:
130:                       mmc_bankvrom(1, 0x1C00, value);
9D031BB4  24040001   ADDIU A0, ZERO, 1
9D031BB8  0F40B1E8   JAL mmc_bankvrom
9D031BBC  24051C00   ADDIU A1, ZERO, 7168
131:                       break;
9D031BC0  0B40C704   J 0x9D031C10
9D031BC4  8FBF0014   LW RA, 20(SP)
132:                    
133:                    case 0xF000:
134:                       irq.latch = value;
9D031A5C  0B40C6F2   J 0x9D031BC8
9D031A60  3C02A001   LUI V0, -24575
135:                       break;
9D031BC8  0B40C703   J 0x9D031C0C
9D031BCC  AC45B8FC   SW A1, -18180(V0)
136:                    
137:                    case 0xF001:
138:                       irq.enabled = (value >> 1) & 0x01;
9D031BD0  7CA20040   EXT V0, A1, 1, 1
9D031BD4  3C03A001   LUI V1, -24575
9D031BD8  2463B8F4   ADDIU V1, V1, -18188
9D031BDC  AC620004   SW V0, 4(V1)
139:                       irq.wait_state = value & 0x01;
9D031BE0  30A60001   ANDI A2, A1, 1
140:                       if (irq.enabled)
9D031BE4  10400009   BEQ V0, ZERO, 0x9D031C0C
9D031BE8  AC66000C   SW A2, 12(V1)
141:                          irq.counter = irq.latch;
9D031BEC  3C02A001   LUI V0, -24575
9D031BF0  8C630008   LW V1, 8(V1)
9D031BF4  0B40C703   J 0x9D031C0C
9D031BF8  AC43B8F4   SW V1, -18188(V0)
142:                       break;
143:                    
144:                    case 0xF002:
145:                       irq.enabled = irq.wait_state;
9D031BFC  3C02A001   LUI V0, -24575
9D031C00  2442B8F4   ADDIU V0, V0, -18188
9D031C04  8C43000C   LW V1, 12(V0)
9D031C08  AC430004   SW V1, 4(V0)
146:                       break;
147:                    
148:                    default:
149:                 #ifdef NOFRENDO_DEBUG
150:                       log_printf("invalid VRC6 write: $%02X to $%04X", value, address);
151:                 #endif
152:                       break;      
153:                    }
154:                 }
9D0319DC  0B40C704   J 0x9D031C10
9D0319E0  8FBF0014   LW RA, 20(SP)
9D031A00  0B40C704   J 0x9D031C10
9D031A04  8FBF0014   LW RA, 20(SP)
9D031A38  0B40C704   J 0x9D031C10
9D031A3C  8FBF0014   LW RA, 20(SP)
9D031A94  0B40C704   J 0x9D031C10
9D031A98  8FBF0014   LW RA, 20(SP)
9D031AAC  0B40C704   J 0x9D031C10
9D031AB0  8FBF0014   LW RA, 20(SP)
9D031C0C  8FBF0014   LW RA, 20(SP)
9D031C10  03E00008   JR RA
9D031C14  27BD0018   ADDIU SP, SP, 24
155:                 
156:                 static void map24_getstate(SnssMapperBlock *state)
157:                 {
158:                    state->extraData.mapper24.irqCounter = irq.counter;
9D031950  3C02A001   LUI V0, -24575
9D031954  8C43B8F4   LW V1, -18188(V0)
9D031958  A0830018   SB V1, 24(A0)
159:                    state->extraData.mapper24.irqCounterEnabled = irq.enabled;
9D03195C  2442B8F4   ADDIU V0, V0, -18188
9D031960  8C420004   LW V0, 4(V0)
9D031964  03E00008   JR RA
9D031968  A0820019   SB V0, 25(A0)
160:                 }
161:                 
162:                 static void map24_setstate(SnssMapperBlock *state)
163:                 {
164:                    irq.counter = state->extraData.mapper24.irqCounter;
9D03196C  3C02A001   LUI V0, -24575
9D031970  90830018   LBU V1, 24(A0)
9D031974  AC43B8F4   SW V1, -18188(V0)
165:                    irq.enabled = state->extraData.mapper24.irqCounterEnabled;
9D031978  2442B8F4   ADDIU V0, V0, -18188
9D03197C  90830019   LBU V1, 25(A0)
9D031980  03E00008   JR RA
9D031984  AC430004   SW V1, 4(V0)
166:                 }
167:                 
168:                 static map_memwrite map24_memwrite[] =
169:                 {
170:                    { 0x8000, 0xF002, map24_write },
171:                    {     -1,     -1, NULL }
172:                 };
173:                 
174:                 mapintf_t map24_intf =
175:                 {
176:                    24, /* mapper number */
177:                    "Konami VRC6", /* mapper name */
178:                    map24_init, /* init routine */
179:                    NULL, /* vblank callback */
180:                    map24_hblank, /* hblank callback */
181:                    map24_getstate, /* get state (snss) */
182:                    map24_setstate, /* set state (snss) */
183:                    NULL, /* memory read structure */
184:                    map24_memwrite, /* memory write structure */
185:                    &vrcvi_ext /* external sound device */
186:                 };
187:                 
188:                 /*
189:                 ** $Log: map024.c,v $
190:                 ** Revision 1.2  2001/04/27 14:37:11  neil
191:                 ** wheeee
192:                 **
193:                 ** Revision 1.1  2001/04/27 12:54:40  neil
194:                 ** blah
195:                 **
196:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
197:                 ** initial
198:                 **
199:                 ** Revision 1.1  2000/10/24 12:19:33  matt
200:                 ** changed directory structure
201:                 **
202:                 ** Revision 1.11  2000/10/22 19:17:46  matt
203:                 ** mapper cleanups galore
204:                 **
205:                 ** Revision 1.10  2000/10/22 15:03:13  matt
206:                 ** simplified mirroring
207:                 **
208:                 ** Revision 1.9  2000/10/21 19:33:38  matt
209:                 ** many more cleanups
210:                 **
211:                 ** Revision 1.8  2000/10/10 13:58:17  matt
212:                 ** stroustrup squeezing his way in the door
213:                 **
214:                 ** Revision 1.7  2000/10/09 12:00:53  matt
215:                 ** removed old code
216:                 **
217:                 ** Revision 1.6  2000/08/16 02:50:11  matt
218:                 ** random mapper cleanups
219:                 **
220:                 ** Revision 1.5  2000/07/15 23:52:19  matt
221:                 ** rounded out a bunch more mapper interfaces
222:                 **
223:                 ** Revision 1.4  2000/07/10 13:51:25  matt
224:                 ** using generic nes_irq() routine now
225:                 **
226:                 ** Revision 1.3  2000/07/10 05:29:03  matt
227:                 ** cleaned up some mirroring issues
228:                 **
229:                 ** Revision 1.2  2000/07/06 02:48:43  matt
230:                 ** clearly labelled structure members
231:                 **
232:                 ** Revision 1.1  2000/07/04 23:11:45  matt
233:                 ** initial revision
234:                 **
235:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map019.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map19.c
21:                  **
22:                  ** mapper 19 interface
23:                  ** $Id: map019.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes_ppu.h>
29:                  
30:                  /* TODO: shouldn't there be an h-blank IRQ handler??? */
31:                  
32:                  /* Special mirroring macro for mapper 19 */
33:                  #define N_BANK1(table, value) \
34:                  { \
35:                     if ((value) < 0xE0) \
36:                        ppu_setpage(1, (table) + 8, &mmc_getinfo()->vrom[((value) % (mmc_getinfo()->vrom_banks * 8)) << 10] - (0x2000 + ((table) << 10))); \
37:                     else \
38:                        ppu_setpage(1, (table) + 8, &mmc_getinfo()->vram[((value) & 7) << 10] - (0x2000 + ((table) << 10))); \
39:                     ppu_mirrorhipages(); \
40:                  }
41:                  
42:                  static struct
43:                  {
44:                     int counter, enabled;
45:                  } irq;
46:                  
47:                  static void map19_init(void)
48:                  {
49:                     irq.counter = irq.enabled = 0;
9D034B38  AF80807C   SW ZERO, -32644(GP)
9D034B3C  03E00008   JR RA
9D034B40  AF808078   SW ZERO, -32648(GP)
50:                  }
51:                  
52:                  /* mapper 19: Namcot 106 */
53:                  static void map19_write(uint32 address, uint8 value)
54:                  {
9D034B94  27BDFFE0   ADDIU SP, SP, -32
9D034B98  AFBF001C   SW RA, 28(SP)
9D034B9C  AFB20018   SW S2, 24(SP)
9D034BA0  AFB10014   SW S1, 20(SP)
9D034BA4  AFB00010   SW S0, 16(SP)
55:                     int reg = address >> 11;
9D034B80  000422C2   SRL A0, A0, 11
56:                     switch (reg)
9D034B84  2482FFF6   ADDIU V0, A0, -10
9D034B88  2C430015   SLTIU V1, V0, 21
9D034B8C  10600072   BEQ V1, ZERO, 0x9D034D58
9D034B90  00021080   SLL V0, V0, 2
9D034BA8  3C039D03   LUI V1, -25341
9D034BAC  24634BC0   ADDIU V1, V1, 19392
9D034BB0  00621021   ADDU V0, V1, V0
9D034BB4  8C420000   LW V0, 0(V0)
9D034BB8  00400008   JR V0
9D034BBC  00A08021   ADDU S0, A1, ZERO
57:                     {
58:                     case 0xA:
59:                        irq.counter &= ~0xFF;
9D034C18  8C430000   LW V1, 0(V0)
9D034C1C  7C033804   INS V1, ZERO, 0, 8
60:                        irq.counter |= value;
9D034C14  27828078   ADDIU V0, GP, -32648
9D034C20  00A38025   OR S0, A1, V1
61:                        break;
9D034C24  0B40D351   J .LVL28
9D034C28  AC500000   SW S0, 0(V0)
62:                     
63:                     case 0xB:
64:                        irq.counter = ((value & 0x7F) << 8) | (irq.counter & 0xFF);
9D034C2C  27828078   ADDIU V0, GP, -32648
9D034C30  30A3007F   ANDI V1, A1, 127
9D034C34  00031A00   SLL V1, V1, 8
9D034C38  90440000   LBU A0, 0(V0)
9D034C3C  00641825   OR V1, V1, A0
9D034C40  AC430000   SW V1, 0(V0)
65:                        irq.enabled = (value & 0x80) ? true : false;
9D034C44  000581C2   SRL S0, A1, 7
66:                        break;
9D034C48  0B40D351   J .LVL28
9D034C4C  AF90807C   SW S0, -32644(GP)
67:                  
68:                     case 0x10:
69:                     case 0x11:
70:                     case 0x12:
71:                     case 0x13:
72:                     case 0x14:
73:                     case 0x15:
74:                     case 0x16:
75:                     case 0x17:
76:                        mmc_bankvrom(1, (reg & 7) << 10, value);
9D034C50  30850007   ANDI A1, A0, 7
9D034C54  24040001   ADDIU A0, ZERO, 1
9D034C58  00052A80   SLL A1, A1, 10
9D034C5C  0F40B1E8   JAL mmc_bankvrom
9D034C60  02003021   ADDU A2, S0, ZERO
77:                        break;
9D034C64  0B40D352   J 0x9D034D48
9D034C68  8FBF001C   LW RA, 28(SP)
78:                  
79:                     case 0x18:
80:                     case 0x19:
81:                     case 0x1A:
82:                     case 0x1B:
83:                        N_BANK1(reg & 3, value);
9D034C6C  2CA200E0   SLTIU V0, A1, 224
9D034C70  10400014   BEQ V0, ZERO, 0x9D034CC4
9D034C74  00000000   NOP
9D034C78  0F40B1DC   JAL mmc_getinfo
9D034C7C  30910003   ANDI S1, A0, 3
9D034C80  0F40B1DC   JAL mmc_getinfo
9D034C84  8C520004   LW S2, 4(V0)
9D034C88  8C420014   LW V0, 20(V0)
9D034C8C  000210C0   SLL V0, V0, 3
9D034C90  0202001A   DIV S0, V0
9D034C94  004001F4   TEQ V0, ZERO
9D034C98  00003010   MFHI A2
9D034C9C  00063280   SLL A2, A2, 10
9D034CA0  24C6E000   ADDIU A2, A2, -8192
9D034CA4  00111280   SLL V0, S1, 10
9D034CA8  00C23023   SUBU A2, A2, V0
9D034CAC  24040001   ADDIU A0, ZERO, 1
9D034CB0  26250008   ADDIU A1, S1, 8
9D034CB4  0F4060DF   JAL ppu_setpage
9D034CB8  02463021   ADDU A2, S2, A2
9D034CBC  0B40D33D   J .LVL15
9D034CC0  00000000   NOP
9D034CC4  0F40B1DC   JAL mmc_getinfo
9D034CC8  30910003   ANDI S1, A0, 3
9D034CCC  32040007   ANDI A0, S0, 7
9D034CD0  00042280   SLL A0, A0, 10
9D034CD4  2484E000   ADDIU A0, A0, -8192
9D034CD8  00111A80   SLL V1, S1, 10
9D034CDC  00831823   SUBU V1, A0, V1
9D034CE0  8C46000C   LW A2, 12(V0)
9D034CE4  24040001   ADDIU A0, ZERO, 1
9D034CE8  26250008   ADDIU A1, S1, 8
9D034CEC  0F4060DF   JAL ppu_setpage
9D034CF0  00C33021   ADDU A2, A2, V1
9D034CF4  0F406119   JAL ppu_mirrorhipages
9D034CF8  00000000   NOP
84:                        break;
9D034CFC  0B40D352   J 0x9D034D48
9D034D00  8FBF001C   LW RA, 28(SP)
85:                  
86:                     case 0x1C:
87:                        mmc_bankrom(8, 0x8000, value);
9D034D04  24040008   ADDIU A0, ZERO, 8
9D034D08  34058000   ORI A1, ZERO, -32768
9D034D0C  0F40B246   JAL mmc_bankrom
9D034D10  02003021   ADDU A2, S0, ZERO
88:                        break;
9D034D14  0B40D352   J 0x9D034D48
9D034D18  8FBF001C   LW RA, 28(SP)
89:                  
90:                     case 0x1D:
91:                        mmc_bankrom(8, 0xA000, value);
9D034D1C  24040008   ADDIU A0, ZERO, 8
9D034D20  3405A000   ORI A1, ZERO, -24576
9D034D24  0F40B246   JAL mmc_bankrom
9D034D28  02003021   ADDU A2, S0, ZERO
92:                        break;
9D034D2C  0B40D352   J 0x9D034D48
9D034D30  8FBF001C   LW RA, 28(SP)
93:                     
94:                     case 0x1E:
95:                        mmc_bankrom(8, 0xC000, value);
9D034D34  24040008   ADDIU A0, ZERO, 8
9D034D38  3405C000   ORI A1, ZERO, -16384
9D034D3C  0F40B246   JAL mmc_bankrom
9D034D40  02003021   ADDU A2, S0, ZERO
96:                        break;
97:                     
98:                     default:
99:                        break;
100:                    }
101:                 }
9D034D44  8FBF001C   LW RA, 28(SP)
9D034D48  8FB20018   LW S2, 24(SP)
9D034D4C  8FB10014   LW S1, 20(SP)
9D034D50  8FB00010   LW S0, 16(SP)
9D034D54  27BD0020   ADDIU SP, SP, 32
9D034D58  03E00008   JR RA
9D034D5C  00000000   NOP
102:                 
103:                 static void map19_getstate(SnssMapperBlock *state)
104:                 {
105:                    state->extraData.mapper19.irqCounterLowByte = irq.counter & 0xFF;
9D034B44  8F828078   LW V0, -32648(GP)
9D034B48  A0820018   SB V0, 24(A0)
106:                    state->extraData.mapper19.irqCounterHighByte = irq.counter >> 8;
9D034B4C  00021203   SRA V0, V0, 8
9D034B50  A0820019   SB V0, 25(A0)
107:                    state->extraData.mapper19.irqCounterEnabled = irq.enabled;
9D034B54  8F82807C   LW V0, -32644(GP)
9D034B58  03E00008   JR RA
9D034B5C  A082001A   SB V0, 26(A0)
108:                 }
109:                 
110:                 static void map19_setstate(SnssMapperBlock *state)
111:                 {
112:                    irq.counter = (state->extraData.mapper19.irqCounterHighByte << 8)
9D034B60  90820019   LBU V0, 25(A0)
9D034B64  00021200   SLL V0, V0, 8
9D034B70  AF828078   SW V0, -32648(GP)
113:                                        | state->extraData.mapper19.irqCounterLowByte;
9D034B68  90830018   LBU V1, 24(A0)
9D034B6C  00431025   OR V0, V0, V1
114:                    irq.enabled = state->extraData.mapper19.irqCounterEnabled;
9D034B74  9082001A   LBU V0, 26(A0)
9D034B78  03E00008   JR RA
9D034B7C  AF82807C   SW V0, -32644(GP)
115:                 }
116:                 
117:                 static map_memwrite map19_memwrite[] =
118:                 {
119:                    { 0x5000, 0x5FFF, map19_write },
120:                    { 0x8000, 0xFFFF, map19_write },
121:                    {     -1,     -1, NULL }
122:                 };
123:                 
124:                 mapintf_t map19_intf =
125:                 {
126:                    19, /* mapper number */
127:                    "Namcot 106", /* mapper name */
128:                    map19_init, /* init routine */
129:                    NULL, /* vblank callback */
130:                    NULL, /* hblank callback */
131:                    map19_getstate, /* get state (snss) */
132:                    map19_setstate, /* set state (snss) */
133:                    NULL, /* memory read structure */
134:                    map19_memwrite, /* memory write structure */
135:                    NULL /* external sound device */
136:                 };
137:                 
138:                 /*
139:                 ** $Log: map019.c,v $
140:                 ** Revision 1.2  2001/04/27 14:37:11  neil
141:                 ** wheeee
142:                 **
143:                 ** Revision 1.1  2001/04/27 12:54:40  neil
144:                 ** blah
145:                 **
146:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
147:                 ** initial
148:                 **
149:                 ** Revision 1.1  2000/10/24 12:19:33  matt
150:                 ** changed directory structure
151:                 **
152:                 ** Revision 1.6  2000/10/22 19:17:46  matt
153:                 ** mapper cleanups galore
154:                 **
155:                 ** Revision 1.5  2000/10/21 19:33:38  matt
156:                 ** many more cleanups
157:                 **
158:                 ** Revision 1.4  2000/10/10 13:58:17  matt
159:                 ** stroustrup squeezing his way in the door
160:                 **
161:                 ** Revision 1.3  2000/07/15 23:52:20  matt
162:                 ** rounded out a bunch more mapper interfaces
163:                 **
164:                 ** Revision 1.2  2000/07/06 02:48:43  matt
165:                 ** clearly labelled structure members
166:                 **
167:                 ** Revision 1.1  2000/07/06 01:01:56  matt
168:                 ** initial revision
169:                 **
170:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map018.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map18.c
21:                  **
22:                  ** mapper 18 interface
23:                  ** $Id: map018.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes_ppu.h>
29:                  
30:                  /* mapper 18: Jaleco SS8806 */
31:                  #define  VRC_PBANK(bank, value, high) \
32:                  do { \
33:                     if ((high)) \
34:                        highprgnybbles[(bank)] = (value) & 0x0F; \
35:                     else \
36:                        lowprgnybbles[(bank)] = (value) & 0x0F; \
37:                     mmc_bankrom(8, 0x8000 + ((bank) << 13), (highprgnybbles[(bank)] << 4)+lowprgnybbles[(bank)]); \
38:                  } while (0)
39:                  
40:                  #define VRC_VBANK(bank, value, high) \
41:                  { \
42:                     if ((high)) \
43:                        highnybbles[(bank)] = (value) & 0x0F; \
44:                     else \
45:                        lownybbles[(bank)] = (value) & 0x0F; \
46:                     mmc_bankvrom(1, (bank) << 10, (highnybbles[(bank)] << 4)+lownybbles[(bank)]); \
47:                  }
48:                  
49:                  static struct
50:                  {
51:                     int counter, enabled;
52:                     uint8 nybbles[4];
53:                     int clockticks;
54:                  } irq;
55:                  
56:                  static void map18_init(void)
57:                  {
58:                     irq.counter = irq.enabled = 0;
9D02B900  3C02A001   LUI V0, -24575
9D02B904  2443B8B4   ADDIU V1, V0, -18252
9D02B908  AC600004   SW ZERO, 4(V1)
9D02B90C  03E00008   JR RA
9D02B910  AC40B8B4   SW ZERO, -18252(V0)
59:                  }
60:                  
61:                  static uint8 lownybbles[8];
62:                  static uint8 highnybbles[8];
63:                  static uint8 lowprgnybbles[3];
64:                  static uint8 highprgnybbles[3];
65:                  
66:                  
67:                  static void map18_write(uint32 address, uint8 value)
68:                  {
9D02B960  27BDFFE8   ADDIU SP, SP, -24
69:                     switch (address)
9D02B964  3402C000   ORI V0, ZERO, -16384
9D02B968  108200F0   BEQ A0, V0, 0x9D02BD2C
9D02B96C  AFBF0014   SW RA, 20(SP)
9D02B970  3402C001   ORI V0, ZERO, -16383
9D02B974  0082102B   SLTU V0, A0, V0
9D02B978  10400031   BEQ V0, ZERO, 0x9D02BA40
9D02B97C  3402A000   ORI V0, ZERO, -24576
9D02B980  1082009C   BEQ A0, V0, 0x9D02BBF4
9D02B984  3402A001   ORI V0, ZERO, -24575
9D02B988  0082102B   SLTU V0, A0, V0
9D02B98C  10400016   BEQ V0, ZERO, 0x9D02B9E8
9D02B990  3402B000   ORI V0, ZERO, -20480
9D02B994  34028002   ORI V0, ZERO, -32766
9D02B998  1082006F   BEQ A0, V0, 0x9D02BB58
9D02B99C  34028003   ORI V0, ZERO, -32765
9D02B9A0  0082102B   SLTU V0, A0, V0
9D02B9A4  10400008   BEQ V0, ZERO, 0x9D02B9C8
9D02B9A8  34029000   ORI V0, ZERO, -28672
9D02B9AC  34028000   ORI V0, ZERO, -32768
9D02B9B0  10820056   BEQ A0, V0, 0x9D02BB0C
9D02B9B4  34028001   ORI V0, ZERO, -32767
9D02B9B8  5082005E   BEQL A0, V0, 0x9D02BB34
9D02B9BC  30A5000F   ANDI A1, A1, 15
9D02B9C8  10820076   BEQ A0, V0, 0x9D02BBA4
9D02B9CC  34029001   ORI V0, ZERO, -28671
9D02B9D0  1082007E   BEQ A0, V0, 0x9D02BBCC
9D02B9D4  34028003   ORI V0, ZERO, -32765
9D02B9D8  548201C3   BNEL A0, V0, 0x9D02C0E8
9D02B9DC  8FBF0014   LW RA, 20(SP)
9D02B9E8  108200A9   BEQ A0, V0, 0x9D02BC90
9D02B9EC  3402B001   ORI V0, ZERO, -20479
9D02B9F0  0082102B   SLTU V0, A0, V0
9D02B9F4  10400009   BEQ V0, ZERO, 0x9D02BA1C
9D02B9F8  3402A002   ORI V0, ZERO, -24574
9D02B9FC  10820091   BEQ A0, V0, 0x9D02BC44
9D02BA00  0082102B   SLTU V0, A0, V0
9D02BA04  14400085   BNE V0, ZERO, 0x9D02BC1C
9D02BA08  3402A003   ORI V0, ZERO, -24573
9D02BA0C  50820097   BEQL A0, V0, 0x9D02BC6C
9D02BA10  30A5000F   ANDI A1, A1, 15
9D02BA1C  3402B002   ORI V0, ZERO, -20478
9D02BA20  108200AF   BEQ A0, V0, 0x9D02BCE0
9D02BA24  0082102B   SLTU V0, A0, V0
9D02BA28  144000A3   BNE V0, ZERO, 0x9D02BCB8
9D02BA2C  3402B003   ORI V0, ZERO, -20477
9D02BA30  508200B5   BEQL A0, V0, 0x9D02BD08
9D02BA34  30A5000F   ANDI A1, A1, 15
9D02BA40  3402D003   ORI V0, ZERO, -12285
9D02BA44  108200FD   BEQ A0, V0, 0x9D02BE3C
9D02BA48  3402D004   ORI V0, ZERO, -12284
9D02BA4C  0082102B   SLTU V0, A0, V0
9D02BA50  10400017   BEQ V0, ZERO, 0x9D02BAB0
9D02BA54  3402E003   ORI V0, ZERO, -8189
9D02BA58  3402C003   ORI V0, ZERO, -16381
9D02BA5C  108200D0   BEQ A0, V0, 0x9D02BDA0
9D02BA60  3402C004   ORI V0, ZERO, -16380
9D02BA64  0082102B   SLTU V0, A0, V0
9D02BA68  10400008   BEQ V0, ZERO, 0x9D02BA8C
9D02BA6C  3402D001   ORI V0, ZERO, -12287
9D02BA70  3402C001   ORI V0, ZERO, -16383
9D02BA74  108200B7   BEQ A0, V0, 0x9D02BD54
9D02BA78  3402C002   ORI V0, ZERO, -16382
9D02BA7C  108200BF   BEQ A0, V0, 0x9D02BD7C
9D02BA80  30A2000F   ANDI V0, A1, 15
9D02BA8C  108200D7   BEQ A0, V0, 0x9D02BDEC
9D02BA90  3402D002   ORI V0, ZERO, -12286
9D02BA94  0082102B   SLTU V0, A0, V0
9D02BA98  104000DE   BEQ V0, ZERO, 0x9D02BE14
9D02BA9C  3402D000   ORI V0, ZERO, -12288
9D02BAA0  108200C9   BEQ A0, V0, 0x9D02BDC8
9D02BAA4  30A2000F   ANDI V0, A1, 15
9D02BAB0  10820142   BEQ A0, V0, 0x9D02BFBC
9D02BAB4  3402E004   ORI V0, ZERO, -8188
9D02BAB8  0082102B   SLTU V0, A0, V0
9D02BABC  1040000A   BEQ V0, ZERO, 0x9D02BAE8
9D02BAC0  3402E001   ORI V0, ZERO, -8191
9D02BAC4  10820103   BEQ A0, V0, 0x9D02BED4
9D02BAC8  3402E002   ORI V0, ZERO, -8190
9D02BACC  0082102B   SLTU V0, A0, V0
9D02BAD0  1040011D   BEQ V0, ZERO, 0x9D02BF48
9D02BAD4  3402E000   ORI V0, ZERO, -8192
9D02BAD8  508200E2   BEQL A0, V0, 0x9D02BE64
9D02BADC  30A5000F   ANDI A1, A1, 15
9D02BAE8  3402F001   ORI V0, ZERO, -4095
9D02BAEC  10820156   BEQ A0, V0, 0x9D02C048
9D02BAF0  3402F002   ORI V0, ZERO, -4094
9D02BAF4  10820158   BEQ A0, V0, 0x9D02C058
9D02BAF8  3402F000   ORI V0, ZERO, -4096
9D02BAFC  1482017A   BNE A0, V0, 0x9D02C0E8
9D02BB00  8FBF0014   LW RA, 20(SP)
70:                     {
71:                     case 0x8000: VRC_PBANK(0, value, 0); break;
9D02BB0C  30A2000F   ANDI V0, A1, 15
9D02BB10  A3828098   SB V0, -32616(GP)
9D02BB14  93868094   LBU A2, -32620(GP)
9D02BB18  00063100   SLL A2, A2, 4
9D02BB1C  24040008   ADDIU A0, ZERO, 8
9D02BB20  34058000   ORI A1, ZERO, -32768
9D02BB24  0F40B246   JAL mmc_bankrom
9D02BB28  00C23021   ADDU A2, A2, V0
9D02BB2C  0B40B03A   J 0x9D02C0E8
9D02BB30  8FBF0014   LW RA, 20(SP)
72:                     case 0x8001: VRC_PBANK(0, value, 1); break;
9D02BB34  A3858094   SB A1, -32620(GP)
9D02BB38  00053100   SLL A2, A1, 4
9D02BB3C  93828098   LBU V0, -32616(GP)
9D02BB40  24040008   ADDIU A0, ZERO, 8
9D02BB44  34058000   ORI A1, ZERO, -32768
9D02BB48  0F40B246   JAL mmc_bankrom
9D02BB4C  00C23021   ADDU A2, A2, V0
9D02BB50  0B40B03A   J 0x9D02C0E8
9D02BB54  8FBF0014   LW RA, 20(SP)
73:                     case 0x8002: VRC_PBANK(1, value, 0); break;
9D02BB58  30A2000F   ANDI V0, A1, 15
9D02BB5C  A3828099   SB V0, -32615(GP)
9D02BB60  93868095   LBU A2, -32619(GP)
9D02BB64  00063100   SLL A2, A2, 4
9D02BB68  24040008   ADDIU A0, ZERO, 8
9D02BB6C  3405A000   ORI A1, ZERO, -24576
9D02BB70  0F40B246   JAL mmc_bankrom
9D02BB74  00C23021   ADDU A2, A2, V0
9D02BB78  0B40B03A   J 0x9D02C0E8
9D02BB7C  8FBF0014   LW RA, 20(SP)
74:                     case 0x8003: VRC_PBANK(1, value, 1); break;
9D02B9E0  0B40AEE0   J 0x9D02BB80
9D02B9E4  30A5000F   ANDI A1, A1, 15
9D02BB80  A3858095   SB A1, -32619(GP)
9D02BB84  00053100   SLL A2, A1, 4
9D02BB88  93828099   LBU V0, -32615(GP)
9D02BB8C  24040008   ADDIU A0, ZERO, 8
9D02BB90  3405A000   ORI A1, ZERO, -24576
9D02BB94  0F40B246   JAL mmc_bankrom
9D02BB98  00C23021   ADDU A2, A2, V0
9D02BB9C  0B40B03A   J 0x9D02C0E8
9D02BBA0  8FBF0014   LW RA, 20(SP)
75:                     case 0x9000: VRC_PBANK(2, value, 0); break;
9D02BBA4  30A2000F   ANDI V0, A1, 15
9D02BBA8  A382809A   SB V0, -32614(GP)
9D02BBAC  93868096   LBU A2, -32618(GP)
9D02BBB0  00063100   SLL A2, A2, 4
9D02BBB4  24040008   ADDIU A0, ZERO, 8
9D02BBB8  3405C000   ORI A1, ZERO, -16384
9D02BBBC  0F40B246   JAL mmc_bankrom
9D02BBC0  00C23021   ADDU A2, A2, V0
9D02BBC4  0B40B03A   J 0x9D02C0E8
9D02BBC8  8FBF0014   LW RA, 20(SP)
76:                     case 0x9001: VRC_PBANK(2, value, 1); break;
9D02BBCC  30A5000F   ANDI A1, A1, 15
9D02BBD0  A3858096   SB A1, -32618(GP)
9D02BBD4  00053100   SLL A2, A1, 4
9D02BBD8  9382809A   LBU V0, -32614(GP)
9D02BBDC  24040008   ADDIU A0, ZERO, 8
9D02BBE0  3405C000   ORI A1, ZERO, -16384
9D02BBE4  0F40B246   JAL mmc_bankrom
9D02BBE8  00C23021   ADDU A2, A2, V0
9D02BBEC  0B40B03A   J 0x9D02C0E8
9D02BBF0  8FBF0014   LW RA, 20(SP)
77:                     case 0xA000: VRC_VBANK(0, value, 0); break;
9D02BBF4  30A2000F   ANDI V0, A1, 15
9D02BBF8  A38280A4   SB V0, -32604(GP)
9D02BBFC  9386809C   LBU A2, -32612(GP)
9D02BC00  00063100   SLL A2, A2, 4
9D02BC04  24040001   ADDIU A0, ZERO, 1
9D02BC08  00002821   ADDU A1, ZERO, ZERO
9D02BC0C  0F40B1E8   JAL mmc_bankvrom
9D02BC10  00C23021   ADDU A2, A2, V0
9D02BC14  0B40B03A   J 0x9D02C0E8
9D02BC18  8FBF0014   LW RA, 20(SP)
78:                     case 0xA001: VRC_VBANK(0, value, 1); break;
9D02BC1C  30A5000F   ANDI A1, A1, 15
9D02BC20  A385809C   SB A1, -32612(GP)
9D02BC24  00053100   SLL A2, A1, 4
9D02BC28  938280A4   LBU V0, -32604(GP)
9D02BC2C  24040001   ADDIU A0, ZERO, 1
9D02BC30  00002821   ADDU A1, ZERO, ZERO
9D02BC34  0F40B1E8   JAL mmc_bankvrom
9D02BC38  00C23021   ADDU A2, A2, V0
9D02BC3C  0B40B03A   J 0x9D02C0E8
9D02BC40  8FBF0014   LW RA, 20(SP)
79:                     case 0xA002: VRC_VBANK(1, value, 0); break;
9D02BC44  30A2000F   ANDI V0, A1, 15
9D02BC48  A38280A5   SB V0, -32603(GP)
9D02BC4C  9386809D   LBU A2, -32611(GP)
9D02BC50  00063100   SLL A2, A2, 4
9D02BC54  24040001   ADDIU A0, ZERO, 1
9D02BC58  24050400   ADDIU A1, ZERO, 1024
9D02BC5C  0F40B1E8   JAL mmc_bankvrom
9D02BC60  00C23021   ADDU A2, A2, V0
9D02BC64  0B40B03A   J 0x9D02C0E8
9D02BC68  8FBF0014   LW RA, 20(SP)
80:                     case 0xA003: VRC_VBANK(1, value, 1); break;
9D02BC6C  A385809D   SB A1, -32611(GP)
9D02BC70  00053100   SLL A2, A1, 4
9D02BC74  938280A5   LBU V0, -32603(GP)
9D02BC78  24040001   ADDIU A0, ZERO, 1
9D02BC7C  24050400   ADDIU A1, ZERO, 1024
9D02BC80  0F40B1E8   JAL mmc_bankvrom
9D02BC84  00C23021   ADDU A2, A2, V0
9D02BC88  0B40B03A   J 0x9D02C0E8
9D02BC8C  8FBF0014   LW RA, 20(SP)
81:                     case 0xB000: VRC_VBANK(2, value, 0); break;
9D02BC90  30A2000F   ANDI V0, A1, 15
9D02BC94  A38280A6   SB V0, -32602(GP)
9D02BC98  9386809E   LBU A2, -32610(GP)
9D02BC9C  00063100   SLL A2, A2, 4
9D02BCA0  24040001   ADDIU A0, ZERO, 1
9D02BCA4  24050800   ADDIU A1, ZERO, 2048
9D02BCA8  0F40B1E8   JAL mmc_bankvrom
9D02BCAC  00C23021   ADDU A2, A2, V0
9D02BCB0  0B40B03A   J 0x9D02C0E8
9D02BCB4  8FBF0014   LW RA, 20(SP)
82:                     case 0xB001: VRC_VBANK(2, value, 1); break;
9D02BCB8  30A5000F   ANDI A1, A1, 15
9D02BCBC  A385809E   SB A1, -32610(GP)
9D02BCC0  00053100   SLL A2, A1, 4
9D02BCC4  938280A6   LBU V0, -32602(GP)
9D02BCC8  24040001   ADDIU A0, ZERO, 1
9D02BCCC  24050800   ADDIU A1, ZERO, 2048
9D02BCD0  0F40B1E8   JAL mmc_bankvrom
9D02BCD4  00C23021   ADDU A2, A2, V0
9D02BCD8  0B40B03A   J 0x9D02C0E8
9D02BCDC  8FBF0014   LW RA, 20(SP)
83:                     case 0xB002: VRC_VBANK(3, value, 0); break;
9D02BCE0  30A2000F   ANDI V0, A1, 15
9D02BCE4  A38280A7   SB V0, -32601(GP)
9D02BCE8  9386809F   LBU A2, -32609(GP)
9D02BCEC  00063100   SLL A2, A2, 4
9D02BCF0  24040001   ADDIU A0, ZERO, 1
9D02BCF4  24050C00   ADDIU A1, ZERO, 3072
9D02BCF8  0F40B1E8   JAL mmc_bankvrom
9D02BCFC  00C23021   ADDU A2, A2, V0
9D02BD00  0B40B03A   J 0x9D02C0E8
9D02BD04  8FBF0014   LW RA, 20(SP)
84:                     case 0xB003: VRC_VBANK(3, value, 1); break;
9D02BD08  A385809F   SB A1, -32609(GP)
9D02BD0C  00053100   SLL A2, A1, 4
9D02BD10  938280A7   LBU V0, -32601(GP)
9D02BD14  24040001   ADDIU A0, ZERO, 1
9D02BD18  24050C00   ADDIU A1, ZERO, 3072
9D02BD1C  0F40B1E8   JAL mmc_bankvrom
9D02BD20  00C23021   ADDU A2, A2, V0
9D02BD24  0B40B03A   J 0x9D02C0E8
9D02BD28  8FBF0014   LW RA, 20(SP)
85:                     case 0xC000: VRC_VBANK(4, value, 0); break;
9D02BD2C  30A2000F   ANDI V0, A1, 15
9D02BD30  A38280A8   SB V0, -32600(GP)
9D02BD34  938680A0   LBU A2, -32608(GP)
9D02BD38  00063100   SLL A2, A2, 4
9D02BD3C  24040001   ADDIU A0, ZERO, 1
9D02BD40  24051000   ADDIU A1, ZERO, 4096
9D02BD44  0F40B1E8   JAL mmc_bankvrom
9D02BD48  00C23021   ADDU A2, A2, V0
9D02BD4C  0B40B03A   J 0x9D02C0E8
9D02BD50  8FBF0014   LW RA, 20(SP)
86:                     case 0xC001: VRC_VBANK(4, value, 1); break;
9D02BD54  30A5000F   ANDI A1, A1, 15
9D02BD58  A38580A0   SB A1, -32608(GP)
9D02BD5C  00053100   SLL A2, A1, 4
9D02BD60  938280A8   LBU V0, -32600(GP)
9D02BD64  24040001   ADDIU A0, ZERO, 1
9D02BD68  24051000   ADDIU A1, ZERO, 4096
9D02BD6C  0F40B1E8   JAL mmc_bankvrom
9D02BD70  00C23021   ADDU A2, A2, V0
9D02BD74  0B40B03A   J 0x9D02C0E8
9D02BD78  8FBF0014   LW RA, 20(SP)
87:                     case 0xC002: VRC_VBANK(5, value, 0); break;
9D02BD7C  A38280A9   SB V0, -32599(GP)
9D02BD80  938680A1   LBU A2, -32607(GP)
9D02BD84  00063100   SLL A2, A2, 4
9D02BD88  24040001   ADDIU A0, ZERO, 1
9D02BD8C  24051400   ADDIU A1, ZERO, 5120
9D02BD90  0F40B1E8   JAL mmc_bankvrom
9D02BD94  00C23021   ADDU A2, A2, V0
9D02BD98  0B40B03A   J 0x9D02C0E8
9D02BD9C  8FBF0014   LW RA, 20(SP)
88:                     case 0xC003: VRC_VBANK(5, value, 1); break;
9D02BDA0  30A5000F   ANDI A1, A1, 15
9D02BDA4  A38580A1   SB A1, -32607(GP)
9D02BDA8  00053100   SLL A2, A1, 4
9D02BDAC  938280A9   LBU V0, -32599(GP)
9D02BDB0  24040001   ADDIU A0, ZERO, 1
9D02BDB4  24051400   ADDIU A1, ZERO, 5120
9D02BDB8  0F40B1E8   JAL mmc_bankvrom
9D02BDBC  00C23021   ADDU A2, A2, V0
9D02BDC0  0B40B03A   J 0x9D02C0E8
9D02BDC4  8FBF0014   LW RA, 20(SP)
89:                     case 0xD000: VRC_VBANK(6, value, 0); break;
9D02BDC8  A38280AA   SB V0, -32598(GP)
9D02BDCC  938680A2   LBU A2, -32606(GP)
9D02BDD0  00063100   SLL A2, A2, 4
9D02BDD4  24040001   ADDIU A0, ZERO, 1
9D02BDD8  24051800   ADDIU A1, ZERO, 6144
9D02BDDC  0F40B1E8   JAL mmc_bankvrom
9D02BDE0  00C23021   ADDU A2, A2, V0
9D02BDE4  0B40B03A   J 0x9D02C0E8
9D02BDE8  8FBF0014   LW RA, 20(SP)
90:                     case 0xD001: VRC_VBANK(6, value, 1); break;
9D02BDEC  30A5000F   ANDI A1, A1, 15
9D02BDF0  A38580A2   SB A1, -32606(GP)
9D02BDF4  00053100   SLL A2, A1, 4
9D02BDF8  938280AA   LBU V0, -32598(GP)
9D02BDFC  24040001   ADDIU A0, ZERO, 1
9D02BE00  24051800   ADDIU A1, ZERO, 6144
9D02BE04  0F40B1E8   JAL mmc_bankvrom
9D02BE08  00C23021   ADDU A2, A2, V0
9D02BE0C  0B40B03A   J 0x9D02C0E8
9D02BE10  8FBF0014   LW RA, 20(SP)
91:                     case 0xD002: VRC_VBANK(7, value, 0); break;
9D02BE14  30A2000F   ANDI V0, A1, 15
9D02BE18  A38280AB   SB V0, -32597(GP)
9D02BE1C  938680A3   LBU A2, -32605(GP)
9D02BE20  00063100   SLL A2, A2, 4
9D02BE24  24040001   ADDIU A0, ZERO, 1
9D02BE28  24051C00   ADDIU A1, ZERO, 7168
9D02BE2C  0F40B1E8   JAL mmc_bankvrom
9D02BE30  00C23021   ADDU A2, A2, V0
9D02BE34  0B40B03A   J 0x9D02C0E8
9D02BE38  8FBF0014   LW RA, 20(SP)
92:                     case 0xD003: VRC_VBANK(7, value, 1); break;
9D02BE3C  30A5000F   ANDI A1, A1, 15
9D02BE40  A38580A3   SB A1, -32605(GP)
9D02BE44  00053100   SLL A2, A1, 4
9D02BE48  938280AB   LBU V0, -32597(GP)
9D02BE4C  24040001   ADDIU A0, ZERO, 1
9D02BE50  24051C00   ADDIU A1, ZERO, 7168
9D02BE54  0F40B1E8   JAL mmc_bankvrom
9D02BE58  00C23021   ADDU A2, A2, V0
9D02BE5C  0B40B03A   J 0x9D02C0E8
9D02BE60  8FBF0014   LW RA, 20(SP)
93:                     case 0xE000:
94:                        irq.nybbles[0]=value&0x0F;
9D02BE64  3C02A001   LUI V0, -24575
9D02BE68  2442B8B4   ADDIU V0, V0, -18252
9D02BE6C  A0450008   SB A1, 8(V0)
95:                        irq.clockticks= (irq.nybbles[0]) | (irq.nybbles[1]<<4) |
9D02BE78  90430009   LBU V1, 9(V0)
9D02BE7C  00031900   SLL V1, V1, 4
9D02BE80  00832025   OR A0, A0, V1
9D02BE8C  00831825   OR V1, A0, V1
9D02BE94  AC45000C   SW A1, 12(V0)
96:                                       (irq.nybbles[2]<<8) | (irq.nybbles[3]<<12);
9D02BE70  9044000A   LBU A0, 10(V0)
9D02BE74  00042200   SLL A0, A0, 8
9D02BE84  9043000B   LBU V1, 11(V0)
9D02BE88  00031B00   SLL V1, V1, 12
9D02BE90  00652825   OR A1, V1, A1
97:                        irq.counter=(uint8)(irq.clockticks/114);
9D02BE98  3C028FB8   LUI V0, -28744
9D02BE9C  244223EF   ADDIU V0, V0, 9199
9D02BEA0  00A20018   MULT 0, A1, V0
9D02BEA4  00001010   MFHI V0
9D02BEA8  00452821   ADDU A1, V0, A1
9D02BEAC  7CA53980   EXT A1, A1, 6, 8
9D02BEBC  3C02A001   LUI V0, -24575
9D02BEC0  0B40B039   J .LVL110
9D02BEC4  AC45B8B4   SW A1, -18252(V0)
98:                        if(irq.counter>15) irq.counter-=16;
9D02BEB0  28A20010   SLTI V0, A1, 16
9D02BEB4  50400004   BEQL V0, ZERO, 0x9D02BEC8
9D02BEB8  24A5FFF0   ADDIU A1, A1, -16
9D02BEC8  3C02A001   LUI V0, -24575
9D02BECC  0B40B039   J .LVL110
9D02BED0  AC45B8B4   SW A1, -18252(V0)
99:                        break;
100:                    case 0xE001:
101:                       irq.nybbles[1]=value&0x0F;
9D02BED4  30A5000F   ANDI A1, A1, 15
9D02BED8  3C02A001   LUI V0, -24575
9D02BEDC  2442B8B4   ADDIU V0, V0, -18252
9D02BEE0  A0450009   SB A1, 9(V0)
102:                       irq.clockticks= (irq.nybbles[0]) | (irq.nybbles[1]<<4) |
9D02BEF4  00832025   OR A0, A0, V1
9D02BEF8  90430008   LBU V1, 8(V0)
9D02BEFC  00831825   OR V1, A0, V1
9D02BF00  00052900   SLL A1, A1, 4
9D02BF08  AC43000C   SW V1, 12(V0)
103:                                      (irq.nybbles[2]<<8) | (irq.nybbles[3]<<12);
9D02BEE4  9044000A   LBU A0, 10(V0)
9D02BEE8  00042200   SLL A0, A0, 8
9D02BEEC  9043000B   LBU V1, 11(V0)
9D02BEF0  00031B00   SLL V1, V1, 12
9D02BF04  00651825   OR V1, V1, A1
104:                       irq.counter=(uint8)(irq.clockticks/114);
9D02BF0C  3C028FB8   LUI V0, -28744
9D02BF10  244223EF   ADDIU V0, V0, 9199
9D02BF14  00620018   MULT 0, V1, V0
9D02BF18  00001010   MFHI V0
9D02BF1C  00431821   ADDU V1, V0, V1
9D02BF20  7C633980   EXT V1, V1, 6, 8
9D02BF30  3C02A001   LUI V0, -24575
9D02BF34  0B40B039   J .LVL110
9D02BF38  AC43B8B4   SW V1, -18252(V0)
105:                       if(irq.counter>15) irq.counter-=16;
9D02BF24  28620010   SLTI V0, V1, 16
9D02BF28  50400004   BEQL V0, ZERO, 0x9D02BF3C
9D02BF2C  2463FFF0   ADDIU V1, V1, -16
9D02BF3C  3C02A001   LUI V0, -24575
9D02BF40  0B40B039   J .LVL110
9D02BF44  AC43B8B4   SW V1, -18252(V0)
106:                       break;
107:                    case 0xE002:
108:                       irq.nybbles[2]=value&0x0F;
9D02BF48  30A5000F   ANDI A1, A1, 15
9D02BF4C  3C02A001   LUI V0, -24575
9D02BF50  2442B8B4   ADDIU V0, V0, -18252
9D02BF54  A045000A   SB A1, 10(V0)
109:                       irq.clockticks= (irq.nybbles[0]) | (irq.nybbles[1]<<4) |
9D02BF58  90440009   LBU A0, 9(V0)
9D02BF5C  00042100   SLL A0, A0, 4
9D02BF68  00832025   OR A0, A0, V1
9D02BF6C  90430008   LBU V1, 8(V0)
9D02BF70  00831825   OR V1, A0, V1
9D02BF7C  AC43000C   SW V1, 12(V0)
110:                                      (irq.nybbles[2]<<8) | (irq.nybbles[3]<<12);
9D02BF60  9043000B   LBU V1, 11(V0)
9D02BF64  00031B00   SLL V1, V1, 12
9D02BF74  00052A00   SLL A1, A1, 8
9D02BF78  00651825   OR V1, V1, A1
111:                       irq.counter=(uint8)(irq.clockticks/114);
9D02BF80  3C028FB8   LUI V0, -28744
9D02BF84  244223EF   ADDIU V0, V0, 9199
9D02BF88  00620018   MULT 0, V1, V0
9D02BF8C  00001010   MFHI V0
9D02BF90  00431821   ADDU V1, V0, V1
9D02BF94  7C633980   EXT V1, V1, 6, 8
9D02BFA4  3C02A001   LUI V0, -24575
9D02BFA8  0B40B039   J .LVL110
9D02BFAC  AC43B8B4   SW V1, -18252(V0)
112:                       if(irq.counter>15) irq.counter-=16;
9D02BF98  28620010   SLTI V0, V1, 16
9D02BF9C  50400004   BEQL V0, ZERO, 0x9D02BFB0
9D02BFA0  2463FFF0   ADDIU V1, V1, -16
9D02BFB0  3C02A001   LUI V0, -24575
9D02BFB4  0B40B039   J .LVL110
9D02BFB8  AC43B8B4   SW V1, -18252(V0)
113:                       break;
114:                    case 0xE003:
115:                       irq.nybbles[3]=value&0x0F;
9D02BFBC  30A5000F   ANDI A1, A1, 15
9D02BFC0  3C02A001   LUI V0, -24575
9D02BFC4  2442B8B4   ADDIU V0, V0, -18252
9D02BFC8  A045000B   SB A1, 11(V0)
116:                       irq.clockticks= (irq.nybbles[0]) | (irq.nybbles[1]<<4) |
9D02BFCC  90440009   LBU A0, 9(V0)
9D02BFD0  00042100   SLL A0, A0, 4
9D02BFDC  00832025   OR A0, A0, V1
9D02BFE0  90430008   LBU V1, 8(V0)
9D02BFE4  00831825   OR V1, A0, V1
9D02BFF0  AC43000C   SW V1, 12(V0)
117:                                      (irq.nybbles[2]<<8) | (irq.nybbles[3]<<12);
9D02BFD4  9043000A   LBU V1, 10(V0)
9D02BFD8  00031A00   SLL V1, V1, 8
9D02BFE8  00052B00   SLL A1, A1, 12
9D02BFEC  00651825   OR V1, V1, A1
118:                       irq.counter=(uint8)(irq.clockticks/114);
9D02BFF4  3C028FB8   LUI V0, -28744
9D02BFF8  244223EF   ADDIU V0, V0, 9199
9D02BFFC  00620018   MULT 0, V1, V0
9D02C000  00001010   MFHI V0
9D02C004  00431821   ADDU V1, V0, V1
9D02C008  7C633980   EXT V1, V1, 6, 8
9D02C018  3C02A001   LUI V0, -24575
9D02C01C  0B40B039   J .LVL110
9D02C020  AC43B8B4   SW V1, -18252(V0)
119:                       if(irq.counter>15) irq.counter-=16;
9D02C00C  28620010   SLTI V0, V1, 16
9D02C010  50400004   BEQL V0, ZERO, 0x9D02C024
9D02C014  2463FFF0   ADDIU V1, V1, -16
9D02C024  3C02A001   LUI V0, -24575
9D02C028  0B40B039   J .LVL110
9D02C02C  AC43B8B4   SW V1, -18252(V0)
120:                       break;
121:                    case 0xF000:
122:                       if(value&0x01) irq.enabled=true;
9D02BB04  0B40B00C   J 0x9D02C030
9D02BB08  30A50001   ANDI A1, A1, 1
9D02C030  10A0002D   BEQ A1, ZERO, 0x9D02C0E8
9D02C034  8FBF0014   LW RA, 20(SP)
9D02C038  24030001   ADDIU V1, ZERO, 1
9D02C03C  3C02A001   LUI V0, -24575
9D02C040  0B40B039   J .LVL110
9D02C044  AC43B8B8   SW V1, -18248(V0)
123:                       break;
124:                    case 0xF001: 
125:                       irq.enabled=value&0x01;
9D02C048  30A50001   ANDI A1, A1, 1
9D02C04C  3C02A001   LUI V0, -24575
126:                       break;
9D02C050  0B40B039   J .LVL110
9D02C054  AC45B8B8   SW A1, -18248(V0)
127:                    case 0xF002: 
128:                       switch(value&0x03)
9D02C058  30A50003   ANDI A1, A1, 3
9D02C05C  24020001   ADDIU V0, ZERO, 1
9D02C060  10A2000F   BEQ A1, V0, 0x9D02C0A0
9D02C064  00002021   ADDU A0, ZERO, ZERO
9D02C068  10A00007   BEQ A1, ZERO, 0x9D02C088
9D02C06C  24020002   ADDIU V0, ZERO, 2
9D02C070  10A20011   BEQ A1, V0, 0x9D02C0B8
9D02C074  24020003   ADDIU V0, ZERO, 3
9D02C078  10A20016   BEQ A1, V0, 0x9D02C0D4
9D02C07C  24040001   ADDIU A0, ZERO, 1
129:                       {
130:                       case 0:  ppu_mirror(0, 0, 1, 1); break;
9D02C088  00002821   ADDU A1, ZERO, ZERO
9D02C08C  24060001   ADDIU A2, ZERO, 1
9D02C090  0F406128   JAL ppu_mirror
9D02C094  24070001   ADDIU A3, ZERO, 1
9D02C098  0B40B03A   J 0x9D02C0E8
9D02C09C  8FBF0014   LW RA, 20(SP)
131:                       case 1:  ppu_mirror(0, 1, 0, 1); break;
9D02C0A0  24050001   ADDIU A1, ZERO, 1
9D02C0A4  00003021   ADDU A2, ZERO, ZERO
9D02C0A8  0F406128   JAL ppu_mirror
9D02C0AC  24070001   ADDIU A3, ZERO, 1
9D02C0B0  0B40B03A   J 0x9D02C0E8
9D02C0B4  8FBF0014   LW RA, 20(SP)
132:                       case 2:  ppu_mirror(1,1,1,1);break;
9D02C0B8  24040001   ADDIU A0, ZERO, 1
9D02C0BC  24050001   ADDIU A1, ZERO, 1
9D02C0C0  24060001   ADDIU A2, ZERO, 1
9D02C0C4  0F406128   JAL ppu_mirror
9D02C0C8  24070001   ADDIU A3, ZERO, 1
9D02C0CC  0B40B03A   J 0x9D02C0E8
9D02C0D0  8FBF0014   LW RA, 20(SP)
133:                       case 3:  ppu_mirror(1,1,1,1);break; // should this be zero?
9D02C0D4  24050001   ADDIU A1, ZERO, 1
9D02C0D8  24060001   ADDIU A2, ZERO, 1
9D02C0DC  0F406128   JAL ppu_mirror
9D02C0E0  24070001   ADDIU A3, ZERO, 1
134:                       default: break;
135:                       }
136:                       break;
137:                    default:
138:                       break;
139:                    }
140:                 }
9D02B9C0  0B40B03A   J 0x9D02C0E8
9D02B9C4  8FBF0014   LW RA, 20(SP)
9D02BA14  0B40B03A   J 0x9D02C0E8
9D02BA18  8FBF0014   LW RA, 20(SP)
9D02BA38  0B40B03A   J 0x9D02C0E8
9D02BA3C  8FBF0014   LW RA, 20(SP)
9D02BA84  0B40B03A   J 0x9D02C0E8
9D02BA88  8FBF0014   LW RA, 20(SP)
9D02BAA8  0B40B03A   J 0x9D02C0E8
9D02BAAC  8FBF0014   LW RA, 20(SP)
9D02BAE0  0B40B03A   J 0x9D02C0E8
9D02BAE4  8FBF0014   LW RA, 20(SP)
9D02C080  0B40B03A   J 0x9D02C0E8
9D02C084  8FBF0014   LW RA, 20(SP)
9D02C0E4  8FBF0014   LW RA, 20(SP)
9D02C0E8  03E00008   JR RA
9D02C0EC  27BD0018   ADDIU SP, SP, 24
141:                 
142:                 
143:                 static map_memwrite map18_memwrite[] =
144:                 {
145:                    { 0x8000, 0xFFFF, map18_write },
146:                    {     -1,     -1, NULL }
147:                 };
148:                 
149:                 static void map18_getstate(SnssMapperBlock *state)
150:                 {
151:                    state->extraData.mapper18.irqCounterLowByte = irq.counter & 0xFF;
9D02B914  3C02A001   LUI V0, -24575
9D02B918  8C43B8B4   LW V1, -18252(V0)
9D02B91C  A0830018   SB V1, 24(A0)
152:                    state->extraData.mapper18.irqCounterHighByte = irq.counter >> 8;
9D02B920  00031A03   SRA V1, V1, 8
9D02B924  A0830019   SB V1, 25(A0)
153:                    state->extraData.mapper18.irqCounterEnabled = irq.enabled;
9D02B928  2442B8B4   ADDIU V0, V0, -18252
9D02B92C  8C420004   LW V0, 4(V0)
9D02B930  03E00008   JR RA
9D02B934  A082001A   SB V0, 26(A0)
154:                 }
155:                 
156:                 static void map18_setstate(SnssMapperBlock *state)
157:                 {
158:                    irq.counter = (state->extraData.mapper18.irqCounterHighByte << 8)
9D02B938  3C02A001   LUI V0, -24575
9D02B93C  90830019   LBU V1, 25(A0)
9D02B940  00031A00   SLL V1, V1, 8
9D02B94C  AC43B8B4   SW V1, -18252(V0)
159:                                        | state->extraData.mapper18.irqCounterLowByte;
9D02B944  90850018   LBU A1, 24(A0)
9D02B948  00651825   OR V1, V1, A1
160:                    irq.enabled = state->extraData.mapper18.irqCounterEnabled;
9D02B950  2442B8B4   ADDIU V0, V0, -18252
9D02B954  9083001A   LBU V1, 26(A0)
9D02B958  03E00008   JR RA
9D02B95C  AC430004   SW V1, 4(V0)
161:                 }
162:                 
163:                 mapintf_t map18_intf =
164:                 {
165:                    18, /* mapper number */
166:                    "Jaleco SS8806", /* mapper name */
167:                    map18_init, /* init routine */
168:                    NULL, /* vblank callback */
169:                    NULL, /* hblank callback */
170:                    map18_getstate, /* get state (snss) */
171:                    map18_setstate, /* set state (snss) */
172:                    NULL, /* memory read structure */
173:                    map18_memwrite, /* memory write structure */
174:                    NULL /* external sound device */
175:                 };
176:                 
177:                 /*
178:                 ** $Log: map018.c,v $
179:                 ** Revision 1.2  2001/04/27 14:37:11  neil
180:                 ** wheeee
181:                 **
182:                 ** Revision 1.1  2001/04/27 12:54:40  neil
183:                 ** blah
184:                 **
185:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
186:                 ** initial
187:                 **
188:                 ** Revision 1.1  2000/10/24 12:19:33  matt
189:                 ** changed directory structure
190:                 **
191:                 ** Revision 1.8  2000/10/22 19:17:46  matt
192:                 ** mapper cleanups galore
193:                 **
194:                 ** Revision 1.7  2000/10/22 15:03:13  matt
195:                 ** simplified mirroring
196:                 **
197:                 ** Revision 1.6  2000/10/21 19:33:38  matt
198:                 ** many more cleanups
199:                 **
200:                 ** Revision 1.5  2000/10/10 13:58:17  matt
201:                 ** stroustrup squeezing his way in the door
202:                 **
203:                 ** Revision 1.4  2000/07/15 23:52:19  matt
204:                 ** rounded out a bunch more mapper interfaces
205:                 **
206:                 ** Revision 1.3  2000/07/10 05:29:03  matt
207:                 ** cleaned up some mirroring issues
208:                 **
209:                 ** Revision 1.2  2000/07/06 02:48:42  matt
210:                 ** clearly labelled structure members
211:                 **
212:                 ** Revision 1.1  2000/07/06 01:01:56  matt
213:                 ** initial revision
214:                 **
215:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map016.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map16.c
21:                  **
22:                  ** mapper 16 interface
23:                  ** $Id: map016.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes_ppu.h>
29:                  #include <nes.h>
30:                  
31:                  static struct
32:                  {
33:                     int counter;
34:                     bool enabled;
35:                  } irq;
36:                  
37:                  /* mapper 16: Bandai */
38:                  
39:                  static void map16_init(void)
40:                  {
9D0351D0  27BDFFE8   ADDIU SP, SP, -24
9D0351D4  AFBF0014   SW RA, 20(SP)
41:                     mmc_bankrom(16, 0x8000, 0);
9D0351D8  24040010   ADDIU A0, ZERO, 16
9D0351DC  34058000   ORI A1, ZERO, -32768
9D0351E0  0F40B246   JAL mmc_bankrom
9D0351E4  00003021   ADDU A2, ZERO, ZERO
42:                     mmc_bankrom(16, 0xC000, MMC_LASTBANK);
9D0351E8  24040010   ADDIU A0, ZERO, 16
9D0351EC  3405C000   ORI A1, ZERO, -16384
9D0351F0  0F40B246   JAL mmc_bankrom
9D0351F4  2406FFFF   ADDIU A2, ZERO, -1
43:                     irq.counter = 0;
9D0351F8  AF8080AC   SW ZERO, -32596(GP)
44:                     irq.enabled = false;
9D0351FC  AF8080B0   SW ZERO, -32592(GP)
45:                  }
9D035200  8FBF0014   LW RA, 20(SP)
9D035204  03E00008   JR RA
9D035208  27BD0018   ADDIU SP, SP, 24
46:                  
47:                  static void map16_write(uint32 address, uint8 value)
48:                  {
9D03520C  27BDFFE8   ADDIU SP, SP, -24
9D035210  00A03021   ADDU A2, A1, ZERO
49:                     int reg = address & 0xF;
9D035214  3085000F   ANDI A1, A0, 15
50:                  
51:                     if (reg < 8)
9D035218  28A30008   SLTI V1, A1, 8
9D03521C  10600006   BEQ V1, ZERO, 0x9D035238
9D035220  AFBF0014   SW RA, 20(SP)
52:                     {
53:                        mmc_bankvrom(1, reg << 10, value);
9D035224  24040001   ADDIU A0, ZERO, 1
9D035228  0F40B1E8   JAL mmc_bankvrom
9D03522C  00052A80   SLL A1, A1, 10
9D035230  0B40D4D6   J 0x9D035358
9D035234  8FBF0014   LW RA, 20(SP)
54:                     }
55:                     else
56:                     {
57:                        switch (address & 0x000F)
9D035238  3084000F   ANDI A0, A0, 15
9D03523C  2484FFF8   ADDIU A0, A0, -8
9D035240  2C820005   SLTIU V0, A0, 5
9D035244  10400043   BEQ V0, ZERO, 0x9D035354
9D035248  00042080   SLL A0, A0, 2
9D03524C  3C029D03   LUI V0, -25341
9D035250  24425264   ADDIU V0, V0, 21092
9D035254  00442021   ADDU A0, V0, A0
9D035258  8C820000   LW V0, 0(A0)
9D03525C  00400008   JR V0
9D035260  00000000   NOP
58:                        {
59:                        case 0x8:
60:                           mmc_bankrom(16, 0x8000, value);
9D035278  24040010   ADDIU A0, ZERO, 16
9D03527C  0F40B246   JAL mmc_bankrom
9D035280  34058000   ORI A1, ZERO, -32768
61:                           break;
9D035284  0B40D4D6   J 0x9D035358
9D035288  8FBF0014   LW RA, 20(SP)
62:                  
63:                        case 0x9:
64:                           switch (value & 3)
9D03528C  30C60003   ANDI A2, A2, 3
9D035290  24020001   ADDIU V0, ZERO, 1
9D035294  10C2000F   BEQ A2, V0, 0x9D0352D4
9D035298  00002021   ADDU A0, ZERO, ZERO
9D03529C  10C00007   BEQ A2, ZERO, 0x9D0352BC
9D0352A0  24020002   ADDIU V0, ZERO, 2
9D0352A4  10C20011   BEQ A2, V0, 0x9D0352EC
9D0352A8  24020003   ADDIU V0, ZERO, 3
9D0352AC  10C20015   BEQ A2, V0, 0x9D035304
9D0352B0  24040001   ADDIU A0, ZERO, 1
65:                           {
66:                           case 0:
67:                              ppu_mirror(0, 0, 1, 1); /* horizontal */
9D0352BC  00002821   ADDU A1, ZERO, ZERO
9D0352C0  24060001   ADDIU A2, ZERO, 1
9D0352C4  0F406128   JAL ppu_mirror
9D0352C8  24070001   ADDIU A3, ZERO, 1
68:                              break;
9D0352CC  0B40D4D6   J 0x9D035358
9D0352D0  8FBF0014   LW RA, 20(SP)
69:                        
70:                           case 1:
71:                              ppu_mirror(0, 1, 0, 1); /* vertical */
9D0352D4  24050001   ADDIU A1, ZERO, 1
9D0352D8  00003021   ADDU A2, ZERO, ZERO
9D0352DC  0F406128   JAL ppu_mirror
9D0352E0  24070001   ADDIU A3, ZERO, 1
72:                              break;
9D0352E4  0B40D4D6   J 0x9D035358
9D0352E8  8FBF0014   LW RA, 20(SP)
73:                        
74:                           case 2:
75:                              ppu_mirror(0, 0, 0, 0);
9D0352EC  00002821   ADDU A1, ZERO, ZERO
9D0352F0  00003021   ADDU A2, ZERO, ZERO
9D0352F4  0F406128   JAL ppu_mirror
9D0352F8  00003821   ADDU A3, ZERO, ZERO
76:                              break;
9D0352FC  0B40D4D6   J 0x9D035358
9D035300  8FBF0014   LW RA, 20(SP)
77:                        
78:                           case 3:
79:                              ppu_mirror(1, 1, 1, 1);
9D035304  24050001   ADDIU A1, ZERO, 1
9D035308  24060001   ADDIU A2, ZERO, 1
9D03530C  0F406128   JAL ppu_mirror
9D035310  24070001   ADDIU A3, ZERO, 1
80:                              break;
9D035314  0B40D4D6   J 0x9D035358
9D035318  8FBF0014   LW RA, 20(SP)
81:                           }
82:                           break;
83:                     
84:                        case 0xA:
85:                           irq.enabled = (value & 1) ? true : false;
9D03531C  30C60001   ANDI A2, A2, 1
86:                           break;
9D035320  0B40D4D5   J 0x9D035354
9D035324  AF8680B0   SW A2, -32592(GP)
87:                   
88:                        case 0xB:
89:                           irq.counter = (irq.counter & 0xFF00) | value;
9D035328  278280AC   ADDIU V0, GP, -32596
9D03532C  8C430000   LW V1, 0(V0)
9D035330  3063FF00   ANDI V1, V1, -256
9D035334  00C33025   OR A2, A2, V1
90:                           break;
9D035338  0B40D4D5   J 0x9D035354
9D03533C  AC460000   SW A2, 0(V0)
91:                     
92:                        case 0xC:
93:                           irq.counter = (value << 8) | (irq.counter & 0xFF);
9D035340  278280AC   ADDIU V0, GP, -32596
9D035344  00063200   SLL A2, A2, 8
9D035348  90430000   LBU V1, 0(V0)
9D03534C  00C33025   OR A2, A2, V1
9D035350  AC460000   SW A2, 0(V0)
94:                           break;
95:                     
96:                        case 0xD:
97:                           /* eeprom I/O port? */
98:                           break;
99:                        }
100:                    }
101:                 }
9D0352B4  0B40D4D6   J 0x9D035358
9D0352B8  8FBF0014   LW RA, 20(SP)
9D035354  8FBF0014   LW RA, 20(SP)
9D035358  03E00008   JR RA
9D03535C  27BD0018   ADDIU SP, SP, 24
102:                 
103:                 static void map16_hblank(int vblank)
104:                 {
9D035360  27BDFFE8   ADDIU SP, SP, -24
9D035364  AFBF0014   SW RA, 20(SP)
105:                    UNUSED(vblank);
106:                 
107:                    if (irq.enabled)
9D035368  8F8280B0   LW V0, -32592(GP)
9D03536C  10400007   BEQ V0, ZERO, .LVL27
9D035370  8F8280AC   LW V0, -32596(GP)
108:                    {
109:                       if (irq.counter)
9D035374  10400005   BEQ V0, ZERO, .LVL27
9D035378  2442FFFF   ADDIU V0, V0, -1
110:                       {
111:                          if (0 == --irq.counter)
9D03537C  14400003   BNE V0, ZERO, .LVL27
9D035380  AF8280AC   SW V0, -32596(GP)
112:                             nes_irq();
9D035384  0F408A46   JAL nes_irq
9D035388  00000000   NOP
113:                       }
114:                    }
115:                 }
9D03538C  8FBF0014   LW RA, 20(SP)
9D035390  03E00008   JR RA
9D035394  27BD0018   ADDIU SP, SP, 24
116:                 
117:                 static void map16_getstate(SnssMapperBlock *state)
118:                 {
119:                    state->extraData.mapper16.irqCounterLowByte = irq.counter & 0xFF;
9D035194  8F8280AC   LW V0, -32596(GP)
9D035198  A0820018   SB V0, 24(A0)
120:                    state->extraData.mapper16.irqCounterHighByte = irq.counter >> 8;
9D03519C  00021203   SRA V0, V0, 8
9D0351A0  A0820019   SB V0, 25(A0)
121:                    state->extraData.mapper16.irqCounterEnabled = irq.enabled;
9D0351A4  8F8280B0   LW V0, -32592(GP)
9D0351A8  03E00008   JR RA
9D0351AC  A082001A   SB V0, 26(A0)
122:                 }
123:                 
124:                 static void map16_setstate(SnssMapperBlock *state)
125:                 {
126:                    irq.counter = (state->extraData.mapper16.irqCounterHighByte << 8)
9D0351B0  90820019   LBU V0, 25(A0)
9D0351B4  00021200   SLL V0, V0, 8
9D0351C0  AF8280AC   SW V0, -32596(GP)
127:                                        | state->extraData.mapper16.irqCounterLowByte;
9D0351B8  90830018   LBU V1, 24(A0)
9D0351BC  00431025   OR V0, V0, V1
128:                    irq.enabled = state->extraData.mapper16.irqCounterEnabled;
9D0351C4  9082001A   LBU V0, 26(A0)
9D0351C8  03E00008   JR RA
9D0351CC  AF8280B0   SW V0, -32592(GP)
129:                 }
130:                 
131:                 static map_memwrite map16_memwrite[] =
132:                 {
133:                    { 0x6000, 0x600D, map16_write },
134:                    { 0x7FF0, 0x7FFD, map16_write },
135:                    { 0x8000, 0x800D, map16_write },
136:                    {     -1,     -1, NULL }
137:                 };
138:                 
139:                 mapintf_t map16_intf = 
140:                 {
141:                    16, /* mapper number */
142:                    "Bandai", /* mapper name */
143:                    map16_init, /* init routine */
144:                    NULL, /* vblank callback */
145:                    map16_hblank, /* hblank callback */
146:                    map16_getstate, /* get state (snss) */
147:                    map16_setstate, /* set state (snss) */
148:                    NULL, /* memory read structure */
149:                    map16_memwrite, /* memory write structure */
150:                    NULL /* external sound device */
151:                 };
152:                 
153:                 /*
154:                 ** $Log: map016.c,v $
155:                 ** Revision 1.2  2001/04/27 14:37:11  neil
156:                 ** wheeee
157:                 **
158:                 ** Revision 1.1  2001/04/27 12:54:40  neil
159:                 ** blah
160:                 **
161:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
162:                 ** initial
163:                 **
164:                 ** Revision 1.1  2000/10/24 12:19:33  matt
165:                 ** changed directory structure
166:                 **
167:                 ** Revision 1.8  2000/10/22 19:17:46  matt
168:                 ** mapper cleanups galore
169:                 **
170:                 ** Revision 1.7  2000/10/22 15:03:13  matt
171:                 ** simplified mirroring
172:                 **
173:                 ** Revision 1.6  2000/10/21 19:33:38  matt
174:                 ** many more cleanups
175:                 **
176:                 ** Revision 1.5  2000/10/10 13:58:16  matt
177:                 ** stroustrup squeezing his way in the door
178:                 **
179:                 ** Revision 1.4  2000/08/16 02:50:11  matt
180:                 ** random mapper cleanups
181:                 **
182:                 ** Revision 1.3  2000/07/15 23:52:20  matt
183:                 ** rounded out a bunch more mapper interfaces
184:                 **
185:                 ** Revision 1.2  2000/07/11 05:03:49  matt
186:                 ** value masking isn't necessary for the banking routines
187:                 **
188:                 ** Revision 1.1  2000/07/11 03:14:18  melanson
189:                 ** Initial commit for mappers 16, 34, and 231
190:                 **
191:                 **
192:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map015.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map15.c
21:                  **
22:                  ** mapper 15 interface
23:                  ** $Id: map015.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes_ppu.h>
29:                  
30:                  /* mapper 15: Contra 100-in-1 */
31:                  static void map15_write(uint32 address, uint8 value)
32:                  {
9D03427C  27BDFFD8   ADDIU SP, SP, -40
9D034280  AFBF0024   SW RA, 36(SP)
9D034284  AFB40020   SW S4, 32(SP)
9D034288  AFB3001C   SW S3, 28(SP)
9D03428C  AFB20018   SW S2, 24(SP)
9D034290  AFB10014   SW S1, 20(SP)
9D034294  AFB00010   SW S0, 16(SP)
9D034298  00A08021   ADDU S0, A1, ZERO
33:                     int bank = value & 0x3F;
9D03429C  30B2003F   ANDI S2, A1, 63
34:                     uint8 swap = (value & 0x80) >> 7;
35:                  
36:                     switch (address & 0x3)
9D0342A0  30840003   ANDI A0, A0, 3
9D0342A4  24020001   ADDIU V0, ZERO, 1
9D0342A8  1082002D   BEQ A0, V0, 0x9D034360
9D0342AC  000589C2   SRL S1, A1, 7
9D0342B0  10800007   BEQ A0, ZERO, 0x9D0342D0
9D0342B4  24020002   ADDIU V0, ZERO, 2
9D0342B8  10820035   BEQ A0, V0, 0x9D034390
9D0342BC  24020003   ADDIU V0, ZERO, 3
9D0342C0  1082005A   BEQ A0, V0, 0x9D03442C
9D0342C4  00129040   SLL S2, S2, 1
37:                     {
38:                     case 0:
39:                        mmc_bankrom(8, 0x8000, (bank << 1) + swap);
9D0342D0  0012A040   SLL S4, S2, 1
9D0342D4  24040008   ADDIU A0, ZERO, 8
9D0342D8  34058000   ORI A1, ZERO, -32768
9D0342DC  0F40B246   JAL mmc_bankrom
9D0342E0  02913021   ADDU A2, S4, S1
40:                        mmc_bankrom(8, 0xA000, (bank << 1) + (swap ^ 1));
9D0342E4  3A330001   XORI S3, S1, 1
9D0342E8  24040008   ADDIU A0, ZERO, 8
9D0342EC  3405A000   ORI A1, ZERO, -24576
9D0342F0  0F40B246   JAL mmc_bankrom
9D0342F4  02933021   ADDU A2, S4, S3
41:                        mmc_bankrom(8, 0xC000, ((bank + 1) << 1) + swap);
9D0342F8  26520001   ADDIU S2, S2, 1
9D0342FC  00129040   SLL S2, S2, 1
9D034300  24040008   ADDIU A0, ZERO, 8
9D034304  3405C000   ORI A1, ZERO, -16384
9D034308  0F40B246   JAL mmc_bankrom
9D03430C  02323021   ADDU A2, S1, S2
42:                        mmc_bankrom(8, 0xE000, ((bank + 1) << 1) + (swap ^ 1));
9D034310  24040008   ADDIU A0, ZERO, 8
9D034314  3405E000   ORI A1, ZERO, -8192
9D034318  0F40B246   JAL mmc_bankrom
9D03431C  02723021   ADDU A2, S3, S2
43:                  
44:                        if (value & 0x40)
9D034320  32100040   ANDI S0, S0, 64
9D034324  321000FF   ANDI S0, S0, 255
9D034328  12000007   BEQ S0, ZERO, 0x9D034348
9D03432C  00002021   ADDU A0, ZERO, ZERO
45:                           ppu_mirror(0, 0, 1, 1); /* horizontal */
9D034330  00002821   ADDU A1, ZERO, ZERO
9D034334  24060001   ADDIU A2, ZERO, 1
9D034338  0F406128   JAL ppu_mirror
9D03433C  24070001   ADDIU A3, ZERO, 1
9D034340  0B40D123   J 0x9D03448C
9D034344  8FBF0024   LW RA, 36(SP)
46:                        else
47:                           ppu_mirror(0, 1, 0, 1); /* vertical */
9D034348  24050001   ADDIU A1, ZERO, 1
9D03434C  00003021   ADDU A2, ZERO, ZERO
9D034350  0F406128   JAL ppu_mirror
9D034354  24070001   ADDIU A3, ZERO, 1
48:                        break;
49:                  
50:                     case 1:
51:                        mmc_bankrom(8, 0xC000, (bank << 1) + swap);
9D034360  00129040   SLL S2, S2, 1
9D034364  24040008   ADDIU A0, ZERO, 8
9D034368  3405C000   ORI A1, ZERO, -16384
9D03436C  0F40B246   JAL mmc_bankrom
9D034370  02513021   ADDU A2, S2, S1
52:                        mmc_bankrom(8, 0xE000, (bank << 1) + (swap ^ 1));
9D034374  3A260001   XORI A2, S1, 1
9D034378  24040008   ADDIU A0, ZERO, 8
9D03437C  3405E000   ORI A1, ZERO, -8192
9D034380  0F40B246   JAL mmc_bankrom
9D034384  02463021   ADDU A2, S2, A2
53:                        break;
9D034388  0B40D123   J 0x9D03448C
9D03438C  8FBF0024   LW RA, 36(SP)
54:                  
55:                     case 2:
56:                        if (swap)
9D034390  12200014   BEQ S1, ZERO, 0x9D0343E4
9D034394  00129040   SLL S2, S2, 1
57:                        {
58:                           mmc_bankrom(8, 0x8000, (bank << 1) + 1);
9D034398  26520001   ADDIU S2, S2, 1
9D03439C  24040008   ADDIU A0, ZERO, 8
9D0343A0  34058000   ORI A1, ZERO, -32768
9D0343A4  0F40B246   JAL mmc_bankrom
9D0343A8  02403021   ADDU A2, S2, ZERO
59:                           mmc_bankrom(8, 0xA000, (bank << 1) + 1);
9D0343AC  24040008   ADDIU A0, ZERO, 8
9D0343B0  3405A000   ORI A1, ZERO, -24576
9D0343B4  0F40B246   JAL mmc_bankrom
9D0343B8  02403021   ADDU A2, S2, ZERO
60:                           mmc_bankrom(8, 0xC000, (bank << 1) + 1);
9D0343BC  24040008   ADDIU A0, ZERO, 8
9D0343C0  3405C000   ORI A1, ZERO, -16384
9D0343C4  0F40B246   JAL mmc_bankrom
9D0343C8  02403021   ADDU A2, S2, ZERO
61:                           mmc_bankrom(8, 0xE000, (bank << 1) + 1);
9D0343CC  24040008   ADDIU A0, ZERO, 8
9D0343D0  3405E000   ORI A1, ZERO, -8192
9D0343D4  0F40B246   JAL mmc_bankrom
9D0343D8  02403021   ADDU A2, S2, ZERO
9D0343DC  0B40D123   J 0x9D03448C
9D0343E0  8FBF0024   LW RA, 36(SP)
62:                        }
63:                        else
64:                        {
65:                           mmc_bankrom(8, 0x8000, (bank << 1));
9D0343E4  24040008   ADDIU A0, ZERO, 8
9D0343E8  34058000   ORI A1, ZERO, -32768
9D0343EC  0F40B246   JAL mmc_bankrom
9D0343F0  02403021   ADDU A2, S2, ZERO
66:                           mmc_bankrom(8, 0xA000, (bank << 1));
9D0343F4  24040008   ADDIU A0, ZERO, 8
9D0343F8  3405A000   ORI A1, ZERO, -24576
9D0343FC  0F40B246   JAL mmc_bankrom
9D034400  02403021   ADDU A2, S2, ZERO
67:                           mmc_bankrom(8, 0xC000, (bank << 1));
9D034404  24040008   ADDIU A0, ZERO, 8
9D034408  3405C000   ORI A1, ZERO, -16384
9D03440C  0F40B246   JAL mmc_bankrom
9D034410  02403021   ADDU A2, S2, ZERO
68:                           mmc_bankrom(8, 0xE000, (bank << 1));
9D034414  24040008   ADDIU A0, ZERO, 8
9D034418  3405E000   ORI A1, ZERO, -8192
9D03441C  0F40B246   JAL mmc_bankrom
9D034420  02403021   ADDU A2, S2, ZERO
69:                        }
70:                        break;
71:                  
72:                     case 3:
73:                        mmc_bankrom(8, 0xC000, (bank << 1) + swap);
9D03442C  24040008   ADDIU A0, ZERO, 8
9D034430  3405C000   ORI A1, ZERO, -16384
9D034434  0F40B246   JAL mmc_bankrom
9D034438  02513021   ADDU A2, S2, S1
74:                        mmc_bankrom(8, 0xE000, (bank << 1) + (swap ^ 1));
9D03443C  3A260001   XORI A2, S1, 1
9D034440  24040008   ADDIU A0, ZERO, 8
9D034444  3405E000   ORI A1, ZERO, -8192
9D034448  0F40B246   JAL mmc_bankrom
9D03444C  02463021   ADDU A2, S2, A2
75:                  
76:                        if (value & 0x40)
9D034450  32100040   ANDI S0, S0, 64
9D034454  321000FF   ANDI S0, S0, 255
9D034458  12000007   BEQ S0, ZERO, 0x9D034478
9D03445C  00002021   ADDU A0, ZERO, ZERO
77:                           ppu_mirror(0, 0, 1, 1); /* horizontal */
9D034460  00002821   ADDU A1, ZERO, ZERO
9D034464  24060001   ADDIU A2, ZERO, 1
9D034468  0F406128   JAL ppu_mirror
9D03446C  24070001   ADDIU A3, ZERO, 1
9D034470  0B40D123   J 0x9D03448C
9D034474  8FBF0024   LW RA, 36(SP)
78:                        else
79:                           ppu_mirror(0, 1, 0, 1); /* vertical */
9D034478  24050001   ADDIU A1, ZERO, 1
9D03447C  00003021   ADDU A2, ZERO, ZERO
9D034480  0F406128   JAL ppu_mirror
9D034484  24070001   ADDIU A3, ZERO, 1
80:                        break;
81:                  
82:                     default:
83:                        break;
84:                     }
85:                  }
9D0342C8  0B40D123   J 0x9D03448C
9D0342CC  8FBF0024   LW RA, 36(SP)
9D034358  0B40D123   J 0x9D03448C
9D03435C  8FBF0024   LW RA, 36(SP)
9D034424  0B40D123   J 0x9D03448C
9D034428  8FBF0024   LW RA, 36(SP)
9D034488  8FBF0024   LW RA, 36(SP)
9D03448C  8FB40020   LW S4, 32(SP)
9D034490  8FB3001C   LW S3, 28(SP)
9D034494  8FB20018   LW S2, 24(SP)
9D034498  8FB10014   LW S1, 20(SP)
9D03449C  8FB00010   LW S0, 16(SP)
9D0344A0  03E00008   JR RA
9D0344A4  27BD0028   ADDIU SP, SP, 40
86:                  
87:                  static void map15_init(void)
88:                  {
9D034258  27BDFFE8   ADDIU SP, SP, -24
9D03425C  AFBF0014   SW RA, 20(SP)
89:                     mmc_bankrom(32, 0x8000, 0);
9D034260  24040020   ADDIU A0, ZERO, 32
9D034264  34058000   ORI A1, ZERO, -32768
9D034268  0F40B246   JAL mmc_bankrom
9D03426C  00003021   ADDU A2, ZERO, ZERO
90:                  }
9D034270  8FBF0014   LW RA, 20(SP)
9D034274  03E00008   JR RA
9D034278  27BD0018   ADDIU SP, SP, 24
91:                  
92:                  static map_memwrite map15_memwrite[] =
93:                  {
94:                     { 0x8000, 0xFFFF, map15_write },
95:                     {     -1,     -1, NULL }
96:                  };
97:                  
98:                  mapintf_t map15_intf =
99:                  {
100:                    15, /* mapper number */
101:                    "Contra 100-in-1", /* mapper name */
102:                    map15_init, /* init routine */
103:                    NULL, /* vblank callback */
104:                    NULL, /* hblank callback */
105:                    NULL, /* get state (snss) */
106:                    NULL, /* set state (snss) */
107:                    NULL, /* memory read structure */
108:                    map15_memwrite, /* memory write structure */
109:                    NULL /* external sound device */
110:                 };
111:                 
112:                 /*
113:                 ** $Log: map015.c,v $
114:                 ** Revision 1.2  2001/04/27 14:37:11  neil
115:                 ** wheeee
116:                 **
117:                 ** Revision 1.1  2001/04/27 12:54:40  neil
118:                 ** blah
119:                 **
120:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
121:                 ** initial
122:                 **
123:                 ** Revision 1.1  2000/10/24 12:19:33  matt
124:                 ** changed directory structure
125:                 **
126:                 ** Revision 1.6  2000/10/22 19:17:46  matt
127:                 ** mapper cleanups galore
128:                 **
129:                 ** Revision 1.5  2000/10/22 15:03:13  matt
130:                 ** simplified mirroring
131:                 **
132:                 ** Revision 1.4  2000/10/21 19:33:38  matt
133:                 ** many more cleanups
134:                 **
135:                 ** Revision 1.3  2000/07/10 05:29:03  matt
136:                 ** cleaned up some mirroring issues
137:                 **
138:                 ** Revision 1.2  2000/07/06 02:48:43  matt
139:                 ** clearly labelled structure members
140:                 **
141:                 ** Revision 1.1  2000/07/05 05:05:18  matt
142:                 ** initial revision
143:                 **
144:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map011.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map11.c
21:                  **
22:                  ** mapper 11 interface
23:                  ** $Id: map011.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  
29:                  /* mapper 11: Color Dreams, Wisdom Tree */
30:                  static void map11_write(uint32 address, uint8 value)
31:                  {
9D03ACFC  27BDFFE8   ADDIU SP, SP, -24
9D03AD00  AFBF0014   SW RA, 20(SP)
9D03AD04  AFB00010   SW S0, 16(SP)
9D03AD08  00A08021   ADDU S0, A1, ZERO
32:                     UNUSED(address);
33:                  
34:                     mmc_bankrom(32, 0x8000, value & 0x0F);
9D03AD0C  24040020   ADDIU A0, ZERO, 32
9D03AD10  34058000   ORI A1, ZERO, -32768
9D03AD14  0F40B246   JAL mmc_bankrom
9D03AD18  3206000F   ANDI A2, S0, 15
35:                     mmc_bankvrom(8, 0x0000, value >> 4);
9D03AD1C  24040008   ADDIU A0, ZERO, 8
9D03AD20  00002821   ADDU A1, ZERO, ZERO
9D03AD24  0F40B1E8   JAL mmc_bankvrom
9D03AD28  00103102   SRL A2, S0, 4
36:                  }
9D03AD2C  8FBF0014   LW RA, 20(SP)
9D03AD30  8FB00010   LW S0, 16(SP)
9D03AD34  03E00008   JR RA
9D03AD38  27BD0018   ADDIU SP, SP, 24
37:                  
38:                  static void map11_init(void)
39:                  {
9D03AD3C  27BDFFE8   ADDIU SP, SP, -24
9D03AD40  AFBF0014   SW RA, 20(SP)
40:                     mmc_bankrom(32, 0x8000, 0);
9D03AD44  24040020   ADDIU A0, ZERO, 32
9D03AD48  34058000   ORI A1, ZERO, -32768
9D03AD4C  0F40B246   JAL mmc_bankrom
9D03AD50  00003021   ADDU A2, ZERO, ZERO
41:                     mmc_bankvrom(8, 0x0000, 0);
9D03AD54  24040008   ADDIU A0, ZERO, 8
9D03AD58  00002821   ADDU A1, ZERO, ZERO
9D03AD5C  0F40B1E8   JAL mmc_bankvrom
9D03AD60  00003021   ADDU A2, ZERO, ZERO
42:                  }
9D03AD64  8FBF0014   LW RA, 20(SP)
9D03AD68  03E00008   JR RA
9D03AD6C  27BD0018   ADDIU SP, SP, 24
43:                  
44:                  static map_memwrite map11_memwrite[] =
45:                  {
46:                     { 0x8000, 0xFFFF, map11_write },
47:                     {     -1,     -1, NULL }
48:                  };
49:                  
50:                  mapintf_t map11_intf =
51:                  {
52:                     11, /* mapper number */
53:                     "Color Dreams", /* mapper name */
54:                     map11_init, /* init routine */
55:                     NULL, /* vblank callback */
56:                     NULL, /* hblank callback */
57:                     NULL, /* get state (snss) */
58:                     NULL, /* set state (snss) */
59:                     NULL, /* memory read structure */
60:                     map11_memwrite, /* memory write structure */
61:                     NULL /* external sound device */
62:                  };
63:                  
64:                  /*
65:                  ** $Log: map011.c,v $
66:                  ** Revision 1.2  2001/04/27 14:37:11  neil
67:                  ** wheeee
68:                  **
69:                  ** Revision 1.1  2001/04/27 12:54:40  neil
70:                  ** blah
71:                  **
72:                  ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
73:                  ** initial
74:                  **
75:                  ** Revision 1.1  2000/10/24 12:19:33  matt
76:                  ** changed directory structure
77:                  **
78:                  ** Revision 1.5  2000/10/22 19:17:46  matt
79:                  ** mapper cleanups galore
80:                  **
81:                  ** Revision 1.4  2000/10/21 19:33:38  matt
82:                  ** many more cleanups
83:                  **
84:                  ** Revision 1.3  2000/08/16 02:50:11  matt
85:                  ** random mapper cleanups
86:                  **
87:                  ** Revision 1.2  2000/07/06 02:48:43  matt
88:                  ** clearly labelled structure members
89:                  **
90:                  ** Revision 1.1  2000/07/04 23:11:45  matt
91:                  ** initial revision
92:                  **
93:                  */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map009.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map9.c
21:                  **
22:                  ** mapper 9 interface
23:                  ** $Id: map009.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <string.h>
27:                  #include <noftypes.h>
28:                  #include <nes_mmc.h>
29:                  #include <nes_ppu.h>
30:                  #include <libsnss.h>
31:                  
32:                  static uint8 latch[2];
33:                  static uint8 regs[4];
34:                  
35:                  /* Used when tile $FD/$FE is accessed */
36:                  static void mmc9_latchfunc(uint32 address, uint8 value)
37:                  {
9D032C00  27BDFFE8   ADDIU SP, SP, -24
9D032C04  AFBF0014   SW RA, 20(SP)
38:                     if (0xFD == value || 0xFE == value)
9D032BEC  24A20003   ADDIU V0, A1, 3
9D032BF0  304200FF   ANDI V0, V0, 255
9D032BF4  2C420002   SLTIU V0, V0, 2
9D032BF8  10400012   BEQ V0, ZERO, 0x9D032C44
9D032BFC  00000000   NOP
39:                     {
40:                        int reg;
41:                  
42:                        if (address)
9D032C08  10800004   BEQ A0, ZERO, 0x9D032C1C
9D032C0C  00801821   ADDU V1, A0, ZERO
43:                        {
44:                           latch[1] = value;
9D032C10  A3858089   SB A1, -32631(GP)
9D032C14  0B40CB09   J 0x9D032C24
9D032C18  24A5FF05   ADDIU A1, A1, -251
45:                           reg = 2 + (value - 0xFD);
46:                        }
47:                        else
48:                        {
49:                           latch[0] = value;
9D032C1C  A3858088   SB A1, -32632(GP)
50:                           reg = value - 0xFD;
9D032C20  24A5FF03   ADDIU A1, A1, -253
51:                        }
52:                  
53:                        mmc_bankvrom(4, address, regs[reg]);
9D032C24  27828084   ADDIU V0, GP, -32636
9D032C28  00451021   ADDU V0, V0, A1
9D032C2C  24040004   ADDIU A0, ZERO, 4
9D032C30  00602821   ADDU A1, V1, ZERO
9D032C34  0F40B1E8   JAL mmc_bankvrom
9D032C38  90460000   LBU A2, 0(V0)
54:                     }
55:                  }
9D032C3C  8FBF0014   LW RA, 20(SP)
9D032C40  27BD0018   ADDIU SP, SP, 24
9D032C44  03E00008   JR RA
9D032C48  00000000   NOP
56:                  
57:                  /* mapper 9: MMC2 */
58:                  /* MMC2: Punch-Out! */
59:                  static void map9_write(uint32 address, uint8 value)
60:                  {
9D032C60  27BDFFE8   ADDIU SP, SP, -24
9D032C64  AFBF0014   SW RA, 20(SP)
61:                     switch ((address & 0xF000) >> 12)
9D032C4C  7C841B00   EXT A0, A0, 12, 4
9D032C50  2484FFF6   ADDIU A0, A0, -10
9D032C54  2C820006   SLTIU V0, A0, 6
9D032C58  1040004B   BEQ V0, ZERO, 0x9D032D88
9D032C5C  00042080   SLL A0, A0, 2
9D032C68  3C029D03   LUI V0, -25341
9D032C6C  24422C80   ADDIU V0, V0, 11392
9D032C70  00442021   ADDU A0, V0, A0
9D032C74  8C820000   LW V0, 0(A0)
9D032C78  00400008   JR V0
9D032C7C  00A03021   ADDU A2, A1, ZERO
62:                     {
63:                     case 0xA:
64:                        mmc_bankrom(8, 0x8000, value);
9D032C98  24040008   ADDIU A0, ZERO, 8
9D032C9C  0F40B246   JAL mmc_bankrom
9D032CA0  34058000   ORI A1, ZERO, -32768
65:                        break;
9D032CA4  0B40CB61   J 0x9D032D84
9D032CA8  8FBF0014   LW RA, 20(SP)
66:                  
67:                     case 0xB:
68:                        regs[0] = value;
9D032CAC  A3858084   SB A1, -32636(GP)
69:                        if (0xFD == latch[0])
9D032CB0  93838088   LBU V1, -32632(GP)
9D032CB4  240200FD   ADDIU V0, ZERO, 253
9D032CB8  54620032   BNEL V1, V0, 0x9D032D84
9D032CBC  8FBF0014   LW RA, 20(SP)
70:                           mmc_bankvrom(4, 0x0000, value);
9D032CC0  24040004   ADDIU A0, ZERO, 4
9D032CC4  0F40B1E8   JAL mmc_bankvrom
9D032CC8  00002821   ADDU A1, ZERO, ZERO
71:                        break;
72:                  
73:                     case 0xC:
74:                        regs[1] = value;
9D032CD4  A3858085   SB A1, -32635(GP)
75:                        if (0xFE == latch[0])
9D032CD8  93838088   LBU V1, -32632(GP)
9D032CDC  240200FE   ADDIU V0, ZERO, 254
9D032CE0  54620028   BNEL V1, V0, 0x9D032D84
9D032CE4  8FBF0014   LW RA, 20(SP)
76:                           mmc_bankvrom(4, 0x0000, value);
9D032CE8  24040004   ADDIU A0, ZERO, 4
9D032CEC  0F40B1E8   JAL mmc_bankvrom
9D032CF0  00002821   ADDU A1, ZERO, ZERO
77:                        break;
78:                  
79:                     case 0xD:
80:                        regs[2] = value;
9D032CFC  A3858086   SB A1, -32634(GP)
81:                        if (0xFD == latch[1])
9D032D00  93838089   LBU V1, -32631(GP)
9D032D04  240200FD   ADDIU V0, ZERO, 253
9D032D08  5462001E   BNEL V1, V0, 0x9D032D84
9D032D0C  8FBF0014   LW RA, 20(SP)
82:                           mmc_bankvrom(4, 0x1000, value);
9D032D10  24040004   ADDIU A0, ZERO, 4
9D032D14  0F40B1E8   JAL mmc_bankvrom
9D032D18  24051000   ADDIU A1, ZERO, 4096
83:                        break;
84:                  
85:                     case 0xE:
86:                        regs[3] = value;
9D032D24  A3858087   SB A1, -32633(GP)
87:                        if (0xFE == latch[1])
9D032D28  93838089   LBU V1, -32631(GP)
9D032D2C  240200FE   ADDIU V0, ZERO, 254
9D032D30  54620014   BNEL V1, V0, 0x9D032D84
9D032D34  8FBF0014   LW RA, 20(SP)
88:                           mmc_bankvrom(4, 0x1000, value);
9D032D38  24040004   ADDIU A0, ZERO, 4
9D032D3C  0F40B1E8   JAL mmc_bankvrom
9D032D40  24051000   ADDIU A1, ZERO, 4096
89:                        break;
90:                  
91:                     case 0xF:
92:                        if (value & 1)
9D032D4C  30A60001   ANDI A2, A1, 1
9D032D50  10C00007   BEQ A2, ZERO, 0x9D032D70
9D032D54  00002021   ADDU A0, ZERO, ZERO
93:                           ppu_mirror(0, 0, 1, 1); /* horizontal */
9D032D58  00002821   ADDU A1, ZERO, ZERO
9D032D5C  24060001   ADDIU A2, ZERO, 1
9D032D60  0F406128   JAL ppu_mirror
9D032D64  24070001   ADDIU A3, ZERO, 1
9D032D68  0B40CB61   J 0x9D032D84
9D032D6C  8FBF0014   LW RA, 20(SP)
94:                        else
95:                           ppu_mirror(0, 1, 0, 1); /* vertical */
9D032D70  24050001   ADDIU A1, ZERO, 1
9D032D74  00003021   ADDU A2, ZERO, ZERO
9D032D78  0F406128   JAL ppu_mirror
9D032D7C  24070001   ADDIU A3, ZERO, 1
96:                        break;
97:                  
98:                     default:
99:                        break;
100:                    }
101:                 }
9D032CCC  0B40CB61   J 0x9D032D84
9D032CD0  8FBF0014   LW RA, 20(SP)
9D032CF4  0B40CB61   J 0x9D032D84
9D032CF8  8FBF0014   LW RA, 20(SP)
9D032D1C  0B40CB61   J 0x9D032D84
9D032D20  8FBF0014   LW RA, 20(SP)
9D032D44  0B40CB61   J 0x9D032D84
9D032D48  8FBF0014   LW RA, 20(SP)
9D032D80  8FBF0014   LW RA, 20(SP)
9D032D84  27BD0018   ADDIU SP, SP, 24
9D032D88  03E00008   JR RA
9D032D8C  00000000   NOP
102:                 
103:                 static void map9_init(void)
104:                 {
9D032D90  27BDFFE8   ADDIU SP, SP, -24
9D032D94  AFBF0014   SW RA, 20(SP)
105:                    memset(regs, 0, sizeof(regs));
9D032D98  AF808084   SW ZERO, -32636(GP)
106:                 
107:                    mmc_bankrom(8, 0x8000, 0);
9D032D9C  24040008   ADDIU A0, ZERO, 8
9D032DA0  34058000   ORI A1, ZERO, -32768
9D032DA4  0F40B246   JAL mmc_bankrom
9D032DA8  00003021   ADDU A2, ZERO, ZERO
108:                    mmc_bankrom(8, 0xA000, (mmc_getinfo()->rom_banks * 2) - 3);
9D032DAC  0F40B1DC   JAL mmc_getinfo
9D032DB0  00000000   NOP
9D032DB4  8C460010   LW A2, 16(V0)
9D032DB8  00063040   SLL A2, A2, 1
9D032DBC  24040008   ADDIU A0, ZERO, 8
9D032DC0  3405A000   ORI A1, ZERO, -24576
9D032DC4  0F40B246   JAL mmc_bankrom
9D032DC8  24C6FFFD   ADDIU A2, A2, -3
109:                    mmc_bankrom(8, 0xC000, (mmc_getinfo()->rom_banks * 2) - 2);
9D032DCC  0F40B1DC   JAL mmc_getinfo
9D032DD0  00000000   NOP
9D032DD4  8C460010   LW A2, 16(V0)
9D032DD8  24C6FFFF   ADDIU A2, A2, -1
9D032DDC  24040008   ADDIU A0, ZERO, 8
9D032DE0  3405C000   ORI A1, ZERO, -16384
9D032DE4  0F40B246   JAL mmc_bankrom
9D032DE8  00063040   SLL A2, A2, 1
110:                    mmc_bankrom(8, 0xE000, (mmc_getinfo()->rom_banks * 2) - 1);
9D032DEC  0F40B1DC   JAL mmc_getinfo
9D032DF0  00000000   NOP
9D032DF4  8C460010   LW A2, 16(V0)
9D032DF8  00063040   SLL A2, A2, 1
9D032DFC  24040008   ADDIU A0, ZERO, 8
9D032E00  3405E000   ORI A1, ZERO, -8192
9D032E04  0F40B246   JAL mmc_bankrom
9D032E08  24C6FFFF   ADDIU A2, A2, -1
111:                 
112:                    latch[0] = 0xFE;
9D032E0C  2402FFFE   ADDIU V0, ZERO, -2
9D032E10  A3828088   SB V0, -32632(GP)
113:                    latch[1] = 0xFE;
9D032E14  A3828089   SB V0, -32631(GP)
114:                 
115:                    ppu_setlatchfunc(mmc9_latchfunc);
9D032E18  3C049D03   LUI A0, -25341
9D032E1C  0F406391   JAL ppu_setlatchfunc
9D032E20  24842BEC   ADDIU A0, A0, 11244
116:                 }
9D032E24  8FBF0014   LW RA, 20(SP)
9D032E28  03E00008   JR RA
9D032E2C  27BD0018   ADDIU SP, SP, 24
117:                 
118:                 static void map9_getstate(SnssMapperBlock *state)
119:                 {
120:                    state->extraData.mapper9.latch[0] = latch[0];
9D032B84  93828088   LBU V0, -32632(GP)
9D032B88  A0820018   SB V0, 24(A0)
121:                    state->extraData.mapper9.latch[1] = latch[1];
9D032B8C  93828089   LBU V0, -32631(GP)
9D032B90  A0820019   SB V0, 25(A0)
122:                    state->extraData.mapper9.lastB000Write = regs[0];
9D032B94  93828084   LBU V0, -32636(GP)
9D032B98  A082001A   SB V0, 26(A0)
123:                    state->extraData.mapper9.lastC000Write = regs[1];
9D032B9C  93828085   LBU V0, -32635(GP)
9D032BA0  A082001B   SB V0, 27(A0)
124:                    state->extraData.mapper9.lastD000Write = regs[2];
9D032BA4  93828086   LBU V0, -32634(GP)
9D032BA8  A082001C   SB V0, 28(A0)
125:                    state->extraData.mapper9.lastE000Write = regs[3];
9D032BAC  93828087   LBU V0, -32633(GP)
9D032BB0  03E00008   JR RA
9D032BB4  A082001D   SB V0, 29(A0)
126:                 }
127:                 
128:                 static void map9_setstate(SnssMapperBlock *state)
129:                 {
130:                    latch[0] = state->extraData.mapper9.latch[0];
9D032BB8  90820018   LBU V0, 24(A0)
9D032BBC  A3828088   SB V0, -32632(GP)
131:                    latch[1] = state->extraData.mapper9.latch[1];
9D032BC0  90820019   LBU V0, 25(A0)
9D032BC4  A3828089   SB V0, -32631(GP)
132:                    regs[0] = state->extraData.mapper9.lastB000Write;
9D032BC8  9082001A   LBU V0, 26(A0)
9D032BCC  A3828084   SB V0, -32636(GP)
133:                    regs[1] = state->extraData.mapper9.lastC000Write;
9D032BD0  9082001B   LBU V0, 27(A0)
9D032BD4  A3828085   SB V0, -32635(GP)
134:                    regs[2] = state->extraData.mapper9.lastD000Write;
9D032BD8  9082001C   LBU V0, 28(A0)
9D032BDC  A3828086   SB V0, -32634(GP)
135:                    regs[3] = state->extraData.mapper9.lastE000Write;
9D032BE0  9082001D   LBU V0, 29(A0)
9D032BE4  03E00008   JR RA
9D032BE8  A3828087   SB V0, -32633(GP)
136:                 }
137:                 
138:                 static map_memwrite map9_memwrite[] =
139:                 {
140:                    { 0x8000, 0xFFFF, map9_write },
141:                    {     -1,     -1, NULL }
142:                 };
143:                 
144:                 mapintf_t map9_intf =
145:                 {
146:                    9, /* mapper number */
147:                    "MMC2", /* mapper name */
148:                    map9_init, /* init routine */
149:                    NULL, /* vblank callback */
150:                    NULL, /* hblank callback */
151:                    map9_getstate, /* get state (snss) */
152:                    map9_setstate, /* set state (snss) */
153:                    NULL, /* memory read structure */
154:                    map9_memwrite, /* memory write structure */
155:                    NULL /* external sound device */
156:                 };
157:                 
158:                 /*
159:                 ** $Log: map009.c,v $
160:                 ** Revision 1.2  2001/04/27 14:37:11  neil
161:                 ** wheeee
162:                 **
163:                 ** Revision 1.1  2001/04/27 12:54:40  neil
164:                 ** blah
165:                 **
166:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
167:                 ** initial
168:                 **
169:                 ** Revision 1.1  2000/10/24 12:19:33  matt
170:                 ** changed directory structure
171:                 **
172:                 ** Revision 1.9  2000/10/22 19:17:46  matt
173:                 ** mapper cleanups galore
174:                 **
175:                 ** Revision 1.8  2000/10/22 15:03:14  matt
176:                 ** simplified mirroring
177:                 **
178:                 ** Revision 1.7  2000/10/21 19:33:38  matt
179:                 ** many more cleanups
180:                 **
181:                 ** Revision 1.6  2000/07/17 05:11:35  matt
182:                 ** minor update from making PPU code less filthy
183:                 **
184:                 ** Revision 1.5  2000/07/15 23:52:19  matt
185:                 ** rounded out a bunch more mapper interfaces
186:                 **
187:                 ** Revision 1.4  2000/07/10 05:29:03  matt
188:                 ** cleaned up some mirroring issues
189:                 **
190:                 ** Revision 1.3  2000/07/06 02:48:43  matt
191:                 ** clearly labelled structure members
192:                 **
193:                 ** Revision 1.2  2000/07/05 22:50:33  matt
194:                 ** fixed punchout -- works 100% now
195:                 **
196:                 ** Revision 1.1  2000/07/05 05:05:18  matt
197:                 ** initial revision
198:                 **
199:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map008.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map8.c
21:                  **
22:                  ** mapper 8 interface
23:                  ** $Id: map008.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  
29:                  /* mapper 8: FFE F3xxx -- what the hell uses this? */
30:                  static void map8_write(uint32 address, uint8 value)
31:                  {
9D03A81C  27BDFFE8   ADDIU SP, SP, -24
9D03A820  AFBF0014   SW RA, 20(SP)
9D03A824  AFB00010   SW S0, 16(SP)
9D03A828  00A08021   ADDU S0, A1, ZERO
32:                     UNUSED(address);
33:                  
34:                     mmc_bankrom(16, 0x8000, value >> 3);
9D03A82C  24040010   ADDIU A0, ZERO, 16
9D03A830  34058000   ORI A1, ZERO, -32768
9D03A834  0F40B246   JAL mmc_bankrom
9D03A838  001030C2   SRL A2, S0, 3
35:                     mmc_bankvrom(8, 0x0000, value & 7);
9D03A83C  24040008   ADDIU A0, ZERO, 8
9D03A840  00002821   ADDU A1, ZERO, ZERO
9D03A844  0F40B1E8   JAL mmc_bankvrom
9D03A848  32060007   ANDI A2, S0, 7
36:                  }
9D03A84C  8FBF0014   LW RA, 20(SP)
9D03A850  8FB00010   LW S0, 16(SP)
9D03A854  03E00008   JR RA
9D03A858  27BD0018   ADDIU SP, SP, 24
37:                  
38:                  static void map8_init(void)
39:                  {
9D03A85C  27BDFFE8   ADDIU SP, SP, -24
9D03A860  AFBF0014   SW RA, 20(SP)
40:                     mmc_bankrom(16, 0x8000, 0);
9D03A864  24040010   ADDIU A0, ZERO, 16
9D03A868  34058000   ORI A1, ZERO, -32768
9D03A86C  0F40B246   JAL mmc_bankrom
9D03A870  00003021   ADDU A2, ZERO, ZERO
41:                     mmc_bankrom(16, 0xC000, 1);
9D03A874  24040010   ADDIU A0, ZERO, 16
9D03A878  3405C000   ORI A1, ZERO, -16384
9D03A87C  0F40B246   JAL mmc_bankrom
9D03A880  24060001   ADDIU A2, ZERO, 1
42:                     mmc_bankvrom(8, 0x0000, 0);
9D03A884  24040008   ADDIU A0, ZERO, 8
9D03A888  00002821   ADDU A1, ZERO, ZERO
9D03A88C  0F40B1E8   JAL mmc_bankvrom
9D03A890  00003021   ADDU A2, ZERO, ZERO
43:                  }
9D03A894  8FBF0014   LW RA, 20(SP)
9D03A898  03E00008   JR RA
9D03A89C  27BD0018   ADDIU SP, SP, 24
44:                  
45:                  static map_memwrite map8_memwrite[] =
46:                  {
47:                     { 0x8000, 0xFFFF, map8_write },
48:                     {     -1,     -1, NULL }
49:                  };
50:                  
51:                  mapintf_t map8_intf =
52:                  {
53:                     8, /* mapper number */
54:                     "FFE F3xxx", /* mapper name */
55:                     map8_init, /* init routine */
56:                     NULL, /* vblank callback */
57:                     NULL, /* hblank callback */
58:                     NULL, /* get state (snss) */
59:                     NULL, /* set state (snss) */
60:                     NULL, /* memory read structure */
61:                     map8_memwrite, /* memory write structure */
62:                     NULL /* external sound device */
63:                  };
64:                  
65:                  /*
66:                  ** $Log: map008.c,v $
67:                  ** Revision 1.2  2001/04/27 14:37:11  neil
68:                  ** wheeee
69:                  **
70:                  ** Revision 1.1  2001/04/27 12:54:40  neil
71:                  ** blah
72:                  **
73:                  ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
74:                  ** initial
75:                  **
76:                  ** Revision 1.1  2000/10/24 12:19:32  matt
77:                  ** changed directory structure
78:                  **
79:                  ** Revision 1.5  2000/10/22 19:17:47  matt
80:                  ** mapper cleanups galore
81:                  **
82:                  ** Revision 1.4  2000/10/21 19:33:38  matt
83:                  ** many more cleanups
84:                  **
85:                  ** Revision 1.3  2000/08/16 02:50:11  matt
86:                  ** random mapper cleanups
87:                  **
88:                  ** Revision 1.2  2000/07/06 02:48:43  matt
89:                  ** clearly labelled structure members
90:                  **
91:                  ** Revision 1.1  2000/07/04 23:11:45  matt
92:                  ** initial revision
93:                  **
94:                  */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map007.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map7.c
21:                  **
22:                  ** mapper 7 interface
23:                  ** $Id: map007.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes_ppu.h>
29:                  #include <log.h>
30:                  
31:                  /* mapper 7: AOROM */
32:                  static void map7_write(uint32 address, uint8 value)
33:                  {
9D03AFC0  27BDFFE8   ADDIU SP, SP, -24
9D03AFC4  AFBF0014   SW RA, 20(SP)
9D03AFC8  AFB00010   SW S0, 16(SP)
9D03AFCC  00A08021   ADDU S0, A1, ZERO
34:                     int mirror;
35:                     UNUSED(address);
36:                  
37:                     mmc_bankrom(32, 0x8000, value);
9D03AFD0  24040020   ADDIU A0, ZERO, 32
9D03AFD4  34058000   ORI A1, ZERO, -32768
9D03AFD8  0F40B246   JAL mmc_bankrom
9D03AFDC  02003021   ADDU A2, S0, ZERO
38:                     mirror = (value & 0x10) >> 4;
9D03AFE0  7E070100   EXT A3, S0, 4, 1
39:                     ppu_mirror(mirror, mirror, mirror, mirror);
9D03AFE4  00E02021   ADDU A0, A3, ZERO
9D03AFE8  00E02821   ADDU A1, A3, ZERO
9D03AFEC  0F406128   JAL ppu_mirror
9D03AFF0  00E03021   ADDU A2, A3, ZERO
40:                  }
9D03AFF4  8FBF0014   LW RA, 20(SP)
9D03AFF8  8FB00010   LW S0, 16(SP)
9D03AFFC  03E00008   JR RA
9D03B000  27BD0018   ADDIU SP, SP, 24
41:                  
42:                  static void map7_init(void)
43:                  {
9D03AF9C  27BDFFE8   ADDIU SP, SP, -24
9D03AFA0  AFBF0014   SW RA, 20(SP)
44:                     mmc_bankrom(32, 0x8000, 0);
9D03AFA4  24040020   ADDIU A0, ZERO, 32
9D03AFA8  34058000   ORI A1, ZERO, -32768
9D03AFAC  0F40B246   JAL mmc_bankrom
9D03AFB0  00003021   ADDU A2, ZERO, ZERO
45:                  }
9D03AFB4  8FBF0014   LW RA, 20(SP)
9D03AFB8  03E00008   JR RA
9D03AFBC  27BD0018   ADDIU SP, SP, 24
46:                  
47:                  static map_memwrite map7_memwrite[] =
48:                  {
49:                     { 0x8000, 0xFFFF, map7_write },
50:                     {     -1,     -1, NULL }
51:                  };
52:                  
53:                  mapintf_t map7_intf =
54:                  {
55:                     7, /* mapper number */
56:                     "AOROM", /* mapper name */
57:                     map7_init, /* init routine */
58:                     NULL, /* vblank callback */
59:                     NULL, /* hblank callback */
60:                     NULL, /* get state (snss) */
61:                     NULL, /* set state (snss) */
62:                     NULL, /* memory read structure */
63:                     map7_memwrite, /* memory write structure */
64:                     NULL /* external sound device */
65:                  };
66:                  
67:                  /*
68:                  ** $Log: map007.c,v $
69:                  ** Revision 1.2  2001/04/27 14:37:11  neil
70:                  ** wheeee
71:                  **
72:                  ** Revision 1.1  2001/04/27 12:54:40  neil
73:                  ** blah
74:                  **
75:                  ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
76:                  ** initial
77:                  **
78:                  ** Revision 1.1  2000/10/24 12:19:32  matt
79:                  ** changed directory structure
80:                  **
81:                  ** Revision 1.6  2000/10/22 19:17:46  matt
82:                  ** mapper cleanups galore
83:                  **
84:                  ** Revision 1.5  2000/10/22 15:03:13  matt
85:                  ** simplified mirroring
86:                  **
87:                  ** Revision 1.4  2000/10/21 19:33:38  matt
88:                  ** many more cleanups
89:                  **
90:                  ** Revision 1.3  2000/08/16 02:50:11  matt
91:                  ** random mapper cleanups
92:                  **
93:                  ** Revision 1.2  2000/07/06 02:48:43  matt
94:                  ** clearly labelled structure members
95:                  **
96:                  ** Revision 1.1  2000/07/04 23:11:45  matt
97:                  ** initial revision
98:                  **
99:                  */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map005.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map5.c
21:                  **
22:                  ** mapper 5 interface
23:                  ** $Id: map005.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes.h>
29:                  #include <log.h>
30:                  #include "mmc5_snd.h"
31:                  
32:                  /* TODO: there's lots of info about this mapper now;
33:                  ** let's implement it correctly/completely
34:                  */
35:                  
36:                  static struct
37:                  {
38:                     int counter, enabled;
39:                     int reset, latch;
40:                  } irq;
41:                  
42:                  /* MMC5 - Castlevania III, etc */
43:                  static void map5_hblank(int vblank)
44:                  {
9D031F44  27BDFFE8   ADDIU SP, SP, -24
9D031F48  AFBF0014   SW RA, 20(SP)
9D031F4C  AFB00010   SW S0, 16(SP)
45:                     UNUSED(vblank);
46:                  
47:                     if (irq.counter == nes_getcontextptr()->scanline)
9D031F50  3C02A001   LUI V0, -24575
9D031F54  0F408AD0   JAL nes_getcontextptr
9D031F58  8C50B8E4   LW S0, -18204(V0)
9D031F5C  8C420320   LW V0, 800(V0)
9D031F60  16020010   BNE S0, V0, 0x9D031FA4
9D031F64  8FBF0014   LW RA, 20(SP)
48:                     {
49:                        if (true == irq.enabled)
9D031F68  3C02A001   LUI V0, -24575
9D031F6C  8C43B8E8   LW V1, -18200(V0)
9D031F70  24020001   ADDIU V0, ZERO, 1
9D031F74  14620007   BNE V1, V0, 0x9D031F94
9D031F78  3C02A001   LUI V0, -24575
50:                        {
51:                           nes_irq();
9D031F7C  0F408A46   JAL nes_irq
9D031F80  00000000   NOP
52:                           irq.reset = true;
9D031F84  24030001   ADDIU V1, ZERO, 1
9D031F88  3C02A001   LUI V0, -24575
9D031F8C  AC43B8EC   SW V1, -18196(V0)
53:                        }
54:                        //else 
55:                        //   irq.reset = false;
56:                        irq.counter = irq.latch;
9D031F90  3C02A001   LUI V0, -24575
9D031F94  2443B8E4   ADDIU V1, V0, -18204
9D031F98  8C63000C   LW V1, 12(V1)
9D031F9C  AC43B8E4   SW V1, -18204(V0)
57:                     }
58:                  }
9D031FA0  8FBF0014   LW RA, 20(SP)
9D031FA4  8FB00010   LW S0, 16(SP)
9D031FA8  03E00008   JR RA
9D031FAC  27BD0018   ADDIU SP, SP, 24
59:                  
60:                  static void map5_write(uint32 address, uint8 value)
61:                  {
9D031D28  27BDFFE8   ADDIU SP, SP, -24
9D031D2C  AFBF0014   SW RA, 20(SP)
9D031D30  AFB00010   SW S0, 16(SP)
62:                     static int page_size = 8;
63:                  
64:                     /* ex-ram memory-- bleh! */
65:                     if (address >= 0x5C00 && address <= 0x5FFF)
9D031D18  2482A400   ADDIU V0, A0, -23552
9D031D1C  2C420400   SLTIU V0, V0, 1024
9D031D20  14400086   BNE V0, ZERO, 0x9D031F3C
9D031D24  24025122   ADDIU V0, ZERO, 20770
66:                        return;
67:                  
68:                     switch (address)
9D031D34  10820054   BEQ A0, V0, 0x9D031E88
9D031D38  00A08021   ADDU S0, A1, ZERO
9D031D3C  2C825123   SLTIU V0, A0, 20771
9D031D40  10400015   BEQ V0, ZERO, 0x9D031D98
9D031D44  2402512A   ADDIU V0, ZERO, 20778
9D031D48  24025115   ADDIU V0, ZERO, 20757
9D031D4C  10820033   BEQ A0, V0, 0x9D031E1C
9D031D50  2C825116   SLTIU V0, A0, 20758
9D031D54  10400008   BEQ V0, ZERO, 0x9D031D78
9D031D58  24025120   ADDIU V0, ZERO, 20768
9D031D5C  24025105   ADDIU V0, ZERO, 20741
9D031D60  10820022   BEQ A0, V0, 0x9D031DEC
9D031D64  24025114   ADDIU V0, ZERO, 20756
9D031D68  10820027   BEQ A0, V0, 0x9D031E08
9D031D6C  24040008   ADDIU A0, ZERO, 8
9D031D78  10820037   BEQ A0, V0, 0x9D031E58
9D031D7C  2C825121   SLTIU V0, A0, 20769
9D031D80  1040003B   BEQ V0, ZERO, 0x9D031E70
9D031D84  24025116   ADDIU V0, ZERO, 20758
9D031D88  1082002E   BEQ A0, V0, 0x9D031E44
9D031D8C  24040008   ADDIU A0, ZERO, 8
9D031D98  10820052   BEQ A0, V0, 0x9D031EE4
9D031D9C  2C82512B   SLTIU V0, A0, 20779
9D031DA0  1040000A   BEQ V0, ZERO, 0x9D031DCC
9D031DA4  24025203   ADDIU V0, ZERO, 20995
9D031DA8  24025128   ADDIU V0, ZERO, 20776
9D031DAC  10820041   BEQ A0, V0, 0x9D031EB4
9D031DB0  2C825129   SLTIU V0, A0, 20777
9D031DB4  10400045   BEQ V0, ZERO, 0x9D031ECC
9D031DB8  24025123   ADDIU V0, ZERO, 20771
9D031DBC  10820038   BEQ A0, V0, 0x9D031EA0
9D031DC0  24040001   ADDIU A0, ZERO, 1
9D031DCC  10820050   BEQ A0, V0, 0x9D031F10
9D031DD0  24025204   ADDIU V0, ZERO, 20996
9D031DD4  10820053   BEQ A0, V0, 0x9D031F24
9D031DD8  2402512B   ADDIU V0, ZERO, 20779
9D031DDC  54820055   BNEL A0, V0, 0x9D031F34
9D031DE0  8FBF0014   LW RA, 20(SP)
69:                     {
70:                     case 0x5100:
71:                        /* PRG page size setting */
72:                        /* 0:32k 1:16k 2,3:8k */
73:                        switch (value & 3)
74:                        {
75:                        case 0:
76:                           page_size = 32;
77:                           break;
78:                  
79:                        case 1:
80:                           page_size = 16;
81:                           break;
82:                        
83:                        case 2:
84:                        case 3:
85:                           page_size = 8;
86:                           break;
87:                        }
88:                        break;
89:                  
90:                     case 0x5101:
91:                        /* CHR page size setting */
92:                        /* 0:8k 1:4k 2:2k 3:1k */
93:                        break;
94:                  
95:                     case 0x5104:
96:                        /* GFX mode setting */
97:                        /*
98:                        00:split mode
99:                        01:split & exgraffix
100:                       10:ex-ram
101:                       11:exram + write protect
102:                       */
103:                       break;
104:                    
105:                    case 0x5105:
106:                       /* TODO: exram needs to fill in nametables 2-3 */
107:                       ppu_mirror(value & 3, (value >> 2) & 3, (value >> 4) & 3, value >> 6);
9D031DEC  30A40003   ANDI A0, A1, 3
9D031DF0  7CA50880   EXT A1, A1, 2, 2
9D031DF4  7E060900   EXT A2, S0, 4, 2
9D031DF8  0F406128   JAL ppu_mirror
9D031DFC  00103982   SRL A3, S0, 6
108:                       break;
9D031E00  0B40C7CD   J 0x9D031F34
9D031E04  8FBF0014   LW RA, 20(SP)
109:                 
110:                    case 0x5106:
111:                    case 0x5107:
112:                       /* ex-ram fill mode stuff */
113:                       break;
114:                    
115:                    case 0x5113:
116:                       /* ram page for $6000-7FFF? bit 2*/
117:                       break;
118:                    
119:                    case 0x5114:
120:                       mmc_bankrom(8, 0x8000, value);
9D031E08  34058000   ORI A1, ZERO, -32768
9D031E0C  0F40B246   JAL mmc_bankrom
9D031E10  02003021   ADDU A2, S0, ZERO
121:                       //if (page_size == 8)
122:                       //   mmc_bankrom(8, 0x8000, value);
123:                       break;
9D031E14  0B40C7CD   J 0x9D031F34
9D031E18  8FBF0014   LW RA, 20(SP)
124:                 
125:                    case 0x5115:
126:                       mmc_bankrom(8, 0x8000, value);
9D031E1C  24040008   ADDIU A0, ZERO, 8
9D031E20  34058000   ORI A1, ZERO, -32768
9D031E24  0F40B246   JAL mmc_bankrom
9D031E28  02003021   ADDU A2, S0, ZERO
127:                       mmc_bankrom(8, 0xA000, value + 1);
9D031E2C  24040008   ADDIU A0, ZERO, 8
9D031E30  3405A000   ORI A1, ZERO, -24576
9D031E34  0F40B246   JAL mmc_bankrom
9D031E38  26060001   ADDIU A2, S0, 1
128:                       //if (page_size == 8)
129:                       //   mmc_bankrom(8, 0xA000, value);
130:                       //else if (page_size == 16)
131:                       //   mmc_bankrom(16, 0x8000, value >> 1);
132:                          //mmc_bankrom(16, 0x8000, value & 0xFE);
133:                       break;
9D031E3C  0B40C7CD   J 0x9D031F34
9D031E40  8FBF0014   LW RA, 20(SP)
134:                 
135:                    case 0x5116:
136:                       mmc_bankrom(8, 0xC000, value);
9D031E44  3405C000   ORI A1, ZERO, -16384
9D031E48  0F40B246   JAL mmc_bankrom
9D031E4C  02003021   ADDU A2, S0, ZERO
137:                       //if (page_size == 8)
138:                       //   mmc_bankrom(8, 0xC000, value);
139:                       break;
9D031E50  0B40C7CD   J 0x9D031F34
9D031E54  8FBF0014   LW RA, 20(SP)
140:                 
141:                    case 0x5117:
142:                       //if (page_size == 8)
143:                       //   mmc_bankrom(8, 0xE000, value);
144:                       //else if (page_size == 16)
145:                       //   mmc_bankrom(16, 0xC000, value >> 1);
146:                          //mmc_bankrom(16, 0xC000, value & 0xFE);
147:                       //else if (page_size == 32)
148:                       //   mmc_bankrom(32, 0x8000, value >> 2);
149:                          //mmc_bankrom(32, 0x8000, value & 0xFC);
150:                       break;
151:                 
152:                    case 0x5120:
153:                       mmc_bankvrom(1, 0x0000, value);
9D031E58  24040001   ADDIU A0, ZERO, 1
9D031E5C  00002821   ADDU A1, ZERO, ZERO
9D031E60  0F40B1E8   JAL mmc_bankvrom
9D031E64  02003021   ADDU A2, S0, ZERO
154:                       break;
9D031E68  0B40C7CD   J 0x9D031F34
9D031E6C  8FBF0014   LW RA, 20(SP)
155:                 
156:                    case 0x5121:
157:                       mmc_bankvrom(1, 0x0400, value);
9D031E70  24040001   ADDIU A0, ZERO, 1
9D031E74  24050400   ADDIU A1, ZERO, 1024
9D031E78  0F40B1E8   JAL mmc_bankvrom
9D031E7C  02003021   ADDU A2, S0, ZERO
158:                       break;
9D031E80  0B40C7CD   J 0x9D031F34
9D031E84  8FBF0014   LW RA, 20(SP)
159:                 
160:                    case 0x5122:
161:                       mmc_bankvrom(1, 0x0800, value);
9D031E88  24040001   ADDIU A0, ZERO, 1
9D031E8C  24050800   ADDIU A1, ZERO, 2048
9D031E90  0F40B1E8   JAL mmc_bankvrom
9D031E94  02003021   ADDU A2, S0, ZERO
162:                       break;
9D031E98  0B40C7CD   J 0x9D031F34
9D031E9C  8FBF0014   LW RA, 20(SP)
163:                 
164:                    case 0x5123:
165:                       mmc_bankvrom(1, 0x0C00, value);
9D031EA0  24050C00   ADDIU A1, ZERO, 3072
9D031EA4  0F40B1E8   JAL mmc_bankvrom
9D031EA8  02003021   ADDU A2, S0, ZERO
166:                       break;
9D031EAC  0B40C7CD   J 0x9D031F34
9D031EB0  8FBF0014   LW RA, 20(SP)
167:                 
168:                    case 0x5124:
169:                    case 0x5125:
170:                    case 0x5126:
171:                    case 0x5127:
172:                       /* more VROM shit? */
173:                       break;
174:                 
175:                    case 0x5128:
176:                       mmc_bankvrom(1, 0x1000, value);
9D031EB4  24040001   ADDIU A0, ZERO, 1
9D031EB8  24051000   ADDIU A1, ZERO, 4096
9D031EBC  0F40B1E8   JAL mmc_bankvrom
9D031EC0  02003021   ADDU A2, S0, ZERO
177:                       break;
9D031EC4  0B40C7CD   J 0x9D031F34
9D031EC8  8FBF0014   LW RA, 20(SP)
178:                 
179:                    case 0x5129:
180:                       mmc_bankvrom(1, 0x1400, value);
9D031ECC  24040001   ADDIU A0, ZERO, 1
9D031ED0  24051400   ADDIU A1, ZERO, 5120
9D031ED4  0F40B1E8   JAL mmc_bankvrom
9D031ED8  02003021   ADDU A2, S0, ZERO
181:                       break;
9D031EDC  0B40C7CD   J 0x9D031F34
9D031EE0  8FBF0014   LW RA, 20(SP)
182:                 
183:                    case 0x512A:
184:                       mmc_bankvrom(1, 0x1800, value);
9D031EE4  24040001   ADDIU A0, ZERO, 1
9D031EE8  24051800   ADDIU A1, ZERO, 6144
9D031EEC  0F40B1E8   JAL mmc_bankvrom
9D031EF0  02003021   ADDU A2, S0, ZERO
185:                       break;
9D031EF4  0B40C7CD   J 0x9D031F34
9D031EF8  8FBF0014   LW RA, 20(SP)
186:                 
187:                    case 0x512B:
188:                       mmc_bankvrom(1, 0x1C00, value);
9D031DE4  0B40C7BF   J 0x9D031EFC
9D031DE8  24040001   ADDIU A0, ZERO, 1
9D031EFC  24051C00   ADDIU A1, ZERO, 7168
9D031F00  0F40B1E8   JAL mmc_bankvrom
9D031F04  02003021   ADDU A2, S0, ZERO
189:                       break;
9D031F08  0B40C7CD   J 0x9D031F34
9D031F0C  8FBF0014   LW RA, 20(SP)
190:                 
191:                    case 0x5203:
192:                       irq.counter = value;
9D031F10  3C02A001   LUI V0, -24575
9D031F14  AC45B8E4   SW A1, -18204(V0)
193:                       irq.latch = value;
9D031F18  2442B8E4   ADDIU V0, V0, -18204
194:                 //      irq.reset = false;
195:                       break;
9D031F1C  0B40C7CC   J 0x9D031F30
9D031F20  AC45000C   SW A1, 12(V0)
196:                 
197:                    case 0x5204:
198:                       irq.enabled = (value & 0x80) ? true : false;
9D031F24  000581C2   SRL S0, A1, 7
9D031F28  3C02A001   LUI V0, -24575
9D031F2C  AC50B8E8   SW S0, -18200(V0)
199:                 //      irq.reset = false;
200:                       break;
201:                 
202:                    default:
203:                 #ifdef NOFRENDO_DEBUG
204:                       log_printf("unknown mmc5 write: $%02X to $%04X\n", value, address);
205:                 #endif /* NOFRENDO_DEBUG */
206:                       break;
207:                    }
208:                 }
9D031D70  0B40C7CD   J 0x9D031F34
9D031D74  8FBF0014   LW RA, 20(SP)
9D031D90  0B40C7CD   J 0x9D031F34
9D031D94  8FBF0014   LW RA, 20(SP)
9D031DC4  0B40C7CD   J 0x9D031F34
9D031DC8  8FBF0014   LW RA, 20(SP)
9D031F30  8FBF0014   LW RA, 20(SP)
9D031F34  8FB00010   LW S0, 16(SP)
9D031F38  27BD0018   ADDIU SP, SP, 24
9D031F3C  03E00008   JR RA
9D031F40  00000000   NOP
209:                 
210:                 static uint8 map5_read(uint32 address)
211:                 {
212:                    /* Castlevania 3 IRQ counter */
213:                    if (address == 0x5204)
9D031C78  24035204   ADDIU V1, ZERO, 20996
9D031C7C  14830005   BNE A0, V1, 0x9D031C94
9D031C80  240200FF   ADDIU V0, ZERO, 255
214:                    {
215:                       /* if reset == 1, we've hit scanline */
216:                       return (irq.reset ? 0x40 : 0x00);
9D031C84  3C02A001   LUI V0, -24575
9D031C88  8C43B8EC   LW V1, -18196(V0)
9D031C8C  24020040   ADDIU V0, ZERO, 64
9D031C90  0003100A   MOVZ V0, ZERO, V1
217:                    }
218:                    else
219:                    {
220:                 #ifdef NOFRENDO_DEBUG
221:                       log_printf("invalid MMC5 read: $%04X", address);
222:                 #endif
223:                       return 0xFF;
224:                    }
225:                 }
9D031C94  03E00008   JR RA
9D031C98  00000000   NOP
226:                 
227:                 static void map5_init(void)
228:                 {
9D031CAC  27BDFFE8   ADDIU SP, SP, -24
9D031CB0  AFBF0014   SW RA, 20(SP)
229:                    mmc_bankrom(8, 0x8000, MMC_LASTBANK);
9D031CB4  24040008   ADDIU A0, ZERO, 8
9D031CB8  34058000   ORI A1, ZERO, -32768
9D031CBC  0F40B246   JAL mmc_bankrom
9D031CC0  2406FFFF   ADDIU A2, ZERO, -1
230:                    mmc_bankrom(8, 0xA000, MMC_LASTBANK);
9D031CC4  24040008   ADDIU A0, ZERO, 8
9D031CC8  3405A000   ORI A1, ZERO, -24576
9D031CCC  0F40B246   JAL mmc_bankrom
9D031CD0  2406FFFF   ADDIU A2, ZERO, -1
231:                    mmc_bankrom(8, 0xC000, MMC_LASTBANK);
9D031CD4  24040008   ADDIU A0, ZERO, 8
9D031CD8  3405C000   ORI A1, ZERO, -16384
9D031CDC  0F40B246   JAL mmc_bankrom
9D031CE0  2406FFFF   ADDIU A2, ZERO, -1
232:                    mmc_bankrom(8, 0xE000, MMC_LASTBANK);
9D031CE4  24040008   ADDIU A0, ZERO, 8
9D031CE8  3405E000   ORI A1, ZERO, -8192
9D031CEC  0F40B246   JAL mmc_bankrom
9D031CF0  2406FFFF   ADDIU A2, ZERO, -1
233:                 
234:                    irq.counter = irq.enabled = 0;
9D031CF4  3C03A001   LUI V1, -24575
9D031CF8  2462B8E4   ADDIU V0, V1, -18204
9D031CFC  AC400004   SW ZERO, 4(V0)
9D031D00  AC60B8E4   SW ZERO, -18204(V1)
235:                    irq.reset = irq.latch = 0;
9D031D04  AC40000C   SW ZERO, 12(V0)
9D031D08  AC400008   SW ZERO, 8(V0)
236:                 }
9D031D0C  8FBF0014   LW RA, 20(SP)
9D031D10  03E00008   JR RA
9D031D14  27BD0018   ADDIU SP, SP, 24
237:                 
238:                 /* incomplete SNSS definition */
239:                 static void map5_getstate(SnssMapperBlock *state)
240:                 {
241:                    state->extraData.mapper5.dummy = 0;
9D031C9C  03E00008   JR RA
9D031CA0  A0800018   SB ZERO, 24(A0)
242:                 }
243:                 
244:                 static void map5_setstate(SnssMapperBlock *state)
245:                 {
9D031CA4  03E00008   JR RA
9D031CA8  00000000   NOP
246:                    UNUSED(state);
247:                 }
248:                 
249:                 static map_memwrite map5_memwrite[] =
250:                 {
251:                    /* $5000 - $5015 handled by sound */
252:                    { 0x5016, 0x5FFF, map5_write },
253:                    { 0x8000, 0xFFFF, map5_write },
254:                    {     -1,     -1, NULL }
255:                 };
256:                 
257:                 static map_memread map5_memread[] = 
258:                 {
259:                    { 0x5204, 0x5204, map5_read },
260:                    {     -1,     -1, NULL }
261:                 };
262:                 
263:                 mapintf_t map5_intf =
264:                 {
265:                    5, /* mapper number */
266:                    "MMC5", /* mapper name */
267:                    map5_init, /* init routine */
268:                    NULL, /* vblank callback */
269:                    map5_hblank, /* hblank callback */
270:                    map5_getstate, /* get state (snss) */
271:                    map5_setstate, /* set state (snss) */
272:                    map5_memread, /* memory read structure */
273:                    map5_memwrite, /* memory write structure */
274:                    &mmc5_ext /* external sound device */
275:                 };
276:                 /*
277:                 ** $Log: map005.c,v $
278:                 ** Revision 1.2  2001/04/27 14:37:11  neil
279:                 ** wheeee
280:                 **
281:                 ** Revision 1.1  2001/04/27 12:54:40  neil
282:                 ** blah
283:                 **
284:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
285:                 ** initial
286:                 **
287:                 ** Revision 1.2  2000/11/25 20:32:33  matt
288:                 ** scanline interface change
289:                 **
290:                 ** Revision 1.1  2000/10/24 12:19:32  matt
291:                 ** changed directory structure
292:                 **
293:                 ** Revision 1.11  2000/10/22 19:17:46  matt
294:                 ** mapper cleanups galore
295:                 **
296:                 ** Revision 1.10  2000/10/21 19:33:37  matt
297:                 ** many more cleanups
298:                 **
299:                 ** Revision 1.9  2000/10/17 03:23:16  matt
300:                 ** added mmc5 sound interface
301:                 **
302:                 ** Revision 1.8  2000/10/10 13:58:17  matt
303:                 ** stroustrup squeezing his way in the door
304:                 **
305:                 ** Revision 1.7  2000/08/16 02:50:11  matt
306:                 ** random mapper cleanups
307:                 **
308:                 ** Revision 1.6  2000/07/15 23:52:19  matt
309:                 ** rounded out a bunch more mapper interfaces
310:                 **
311:                 ** Revision 1.5  2000/07/10 13:51:25  matt
312:                 ** using generic nes_irq() routine now
313:                 **
314:                 ** Revision 1.4  2000/07/10 05:29:03  matt
315:                 ** cleaned up some mirroring issues
316:                 **
317:                 ** Revision 1.3  2000/07/06 02:48:43  matt
318:                 ** clearly labelled structure members
319:                 **
320:                 ** Revision 1.2  2000/07/05 05:04:51  matt
321:                 ** fixed h-blank callback
322:                 **
323:                 ** Revision 1.1  2000/07/04 23:11:45  matt
324:                 ** initial revision
325:                 **
326:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map004.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map4.c
21:                  **
22:                  ** mapper 4 interface
23:                  ** $Id: map004.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  #include <nes.h>
29:                  #include <libsnss.h>
30:                  
31:                  static struct
32:                  {
33:                     int counter, latch;
34:                     bool enabled, reset;
35:                  } irq;
36:                  
37:                  static uint8 reg;
38:                  static uint8 command;
39:                  static uint16 vrombase;
40:                  
41:                  /* mapper 4: MMC3 */
42:                  static void map4_write(uint32 address, uint8 value)
43:                  {
9D02FC78  27BDFFE8   ADDIU SP, SP, -24
9D02FC7C  AFBF0014   SW RA, 20(SP)
9D02FC80  AFB00010   SW S0, 16(SP)
44:                     switch (address & 0xE001)
9D02FC84  3084E001   ANDI A0, A0, -8191
9D02FC88  3402C000   ORI V0, ZERO, -16384
9D02FC8C  108200A2   BEQ A0, V0, 0x9D02FF18
9D02FC90  00A08021   ADDU S0, A1, ZERO
9D02FC94  3402C001   ORI V0, ZERO, -16383
9D02FC98  0082102B   SLTU V0, A0, V0
9D02FC9C  1040000A   BEQ V0, ZERO, 0x9D02FCC8
9D02FCA0  3402E000   ORI V0, ZERO, -8192
9D02FCA4  34028001   ORI V0, ZERO, -32767
9D02FCA8  1082002E   BEQ A0, V0, 0x9D02FD64
9D02FCAC  3402A000   ORI V0, ZERO, -24576
9D02FCB0  10820083   BEQ A0, V0, 0x9D02FEC0
9D02FCB4  34028000   ORI V0, ZERO, -32768
9D02FCB8  148200A7   BNE A0, V0, 0x9D02FF58
9D02FCBC  3C02A001   LUI V0, -24575
9D02FCC8  1082009C   BEQ A0, V0, 0x9D02FF3C
9D02FCCC  3402E001   ORI V0, ZERO, -8191
9D02FCD0  1082009D   BEQ A0, V0, 0x9D02FF48
9D02FCD4  3402C001   ORI V0, ZERO, -16383
9D02FCD8  5482009F   BNEL A0, V0, 0x9D02FF58
9D02FCDC  3C02A001   LUI V0, -24575
45:                     {
46:                     case 0x8000:
47:                        command = value;
9D02FCC0  0B40BF3A   J 0x9D02FCE8
9D02FCC4  A385806E   SB A1, -32658(GP)
48:                        vrombase = (command & 0x80) ? 0x1000 : 0x0000;
9D02FCE8  000519C2   SRL V1, A1, 7
9D02FCEC  24021000   ADDIU V0, ZERO, 4096
9D02FCF0  0003100A   MOVZ V0, ZERO, V1
9D02FCF4  A782806C   SH V0, -32660(GP)
49:                        
50:                        if (reg != (value & 0x40))
9D02FCF8  30B00040   ANDI S0, A1, 64
9D02FCFC  321000FF   ANDI S0, S0, 255
9D02FD00  9382806F   LBU V0, -32657(GP)
9D02FD04  50500093   BEQL V0, S0, 0x9D02FF54
9D02FD08  A390806F   SB S0, -32657(GP)
51:                        {
52:                           if (value & 0x40)
9D02FD0C  1200000B   BEQ S0, ZERO, 0x9D02FD3C
9D02FD10  00000000   NOP
53:                              mmc_bankrom(8, 0x8000, (mmc_getinfo()->rom_banks * 2) - 2);
9D02FD14  0F40B1DC   JAL mmc_getinfo
9D02FD18  00000000   NOP
9D02FD1C  8C460010   LW A2, 16(V0)
9D02FD20  24C6FFFF   ADDIU A2, A2, -1
9D02FD24  24040008   ADDIU A0, ZERO, 8
9D02FD28  34058000   ORI A1, ZERO, -32768
9D02FD2C  0F40B246   JAL mmc_bankrom
9D02FD30  00063040   SLL A2, A2, 1
9D02FD34  0B40BFD5   J 0x9D02FF54
9D02FD38  A390806F   SB S0, -32657(GP)
54:                           else
55:                              mmc_bankrom(8, 0xC000, (mmc_getinfo()->rom_banks * 2) - 2);
9D02FD3C  0F40B1DC   JAL mmc_getinfo
9D02FD40  00000000   NOP
9D02FD44  8C460010   LW A2, 16(V0)
9D02FD48  24C6FFFF   ADDIU A2, A2, -1
9D02FD4C  24040008   ADDIU A0, ZERO, 8
9D02FD50  3405C000   ORI A1, ZERO, -16384
9D02FD54  0F40B246   JAL mmc_bankrom
9D02FD58  00063040   SLL A2, A2, 1
56:                        }
57:                        reg = value & 0x40;
58:                        break;
9D02FD5C  0B40BFD5   J 0x9D02FF54
9D02FD60  A390806F   SB S0, -32657(GP)
59:                  
60:                     case 0x8001:
61:                        switch (command & 0x07)
9D02FD64  9382806E   LBU V0, -32658(GP)
9D02FD68  30440007   ANDI A0, V0, 7
9D02FD6C  00042080   SLL A0, A0, 2
9D02FD70  3C039D03   LUI V1, -25341
9D02FD74  2463FD88   ADDIU V1, V1, -632
9D02FD78  00641821   ADDU V1, V1, A0
9D02FD7C  8C630000   LW V1, 0(V1)
9D02FD80  00600008   JR V1
9D02FD84  00000000   NOP
62:                        {
63:                        case 0:
64:                           value &= 0xFE;
65:                           mmc_bankvrom(1, vrombase ^ 0x0000, value);
9D02FDA8  30B000FE   ANDI S0, A1, 254
9D02FDAC  24040001   ADDIU A0, ZERO, 1
9D02FDB0  9785806C   LHU A1, -32660(GP)
9D02FDB4  0F40B1E8   JAL mmc_bankvrom
9D02FDB8  02003021   ADDU A2, S0, ZERO
66:                           mmc_bankvrom(1, vrombase ^ 0x0400, value + 1);
9D02FDBC  9785806C   LHU A1, -32660(GP)
9D02FDC0  24040001   ADDIU A0, ZERO, 1
9D02FDC4  38A50400   XORI A1, A1, 1024
9D02FDC8  0F40B1E8   JAL mmc_bankvrom
9D02FDCC  26060001   ADDIU A2, S0, 1
67:                           break;
9D02FDD0  0B40BFD6   J 0x9D02FF58
9D02FDD4  3C02A001   LUI V0, -24575
68:                  
69:                        case 1:
70:                           value &= 0xFE;
71:                           mmc_bankvrom(1, vrombase ^ 0x0800, value);
9D02FDD8  30B000FE   ANDI S0, A1, 254
9D02FDDC  9785806C   LHU A1, -32660(GP)
9D02FDE0  24040001   ADDIU A0, ZERO, 1
9D02FDE4  38A50800   XORI A1, A1, 2048
9D02FDE8  0F40B1E8   JAL mmc_bankvrom
9D02FDEC  02003021   ADDU A2, S0, ZERO
72:                           mmc_bankvrom(1, vrombase ^ 0x0C00, value + 1);
9D02FDF0  9785806C   LHU A1, -32660(GP)
9D02FDF4  24040001   ADDIU A0, ZERO, 1
9D02FDF8  38A50C00   XORI A1, A1, 3072
9D02FDFC  0F40B1E8   JAL mmc_bankvrom
9D02FE00  26060001   ADDIU A2, S0, 1
73:                           break;
9D02FE04  0B40BFD6   J 0x9D02FF58
9D02FE08  3C02A001   LUI V0, -24575
74:                  
75:                        case 2:
76:                           mmc_bankvrom(1, vrombase ^ 0x1000, value);
9D02FE0C  9785806C   LHU A1, -32660(GP)
9D02FE10  24040001   ADDIU A0, ZERO, 1
9D02FE14  38A51000   XORI A1, A1, 4096
9D02FE18  0F40B1E8   JAL mmc_bankvrom
9D02FE1C  02003021   ADDU A2, S0, ZERO
77:                           break;
9D02FE20  0B40BFD6   J 0x9D02FF58
9D02FE24  3C02A001   LUI V0, -24575
78:                  
79:                        case 3:
80:                           mmc_bankvrom(1, vrombase ^ 0x1400, value);
9D02FE28  9785806C   LHU A1, -32660(GP)
9D02FE2C  24040001   ADDIU A0, ZERO, 1
9D02FE30  38A51400   XORI A1, A1, 5120
9D02FE34  0F40B1E8   JAL mmc_bankvrom
9D02FE38  02003021   ADDU A2, S0, ZERO
81:                           break;
9D02FE3C  0B40BFD6   J 0x9D02FF58
9D02FE40  3C02A001   LUI V0, -24575
82:                  
83:                        case 4:
84:                           mmc_bankvrom(1, vrombase ^ 0x1800, value);
9D02FE44  9785806C   LHU A1, -32660(GP)
9D02FE48  24040001   ADDIU A0, ZERO, 1
9D02FE4C  38A51800   XORI A1, A1, 6144
9D02FE50  0F40B1E8   JAL mmc_bankvrom
9D02FE54  02003021   ADDU A2, S0, ZERO
85:                           break;
9D02FE58  0B40BFD6   J 0x9D02FF58
9D02FE5C  3C02A001   LUI V0, -24575
86:                  
87:                        case 5:
88:                           mmc_bankvrom(1, vrombase ^ 0x1C00, value);
9D02FE60  9785806C   LHU A1, -32660(GP)
9D02FE64  24040001   ADDIU A0, ZERO, 1
9D02FE68  38A51C00   XORI A1, A1, 7168
9D02FE6C  0F40B1E8   JAL mmc_bankvrom
9D02FE70  02003021   ADDU A2, S0, ZERO
89:                           break;
9D02FE74  0B40BFD6   J 0x9D02FF58
9D02FE78  3C02A001   LUI V0, -24575
90:                  
91:                        case 6:
92:                           mmc_bankrom(8, (command & 0x40) ? 0xC000 : 0x8000, value);
9D02FE7C  30420040   ANDI V0, V0, 64
9D02FE80  304500FF   ANDI A1, V0, 255
9D02FE84  24040008   ADDIU A0, ZERO, 8
9D02FE88  3402C000   ORI V0, ZERO, -16384
9D02FE8C  34038000   ORI V1, ZERO, -32768
9D02FE90  0065100A   MOVZ V0, V1, A1
9D02FE94  00402821   ADDU A1, V0, ZERO
9D02FE98  0F40B246   JAL mmc_bankrom
9D02FE9C  02003021   ADDU A2, S0, ZERO
93:                           break;
9D02FEA0  0B40BFD6   J 0x9D02FF58
9D02FEA4  3C02A001   LUI V0, -24575
94:                  
95:                        case 7:
96:                           mmc_bankrom(8, 0xA000, value);
9D02FEA8  24040008   ADDIU A0, ZERO, 8
9D02FEAC  3405A000   ORI A1, ZERO, -24576
9D02FEB0  0F40B246   JAL mmc_bankrom
9D02FEB4  02003021   ADDU A2, S0, ZERO
97:                           break;
9D02FEB8  0B40BFD6   J 0x9D02FF58
9D02FEBC  3C02A001   LUI V0, -24575
98:                        }
99:                        break;
100:                 
101:                    case 0xA000:
102:                       /* four screen mirroring crap */
103:                       if (0 == (mmc_getinfo()->flags & ROM_FLAG_FOURSCREEN))
9D02FEC0  0F40B1DC   JAL mmc_getinfo
9D02FEC4  00000000   NOP
9D02FEC8  90420028   LBU V0, 40(V0)
9D02FECC  30420004   ANDI V0, V0, 4
9D02FED0  304200FF   ANDI V0, V0, 255
9D02FED4  14400020   BNE V0, ZERO, 0x9D02FF58
9D02FED8  3C02A001   LUI V0, -24575
104:                       {
105:                          if (value & 1)
9D02FEDC  32100001   ANDI S0, S0, 1
9D02FEE0  12000007   BEQ S0, ZERO, 0x9D02FF00
9D02FEE4  00002021   ADDU A0, ZERO, ZERO
106:                             ppu_mirror(0, 0, 1, 1); /* horizontal */
9D02FEE8  00002821   ADDU A1, ZERO, ZERO
9D02FEEC  24060001   ADDIU A2, ZERO, 1
9D02FEF0  0F406128   JAL ppu_mirror
9D02FEF4  24070001   ADDIU A3, ZERO, 1
9D02FEF8  0B40BFD6   J 0x9D02FF58
9D02FEFC  3C02A001   LUI V0, -24575
107:                          else
108:                             ppu_mirror(0, 1, 0, 1); /* vertical */
9D02FF00  24050001   ADDIU A1, ZERO, 1
9D02FF04  00003021   ADDU A2, ZERO, ZERO
9D02FF08  0F406128   JAL ppu_mirror
9D02FF0C  24070001   ADDIU A3, ZERO, 1
109:                       }
110:                       break;
111:                 
112:                    case 0xA001:
113:                       /* Save RAM enable / disable */
114:                       /* Messes up Startropics I/II if implemented -- bah */
115:                       break;
116:                 
117:                    case 0xC000:
118:                       irq.latch = value;
9D02FF18  3C02A001   LUI V0, -24575
119:                 //      if (irq.reset)
120:                 //         irq.counter = irq.latch;
121:                       break;
9D02FF1C  0B40BFD5   J 0x9D02FF54
9D02FF20  AC45B888   SW A1, -18296(V0)
122:                 
123:                    case 0xC001:
124:                       irq.reset = true;
9D02FCE0  0B40BFC9   J 0x9D02FF24
9D02FCE4  3C02A001   LUI V0, -24575
9D02FF24  2443B884   ADDIU V1, V0, -18300
9D02FF28  24040001   ADDIU A0, ZERO, 1
9D02FF2C  AC64000C   SW A0, 12(V1)
125:                       irq.counter = irq.latch;
9D02FF30  8C630004   LW V1, 4(V1)
126:                       break;
9D02FF34  0B40BFD5   J 0x9D02FF54
9D02FF38  AC43B884   SW V1, -18300(V0)
127:                 
128:                    case 0xE000:
129:                       irq.enabled = false;
9D02FF3C  3C02A001   LUI V0, -24575
130:                 //      if (irq.reset)
131:                 //         irq.counter = irq.latch;
132:                       break;
9D02FF40  0B40BFD5   J 0x9D02FF54
9D02FF44  AC40B88C   SW ZERO, -18292(V0)
133:                 
134:                    case 0xE001:
135:                       irq.enabled = true;
9D02FF48  24030001   ADDIU V1, ZERO, 1
9D02FF4C  3C02A001   LUI V0, -24575
9D02FF50  AC43B88C   SW V1, -18292(V0)
136:                 //      if (irq.reset)
137:                 //         irq.counter = irq.latch;
138:                       break;
139:                 
140:                    default:
141:                       break;
142:                    }
143:                 
144:                    if (true == irq.reset)
9D02FF10  0B40BFD6   J 0x9D02FF58
9D02FF14  3C02A001   LUI V0, -24575
9D02FF54  3C02A001   LUI V0, -24575
9D02FF58  8C43B890   LW V1, -18288(V0)
9D02FF5C  24020001   ADDIU V0, ZERO, 1
9D02FF60  14620006   BNE V1, V0, 0x9D02FF7C
9D02FF64  8FBF0014   LW RA, 20(SP)
145:                       irq.counter = irq.latch;
9D02FF68  3C02A001   LUI V0, -24575
9D02FF6C  2443B884   ADDIU V1, V0, -18300
9D02FF70  8C630004   LW V1, 4(V1)
9D02FF74  AC43B884   SW V1, -18300(V0)
146:                 }
9D02FF78  8FBF0014   LW RA, 20(SP)
9D02FF7C  8FB00010   LW S0, 16(SP)
9D02FF80  03E00008   JR RA
9D02FF84  27BD0018   ADDIU SP, SP, 24
147:                 
148:                 static void map4_hblank(int vblank)
149:                 {
9D02FF90  27BDFFE8   ADDIU SP, SP, -24
9D02FF94  AFBF0014   SW RA, 20(SP)
150:                    if (vblank)
9D02FF88  14800019   BNE A0, ZERO, 0x9D02FFF0
9D02FF8C  00000000   NOP
151:                       return;
152:                 
153:                    if (ppu_enabled())
9D02FF98  0F406397   JAL ppu_enabled
9D02FF9C  00000000   NOP
9D02FFA0  10400011   BEQ V0, ZERO, .LVL44
9D02FFA4  3C02A001   LUI V0, -24575
154:                    {
155:                       if (irq.counter >= 0)
9D02FFA8  8C42B884   LW V0, -18300(V0)
9D02FFAC  0440000E   BLTZ V0, .LVL44
9D02FFB0  3C03A001   LUI V1, -24575
156:                       {
157:                          irq.reset = false;
9D02FFB4  2464B884   ADDIU A0, V1, -18300
9D02FFB8  AC80000C   SW ZERO, 12(A0)
158:                          irq.counter--;
9D02FFBC  2442FFFF   ADDIU V0, V0, -1
159:                 
160:                          if (irq.counter < 0)
9D02FFC0  04410009   BGEZ V0, .LVL44
9D02FFC4  AC62B884   SW V0, -18300(V1)
161:                          {
162:                             if (irq.enabled)
9D02FFC8  3C02A001   LUI V0, -24575
9D02FFCC  8C42B88C   LW V0, -18292(V0)
9D02FFD0  10400006   BEQ V0, ZERO, 0x9D02FFEC
9D02FFD4  8FBF0014   LW RA, 20(SP)
163:                             {
164:                                irq.reset = true;
9D02FFD8  24030001   ADDIU V1, ZERO, 1
9D02FFDC  3C02A001   LUI V0, -24575
165:                                nes_irq();
9D02FFE0  0F408A46   JAL nes_irq
9D02FFE4  AC43B890   SW V1, -18288(V0)
166:                             }
167:                          }
168:                       }
169:                    }
170:                 }
9D02FFE8  8FBF0014   LW RA, 20(SP)
9D02FFEC  27BD0018   ADDIU SP, SP, 24
9D02FFF0  03E00008   JR RA
9D02FFF4  00000000   NOP
171:                 
172:                 static void map4_getstate(SnssMapperBlock *state)
173:                 {
174:                    state->extraData.mapper4.irqCounter = irq.counter;
9D02FBF8  3C02A001   LUI V0, -24575
9D02FBFC  8C43B884   LW V1, -18300(V0)
9D02FC00  A0830018   SB V1, 24(A0)
175:                    state->extraData.mapper4.irqLatchCounter = irq.latch;
9D02FC04  2442B884   ADDIU V0, V0, -18300
9D02FC08  8C430004   LW V1, 4(V0)
9D02FC0C  A0830019   SB V1, 25(A0)
176:                    state->extraData.mapper4.irqCounterEnabled = irq.enabled;
9D02FC10  8C420008   LW V0, 8(V0)
9D02FC14  A082001A   SB V0, 26(A0)
177:                    state->extraData.mapper4.last8000Write = command;
9D02FC18  9382806E   LBU V0, -32658(GP)
9D02FC1C  03E00008   JR RA
9D02FC20  A082001B   SB V0, 27(A0)
178:                 }
179:                 
180:                 static void map4_setstate(SnssMapperBlock *state)
181:                 {
182:                    irq.counter = state->extraData.mapper4.irqCounter;
9D02FC24  3C02A001   LUI V0, -24575
9D02FC28  90830018   LBU V1, 24(A0)
9D02FC2C  AC43B884   SW V1, -18300(V0)
183:                    irq.latch = state->extraData.mapper4.irqLatchCounter;
9D02FC30  2442B884   ADDIU V0, V0, -18300
9D02FC34  90830019   LBU V1, 25(A0)
9D02FC38  AC430004   SW V1, 4(V0)
184:                    irq.enabled = state->extraData.mapper4.irqCounterEnabled;
9D02FC3C  9083001A   LBU V1, 26(A0)
9D02FC40  AC430008   SW V1, 8(V0)
185:                    command = state->extraData.mapper4.last8000Write;
9D02FC44  9082001B   LBU V0, 27(A0)
9D02FC48  03E00008   JR RA
9D02FC4C  A382806E   SB V0, -32658(GP)
186:                 }
187:                 
188:                 static void map4_init(void)
189:                 {
190:                    irq.counter = irq.latch = 0;
9D02FC50  3C03A001   LUI V1, -24575
9D02FC54  2462B884   ADDIU V0, V1, -18300
9D02FC58  AC400004   SW ZERO, 4(V0)
9D02FC5C  AC60B884   SW ZERO, -18300(V1)
191:                    irq.enabled = irq.reset = false;
9D02FC60  AC40000C   SW ZERO, 12(V0)
9D02FC64  AC400008   SW ZERO, 8(V0)
192:                    reg = command = 0;
9D02FC68  A380806E   SB ZERO, -32658(GP)
9D02FC6C  A380806F   SB ZERO, -32657(GP)
193:                    vrombase = 0x0000;
9D02FC70  03E00008   JR RA
9D02FC74  A780806C   SH ZERO, -32660(GP)
194:                 }
195:                 
196:                 static map_memwrite map4_memwrite[] =
197:                 {
198:                    { 0x8000, 0xFFFF, map4_write },
199:                    {     -1,     -1, NULL }
200:                 };
201:                 
202:                 mapintf_t map4_intf =
203:                 {
204:                    4, /* mapper number */
205:                    "MMC3", /* mapper name */
206:                    map4_init, /* init routine */
207:                    NULL, /* vblank callback */
208:                    map4_hblank, /* hblank callback */
209:                    map4_getstate, /* get state (snss) */
210:                    map4_setstate, /* set state (snss) */
211:                    NULL, /* memory read structure */
212:                    map4_memwrite, /* memory write structure */
213:                    NULL /* external sound device */
214:                 };
215:                 
216:                 /*
217:                 ** $Log: map004.c,v $
218:                 ** Revision 1.2  2001/04/27 14:37:11  neil
219:                 ** wheeee
220:                 **
221:                 ** Revision 1.1  2001/04/27 12:54:40  neil
222:                 ** blah
223:                 **
224:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
225:                 ** initial
226:                 **
227:                 ** Revision 1.2  2000/11/26 15:40:49  matt
228:                 ** hey, it actually works now
229:                 **
230:                 ** Revision 1.1  2000/10/24 12:19:32  matt
231:                 ** changed directory structure
232:                 **
233:                 ** Revision 1.12  2000/10/23 15:53:27  matt
234:                 ** suppressed warnings
235:                 **
236:                 ** Revision 1.11  2000/10/22 19:17:46  matt
237:                 ** mapper cleanups galore
238:                 **
239:                 ** Revision 1.10  2000/10/22 15:03:13  matt
240:                 ** simplified mirroring
241:                 **
242:                 ** Revision 1.9  2000/10/21 19:33:38  matt
243:                 ** many more cleanups
244:                 **
245:                 ** Revision 1.8  2000/10/10 13:58:17  matt
246:                 ** stroustrup squeezing his way in the door
247:                 **
248:                 ** Revision 1.7  2000/10/08 18:05:44  matt
249:                 ** kept old version around, just in case....
250:                 **
251:                 ** Revision 1.6  2000/07/15 23:52:19  matt
252:                 ** rounded out a bunch more mapper interfaces
253:                 **
254:                 ** Revision 1.5  2000/07/10 13:51:25  matt
255:                 ** using generic nes_irq() routine now
256:                 **
257:                 ** Revision 1.4  2000/07/10 05:29:03  matt
258:                 ** cleaned up some mirroring issues
259:                 **
260:                 ** Revision 1.3  2000/07/06 02:48:43  matt
261:                 ** clearly labelled structure members
262:                 **
263:                 ** Revision 1.2  2000/07/05 05:04:39  matt
264:                 ** minor modifications
265:                 **
266:                 ** Revision 1.1  2000/07/04 23:11:45  matt
267:                 ** initial revision
268:                 **
269:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map003.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map3.c
21:                  **
22:                  ** mapper 3 interface
23:                  ** $Id: map003.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  
29:                  /* mapper 3: CNROM */
30:                  static void map3_write(uint32 address, uint8 value)
31:                  {
9D03BE6C  27BDFFE8   ADDIU SP, SP, -24
9D03BE70  AFBF0014   SW RA, 20(SP)
9D03BE74  00A03021   ADDU A2, A1, ZERO
32:                     UNUSED(address);
33:                  
34:                     mmc_bankvrom(8, 0x0000, value);
9D03BE78  24040008   ADDIU A0, ZERO, 8
9D03BE7C  0F40B1E8   JAL mmc_bankvrom
9D03BE80  00002821   ADDU A1, ZERO, ZERO
35:                  }
9D03BE84  8FBF0014   LW RA, 20(SP)
9D03BE88  03E00008   JR RA
9D03BE8C  27BD0018   ADDIU SP, SP, 24
36:                  
37:                  static map_memwrite map3_memwrite[] =
38:                  {
39:                     { 0x8000, 0xFFFF, map3_write },
40:                     {     -1,     -1, NULL }
41:                  };
42:                  
43:                  mapintf_t map3_intf =
44:                  {
45:                     3, /* mapper number */
46:                     "CNROM", /* mapper name */
47:                     NULL, /* init routine */
48:                     NULL, /* vblank callback */
49:                     NULL, /* hblank callback */
50:                     NULL, /* get state (snss) */
51:                     NULL, /* set state (snss) */
52:                     NULL, /* memory read structure */
53:                     map3_memwrite, /* memory write structure */
54:                     NULL /* external sound device */
55:                  };
56:                  
57:                  /*
58:                  ** $Log: map003.c,v $
59:                  ** Revision 1.2  2001/04/27 14:37:11  neil
60:                  ** wheeee
61:                  **
62:                  ** Revision 1.1  2001/04/27 12:54:40  neil
63:                  ** blah
64:                  **
65:                  ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
66:                  ** initial
67:                  **
68:                  ** Revision 1.1  2000/10/24 12:19:32  matt
69:                  ** changed directory structure
70:                  **
71:                  ** Revision 1.5  2000/10/22 19:17:46  matt
72:                  ** mapper cleanups galore
73:                  **
74:                  ** Revision 1.4  2000/10/21 19:33:38  matt
75:                  ** many more cleanups
76:                  **
77:                  ** Revision 1.3  2000/08/16 02:50:11  matt
78:                  ** random mapper cleanups
79:                  **
80:                  ** Revision 1.2  2000/07/06 02:48:43  matt
81:                  ** clearly labelled structure members
82:                  **
83:                  ** Revision 1.1  2000/07/04 23:11:45  matt
84:                  ** initial revision
85:                  **
86:                  */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map002.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map2.c
21:                  **
22:                  ** mapper 2 interface
23:                  ** $Id: map002.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <noftypes.h>
27:                  #include <nes_mmc.h>
28:                  
29:                  /* mapper 2: UNROM */
30:                  static void map2_write(uint32 address, uint8 value)
31:                  {
9D03BEB4  27BDFFE8   ADDIU SP, SP, -24
9D03BEB8  AFBF0014   SW RA, 20(SP)
9D03BEBC  00A03021   ADDU A2, A1, ZERO
32:                     UNUSED(address);
33:                  
34:                     mmc_bankrom(16, 0x8000, value);
9D03BEC0  24040010   ADDIU A0, ZERO, 16
9D03BEC4  0F40B246   JAL mmc_bankrom
9D03BEC8  34058000   ORI A1, ZERO, -32768
35:                  }
9D03BECC  8FBF0014   LW RA, 20(SP)
9D03BED0  03E00008   JR RA
9D03BED4  27BD0018   ADDIU SP, SP, 24
36:                  
37:                  static map_memwrite map2_memwrite[] =
38:                  {
39:                     { 0x8000, 0xFFFF, map2_write },
40:                     {     -1,     -1, NULL }
41:                  };
42:                  
43:                  mapintf_t map2_intf =
44:                  {
45:                     2, /* mapper number */
46:                     "UNROM", /* mapper name */
47:                     NULL, /* init routine */
48:                     NULL, /* vblank callback */
49:                     NULL, /* hblank callback */
50:                     NULL, /* get state (snss) */
51:                     NULL, /* set state (snss) */
52:                     NULL, /* memory read structure */
53:                     map2_memwrite, /* memory write structure */
54:                     NULL /* external sound device */
55:                  };
56:                  
57:                  /*
58:                  ** $Log: map002.c,v $
59:                  ** Revision 1.2  2001/04/27 14:37:11  neil
60:                  ** wheeee
61:                  **
62:                  ** Revision 1.1  2001/04/27 12:54:40  neil
63:                  ** blah
64:                  **
65:                  ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
66:                  ** initial
67:                  **
68:                  ** Revision 1.1  2000/10/24 12:19:32  matt
69:                  ** changed directory structure
70:                  **
71:                  ** Revision 1.5  2000/10/22 19:17:46  matt
72:                  ** mapper cleanups galore
73:                  **
74:                  ** Revision 1.4  2000/10/21 19:33:38  matt
75:                  ** many more cleanups
76:                  **
77:                  ** Revision 1.3  2000/08/16 02:50:11  matt
78:                  ** random mapper cleanups
79:                  **
80:                  ** Revision 1.2  2000/07/06 02:48:43  matt
81:                  ** clearly labelled structure members
82:                  **
83:                  ** Revision 1.1  2000/07/04 23:11:45  matt
84:                  ** initial revision
85:                  **
86:                  */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/mappers/map001.c  --------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** map1.c
21:                  **
22:                  ** mapper 1 interface
23:                  ** $Id: map001.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <string.h>
27:                  #include <noftypes.h>
28:                  #include <nes_mmc.h>
29:                  #include <nes_ppu.h>
30:                  
31:                  /* TODO: WRAM enable ala Mark Knibbs:
32:                     ==================================
33:                  The SNROM board uses 8K CHR-RAM. The CHR-RAM is paged (i.e. it can be split
34:                  into two 4Kbyte pages).
35:                  
36:                  The CRA16 line of the MMC1 is connected to the /CS1 pin of the WRAM. THIS MEANS
37:                  THAT THE WRAM CAN BE ENABLED OR DISABLED ACCORDING TO THE STATE OF THE CRA16
38:                  LINE. The CRA16 line corresponds to bit 4 of MMC1 registers 1 & 2.
39:                  
40:                  The WRAM is enabled when the CRA16 line is low, and disabled when CRA16 is
41:                  high. This has implications when CHR page size is 4K, if the two page numbers
42:                  set have different CRA16 states (e.g. reg 1 bit 4 = 0, reg 2 bit 4 = 1). Then
43:                  the WRAM will be enabled and disabled depending on what CHR address is being
44:                  accessed.
45:                  
46:                  When CHR page size is 8K, bit 4 of MMC1 register 1 (and not register 2, because
47:                  page size is 8K) controls whether the WRAM is enabled or not. It must be low
48:                  to be enabled. When the WRAM is disabled, reading from and writing to it will
49:                  not be possible.
50:                  */
51:                  
52:                  /* TODO: roll this into something... */
53:                  static int bitcount = 0;
54:                  static uint8 latch = 0;
55:                  static uint8 regs[4];
56:                  static int bank_select;
57:                  static uint8 lastreg;
58:                  
59:                  static void map1_write(uint32 address, uint8 value)
60:                  {
9D0312E4  27BDFFE8   ADDIU SP, SP, -24
9D0312E8  AFBF0014   SW RA, 20(SP)
61:                     int regnum = (address >> 13) - 4;
9D0312EC  00042342   SRL A0, A0, 13
62:                  
63:                     if (value & 0x80)
9D0312F0  7C051C20   SEB V1, A1
9D0312F4  04610008   BGEZ V1, 0x9D031318
9D0312F8  2484FFFC   ADDIU A0, A0, -4
64:                     {
65:                        regs[0] |= 0x0C;
9D0312FC  278280E4   ADDIU V0, GP, -32540
9D031300  90430000   LBU V1, 0(V0)
9D031304  3463000C   ORI V1, V1, 12
9D031308  A0430000   SB V1, 0(V0)
66:                        bitcount = 0;
9D03130C  AF8080EC   SW ZERO, -32532(GP)
67:                        latch = 0;
68:                        return;
9D031310  0B40C560   J .LVL29
9D031314  A38080E8   SB ZERO, -32536(GP)
69:                     }
70:                  
71:                     if (lastreg != regnum)
9D031318  938380DC   LBU V1, -32548(GP)
9D03131C  10640004   BEQ V1, A0, 0x9D031330
9D031320  00801021   ADDU V0, A0, ZERO
72:                     {
73:                        bitcount = 0;
9D031324  AF8080EC   SW ZERO, -32532(GP)
74:                        latch = 0;
9D031328  A38080E8   SB ZERO, -32536(GP)
75:                        lastreg = regnum;
9D03132C  A38480DC   SB A0, -32548(GP)
76:                     }
77:                     //lastreg = regnum;
78:                  
79:                     latch |= ((value & 1) << bitcount++);
9D031330  8F8680EC   LW A2, -32532(GP)
9D031334  24C30001   ADDIU V1, A2, 1
9D031338  AF8380EC   SW V1, -32532(GP)
9D03133C  30A50001   ANDI A1, A1, 1
9D031340  00C53004   SLLV A2, A1, A2
9D031344  938780E8   LBU A3, -32536(GP)
9D031348  00C73025   OR A2, A2, A3
9D03134C  30C600FF   ANDI A2, A2, 255
80:                  
81:                     /* 5 bit registers */
82:                     if (5 != bitcount)
9D031350  24050005   ADDIU A1, ZERO, 5
9D031354  1465008A   BNE V1, A1, .LVL29
9D031358  A38680E8   SB A2, -32536(GP)
83:                        return;
84:                  
85:                     regs[regnum] = latch;
9D03135C  278380E4   ADDIU V1, GP, -32540
9D031360  00641821   ADDU V1, V1, A0
9D031364  A0660000   SB A2, 0(V1)
86:                     value = latch;
87:                     bitcount = 0;
9D031368  AF8080EC   SW ZERO, -32532(GP)
88:                     latch = 0;
89:                  
90:                     switch (regnum)
9D03136C  24030001   ADDIU V1, ZERO, 1
9D031370  10430026   BEQ V0, V1, 0x9D03140C
9D031374  A38080E8   SB ZERO, -32536(GP)
9D031378  28840002   SLTI A0, A0, 2
9D03137C  50800005   BEQL A0, ZERO, 0x9D031394
9D031380  24030002   ADDIU V1, ZERO, 2
9D031384  10400009   BEQ V0, ZERO, 0x9D0313AC
9D031388  30C20002   ANDI V0, A2, 2
9D031394  1043002C   BEQ V0, V1, 0x9D031448
9D031398  24030003   ADDIU V1, ZERO, 3
9D03139C  10430034   BEQ V0, V1, 0x9D031470
9D0313A0  8FBF0014   LW RA, 20(SP)
9D0313A4  0B40C561   J 0x9D031584
9D0313A8  00000000   NOP
91:                     {
92:                     case 0:
93:                        {
94:                           if (0 == (value & 2))
9D0313AC  304200FF   ANDI V0, V0, 255
9D0313B0  54400008   BNEL V0, ZERO, 0x9D0313D4
9D0313B4  30C60001   ANDI A2, A2, 1
95:                           {
96:                              int mirror = value & 1;
9D0313B8  30C70001   ANDI A3, A2, 1
97:                              ppu_mirror(mirror, mirror, mirror, mirror);
9D0313BC  00E02021   ADDU A0, A3, ZERO
9D0313C0  00E02821   ADDU A1, A3, ZERO
9D0313C4  0F406128   JAL ppu_mirror
9D0313C8  00E03021   ADDU A2, A3, ZERO
9D0313CC  0B40C561   J 0x9D031584
9D0313D0  8FBF0014   LW RA, 20(SP)
98:                           }
99:                           else
100:                          {
101:                             if (value & 1)
9D0313D4  10C00007   BEQ A2, ZERO, 0x9D0313F4
9D0313D8  00002021   ADDU A0, ZERO, ZERO
102:                                ppu_mirror(0, 0, 1, 1);
9D0313DC  00002821   ADDU A1, ZERO, ZERO
9D0313E0  24060001   ADDIU A2, ZERO, 1
9D0313E4  0F406128   JAL ppu_mirror
9D0313E8  24070001   ADDIU A3, ZERO, 1
9D0313EC  0B40C561   J 0x9D031584
9D0313F0  8FBF0014   LW RA, 20(SP)
103:                             else
104:                                ppu_mirror(0, 1, 0, 1);
9D0313F4  24050001   ADDIU A1, ZERO, 1
9D0313F8  00003021   ADDU A2, ZERO, ZERO
9D0313FC  0F406128   JAL ppu_mirror
9D031400  24070001   ADDIU A3, ZERO, 1
105:                          }
106:                       }
107:                       break;
108:                 
109:                    case 1:
110:                       if (regs[0] & 0x10)
9D03140C  938280E4   LBU V0, -32540(GP)
9D031410  30420010   ANDI V0, V0, 16
9D031414  304200FF   ANDI V0, V0, 255
9D031418  10400006   BEQ V0, ZERO, 0x9D031434
9D03141C  24040008   ADDIU A0, ZERO, 8
111:                          mmc_bankvrom(4, 0x0000, value);
9D031420  24040004   ADDIU A0, ZERO, 4
9D031424  0F40B1E8   JAL mmc_bankvrom
9D031428  00002821   ADDU A1, ZERO, ZERO
9D03142C  0B40C561   J 0x9D031584
9D031430  8FBF0014   LW RA, 20(SP)
112:                       else
113:                          mmc_bankvrom(8, 0x0000, value >> 1);
9D031434  00002821   ADDU A1, ZERO, ZERO
9D031438  0F40B1E8   JAL mmc_bankvrom
9D03143C  00063042   SRL A2, A2, 1
114:                       break;
115:                 
116:                    case 2:
117:                       if (regs[0] & 0x10)
9D031448  938280E4   LBU V0, -32540(GP)
9D03144C  30420010   ANDI V0, V0, 16
9D031450  304200FF   ANDI V0, V0, 255
9D031454  5040004B   BEQL V0, ZERO, 0x9D031584
9D031458  8FBF0014   LW RA, 20(SP)
118:                          mmc_bankvrom(4, 0x1000, value);
9D03145C  24040004   ADDIU A0, ZERO, 4
9D031460  0F40B1E8   JAL mmc_bankvrom
9D031464  24051000   ADDIU A1, ZERO, 4096
119:                       break;
120:                 
121:                    case 3:
122:                       if (mmc_getinfo()->rom_banks == 0x20)
9D031470  0F40B1DC   JAL mmc_getinfo
9D031474  00000000   NOP
9D031478  8C430010   LW V1, 16(V0)
9D03147C  24020020   ADDIU V0, ZERO, 32
9D031480  14620007   BNE V1, V0, 0x9D0314A0
9D031484  938380E5   LBU V1, -32539(GP)
123:                       {
124:                          bank_select = (regs[1] & 0x10) ? 0 : 0x10;
9D031488  30630010   ANDI V1, V1, 16
9D03148C  306300FF   ANDI V1, V1, 255
9D031490  24020010   ADDIU V0, ZERO, 16
9D031494  0003100B   MOVN V0, ZERO, V1
9D031498  0B40C540   J 0x9D031500
9D03149C  AF8280E0   SW V0, -32544(GP)
125:                       }
126:                       else if (mmc_getinfo()->rom_banks == 0x40)
9D0314A0  0F40B1DC   JAL mmc_getinfo
9D0314A4  00000000   NOP
9D0314A8  8C430010   LW V1, 16(V0)
9D0314AC  24020040   ADDIU V0, ZERO, 64
9D0314B0  54620013   BNEL V1, V0, 0x9D031500
9D0314B4  AF8080E0   SW ZERO, -32544(GP)
127:                       {
128:                          if (regs[0] & 0x10)
9D0314B8  938280E4   LBU V0, -32540(GP)
9D0314BC  30420010   ANDI V0, V0, 16
9D0314C0  304200FF   ANDI V0, V0, 255
9D0314C4  1040000A   BEQ V0, ZERO, 0x9D0314F0
9D0314C8  938280E5   LBU V0, -32539(GP)
129:                             bank_select = (regs[1] & 0x10) | ((regs[2] & 0x10) << 1);
9D0314CC  938280E6   LBU V0, -32538(GP)
9D0314D0  30420010   ANDI V0, V0, 16
9D0314D4  304200FF   ANDI V0, V0, 255
9D0314D8  00021040   SLL V0, V0, 1
9D0314DC  938380E5   LBU V1, -32539(GP)
9D0314E0  30630010   ANDI V1, V1, 16
9D0314E4  00621025   OR V0, V1, V0
9D0314E8  0B40C540   J 0x9D031500
9D0314EC  AF8280E0   SW V0, -32544(GP)
130:                          else
131:                             bank_select = (regs[1] & 0x10) << 1;
9D0314F0  30420010   ANDI V0, V0, 16
9D0314F4  304200FF   ANDI V0, V0, 255
9D0314F8  00021040   SLL V0, V0, 1
9D0314FC  AF8280E0   SW V0, -32544(GP)
132:                       }
133:                       else
134:                       {
135:                          bank_select = 0;
136:                       }
137:                    
138:                       if (0 == (regs[0] & 0x08))
9D031500  938280E4   LBU V0, -32540(GP)
9D031504  30430008   ANDI V1, V0, 8
9D031508  306300FF   ANDI V1, V1, 255
9D03150C  1460000B   BNE V1, ZERO, 0x9D03153C
9D031510  30420004   ANDI V0, V0, 4
139:                          mmc_bankrom(32, 0x8000, ((regs[3] >> 1) + (bank_select >> 1)));
9D031514  938680E7   LBU A2, -32537(GP)
9D031518  00063042   SRL A2, A2, 1
9D03151C  8F8280E0   LW V0, -32544(GP)
9D031520  00021043   SRA V0, V0, 1
9D031524  24040020   ADDIU A0, ZERO, 32
9D031528  34058000   ORI A1, ZERO, -32768
9D03152C  0F40B246   JAL mmc_bankrom
9D031530  00C23021   ADDU A2, A2, V0
9D031534  0B40C561   J 0x9D031584
9D031538  8FBF0014   LW RA, 20(SP)
140:                       else if (regs[0] & 0x04)
9D03153C  304200FF   ANDI V0, V0, 255
9D031540  10400009   BEQ V0, ZERO, 0x9D031568
9D031544  938680E7   LBU A2, -32537(GP)
141:                          mmc_bankrom(16, 0x8000, ((regs[3] & 0xF) + bank_select));
9D031548  30C6000F   ANDI A2, A2, 15
9D03154C  24040010   ADDIU A0, ZERO, 16
9D031550  34058000   ORI A1, ZERO, -32768
9D031554  8F8280E0   LW V0, -32544(GP)
9D031558  0F40B246   JAL mmc_bankrom
9D03155C  00C23021   ADDU A2, A2, V0
9D031560  0B40C561   J 0x9D031584
9D031564  8FBF0014   LW RA, 20(SP)
142:                       else
143:                          mmc_bankrom(16, 0xC000, ((regs[3] & 0xF) + bank_select));
9D031568  30C6000F   ANDI A2, A2, 15
9D03156C  24040010   ADDIU A0, ZERO, 16
9D031570  3405C000   ORI A1, ZERO, -16384
9D031574  8F8280E0   LW V0, -32544(GP)
9D031578  0F40B246   JAL mmc_bankrom
9D03157C  00C23021   ADDU A2, A2, V0
144:                 
145:                    default:
146:                       break;
147:                    }
148:                 }
9D03138C  0B40C561   J 0x9D031584
9D031390  8FBF0014   LW RA, 20(SP)
9D031404  0B40C561   J 0x9D031584
9D031408  8FBF0014   LW RA, 20(SP)
9D031440  0B40C561   J 0x9D031584
9D031444  8FBF0014   LW RA, 20(SP)
9D031468  0B40C561   J 0x9D031584
9D03146C  8FBF0014   LW RA, 20(SP)
9D031580  8FBF0014   LW RA, 20(SP)
9D031584  03E00008   JR RA
9D031588  27BD0018   ADDIU SP, SP, 24
149:                 
150:                 static void map1_init(void)
151:                 {
9D03158C  27BDFFE8   ADDIU SP, SP, -24
9D031590  AFBF0014   SW RA, 20(SP)
152:                    bitcount = 0;
9D031594  AF8080EC   SW ZERO, -32532(GP)
153:                    latch = 0;
9D031598  A38080E8   SB ZERO, -32536(GP)
154:                 
155:                    memset(regs, 0, sizeof(regs));
156:                 
157:                    if (mmc_getinfo()->rom_banks == 0x20)
9D03159C  0F40B1DC   JAL mmc_getinfo
9D0315A0  AF8080E4   SW ZERO, -32540(GP)
9D0315A4  8C430010   LW V1, 16(V0)
9D0315A8  24020020   ADDIU V0, ZERO, 32
9D0315AC  14620006   BNE V1, V0, 0x9D0315C8
9D0315B0  34048000   ORI A0, ZERO, -32768
158:                       mmc_bankrom(16, 0xC000, 0x0F);
9D0315B4  24040010   ADDIU A0, ZERO, 16
9D0315B8  3405C000   ORI A1, ZERO, -16384
9D0315BC  0F40B246   JAL mmc_bankrom
9D0315C0  2406000F   ADDIU A2, ZERO, 15
159:                 
160:                    map1_write(0x8000, 0x80);
9D0315C4  34048000   ORI A0, ZERO, -32768
9D0315C8  0F40C4B9   JAL .LFB5, map1_write, .LFE8
9D0315CC  24050080   ADDIU A1, ZERO, 128
161:                 }
9D0315D0  8FBF0014   LW RA, 20(SP)
9D0315D4  03E00008   JR RA
9D0315D8  27BD0018   ADDIU SP, SP, 24
162:                 
163:                 static void map1_getstate(SnssMapperBlock *state)
164:                 {
165:                    state->extraData.mapper1.registers[0] = regs[0];
9D031284  938280E4   LBU V0, -32540(GP)
9D031288  A0820018   SB V0, 24(A0)
166:                    state->extraData.mapper1.registers[1] = regs[1];
9D03128C  938280E5   LBU V0, -32539(GP)
9D031290  A0820019   SB V0, 25(A0)
167:                    state->extraData.mapper1.registers[2] = regs[2];
9D031294  938280E6   LBU V0, -32538(GP)
9D031298  A082001A   SB V0, 26(A0)
168:                    state->extraData.mapper1.registers[3] = regs[3];
9D03129C  938280E7   LBU V0, -32537(GP)
9D0312A0  A082001B   SB V0, 27(A0)
169:                    state->extraData.mapper1.latch = latch;
9D0312A4  938280E8   LBU V0, -32536(GP)
9D0312A8  A082001C   SB V0, 28(A0)
170:                    state->extraData.mapper1.numberOfBits = bitcount;
9D0312AC  8F8280EC   LW V0, -32532(GP)
9D0312B0  03E00008   JR RA
9D0312B4  A082001D   SB V0, 29(A0)
171:                 }
172:                 
173:                 
174:                 static void map1_setstate(SnssMapperBlock *state)
175:                 {
176:                    regs[1] = state->extraData.mapper1.registers[0];
177:                    regs[1] = state->extraData.mapper1.registers[1];
9D0312B8  90820019   LBU V0, 25(A0)
9D0312BC  A38280E5   SB V0, -32539(GP)
178:                    regs[2] = state->extraData.mapper1.registers[2];
9D0312C0  9082001A   LBU V0, 26(A0)
9D0312C4  A38280E6   SB V0, -32538(GP)
179:                    regs[3] = state->extraData.mapper1.registers[3];
9D0312C8  9082001B   LBU V0, 27(A0)
9D0312CC  A38280E7   SB V0, -32537(GP)
180:                    latch = state->extraData.mapper1.latch;
9D0312D0  9082001C   LBU V0, 28(A0)
9D0312D4  A38280E8   SB V0, -32536(GP)
181:                    bitcount = state->extraData.mapper1.numberOfBits;
9D0312D8  9082001D   LBU V0, 29(A0)
9D0312DC  03E00008   JR RA
9D0312E0  AF8280EC   SW V0, -32532(GP)
182:                 }
183:                 
184:                 static map_memwrite map1_memwrite[] =
185:                 {
186:                    { 0x8000, 0xFFFF, map1_write },
187:                    {     -1,     -1, NULL }
188:                 };
189:                 
190:                 mapintf_t map1_intf =
191:                 {
192:                    1, /* mapper number */
193:                    "MMC1", /* mapper name */
194:                    map1_init, /* init routine */
195:                    NULL, /* vblank callback */
196:                    NULL, /* hblank callback */
197:                    map1_getstate, /* get state (snss) */
198:                    map1_setstate, /* set state (snss) */
199:                    NULL, /* memory read structure */
200:                    map1_memwrite, /* memory write structure */
201:                    NULL /* external sound device */
202:                 };
203:                 
204:                 /*
205:                 ** $Log: map001.c,v $
206:                 ** Revision 1.2  2001/04/27 14:37:11  neil
207:                 ** wheeee
208:                 **
209:                 ** Revision 1.1  2001/04/27 12:54:40  neil
210:                 ** blah
211:                 **
212:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
213:                 ** initial
214:                 **
215:                 ** Revision 1.1  2000/10/24 12:19:32  matt
216:                 ** changed directory structure
217:                 **
218:                 ** Revision 1.8  2000/10/22 19:46:50  matt
219:                 ** mirroring bugfix
220:                 **
221:                 ** Revision 1.7  2000/10/22 19:17:46  matt
222:                 ** mapper cleanups galore
223:                 **
224:                 ** Revision 1.6  2000/10/22 15:03:13  matt
225:                 ** simplified mirroring
226:                 **
227:                 ** Revision 1.5  2000/10/21 19:33:38  matt
228:                 ** many more cleanups
229:                 **
230:                 ** Revision 1.4  2000/07/15 23:52:19  matt
231:                 ** rounded out a bunch more mapper interfaces
232:                 **
233:                 ** Revision 1.3  2000/07/10 05:29:03  matt
234:                 ** cleaned up some mirroring issues
235:                 **
236:                 ** Revision 1.2  2000/07/06 02:48:43  matt
237:                 ** clearly labelled structure members
238:                 **
239:                 ** Revision 1.1  2000/07/04 23:11:45  matt
240:                 ** initial revision
241:                 **
242:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/log.c  -------------------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** log.c
21:                  **
22:                  ** Error logging functions
23:                  ** $Id: log.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <stdlib.h>
27:                  #include <stdio.h>
28:                  #include <stdarg.h>
29:                  #include <noftypes.h>
30:                  #include <log.h>
31:                  
32:                  
33:                  //static FILE *errorlog = NULL;
34:                  static int (*log_func)(const char *string) = NULL;
35:                  
36:                  /* first up: debug versions of calls */
37:                  #ifdef NOFRENDO_DEBUG
38:                  int log_init(void)
39:                  {
40:                  //   errorlog = fopen("errorlog.txt", "wt");
41:                  //   if (NULL == errorlog)
42:                  //      return (-1);
43:                  
44:                     return 0;
45:                  }
46:                  
47:                  void log_shutdown(void)
48:                  {
49:                     /* Snoop around for unallocated blocks */
50:                     mem_checkblocks();
51:                     mem_checkleaks();
52:                     mem_cleanup();
53:                  
54:                  //   if (NULL != errorlog)
55:                  //      fclose(errorlog);
56:                  }
57:                  
58:                  int log_print(const char *string)
59:                  {
60:                     /* if we have a custom logging function, use that */
61:                     if (NULL != log_func)
62:                        log_func(string);
63:                     
64:                     /* Log it to disk, as well */
65:                  //   fputs(string, errorlog);
66:                  //	printf("%s\n", string);
67:                  
68:                     return 0;
69:                  }
70:                  
71:                  int log_printf(const char *format, ... )
72:                  {
73:                     /* don't allocate on stack every call */
74:                     static char buffer[1024 + 1];
75:                     va_list arg;
76:                  
77:                     va_start(arg, format);
78:                  
79:                     if (NULL != log_func)
80:                     {
81:                        vsprintf(buffer, format, arg);
82:                        log_func(buffer);
83:                     }
84:                  
85:                  //   vfprintf(errorlog, format, arg);
86:                     va_end(arg);
87:                  
88:                     return 0; /* should be number of chars written */
89:                  }
90:                  
91:                  #else /* !NOFRENDO_DEBUG */
92:                  
93:                  int log_init(void)
94:                  {
95:                     return 0;
96:                  }
9D03BB88  03E00008   JR RA
9D03BB8C  00001021   ADDU V0, ZERO, ZERO
97:                  
98:                  void log_shutdown(void)
99:                  {
9D03BB90  03E00008   JR RA
9D03BB94  00000000   NOP
100:                 }
101:                 
102:                 int log_print(const char *string)
103:                 {
104:                    UNUSED(string);
105:                 
106:                    return 0;
107:                 }
9D03BB98  03E00008   JR RA
9D03BB9C  00001021   ADDU V0, ZERO, ZERO
108:                 
109:                 int log_printf(const char *format, ... )
110:                 {
9D03BBA0  AFA50004   SW A1, 4(SP)
9D03BBA4  AFA60008   SW A2, 8(SP)
9D03BBA8  AFA7000C   SW A3, 12(SP)
111:                    UNUSED(format);
112:                 
113:                    return 0; /* should be number of chars written */
114:                 }
9D03BBAC  03E00008   JR RA
9D03BBB0  00001021   ADDU V0, ZERO, ZERO
115:                 #endif /* !NOFRENDO_DEBUG */
116:                 
117:                 void log_chain_logfunc(int (*func)(const char *string))
118:                 {
119:                    log_func = func;
9D03BBB4  03E00008   JR RA
9D03BBB8  AF848124   SW A0, -32476(GP)
120:                 }
121:                 
122:                 void log_assert(int expr, int line, const char *file, char *msg)
123:                 {
9D03BBBC  03E00008   JR RA
124:                    if (expr)
125:                       return;
126:                 
127:                    if (NULL != msg)
128:                       log_printf("ASSERT: line %d of %s, %s\n", line, file, msg);
129:                    else
130:                       log_printf("ASSERT: line %d of %s\n", line, file);
131:                 
132:                    //asm("break.n 1");
133:                 //   exit(-1);
134:                 }
135:                 
136:                 
137:                 /*
138:                 ** $Log: log.c,v $
139:                 ** Revision 1.2  2001/04/27 14:37:11  neil
140:                 ** wheeee
141:                 **
142:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
143:                 ** initial
144:                 **
145:                 ** Revision 1.14  2000/11/13 00:56:17  matt
146:                 ** doesn't look as nasty now
147:                 **
148:                 ** Revision 1.13  2000/11/06 02:15:07  matt
149:                 ** more robust logging routines
150:                 **
151:                 ** Revision 1.12  2000/10/15 13:28:12  matt
152:                 ** need stdlib.h for exit()
153:                 **
154:                 ** Revision 1.11  2000/10/10 13:13:13  matt
155:                 ** dumb bug in log_chain_logfunc
156:                 **
157:                 ** Revision 1.10  2000/10/10 13:03:54  matt
158:                 ** Mr. Clean makes a guest appearance
159:                 **
160:                 ** Revision 1.9  2000/08/28 01:47:10  matt
161:                 ** quelled fricking compiler complaints
162:                 **
163:                 ** Revision 1.8  2000/07/31 04:28:46  matt
164:                 ** one million cleanups
165:                 **
166:                 ** Revision 1.7  2000/07/17 01:52:27  matt
167:                 ** made sure last line of all source files is a newline
168:                 **
169:                 ** Revision 1.6  2000/07/06 17:20:52  matt
170:                 ** block manager space itself wasn't being freed - d'oh!
171:                 **
172:                 ** Revision 1.5  2000/06/26 04:55:33  matt
173:                 ** minor change
174:                 **
175:                 ** Revision 1.4  2000/06/09 15:12:25  matt
176:                 ** initial revision
177:                 **
178:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/libsnss/libsnss.c  -------------------------
1:                   /**************************************************************************/
2:                   /*
3:                         libsnss.c
4:                   
5:                         (C) 2000 The SNSS Group
6:                         See README.TXT file for license and terms of use.
7:                   
8:                         $Id: libsnss.c,v 1.2 2001/04/27 14:37:11 neil Exp $
9:                   */
10:                  /**************************************************************************/
11:                  
12:                  #include <stdio.h>
13:                  #include <stdlib.h>
14:                  #include <string.h>
15:                  #include <libsnss.h>
16:                  
17:                  /**************************************************************************/
18:                  /* This section deals with endian-specific code. */
19:                  /**************************************************************************/
20:                  
21:                  static unsigned int
22:                  swaap32 (unsigned int source)
23:                  {
24:                  #ifdef USE_LITTLE_ENDIAN
25:                     char buffer[4];
26:                     
27:                     buffer[0] = ((char *) &source)[3];
28:                     buffer[1] = ((char *) &source)[2];
29:                     buffer[2] = ((char *) &source)[1];
30:                     buffer[3] = ((char *) &source)[0];
31:                  
32:                     return *((unsigned int *) buffer);
33:                  #else /* !USE_LITTLE_ENDIAN */
34:                     return source;
35:                  #endif /* !USE_LITTLE_ENDIAN */
36:                  }
37:                  
38:                  static unsigned short
39:                  swaap16 (unsigned short source)
40:                  {
41:                  #ifdef USE_LITTLE_ENDIAN
42:                     char buffer[2];
43:                     
44:                     buffer[0] = ((char *) &source)[1];
45:                     buffer[1] = ((char *) &source)[0];
46:                  
47:                     return *((unsigned short *) buffer);
48:                  #else /* !USE_LITTLE_ENDIAN */
49:                     return source;
50:                  #endif /* !USE_LITTLE_ENDIAN */
51:                  }
52:                  
53:                  /**************************************************************************/
54:                  /* support functions */
55:                  /**************************************************************************/
56:                  
57:                  #define MIN(a,b) (((a) < (b)) ? (a) : (b))
58:                  
59:                  /**************************************************************************/
60:                  
61:                  static SNSS_RETURN_CODE
62:                  SNSS_ReadBlockHeader (SnssBlockHeader *header, SNSS_FILE *snssFile)
63:                  {
9D02094C  27BDFFD8   ADDIU SP, SP, -40
9D020950  AFBF0024   SW RA, 36(SP)
9D020954  AFB00020   SW S0, 32(SP)
9D020958  00808021   ADDU S0, A0, ZERO
64:                     char headerBytes[12];
65:                  
66:                     if (fread (headerBytes, 12, 1, snssFile->fp) != 1)
9D02095C  8CA70000   LW A3, 0(A1)
9D020960  27A40010   ADDIU A0, SP, 16
9D020964  2405000C   ADDIU A1, ZERO, 12
9D020968  0F40CA31   JAL .Letext0, .LFE1, fread
9D02096C  24060001   ADDIU A2, ZERO, 1
9D020970  24050001   ADDIU A1, ZERO, 1
9D020974  1445000F   BNE V0, A1, 0x9D0209B4
9D020978  24030004   ADDIU V1, ZERO, 4
67:                     {
68:                        return SNSS_READ_FAILED;
69:                     }
70:                  
71:                     strncpy (header->tag, &headerBytes[0], TAG_LENGTH);
9D02097C  02002021   ADDU A0, S0, ZERO
9D020980  27A50010   ADDIU A1, SP, 16
9D020984  0F40E164   JAL .LFE23, strncpy
9D020988  24060004   ADDIU A2, ZERO, 4
72:                     header->tag[4] = '\0';
9D02098C  A2000004   SB ZERO, 4(S0)
73:                     header->blockVersion = *((unsigned int *) &headerBytes[4]);
74:                     header->blockVersion = swap32 (header->blockVersion);
9D020990  8FA20014   LW V0, 20(SP)
9D020994  7C0210A0   WSBH V0, V0
9D020998  00221402   ROTR V0, V0, 16
9D02099C  AE020008   SW V0, 8(S0)
75:                     header->blockLength = *((unsigned int *) &headerBytes[8]);
76:                     header->blockLength = swap32 (header->blockLength);
9D0209A0  8FA20018   LW V0, 24(SP)
9D0209A4  7C0210A0   WSBH V0, V0
9D0209A8  00221402   ROTR V0, V0, 16
9D0209AC  AE02000C   SW V0, 12(S0)
77:                  
78:                     return SNSS_OK;
9D0209B0  00001821   ADDU V1, ZERO, ZERO
79:                  }
9D0209B4  00601021   ADDU V0, V1, ZERO
9D0209B8  8FBF0024   LW RA, 36(SP)
9D0209BC  8FB00020   LW S0, 32(SP)
9D0209C0  03E00008   JR RA
9D0209C4  27BD0028   ADDIU SP, SP, 40
80:                  
81:                  /**************************************************************************/
82:                  
83:                  static SNSS_RETURN_CODE
84:                  SNSS_WriteBlockHeader (SnssBlockHeader *header, SNSS_FILE *snssFile)
85:                  {
9D020C4C  27BDFFD0   ADDIU SP, SP, -48
9D020C50  AFBF002C   SW RA, 44(SP)
9D020C54  AFB10028   SW S1, 40(SP)
9D020C58  AFB00024   SW S0, 36(SP)
9D020C5C  00808021   ADDU S0, A0, ZERO
9D020C60  00A08821   ADDU S1, A1, ZERO
86:                     char headerBytes[12];
87:                     unsigned int tempInt;
88:                  
89:                     strncpy (&headerBytes[0], header->tag, TAG_LENGTH);
9D020C64  27A40010   ADDIU A0, SP, 16
9D020C68  02002821   ADDU A1, S0, ZERO
9D020C6C  0F40E164   JAL .LFE23, strncpy
9D020C70  24060004   ADDIU A2, ZERO, 4
90:                  
91:                     tempInt = swap32 (header->blockVersion);
9D020C74  8E020008   LW V0, 8(S0)
9D020C78  7C0210A0   WSBH V0, V0
9D020C7C  00221402   ROTR V0, V0, 16
92:                     headerBytes[4] = ((char *) &tempInt)[0];
9D020C80  A3A20014   SB V0, 20(SP)
93:                     headerBytes[5] = ((char *) &tempInt)[1];
9D020C84  00021A02   SRL V1, V0, 8
9D020C88  A3A30015   SB V1, 21(SP)
94:                     headerBytes[6] = ((char *) &tempInt)[2];
9D020C8C  00021C02   SRL V1, V0, 16
9D020C90  A3A30016   SB V1, 22(SP)
95:                     headerBytes[7] = ((char *) &tempInt)[3];
9D020C94  00021602   SRL V0, V0, 24
9D020C98  A3A20017   SB V0, 23(SP)
96:                  
97:                     tempInt = swap32 (header->blockLength);
9D020C9C  8E02000C   LW V0, 12(S0)
9D020CA0  7C0210A0   WSBH V0, V0
9D020CA4  00221402   ROTR V0, V0, 16
9D020CA8  AFA2001C   SW V0, 28(SP)
98:                     headerBytes[8] = ((char *) &tempInt)[0];
9D020CAC  A3A20018   SB V0, 24(SP)
99:                     headerBytes[9] = ((char *) &tempInt)[1];
9D020CB0  00021A02   SRL V1, V0, 8
9D020CB4  A3A30019   SB V1, 25(SP)
100:                    headerBytes[10] = ((char *) &tempInt)[2];
9D020CB8  00021C02   SRL V1, V0, 16
9D020CBC  A3A3001A   SB V1, 26(SP)
101:                    headerBytes[11] = ((char *) &tempInt)[3];
9D020CC0  00021602   SRL V0, V0, 24
9D020CC4  A3A2001B   SB V0, 27(SP)
102:                 
103:                    if (fwrite (headerBytes, 12, 1, snssFile->fp) != 1)
9D020CC8  27A40010   ADDIU A0, SP, 16
9D020CCC  2405000C   ADDIU A1, ZERO, 12
9D020CD0  24060001   ADDIU A2, ZERO, 1
9D020CD4  0F40EFC8   JAL fwrite
9D020CD8  8E270000   LW A3, 0(S1)
104:                    {
105:                       return SNSS_WRITE_FAILED;
9D020CDC  38420001   XORI V0, V0, 1
106:                    }
107:                 
108:                    return SNSS_OK;
109:                 }
9D020CE0  24030005   ADDIU V1, ZERO, 5
9D020CE4  0002180A   MOVZ V1, ZERO, V0
9D020CE8  00601021   ADDU V0, V1, ZERO
9D020CEC  8FBF002C   LW RA, 44(SP)
9D020CF0  8FB10028   LW S1, 40(SP)
9D020CF4  8FB00024   LW S0, 36(SP)
9D020CF8  03E00008   JR RA
9D020CFC  27BD0030   ADDIU SP, SP, 48
110:                 
111:                 /**************************************************************************/
112:                 
113:                 const char *
114:                 SNSS_GetErrorString (SNSS_RETURN_CODE code)
115:                 {
116:                    switch (code)
9D020FA0  2C820008   SLTIU V0, A0, 8
9D020FA4  10400024   BEQ V0, ZERO, 0x9D021038
9D020FA8  00042080   SLL A0, A0, 2
9D020FAC  3C029D02   LUI V0, -25342
9D020FB0  24420FC4   ADDIU V0, V0, 4036
9D020FB4  00442021   ADDU A0, V0, A0
9D020FB8  8C820000   LW V0, 0(A0)
9D020FBC  00400008   JR V0
9D020FC0  00000000   NOP
117:                    {
118:                    case SNSS_OK:
119:                       return "no error";
9D020FE4  3C029D03   LUI V0, -25341
9D020FE8  03E00008   JR RA
9D020FEC  24427D4C   ADDIU V0, V0, 32076
120:                 
121:                    case SNSS_BAD_FILE_TAG:
122:                       return "not an SNSS file";
9D021044  3C029D03   LUI V0, -25341
123:                 
124:                    case SNSS_OPEN_FAILED:
125:                       return "could not open SNSS file";
9D020FF0  3C029D03   LUI V0, -25341
9D020FF4  03E00008   JR RA
9D020FF8  24427D6C   ADDIU V0, V0, 32108
126:                 
127:                    case SNSS_CLOSE_FAILED:
128:                       return "could not close SNSS file";
9D020FFC  3C029D03   LUI V0, -25341
9D021000  03E00008   JR RA
9D021004  24427D88   ADDIU V0, V0, 32136
129:                 
130:                    case SNSS_READ_FAILED:
131:                       return "could not read from SNSS file";
9D021008  3C029D03   LUI V0, -25341
9D02100C  03E00008   JR RA
9D021010  24427DA4   ADDIU V0, V0, 32164
132:                 
133:                    case SNSS_WRITE_FAILED:
134:                       return "could not write to SNSS file";
9D021014  3C029D03   LUI V0, -25341
9D021018  03E00008   JR RA
9D02101C  24427DC4   ADDIU V0, V0, 32196
135:                 
136:                    case SNSS_OUT_OF_MEMORY:
137:                       return "out of memory";
9D021020  3C029D03   LUI V0, -25341
9D021024  03E00008   JR RA
9D021028  24427DE4   ADDIU V0, V0, 32228
138:                 
139:                    case SNSS_UNSUPPORTED_BLOCK:
140:                       return "unsupported block type";
9D02102C  3C029D03   LUI V0, -25341
9D021030  03E00008   JR RA
9D021034  24427DF4   ADDIU V0, V0, 32244
141:                 
142:                    default:
143:                       return "unknown error";
9D021038  3C029D03   LUI V0, -25341
9D02103C  03E00008   JR RA
9D021040  24427E0C   ADDIU V0, V0, 32268
144:                    }
145:                 }
9D021048  03E00008   JR RA
9D02104C  24427D58   ADDIU V0, V0, 32088
146:                 
147:                 /**************************************************************************/
148:                 /* functions for reading and writing SNSS file headers */
149:                 /**************************************************************************/
150:                 
151:                 static SNSS_RETURN_CODE 
152:                 SNSS_ReadFileHeader (SNSS_FILE *snssFile)
153:                 {
154:                    if (fread (snssFile->headerBlock.tag, 4, 1, snssFile->fp) != 1)
9D021114  02002021   ADDU A0, S0, ZERO
155:                    {
156:                       return SNSS_READ_FAILED;
157:                    }
158:                  
159:                    if (0 != strncmp(snssFile->headerBlock.tag, "SNSS", 4))
9D021130  02002021   ADDU A0, S0, ZERO
160:                    {
161:                       return SNSS_BAD_FILE_TAG;
162:                    }
163:                    
164:                    snssFile->headerBlock.tag[4] = '\0';
9D02114C  A220000C   SB ZERO, 12(S1)
165:                 
166:                    if (fread (&snssFile->headerBlock.numberOfBlocks, sizeof (unsigned int), 1, snssFile->fp) != 1)
9D021150  26240010   ADDIU A0, S1, 16
167:                    {
168:                       return SNSS_READ_FAILED;
169:                    }
170:                 
171:                    snssFile->headerBlock.numberOfBlocks = swap32 (snssFile->headerBlock.numberOfBlocks);
9D021170  8E220010   LW V0, 16(S1)
9D021174  7C0210A0   WSBH V0, V0
9D021178  00221402   ROTR V0, V0, 16
9D02117C  AE220010   SW V0, 16(S1)
172:                 
173:                    return SNSS_OK;
9D021180  0B408465   J 0x9D021194
9D021184  00003821   ADDU A3, ZERO, ZERO
174:                 }
175:                 
176:                 /**************************************************************************/
177:                 
178:                 static SNSS_RETURN_CODE 
179:                 SNSS_WriteFileHeader (SNSS_FILE *snssFile)
180:                 {
9D0208D8  27BDFFD8   ADDIU SP, SP, -40
9D0208DC  AFBF0024   SW RA, 36(SP)
9D0208E0  00801821   ADDU V1, A0, ZERO
181:                    unsigned int tempInt;
182:                    char writeBuffer[8];
183:                 
184:                    /* always place the SNSS tag in this field */
185:                    strncpy (&writeBuffer[0], "SNSS", 4);
9D0208E4  3C025353   LUI V0, 21331
9D0208E8  24424E53   ADDIU V0, V0, 20051
9D0208EC  AFA20014   SW V0, 20(SP)
186:                    tempInt = swap32 (snssFile->headerBlock.numberOfBlocks);
9D0208F0  8C820010   LW V0, 16(A0)
9D0208F4  7C0210A0   WSBH V0, V0
9D0208F8  00221402   ROTR V0, V0, 16
9D0208FC  AFA20010   SW V0, 16(SP)
187:                    writeBuffer[4] = ((char *) &tempInt)[0];
9D020900  A3A20018   SB V0, 24(SP)
188:                    writeBuffer[5] = ((char *) &tempInt)[1];
9D020904  00022202   SRL A0, V0, 8
9D020908  A3A40019   SB A0, 25(SP)
189:                    writeBuffer[6] = ((char *) &tempInt)[2];
9D02090C  00022402   SRL A0, V0, 16
9D020910  A3A4001A   SB A0, 26(SP)
190:                    writeBuffer[7] = ((char *) &tempInt)[3];
9D020914  00021602   SRL V0, V0, 24
9D020918  A3A2001B   SB V0, 27(SP)
191:                 
192:                    if (fwrite (writeBuffer, 8, 1, snssFile->fp) != 1)
9D02091C  27A40014   ADDIU A0, SP, 20
9D020920  24050008   ADDIU A1, ZERO, 8
9D020924  24060001   ADDIU A2, ZERO, 1
9D020928  0F40EFC8   JAL fwrite
9D02092C  8C670000   LW A3, 0(V1)
193:                    {
194:                       return SNSS_WRITE_FAILED;
9D020930  38420001   XORI V0, V0, 1
195:                    }
196:                 
197:                    return SNSS_OK;
198:                 }
9D020934  24030005   ADDIU V1, ZERO, 5
9D020938  0002180A   MOVZ V1, ZERO, V0
9D02093C  00601021   ADDU V0, V1, ZERO
9D020940  8FBF0024   LW RA, 36(SP)
9D020944  03E00008   JR RA
9D020948  27BD0028   ADDIU SP, SP, 40
199:                 
200:                 /**************************************************************************/
201:                 /* general file manipulation functions */
202:                 /**************************************************************************/
203:                 SNSS_RETURN_CODE
204:                 SNSS_OpenFile (SNSS_FILE **snssFile, const char *filename, SNSS_OPEN_MODE mode)
205:                 {
9D021050  27BDFFE0   ADDIU SP, SP, -32
9D021054  AFBF001C   SW RA, 28(SP)
9D021058  AFB20018   SW S2, 24(SP)
9D02105C  AFB10014   SW S1, 20(SP)
9D021060  AFB00010   SW S0, 16(SP)
9D021064  00808021   ADDU S0, A0, ZERO
9D021068  00A09021   ADDU S2, A1, ZERO
9D02106C  00C08821   ADDU S1, A2, ZERO
206:                    *snssFile = malloc(sizeof(SNSS_FILE));
9D021070  0F40AC40   JAL .Letext0, .LFE16, malloc
9D021074  240479FC   ADDIU A0, ZERO, 31228
9D021078  AE020000   SW V0, 0(S0)
207:                    if (NULL == *snssFile)
9D02107C  10400045   BEQ V0, ZERO, 0x9D021194
9D021080  24070006   ADDIU A3, ZERO, 6
208:                    {
209:                       return SNSS_OUT_OF_MEMORY;
210:                    }
211:                  
212:                    /* zero the memory */
213:                    memset (*snssFile, 0, sizeof(SNSS_FILE));
9D021084  00402021   ADDU A0, V0, ZERO
9D021088  00002821   ADDU A1, ZERO, ZERO
9D02108C  0F40E7C9   JAL .Letext0, .LFE0, memset
9D021090  240679FC   ADDIU A2, ZERO, 31228
214:                 
215:                    (*snssFile)->mode = mode;
9D021094  8E020000   LW V0, 0(S0)
216:                 
217:                    if (SNSS_OPEN_READ == mode)
9D021098  1620000D   BNE S1, ZERO, 0x9D0210D0
9D02109C  AC510004   SW S1, 4(V0)
218:                    {
219:                       (*snssFile)->fp = fopen (filename, "rb");
9D0210A0  8E110000   LW S1, 0(S0)
9D0210A4  02402021   ADDU A0, S2, ZERO
9D0210A8  3C059D03   LUI A1, -25341
9D0210AC  0F40DA7E   JAL .Letext0, .LFE3, fopen
9D0210B0  24A57E1C   ADDIU A1, A1, 32284
9D0210B4  AE220000   SW V0, 0(S1)
220:                    }
221:                    else
222:                    {
223:                       (*snssFile)->fp = fopen (filename, "wb");
9D0210D0  8E110000   LW S1, 0(S0)
9D0210D4  02402021   ADDU A0, S2, ZERO
9D0210D8  3C059D03   LUI A1, -25341
9D0210DC  0F40DA7E   JAL .Letext0, .LFE3, fopen
9D0210E0  24A57E20   ADDIU A1, A1, 32288
9D0210E4  AE220000   SW V0, 0(S1)
224:                       (*snssFile)->headerBlock.numberOfBlocks = 0;
9D0210E8  8E020000   LW V0, 0(S0)
9D0210EC  AC400010   SW ZERO, 16(V0)
225:                    }
226:                 
227:                    if (NULL == (*snssFile)->fp)
9D0210B8  8E110000   LW S1, 0(S0)
9D0210BC  8E270000   LW A3, 0(S1)
9D0210C0  54E00014   BNEL A3, ZERO, .LBB25
9D0210C4  26300008   ADDIU S0, S1, 8
9D0210C8  0B408440   J 0x9D021100
9D0210CC  00000000   NOP
9D0210F0  8E110000   LW S1, 0(S0)
9D0210F4  8E220000   LW V0, 0(S1)
9D0210F8  14400023   BNE V0, ZERO, 0x9D021188
9D0210FC  00000000   NOP
228:                    {
229:                       free(*snssFile);
9D021100  0F40CEBA   JAL free
9D021104  02202021   ADDU A0, S1, ZERO
230:                       *snssFile = NULL;
9D021108  AE000000   SW ZERO, 0(S0)
231:                       return SNSS_OPEN_FAILED;
9D02110C  0B408465   J 0x9D021194
9D021110  24070002   ADDIU A3, ZERO, 2
232:                    }
233:                 
234:                    if (SNSS_OPEN_READ == mode)
235:                    {
236:                       return SNSS_ReadFileHeader(*snssFile);
237:                    }
238:                    else
239:                    {
240:                       return SNSS_WriteFileHeader(*snssFile);
9D021188  0F408236   JAL .LFB14, SNSS_WriteFileHeader, .Ltext0
9D02118C  02202021   ADDU A0, S1, ZERO
9D021190  00403821   ADDU A3, V0, ZERO
241:                    }
242:                 }
9D021194  00E01021   ADDU V0, A3, ZERO
9D021198  8FBF001C   LW RA, 28(SP)
9D02119C  8FB20018   LW S2, 24(SP)
9D0211A0  8FB10014   LW S1, 20(SP)
9D0211A4  8FB00010   LW S0, 16(SP)
9D0211A8  03E00008   JR RA
9D0211AC  27BD0020   ADDIU SP, SP, 32
243:                 
244:                 /**************************************************************************/
245:                 
246:                 SNSS_RETURN_CODE
247:                 SNSS_CloseFile (SNSS_FILE **snssFile)
248:                 {
9D0211B0  27BDFFE0   ADDIU SP, SP, -32
9D0211B4  AFBF001C   SW RA, 28(SP)
9D0211B8  AFB10018   SW S1, 24(SP)
9D0211BC  AFB00014   SW S0, 20(SP)
249:                    int prevLoc;
250:                    SNSS_RETURN_CODE code;
251:                 
252:                    /* file was never open, so this should indicate success- kinda. */
253:                    if (NULL == *snssFile)
9D0211C0  8C820000   LW V0, 0(A0)
9D0211C4  10400020   BEQ V0, ZERO, 0x9D021248
9D0211C8  00808021   ADDU S0, A0, ZERO
254:                    {
255:                       return SNSS_OK;
9D021248  00001821   ADDU V1, ZERO, ZERO
256:                    }
257:                 
258:                    if (SNSS_OPEN_WRITE == (*snssFile)->mode)
9D0211CC  8C440004   LW A0, 4(V0)
9D0211D0  24030001   ADDIU V1, ZERO, 1
9D0211D4  54830013   BNEL A0, V1, 0x9D021224
9D0211D8  8E020000   LW V0, 0(S0)
259:                    {
260:                       prevLoc = ftell((*snssFile)->fp);
9D0211DC  0F40ED11   JAL ftell
9D0211E0  8C440000   LW A0, 0(V0)
9D0211E4  00408821   ADDU S1, V0, ZERO
261:                       fseek((*snssFile)->fp, 0, SEEK_SET);
9D0211E8  8E030000   LW V1, 0(S0)
9D0211EC  8C640000   LW A0, 0(V1)
9D0211F0  00002821   ADDU A1, ZERO, ZERO
9D0211F4  0F40E9C4   JAL fseek
9D0211F8  00003021   ADDU A2, ZERO, ZERO
262:                 
263:                       /* write the header again to update block count */
264:                       if (SNSS_OK != (code = SNSS_WriteFileHeader(*snssFile)))
9D0211FC  0F408236   JAL .LFB14, SNSS_WriteFileHeader, .Ltext0
9D021200  8E040000   LW A0, 0(S0)
9D021204  14400011   BNE V0, ZERO, 0x9D02124C
9D021208  24030003   ADDIU V1, ZERO, 3
265:                       {
266:                          return SNSS_CLOSE_FAILED;
267:                       }
268:                 
269:                       fseek((*snssFile)->fp, prevLoc, SEEK_SET);
9D02120C  8E020000   LW V0, 0(S0)
9D021210  8C440000   LW A0, 0(V0)
9D021214  02202821   ADDU A1, S1, ZERO
9D021218  0F40E9C4   JAL fseek
9D02121C  00003021   ADDU A2, ZERO, ZERO
270:                    }
271:                 
272:                    if (fclose ((*snssFile)->fp) != 0)
9D021220  8E020000   LW V0, 0(S0)
9D021224  0F40E9A2   JAL .Letext0, .LFE1, fclose
9D021228  8C440000   LW A0, 0(V0)
9D02122C  14400007   BNE V0, ZERO, 0x9D02124C
9D021230  24030003   ADDIU V1, ZERO, 3
273:                    {
274:                       return SNSS_CLOSE_FAILED;
275:                    }
276:                 
277:                    free(*snssFile);
9D021234  0F40CEBA   JAL free
9D021238  8E040000   LW A0, 0(S0)
278:                    *snssFile = NULL;
9D02123C  AE000000   SW ZERO, 0(S0)
279:                 
280:                    return SNSS_OK;
9D021240  0B408493   J 0x9D02124C
9D021244  00001821   ADDU V1, ZERO, ZERO
281:                 }
9D02124C  00601021   ADDU V0, V1, ZERO
9D021250  8FBF001C   LW RA, 28(SP)
9D021254  8FB10018   LW S1, 24(SP)
9D021258  8FB00014   LW S0, 20(SP)
9D02125C  03E00008   JR RA
9D021260  27BD0020   ADDIU SP, SP, 32
282:                 
283:                 /**************************************************************************/
284:                 
285:                 SNSS_RETURN_CODE 
286:                 SNSS_GetNextBlockType (SNSS_BLOCK_TYPE *blockType, SNSS_FILE *snssFile)
287:                 {
9D021264  27BDFFD8   ADDIU SP, SP, -40
9D021268  AFBF0024   SW RA, 36(SP)
9D02126C  AFB10020   SW S1, 32(SP)
9D021270  AFB0001C   SW S0, 28(SP)
9D021274  00808821   ADDU S1, A0, ZERO
9D021278  00A08021   ADDU S0, A1, ZERO
288:                    char tagBuffer[TAG_LENGTH + 1];
289:                 
290:                    if (fread (tagBuffer, TAG_LENGTH, 1, snssFile->fp) != 1)
9D02127C  27A40010   ADDIU A0, SP, 16
9D021280  24050004   ADDIU A1, ZERO, 4
9D021284  24060001   ADDIU A2, ZERO, 1
9D021288  0F40CA31   JAL .Letext0, .LFE1, fread
9D02128C  8E070000   LW A3, 0(S0)
9D021290  24050001   ADDIU A1, ZERO, 1
9D021294  14450040   BNE V0, A1, 0x9D021398
9D021298  24030004   ADDIU V1, ZERO, 4
291:                    {
292:                       return SNSS_READ_FAILED;
293:                    }
294:                    tagBuffer[TAG_LENGTH] = '\0';
9D02129C  A3A00014   SB ZERO, 20(SP)
295:                 
296:                    /* reset the file pointer to the start of the block */
297:                    if (fseek (snssFile->fp, -TAG_LENGTH, SEEK_CUR) != 0)
9D0212A0  8E040000   LW A0, 0(S0)
9D0212A4  2405FFFC   ADDIU A1, ZERO, -4
9D0212A8  0F40E9C4   JAL fseek
9D0212AC  24060001   ADDIU A2, ZERO, 1
9D0212B0  14400039   BNE V0, ZERO, 0x9D021398
9D0212B4  24030004   ADDIU V1, ZERO, 4
298:                    {
299:                       return SNSS_READ_FAILED;
300:                    }
301:                 
302:                    /* figure out which type of block it is */
303:                    if (strcmp (tagBuffer, "BASR") == 0)
9D0212B8  27A40010   ADDIU A0, SP, 16
9D0212BC  3C059D03   LUI A1, -25341
9D0212C0  0F40DE38   JAL .Letext0, .LFE2, strcmp
9D0212C4  24A57E2C   ADDIU A1, A1, 32300
9D0212C8  14400004   BNE V0, ZERO, 0x9D0212DC
9D0212CC  27A40010   ADDIU A0, SP, 16
304:                    {
305:                       *blockType = SNSS_BASR;
9D0212D0  AE200000   SW ZERO, 0(S1)
9D0212D4  0B4084E6   J 0x9D021398
9D0212D8  00001821   ADDU V1, ZERO, ZERO
306:                    }
307:                    else if (strcmp (tagBuffer, "VRAM") == 0)
9D0212DC  3C059D03   LUI A1, -25341
9D0212E0  0F40DE38   JAL .Letext0, .LFE2, strcmp
9D0212E4  24A57E34   ADDIU A1, A1, 32308
9D0212E8  14400005   BNE V0, ZERO, 0x9D021300
9D0212EC  27A40010   ADDIU A0, SP, 16
308:                    {
309:                       *blockType = SNSS_VRAM;
9D0212F0  24020001   ADDIU V0, ZERO, 1
9D0212F4  AE220000   SW V0, 0(S1)
9D0212F8  0B4084E6   J 0x9D021398
9D0212FC  00001821   ADDU V1, ZERO, ZERO
310:                    }
311:                    else if (strcmp (tagBuffer, "SRAM") == 0)
9D021300  3C059D03   LUI A1, -25341
9D021304  0F40DE38   JAL .Letext0, .LFE2, strcmp
9D021308  24A57E3C   ADDIU A1, A1, 32316
9D02130C  14400005   BNE V0, ZERO, 0x9D021324
9D021310  27A40010   ADDIU A0, SP, 16
312:                    {
313:                       *blockType = SNSS_SRAM;
9D021314  24020002   ADDIU V0, ZERO, 2
9D021318  AE220000   SW V0, 0(S1)
9D02131C  0B4084E6   J 0x9D021398
9D021320  00001821   ADDU V1, ZERO, ZERO
314:                    }
315:                    else if (strcmp (tagBuffer, "MPRD") == 0)
9D021324  3C059D03   LUI A1, -25341
9D021328  0F40DE38   JAL .Letext0, .LFE2, strcmp
9D02132C  24A57E44   ADDIU A1, A1, 32324
9D021330  14400005   BNE V0, ZERO, 0x9D021348
9D021334  27A40010   ADDIU A0, SP, 16
316:                    {
317:                       *blockType = SNSS_MPRD;
9D021338  24020003   ADDIU V0, ZERO, 3
9D02133C  AE220000   SW V0, 0(S1)
9D021340  0B4084E6   J 0x9D021398
9D021344  00001821   ADDU V1, ZERO, ZERO
318:                    }
319:                    else if (strcmp (tagBuffer, "CNTR") == 0)
9D021348  3C059D03   LUI A1, -25341
9D02134C  0F40DE38   JAL .Letext0, .LFE2, strcmp
9D021350  24A57E4C   ADDIU A1, A1, 32332
9D021354  14400005   BNE V0, ZERO, 0x9D02136C
9D021358  27A40010   ADDIU A0, SP, 16
320:                    {
321:                       *blockType = SNSS_CNTR;
9D02135C  24020004   ADDIU V0, ZERO, 4
9D021360  AE220000   SW V0, 0(S1)
9D021364  0B4084E6   J 0x9D021398
9D021368  00001821   ADDU V1, ZERO, ZERO
322:                    }
323:                    else if (strcmp (tagBuffer, "SOUN") == 0)
9D02136C  3C059D03   LUI A1, -25341
9D021370  0F40DE38   JAL .Letext0, .LFE2, strcmp
9D021374  24A57E54   ADDIU A1, A1, 32340
9D021378  14400005   BNE V0, ZERO, 0x9D021390
9D02137C  24020006   ADDIU V0, ZERO, 6
324:                    {
325:                       *blockType = SNSS_SOUN;
9D021380  24020005   ADDIU V0, ZERO, 5
9D021384  AE220000   SW V0, 0(S1)
9D021388  0B4084E6   J 0x9D021398
9D02138C  00001821   ADDU V1, ZERO, ZERO
326:                    }
327:                    else
328:                    {
329:                       *blockType = SNSS_UNKNOWN_BLOCK;
9D021390  AE220000   SW V0, 0(S1)
330:                    }
331:                 
332:                    return SNSS_OK;
9D021394  00001821   ADDU V1, ZERO, ZERO
333:                 }
9D021398  00601021   ADDU V0, V1, ZERO
9D02139C  8FBF0024   LW RA, 36(SP)
9D0213A0  8FB10020   LW S1, 32(SP)
9D0213A4  8FB0001C   LW S0, 28(SP)
9D0213A8  03E00008   JR RA
9D0213AC  27BD0028   ADDIU SP, SP, 40
334:                 
335:                 /**************************************************************************/
336:                 
337:                 SNSS_RETURN_CODE 
338:                 SNSS_SkipNextBlock (SNSS_FILE *snssFile)
339:                 {
9D0213B0  27BDFFE0   ADDIU SP, SP, -32
9D0213B4  AFBF001C   SW RA, 28(SP)
9D0213B8  AFB00018   SW S0, 24(SP)
9D0213BC  00808021   ADDU S0, A0, ZERO
340:                    unsigned int blockLength;
341:                 
342:                    /* skip the block's tag and version */
343:                    if (fseek (snssFile->fp, TAG_LENGTH + sizeof (unsigned int), SEEK_CUR) != 0)
9D0213C0  8C840000   LW A0, 0(A0)
9D0213C4  24050008   ADDIU A1, ZERO, 8
9D0213C8  0F40E9C4   JAL fseek
9D0213CC  24060001   ADDIU A2, ZERO, 1
9D0213D0  14400012   BNE V0, ZERO, 0x9D02141C
9D0213D4  24030004   ADDIU V1, ZERO, 4
344:                    {
345:                       return SNSS_READ_FAILED;
346:                    }
347:                 
348:                    /* get the block data length */
349:                    if (fread (&blockLength, sizeof (unsigned int), 1, snssFile->fp) != 1)
9D0213D8  27A40010   ADDIU A0, SP, 16
9D0213DC  24050004   ADDIU A1, ZERO, 4
9D0213E0  24060001   ADDIU A2, ZERO, 1
9D0213E4  0F40CA31   JAL .Letext0, .LFE1, fread
9D0213E8  8E070000   LW A3, 0(S0)
9D0213EC  24040001   ADDIU A0, ZERO, 1
9D0213F0  1444000A   BNE V0, A0, 0x9D02141C
9D0213F4  24030004   ADDIU V1, ZERO, 4
350:                    {
351:                       return SNSS_READ_FAILED;
352:                    }
353:                    blockLength = swap32 (blockLength);
9D0213F8  8FA50010   LW A1, 16(SP)
9D0213FC  7C0528A0   WSBH A1, A1
9D021400  00252C02   ROTR A1, A1, 16
9D021404  AFA50010   SW A1, 16(SP)
354:                 
355:                    /* skip over the block data */
356:                    if (fseek (snssFile->fp, blockLength, SEEK_CUR) != 0)
9D021408  8E040000   LW A0, 0(S0)
9D02140C  0F40E9C4   JAL fseek
9D021410  24060001   ADDIU A2, ZERO, 1
357:                    {
358:                       return SNSS_READ_FAILED;
9D021414  24030004   ADDIU V1, ZERO, 4
9D021418  0002180A   MOVZ V1, ZERO, V0
359:                    }
360:                 
361:                    return SNSS_OK;
362:                 }
9D02141C  00601021   ADDU V0, V1, ZERO
9D021420  8FBF001C   LW RA, 28(SP)
9D021424  8FB00018   LW S0, 24(SP)
9D021428  03E00008   JR RA
9D02142C  27BD0020   ADDIU SP, SP, 32
363:                 
364:                 /**************************************************************************/
365:                 /* functions for reading and writing base register blocks */
366:                 /**************************************************************************/
367:                 
368:                 static SNSS_RETURN_CODE 
369:                 SNSS_ReadBaseBlock (SNSS_FILE *snssFile)
370:                 {
9D0209C8  27BDE6A0   ADDIU SP, SP, -6496
9D0209CC  AFBF195C   SW RA, 6492(SP)
9D0209D0  AFB01958   SW S0, 6488(SP)
9D0209D4  00808021   ADDU S0, A0, ZERO
371:                    char blockBytes[BASE_BLOCK_LENGTH];
372:                    SnssBlockHeader header;
373:                 
374:                    if (SNSS_ReadBlockHeader (&header, snssFile) != SNSS_OK)
9D0209D8  27A41944   ADDIU A0, SP, 6468
9D0209DC  0F408253   JAL .LFB10, SNSS_ReadBlockHeader, .LFE14
9D0209E0  02002821   ADDU A1, S0, ZERO
9D0209E4  14400094   BNE V0, ZERO, 0x9D020C38
9D0209E8  24030004   ADDIU V1, ZERO, 4
375:                    {
376:                       return SNSS_READ_FAILED;
377:                    }
378:                 
379:                    if (fread (blockBytes, MIN (header.blockLength, BASE_BLOCK_LENGTH), 1, snssFile->fp) != 1)
9D0209EC  8FA21950   LW V0, 6480(SP)
9D0209F0  2C451932   SLTIU A1, V0, 6450
9D0209F4  27A40010   ADDIU A0, SP, 16
9D0209F8  24031931   ADDIU V1, ZERO, 6449
9D0209FC  0045180B   MOVN V1, V0, A1
9D020A00  00602821   ADDU A1, V1, ZERO
9D020A04  24060001   ADDIU A2, ZERO, 1
9D020A08  0F40CA31   JAL .Letext0, .LFE1, fread
9D020A0C  8E070000   LW A3, 0(S0)
9D020A10  24040001   ADDIU A0, ZERO, 1
9D020A14  14440088   BNE V0, A0, 0x9D020C38
9D020A18  24030004   ADDIU V1, ZERO, 4
380:                    {
381:                       return SNSS_READ_FAILED;
382:                    }
383:                 
384:                    snssFile->baseBlock.regA = blockBytes[0x0];
9D020A1C  93A20010   LBU V0, 16(SP)
9D020A20  A2020014   SB V0, 20(S0)
385:                    snssFile->baseBlock.regX = blockBytes[0x1];
9D020A24  93A20011   LBU V0, 17(SP)
9D020A28  A2020015   SB V0, 21(S0)
386:                    snssFile->baseBlock.regY = blockBytes[0x2];
9D020A2C  93A20012   LBU V0, 18(SP)
9D020A30  A2020016   SB V0, 22(S0)
387:                    snssFile->baseBlock.regFlags = blockBytes[0x3];
9D020A34  93A20013   LBU V0, 19(SP)
9D020A38  A2020017   SB V0, 23(S0)
388:                    snssFile->baseBlock.regStack = blockBytes[0x4];
9D020A3C  93A20014   LBU V0, 20(SP)
9D020A40  A2020018   SB V0, 24(S0)
389:                    snssFile->baseBlock.regPc = *((unsigned short *) &blockBytes[0x5]);
9D020A44  93A30015   LBU V1, 21(SP)
9D020A48  93A20016   LBU V0, 22(SP)
9D020A4C  00021200   SLL V0, V0, 8
9D020A50  00431025   OR V0, V0, V1
390:                    snssFile->baseBlock.regPc = swap16 (snssFile->baseBlock.regPc);
9D020A54  7C0210A0   WSBH V0, V0
9D020A58  A602001A   SH V0, 26(S0)
391:                    snssFile->baseBlock.reg2000 = blockBytes[0x7];
9D020A5C  93A20017   LBU V0, 23(SP)
9D020A60  A202001C   SB V0, 28(S0)
392:                    snssFile->baseBlock.reg2001 = blockBytes[0x8];
9D020A64  93A20018   LBU V0, 24(SP)
9D020A68  A202001D   SB V0, 29(S0)
393:                    memcpy (&snssFile->baseBlock.cpuRam, &blockBytes[0x9], 0x800);
9D020A6C  27A30019   ADDIU V1, SP, 25
9D020A70  2602001E   ADDIU V0, S0, 30
9D020A74  27A80819   ADDIU T0, SP, 2073
9D020A78  88670003   LWL A3, 3(V1)
9D020A7C  98670000   LWR A3, 0(V1)
9D020A80  88660007   LWL A2, 7(V1)
9D020A84  98660004   LWR A2, 4(V1)
9D020A88  8865000B   LWL A1, 11(V1)
9D020A8C  98650008   LWR A1, 8(V1)
9D020A90  8864000F   LWL A0, 15(V1)
9D020A94  9864000C   LWR A0, 12(V1)
9D020A98  A8470003   SWL A3, 3(V0)
9D020A9C  B8470000   SWR A3, 0(V0)
9D020AA0  A8460007   SWL A2, 7(V0)
9D020AA4  B8460004   SWR A2, 4(V0)
9D020AA8  A845000B   SWL A1, 11(V0)
9D020AAC  B8450008   SWR A1, 8(V0)
9D020AB0  A844000F   SWL A0, 15(V0)
9D020AB4  B844000C   SWR A0, 12(V0)
9D020AB8  24630010   ADDIU V1, V1, 16
9D020ABC  1468FFEE   BNE V1, T0, 0x9D020A78
9D020AC0  24420010   ADDIU V0, V0, 16
394:                    memcpy (&snssFile->baseBlock.spriteRam, &blockBytes[0x809], 0x100);
9D020AC4  27A30819   ADDIU V1, SP, 2073
9D020AC8  2602081E   ADDIU V0, S0, 2078
9D020ACC  27A80919   ADDIU T0, SP, 2329
9D020AD0  88670003   LWL A3, 3(V1)
9D020AD4  98670000   LWR A3, 0(V1)
9D020AD8  88660007   LWL A2, 7(V1)
9D020ADC  98660004   LWR A2, 4(V1)
9D020AE0  8865000B   LWL A1, 11(V1)
9D020AE4  98650008   LWR A1, 8(V1)
9D020AE8  8864000F   LWL A0, 15(V1)
9D020AEC  9864000C   LWR A0, 12(V1)
9D020AF0  A8470003   SWL A3, 3(V0)
9D020AF4  B8470000   SWR A3, 0(V0)
9D020AF8  A8460007   SWL A2, 7(V0)
9D020AFC  B8460004   SWR A2, 4(V0)
9D020B00  A845000B   SWL A1, 11(V0)
9D020B04  B8450008   SWR A1, 8(V0)
9D020B08  A844000F   SWL A0, 15(V0)
9D020B0C  B844000C   SWR A0, 12(V0)
9D020B10  24630010   ADDIU V1, V1, 16
9D020B14  1468FFEE   BNE V1, T0, 0x9D020AD0
9D020B18  24420010   ADDIU V0, V0, 16
395:                    memcpy (&snssFile->baseBlock.ppuRam, &blockBytes[0x909], 0x1000);
9D020B1C  27A30919   ADDIU V1, SP, 2329
9D020B20  2602091E   ADDIU V0, S0, 2334
9D020B24  27A81919   ADDIU T0, SP, 6425
9D020B28  88670003   LWL A3, 3(V1)
9D020B2C  98670000   LWR A3, 0(V1)
9D020B30  88660007   LWL A2, 7(V1)
9D020B34  98660004   LWR A2, 4(V1)
9D020B38  8865000B   LWL A1, 11(V1)
9D020B3C  98650008   LWR A1, 8(V1)
9D020B40  8864000F   LWL A0, 15(V1)
9D020B44  9864000C   LWR A0, 12(V1)
9D020B48  A8470003   SWL A3, 3(V0)
9D020B4C  B8470000   SWR A3, 0(V0)
9D020B50  A8460007   SWL A2, 7(V0)
9D020B54  B8460004   SWR A2, 4(V0)
9D020B58  A845000B   SWL A1, 11(V0)
9D020B5C  B8450008   SWR A1, 8(V0)
9D020B60  A844000F   SWL A0, 15(V0)
9D020B64  B844000C   SWR A0, 12(V0)
9D020B68  24630010   ADDIU V1, V1, 16
9D020B6C  1468FFEE   BNE V1, T0, 0x9D020B28
9D020B70  24420010   ADDIU V0, V0, 16
396:                    memcpy (&snssFile->baseBlock.palette, &blockBytes[0x1909], 0x20);
9D020B74  2602191E   ADDIU V0, S0, 6430
9D020B78  8BAA191C   LWL T2, 6428(SP)
9D020B7C  9BAA1919   LWR T2, 6425(SP)
9D020B80  8BA91920   LWL T1, 6432(SP)
9D020B84  9BA9191D   LWR T1, 6429(SP)
9D020B88  8BA81924   LWL T0, 6436(SP)
9D020B8C  9BA81921   LWR T0, 6433(SP)
9D020B90  8BA71928   LWL A3, 6440(SP)
9D020B94  9BA71925   LWR A3, 6437(SP)
9D020B98  8BA6192C   LWL A2, 6444(SP)
9D020B9C  9BA61929   LWR A2, 6441(SP)
9D020BA0  8BA51930   LWL A1, 6448(SP)
9D020BA4  9BA5192D   LWR A1, 6445(SP)
9D020BA8  8BA41934   LWL A0, 6452(SP)
9D020BAC  9BA41931   LWR A0, 6449(SP)
9D020BB0  8BA31938   LWL V1, 6456(SP)
9D020BB4  9BA31935   LWR V1, 6453(SP)
9D020BB8  A84A0003   SWL T2, 3(V0)
9D020BBC  B84A0000   SWR T2, 0(V0)
9D020BC0  A8490007   SWL T1, 7(V0)
9D020BC4  B8490004   SWR T1, 4(V0)
9D020BC8  A848000B   SWL T0, 11(V0)
9D020BCC  B8480008   SWR T0, 8(V0)
9D020BD0  A847000F   SWL A3, 15(V0)
9D020BD4  B847000C   SWR A3, 12(V0)
9D020BD8  A8460013   SWL A2, 19(V0)
9D020BDC  B8460010   SWR A2, 16(V0)
9D020BE0  A8450017   SWL A1, 23(V0)
9D020BE4  B8450014   SWR A1, 20(V0)
9D020BE8  A844001B   SWL A0, 27(V0)
9D020BEC  B8440018   SWR A0, 24(V0)
9D020BF0  A843001F   SWL V1, 31(V0)
9D020BF4  B843001C   SWR V1, 28(V0)
397:                    memcpy (&snssFile->baseBlock.mirrorState, &blockBytes[0x1929], 0x4);
9D020BF8  2602193E   ADDIU V0, S0, 6462
9D020BFC  8BA3193C   LWL V1, 6460(SP)
9D020C00  9BA31939   LWR V1, 6457(SP)
9D020C04  AA031941   SWL V1, 6465(S0)
9D020C08  B8430000   SWR V1, 0(V0)
398:                    snssFile->baseBlock.vramAddress = *((unsigned short *) &blockBytes[0x192D]);
9D020C0C  93A2193D   LBU V0, 6461(SP)
9D020C10  93A3193E   LBU V1, 6462(SP)
9D020C14  00031A00   SLL V1, V1, 8
9D020C18  00621025   OR V0, V1, V0
399:                    snssFile->baseBlock.vramAddress = swap16 (snssFile->baseBlock.vramAddress);
9D020C1C  7C0210A0   WSBH V0, V0
9D020C20  A6021942   SH V0, 6466(S0)
400:                    snssFile->baseBlock.spriteRamAddress = blockBytes[0x192F];
9D020C24  93A2193F   LBU V0, 6463(SP)
9D020C28  A2021944   SB V0, 6468(S0)
401:                    snssFile->baseBlock.tileXOffset = blockBytes[0x1930];
9D020C2C  93A21940   LBU V0, 6464(SP)
9D020C30  A2021945   SB V0, 6469(S0)
402:                 
403:                    return SNSS_OK;
9D020C34  00001821   ADDU V1, ZERO, ZERO
404:                 }
9D020C38  00601021   ADDU V0, V1, ZERO
9D020C3C  8FBF195C   LW RA, 6492(SP)
9D020C40  8FB01958   LW S0, 6488(SP)
9D020C44  03E00008   JR RA
9D020C48  27BD1960   ADDIU SP, SP, 6496
405:                 
406:                 /**************************************************************************/
407:                 
408:                 static SNSS_RETURN_CODE 
409:                 SNSS_WriteBaseBlock (SNSS_FILE *snssFile)
410:                 {
9D020D00  27BDE6A0   ADDIU SP, SP, -6496
9D020D04  AFBF195C   SW RA, 6492(SP)
9D020D08  AFB01958   SW S0, 6488(SP)
9D020D0C  00808021   ADDU S0, A0, ZERO
411:                    SnssBlockHeader header;
412:                    SNSS_RETURN_CODE returnCode;
413:                    char blockBytes[BASE_BLOCK_LENGTH];
414:                    unsigned short tempShort;
415:                 
416:                    strcpy (header.tag, "BASR");
9D020D10  3C025253   LUI V0, 21075
9D020D14  24424142   ADDIU V0, V0, 16706
9D020D18  AFA20010   SW V0, 16(SP)
9D020D1C  A3A00014   SB ZERO, 20(SP)
417:                    header.blockVersion = SNSS_BLOCK_VERSION;
9D020D20  24020001   ADDIU V0, ZERO, 1
9D020D24  AFA20018   SW V0, 24(SP)
418:                    header.blockLength = BASE_BLOCK_LENGTH;
9D020D28  24021931   ADDIU V0, ZERO, 6449
9D020D2C  AFA2001C   SW V0, 28(SP)
419:                 
420:                    if ((returnCode = SNSS_WriteBlockHeader (&header, snssFile)) != SNSS_OK)
9D020D30  27A40010   ADDIU A0, SP, 16
9D020D34  0F408313   JAL .LFB11, SNSS_WriteBlockHeader, .LFE19
9D020D38  02002821   ADDU A1, S0, ZERO
9D020D3C  14400093   BNE V0, ZERO, 0x9D020F8C
9D020D40  00401821   ADDU V1, V0, ZERO
421:                    {
422:                       return returnCode;
423:                    }
424:                 
425:                    blockBytes[0x0] = snssFile->baseBlock.regA;
9D020D44  92020014   LBU V0, 20(S0)
9D020D48  A3A20020   SB V0, 32(SP)
426:                    blockBytes[0x1] = snssFile->baseBlock.regX;
9D020D4C  92020015   LBU V0, 21(S0)
9D020D50  A3A20021   SB V0, 33(SP)
427:                    blockBytes[0x2] = snssFile->baseBlock.regY;
9D020D54  92020016   LBU V0, 22(S0)
9D020D58  A3A20022   SB V0, 34(SP)
428:                    blockBytes[0x3] = snssFile->baseBlock.regFlags;
9D020D5C  92020017   LBU V0, 23(S0)
9D020D60  A3A20023   SB V0, 35(SP)
429:                    blockBytes[0x4] = snssFile->baseBlock.regStack;
9D020D64  92020018   LBU V0, 24(S0)
9D020D68  A3A20024   SB V0, 36(SP)
430:                    tempShort = swap16 (snssFile->baseBlock.regPc);
9D020D6C  9602001A   LHU V0, 26(S0)
9D020D70  7C0210A0   WSBH V0, V0
9D020D74  A7A21952   SH V0, 6482(SP)
431:                    blockBytes[0x5] = ((char *) &tempShort)[0];
9D020D78  A3A20025   SB V0, 37(SP)
432:                    blockBytes[0x6] = ((char *) &tempShort)[1];
9D020D7C  00021202   SRL V0, V0, 8
9D020D80  A3A20026   SB V0, 38(SP)
433:                    blockBytes[0x7] = snssFile->baseBlock.reg2000;
9D020D84  9202001C   LBU V0, 28(S0)
9D020D88  A3A20027   SB V0, 39(SP)
434:                    blockBytes[0x8] = snssFile->baseBlock.reg2001;
9D020D8C  9202001D   LBU V0, 29(S0)
9D020D90  A3A20028   SB V0, 40(SP)
435:                    memcpy (&blockBytes[0x9], &snssFile->baseBlock.cpuRam, 0x800);
9D020D94  2603001E   ADDIU V1, S0, 30
9D020D98  27A20029   ADDIU V0, SP, 41
9D020D9C  2608081E   ADDIU T0, S0, 2078
9D020DA0  88670003   LWL A3, 3(V1)
9D020DA4  98670000   LWR A3, 0(V1)
9D020DA8  88660007   LWL A2, 7(V1)
9D020DAC  98660004   LWR A2, 4(V1)
9D020DB0  8865000B   LWL A1, 11(V1)
9D020DB4  98650008   LWR A1, 8(V1)
9D020DB8  8864000F   LWL A0, 15(V1)
9D020DBC  9864000C   LWR A0, 12(V1)
9D020DC0  A8470003   SWL A3, 3(V0)
9D020DC4  B8470000   SWR A3, 0(V0)
9D020DC8  A8460007   SWL A2, 7(V0)
9D020DCC  B8460004   SWR A2, 4(V0)
9D020DD0  A845000B   SWL A1, 11(V0)
9D020DD4  B8450008   SWR A1, 8(V0)
9D020DD8  A844000F   SWL A0, 15(V0)
9D020DDC  B844000C   SWR A0, 12(V0)
9D020DE0  24630010   ADDIU V1, V1, 16
9D020DE4  1468FFEE   BNE V1, T0, 0x9D020DA0
9D020DE8  24420010   ADDIU V0, V0, 16
436:                    memcpy (&blockBytes[0x809], &snssFile->baseBlock.spriteRam, 0x100);
9D020DEC  2603081E   ADDIU V1, S0, 2078
9D020DF0  27A20829   ADDIU V0, SP, 2089
9D020DF4  2608091E   ADDIU T0, S0, 2334
9D020DF8  88670003   LWL A3, 3(V1)
9D020DFC  98670000   LWR A3, 0(V1)
9D020E00  88660007   LWL A2, 7(V1)
9D020E04  98660004   LWR A2, 4(V1)
9D020E08  8865000B   LWL A1, 11(V1)
9D020E0C  98650008   LWR A1, 8(V1)
9D020E10  8864000F   LWL A0, 15(V1)
9D020E14  9864000C   LWR A0, 12(V1)
9D020E18  A8470003   SWL A3, 3(V0)
9D020E1C  B8470000   SWR A3, 0(V0)
9D020E20  A8460007   SWL A2, 7(V0)
9D020E24  B8460004   SWR A2, 4(V0)
9D020E28  A845000B   SWL A1, 11(V0)
9D020E2C  B8450008   SWR A1, 8(V0)
9D020E30  A844000F   SWL A0, 15(V0)
9D020E34  B844000C   SWR A0, 12(V0)
9D020E38  24630010   ADDIU V1, V1, 16
9D020E3C  1468FFEE   BNE V1, T0, 0x9D020DF8
9D020E40  24420010   ADDIU V0, V0, 16
437:                    memcpy (&blockBytes[0x909], &snssFile->baseBlock.ppuRam, 0x1000);
9D020E44  2603091E   ADDIU V1, S0, 2334
9D020E48  27A20929   ADDIU V0, SP, 2345
9D020E4C  2608191E   ADDIU T0, S0, 6430
9D020E50  88670003   LWL A3, 3(V1)
9D020E54  98670000   LWR A3, 0(V1)
9D020E58  88660007   LWL A2, 7(V1)
9D020E5C  98660004   LWR A2, 4(V1)
9D020E60  8865000B   LWL A1, 11(V1)
9D020E64  98650008   LWR A1, 8(V1)
9D020E68  8864000F   LWL A0, 15(V1)
9D020E6C  9864000C   LWR A0, 12(V1)
9D020E70  A8470003   SWL A3, 3(V0)
9D020E74  B8470000   SWR A3, 0(V0)
9D020E78  A8460007   SWL A2, 7(V0)
9D020E7C  B8460004   SWR A2, 4(V0)
9D020E80  A845000B   SWL A1, 11(V0)
9D020E84  B8450008   SWR A1, 8(V0)
9D020E88  A844000F   SWL A0, 15(V0)
9D020E8C  B844000C   SWR A0, 12(V0)
9D020E90  24630010   ADDIU V1, V1, 16
9D020E94  1468FFEE   BNE V1, T0, 0x9D020E50
9D020E98  24420010   ADDIU V0, V0, 16
438:                    memcpy (&blockBytes[0x1909], &snssFile->baseBlock.palette, 0x20);
9D020E9C  2602191E   ADDIU V0, S0, 6430
9D020EA0  88490003   LWL T1, 3(V0)
9D020EA4  98490000   LWR T1, 0(V0)
9D020EA8  88480007   LWL T0, 7(V0)
9D020EAC  98480004   LWR T0, 4(V0)
9D020EB0  8847000B   LWL A3, 11(V0)
9D020EB4  98470008   LWR A3, 8(V0)
9D020EB8  8846000F   LWL A2, 15(V0)
9D020EBC  9846000C   LWR A2, 12(V0)
9D020EC0  88450013   LWL A1, 19(V0)
9D020EC4  98450010   LWR A1, 16(V0)
9D020EC8  88440017   LWL A0, 23(V0)
9D020ECC  98440014   LWR A0, 20(V0)
9D020ED0  8843001B   LWL V1, 27(V0)
9D020ED4  98430018   LWR V1, 24(V0)
9D020ED8  884A001F   LWL T2, 31(V0)
9D020EDC  984A001C   LWR T2, 28(V0)
9D020EE0  ABA9192C   SWL T1, 6444(SP)
9D020EE4  BBA91929   SWR T1, 6441(SP)
9D020EE8  ABA81930   SWL T0, 6448(SP)
9D020EEC  BBA8192D   SWR T0, 6445(SP)
9D020EF0  ABA71934   SWL A3, 6452(SP)
9D020EF4  BBA71931   SWR A3, 6449(SP)
9D020EF8  ABA61938   SWL A2, 6456(SP)
9D020EFC  BBA61935   SWR A2, 6453(SP)
9D020F00  ABA5193C   SWL A1, 6460(SP)
9D020F04  BBA51939   SWR A1, 6457(SP)
9D020F08  ABA41940   SWL A0, 6464(SP)
9D020F0C  BBA4193D   SWR A0, 6461(SP)
9D020F10  ABA31944   SWL V1, 6468(SP)
9D020F14  BBA31941   SWR V1, 6465(SP)
9D020F18  ABAA1948   SWL T2, 6472(SP)
9D020F1C  BBAA1945   SWR T2, 6469(SP)
439:                    memcpy (&blockBytes[0x1929], &snssFile->baseBlock.mirrorState, 0x4);
9D020F20  2602193E   ADDIU V0, S0, 6462
9D020F24  88430003   LWL V1, 3(V0)
9D020F28  98430000   LWR V1, 0(V0)
9D020F2C  ABA3194C   SWL V1, 6476(SP)
9D020F30  BBA31949   SWR V1, 6473(SP)
440:                    tempShort = swap16 (snssFile->baseBlock.vramAddress);
9D020F34  96021942   LHU V0, 6466(S0)
9D020F38  7C0210A0   WSBH V0, V0
9D020F3C  A7A21952   SH V0, 6482(SP)
441:                    blockBytes[0x192D] = ((char *) &tempShort)[0];
9D020F40  A3A2194D   SB V0, 6477(SP)
442:                    blockBytes[0x192E] = ((char *) &tempShort)[1];
9D020F44  00021202   SRL V0, V0, 8
9D020F48  A3A2194E   SB V0, 6478(SP)
443:                    blockBytes[0x192F] = snssFile->baseBlock.spriteRamAddress;
9D020F4C  92021944   LBU V0, 6468(S0)
9D020F50  A3A2194F   SB V0, 6479(SP)
444:                    blockBytes[0x1930] = snssFile->baseBlock.tileXOffset;
9D020F54  92021945   LBU V0, 6469(S0)
9D020F58  A3A21950   SB V0, 6480(SP)
445:                 
446:                    if (fwrite (blockBytes, BASE_BLOCK_LENGTH, 1, snssFile->fp) != 1)
9D020F5C  27A40020   ADDIU A0, SP, 32
9D020F60  24051931   ADDIU A1, ZERO, 6449
9D020F64  24060001   ADDIU A2, ZERO, 1
9D020F68  0F40EFC8   JAL fwrite
9D020F6C  8E070000   LW A3, 0(S0)
9D020F70  24040001   ADDIU A0, ZERO, 1
9D020F74  14440005   BNE V0, A0, 0x9D020F8C
9D020F78  24030005   ADDIU V1, ZERO, 5
447:                    {
448:                       return SNSS_WRITE_FAILED;
449:                    }
450:                 
451:                    snssFile->headerBlock.numberOfBlocks++;
9D020F7C  8E020010   LW V0, 16(S0)
9D020F80  24420001   ADDIU V0, V0, 1
9D020F84  AE020010   SW V0, 16(S0)
452:                 
453:                    return SNSS_OK;
9D020F88  00001821   ADDU V1, ZERO, ZERO
454:                 }
9D020F8C  00601021   ADDU V0, V1, ZERO
9D020F90  8FBF195C   LW RA, 6492(SP)
9D020F94  8FB01958   LW S0, 6488(SP)
9D020F98  03E00008   JR RA
9D020F9C  27BD1960   ADDIU SP, SP, 6496
455:                 
456:                 /**************************************************************************/
457:                 /* functions for reading and writing VRAM blocks */
458:                 /**************************************************************************/
459:                 
460:                 static SNSS_RETURN_CODE 
461:                 SNSS_ReadVramBlock (SNSS_FILE *snssFile)
462:                 {
463:                    SnssBlockHeader header;
464:                 
465:                    if (SNSS_ReadBlockHeader (&header, snssFile) != SNSS_OK)
9D021498  27A40010   ADDIU A0, SP, 16
466:                    {
467:                       return SNSS_READ_FAILED;
468:                    }
469:                 
470:                    if (fread (snssFile->vramBlock.vram, MIN (header.blockLength, VRAM_16K), 1, snssFile->fp) != 1)
9D0214AC  8FA2001C   LW V0, 28(SP)
471:                    {
472:                       return SNSS_READ_FAILED;
473:                    }
474:                 
475:                    snssFile->vramBlock.vramSize = header.blockLength;
9D0214DC  8FA2001C   LW V0, 28(SP)
9D0214E0  A6021946   SH V0, 6470(S0)
476:                 
477:                    return SNSS_OK;
9D0214E4  0B4085AE   J 0x9D0216B8
9D0214E8  00001821   ADDU V1, ZERO, ZERO
478:                 }
479:                 
480:                 /**************************************************************************/
481:                 
482:                 static SNSS_RETURN_CODE 
483:                 SNSS_WriteVramBlock (SNSS_FILE *snssFile)
484:                 {
485:                    SnssBlockHeader header;
486:                    SNSS_RETURN_CODE returnCode;
487:                 
488:                    strcpy (header.tag, "VRAM");
9D021734  3C024D41   LUI V0, 19777
489:                    header.blockVersion = SNSS_BLOCK_VERSION;
9D021744  24020001   ADDIU V0, ZERO, 1
490:                    header.blockLength = snssFile->vramBlock.vramSize;
9D02174C  94821946   LHU V0, 6470(A0)
491:                 
492:                    if ((returnCode = SNSS_WriteBlockHeader (&header, snssFile)) != SNSS_OK)
9D021754  27A40010   ADDIU A0, SP, 16
493:                    {
494:                       return returnCode;
495:                    }
496:                 
497:                    if (fwrite (snssFile->vramBlock.vram, snssFile->vramBlock.vramSize, 1, snssFile->fp) != 1)
9D021768  26041948   ADDIU A0, S0, 6472
498:                    {
499:                       return SNSS_WRITE_FAILED;
500:                    }
501:                 
502:                    snssFile->headerBlock.numberOfBlocks++;
9D021788  8E020010   LW V0, 16(S0)
9D02178C  24420001   ADDIU V0, V0, 1
9D021790  AE020010   SW V0, 16(S0)
503:                 
504:                    return SNSS_OK;
9D021794  0B408669   J 0x9D0219A4
9D021798  00001821   ADDU V1, ZERO, ZERO
505:                 }
506:                 
507:                 /**************************************************************************/
508:                 /* functions for reading and writing SRAM blocks */
509:                 /**************************************************************************/
510:                 
511:                 static SNSS_RETURN_CODE 
512:                 SNSS_ReadSramBlock (SNSS_FILE *snssFile)
513:                 {
514:                    SnssBlockHeader header;
515:                 
516:                    if (SNSS_ReadBlockHeader (&header, snssFile) != SNSS_OK)
9D0214EC  27A40010   ADDIU A0, SP, 16
517:                    {
518:                       return SNSS_READ_FAILED;
519:                    }
520:                 
521:                    if (fread (&snssFile->sramBlock.sramEnabled, 1, 1, snssFile->fp) != 1)
9D021500  2604594A   ADDIU A0, S0, 22858
522:                    {
523:                       return SNSS_READ_FAILED;
524:                    }
525:                 
526:                    /* read blockLength - 1 bytes to get all of the SRAM */
527:                    if (fread (&snssFile->sramBlock.sram, MIN (header.blockLength - 1, SRAM_8K), 1, snssFile->fp) != 1)
9D021520  8FA2001C   LW V0, 28(SP)
528:                    {
529:                       return SNSS_READ_FAILED;
530:                    }
531:                 
532:                    /* SRAM size is the size of the block - 1 (SRAM enabled byte) */
533:                    snssFile->sramBlock.sramSize = header.blockLength - 1;
9D021554  8FA2001C   LW V0, 28(SP)
9D021558  2442FFFF   ADDIU V0, V0, -1
9D02155C  A6025948   SH V0, 22856(S0)
534:                 
535:                    return SNSS_OK;
9D021560  0B4085AE   J 0x9D0216B8
9D021564  00001821   ADDU V1, ZERO, ZERO
536:                 }
537:                 
538:                 /**************************************************************************/
539:                 
540:                 static SNSS_RETURN_CODE 
541:                 SNSS_WriteSramBlock (SNSS_FILE *snssFile)
542:                 {
543:                    SnssBlockHeader header;
544:                    SNSS_RETURN_CODE returnCode;
545:                 
546:                    strcpy (header.tag, "SRAM");
9D02179C  3C024D41   LUI V0, 19777
547:                    header.blockVersion = SNSS_BLOCK_VERSION;
9D0217AC  24020001   ADDIU V0, ZERO, 1
548:                    /* length of block is size of SRAM plus SRAM enabled byte */
549:                    header.blockLength = snssFile->sramBlock.sramSize + 1;
9D0217B4  94825948   LHU V0, 22856(A0)
550:                    if ((returnCode = SNSS_WriteBlockHeader (&header, snssFile)) != SNSS_OK)
9D0217C0  27A40010   ADDIU A0, SP, 16
551:                    {
552:                       return returnCode;
553:                    }
554:                 
555:                    if (fwrite (&snssFile->sramBlock.sramEnabled, 1, 1, snssFile->fp) != 1)
9D0217D4  2604594A   ADDIU A0, S0, 22858
556:                    {
557:                       return SNSS_WRITE_FAILED;
558:                    }
559:                 
560:                    if (fwrite (snssFile->sramBlock.sram, snssFile->sramBlock.sramSize, 1, snssFile->fp) != 1)
9D0217F4  2604594B   ADDIU A0, S0, 22859
561:                    {
562:                       return SNSS_WRITE_FAILED;
563:                    }
564:                 
565:                    snssFile->headerBlock.numberOfBlocks++;
9D021814  8E020010   LW V0, 16(S0)
9D021818  24420001   ADDIU V0, V0, 1
9D02181C  AE020010   SW V0, 16(S0)
566:                 
567:                    return SNSS_OK;
9D021820  0B408669   J 0x9D0219A4
9D021824  00001821   ADDU V1, ZERO, ZERO
568:                 }
569:                 
570:                 /**************************************************************************/
571:                 /* functions for reading and writing mapper data blocks */
572:                 /**************************************************************************/
573:                 
574:                 static SNSS_RETURN_CODE 
575:                 SNSS_ReadMapperBlock (SNSS_FILE *snssFile)
576:                 {
577:                    char *blockBytes;
578:                    int i;
579:                    SnssBlockHeader header;
580:                 
581:                    if (SNSS_ReadBlockHeader (&header, snssFile) != SNSS_OK)
9D021568  27A40010   ADDIU A0, SP, 16
9D02156C  0F408253   JAL .LFB10, SNSS_ReadBlockHeader, .LFE14
9D021570  02002821   ADDU A1, S0, ZERO
9D021574  14400050   BNE V0, ZERO, 0x9D0216B8
9D021578  24030004   ADDIU V1, ZERO, 4
582:                    {
583:                       return SNSS_READ_FAILED;
584:                    }
585:                 
586:                    if ((blockBytes = (char *) malloc (0x8 + 0x10 + 0x80)) == NULL)
9D02157C  0F40AC40   JAL .Letext0, .LFE16, malloc
9D021580  24040098   ADDIU A0, ZERO, 152
9D021584  00408821   ADDU S1, V0, ZERO
9D021588  1040004B   BEQ V0, ZERO, 0x9D0216B8
9D02158C  24030006   ADDIU V1, ZERO, 6
587:                    {
588:                       return SNSS_OUT_OF_MEMORY;
589:                    }
590:                 
591:                    if (fread (blockBytes, MIN (0x8 + 0x10 + 0x80, header.blockLength), 1, snssFile->fp) != 1)
9D021590  8FA2001C   LW V0, 28(SP)
9D021594  2C450099   SLTIU A1, V0, 153
9D021598  02202021   ADDU A0, S1, ZERO
9D02159C  24030098   ADDIU V1, ZERO, 152
9D0215A0  0045180B   MOVN V1, V0, A1
9D0215A4  00602821   ADDU A1, V1, ZERO
9D0215A8  24060001   ADDIU A2, ZERO, 1
9D0215AC  0F40CA31   JAL .Letext0, .LFE1, fread
9D0215B0  8E070000   LW A3, 0(S0)
9D0215B4  24030001   ADDIU V1, ZERO, 1
9D0215B8  10430005   BEQ V0, V1, 0x9D0215D0
9D0215BC  00001021   ADDU V0, ZERO, ZERO
592:                    {
593:                       free(blockBytes);
9D0215C0  0F40CEBA   JAL free
9D0215C4  02202021   ADDU A0, S1, ZERO
594:                       return SNSS_READ_FAILED;
9D0215C8  0B4085AE   J 0x9D0216B8
9D0215CC  24030004   ADDIU V1, ZERO, 4
595:                    }
596:                 
597:                    for (i = 0; i < 4; i++)
9D0215D0  24050008   ADDIU A1, ZERO, 8
9D0215D4  02221821   ADDU V1, S1, V0
9D0215E8  1445FFFA   BNE V0, A1, 0x9D0215D4
9D0215EC  A464794C   SH A0, 31052(V1)
9D0215F0  00001821   ADDU V1, ZERO, ZERO
598:                    {
599:                       snssFile->mapperBlock.prgPages[i] = *((unsigned short *) &blockBytes[i * 2]);
600:                       snssFile->mapperBlock.prgPages[i] = swap16 (snssFile->mapperBlock.prgPages[i]);
9D0215D8  94640000   LHU A0, 0(V1)
9D0215DC  7C0420A0   WSBH A0, A0
9D0215E0  02021821   ADDU V1, S0, V0
9D0215E4  24420002   ADDIU V0, V0, 2
601:                    }
602:                 
603:                    for (i = 0; i < 8; i++)
9D0215F4  24050010   ADDIU A1, ZERO, 16
9D0215F8  02231021   ADDU V0, S1, V1
9D02160C  1465FFFA   BNE V1, A1, 0x9D0215F8
9D021610  A4447954   SH A0, 31060(V0)
604:                    {
605:                       snssFile->mapperBlock.chrPages[i] = *((unsigned short *) &blockBytes[0x8 + (i * 2)]);
606:                       snssFile->mapperBlock.chrPages[i] = swap16 (snssFile->mapperBlock.chrPages[i]);
9D0215FC  94440008   LHU A0, 8(V0)
9D021600  7C0420A0   WSBH A0, A0
9D021604  02031021   ADDU V0, S0, V1
9D021608  24630002   ADDIU V1, V1, 2
607:                    }
608:                 
609:                    memcpy (&snssFile->mapperBlock.extraData.mapperData, &blockBytes[0x18], 0x80);
9D021614  26220018   ADDIU V0, S1, 24
9D021618  26107964   ADDIU S0, S0, 31076
9D02161C  26270098   ADDIU A3, S1, 152
9D021620  8C460000   LW A2, 0(V0)
9D021624  8C450004   LW A1, 4(V0)
9D021628  8C440008   LW A0, 8(V0)
9D02162C  8C43000C   LW V1, 12(V0)
9D021630  AA060003   SWL A2, 3(S0)
9D021634  BA060000   SWR A2, 0(S0)
9D021638  AA050007   SWL A1, 7(S0)
9D02163C  BA050004   SWR A1, 4(S0)
9D021640  AA04000B   SWL A0, 11(S0)
9D021644  BA040008   SWR A0, 8(S0)
9D021648  AA03000F   SWL V1, 15(S0)
9D02164C  BA03000C   SWR V1, 12(S0)
9D021650  24420010   ADDIU V0, V0, 16
9D021654  1447FFF2   BNE V0, A3, 0x9D021620
9D021658  26100010   ADDIU S0, S0, 16
610:                 
611:                    free (blockBytes);
9D02165C  0F40CEBA   JAL free
9D021660  02202021   ADDU A0, S1, ZERO
612:                 
613:                    return SNSS_OK;
9D021664  0B4085AE   J 0x9D0216B8
9D021668  00001821   ADDU V1, ZERO, ZERO
614:                 }
615:                 
616:                 /**************************************************************************/
617:                 
618:                 static SNSS_RETURN_CODE 
619:                 SNSS_WriteMapperBlock (SNSS_FILE *snssFile)
620:                 {
621:                    SnssBlockHeader header;
622:                    char blockBytes[MAPPER_BLOCK_LENGTH];
623:                    unsigned short tempShort;
624:                    int i;
625:                    SNSS_RETURN_CODE returnCode;
626:                 
627:                    strcpy (header.tag, "MPRD");
9D021828  3C024452   LUI V0, 17490
628:                    header.blockVersion = SNSS_BLOCK_VERSION;
9D021838  24020001   ADDIU V0, ZERO, 1
629:                    header.blockLength = MAPPER_BLOCK_LENGTH;
9D021840  24020098   ADDIU V0, ZERO, 152
630:                 
631:                    if ((returnCode = SNSS_WriteBlockHeader (&header, snssFile)) != SNSS_OK)
9D021848  27A400A8   ADDIU A0, SP, 168
632:                    {
633:                       return returnCode;
634:                    }
635:                 
636:                    for (i = 0; i < 4; i++)
9D021884  1445FFF8   BNE V0, A1, .LBB83, .LBB84
637:                    {
638:                       tempShort = swap16 (snssFile->mapperBlock.prgPages[i]);
9D021868  9483794C   LHU V1, 31052(A0)
639:                       blockBytes[(i * 2) + 0] = ((char *) &tempShort)[0];
9D021874  A0430000   SB V1, 0(V0)
640:                       blockBytes[(i * 2) + 1] = ((char *) &tempShort)[1];
9D021878  00031A02   SRL V1, V1, 8
641:                    }
642:                 
643:                    for (i = 0; i < 8; i++)
9D0218B4  1445FFF8   BNE V0, A1, .LBB85, .LBB86
644:                    {
645:                       tempShort = swap16 (snssFile->mapperBlock.chrPages[i]);
9D021898  94837954   LHU V1, 31060(A0)
646:                       blockBytes[0x8 + (i * 2) + 0] = ((char *) &tempShort)[0];
9D0218A4  A0430000   SB V1, 0(V0)
647:                       blockBytes[0x8 + (i * 2) + 1] = ((char *) &tempShort)[1];
9D0218A8  00031A02   SRL V1, V1, 8
648:                    }
649:                 
650:                    memcpy (&blockBytes[0x18], &snssFile->mapperBlock.extraData.mapperData, 0x80);
9D0218BC  26027964   ADDIU V0, S0, 31076
651:                 
652:                    if (fwrite (blockBytes, MAPPER_BLOCK_LENGTH, 1, snssFile->fp) != 1)
9D021904  27A40010   ADDIU A0, SP, 16
653:                    {
654:                       return SNSS_WRITE_FAILED;
655:                    }
656:                 
657:                    snssFile->headerBlock.numberOfBlocks++;
9D021924  8E020010   LW V0, 16(S0)
9D021928  24420001   ADDIU V0, V0, 1
9D02192C  AE020010   SW V0, 16(S0)
658:                 
659:                    return SNSS_OK;
9D021930  0B408669   J 0x9D0219A4
9D021934  00001821   ADDU V1, ZERO, ZERO
660:                 }
661:                 
662:                 /**************************************************************************/
663:                 /* functions for reading and writing controller data blocks */
664:                 /**************************************************************************/
665:                 
666:                 static SNSS_RETURN_CODE 
667:                 SNSS_ReadControllersBlock (SNSS_FILE *snssFile)
668:                 {
669:                    /* quell warnings */
670:                    snssFile = snssFile;
671:                 
672:                    return SNSS_OK;
673:                 }
674:                 
675:                 /**************************************************************************/
676:                 
677:                 static SNSS_RETURN_CODE 
678:                 SNSS_WriteControllersBlock (SNSS_FILE *snssFile)
679:                 {
680:                    /* quell warnings */
681:                    snssFile = snssFile;
682:                 
683:                    return SNSS_OK;
684:                 }
685:                 
686:                 /**************************************************************************/
687:                 /* functions for reading and writing sound blocks */
688:                 /**************************************************************************/
689:                 
690:                 static SNSS_RETURN_CODE 
691:                 SNSS_ReadSoundBlock (SNSS_FILE *snssFile)
692:                 {
693:                    SnssBlockHeader header;
694:                 
695:                    if (SNSS_ReadBlockHeader (&header, snssFile) != SNSS_OK)
9D02166C  27A40010   ADDIU A0, SP, 16
696:                    {
697:                       return SNSS_READ_FAILED;
698:                    }
699:                 
700:                    if (fread (snssFile->soundBlock.soundRegisters, MIN (header.blockLength, 0x16), 1, snssFile->fp) != 1)
9D021680  8FA2001C   LW V0, 28(SP)
701:                    {
702:                       return SNSS_READ_FAILED;
9D0216A4  38420001   XORI V0, V0, 1
9D0216A8  24030004   ADDIU V1, ZERO, 4
703:                    }
704:                 
705:                    return SNSS_OK;
706:                 }
707:                 
708:                 /**************************************************************************/
709:                 
710:                 static SNSS_RETURN_CODE 
711:                 SNSS_WriteSoundBlock (SNSS_FILE *snssFile)
712:                 {
713:                    SnssBlockHeader header;
714:                    SNSS_RETURN_CODE returnCode;
715:                 
716:                    strcpy (header.tag, "SOUN");
9D021938  3C024E55   LUI V0, 20053
717:                    header.blockVersion = SNSS_BLOCK_VERSION;
9D021948  24020001   ADDIU V0, ZERO, 1
718:                    header.blockLength = SOUND_BLOCK_LENGTH;
9D021950  24020016   ADDIU V0, ZERO, 22
719:                 
720:                    if ((returnCode = SNSS_WriteBlockHeader (&header, snssFile)) != SNSS_OK)
9D021958  27A40010   ADDIU A0, SP, 16
721:                    {
722:                       return returnCode;
723:                    }
724:                 
725:                    if (fwrite (snssFile->soundBlock.soundRegisters, SOUND_BLOCK_LENGTH, 1, snssFile->fp) != 1)
9D02196C  260479E5   ADDIU A0, S0, 31205
726:                    {
727:                       return SNSS_WRITE_FAILED;
728:                    }
729:                 
730:                    snssFile->headerBlock.numberOfBlocks++;
9D02198C  8E020010   LW V0, 16(S0)
9D021990  24420001   ADDIU V0, V0, 1
9D021994  AE020010   SW V0, 16(S0)
731:                 
732:                    return SNSS_OK;
9D021998  0B408669   J 0x9D0219A4
9D02199C  00001821   ADDU V1, ZERO, ZERO
733:                 }
734:                 
735:                 /**************************************************************************/
736:                 /* general functions for reading and writing SNSS data blocks */
737:                 /**************************************************************************/
738:                 
739:                 SNSS_RETURN_CODE
740:                 SNSS_ReadBlock (SNSS_FILE *snssFile, SNSS_BLOCK_TYPE blockType)
741:                 {
9D02143C  27BDFFD0   ADDIU SP, SP, -48
9D021440  AFBF002C   SW RA, 44(SP)
9D021444  AFB10028   SW S1, 40(SP)
9D021448  AFB00024   SW S0, 36(SP)
742:                    switch (blockType)
9D021430  2CA20006   SLTIU V0, A1, 6
9D021434  10400011   BEQ V0, ZERO, 0x9D02147C
9D021438  00052880   SLL A1, A1, 2
9D02144C  3C029D02   LUI V0, -25342
9D021450  24421464   ADDIU V0, V0, 5220
9D021454  00452821   ADDU A1, V0, A1
9D021458  8CA20000   LW V0, 0(A1)
9D02145C  00400008   JR V0
9D021460  00808021   ADDU S0, A0, ZERO
743:                    {
744:                    case SNSS_BASR:
745:                       return SNSS_ReadBaseBlock (snssFile);
9D021488  0F408272   JAL .LFB19, SNSS_ReadBaseBlock, .LFE10
9D02148C  00000000   NOP
9D021490  0B4085AE   J 0x9D0216B8
9D021494  00401821   ADDU V1, V0, ZERO
746:                 
747:                    case SNSS_VRAM:
748:                       return SNSS_ReadVramBlock (snssFile);
749:                 
750:                    case SNSS_SRAM:
751:                       return SNSS_ReadSramBlock (snssFile);
752:                 
753:                    case SNSS_MPRD:
754:                       return SNSS_ReadMapperBlock (snssFile);
755:                 
756:                    case SNSS_CNTR:
757:                       return SNSS_ReadControllersBlock (snssFile);
9D0216B4  00001821   ADDU V1, ZERO, ZERO
758:                 
759:                    case SNSS_SOUN:
760:                       return SNSS_ReadSoundBlock (snssFile);
761:                 
762:                    case SNSS_UNKNOWN_BLOCK:
763:                    default:
764:                        return SNSS_UNSUPPORTED_BLOCK;
9D02147C  24030007   ADDIU V1, ZERO, 7
765:                    }
766:                 }
9D021480  03E00008   JR RA
9D021484  00601021   ADDU V0, V1, ZERO
9D0216B8  00601021   ADDU V0, V1, ZERO
9D0216BC  8FBF002C   LW RA, 44(SP)
9D0216C0  8FB10028   LW S1, 40(SP)
9D0216C4  8FB00024   LW S0, 36(SP)
9D0216C8  03E00008   JR RA
9D0216CC  27BD0030   ADDIU SP, SP, 48
767:                 
768:                 /**************************************************************************/
769:                 
770:                 SNSS_RETURN_CODE
771:                 SNSS_WriteBlock (SNSS_FILE *snssFile, SNSS_BLOCK_TYPE blockType)
772:                 {
9D0216DC  27BDFF38   ADDIU SP, SP, -200
9D0216E0  AFBF00C4   SW RA, 196(SP)
9D0216E4  AFB000C0   SW S0, 192(SP)
773:                    switch (blockType)
9D0216D0  2CA20006   SLTIU V0, A1, 6
9D0216D4  10400010   BEQ V0, ZERO, 0x9D021718
9D0216D8  00052880   SLL A1, A1, 2
9D0216E8  3C029D02   LUI V0, -25342
9D0216EC  24421700   ADDIU V0, V0, 5888
9D0216F0  00452821   ADDU A1, V0, A1
9D0216F4  8CA20000   LW V0, 0(A1)
9D0216F8  00400008   JR V0
9D0216FC  00808021   ADDU S0, A0, ZERO
774:                    {
775:                    case SNSS_BASR:
776:                       return SNSS_WriteBaseBlock (snssFile);
9D021724  0F408340   JAL .LFB20, SNSS_WriteBaseBlock, .LFE11
9D021728  00000000   NOP
9D02172C  0B408669   J 0x9D0219A4
9D021730  00401821   ADDU V1, V0, ZERO
777:                 
778:                    case SNSS_VRAM:
779:                       return SNSS_WriteVramBlock (snssFile);
780:                 
781:                    case SNSS_SRAM:
782:                       return SNSS_WriteSramBlock (snssFile);
783:                 
784:                    case SNSS_MPRD:
785:                       return SNSS_WriteMapperBlock (snssFile);
786:                 
787:                    case SNSS_CNTR:
788:                       return SNSS_WriteControllersBlock (snssFile);
9D0219A0  00001821   ADDU V1, ZERO, ZERO
789:                 
790:                    case SNSS_SOUN:
791:                       return SNSS_WriteSoundBlock (snssFile);
792:                 
793:                    case SNSS_UNKNOWN_BLOCK:
794:                    default:
795:                        return SNSS_UNSUPPORTED_BLOCK;
9D021718  24030007   ADDIU V1, ZERO, 7
796:                    }
797:                 }
9D02171C  03E00008   JR RA
9D021720  00601021   ADDU V0, V1, ZERO
9D0219A4  00601021   ADDU V0, V1, ZERO
9D0219A8  8FBF00C4   LW RA, 196(SP)
9D0219AC  8FB000C0   LW S0, 192(SP)
9D0219B0  03E00008   JR RA
9D0219B4  27BD00C8   ADDIU SP, SP, 200
798:                 
799:                 /*
800:                 ** $Log: libsnss.c,v $
801:                 ** Revision 1.2  2001/04/27 14:37:11  neil
802:                 ** wheeee
803:                 **
804:                 ** Revision 1.1  2001/04/27 12:54:40  neil
805:                 ** blah
806:                 **
807:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
808:                 ** initial
809:                 **
810:                 ** Revision 1.1  2000/10/24 12:19:01  matt
811:                 ** changed directory structure
812:                 **
813:                 ** Revision 1.9  2000/10/10 13:03:54  matt
814:                 ** Mr. Clean makes a guest appearance
815:                 **
816:                 ** Revision 1.8  2000/08/16 02:58:34  matt
817:                 ** random cleanups
818:                 **
819:                 ** Revision 1.7  2000/07/17 01:52:27  matt
820:                 ** made sure last line of all source files is a newline
821:                 **
822:                 ** Revision 1.6  2000/07/10 01:54:16  matt
823:                 ** state is now zeroed when it is allocated
824:                 **
825:                 ** Revision 1.5  2000/07/09 15:37:21  matt
826:                 ** all block read/write calls now pass through a common handler
827:                 **
828:                 ** Revision 1.4  2000/07/09 03:39:06  matt
829:                 ** minor modifications
830:                 **
831:                 ** Revision 1.3  2000/07/08 16:01:39  matt
832:                 ** added bald's changes, made error checking more robust
833:                 **
834:                 ** Revision 1.2  2000/07/04 04:46:06  matt
835:                 ** simplified handling of SNSS states
836:                 **
837:                 ** Revision 1.1  2000/06/29 14:13:28  matt
838:                 ** initial revision
839:                 **
840:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/intro.c  -----------------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** intro.c
21:                  **
22:                  ** Nofrendo intro -- 6502 code
23:                  ** $Id: intro.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <string.h>
27:                  #include <stdlib.h>
28:                  #include <noftypes.h>
29:                  #include <intro.h>
30:                  
31:                  #define  CODE_SIZE   0x4000
32:                  #define  VROM_SIZE   0x2000
33:                  
34:                  /* 6502 code for the intro */
35:                  static uint8 intro_code[301] =
36:                  {
37:                     0x78, 0xD8, 0xA2, 0x00, 0x8E, 0x00, 0x20, 0x8E, 0x01, 0x20, 0xAD, 0x02, 0x20, 0xAD, 0x02, 0x20, 
38:                     0x10, 0xFB, 0xAD, 0x02, 0x20, 0x10, 0xFB, 0x8E, 0x03, 0x20, 0xCA, 0x9A, 0xA9, 0x3F, 0x8D, 0x06, 
39:                     0x20, 0xA9, 0x00, 0x8D, 0x06, 0x20, 0xA2, 0x20, 0xA9, 0x0F, 0x8D, 0x07, 0x20, 0xCA, 0xD0, 0xFA, 
40:                     0xA9, 0x20, 0x8D, 0x06, 0x20, 0xA9, 0x00, 0x8D, 0x06, 0x20, 0xAA, 0xA0, 0x10, 0x8D, 0x07, 0x20, 
41:                     0xE8, 0xD0, 0xFA, 0x88, 0xD0, 0xF7, 0xA9, 0xF8, 0xA2, 0x00, 0x9D, 0x00, 0x02, 0xE8, 0xD0, 0xFA, 
42:                     0xA9, 0x02, 0x8D, 0x14, 0x40, 0xA9, 0x21, 0x8D, 0x06, 0x20, 0xA9, 0x89, 0x8D, 0x06, 0x20, 0xA0, 
43:                     0x10, 0xA2, 0xF0, 0x8C, 0x07, 0x20, 0xC8, 0xCA, 0xD0, 0xF9, 0xA9, 0x00, 0x8D, 0x05, 0x20, 0x8D, 
44:                     0x05, 0x20, 0xA9, 0x1E, 0x8D, 0x01, 0x20, 0xA9, 0x80, 0x8D, 0x00, 0x20, 0x20, 0x8B, 0x80, 0x20, 
45:                     0xFE, 0x80, 0x20, 0xF3, 0x80, 0x20, 0xC0, 0x80, 0x4C, 0x88, 0x80, 0xA2, 0x00, 0xA0, 0x06, 0xAD, 
46:                     0x02, 0x20, 0x10, 0xFB, 0x88, 0xD0, 0xF8, 0xA9, 0x00, 0x8D, 0x00, 0x20, 0x8D, 0x01, 0x20, 0xA9, 
47:                     0x3F, 0x8D, 0x06, 0x20, 0xA9, 0x01, 0x8D, 0x06, 0x20, 0xBD, 0x28, 0x81, 0x8D, 0x07, 0x20, 0xA9, 
48:                     0x1E, 0x8D, 0x01, 0x20, 0xA9, 0x80, 0x8D, 0x00, 0x20, 0xE8, 0x8A, 0xC9, 0x05, 0xD0, 0xCE, 0x60, 
49:                     0xA2, 0x05, 0xCA, 0xA0, 0x06, 0xAD, 0x02, 0x20, 0x10, 0xFB, 0x88, 0xD0, 0xF8, 0xA9, 0x00, 0x8D, 
50:                     0x00, 0x20, 0x8D, 0x01, 0x20, 0xA9, 0x3F, 0x8D, 0x06, 0x20, 0xA9, 0x01, 0x8D, 0x06, 0x20, 0xBD, 
51:                     0x28, 0x81, 0x8D, 0x07, 0x20, 0xA9, 0x1E, 0x8D, 0x01, 0x20, 0xA9, 0x80, 0x8D, 0x00, 0x20, 0x8A, 
52:                     0xD0, 0xD0, 0x60, 0xA2, 0x60, 0xAD, 0x02, 0x20, 0x10, 0xFB, 0xCA, 0xD0, 0xF8, 0x60, 0xA9, 0x0F, 
53:                     0x8D, 0x15, 0x40, 0xA9, 0x8D, 0x8D, 0x00, 0x40, 0xA9, 0x7F, 0x8D, 0x01, 0x40, 0xA9, 0x70, 0x8D, 
54:                     0x02, 0x40, 0xA9, 0x08, 0x8D, 0x03, 0x40, 0xA0, 0x05, 0xAD, 0x02, 0x20, 0x10, 0xFB, 0x88, 0xD0, 
55:                     0xF8, 0xA9, 0x54, 0x8D, 0x02, 0x40, 0x60, 0x40, 0x0F, 0x2D, 0x10, 0x3D, 0x20, 
56:                  } ;
57:                  
58:                  /* interrupt vectors (FFFAh - FFFFh) */
59:                  static uint8 intro_vec[6] =
60:                  {
61:                     0x27, 0x81, 0x00, 0x80, 0x27, 0x81
62:                  };
63:                  
64:                  /* graphics */
65:                  static uint8 intro_vrom[4096] = 
66:                  {
67:                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
68:                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
69:                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
70:                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
71:                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
72:                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
73:                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
74:                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
75:                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
76:                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
77:                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
78:                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
79:                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
80:                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
81:                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
82:                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
83:                     0x7F, 0x80, 0xBE, 0xBF, 0xBF, 0xBF, 0xBF, 0xBE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
84:                     0xFF, 0x00, 0x01, 0x01, 0x01, 0x81, 0xC1, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
85:                     0xFF, 0x00, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
86:                     0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
87:                     0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
88:                     0xFF, 0x00, 0x7F, 0xFF, 0xF3, 0xF1, 0xF8, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
89:                     0xFF, 0x00, 0x00, 0x80, 0xC0, 0x80, 0x00, 0x7D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
90:                     0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
91:                     0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
92:                     0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
93:                     0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
94:                     0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
95:                     0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
96:                     0xFF, 0x00, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
97:                     0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
98:                     0xFE, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
99:                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
100:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
101:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
102:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
103:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
104:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
105:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
106:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
107:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
108:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
109:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
110:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
111:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
112:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
113:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
114:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
115:                    0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
116:                    0xE1, 0x71, 0x31, 0x39, 0x1D, 0x0D, 0x0F, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
117:                    0xF0, 0xF1, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
118:                    0xF3, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
119:                    0xC7, 0xE0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
120:                    0xFF, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
121:                    0x7F, 0x7E, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
122:                    0xFC, 0x3C, 0x19, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
123:                    0x79, 0xF0, 0xF0, 0xF0, 0xFF, 0xF0, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
124:                    0xE1, 0xF1, 0xF9, 0xF9, 0xF9, 0x01, 0xF9, 0xF1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
125:                    0xFF, 0xF8, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
126:                    0xF8, 0xF8, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
127:                    0x3C, 0x78, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
128:                    0xFC, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
129:                    0x3C, 0x78, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
130:                    0xF1, 0x79, 0x7D, 0x7D, 0x7D, 0x7D, 0x7D, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
131:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
132:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
133:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
134:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
135:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
136:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
137:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
138:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
139:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
140:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
141:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
142:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
143:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
144:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
145:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
146:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
147:                    0xBE, 0xBE, 0x80, 0x80, 0xBD, 0xA1, 0xBD, 0xA1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
148:                    0x03, 0x03, 0x00, 0x00, 0xE7, 0x11, 0x11, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
149:                    0xF0, 0xF0, 0x00, 0x00, 0xDE, 0x10, 0x1E, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
150:                    0xF3, 0x3F, 0x00, 0x00, 0xF3, 0x88, 0xF0, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
151:                    0xC0, 0x00, 0x00, 0x00, 0xE7, 0x88, 0x8F, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
152:                    0xF8, 0xF8, 0x00, 0x00, 0x2F, 0xA8, 0xA8, 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
153:                    0x7C, 0x7C, 0x00, 0x00, 0x3F, 0xA4, 0xA4, 0xA4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
154:                    0x00, 0x00, 0x00, 0x00, 0x3D, 0xA1, 0xBD, 0xA1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
155:                    0x79, 0x1F, 0x00, 0x00, 0xE7, 0x11, 0x11, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
156:                    0xE1, 0x81, 0x00, 0x00, 0xC3, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
157:                    0xF0, 0xF0, 0x00, 0x00, 0xD1, 0x11, 0x8E, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
158:                    0x7C, 0x7C, 0x00, 0x00, 0x3D, 0x40, 0x38, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
159:                    0x3C, 0x1F, 0x00, 0x00, 0xF7, 0x44, 0x47, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
160:                    0xFC, 0x7C, 0x00, 0x00, 0xBF, 0x24, 0xA4, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
161:                    0x3C, 0x0F, 0x00, 0x00, 0x02, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
162:                    0xF1, 0xC1, 0x01, 0x01, 0x19, 0x25, 0x25, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
163:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
164:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
165:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
166:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
167:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
168:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
169:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
170:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
171:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
172:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
173:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
174:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
175:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
176:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
177:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
178:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
179:                    0x9D, 0x80, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
180:                    0x11, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
181:                    0x0E, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
182:                    0x88, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
183:                    0x88, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
184:                    0xA8, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
185:                    0xA4, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
186:                    0x9D, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
187:                    0x11, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
188:                    0x07, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
189:                    0x84, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
190:                    0x78, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
191:                    0x43, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
192:                    0xA4, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
193:                    0x82, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
194:                    0x99, 0x01, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
195:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
196:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
197:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
198:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
199:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
200:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
201:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
202:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
203:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
204:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
205:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
206:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
207:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
208:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
209:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
210:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
211:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
212:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
213:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
214:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
215:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
216:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
217:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
218:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
219:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
220:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
221:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
222:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
223:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
224:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
225:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
226:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
227:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
228:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
229:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
230:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
231:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
232:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
233:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
234:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
235:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
236:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
237:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
238:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
239:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
240:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
241:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
242:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
243:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
244:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
245:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
246:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
247:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
248:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
249:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
250:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
251:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
252:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
253:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
254:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
255:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
256:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
257:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
258:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
259:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
260:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
261:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
262:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
263:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
264:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
265:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
266:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
267:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
268:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
269:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
270:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
271:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
272:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
273:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
274:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
275:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
276:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
277:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
278:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
279:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
280:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
281:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
282:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
283:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
284:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
285:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
286:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
287:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
288:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
289:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
290:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
291:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
292:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
293:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
294:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
295:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
296:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
297:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
298:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
299:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
300:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
301:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
302:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
303:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
304:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
305:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
306:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
307:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
308:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
309:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
310:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
311:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
312:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
313:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
314:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
315:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
316:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
317:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
318:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
319:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
320:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
321:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
322:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
323:                 };
324:                 
325:                 static uint8 *intro_getrom(void)
326:                 {
327:                    uint8 *rom;
328:                    
329:                    rom = malloc(CODE_SIZE);   
9D035960  0F40DB84   JAL _my_malloc
330:                    if (NULL != rom)
9D035968  1040002C   BEQ V0, ZERO, .LBE7, .LBE6
331:                    {
332:                       /* good measure */
333:                       memset(rom, 0, CODE_SIZE);
9D035970  00402021   ADDU A0, V0, ZERO
334:                 
335:                       /* copy in the code */
336:                       memcpy(rom, intro_code, sizeof(intro_code));
9D035980  3C059D02   LUI A1, -25342
337:                 
338:                       /* copy in the interrupt vectors */
339:                       memcpy(rom + (CODE_SIZE - sizeof(intro_vec)), intro_vec, sizeof(intro_vec));
9D0359F8  3C029D02   LUI V0, -25342
9D0359FC  8C4307A0   LW V1, 1952(V0)
9D035A00  AA033FFD   SWL V1, 16381(S0)
9D035A04  BA033FFA   SWR V1, 16378(S0)
9D035A08  244207A0   ADDIU V0, V0, 1952
9D035A0C  90430004   LBU V1, 4(V0)
9D035A10  A2033FFE   SB V1, 16382(S0)
9D035A14  90420005   LBU V0, 5(V0)
9D035A18  A2023FFF   SB V0, 16383(S0)
340:                    }
341:                 
342:                    return rom;
343:                 }
344:                 
345:                 static uint8 *intro_getvrom(void)
346:                 {
347:                    uint8 *vrom;
348:                 
349:                    vrom = malloc(VROM_SIZE);
9D035A20  0F40DB84   JAL _my_malloc
350:                    if (NULL != vrom)
9D035A28  10400013   BEQ V0, ZERO, .LBE9, .LBE8
351:                    {
352:                       memcpy(vrom, intro_vrom, sizeof(intro_vrom));
9D035A30  3C059D02   LUI A1, -25342
9D035A34  24A5F7A0   ADDIU A1, A1, -2144
9D035A38  24A91000   ADDIU T1, A1, 4096
9D035A3C  8CA80000   LW T0, 0(A1)
9D035A40  8CA70004   LW A3, 4(A1)
9D035A44  8CA60008   LW A2, 8(A1)
9D035A48  8CA4000C   LW A0, 12(A1)
9D035A4C  A8680003   SWL T0, 3(V1)
9D035A50  B8680000   SWR T0, 0(V1)
9D035A54  A8670007   SWL A3, 7(V1)
9D035A58  B8670004   SWR A3, 4(V1)
9D035A5C  A866000B   SWL A2, 11(V1)
9D035A60  B8660008   SWR A2, 8(V1)
9D035A64  A864000F   SWL A0, 15(V1)
9D035A68  B864000C   SWR A0, 12(V1)
9D035A6C  24A50010   ADDIU A1, A1, 16
9D035A70  14A9FFF2   BNE A1, T1, 0x9D035A3C
9D035A74  24630010   ADDIU V1, V1, 16
353:                    }
354:                 
355:                    return vrom;
356:                 }
357:                 
358:                 void intro_get_header(rominfo_t *rominfo)
359:                 {
9D0358FC  27BDFFE8   ADDIU SP, SP, -24
9D035900  AFBF0014   SW RA, 20(SP)
360:                    ASSERT(rominfo);
361:                 
362:                    rominfo->rom_banks = CODE_SIZE / 0x4000;
9D035904  24020001   ADDIU V0, ZERO, 1
9D035908  AC820010   SW V0, 16(A0)
363:                    rominfo->vrom_banks = VROM_SIZE / 0x2000;
9D03590C  AC820014   SW V0, 20(A0)
364:                    rominfo->mirror = MIRROR_VERT;
9D035910  AC820024   SW V0, 36(A0)
365:                    rominfo->flags = 0;
9D035914  A0800028   SB ZERO, 40(A0)
366:                    rominfo->mapper_number = 0;
9D035918  AC800020   SW ZERO, 32(A0)
367:                    
368:                    rominfo->sram_banks = 0;
9D03591C  AC800018   SW ZERO, 24(A0)
369:                    rominfo->vram_banks = 0;
9D035920  AC80001C   SW ZERO, 28(A0)
370:                    rominfo->sram = NULL;
9D035924  AC800008   SW ZERO, 8(A0)
371:                    rominfo->vram = NULL;
9D035928  AC80000C   SW ZERO, 12(A0)
372:                 
373:                    strncpy(rominfo->filename, "Nofrendo intro", PATH_MAX);
9D03592C  24840029   ADDIU A0, A0, 41
9D035930  3C059D02   LUI A1, -25342
9D035934  24A5F790   ADDIU A1, A1, -2160
9D035938  0F40E164   JAL .LFE23, strncpy
9D03593C  24060200   ADDIU A2, ZERO, 512
374:                 }
9D035940  8FBF0014   LW RA, 20(SP)
9D035944  03E00008   JR RA
9D035948  27BD0018   ADDIU SP, SP, 24
375:                 
376:                 int intro_get_rom(rominfo_t *rominfo)
377:                 {
9D03594C  27BDFFE0   ADDIU SP, SP, -32
9D035950  AFBF001C   SW RA, 28(SP)
9D035954  AFB10018   SW S1, 24(SP)
9D035958  AFB00014   SW S0, 20(SP)
9D03595C  00808821   ADDU S1, A0, ZERO
378:                    ASSERT(rominfo);
379:                 
380:                    rominfo->rom = intro_getrom();
9D035A1C  AE300000   SW S0, 0(S1)
381:                    rominfo->vrom = intro_getvrom();
9D035A78  AE220004   SW V0, 4(S1)
382:                    if (NULL == rominfo->rom || NULL == rominfo->vrom)
9D035A7C  8E230000   LW V1, 0(S1)
9D035A80  10600003   BEQ V1, ZERO, 0x9D035A90
9D035A84  2C420001   SLTIU V0, V0, 1
9D035A88  0B40D6A5   J 0x9D035A94
9D035A8C  00021023   SUBU V0, ZERO, V0
383:                       return -1; 
9D035A90  2402FFFF   ADDIU V0, ZERO, -1
384:                 
385:                    return 0;
386:                 }
9D035A94  8FBF001C   LW RA, 28(SP)
9D035A98  8FB10018   LW S1, 24(SP)
9D035A9C  8FB00014   LW S0, 20(SP)
9D035AA0  03E00008   JR RA
9D035AA4  27BD0020   ADDIU SP, SP, 32
387:                 
388:                 /*
389:                 ** $Log: intro.c,v $
390:                 ** Revision 1.2  2001/04/27 14:37:11  neil
391:                 ** wheeee
392:                 **
393:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
394:                 ** initial
395:                 **
396:                 ** Revision 1.5  2000/10/17 03:22:37  matt
397:                 ** cleaning up rom module
398:                 **
399:                 ** Revision 1.4  2000/10/10 13:58:13  matt
400:                 ** stroustrup squeezing his way in the door
401:                 **
402:                 ** Revision 1.3  2000/10/10 13:03:54  matt
403:                 ** Mr. Clean makes a guest appearance
404:                 **
405:                 ** Revision 1.2  2000/07/31 04:28:46  matt
406:                 ** one million cleanups
407:                 **
408:                 ** Revision 1.1  2000/07/30 04:29:11  matt
409:                 ** initial revision
410:                 **
411:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/gui.c  -------------------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** gui.c
21:                  **
22:                  ** GUI routines
23:                  ** $Id: gui.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <stdio.h>
27:                  #include <string.h>
28:                  #include <stdarg.h>
29:                  #include <noftypes.h>
30:                  #include <nes_ppu.h>
31:                  #include <nes_apu.h>
32:                  #include <nesinput.h>
33:                  #include <nes.h>
34:                  #include <log.h>
35:                  #include <osd.h>
36:                  
37:                  #include <bitmap.h>
38:                  
39:                  #include <gui.h>
40:                  #include <gui_elem.h>
41:                  #include <vid_drv.h>
42:                  
43:                  /* TODO: oh god */
44:                  /* 8-bit GUI color table */
45:                  rgb_t gui_pal[GUI_TOTALCOLORS] =
46:                  {
47:                     { 0x00, 0x00, 0x00 }, /* black      */
48:                     { 0x3F, 0x3F, 0x3F }, /* dark gray  */
49:                     { 0x7F, 0x7F, 0x7F }, /* gray       */
50:                     { 0xBF, 0xBF, 0xBF }, /* light gray */
51:                     { 0xFF, 0xFF, 0xFF }, /* white      */
52:                     { 0xFF, 0x00, 0x00 }, /* red        */
53:                     { 0x00, 0xFF, 0x00 }, /* green      */
54:                     { 0x00, 0x00, 0xFF }, /* blue       */
55:                     { 0xFF, 0xFF, 0x00 }, /* yellow     */
56:                     { 0xFF, 0xAF, 0x00 }, /* orange     */
57:                     { 0xFF, 0x00, 0xFF }, /* purple     */
58:                     { 0x3F, 0x7F, 0x7F }, /* teal       */
59:                     { 0x00, 0x2A, 0x00 }, /* dk. green  */
60:                     { 0x00, 0x00, 0x3F }  /* dark blue  */
61:                  };
62:                  
63:                  /**************************************************************/
64:                  #include <pcx.h>
65:                  #include <nesstate.h>
66:                  static bool option_drawsprites = true;
67:                  
68:                  /* save a PCX snapshot */
69:                  void gui_savesnap(void)
70:                  {
9D0240D4  27BDFDE8   ADDIU SP, SP, -536
9D0240D8  AFBF0214   SW RA, 532(SP)
71:                     char filename[PATH_MAX];
72:                     nes_t *nes = nes_getcontextptr();
9D0240DC  0F408AD0   JAL nes_getcontextptr
9D0240E0  AFB00210   SW S0, 528(SP)
73:                  
74:                     //if (osd_makesnapname(filename, PATH_MAX) < 0)
75:                     //   return;
76:                  
77:                     if (pcx_write(filename, vid_getbuffer(), nes->ppu->curpal)) 
9D0240E4  0F40B89E   JAL vid_getbuffer
9D0240E8  00408021   ADDU S0, V0, ZERO
9D0240EC  8E060304   LW A2, 772(S0)
9D0240F0  27A40010   ADDIU A0, SP, 16
9D0240F4  00402821   ADDU A1, V0, ZERO
9D0240F8  0F40D3DF   JAL pcx_write
9D0240FC  24C611AC   ADDIU A2, A2, 4524
9D024100  14400007   BNE V0, ZERO, 0x9D024120
9D024104  8FBF0214   LW RA, 532(SP)
78:                        return;
79:                  
80:                     gui_sendmsg(GUI_GREEN, "Screen saved to %s", filename);
9D024108  240400C6   ADDIU A0, ZERO, 198
9D02410C  3C059D04   LUI A1, -25340
9D024110  24A58CBC   ADDIU A1, A1, -29508
9D024114  0F409020   JAL gui_sendmsg
9D024118  27A60010   ADDIU A2, SP, 16
81:                  }
9D02411C  8FBF0214   LW RA, 532(SP)
9D024120  8FB00210   LW S0, 528(SP)
9D024124  03E00008   JR RA
9D024128  27BD0218   ADDIU SP, SP, 536
82:                  
83:                  /* Show/hide sprites (hiding sprites useful for making maps) */
84:                  void gui_togglesprites(void)
85:                  {
9D02412C  27BDFFE8   ADDIU SP, SP, -24
9D024130  AFBF0014   SW RA, 20(SP)
86:                     option_drawsprites ^= true;
9D024134  8F848024   LW A0, -32732(GP)
9D024138  38840001   XORI A0, A0, 1
87:                     ppu_displaysprites(option_drawsprites);
9D02413C  0F406055   JAL ppu_displaysprites
9D024140  AF848024   SW A0, -32732(GP)
88:                     gui_sendmsg(GUI_GREEN, "Sprites %s", option_drawsprites ? "displayed" : "hidden");
9D024144  8F828024   LW V0, -32732(GP)
9D024148  50400004   BEQL V0, ZERO, 0x9D02415C
9D02414C  3C069D04   LUI A2, -25340
9D024150  3C069D04   LUI A2, -25340
9D024154  0B409058   J 0x9D024160
9D024158  24C68CD0   ADDIU A2, A2, -29488
9D02415C  24C68CDC   ADDIU A2, A2, -29476
9D024160  240400C6   ADDIU A0, ZERO, 198
9D024164  3C059D04   LUI A1, -25340
9D024168  0F409020   JAL gui_sendmsg
9D02416C  24A58CE4   ADDIU A1, A1, -29468
89:                  }
9D024170  8FBF0014   LW RA, 20(SP)
9D024174  03E00008   JR RA
9D024178  27BD0018   ADDIU SP, SP, 24
90:                  
91:                  /* Set the frameskip policy */
92:                  void gui_togglefs(void)
93:                  {
9D02417C  27BDFFE8   ADDIU SP, SP, -24
9D024180  AFBF0014   SW RA, 20(SP)
94:                     nes_t *machine = nes_getcontextptr();
9D024184  0F408AD0   JAL nes_getcontextptr
9D024188  00000000   NOP
95:                  
96:                     machine->autoframeskip ^= true;
9D02418C  8C430328   LW V1, 808(V0)
9D024190  38630001   XORI V1, V1, 1
97:                     if (machine->autoframeskip)
9D024194  10600007   BEQ V1, ZERO, .LVL173
9D024198  AC430328   SW V1, 808(V0)
98:                        gui_sendmsg(GUI_YELLOW, "automatic frameskip");
9D02419C  240400C8   ADDIU A0, ZERO, 200
9D0241A0  3C059D04   LUI A1, -25340
9D0241A4  0F409020   JAL gui_sendmsg
9D0241A8  24A58CF0   ADDIU A1, A1, -29456
9D0241AC  0B409072   J 0x9D0241C8
9D0241B0  8FBF0014   LW RA, 20(SP)
99:                     else
100:                       gui_sendmsg(GUI_YELLOW, "unthrottled emulation");
9D0241B4  240400C8   ADDIU A0, ZERO, 200
9D0241B8  3C059D04   LUI A1, -25340
9D0241BC  0F409020   JAL gui_sendmsg
9D0241C0  24A58D04   ADDIU A1, A1, -29436
101:                 }
9D0241C4  8FBF0014   LW RA, 20(SP)
9D0241C8  03E00008   JR RA
9D0241CC  27BD0018   ADDIU SP, SP, 24
102:                 
103:                 /* display rom information */
104:                 void gui_displayinfo()
105:                 {
9D0241D0  27BDFFE8   ADDIU SP, SP, -24
9D0241D4  AFBF0014   SW RA, 20(SP)
106:                    gui_sendmsg(GUI_ORANGE, (char *) rom_getinfo(nes_getcontextptr()->rominfo));
9D0241D8  0F408AD0   JAL nes_getcontextptr
9D0241DC  00000000   NOP
9D0241E0  0F40AAAB   JAL rom_getinfo
9D0241E4  8C440310   LW A0, 784(V0)
9D0241E8  240400C9   ADDIU A0, ZERO, 201
9D0241EC  0F409020   JAL gui_sendmsg
9D0241F0  00402821   ADDU A1, V0, ZERO
107:                 }
9D0241F4  8FBF0014   LW RA, 20(SP)
9D0241F8  03E00008   JR RA
9D0241FC  27BD0018   ADDIU SP, SP, 24
108:                 
109:                 void gui_toggle_chan(int chan)
110:                 {
9D024200  27BDFFD8   ADDIU SP, SP, -40
9D024204  AFBF0024   SW RA, 36(SP)
9D024208  AFB00020   SW S0, 32(SP)
111:                 #define  FILL_CHAR   0x7C           /* ASCII 124 '|' */
112:                 #define  BLANK_CHAR  0x7F           /* ASCII 127   [delta] */
113:                    static bool chan_enabled[6] = { true, true, true, true, true, true };
114:                 
115:                    chan_enabled[chan] ^= true;
9D02420C  3C10A001   LUI S0, -24575
9D024210  00041880   SLL V1, A0, 2
9D024214  2602A8F0   ADDIU V0, S0, -22288
9D024218  00621021   ADDU V0, V1, V0
9D02421C  8C450000   LW A1, 0(V0)
9D024220  38A50001   XORI A1, A1, 1
116:                    apu_setchan(chan, chan_enabled[chan]);
9D024224  0F407672   JAL apu_setchan
9D024228  AC450000   SW A1, 0(V0)
117:                 
118:                    gui_sendmsg(GUI_ORANGE, "%ca %cb %cc %cd %ce %cext",
9D02422C  8E06A8F0   LW A2, -22288(S0)
9D024234  8C47A8F4   LW A3, -22284(V0)
9D02423C  8C45A8F8   LW A1, -22280(V0)
9D024240  2402007C   ADDIU V0, ZERO, 124
9D024244  2403007F   ADDIU V1, ZERO, 127
9D024248  0065100A   MOVZ V0, V1, A1
9D02424C  00402821   ADDU A1, V0, ZERO
9D024254  8C44A8FC   LW A0, -22276(V0)
9D024258  2402007C   ADDIU V0, ZERO, 124
9D02425C  0064100A   MOVZ V0, V1, A0
9D024260  00402021   ADDU A0, V0, ZERO
9D024268  8C48A900   LW T0, -22272(V0)
9D02426C  2402007C   ADDIU V0, ZERO, 124
9D024270  0048180B   MOVN V1, V0, T0
9D024278  8C49A904   LW T1, -22268(V0)
9D02427C  2408007C   ADDIU T0, ZERO, 124
9D024280  2402007F   ADDIU V0, ZERO, 127
9D024284  0109100B   MOVN V0, T0, T1
9D024288  AFA50010   SW A1, 16(SP)
9D02428C  AFA40014   SW A0, 20(SP)
9D024290  AFA30018   SW V1, 24(SP)
9D024294  AFA2001C   SW V0, 28(SP)
9D024298  240400C9   ADDIU A0, ZERO, 201
9D02429C  3C059D04   LUI A1, -25340
9D0242A0  24A58D1C   ADDIU A1, A1, -29412
9D0242A4  2402007C   ADDIU V0, ZERO, 124
9D0242A8  2403007F   ADDIU V1, ZERO, 127
9D0242AC  0066100A   MOVZ V0, V1, A2
9D0242B0  00403021   ADDU A2, V0, ZERO
9D0242B4  2402007C   ADDIU V0, ZERO, 124
9D0242B8  0067100A   MOVZ V0, V1, A3
9D0242BC  0F409020   JAL gui_sendmsg
9D0242C0  00403821   ADDU A3, V0, ZERO
119:                                chan_enabled[0] ? FILL_CHAR : BLANK_CHAR,
120:                                chan_enabled[1] ? FILL_CHAR : BLANK_CHAR,
9D024230  3C02A001   LUI V0, -24575
121:                                chan_enabled[2] ? FILL_CHAR : BLANK_CHAR,
9D024238  3C02A001   LUI V0, -24575
122:                                chan_enabled[3] ? FILL_CHAR : BLANK_CHAR,
9D024250  3C02A001   LUI V0, -24575
123:                                chan_enabled[4] ? FILL_CHAR : BLANK_CHAR,
9D024264  3C02A001   LUI V0, -24575
124:                                chan_enabled[5] ? FILL_CHAR : BLANK_CHAR);
9D024274  3C02A001   LUI V0, -24575
125:                 }
9D0242C4  8FBF0024   LW RA, 36(SP)
9D0242C8  8FB00020   LW S0, 32(SP)
9D0242CC  03E00008   JR RA
9D0242D0  27BD0028   ADDIU SP, SP, 40
126:                                         
127:                 void gui_setfilter(int filter_type)
128:                 {
9D0242D4  27BDFFD8   ADDIU SP, SP, -40
9D0242D8  AFBF0024   SW RA, 36(SP)
9D0242DC  AFB00020   SW S0, 32(SP)
129:                    char *types[3] = { "no", "lowpass", "weighted" };
9D0242E0  3C029D04   LUI V0, -25340
9D0242E4  24428D38   ADDIU V0, V0, -29384
9D0242E8  AFA20010   SW V0, 16(SP)
9D0242EC  3C029D04   LUI V0, -25340
9D0242F0  24428D3C   ADDIU V0, V0, -29380
9D0242F4  AFA20014   SW V0, 20(SP)
9D0242F8  3C029D04   LUI V0, -25340
9D0242FC  24428D44   ADDIU V0, V0, -29372
9D024300  AFA20018   SW V0, 24(SP)
130:                    static int last_filter = 2;
131:                 
132:                    if (last_filter == filter_type || filter_type < 0 || filter_type > 2)
9D024304  8F82801C   LW V0, -32740(GP)
9D024308  1044000E   BEQ V0, A0, 0x9D024344
9D02430C  00808021   ADDU S0, A0, ZERO
9D024310  2C820003   SLTIU V0, A0, 3
9D024314  1040000C   BEQ V0, ZERO, 0x9D024348
9D024318  8FBF0024   LW RA, 36(SP)
133:                       return;
134:                 
135:                    apu_setfilter(filter_type);
9D02431C  0F407823   JAL .LFB18, .LFE16, apu_setfilter
9D024320  00000000   NOP
136:                    gui_sendmsg(GUI_ORANGE, "%s filter", types[filter_type]);
9D024324  00101080   SLL V0, S0, 2
9D024328  03A21021   ADDU V0, SP, V0
9D02432C  240400C9   ADDIU A0, ZERO, 201
9D024330  3C059D04   LUI A1, -25340
9D024334  24A58D50   ADDIU A1, A1, -29360
9D024338  0F409020   JAL gui_sendmsg
9D02433C  8C460010   LW A2, 16(V0)
137:                    last_filter = filter_type;
9D024340  AF90801C   SW S0, -32740(GP)
138:                 }
9D024344  8FBF0024   LW RA, 36(SP)
9D024348  8FB00020   LW S0, 32(SP)
9D02434C  03E00008   JR RA
9D024350  27BD0028   ADDIU SP, SP, 40
139:                 /**************************************************************/
140:                 
141:                 
142:                 enum
143:                 {
144:                    GUI_WAVENONE,
145:                    GUI_WAVELINE,
146:                    GUI_WAVESOLID,
147:                    GUI_NUMWAVESTYLES
148:                 };
149:                 
150:                 enum
151:                 {
152:                    BUTTON_UP,
153:                    BUTTON_DOWN
154:                 };
155:                 
156:                 
157:                 /* TODO: roll options into a structure */
158:                 static message_t msg;
159:                 static bool option_showfps = false;
160:                 static bool option_showgui = false;
161:                 static int option_wavetype = GUI_WAVENONE;
162:                 static bool option_showpattern = false;
163:                 static bool option_showoam = false;
164:                 static int pattern_col = 0;
165:                 
166:                 /* timimg variables */
167:                 static bool gui_fpsupdate = false;
168:                 static int gui_ticks = 0;
169:                 static int gui_fps = 0;
170:                 static int gui_refresh = 60; /* default to 60Hz */
171:                 
172:                 static int mouse_x, mouse_y, mouse_button;
173:                 
174:                 static bitmap_t *gui_surface;
175:                 
176:                 
177:                 /* Put a pixel on our bitmap- just for GUI use */
178:                 INLINE void gui_putpixel(int x_pos, int y_pos, uint8 color)
179:                 {
180:                    gui_surface->line[y_pos][x_pos] = color;
9D02365C  24A50004   ADDIU A1, A1, 4
9D0236A8  8C650000   LW A1, 0(V1)
9D023764  8CE50000   LW A1, 0(A3)
9D023B38  241EFFC6   ADDIU FP, ZERO, -58
9D023BAC  8F828138   LW V0, -32456(GP)
9D023BB0  8C420098   LW V0, 152(V0)
9D023BB4  00501021   ADDU V0, V0, S0
9D023BB8  0B408EFC   J .LVL117
9D023BBC  A05E0000   SB FP, 0(V0)
9D02403C  8D070014   LW A3, 20(T0)
9D024048  90840000   LBU A0, 0(A0)
181:                 }
182:                 
183:                 /* Line drawing */
184:                 static void gui_hline(int x_pos, int y_pos, int length, uint8 color)
185:                 {
186:                    while (length--)
9D023650  10C0000B   BEQ A2, ZERO, .LVL7
9D023654  00801021   ADDU V0, A0, ZERO
9D023658  00C42021   ADDU A0, A2, A0
9D023678  1444FFFC   BNE V0, A0, .LVL4
9D02367C  A0670000   SB A3, 0(V1)
9D023680  03E00008   JR RA
9D023684  00000000   NOP
187:                       gui_putpixel(x_pos++, y_pos, color);
188:                 }
189:                 
190:                 static void gui_vline(int x_pos, int y_pos, int height, uint8 color)
191:                 {
192:                    while (height--)
9D023688  10C0000D   BEQ A2, ZERO, .LVL13
9D02368C  24C2FFFF   ADDIU V0, A2, -1
9D023690  24A50004   ADDIU A1, A1, 4
9D023694  00052880   SLL A1, A1, 2
9D023698  8F838138   LW V1, -32456(GP)
9D02369C  00651821   ADDU V1, V1, A1
9D0236A0  24630004   ADDIU V1, V1, 4
9D0236A4  2406FFFF   ADDIU A2, ZERO, -1
9D0236B4  2442FFFF   ADDIU V0, V0, -1
9D0236B8  1446FFFB   BNE V0, A2, .LVL11, .LBB18
9D0236BC  24630004   ADDIU V1, V1, 4
9D0236C0  03E00008   JR RA
9D0236C4  00000000   NOP
193:                       gui_putpixel(x_pos, y_pos++, color);
194:                 }
195:                 
196:                 /* Rectangles */
197:                 static void gui_rect(int x_pos, int y_pos, int width, int height, uint8 color)
198:                 {
199:                    gui_hline(x_pos, y_pos, width, color);
9D023BFC  24040080   ADDIU A0, ZERO, 128
200:                    gui_hline(x_pos, y_pos + height - 1, width, color);
9D023C10  24040080   ADDIU A0, ZERO, 128
201:                    gui_vline(x_pos, y_pos + 1, height - 2, color);
9D023C24  24040080   ADDIU A0, ZERO, 128
202:                    gui_vline(x_pos + width - 1, y_pos + 1, height - 2, color);
9D023C38  240400FF   ADDIU A0, ZERO, 255
9D023C3C  24050001   ADDIU A1, ZERO, 1
9D023C40  24060040   ADDIU A2, ZERO, 64
9D023C44  0F408DA2   JAL .LFB13, gui_vline, .LVL8, .LFE12
9D023C48  240700C1   ADDIU A3, ZERO, 193
203:                 }
204:                 
205:                 static void gui_rectfill(int x_pos, int y_pos, int width, int height, uint8 color)
206:                 {
207:                    while (height--)
9D0238EC  2413FFFF   ADDIU S3, ZERO, -1
9D023908  2631FFFF   ADDIU S1, S1, -1
208:                       gui_hline(x_pos, y_pos++, width, color);
9D0238F0  26120001   ADDIU S2, S0, 1
9D0238F4  02A02021   ADDU A0, S5, ZERO
9D0238F8  02002821   ADDU A1, S0, ZERO
9D0238FC  02803021   ADDU A2, S4, ZERO
9D023900  0F408D94   JAL .LFB12, gui_hline, .LVL0, .Ltext0, .Letext0, .LFE31
9D023904  02C03821   ADDU A3, S6, ZERO
9D023908  2631FFFF   ADDIU S1, S1, -1
9D02390C  1633FFF8   BNE S1, S3, .LVL54
9D023910  02408021   ADDU S0, S2, ZERO
209:                 }
210:                 
211:                 /* Draw the outline of a button */
212:                 static void gui_buttonrect(int x_pos, int y_pos, int width, int height, bool down)
213:                 {
214:                    uint8 color1, color2;
215:                 
216:                    if (down)
217:                    {
218:                       color1 = GUI_GRAY;
219:                       color2 = GUI_WHITE;
9D023864  240200C4   ADDIU V0, ZERO, 196
220:                    }
221:                    else
222:                    {
223:                       color1 = GUI_WHITE;
224:                       color2 = GUI_GRAY;
225:                    }
226:                 
227:                    gui_hline(x_pos, y_pos, width - 1, color1);
9D02387C  02E02021   ADDU A0, S7, ZERO
228:                    gui_vline(x_pos, y_pos + 1, height - 2, color1);
9D023890  27D00001   ADDIU S0, FP, 1
229:                    gui_hline(x_pos, y_pos + height - 1, width, color2);
9D0238A8  8FA20018   LW V0, 24(SP)
230:                    gui_vline(x_pos + width - 1, y_pos, height - 1, color2);
9D0238C4  02B72021   ADDU A0, S5, S7
9D0238C8  2484FFFF   ADDIU A0, A0, -1
9D0238CC  03C02821   ADDU A1, FP, ZERO
9D0238D0  26660002   ADDIU A2, S3, 2
9D0238D4  0F408DA2   JAL .LFB13, gui_vline, .LVL8, .LFE12
9D0238D8  02203821   ADDU A3, S1, ZERO
231:                 }
232:                 
233:                 /* Text blitting */
234:                 INLINE void gui_charline(char ch, int x_pos, int y_pos, uint8 color)
235:                 {
236:                    int count = 8;
237:                    while (count--)
9D023718  2404FFFF   ADDIU A0, ZERO, -1
9D023750  24030007   ADDIU V1, ZERO, 7
9D023770  1464FFF8   BNE V1, A0, .LVL24
9D023774  24C60001   ADDIU A2, A2, 1
9D023778  24E70004   ADDIU A3, A3, 4
238:                    {
239:                       if (ch & (1 << count))
9D023754  00694007   SRAV T0, T1, V1
9D023758  31080001   ANDI T0, T0, 1
9D02375C  11000004   BEQ T0, ZERO, .LVL26, .LBE30
9D023760  2463FFFF   ADDIU V1, V1, -1
240:                          gui_putpixel(x_pos, y_pos, color);
241:                       x_pos++;
242:                    }
243:                 }
244:                 
245:                 static void gui_putchar(const uint8 *dat, int height, int x_pos, int y_pos, uint8 color)
246:                 {
247:                    while (height--)
9D02377C  554BFFF2   BNEL T2, T3, .LVL22, .LBB35
9D023780  254A0001   ADDIU T2, T2, 1
248:                       gui_charline(*dat++, x_pos, y_pos++, color);
9D023748  8149FFFF   LB T1, -1(T2)
9D02374C  00403021   ADDU A2, V0, ZERO
249:                 }
250:                 
251:                 /* Return length of text in pixels */
252:                 static int gui_textlen(char *str, font_t *font)
253:                 {
254:                    int pixels = 0;
9D023820  0000A021   ADDU S4, ZERO, ZERO
9D02384C  0000A021   ADDU S4, ZERO, ZERO
255:                    int num_chars = strlen(str);
9D023808  0F40D9CB   JAL strlen
9D02380C  8FB00060   LW S0, 96(SP)
256:                 
257:                    while (num_chars--)
9D023810  1040000E   BEQ V0, ZERO, .LVL43, .LBB45
9D023814  8F868028   LW A2, -32728(GP)
9D023818  8FA30048   LW V1, 72(SP)
9D02381C  00621021   ADDU V0, V1, V0
9D02383C  1462FFF9   BNE V1, V0, .LVL40
9D023840  0284A021   ADDU S4, S4, A0
258:                       pixels += font->character[(*str++ - 32)].spacing;
9D023824  24630001   ADDIU V1, V1, 1
9D023828  8064FFFF   LB A0, -1(V1)
9D02382C  000428C0   SLL A1, A0, 3
9D023830  00A42023   SUBU A0, A1, A0
9D023834  00C42021   ADDU A0, A2, A0
9D023838  9084FF26   LBU A0, -218(A0)
259:                 
260:                    return pixels;
261:                 }
262:                 
263:                 /* Simple textout() type function */
264:                 static int gui_textout(char *str, int x_pos, int y_pos, font_t *font, uint8 color)
265:                 {
9D0236C8  27BDFFD8   ADDIU SP, SP, -40
9D0236CC  AFBF0024   SW RA, 36(SP)
9D0236D0  AFB40020   SW S4, 32(SP)
9D0236D4  AFB3001C   SW S3, 28(SP)
9D0236D8  AFB20018   SW S2, 24(SP)
9D0236DC  AFB10014   SW S1, 20(SP)
9D0236E0  AFB00010   SW S0, 16(SP)
9D0236E4  00808821   ADDU S1, A0, ZERO
9D0236E8  00A09821   ADDU S3, A1, ZERO
9D0236EC  00C0A021   ADDU S4, A2, ZERO
9D0236F0  00E09021   ADDU S2, A3, ZERO
266:                    int x_new;
267:                    int num_chars = strlen(str);
9D0236F4  0F40D9CB   JAL strlen
9D0236F8  93B00038   LBU S0, 56(SP)
268:                    int code;
269:                 
270:                    x_new = x_pos;
9D023704  02601021   ADDU V0, S3, ZERO
9D023708  26830004   ADDIU V1, S4, 4
9D02370C  00031880   SLL V1, V1, 2
9D023710  8F8D8138   LW T5, -32456(GP)
9D023714  01A36821   ADDU T5, T5, V1
9D0237A0  02601021   ADDU V0, S3, ZERO
271:                 
272:                    while (num_chars--)
9D0236FC  10400028   BEQ V0, ZERO, .LVL29
9D023700  02227021   ADDU T6, S1, V0
9D023790  162EFFE2   BNE S1, T6, .LVL16, .LBE28, .LBE26
9D023794  00431021   ADDU V0, V0, V1
9D023798  0B408DEA   J .LVL31
9D02379C  00531023   SUBU V0, V0, S3
273:                    {
274:                       /* Turn ASCII code into letter */
275:                       code = *str++;
9D02371C  26310001   ADDIU S1, S1, 1
9D023720  8223FFFF   LB V1, -1(S1)
276:                       if (code > 0x7F)
277:                          code = 0x7F;
278:                       code -= 32; /* normalize */
9D023724  2463FFE0   ADDIU V1, V1, -32
279:                       gui_putchar(font->character[code].lines, font->height, x_new, y_pos, color);
9D023728  000360C0   SLL T4, V1, 3
9D02372C  01836023   SUBU T4, T4, V1
9D023730  8E4A0000   LW T2, 0(S2)
9D023734  014C5021   ADDU T2, T2, T4
9D023738  25A70004   ADDIU A3, T5, 4
9D02373C  924B0004   LBU T3, 4(S2)
9D023740  0B408DDF   J .LVL27, .LBE33
9D023744  014B5821   ADDU T3, T2, T3
280:                       x_new += font->character[code].spacing;
9D023784  8E430000   LW V1, 0(S2)
9D023788  006C6021   ADDU T4, V1, T4
9D02378C  91830006   LBU V1, 6(T4)
281:                    }
282:                 
283:                    /* Return the length in pixels */
284:                    return (x_new - x_pos);
285:                 }
9D0237A4  00531023   SUBU V0, V0, S3
9D0237A8  8FBF0024   LW RA, 36(SP)
9D0237AC  8FB40020   LW S4, 32(SP)
9D0237B0  8FB3001C   LW S3, 28(SP)
9D0237B4  8FB20018   LW S2, 24(SP)
9D0237B8  8FB10014   LW S1, 20(SP)
9D0237BC  8FB00010   LW S0, 16(SP)
9D0237C0  03E00008   JR RA
9D0237C4  27BD0028   ADDIU SP, SP, 40
286:                 
287:                 /* Draw bar-/button-type text */
288:                 static int gui_textbar(char *str, int x_pos, int y_pos, font_t *font,
289:                                        uint8 color, uint8 bgcolor, bool buttonstate)
290:                 {
9D0237C8  27BDFFB8   ADDIU SP, SP, -72
9D0237CC  AFBF0044   SW RA, 68(SP)
9D0237D0  AFBE0040   SW FP, 64(SP)
9D0237D4  AFB7003C   SW S7, 60(SP)
9D0237D8  AFB60038   SW S6, 56(SP)
9D0237DC  AFB50034   SW S5, 52(SP)
9D0237E0  AFB40030   SW S4, 48(SP)
9D0237E4  AFB3002C   SW S3, 44(SP)
9D0237E8  AFB20028   SW S2, 40(SP)
9D0237EC  AFB10024   SW S1, 36(SP)
9D0237F0  AFB00020   SW S0, 32(SP)
9D0237F4  AFA40048   SW A0, 72(SP)
9D0237F8  00A0B821   ADDU S7, A1, ZERO
9D0237FC  00C0F021   ADDU FP, A2, ZERO
9D023800  AFA70054   SW A3, 84(SP)
9D023804  93B6005C   LBU S6, 92(SP)
291:                    int width = gui_textlen(str, &small);
292:                 
293:                    /* Fill the 'button' */
294:                    gui_buttonrect(x_pos, y_pos, width + 3, font->height + 3, buttonstate);
9D023844  0B408E15   J 0x9D023854
9D023848  26950003   ADDIU S5, S4, 3
9D023850  26950003   ADDIU S5, S4, 3
9D023854  8FA20054   LW V0, 84(SP)
9D023858  90530004   LBU S3, 4(V0)
9D02385C  26630003   ADDIU V1, S3, 3
9D023860  AFA30018   SW V1, 24(SP)
295:                    gui_rectfill(x_pos + 1, y_pos + 1, width + 1, font->height + 1, bgcolor);
9D0238DC  26F50001   ADDIU S5, S7, 1
9D0238E0  26940001   ADDIU S4, S4, 1
9D0238E4  8FA30054   LW V1, 84(SP)
9D0238E8  90710004   LBU S1, 4(V1)
296:                 
297:                    /* Print the text */
298:                    return gui_textout(str, x_pos + 2, y_pos + 2, font, color);
9D023914  93A20058   LBU V0, 88(SP)
9D023918  AFA20010   SW V0, 16(SP)
9D02391C  8FA40048   LW A0, 72(SP)
9D023920  26E50002   ADDIU A1, S7, 2
9D023924  27C60002   ADDIU A2, FP, 2
9D023928  0F408DB2   JAL .LFB20, gui_textout, .LVL14, .LFE13
9D02392C  8FA70054   LW A3, 84(SP)
299:                 }
9D023930  8FBF0044   LW RA, 68(SP)
9D023934  8FBE0040   LW FP, 64(SP)
9D023938  8FB7003C   LW S7, 60(SP)
9D02393C  8FB60038   LW S6, 56(SP)
9D023940  8FB50034   LW S5, 52(SP)
9D023944  8FB40030   LW S4, 48(SP)
9D023948  8FB3002C   LW S3, 44(SP)
9D02394C  8FB20028   LW S2, 40(SP)
9D023950  8FB10024   LW S1, 36(SP)
9D023954  8FB00020   LW S0, 32(SP)
9D023958  03E00008   JR RA
9D02395C  27BD0048   ADDIU SP, SP, 72
300:                 
301:                 /* Draw the mouse pointer */
302:                 static void gui_drawmouse(void)
303:                 {
304:                    int ythresh, xthresh;
305:                    int i, j, color;
306:                 
307:                    ythresh = gui_surface->height - mouse_y - 1;
9D023FEC  8F8C8138   LW T4, -32456(GP)
308:                    for (j = 0; j < CURSOR_HEIGHT; j++)
9D024064  14ABFFEB   BNE A1, T3, .LVL150
309:                    {
310:                       if (ythresh < 0)
9D024014  05420013   BLTZL T2, 0x9D024064
311:                          continue;
312:                 
313:                       xthresh = gui_surface->width - mouse_x - 1;
9D02401C  8D830000   LW V1, 0(T4)
314:                       for (i = 0; i < CURSOR_WIDTH; i++)
9D024010  2406000B   ADDIU A2, ZERO, 11
9D024024  00001021   ADDU V0, ZERO, ZERO
9D024050  24420001   ADDIU V0, V0, 1
315:                       {
316:                          if (xthresh < 0)
9D024028  04600009   BLTZ V1, .LVL156, .LBE91
317:                             continue;
318:                 
319:                          color = cursor[(j * CURSOR_WIDTH) + i];
9D024030  90840000   LBU A0, 0(A0)
320:                 
321:                          if (color)
9D024034  10800006   BEQ A0, ZERO, .LVL156, .LBE91
322:                             gui_putpixel(mouse_x + i, mouse_y + j, cursor_color[color]);
9D024008  3C099D03   LUI T1, -25341
9D024044  00892021   ADDU A0, A0, T1
323:                          xthresh--;
324:                       }
325:                       ythresh--;
9D02405C  254AFFFF   ADDIU T2, T2, -1
9D024060  24A5000B   ADDIU A1, A1, 11
9D024064  14ABFFEB   BNE A1, T3, .LVL150
9D024068  25080004   ADDIU T0, T0, 4
326:                    }
327:                 }
328:                 
329:                 void gui_tick(int ticks)
330:                 {
331:                 
332:                    static int fps_counter = 0;
333:                 
334:                    gui_ticks += ticks;
9D023C94  8F828140   LW V0, -32448(GP)
9D023C98  00441021   ADDU V0, V0, A0
9D023C9C  AF828140   SW V0, -32448(GP)
335:                    fps_counter += ticks;
9D023CA0  8F828134   LW V0, -32460(GP)
9D023CA4  00822021   ADDU A0, A0, V0
9D023CA8  AF848134   SW A0, -32460(GP)
336:                    
337:                    if (fps_counter >= gui_refresh)
9D023CAC  8F828020   LW V0, -32736(GP)
9D023CB0  0082182A   SLT V1, A0, V0
9D023CB4  14600004   BNE V1, ZERO, 0x9D023CC8
9D023CB8  00822023   SUBU A0, A0, V0
338:                    {
339:                       fps_counter -= gui_refresh;
9D023CBC  AF848134   SW A0, -32460(GP)
340:                       gui_fpsupdate = true;
9D023CC0  24020001   ADDIU V0, ZERO, 1
9D023CC4  AF828144   SW V0, -32444(GP)
9D023CC8  03E00008   JR RA
9D023CCC  00000000   NOP
341:                    }
342:                 }
343:                 
344:                 /* updated in sync with the timer interrupt */
345:                 static void gui_tickdec(void)
346:                 {
347:                 #ifdef NOFRENDO_DEBUG
348:                    static int hertz_ticks = 0;
349:                 #endif
350:                    int ticks = gui_ticks;
9D023DB4  8F828140   LW V0, -32448(GP)
351:                 
352:                    if (0 == ticks)
9D023DB8  1040000B   BEQ V0, ZERO, .LBE77
9D023DBC  3C03A001   LUI V1, -24575
353:                       return;
354:                 
355:                    gui_ticks = 0;
9D023DC0  AF808140   SW ZERO, -32448(GP)
356:                 
357:                 #ifdef NOFRENDO_DEBUG
358:                    /* Check for corrupt memory block every 10 seconds */
359:                    hertz_ticks += ticks;
360:                    if (hertz_ticks >= (10 * gui_refresh))
361:                    {
362:                       hertz_ticks -= (10 * gui_refresh);
363:                       mem_checkblocks(); 
364:                    }
365:                 #endif
366:                 
367:                    /* TODO: bleh */
368:                    if (msg.ttl > 0)
9D023DC4  8C63A62C   LW V1, -22996(V1)
9D023DC8  18600007   BLEZ V1, .LBE77
9D023DCC  00621023   SUBU V0, V1, V0
369:                    {
370:                       msg.ttl -= ticks;
9D023DD8  0B408F7A   J .LBE77
9D023DDC  AC62A62C   SW V0, -22996(V1)
371:                       if (msg.ttl < 0)
9D023DD0  04400003   BLTZ V0, .LBB77
9D023DD4  3C03A001   LUI V1, -24575
372:                          msg.ttl = 0;
9D023DE0  3C02A001   LUI V0, -24575
9D023DE4  AC40A62C   SW ZERO, -22996(V0)
373:                    }
374:                 }
375:                 
376:                 /* Update the FPS display */
377:                 static void gui_updatefps(void)
378:                 {
379:                    static char fpsbuf[20];
380:                 
381:                    /* Check to see if we need to do an sprintf or not */
382:                    if (true == gui_fpsupdate)
9D023DF4  24020001   ADDIU V0, ZERO, 1
383:                    {
384:                       sprintf(fpsbuf, "%4d FPS /%4d%%", gui_fps, (gui_fps * 100) / gui_refresh);
9D023E04  8F86813C   LW A2, -32452(GP)
385:                       gui_fps = 0;
9D023E40  AF80813C   SW ZERO, -32452(GP)
386:                       gui_fpsupdate = false;
9D023E44  AF808144   SW ZERO, -32444(GP)
387:                    }
388:                 
389:                    gui_textout(fpsbuf, gui_surface->width - 1 - 90, 1, &small, GUI_GREEN);
9D023E48  8F828138   LW V0, -32456(GP)
390:                 }
391:                 
392:                 /* Turn FPS on/off */
393:                 void gui_togglefps(void)
394:                 {
395:                    option_showfps ^= true;
9D023CD0  8F82815C   LW V0, -32420(GP)
9D023CD4  38420001   XORI V0, V0, 1
9D023CD8  03E00008   JR RA
9D023CDC  AF82815C   SW V0, -32420(GP)
396:                 }
397:                 
398:                 /* Turn GUI on/off */
399:                 void gui_togglegui(void)
400:                 {
401:                    option_showgui ^= true;
9D023CE0  8F828158   LW V0, -32424(GP)
9D023CE4  38420001   XORI V0, V0, 1
9D023CE8  03E00008   JR RA
9D023CEC  AF828158   SW V0, -32424(GP)
402:                 }
403:                 
404:                 void gui_togglewave(void)
405:                 {
406:                    option_wavetype = (option_wavetype + 1) % GUI_NUMWAVESTYLES;
9D023CF0  8F828154   LW V0, -32428(GP)
9D023CF4  24420001   ADDIU V0, V0, 1
9D023CF8  3C035555   LUI V1, 21845
9D023CFC  24635556   ADDIU V1, V1, 21846
9D023D00  00430018   MULT 0, V0, V1
9D023D04  00001810   MFHI V1
9D023D08  000227C3   SRA A0, V0, 31
9D023D0C  00641823   SUBU V1, V1, A0
9D023D10  00032040   SLL A0, V1, 1
9D023D14  00831821   ADDU V1, A0, V1
9D023D18  00431023   SUBU V0, V0, V1
9D023D1C  03E00008   JR RA
9D023D20  AF828154   SW V0, -32428(GP)
407:                 }
408:                 
409:                 void gui_toggleoam(void)
410:                 {
411:                    option_showoam ^= true;
9D023D24  8F82814C   LW V0, -32436(GP)
9D023D28  38420001   XORI V0, V0, 1
9D023D2C  03E00008   JR RA
9D023D30  AF82814C   SW V0, -32436(GP)
412:                 }
413:                 
414:                 /* TODO: hack! */
415:                 void gui_togglepattern(void)
416:                 {
417:                    option_showpattern ^= true;
9D023D34  8F828150   LW V0, -32432(GP)
9D023D38  38420001   XORI V0, V0, 1
9D023D3C  03E00008   JR RA
9D023D40  AF828150   SW V0, -32432(GP)
418:                 }
419:                 
420:                 /* TODO: hack! */
421:                 void gui_decpatterncol(void)
422:                 {
423:                    if (pattern_col && option_showpattern)
9D023D44  8F828148   LW V0, -32440(GP)
9D023D48  10400004   BEQ V0, ZERO, 0x9D023D5C
9D023D4C  8F838150   LW V1, -32432(GP)
9D023D50  10600002   BEQ V1, ZERO, 0x9D023D5C
9D023D54  2442FFFF   ADDIU V0, V0, -1
424:                       pattern_col--;
9D023D58  AF828148   SW V0, -32440(GP)
9D023D5C  03E00008   JR RA
9D023D60  00000000   NOP
425:                 }
426:                 
427:                 /* TODO: hack! */
428:                 void gui_incpatterncol(void)
429:                 {
430:                    if ((pattern_col < 7) && option_showpattern)
9D023D64  8F828148   LW V0, -32440(GP)
9D023D68  28430007   SLTI V1, V0, 7
9D023D6C  10600004   BEQ V1, ZERO, 0x9D023D80
9D023D70  8F838150   LW V1, -32432(GP)
9D023D74  10600002   BEQ V1, ZERO, 0x9D023D80
9D023D78  24420001   ADDIU V0, V0, 1
431:                       pattern_col++;
9D023D7C  AF828148   SW V0, -32440(GP)
9D023D80  03E00008   JR RA
9D023D84  00000000   NOP
432:                 }
433:                 
434:                 /* Downward-scrolling message display */
435:                 static void gui_updatemsg(void)
436:                 {
437:                    if (msg.ttl)
9D023F9C  8C42A62C   LW V0, -22996(V0)
438:                       gui_textbar(msg.text, 2, gui_surface->height - 10, &small, msg.color, GUI_DKGRAY, BUTTON_UP);
9D023FA8  8F828138   LW V0, -32456(GP)
9D023FAC  8C460004   LW A2, 4(V0)
9D023FB0  3C02A001   LUI V0, -24575
9D023FB4  9042A730   LBU V0, -22736(V0)
9D023FB8  AFA20010   SW V0, 16(SP)
9D023FBC  240200C1   ADDIU V0, ZERO, 193
9D023FC0  AFA20014   SW V0, 20(SP)
9D023FC4  AFA00018   SW ZERO, 24(SP)
9D023FC8  3C04A001   LUI A0, -24575
9D023FCC  2484A630   ADDIU A0, A0, -22992
9D023FD0  24050002   ADDIU A1, ZERO, 2
9D023FD4  24C6FFF6   ADDIU A2, A2, -10
9D023FD8  0F408DF2   JAL .LFB21, gui_textbar, .LVL37, .LFE20
9D023FDC  27878028   ADDIU A3, GP, -32728
439:                 }
440:                 
441:                 /* Little thing to display the waveform */
442:                 static void gui_updatewave(int wave_type)
443:                 {
9D023960  27BDFE48   ADDIU SP, SP, -440
9D023964  AFBF01B4   SW RA, 436(SP)
9D023968  AFBE01B0   SW FP, 432(SP)
9D02396C  AFB701AC   SW S7, 428(SP)
9D023970  AFB601A8   SW S6, 424(SP)
9D023974  AFB501A4   SW S5, 420(SP)
9D023978  AFB401A0   SW S4, 416(SP)
9D02397C  AFB3019C   SW S3, 412(SP)
9D023980  AFB20198   SW S2, 408(SP)
9D023984  AFB10194   SW S1, 404(SP)
9D023988  AFB00190   SW S0, 400(SP)
9D02398C  00808021   ADDU S0, A0, ZERO
444:                 #define  WAVEDISP_WIDTH   128
445:                    int loop, xofs, yofs;
446:                    int difference, offset;
447:                    float scale;
448:                    uint8 val, oldval;
449:                    int vis_length = 0;
450:                    void *vis_buffer = NULL;
451:                    int vis_bps;
452:                    apu_t apu;
453:                 
454:                    apu_getcontext(&apu);
9D023990  0F40765D   JAL apu_getcontext
9D023994  27A40020   ADDIU A0, SP, 32
455:                    vis_buffer = apu.buffer;
9D023998  8FB10158   LW S1, 344(SP)
456:                    vis_length = apu.num_samples;
457:                    vis_bps = apu.sample_bits;
9D02399C  8FB20174   LW S2, 372(SP)
458:                 
459:                    xofs = (NES_SCREEN_WIDTH - WAVEDISP_WIDTH);
460:                    yofs = 1;
461:                    scale = (float) (vis_length / (float) WAVEDISP_WIDTH);
9D0239A0  0F40ECB4   JAL sitofp
9D0239A4  8FA4015C   LW A0, 348(SP)
9D0239A8  00402021   ADDU A0, V0, ZERO
9D0239AC  3C029D04   LUI V0, -25340
9D0239B0  0F40D562   JAL __mulsf3
9D0239B4  8C458D5C   LW A1, -29348(V0)
462:                 
463:                    if (NULL == vis_buffer)
9D0239B8  16200013   BNE S1, ZERO, .LVL76
9D0239BC  00409821   ADDU S3, V0, ZERO
464:                    {
465:                       /* draw centerline */
466:                       gui_hline(xofs, yofs + 0x20, WAVEDISP_WIDTH, GUI_GRAY);
9D0239C0  24040080   ADDIU A0, ZERO, 128
9D0239C4  24050021   ADDIU A1, ZERO, 33
9D0239C8  24060080   ADDIU A2, ZERO, 128
9D0239CC  0F408D94   JAL .LFB12, gui_hline, .LVL0, .Ltext0, .Letext0, .LFE31
9D0239D0  240700C2   ADDIU A3, ZERO, 194
467:                       gui_textbar("no sound", xofs + 40, yofs + 0x20 - 4, &small, GUI_RED, GUI_DKGRAY, BUTTON_UP);
9D0239D4  240200C5   ADDIU V0, ZERO, 197
9D0239D8  AFA20010   SW V0, 16(SP)
9D0239DC  240200C1   ADDIU V0, ZERO, 193
9D0239E0  AFA20014   SW V0, 20(SP)
9D0239E4  AFA00018   SW ZERO, 24(SP)
9D0239E8  3C049D04   LUI A0, -25340
9D0239EC  24848C74   ADDIU A0, A0, -29580
9D0239F0  240500A8   ADDIU A1, ZERO, 168
9D0239F4  2406001D   ADDIU A2, ZERO, 29
9D0239F8  0F408DF2   JAL .LFB21, gui_textbar, .LVL37, .LFE20
9D0239FC  27878028   ADDIU A3, GP, -32728
9D023A00  0B408F00   J 0x9D023C00
9D023A04  24040080   ADDIU A0, ZERO, 128
468:                 
469:                    }
470:                    else if (GUI_WAVELINE == wave_type)
9D023A08  24020001   ADDIU V0, ZERO, 1
9D023A0C  16020044   BNE S0, V0, .LVL99
9D023A10  24020002   ADDIU V0, ZERO, 2
471:                    {
472:                       /* draw centerline */
473:                       gui_hline(xofs, yofs + 0x20, WAVEDISP_WIDTH, GUI_GRAY);
9D023A14  24040080   ADDIU A0, ZERO, 128
9D023A18  24050021   ADDIU A1, ZERO, 33
9D023A1C  24060080   ADDIU A2, ZERO, 128
9D023A20  0F408D94   JAL .LFB12, gui_hline, .LVL0, .Ltext0, .Letext0, .LFE31
9D023A24  240700C2   ADDIU A3, ZERO, 194
474:                 
475:                       /* initial old value */
476:                       if (16 == vis_bps)
9D023A28  24020010   ADDIU V0, ZERO, 16
9D023A2C  56420008   BNEL S2, V0, .LVL79
9D023A30  92220000   LBU V0, 0(S1)
477:                          oldval = 0x40 - (((((uint16 *) vis_buffer)[0] >> 8) ^ 0x80) >> 2);
9D023A34  96220000   LHU V0, 0(S1)
9D023A38  38428000   XORI V0, V0, -32768
9D023A3C  00021282   SRL V0, V0, 10
9D023A40  24150040   ADDIU S5, ZERO, 64
9D023A44  02A2A823   SUBU S5, S5, V0
9D023A48  0B408F15   J .LVL124
9D023A4C  32B500FF   ANDI S5, S5, 255
478:                       else
479:                          oldval = 0x40 - (((uint8 *) vis_buffer)[0] >> 2);
9D023A50  00021082   SRL V0, V0, 2
9D023A54  24150040   ADDIU S5, ZERO, 64
9D023A58  02A2A823   SUBU S5, S5, V0
9D023A5C  0B408F15   J .LVL124
9D023A60  32B500FF   ANDI S5, S5, 255
480:                 
481:                       for (loop = 1; loop < WAVEDISP_WIDTH; loop++)
9D023B0C  26100001   ADDIU S0, S0, 1
9D023B10  1616FFD4   BNE S0, S6, .LVL81
9D023B14  0280A821   ADDU S5, S4, ZERO
9D023B18  0B408F00   J 0x9D023C00
9D023B1C  24040080   ADDIU A0, ZERO, 128
9D023C60  0B408E99   J .LVL81
9D023C64  24160080   ADDIU S6, ZERO, 128
482:                       {
483:                          //val = 0x40 - (vis_buffer[(uint32) (loop * scale)] >> 2);
484:                          if (16 == vis_bps)
9D023A64  165E0010   BNE S2, FP, .LVL86
9D023A68  00000000   NOP
9D023C58  241E0010   ADDIU FP, ZERO, 16
485:                             val = 0x40 - (((((uint16 *) vis_buffer)[(uint32) (loop * scale)] >> 8) ^ 0x80) >> 2);
9D023A6C  0F40ECB4   JAL sitofp
9D023A70  02002021   ADDU A0, S0, ZERO
9D023A74  00402021   ADDU A0, V0, ZERO
9D023A78  0F40D562   JAL __mulsf3
9D023A7C  02602821   ADDU A1, S3, ZERO
9D023A80  0F40EAA9   JAL fptoui
9D023A84  00402021   ADDU A0, V0, ZERO
9D023A88  00021040   SLL V0, V0, 1
9D023A8C  02221021   ADDU V0, S1, V0
9D023A90  94540000   LHU S4, 0(V0)
9D023A94  3A948000   XORI S4, S4, -32768
9D023A98  0014A282   SRL S4, S4, 10
9D023A9C  02F4A023   SUBU S4, S7, S4
9D023AA0  0B408EB6   J .LVL90
9D023AA4  329400FF   ANDI S4, S4, 255
486:                          else
487:                             val = 0x40 - (((uint8 *) vis_buffer)[(uint32) (loop * scale)] >> 2);
9D023AA8  0F40ECB4   JAL sitofp
9D023AAC  02002021   ADDU A0, S0, ZERO
9D023AB0  00402021   ADDU A0, V0, ZERO
9D023AB4  0F40D562   JAL __mulsf3
9D023AB8  02602821   ADDU A1, S3, ZERO
9D023ABC  0F40EAA9   JAL fptoui
9D023AC0  00402021   ADDU A0, V0, ZERO
9D023AC4  02221021   ADDU V0, S1, V0
9D023AC8  90540000   LBU S4, 0(V0)
9D023ACC  0014A082   SRL S4, S4, 2
9D023AD0  02F4A023   SUBU S4, S7, S4
9D023AD4  329400FF   ANDI S4, S4, 255
9D023C5C  24170040   ADDIU S7, ZERO, 64
488:                          if (oldval < val)
9D023AD8  02B4102B   SLTU V0, S5, S4
9D023ADC  50400005   BEQL V0, ZERO, .LVL93
9D023AE0  02802821   ADDU A1, S4, ZERO
489:                          {
490:                             offset = oldval;
9D023AE4  02A02821   ADDU A1, S5, ZERO
491:                             difference = (val - oldval) + 1;
9D023AE8  0295A823   SUBU S5, S4, S5
9D023AEC  0B408EBF   J .LVL95
9D023AF0  26A60001   ADDIU A2, S5, 1
492:                          }
493:                          else
494:                          {
495:                             offset = val;
496:                             difference = (oldval - val) + 1;
9D023AF4  02B4A823   SUBU S5, S5, S4
9D023AF8  26A60001   ADDIU A2, S5, 1
497:                          }
498:                 
499:                          gui_vline(xofs + loop, yofs + offset, difference, GUI_GREEN);
9D023AFC  26040080   ADDIU A0, S0, 128
9D023B00  24A50001   ADDIU A1, A1, 1
9D023B04  0F408DA2   JAL .LFB13, gui_vline, .LVL8, .LFE12
9D023B08  240700C6   ADDIU A3, ZERO, 198
500:                          oldval = val;
9D023C54  24100001   ADDIU S0, ZERO, 1
501:                       }
502:                    }
503:                    /* solid wave */
504:                    else if (GUI_WAVESOLID == wave_type)
9D023B20  56020037   BNEL S0, V0, 0x9D023C00
9D023B24  24040080   ADDIU A0, ZERO, 128
9D023B28  24100080   ADDIU S0, ZERO, 128
505:                    {
506:                       for (loop = 0; loop < WAVEDISP_WIDTH; loop++)
9D023B3C  24150100   ADDIU S5, ZERO, 256
9D023BF4  1615FFD2   BNE S0, S5, .LVL101
9D023BF8  00000000   NOP
507:                       {
508:                          //val = vis_buffer[(uint32) (loop * scale)] >> 2;
509:                          if (16 == vis_bps)
9D023B2C  24160010   ADDIU S6, ZERO, 16
9D023B40  1656000E   BNE S2, S6, .LVL106
9D023B44  2604FF80   ADDIU A0, S0, -128
510:                             val = ((((uint16 *) vis_buffer)[(uint32) (loop * scale)] >> 8) ^ 0x80) >> 2;
9D023B48  0F40ECB4   JAL sitofp
9D023B4C  00000000   NOP
9D023B50  00402021   ADDU A0, V0, ZERO
9D023B54  0F40D562   JAL __mulsf3
9D023B58  02602821   ADDU A1, S3, ZERO
9D023B5C  0F40EAA9   JAL fptoui
9D023B60  00402021   ADDU A0, V0, ZERO
9D023B64  00021040   SLL V0, V0, 1
9D023B68  02221021   ADDU V0, S1, V0
9D023B6C  94460000   LHU A2, 0(V0)
9D023B70  38C68000   XORI A2, A2, -32768
9D023B74  0B408EE9   J .LVL110
9D023B78  00063282   SRL A2, A2, 10
511:                          else
512:                             val = ((uint8 *) vis_buffer)[(uint32) (loop * scale)] >> 2;
9D023B7C  0F40ECB4   JAL sitofp
9D023B80  00000000   NOP
9D023B84  00402021   ADDU A0, V0, ZERO
9D023B88  0F40D562   JAL __mulsf3
9D023B8C  02602821   ADDU A1, S3, ZERO
9D023B90  0F40EAA9   JAL fptoui
9D023B94  00402021   ADDU A0, V0, ZERO
9D023B98  02221021   ADDU V0, S1, V0
9D023B9C  90460000   LBU A2, 0(V0)
9D023BA0  00063082   SRL A2, A2, 2
513:                          if (val == 0x20)
9D023B30  24140020   ADDIU S4, ZERO, 32
9D023BA4  14D40006   BNE A2, S4, .LVL112
9D023BA8  2CC20020   SLTIU V0, A2, 32
514:                             gui_putpixel(xofs + loop, yofs + 0x20, GUI_GREEN);
515:                          else if (val < 0x20)
9D023BC0  10400007   BEQ V0, ZERO, .LVL115
9D023BC4  02002021   ADDU A0, S0, ZERO
516:                             gui_vline(xofs + loop, yofs + 0x20, 0x20 - val, GUI_GREEN);
9D023BC8  24050021   ADDIU A1, ZERO, 33
9D023BCC  02863023   SUBU A2, S4, A2
9D023BD0  0F408DA2   JAL .LFB13, gui_vline, .LVL8, .LFE12
9D023BD4  240700C6   ADDIU A3, ZERO, 198
9D023BD8  0B408EFD   J .LVL118
9D023BDC  26100001   ADDIU S0, S0, 1
517:                          else
518:                             gui_vline(xofs + loop, yofs + 0x20 - (val - 0x20), val - 0x20,
9D023B34  24170041   ADDIU S7, ZERO, 65
9D023BE0  02E62823   SUBU A1, S7, A2
9D023BE4  24C6FFE0   ADDIU A2, A2, -32
9D023BE8  0F408DA2   JAL .LFB13, gui_vline, .LVL8, .LFE12
9D023BEC  240700C6   ADDIU A3, ZERO, 198
9D023BF0  26100001   ADDIU S0, S0, 1
519:                                       GUI_GREEN);
520:                       }
521:                    }
522:                 
523:                    gui_rect(xofs, yofs - 1, WAVEDISP_WIDTH, 66, GUI_DKGRAY);
524:                 }
9D023C4C  0B408F1A   J .LVL126
9D023C50  8FBF01B4   LW RA, 436(SP)
9D023C68  8FBE01B0   LW FP, 432(SP)
9D023C6C  8FB701AC   LW S7, 428(SP)
9D023C70  8FB601A8   LW S6, 424(SP)
9D023C74  8FB501A4   LW S5, 420(SP)
9D023C78  8FB401A0   LW S4, 416(SP)
9D023C7C  8FB3019C   LW S3, 412(SP)
9D023C80  8FB20198   LW S2, 408(SP)
9D023C84  8FB10194   LW S1, 404(SP)
9D023C88  8FB00190   LW S0, 400(SP)
9D023C8C  03E00008   JR RA
9D023C90  27BD01B8   ADDIU SP, SP, 440
525:                 
526:                 
527:                 static void gui_updatepattern(void)
528:                 {
529:                    /* Pretty it up a bit */
530:                    gui_textbar("Pattern Table 0", 0, 0, &small, GUI_GREEN, GUI_DKGRAY, BUTTON_UP);
9D023E90  241100C6   ADDIU S1, ZERO, 198
531:                    gui_textbar("Pattern Table 1", 128, 0, &small, GUI_GREEN, GUI_DKGRAY, BUTTON_UP);
9D023EBC  AFB10010   SW S1, 16(SP)
532:                    gui_hline(0, 9, 256, GUI_DKGRAY);
9D023EE0  00002021   ADDU A0, ZERO, ZERO
533:                    gui_hline(0, 138, 256, GUI_DKGRAY);
9D023EF4  00002021   ADDU A0, ZERO, ZERO
534:                 
535:                    /* Dump the actual tables */
536:                    ppu_dumppattern(gui_surface, 0, 0, 10, pattern_col);
9D023F08  8F828148   LW V0, -32440(GP)
537:                    ppu_dumppattern(gui_surface, 1, 128, 10, pattern_col);
9D023F24  8F828148   LW V0, -32440(GP)
9D023F28  AFA20010   SW V0, 16(SP)
9D023F2C  8F848138   LW A0, -32456(GP)
9D023F30  24050001   ADDIU A1, ZERO, 1
9D023F34  24060080   ADDIU A2, ZERO, 128
9D023F38  0F4067CE   JAL ppu_dumppattern
9D023F3C  2407000A   ADDIU A3, ZERO, 10
538:                 }
539:                 
540:                 static void gui_updateoam(void)
541:                 {
542:                    int y;
543:                 
544:                    y = option_showpattern ? 140 : 0;
9D023F4C  2402008C   ADDIU V0, ZERO, 140
545:                    gui_textbar("Current OAM", 0, y, &small, GUI_GREEN, GUI_DKGRAY, BUTTON_UP);
9D023F5C  240200C6   ADDIU V0, ZERO, 198
546:                    ppu_dumpoam(gui_surface, 0, y + 9);
9D023F88  8F848138   LW A0, -32456(GP)
9D023F8C  00002821   ADDU A1, ZERO, ZERO
9D023F90  0F4066F7   JAL ppu_dumpoam
9D023F94  26060009   ADDIU A2, S0, 9
547:                 }
548:                 
549:                 
550:                 /* The GUI overlay */
551:                 void gui_frame(bool draw)
552:                 {
9D023D88  27BDFFD0   ADDIU SP, SP, -48
9D023D8C  AFBF002C   SW RA, 44(SP)
9D023D90  AFB10028   SW S1, 40(SP)
9D023D94  AFB00024   SW S0, 36(SP)
553:                    gui_fps++;
9D023D98  8F82813C   LW V0, -32452(GP)
9D023D9C  24420001   ADDIU V0, V0, 1
554:                    if (false == draw)
9D023DA0  108000B2   BEQ A0, ZERO, .LVL159, .LBE87, .LBE86
9D023DA4  AF82813C   SW V0, -32452(GP)
555:                       return;
556:                 
557:                    gui_surface = vid_getbuffer();
9D023DA8  0F40B89E   JAL vid_getbuffer
9D023DAC  00000000   NOP
9D023DB0  AF828138   SW V0, -32456(GP)
558:                 
559:                    ASSERT(gui_surface);
560:                 
561:                    gui_tickdec();
562:                 
563:                    if (option_showfps)
9D023DE8  8F82815C   LW V0, -32420(GP)
9D023DEC  10400021   BEQ V0, ZERO, 0x9D023E74
9D023DF0  8F848154   LW A0, -32428(GP)
564:                       gui_updatefps();
565:                 
566:                    if (option_wavetype != GUI_WAVENONE)
9D023E70  8F848154   LW A0, -32428(GP)
9D023E74  10800004   BEQ A0, ZERO, 0x9D023E88
9D023E78  8F828150   LW V0, -32432(GP)
567:                       gui_updatewave(option_wavetype);
9D023E7C  0F408E58   JAL .LFB34, gui_updatewave, .LVL67, .LFE21
9D023E80  00000000   NOP
568:                 
569:                    if (option_showpattern)
9D023E84  8F828150   LW V0, -32432(GP)
9D023E88  1040002E   BEQ V0, ZERO, 0x9D023F44
9D023E8C  8F82814C   LW V0, -32436(GP)
570:                       gui_updatepattern();
571:                 
572:                    if (option_showoam)
9D023F40  8F82814C   LW V0, -32436(GP)
9D023F44  10400015   BEQ V0, ZERO, .LBB84
9D023F48  3C02A001   LUI V0, -24575
573:                       gui_updateoam();
574:                 
575:                    if (msg.ttl)
9D023F98  3C02A001   LUI V0, -24575
576:                       gui_updatemsg();
577:                 
578:                    if (option_showgui)
9D023FE0  8F828158   LW V0, -32424(GP)
9D023FE4  10400022   BEQ V0, ZERO, 0x9D024070
9D023FE8  8FBF002C   LW RA, 44(SP)
579:                    {
580:                       //osd_getmouse(&mouse_x, &mouse_y, &mouse_button);
581:                       gui_drawmouse();
582:                    }
583:                 }
9D02406C  8FBF002C   LW RA, 44(SP)
9D024070  8FB10028   LW S1, 40(SP)
9D024074  8FB00024   LW S0, 36(SP)
9D024078  03E00008   JR RA
9D02407C  27BD0030   ADDIU SP, SP, 48
584:                 
585:                 void gui_sendmsg(int color, char *format, ...)
586:                 {
9D024080  27BDFFE0   ADDIU SP, SP, -32
9D024084  AFBF001C   SW RA, 28(SP)
9D024088  AFB00018   SW S0, 24(SP)
9D02408C  00808021   ADDU S0, A0, ZERO
9D024090  AFA60028   SW A2, 40(SP)
9D024094  AFA7002C   SW A3, 44(SP)
587:                    va_list arg;
588:                    va_start(arg, format);
9D024098  27A60028   ADDIU A2, SP, 40
9D02409C  AFA60010   SW A2, 16(SP)
589:                    vsprintf(msg.text, format, arg);
9D0240A0  3C04A001   LUI A0, -24575
9D0240A4  0F40ED28   JAL vsprintf
9D0240A8  2484A630   ADDIU A0, A0, -22992
590:                 
591:                 #ifdef NOFRENDO_DEBUG
592:                    log_print("GUI: ");
593:                    log_print(msg.text);
594:                    log_print("\n");
595:                 #endif
596:                 
597:                    va_end(arg);
598:                 
599:                    msg.ttl = gui_refresh * 2; /* 2 second delay */
9D0240AC  3C02A001   LUI V0, -24575
9D0240B0  8F838020   LW V1, -32736(GP)
9D0240B4  00031840   SLL V1, V1, 1
9D0240B8  AC43A62C   SW V1, -22996(V0)
600:                    msg.color = color;
9D0240BC  2442A62C   ADDIU V0, V0, -22996
9D0240C0  A0500104   SB S0, 260(V0)
601:                 }
9D0240C4  8FBF001C   LW RA, 28(SP)
9D0240C8  8FB00018   LW S0, 24(SP)
9D0240CC  03E00008   JR RA
9D0240D0  27BD0020   ADDIU SP, SP, 32
602:                 
603:                 void gui_setrefresh(int frequency)
604:                 {
605:                    gui_refresh = frequency;
9D024354  03E00008   JR RA
9D024358  AF848020   SW A0, -32736(GP)
606:                 }
607:                 
608:                 int gui_init(void)
609:                 {
9D02435C  27BDFFE8   ADDIU SP, SP, -24
9D024360  AFBF0014   SW RA, 20(SP)
610:                    gui_refresh = 60;
9D024364  2402003C   ADDIU V0, ZERO, 60
9D024368  AF828020   SW V0, -32736(GP)
611:                    memset(&msg, 0, sizeof(message_t));
9D02436C  3C04A001   LUI A0, -24575
9D024370  2484A62C   ADDIU A0, A0, -22996
9D024374  00002821   ADDU A1, ZERO, ZERO
9D024378  0F40E7C9   JAL .Letext0, .LFE0, memset
9D02437C  24060108   ADDIU A2, ZERO, 264
612:                 
613:                    return 0; /* can't fail */
614:                 }
9D024380  00001021   ADDU V0, ZERO, ZERO
9D024384  8FBF0014   LW RA, 20(SP)
9D024388  03E00008   JR RA
9D02438C  27BD0018   ADDIU SP, SP, 24
615:                 
616:                 void gui_shutdown(void)
617:                 {
9D024390  03E00008   JR RA
618:                 }
619:                 
620:                 /*
621:                 ** $Log: gui.c,v $
622:                 ** Revision 1.2  2001/04/27 14:37:11  neil
623:                 ** wheeee
624:                 **
625:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
626:                 ** initial
627:                 **
628:                 ** Revision 1.26  2000/11/25 20:26:05  matt
629:                 ** removed fds "system"
630:                 **
631:                 ** Revision 1.25  2000/11/09 14:05:43  matt
632:                 ** state load fixed, state save mostly fixed
633:                 **
634:                 ** Revision 1.24  2000/11/05 16:37:18  matt
635:                 ** rolled rgb.h into bitmap.h
636:                 **
637:                 ** Revision 1.23  2000/10/27 12:57:49  matt
638:                 ** fixed pcx snapshots
639:                 **
640:                 ** Revision 1.22  2000/10/25 00:23:16  matt
641:                 ** makefiles updated for new directory structure
642:                 **
643:                 ** Revision 1.21  2000/10/23 17:50:47  matt
644:                 ** adding fds support
645:                 **
646:                 ** Revision 1.20  2000/10/23 15:52:04  matt
647:                 ** better system handling
648:                 **
649:                 ** Revision 1.19  2000/10/22 19:15:39  matt
650:                 ** more sane timer ISR / autoframeskip
651:                 **
652:                 ** Revision 1.18  2000/10/17 03:22:37  matt
653:                 ** cleaning up rom module
654:                 **
655:                 ** Revision 1.17  2000/10/10 13:58:13  matt
656:                 ** stroustrup squeezing his way in the door
657:                 **
658:                 ** Revision 1.16  2000/10/10 13:03:53  matt
659:                 ** Mr. Clean makes a guest appearance
660:                 **
661:                 ** Revision 1.15  2000/10/08 17:59:12  matt
662:                 ** gui_ticks is volatile
663:                 **
664:                 ** Revision 1.14  2000/09/15 04:58:06  matt
665:                 ** simplifying and optimizing APU core
666:                 **
667:                 ** Revision 1.13  2000/07/31 04:28:46  matt
668:                 ** one million cleanups
669:                 **
670:                 ** Revision 1.12  2000/07/30 04:29:59  matt
671:                 ** no more apu_getpcmdata hack
672:                 **
673:                 ** Revision 1.11  2000/07/25 02:20:47  matt
674:                 ** moved gui palette filth here, for the time being
675:                 **
676:                 ** Revision 1.10  2000/07/24 04:32:05  matt
677:                 ** bugfix on message delay
678:                 **
679:                 ** Revision 1.9  2000/07/23 15:16:25  matt
680:                 ** moved non-osd code here
681:                 **
682:                 ** Revision 1.8  2000/07/17 01:52:27  matt
683:                 ** made sure last line of all source files is a newline
684:                 **
685:                 ** Revision 1.7  2000/07/11 04:40:23  matt
686:                 ** updated for new screen dimension defines
687:                 **
688:                 ** Revision 1.6  2000/07/09 03:39:33  matt
689:                 ** small gui_frame cleanup
690:                 **
691:                 ** Revision 1.5  2000/07/06 16:47:18  matt
692:                 ** new video driver interface
693:                 **
694:                 ** Revision 1.4  2000/06/09 15:12:25  matt
695:                 ** initial revision
696:                 **
697:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/event.c  -----------------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** event.c
21:                  **
22:                  ** OS-independent event handling
23:                  ** $Id: event.c,v 1.3 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <stdlib.h>
27:                  #include <noftypes.h>
28:                  #include <event.h>
29:                  #include <nofrendo.h>
30:                  #include <gui.h>
31:                  #include <osd.h>
32:                  
33:                  /* TODO: put system specific stuff in their own files... */
34:                  #include <nes.h>
35:                  #include <nesinput.h>
36:                  #include <nes_pal.h>
37:                  #include <nesstate.h>
38:                  
39:                  /* pointer to our current system's event handler table */
40:                  static event_t *system_events = NULL;
41:                  
42:                  /* standard keyboard input */
43:                  static nesinput_t kb_input = { INP_JOYPAD0, 0 };
44:                  static nesinput_t kb_alt_input = { INP_JOYPAD1, 0 };
45:                  
46:                  static void func_event_quit(int code)
47:                  {
9D0273E8  27BDFFE8   ADDIU SP, SP, -24
9D0273EC  AFBF0014   SW RA, 20(SP)
48:                     UNUSED(code);
49:                     main_quit();
9D0273F0  0F40CBEA   JAL main_quit
9D0273F4  00000000   NOP
50:                  }
9D0273F8  8FBF0014   LW RA, 20(SP)
9D0273FC  03E00008   JR RA
9D027400  27BD0018   ADDIU SP, SP, 24
51:                  
52:                  static void func_event_insert(int code)
53:                  {
9D026950  03E00008   JR RA
9D026954  00000000   NOP
54:                     UNUSED(code);
55:                     /* TODO: after the GUI */
56:                  }
57:                  
58:                  static void func_event_eject(int code)
59:                  {
9D0273C8  27BDFFE8   ADDIU SP, SP, -24
9D0273CC  AFBF0014   SW RA, 20(SP)
60:                     if (INP_STATE_MAKE == code)
9D0273BC  24020001   ADDIU V0, ZERO, 1
9D0273C0  14820007   BNE A0, V0, 0x9D0273E0
9D0273C4  00000000   NOP
61:                        main_eject();
9D0273D0  0F40CBD0   JAL main_eject
9D0273D4  00000000   NOP
62:                  }
9D0273D8  8FBF0014   LW RA, 20(SP)
9D0273DC  27BD0018   ADDIU SP, SP, 24
9D0273E0  03E00008   JR RA
9D0273E4  00000000   NOP
63:                  
64:                  static void func_event_togglepause(int code)
65:                  {
9D02739C  27BDFFE8   ADDIU SP, SP, -24
9D0273A0  AFBF0014   SW RA, 20(SP)
66:                     if (INP_STATE_MAKE == code)
9D027390  24020001   ADDIU V0, ZERO, 1
9D027394  14820007   BNE A0, V0, 0x9D0273B4
9D027398  00000000   NOP
67:                        nes_togglepause();
9D0273A4  0F408BCF   JAL nes_togglepause
9D0273A8  00000000   NOP
68:                  }
9D0273AC  8FBF0014   LW RA, 20(SP)
9D0273B0  27BD0018   ADDIU SP, SP, 24
9D0273B4  03E00008   JR RA
9D0273B8  00000000   NOP
69:                  
70:                  static void func_event_soft_reset(int code)
71:                  {
9D027370  27BDFFE8   ADDIU SP, SP, -24
9D027374  AFBF0014   SW RA, 20(SP)
72:                     if (INP_STATE_MAKE == code) 
9D027364  24020001   ADDIU V0, ZERO, 1
9D027368  14820007   BNE A0, V0, 0x9D027388
9D02736C  00000000   NOP
73:                        nes_reset(SOFT_RESET);
9D027378  0F408B62   JAL nes_reset
9D02737C  00002021   ADDU A0, ZERO, ZERO
74:                  }
9D027380  8FBF0014   LW RA, 20(SP)
9D027384  27BD0018   ADDIU SP, SP, 24
9D027388  03E00008   JR RA
9D02738C  00000000   NOP
75:                  
76:                  static void func_event_hard_reset(int code)
77:                  {
9D027344  27BDFFE8   ADDIU SP, SP, -24
9D027348  AFBF0014   SW RA, 20(SP)
78:                     if (INP_STATE_MAKE == code)
9D027338  24020001   ADDIU V0, ZERO, 1
9D02733C  14820007   BNE A0, V0, 0x9D02735C
9D027340  00000000   NOP
79:                        nes_reset(HARD_RESET);
9D02734C  0F408B62   JAL nes_reset
9D027350  24040001   ADDIU A0, ZERO, 1
80:                  }
9D027354  8FBF0014   LW RA, 20(SP)
9D027358  27BD0018   ADDIU SP, SP, 24
9D02735C  03E00008   JR RA
9D027360  00000000   NOP
81:                  
82:                  static void func_event_snapshot(int code)
83:                  {
9D027318  27BDFFE8   ADDIU SP, SP, -24
9D02731C  AFBF0014   SW RA, 20(SP)
84:                     if (INP_STATE_MAKE == code)
9D02730C  24020001   ADDIU V0, ZERO, 1
9D027310  14820007   BNE A0, V0, 0x9D027330
9D027314  00000000   NOP
85:                        gui_savesnap();
9D027320  0F409035   JAL gui_savesnap
9D027324  00000000   NOP
86:                  }
9D027328  8FBF0014   LW RA, 20(SP)
9D02732C  27BD0018   ADDIU SP, SP, 24
9D027330  03E00008   JR RA
9D027334  00000000   NOP
87:                  
88:                  static void func_event_toggle_frameskip(int code)
89:                  {
9D0272EC  27BDFFE8   ADDIU SP, SP, -24
9D0272F0  AFBF0014   SW RA, 20(SP)
90:                     if (INP_STATE_MAKE == code)
9D0272E0  24020001   ADDIU V0, ZERO, 1
9D0272E4  14820007   BNE A0, V0, 0x9D027304
9D0272E8  00000000   NOP
91:                        gui_togglefs();
9D0272F4  0F40905F   JAL gui_togglefs
9D0272F8  00000000   NOP
92:                  }
9D0272FC  8FBF0014   LW RA, 20(SP)
9D027300  27BD0018   ADDIU SP, SP, 24
9D027304  03E00008   JR RA
9D027308  00000000   NOP
93:                  
94:                  static void func_event_state_save(int code)
95:                  {
9D0272C0  27BDFFE8   ADDIU SP, SP, -24
9D0272C4  AFBF0014   SW RA, 20(SP)
96:                     if (INP_STATE_MAKE == code)
9D0272B4  24020001   ADDIU V0, ZERO, 1
9D0272B8  14820007   BNE A0, V0, 0x9D0272D8
9D0272BC  00000000   NOP
97:                        state_save();
9D0272C8  0F409443   JAL state_save
9D0272CC  00000000   NOP
98:                  }
9D0272D0  8FBF0014   LW RA, 20(SP)
9D0272D4  27BD0018   ADDIU SP, SP, 24
9D0272D8  03E00008   JR RA
9D0272DC  00000000   NOP
99:                  
100:                 static void func_event_state_load(int code)
101:                 {
9D027294  27BDFFE8   ADDIU SP, SP, -24
9D027298  AFBF0014   SW RA, 20(SP)
102:                    if (INP_STATE_MAKE == code)
9D027288  24020001   ADDIU V0, ZERO, 1
9D02728C  14820007   BNE A0, V0, 0x9D0272AC
9D027290  00000000   NOP
103:                       state_load();
9D02729C  0F4095D7   JAL state_load
9D0272A0  00000000   NOP
104:                 }
9D0272A4  8FBF0014   LW RA, 20(SP)
9D0272A8  27BD0018   ADDIU SP, SP, 24
9D0272AC  03E00008   JR RA
9D0272B0  00000000   NOP
105:                 
106:                 static void func_event_state_slot_0(int code)
107:                 {
9D027268  27BDFFE8   ADDIU SP, SP, -24
9D02726C  AFBF0014   SW RA, 20(SP)
108:                    if (INP_STATE_MAKE == code)
9D02725C  24020001   ADDIU V0, ZERO, 1
9D027260  14820007   BNE A0, V0, 0x9D027280
9D027264  00000000   NOP
109:                       state_setslot(0);
9D027270  0F409433   JAL state_setslot
9D027274  00002021   ADDU A0, ZERO, ZERO
110:                 }
9D027278  8FBF0014   LW RA, 20(SP)
9D02727C  27BD0018   ADDIU SP, SP, 24
9D027280  03E00008   JR RA
9D027284  00000000   NOP
111:                 
112:                 static void func_event_state_slot_1(int code)
113:                 {
9D02723C  27BDFFE8   ADDIU SP, SP, -24
9D027240  AFBF0014   SW RA, 20(SP)
114:                    if (INP_STATE_MAKE == code) 
9D027230  24020001   ADDIU V0, ZERO, 1
9D027234  14820007   BNE A0, V0, 0x9D027254
9D027238  00000000   NOP
115:                       state_setslot(1);
9D027244  0F409433   JAL state_setslot
9D027248  24040001   ADDIU A0, ZERO, 1
116:                 }
9D02724C  8FBF0014   LW RA, 20(SP)
9D027250  27BD0018   ADDIU SP, SP, 24
9D027254  03E00008   JR RA
9D027258  00000000   NOP
117:                 
118:                 static void func_event_state_slot_2(int code)
119:                 {
9D027210  27BDFFE8   ADDIU SP, SP, -24
9D027214  AFBF0014   SW RA, 20(SP)
120:                    if (INP_STATE_MAKE == code) 
9D027204  24020001   ADDIU V0, ZERO, 1
9D027208  14820007   BNE A0, V0, 0x9D027228
9D02720C  00000000   NOP
121:                       state_setslot(2);
9D027218  0F409433   JAL state_setslot
9D02721C  24040002   ADDIU A0, ZERO, 2
122:                 }
9D027220  8FBF0014   LW RA, 20(SP)
9D027224  27BD0018   ADDIU SP, SP, 24
9D027228  03E00008   JR RA
9D02722C  00000000   NOP
123:                 
124:                 static void func_event_state_slot_3(int code)
125:                 {
9D0271E4  27BDFFE8   ADDIU SP, SP, -24
9D0271E8  AFBF0014   SW RA, 20(SP)
126:                    if (INP_STATE_MAKE == code)
9D0271D8  24020001   ADDIU V0, ZERO, 1
9D0271DC  14820007   BNE A0, V0, 0x9D0271FC
9D0271E0  00000000   NOP
127:                       state_setslot(3);
9D0271EC  0F409433   JAL state_setslot
9D0271F0  24040003   ADDIU A0, ZERO, 3
128:                 }
9D0271F4  8FBF0014   LW RA, 20(SP)
9D0271F8  27BD0018   ADDIU SP, SP, 24
9D0271FC  03E00008   JR RA
9D027200  00000000   NOP
129:                 
130:                 static void func_event_state_slot_4(int code)
131:                 {
9D0271B8  27BDFFE8   ADDIU SP, SP, -24
9D0271BC  AFBF0014   SW RA, 20(SP)
132:                    if (INP_STATE_MAKE == code)
9D0271AC  24020001   ADDIU V0, ZERO, 1
9D0271B0  14820007   BNE A0, V0, 0x9D0271D0
9D0271B4  00000000   NOP
133:                       state_setslot(4);
9D0271C0  0F409433   JAL state_setslot
9D0271C4  24040004   ADDIU A0, ZERO, 4
134:                 }
9D0271C8  8FBF0014   LW RA, 20(SP)
9D0271CC  27BD0018   ADDIU SP, SP, 24
9D0271D0  03E00008   JR RA
9D0271D4  00000000   NOP
135:                 
136:                 static void func_event_state_slot_5(int code)
137:                 {
9D02718C  27BDFFE8   ADDIU SP, SP, -24
9D027190  AFBF0014   SW RA, 20(SP)
138:                    if (INP_STATE_MAKE == code) 
9D027180  24020001   ADDIU V0, ZERO, 1
9D027184  14820007   BNE A0, V0, 0x9D0271A4
9D027188  00000000   NOP
139:                       state_setslot(5);
9D027194  0F409433   JAL state_setslot
9D027198  24040005   ADDIU A0, ZERO, 5
140:                 }
9D02719C  8FBF0014   LW RA, 20(SP)
9D0271A0  27BD0018   ADDIU SP, SP, 24
9D0271A4  03E00008   JR RA
9D0271A8  00000000   NOP
141:                 
142:                 static void func_event_state_slot_6(int code)
143:                 {
9D027160  27BDFFE8   ADDIU SP, SP, -24
9D027164  AFBF0014   SW RA, 20(SP)
144:                    if (INP_STATE_MAKE == code) 
9D027154  24020001   ADDIU V0, ZERO, 1
9D027158  14820007   BNE A0, V0, 0x9D027178
9D02715C  00000000   NOP
145:                       state_setslot(6);
9D027168  0F409433   JAL state_setslot
9D02716C  24040006   ADDIU A0, ZERO, 6
146:                 }
9D027170  8FBF0014   LW RA, 20(SP)
9D027174  27BD0018   ADDIU SP, SP, 24
9D027178  03E00008   JR RA
9D02717C  00000000   NOP
147:                 
148:                 static void func_event_state_slot_7(int code)
149:                 {
9D027134  27BDFFE8   ADDIU SP, SP, -24
9D027138  AFBF0014   SW RA, 20(SP)
150:                    if (INP_STATE_MAKE == code) 
9D027128  24020001   ADDIU V0, ZERO, 1
9D02712C  14820007   BNE A0, V0, 0x9D02714C
9D027130  00000000   NOP
151:                       state_setslot(7);
9D02713C  0F409433   JAL state_setslot
9D027140  24040007   ADDIU A0, ZERO, 7
152:                 }
9D027144  8FBF0014   LW RA, 20(SP)
9D027148  27BD0018   ADDIU SP, SP, 24
9D02714C  03E00008   JR RA
9D027150  00000000   NOP
153:                 
154:                 static void func_event_state_slot_8(int code)
155:                 {
9D027108  27BDFFE8   ADDIU SP, SP, -24
9D02710C  AFBF0014   SW RA, 20(SP)
156:                    if (INP_STATE_MAKE == code)
9D0270FC  24020001   ADDIU V0, ZERO, 1
9D027100  14820007   BNE A0, V0, 0x9D027120
9D027104  00000000   NOP
157:                       state_setslot(8);
9D027110  0F409433   JAL state_setslot
9D027114  24040008   ADDIU A0, ZERO, 8
158:                 }
9D027118  8FBF0014   LW RA, 20(SP)
9D02711C  27BD0018   ADDIU SP, SP, 24
9D027120  03E00008   JR RA
9D027124  00000000   NOP
159:                 
160:                 static void func_event_state_slot_9(int code)
161:                 {
9D0270DC  27BDFFE8   ADDIU SP, SP, -24
9D0270E0  AFBF0014   SW RA, 20(SP)
162:                    if (INP_STATE_MAKE == code)
9D0270D0  24020001   ADDIU V0, ZERO, 1
9D0270D4  14820007   BNE A0, V0, 0x9D0270F4
9D0270D8  00000000   NOP
163:                       state_setslot(9);
9D0270E4  0F409433   JAL state_setslot
9D0270E8  24040009   ADDIU A0, ZERO, 9
164:                 }
9D0270EC  8FBF0014   LW RA, 20(SP)
9D0270F0  27BD0018   ADDIU SP, SP, 24
9D0270F4  03E00008   JR RA
9D0270F8  00000000   NOP
165:                 
166:                 static void func_event_gui_toggle_oam(int code)
167:                 {
9D0270B0  27BDFFE8   ADDIU SP, SP, -24
9D0270B4  AFBF0014   SW RA, 20(SP)
168:                    if (INP_STATE_MAKE == code)
9D0270A4  24020001   ADDIU V0, ZERO, 1
9D0270A8  14820007   BNE A0, V0, 0x9D0270C8
9D0270AC  00000000   NOP
169:                       gui_toggleoam();
9D0270B8  0F408F49   JAL gui_toggleoam
9D0270BC  00000000   NOP
170:                 }
9D0270C0  8FBF0014   LW RA, 20(SP)
9D0270C4  27BD0018   ADDIU SP, SP, 24
9D0270C8  03E00008   JR RA
9D0270CC  00000000   NOP
171:                 
172:                 static void func_event_gui_toggle_wave(int code)
173:                 {
9D027084  27BDFFE8   ADDIU SP, SP, -24
9D027088  AFBF0014   SW RA, 20(SP)
174:                    if (INP_STATE_MAKE == code)
9D027078  24020001   ADDIU V0, ZERO, 1
9D02707C  14820007   BNE A0, V0, 0x9D02709C
9D027080  00000000   NOP
175:                       gui_togglewave();
9D02708C  0F408F3C   JAL gui_togglewave
9D027090  00000000   NOP
176:                 }
9D027094  8FBF0014   LW RA, 20(SP)
9D027098  27BD0018   ADDIU SP, SP, 24
9D02709C  03E00008   JR RA
9D0270A0  00000000   NOP
177:                 
178:                 static void func_event_gui_toggle_pattern(int code)
179:                 {
9D027058  27BDFFE8   ADDIU SP, SP, -24
9D02705C  AFBF0014   SW RA, 20(SP)
180:                    if (INP_STATE_MAKE == code)
9D02704C  24020001   ADDIU V0, ZERO, 1
9D027050  14820007   BNE A0, V0, 0x9D027070
9D027054  00000000   NOP
181:                       gui_togglepattern();
9D027060  0F408F4D   JAL gui_togglepattern
9D027064  00000000   NOP
182:                 }
9D027068  8FBF0014   LW RA, 20(SP)
9D02706C  27BD0018   ADDIU SP, SP, 24
9D027070  03E00008   JR RA
9D027074  00000000   NOP
183:                 
184:                 static void func_event_gui_pattern_color_up(int code)
185:                 {
9D02702C  27BDFFE8   ADDIU SP, SP, -24
9D027030  AFBF0014   SW RA, 20(SP)
186:                    if (INP_STATE_MAKE == code)
9D027020  24020001   ADDIU V0, ZERO, 1
9D027024  14820007   BNE A0, V0, 0x9D027044
9D027028  00000000   NOP
187:                       gui_incpatterncol();
9D027034  0F408F59   JAL gui_incpatterncol
9D027038  00000000   NOP
188:                 }
9D02703C  8FBF0014   LW RA, 20(SP)
9D027040  27BD0018   ADDIU SP, SP, 24
9D027044  03E00008   JR RA
9D027048  00000000   NOP
189:                 
190:                 static void func_event_gui_pattern_color_down(int code)
191:                 {
9D027000  27BDFFE8   ADDIU SP, SP, -24
9D027004  AFBF0014   SW RA, 20(SP)
192:                    if (INP_STATE_MAKE == code)
9D026FF4  24020001   ADDIU V0, ZERO, 1
9D026FF8  14820007   BNE A0, V0, 0x9D027018
9D026FFC  00000000   NOP
193:                       gui_decpatterncol();
9D027008  0F408F51   JAL gui_decpatterncol
9D02700C  00000000   NOP
194:                 }
9D027010  8FBF0014   LW RA, 20(SP)
9D027014  27BD0018   ADDIU SP, SP, 24
9D027018  03E00008   JR RA
9D02701C  00000000   NOP
195:                 
196:                 static void func_event_gui_toggle_fps(int code)
197:                 {
9D026FD4  27BDFFE8   ADDIU SP, SP, -24
9D026FD8  AFBF0014   SW RA, 20(SP)
198:                    if (INP_STATE_MAKE == code)
9D026FC8  24020001   ADDIU V0, ZERO, 1
9D026FCC  14820007   BNE A0, V0, 0x9D026FEC
9D026FD0  00000000   NOP
199:                       gui_togglefps();
9D026FDC  0F408F34   JAL gui_togglefps
9D026FE0  00000000   NOP
200:                 }
9D026FE4  8FBF0014   LW RA, 20(SP)
9D026FE8  27BD0018   ADDIU SP, SP, 24
9D026FEC  03E00008   JR RA
9D026FF0  00000000   NOP
201:                 
202:                 static void func_event_gui_display_info(int code)
203:                 {
9D026FA8  27BDFFE8   ADDIU SP, SP, -24
9D026FAC  AFBF0014   SW RA, 20(SP)
204:                    if (INP_STATE_MAKE == code)
9D026F9C  24020001   ADDIU V0, ZERO, 1
9D026FA0  14820007   BNE A0, V0, 0x9D026FC0
9D026FA4  00000000   NOP
205:                       gui_displayinfo();
9D026FB0  0F409074   JAL gui_displayinfo
9D026FB4  00000000   NOP
206:                 }
9D026FB8  8FBF0014   LW RA, 20(SP)
9D026FBC  27BD0018   ADDIU SP, SP, 24
9D026FC0  03E00008   JR RA
9D026FC4  00000000   NOP
207:                 
208:                 static void func_event_gui_toggle(int code)
209:                 {
9D026F7C  27BDFFE8   ADDIU SP, SP, -24
9D026F80  AFBF0014   SW RA, 20(SP)
210:                    if (INP_STATE_MAKE == code)
9D026F70  24020001   ADDIU V0, ZERO, 1
9D026F74  14820007   BNE A0, V0, 0x9D026F94
9D026F78  00000000   NOP
211:                       gui_togglegui();
9D026F84  0F408F38   JAL gui_togglegui
9D026F88  00000000   NOP
212:                 }
9D026F8C  8FBF0014   LW RA, 20(SP)
9D026F90  27BD0018   ADDIU SP, SP, 24
9D026F94  03E00008   JR RA
9D026F98  00000000   NOP
213:                 
214:                 static void func_event_toggle_channel_0(int code)
215:                 {
9D026F50  27BDFFE8   ADDIU SP, SP, -24
9D026F54  AFBF0014   SW RA, 20(SP)
216:                    if (INP_STATE_MAKE == code)
9D026F44  24020001   ADDIU V0, ZERO, 1
9D026F48  14820007   BNE A0, V0, 0x9D026F68
9D026F4C  00000000   NOP
217:                       gui_toggle_chan(0);
9D026F58  0F409080   JAL gui_toggle_chan
9D026F5C  00002021   ADDU A0, ZERO, ZERO
218:                 }
9D026F60  8FBF0014   LW RA, 20(SP)
9D026F64  27BD0018   ADDIU SP, SP, 24
9D026F68  03E00008   JR RA
9D026F6C  00000000   NOP
219:                 
220:                 static void func_event_toggle_channel_1(int code)
221:                 {
9D026F24  27BDFFE8   ADDIU SP, SP, -24
9D026F28  AFBF0014   SW RA, 20(SP)
222:                    if (INP_STATE_MAKE == code)
9D026F18  24020001   ADDIU V0, ZERO, 1
9D026F1C  14820007   BNE A0, V0, 0x9D026F3C
9D026F20  00000000   NOP
223:                       gui_toggle_chan(1);
9D026F2C  0F409080   JAL gui_toggle_chan
9D026F30  24040001   ADDIU A0, ZERO, 1
224:                 }
9D026F34  8FBF0014   LW RA, 20(SP)
9D026F38  27BD0018   ADDIU SP, SP, 24
9D026F3C  03E00008   JR RA
9D026F40  00000000   NOP
225:                 
226:                 static void func_event_toggle_channel_2(int code)
227:                 {
9D026EF8  27BDFFE8   ADDIU SP, SP, -24
9D026EFC  AFBF0014   SW RA, 20(SP)
228:                    if (INP_STATE_MAKE == code)
9D026EEC  24020001   ADDIU V0, ZERO, 1
9D026EF0  14820007   BNE A0, V0, 0x9D026F10
9D026EF4  00000000   NOP
229:                       gui_toggle_chan(2);
9D026F00  0F409080   JAL gui_toggle_chan
9D026F04  24040002   ADDIU A0, ZERO, 2
230:                 }
9D026F08  8FBF0014   LW RA, 20(SP)
9D026F0C  27BD0018   ADDIU SP, SP, 24
9D026F10  03E00008   JR RA
9D026F14  00000000   NOP
231:                 
232:                 static void func_event_toggle_channel_3(int code)
233:                 {
9D026ECC  27BDFFE8   ADDIU SP, SP, -24
9D026ED0  AFBF0014   SW RA, 20(SP)
234:                    if (INP_STATE_MAKE == code)
9D026EC0  24020001   ADDIU V0, ZERO, 1
9D026EC4  14820007   BNE A0, V0, 0x9D026EE4
9D026EC8  00000000   NOP
235:                       gui_toggle_chan(3);
9D026ED4  0F409080   JAL gui_toggle_chan
9D026ED8  24040003   ADDIU A0, ZERO, 3
236:                 }
9D026EDC  8FBF0014   LW RA, 20(SP)
9D026EE0  27BD0018   ADDIU SP, SP, 24
9D026EE4  03E00008   JR RA
9D026EE8  00000000   NOP
237:                 
238:                 static void func_event_toggle_channel_4(int code)
239:                 {
9D026EA0  27BDFFE8   ADDIU SP, SP, -24
9D026EA4  AFBF0014   SW RA, 20(SP)
240:                    if (INP_STATE_MAKE == code)
9D026E94  24020001   ADDIU V0, ZERO, 1
9D026E98  14820007   BNE A0, V0, 0x9D026EB8
9D026E9C  00000000   NOP
241:                       gui_toggle_chan(4);
9D026EA8  0F409080   JAL gui_toggle_chan
9D026EAC  24040004   ADDIU A0, ZERO, 4
242:                 }
9D026EB0  8FBF0014   LW RA, 20(SP)
9D026EB4  27BD0018   ADDIU SP, SP, 24
9D026EB8  03E00008   JR RA
9D026EBC  00000000   NOP
243:                 
244:                 static void func_event_toggle_channel_5(int code)
245:                 {
9D026E74  27BDFFE8   ADDIU SP, SP, -24
9D026E78  AFBF0014   SW RA, 20(SP)
246:                    if (INP_STATE_MAKE == code)
9D026E68  24020001   ADDIU V0, ZERO, 1
9D026E6C  14820007   BNE A0, V0, 0x9D026E8C
9D026E70  00000000   NOP
247:                       gui_toggle_chan(5);
9D026E7C  0F409080   JAL gui_toggle_chan
9D026E80  24040005   ADDIU A0, ZERO, 5
248:                 }
9D026E84  8FBF0014   LW RA, 20(SP)
9D026E88  27BD0018   ADDIU SP, SP, 24
9D026E8C  03E00008   JR RA
9D026E90  00000000   NOP
249:                 
250:                 static void func_event_set_filter_0(int code)
251:                 {
9D026E48  27BDFFE8   ADDIU SP, SP, -24
9D026E4C  AFBF0014   SW RA, 20(SP)
252:                    if (INP_STATE_MAKE == code)
9D026E3C  24020001   ADDIU V0, ZERO, 1
9D026E40  14820007   BNE A0, V0, 0x9D026E60
9D026E44  00000000   NOP
253:                       gui_setfilter(0);
9D026E50  0F4090B5   JAL gui_setfilter
9D026E54  00002021   ADDU A0, ZERO, ZERO
254:                 }
9D026E58  8FBF0014   LW RA, 20(SP)
9D026E5C  27BD0018   ADDIU SP, SP, 24
9D026E60  03E00008   JR RA
9D026E64  00000000   NOP
255:                 
256:                 static void func_event_set_filter_1(int code)
257:                 {
9D026E1C  27BDFFE8   ADDIU SP, SP, -24
9D026E20  AFBF0014   SW RA, 20(SP)
258:                    if (INP_STATE_MAKE == code)
9D026E10  24020001   ADDIU V0, ZERO, 1
9D026E14  14820007   BNE A0, V0, 0x9D026E34
9D026E18  00000000   NOP
259:                       gui_setfilter(1);
9D026E24  0F4090B5   JAL gui_setfilter
9D026E28  24040001   ADDIU A0, ZERO, 1
260:                 }
9D026E2C  8FBF0014   LW RA, 20(SP)
9D026E30  27BD0018   ADDIU SP, SP, 24
9D026E34  03E00008   JR RA
9D026E38  00000000   NOP
261:                 
262:                 static void func_event_set_filter_2(int code)
263:                 {
9D026DF0  27BDFFE8   ADDIU SP, SP, -24
9D026DF4  AFBF0014   SW RA, 20(SP)
264:                    if (INP_STATE_MAKE == code)
9D026DE4  24020001   ADDIU V0, ZERO, 1
9D026DE8  14820007   BNE A0, V0, 0x9D026E08
9D026DEC  00000000   NOP
265:                       gui_setfilter(2);
9D026DF8  0F4090B5   JAL gui_setfilter
9D026DFC  24040002   ADDIU A0, ZERO, 2
266:                 }
9D026E00  8FBF0014   LW RA, 20(SP)
9D026E04  27BD0018   ADDIU SP, SP, 24
9D026E08  03E00008   JR RA
9D026E0C  00000000   NOP
267:                 
268:                 static void func_event_toggle_sprites(int code)
269:                 {
9D026DC4  27BDFFE8   ADDIU SP, SP, -24
9D026DC8  AFBF0014   SW RA, 20(SP)
270:                    if (INP_STATE_MAKE == code)
9D026DB8  24020001   ADDIU V0, ZERO, 1
9D026DBC  14820007   BNE A0, V0, 0x9D026DDC
9D026DC0  00000000   NOP
271:                       gui_togglesprites();
9D026DCC  0F40904B   JAL gui_togglesprites
9D026DD0  00000000   NOP
272:                 }
9D026DD4  8FBF0014   LW RA, 20(SP)
9D026DD8  27BD0018   ADDIU SP, SP, 24
9D026DDC  03E00008   JR RA
9D026DE0  00000000   NOP
273:                 
274:                 static void func_event_palette_hue_up(int code)
275:                 {
9D026D5C  27BDFFE8   ADDIU SP, SP, -24
9D026D60  AFBF0014   SW RA, 20(SP)
9D026D64  AFB00010   SW S0, 16(SP)
276:                    /* make sure we don't have a VS game */
277:                    if (nes_getcontextptr()->rominfo->flags & ROM_FLAG_VERSUS)
9D026D68  0F408AD0   JAL nes_getcontextptr
9D026D6C  00808021   ADDU S0, A0, ZERO
9D026D70  8C420310   LW V0, 784(V0)
9D026D74  90420028   LBU V0, 40(V0)
9D026D78  30420008   ANDI V0, V0, 8
9D026D7C  304200FF   ANDI V0, V0, 255
9D026D80  14400009   BNE V0, ZERO, .LVL81
9D026D84  24020001   ADDIU V0, ZERO, 1
278:                       return;
279:                 
280:                    if (INP_STATE_MAKE == code)
9D026D88  16020008   BNE S0, V0, 0x9D026DAC
9D026D8C  8FBF0014   LW RA, 20(SP)
281:                    {
282:                       pal_inchue();
9D026D90  0F40C1B9   JAL pal_inchue
9D026D94  00000000   NOP
283:                       ppu_setdefaultpal(nes_getcontextptr()->ppu);
9D026D98  0F408AD0   JAL nes_getcontextptr
9D026D9C  00000000   NOP
9D026DA0  0F40636C   JAL ppu_setdefaultpal
9D026DA4  8C440304   LW A0, 772(V0)
284:                    }
285:                 }
9D026DA8  8FBF0014   LW RA, 20(SP)
9D026DAC  8FB00010   LW S0, 16(SP)
9D026DB0  03E00008   JR RA
9D026DB4  27BD0018   ADDIU SP, SP, 24
286:                 
287:                 static void func_event_palette_hue_down(int code)
288:                 {
9D026D00  27BDFFE8   ADDIU SP, SP, -24
9D026D04  AFBF0014   SW RA, 20(SP)
9D026D08  AFB00010   SW S0, 16(SP)
289:                    /* make sure we don't have a VS game */
290:                    if (nes_getcontextptr()->rominfo->flags & ROM_FLAG_VERSUS)
9D026D0C  0F408AD0   JAL nes_getcontextptr
9D026D10  00808021   ADDU S0, A0, ZERO
9D026D14  8C420310   LW V0, 784(V0)
9D026D18  90420028   LBU V0, 40(V0)
9D026D1C  30420008   ANDI V0, V0, 8
9D026D20  304200FF   ANDI V0, V0, 255
9D026D24  14400009   BNE V0, ZERO, .LVL75
9D026D28  24020001   ADDIU V0, ZERO, 1
291:                       return;
292:                 
293:                    if (INP_STATE_MAKE == code)
9D026D2C  16020008   BNE S0, V0, 0x9D026D50
9D026D30  8FBF0014   LW RA, 20(SP)
294:                    {
295:                       pal_dechue();
9D026D34  0F40C1A8   JAL pal_dechue
9D026D38  00000000   NOP
296:                       ppu_setdefaultpal(nes_getcontextptr()->ppu);
9D026D3C  0F408AD0   JAL nes_getcontextptr
9D026D40  00000000   NOP
9D026D44  0F40636C   JAL ppu_setdefaultpal
9D026D48  8C440304   LW A0, 772(V0)
297:                    }
298:                 }
9D026D4C  8FBF0014   LW RA, 20(SP)
9D026D50  8FB00010   LW S0, 16(SP)
9D026D54  03E00008   JR RA
9D026D58  27BD0018   ADDIU SP, SP, 24
299:                 
300:                 static void func_event_palette_tint_up(int code)
301:                 {
9D026CA4  27BDFFE8   ADDIU SP, SP, -24
9D026CA8  AFBF0014   SW RA, 20(SP)
9D026CAC  AFB00010   SW S0, 16(SP)
302:                    /* make sure we don't have a VS game */
303:                    if (nes_getcontextptr()->rominfo->flags & ROM_FLAG_VERSUS)
9D026CB0  0F408AD0   JAL nes_getcontextptr
9D026CB4  00808021   ADDU S0, A0, ZERO
9D026CB8  8C420310   LW V0, 784(V0)
9D026CBC  90420028   LBU V0, 40(V0)
9D026CC0  30420008   ANDI V0, V0, 8
9D026CC4  304200FF   ANDI V0, V0, 255
9D026CC8  14400009   BNE V0, ZERO, .LVL69
9D026CCC  24020001   ADDIU V0, ZERO, 1
304:                       return;
305:                 
306:                    if (INP_STATE_MAKE == code)
9D026CD0  16020008   BNE S0, V0, 0x9D026CF4
9D026CD4  8FBF0014   LW RA, 20(SP)
307:                    {
308:                       pal_inctint();
9D026CD8  0F40C1DB   JAL pal_inctint
9D026CDC  00000000   NOP
309:                       ppu_setdefaultpal(nes_getcontextptr()->ppu);
9D026CE0  0F408AD0   JAL nes_getcontextptr
9D026CE4  00000000   NOP
9D026CE8  0F40636C   JAL ppu_setdefaultpal
9D026CEC  8C440304   LW A0, 772(V0)
310:                    }
311:                 }
9D026CF0  8FBF0014   LW RA, 20(SP)
9D026CF4  8FB00010   LW S0, 16(SP)
9D026CF8  03E00008   JR RA
9D026CFC  27BD0018   ADDIU SP, SP, 24
312:                 
313:                 static void func_event_palette_tint_down(int code)
314:                 {
9D026C48  27BDFFE8   ADDIU SP, SP, -24
9D026C4C  AFBF0014   SW RA, 20(SP)
9D026C50  AFB00010   SW S0, 16(SP)
315:                    /* make sure we don't have a VS game */
316:                    if (nes_getcontextptr()->rominfo->flags & ROM_FLAG_VERSUS)
9D026C54  0F408AD0   JAL nes_getcontextptr
9D026C58  00808021   ADDU S0, A0, ZERO
9D026C5C  8C420310   LW V0, 784(V0)
9D026C60  90420028   LBU V0, 40(V0)
9D026C64  30420008   ANDI V0, V0, 8
9D026C68  304200FF   ANDI V0, V0, 255
9D026C6C  14400009   BNE V0, ZERO, .LVL63
9D026C70  24020001   ADDIU V0, ZERO, 1
317:                       return;
318:                 
319:                    if (INP_STATE_MAKE == code)
9D026C74  16020008   BNE S0, V0, 0x9D026C98
9D026C78  8FBF0014   LW RA, 20(SP)
320:                    {
321:                       pal_dectint();
9D026C7C  0F40C1CA   JAL pal_dectint
9D026C80  00000000   NOP
322:                       ppu_setdefaultpal(nes_getcontextptr()->ppu);
9D026C84  0F408AD0   JAL nes_getcontextptr
9D026C88  00000000   NOP
9D026C8C  0F40636C   JAL ppu_setdefaultpal
9D026C90  8C440304   LW A0, 772(V0)
323:                    }
324:                 }
9D026C94  8FBF0014   LW RA, 20(SP)
9D026C98  8FB00010   LW S0, 16(SP)
9D026C9C  03E00008   JR RA
9D026CA0  27BD0018   ADDIU SP, SP, 24
325:                 
326:                 static void func_event_palette_set_default(int code)
327:                 {
9D026BF4  27BDFFE8   ADDIU SP, SP, -24
9D026BF8  AFBF0014   SW RA, 20(SP)
9D026BFC  AFB00010   SW S0, 16(SP)
328:                    /* make sure we don't have a VS game */
329:                    if (nes_getcontextptr()->rominfo->flags & ROM_FLAG_VERSUS)
9D026C00  0F408AD0   JAL nes_getcontextptr
9D026C04  00808021   ADDU S0, A0, ZERO
9D026C08  8C420310   LW V0, 784(V0)
9D026C0C  90420028   LBU V0, 40(V0)
9D026C10  30420008   ANDI V0, V0, 8
9D026C14  304200FF   ANDI V0, V0, 255
9D026C18  14400007   BNE V0, ZERO, .LVL57
9D026C1C  24020001   ADDIU V0, ZERO, 1
330:                       return;
331:                 
332:                    if (INP_STATE_MAKE == code)
9D026C20  16020006   BNE S0, V0, 0x9D026C3C
9D026C24  8FBF0014   LW RA, 20(SP)
333:                       ppu_setdefaultpal(nes_getcontextptr()->ppu);
9D026C28  0F408AD0   JAL nes_getcontextptr
9D026C2C  00000000   NOP
9D026C30  0F40636C   JAL ppu_setdefaultpal
9D026C34  8C440304   LW A0, 772(V0)
334:                 }
9D026C38  8FBF0014   LW RA, 20(SP)
9D026C3C  8FB00010   LW S0, 16(SP)
9D026C40  03E00008   JR RA
9D026C44  27BD0018   ADDIU SP, SP, 24
335:                 
336:                 static void func_event_palette_set_shady(int code)
337:                 {
9D026B98  27BDFFE8   ADDIU SP, SP, -24
9D026B9C  AFBF0014   SW RA, 20(SP)
9D026BA0  AFB00010   SW S0, 16(SP)
338:                    /* make sure we don't have a VS game */
339:                    if (nes_getcontextptr()->rominfo->flags & ROM_FLAG_VERSUS)
9D026BA4  0F408AD0   JAL nes_getcontextptr
9D026BA8  00808021   ADDU S0, A0, ZERO
9D026BAC  8C420310   LW V0, 784(V0)
9D026BB0  90420028   LBU V0, 40(V0)
9D026BB4  30420008   ANDI V0, V0, 8
9D026BB8  304200FF   ANDI V0, V0, 255
9D026BBC  14400009   BNE V0, ZERO, .LVL52
9D026BC0  24020001   ADDIU V0, ZERO, 1
340:                       return;
341:                 
342:                    if (INP_STATE_MAKE == code)
9D026BC4  16020008   BNE S0, V0, 0x9D026BE8
9D026BC8  8FBF0014   LW RA, 20(SP)
343:                       ppu_setpal(nes_getcontextptr()->ppu, shady_palette);
9D026BCC  0F408AD0   JAL nes_getcontextptr
9D026BD0  00000000   NOP
9D026BD4  8C440304   LW A0, 772(V0)
9D026BD8  3C05A001   LUI A1, -24575
9D026BDC  0F406339   JAL ppu_setpal
9D026BE0  24A59EAC   ADDIU A1, A1, -24916
344:                 }
9D026BE4  8FBF0014   LW RA, 20(SP)
9D026BE8  8FB00010   LW S0, 16(SP)
9D026BEC  03E00008   JR RA
9D026BF0  27BD0018   ADDIU SP, SP, 24
345:                 
346:                 static void func_event_joypad1_a(int code)
347:                 {
9D026B74  27BDFFE8   ADDIU SP, SP, -24
9D026B78  AFBF0014   SW RA, 20(SP)
9D026B7C  00802821   ADDU A1, A0, ZERO
348:                    input_event(&kb_input, code, INP_PAD_A);
9D026B80  27848038   ADDIU A0, GP, -32712
9D026B84  0F40CCC8   JAL input_event
9D026B88  24060001   ADDIU A2, ZERO, 1
349:                 }
9D026B8C  8FBF0014   LW RA, 20(SP)
9D026B90  03E00008   JR RA
9D026B94  27BD0018   ADDIU SP, SP, 24
350:                 
351:                 static void func_event_joypad1_b(int code)
352:                 {
9D026B50  27BDFFE8   ADDIU SP, SP, -24
9D026B54  AFBF0014   SW RA, 20(SP)
9D026B58  00802821   ADDU A1, A0, ZERO
353:                    input_event(&kb_input, code, INP_PAD_B);
9D026B5C  27848038   ADDIU A0, GP, -32712
9D026B60  0F40CCC8   JAL input_event
9D026B64  24060002   ADDIU A2, ZERO, 2
354:                 }
9D026B68  8FBF0014   LW RA, 20(SP)
9D026B6C  03E00008   JR RA
9D026B70  27BD0018   ADDIU SP, SP, 24
355:                 
356:                 static void func_event_joypad1_start(int code)
357:                 {
9D026B2C  27BDFFE8   ADDIU SP, SP, -24
9D026B30  AFBF0014   SW RA, 20(SP)
9D026B34  00802821   ADDU A1, A0, ZERO
358:                    input_event(&kb_input, code, INP_PAD_START);
9D026B38  27848038   ADDIU A0, GP, -32712
9D026B3C  0F40CCC8   JAL input_event
9D026B40  24060008   ADDIU A2, ZERO, 8
359:                 }
9D026B44  8FBF0014   LW RA, 20(SP)
9D026B48  03E00008   JR RA
9D026B4C  27BD0018   ADDIU SP, SP, 24
360:                 
361:                 static void func_event_joypad1_select(int code)
362:                 {
9D026B08  27BDFFE8   ADDIU SP, SP, -24
9D026B0C  AFBF0014   SW RA, 20(SP)
9D026B10  00802821   ADDU A1, A0, ZERO
363:                    input_event(&kb_input, code, INP_PAD_SELECT);
9D026B14  27848038   ADDIU A0, GP, -32712
9D026B18  0F40CCC8   JAL input_event
9D026B1C  24060004   ADDIU A2, ZERO, 4
364:                 }
9D026B20  8FBF0014   LW RA, 20(SP)
9D026B24  03E00008   JR RA
9D026B28  27BD0018   ADDIU SP, SP, 24
365:                 
366:                 static void func_event_joypad1_up(int code)
367:                 {
9D026AE4  27BDFFE8   ADDIU SP, SP, -24
9D026AE8  AFBF0014   SW RA, 20(SP)
9D026AEC  00802821   ADDU A1, A0, ZERO
368:                    input_event(&kb_input, code, INP_PAD_UP);
9D026AF0  27848038   ADDIU A0, GP, -32712
9D026AF4  0F40CCC8   JAL input_event
9D026AF8  24060010   ADDIU A2, ZERO, 16
369:                 }
9D026AFC  8FBF0014   LW RA, 20(SP)
9D026B00  03E00008   JR RA
9D026B04  27BD0018   ADDIU SP, SP, 24
370:                 
371:                 static void func_event_joypad1_down(int code)
372:                 {
9D026AC0  27BDFFE8   ADDIU SP, SP, -24
9D026AC4  AFBF0014   SW RA, 20(SP)
9D026AC8  00802821   ADDU A1, A0, ZERO
373:                    input_event(&kb_input, code, INP_PAD_DOWN);
9D026ACC  27848038   ADDIU A0, GP, -32712
9D026AD0  0F40CCC8   JAL input_event
9D026AD4  24060020   ADDIU A2, ZERO, 32
374:                 }
9D026AD8  8FBF0014   LW RA, 20(SP)
9D026ADC  03E00008   JR RA
9D026AE0  27BD0018   ADDIU SP, SP, 24
375:                 
376:                 static void func_event_joypad1_left(int code)
377:                 {
9D026A9C  27BDFFE8   ADDIU SP, SP, -24
9D026AA0  AFBF0014   SW RA, 20(SP)
9D026AA4  00802821   ADDU A1, A0, ZERO
378:                    input_event(&kb_input, code, INP_PAD_LEFT);
9D026AA8  27848038   ADDIU A0, GP, -32712
9D026AAC  0F40CCC8   JAL input_event
9D026AB0  24060040   ADDIU A2, ZERO, 64
379:                 }
9D026AB4  8FBF0014   LW RA, 20(SP)
9D026AB8  03E00008   JR RA
9D026ABC  27BD0018   ADDIU SP, SP, 24
380:                 
381:                 static void func_event_joypad1_right(int code)
382:                 {
9D026A78  27BDFFE8   ADDIU SP, SP, -24
9D026A7C  AFBF0014   SW RA, 20(SP)
9D026A80  00802821   ADDU A1, A0, ZERO
383:                    input_event(&kb_input, code, INP_PAD_RIGHT);
9D026A84  27848038   ADDIU A0, GP, -32712
9D026A88  0F40CCC8   JAL input_event
9D026A8C  24060080   ADDIU A2, ZERO, 128
384:                 }
9D026A90  8FBF0014   LW RA, 20(SP)
9D026A94  03E00008   JR RA
9D026A98  27BD0018   ADDIU SP, SP, 24
385:                 
386:                 static void func_event_joypad2_a(int code)
387:                 {
9D026A54  27BDFFE8   ADDIU SP, SP, -24
9D026A58  AFBF0014   SW RA, 20(SP)
9D026A5C  00802821   ADDU A1, A0, ZERO
388:                    input_event(&kb_alt_input, code, INP_PAD_A);
9D026A60  27848030   ADDIU A0, GP, -32720
9D026A64  0F40CCC8   JAL input_event
9D026A68  24060001   ADDIU A2, ZERO, 1
389:                 }
9D026A6C  8FBF0014   LW RA, 20(SP)
9D026A70  03E00008   JR RA
9D026A74  27BD0018   ADDIU SP, SP, 24
390:                 
391:                 static void func_event_joypad2_b(int code)
392:                 {
9D026A30  27BDFFE8   ADDIU SP, SP, -24
9D026A34  AFBF0014   SW RA, 20(SP)
9D026A38  00802821   ADDU A1, A0, ZERO
393:                    input_event(&kb_alt_input, code, INP_PAD_B);
9D026A3C  27848030   ADDIU A0, GP, -32720
9D026A40  0F40CCC8   JAL input_event
9D026A44  24060002   ADDIU A2, ZERO, 2
394:                 }
9D026A48  8FBF0014   LW RA, 20(SP)
9D026A4C  03E00008   JR RA
9D026A50  27BD0018   ADDIU SP, SP, 24
395:                 
396:                 static void func_event_joypad2_start(int code)
397:                 {
9D026A0C  27BDFFE8   ADDIU SP, SP, -24
9D026A10  AFBF0014   SW RA, 20(SP)
9D026A14  00802821   ADDU A1, A0, ZERO
398:                    input_event(&kb_alt_input, code, INP_PAD_START);
9D026A18  27848030   ADDIU A0, GP, -32720
9D026A1C  0F40CCC8   JAL input_event
9D026A20  24060008   ADDIU A2, ZERO, 8
399:                 }
9D026A24  8FBF0014   LW RA, 20(SP)
9D026A28  03E00008   JR RA
9D026A2C  27BD0018   ADDIU SP, SP, 24
400:                 
401:                 static void func_event_joypad2_select(int code)
402:                 {
9D0269E8  27BDFFE8   ADDIU SP, SP, -24
9D0269EC  AFBF0014   SW RA, 20(SP)
9D0269F0  00802821   ADDU A1, A0, ZERO
403:                    input_event(&kb_alt_input, code, INP_PAD_SELECT);
9D0269F4  27848030   ADDIU A0, GP, -32720
9D0269F8  0F40CCC8   JAL input_event
9D0269FC  24060004   ADDIU A2, ZERO, 4
404:                 }
9D026A00  8FBF0014   LW RA, 20(SP)
9D026A04  03E00008   JR RA
9D026A08  27BD0018   ADDIU SP, SP, 24
405:                 
406:                 static void func_event_joypad2_up(int code)
407:                 {
9D0269C4  27BDFFE8   ADDIU SP, SP, -24
9D0269C8  AFBF0014   SW RA, 20(SP)
9D0269CC  00802821   ADDU A1, A0, ZERO
408:                    input_event(&kb_alt_input, code, INP_PAD_UP);
9D0269D0  27848030   ADDIU A0, GP, -32720
9D0269D4  0F40CCC8   JAL input_event
9D0269D8  24060010   ADDIU A2, ZERO, 16
409:                 }
9D0269DC  8FBF0014   LW RA, 20(SP)
9D0269E0  03E00008   JR RA
9D0269E4  27BD0018   ADDIU SP, SP, 24
410:                 
411:                 static void func_event_joypad2_down(int code)
412:                 {
9D0269A0  27BDFFE8   ADDIU SP, SP, -24
9D0269A4  AFBF0014   SW RA, 20(SP)
9D0269A8  00802821   ADDU A1, A0, ZERO
413:                    input_event(&kb_alt_input, code, INP_PAD_DOWN);
9D0269AC  27848030   ADDIU A0, GP, -32720
9D0269B0  0F40CCC8   JAL input_event
9D0269B4  24060020   ADDIU A2, ZERO, 32
414:                 }
9D0269B8  8FBF0014   LW RA, 20(SP)
9D0269BC  03E00008   JR RA
9D0269C0  27BD0018   ADDIU SP, SP, 24
415:                 
416:                 static void func_event_joypad2_left(int code)
417:                 {
9D02697C  27BDFFE8   ADDIU SP, SP, -24
9D026980  AFBF0014   SW RA, 20(SP)
9D026984  00802821   ADDU A1, A0, ZERO
418:                    input_event(&kb_alt_input, code, INP_PAD_LEFT);
9D026988  27848030   ADDIU A0, GP, -32720
9D02698C  0F40CCC8   JAL input_event
9D026990  24060040   ADDIU A2, ZERO, 64
419:                 }
9D026994  8FBF0014   LW RA, 20(SP)
9D026998  03E00008   JR RA
9D02699C  27BD0018   ADDIU SP, SP, 24
420:                 
421:                 static void func_event_joypad2_right(int code)
422:                 {
9D026958  27BDFFE8   ADDIU SP, SP, -24
9D02695C  AFBF0014   SW RA, 20(SP)
9D026960  00802821   ADDU A1, A0, ZERO
423:                    input_event(&kb_alt_input, code, INP_PAD_RIGHT);
9D026964  27848030   ADDIU A0, GP, -32720
9D026968  0F40CCC8   JAL input_event
9D02696C  24060080   ADDIU A2, ZERO, 128
424:                 }
9D026970  8FBF0014   LW RA, 20(SP)
9D026974  03E00008   JR RA
9D026978  27BD0018   ADDIU SP, SP, 24
425:                 
426:                 static void func_event_songup(int code)
427:                 {
428:                 }
429:                 
430:                 static void func_event_songdown(int code)
431:                 {
432:                 }
433:                 
434:                 static void func_event_startsong(int code)
435:                 {
436:                 }
437:                 
438:                 /* NES events */
439:                 static event_t nes_events[] =
440:                 {
441:                    NULL, /* 0 */
442:                    func_event_quit,
443:                    func_event_insert,
444:                    func_event_eject,
445:                    func_event_togglepause,
446:                    func_event_soft_reset,
447:                    func_event_hard_reset,
448:                    func_event_snapshot,
449:                    func_event_toggle_frameskip,
450:                    /* saves */
451:                    func_event_state_save,
452:                    func_event_state_load, /* 10 */
453:                    func_event_state_slot_0,
454:                    func_event_state_slot_1,
455:                    func_event_state_slot_2,
456:                    func_event_state_slot_3,
457:                    func_event_state_slot_4,
458:                    func_event_state_slot_5,
459:                    func_event_state_slot_6,
460:                    func_event_state_slot_7,
461:                    func_event_state_slot_8,
462:                    func_event_state_slot_9, /* 20 */
463:                    /* GUI */
464:                    func_event_gui_toggle_oam,
465:                    func_event_gui_toggle_wave,
466:                    func_event_gui_toggle_pattern,
467:                    func_event_gui_pattern_color_up,
468:                    func_event_gui_pattern_color_down,
469:                    func_event_gui_toggle_fps,
470:                    func_event_gui_display_info,
471:                    func_event_gui_toggle,
472:                    /* sound */
473:                    func_event_toggle_channel_0,
474:                    func_event_toggle_channel_1, /* 30 */
475:                    func_event_toggle_channel_2,
476:                    func_event_toggle_channel_3,
477:                    func_event_toggle_channel_4,
478:                    func_event_toggle_channel_5,
479:                    func_event_set_filter_0,
480:                    func_event_set_filter_1,
481:                    func_event_set_filter_2,
482:                    /* picture */
483:                    func_event_toggle_sprites,
484:                    func_event_palette_hue_up,
485:                    func_event_palette_hue_down,
486:                    func_event_palette_tint_up, /* 40 */
487:                    func_event_palette_tint_down,
488:                    func_event_palette_set_default,
489:                    func_event_palette_set_shady,
490:                    /* joypad 1 */
491:                    func_event_joypad1_a,
492:                    func_event_joypad1_b, 
493:                    func_event_joypad1_start,
494:                    func_event_joypad1_select,
495:                    func_event_joypad1_up,
496:                    func_event_joypad1_down,
497:                    func_event_joypad1_left, /* 50 */
498:                    func_event_joypad1_right,
499:                    /* joypad 2 */
500:                    func_event_joypad2_a,
501:                    func_event_joypad2_b,
502:                    func_event_joypad2_start,
503:                    func_event_joypad2_select,
504:                    func_event_joypad2_up,
505:                    func_event_joypad2_down,
506:                    func_event_joypad2_left,
507:                    func_event_joypad2_right,
508:                    /* NSF control */
509:                    NULL, /* 60 */
510:                    NULL,
511:                    NULL,
512:                    /* OS-specific */
513:                    NULL,
514:                    NULL,
515:                    NULL,
516:                    NULL,
517:                    NULL,
518:                    NULL,
519:                    NULL,
520:                    NULL, /* 70 */
521:                    NULL,
522:                    /* last */
523:                    NULL
524:                 };
525:                 
526:                 
527:                 static event_t *event_system_table[NUM_SUPPORTED_SYSTEMS] =
528:                 {
529:                    NULL, /* unknown */
530:                    NULL, /* autodetect */
531:                    nes_events, /* nes */
532:                 };
533:                 
534:                 void event_init(void)
535:                 {
9D027404  27BDFFE8   ADDIU SP, SP, -24
9D027408  AFBF0014   SW RA, 20(SP)
536:                    input_register(&kb_input);
9D02740C  0F40CCBD   JAL input_register
9D027410  27848038   ADDIU A0, GP, -32712
537:                    input_register(&kb_alt_input);
9D027414  0F40CCBD   JAL input_register
9D027418  27848030   ADDIU A0, GP, -32720
538:                 }
9D02741C  8FBF0014   LW RA, 20(SP)
9D027420  03E00008   JR RA
9D027424  27BD0018   ADDIU SP, SP, 24
539:                 
540:                 /* set up the event system for a certain console/system type */
541:                 void event_set_system(system_t type)
542:                 {
543:                    ASSERT(type < NUM_SUPPORTED_SYSTEMS);
544:                 
545:                    system_events = event_system_table[type];
9D027428  00042080   SLL A0, A0, 2
9D02742C  3C029D04   LUI V0, -25340
9D027430  2442C350   ADDIU V0, V0, -15536
9D027434  00822021   ADDU A0, A0, V0
9D027438  8C820000   LW V0, 0(A0)
9D02743C  03E00008   JR RA
9D027440  AF828160   SW V0, -32416(GP)
546:                 }
547:                 
548:                 void event_set(int index, event_t handler)
549:                 {
550:                    /* now, event_set is used to set osd-specific events.  We should assume
551:                    ** (for now, at least) that these events should be used across all
552:                    ** emulated systems, so let's loop through all system event handler
553:                    ** tables and add this event...
554:                    */
555:                    int i;
556:                 
557:                    for (i = 0; i < NUM_SUPPORTED_SYSTEMS; i++)
558:                    {
559:                       if(event_system_table[i])
560:                       {
561:                          event_system_table[i][index] = handler;
9D027444  00042080   SLL A0, A0, 2
9D027448  3C02A001   LUI V0, -24575
9D02744C  2442A4F0   ADDIU V0, V0, -23312
9D027450  00441021   ADDU V0, V0, A0
9D027454  03E00008   JR RA
9D027458  AC450000   SW A1, 0(V0)
562:                       }
563:                    }
564:                 }
565:                 
566:                 event_t event_get(int index)
567:                 {
568:                    return system_events[index];
9D02745C  00042080   SLL A0, A0, 2
9D027460  8F828160   LW V0, -32416(GP)
9D027464  00442021   ADDU A0, V0, A0
569:                 }
9D027468  03E00008   JR RA
9D02746C  8C820000   LW V0, 0(A0)
570:                 
571:                 
572:                 /*
573:                 ** $Log: event.c,v $
574:                 ** Revision 1.3  2001/04/27 14:37:11  neil
575:                 ** wheeee
576:                 **
577:                 ** Revision 1.2  2001/04/27 11:10:08  neil
578:                 ** compile
579:                 **
580:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
581:                 ** initial
582:                 **
583:                 ** Revision 1.18  2000/11/25 20:26:05  matt
584:                 ** removed fds "system"
585:                 **
586:                 ** Revision 1.17  2000/11/09 14:05:42  matt
587:                 ** state load fixed, state save mostly fixed
588:                 **
589:                 ** Revision 1.16  2000/11/05 16:37:18  matt
590:                 ** rolled rgb.h into bitmap.h
591:                 **
592:                 ** Revision 1.15  2000/11/01 17:33:26  neil
593:                 ** little crash bugs fixed
594:                 **
595:                 ** Revision 1.14  2000/11/01 14:15:35  matt
596:                 ** multi-system event system, or whatever
597:                 **
598:                 ** Revision 1.13  2000/10/27 12:59:48  matt
599:                 ** api change for ppu palette functions
600:                 **
601:                 ** Revision 1.12  2000/10/26 22:48:05  matt
602:                 ** no need for extern
603:                 **
604:                 ** Revision 1.11  2000/10/25 00:23:16  matt
605:                 ** makefiles updated for new directory structure
606:                 **
607:                 ** Revision 1.10  2000/10/23 17:50:46  matt
608:                 ** adding fds support
609:                 **
610:                 ** Revision 1.9  2000/10/23 15:52:04  matt
611:                 ** better system handling
612:                 **
613:                 ** Revision 1.8  2000/10/22 15:01:51  matt
614:                 ** prevented palette changing in VS unisystem games
615:                 **
616:                 ** Revision 1.7  2000/10/10 13:03:54  matt
617:                 ** Mr. Clean makes a guest appearance
618:                 **
619:                 ** Revision 1.6  2000/08/16 02:58:34  matt
620:                 ** random cleanups
621:                 **
622:                 ** Revision 1.5  2000/07/27 01:15:33  matt
623:                 ** name changes
624:                 **
625:                 ** Revision 1.4  2000/07/26 21:36:13  neil
626:                 ** Big honkin' change -- see the mailing list
627:                 **
628:                 ** Revision 1.3  2000/07/23 15:17:19  matt
629:                 ** non-osd calls moved from osd.c to gui.c
630:                 **
631:                 ** Revision 1.2  2000/07/21 12:07:40  neil
632:                 ** added room in event_array for all osd events
633:                 **
634:                 ** Revision 1.1  2000/07/21 04:26:38  matt
635:                 ** initial revision
636:                 **
637:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/cpu/nes6502.c  -----------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** nes6502.c
21:                  **
22:                  ** NES custom 6502 (2A03) CPU implementation
23:                  ** $Id: nes6502.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  
27:                  #include <noftypes.h>
28:                  #include "nes6502.h"
29:                  #include "dis6502.h"
30:                  
31:                  #//define  NES6502_DISASM
32:                  
33:                  #ifdef __GNUC__
34:                  #define  NES6502_JUMPTABLE
35:                  #endif /* __GNUC__ */
36:                  
37:                  
38:                  #define  ADD_CYCLES(x) \
39:                  { \
40:                     remaining_cycles -= (x); \
41:                     cpu.total_cycles += (x); \
42:                  }
43:                  
44:                  /*
45:                  ** Check to see if an index reg addition overflowed to next page
46:                  */
47:                  #define PAGE_CROSS_CHECK(addr, reg) \
48:                  { \
49:                     if ((reg) > (uint8) (addr)) \
50:                        ADD_CYCLES(1); \
51:                  }
52:                  
53:                  #define EMPTY_READ(value)  /* empty */
54:                  
55:                  /*
56:                  ** Addressing mode macros
57:                  */
58:                  
59:                  /* Immediate */
60:                  #define IMMEDIATE_BYTE(value) \
61:                  { \
62:                     value = bank_readbyte(PC++); \
63:                  }
64:                  
65:                  /* Absolute */
66:                  #define ABSOLUTE_ADDR(address) \
67:                  { \
68:                     address = bank_readword(PC); \
69:                     PC += 2; \
70:                  }
71:                  
72:                  #define ABSOLUTE(address, value) \
73:                  { \
74:                     ABSOLUTE_ADDR(address); \
75:                     value = mem_readbyte(address); \
76:                  }
77:                  
78:                  #define ABSOLUTE_BYTE(value) \
79:                  { \
80:                     ABSOLUTE(temp, value); \
81:                  }
82:                  
83:                  /* Absolute indexed X */
84:                  #define ABS_IND_X_ADDR(address) \
85:                  { \
86:                     ABSOLUTE_ADDR(address); \
87:                     address = (address + X) & 0xFFFF; \
88:                  }
89:                  
90:                  #define ABS_IND_X(address, value) \
91:                  { \
92:                     ABS_IND_X_ADDR(address); \
93:                     value = mem_readbyte(address); \
94:                  }
95:                  
96:                  #define ABS_IND_X_BYTE(value) \
97:                  { \
98:                     ABS_IND_X(temp, value); \
99:                  }
100:                 
101:                 /* special page-cross check version for read instructions */
102:                 #define ABS_IND_X_BYTE_READ(value) \
103:                 { \
104:                    ABS_IND_X_ADDR(temp); \
105:                    PAGE_CROSS_CHECK(temp, X); \
106:                    value = mem_readbyte(temp); \
107:                 }
108:                 
109:                 /* Absolute indexed Y */
110:                 #define ABS_IND_Y_ADDR(address) \
111:                 { \
112:                    ABSOLUTE_ADDR(address); \
113:                    address = (address + Y) & 0xFFFF; \
114:                 }
115:                 
116:                 #define ABS_IND_Y(address, value) \
117:                 { \
118:                    ABS_IND_Y_ADDR(address); \
119:                    value = mem_readbyte(address); \
120:                 }
121:                 
122:                 #define ABS_IND_Y_BYTE(value) \
123:                 { \
124:                    ABS_IND_Y(temp, value); \
125:                 }
126:                 
127:                 /* special page-cross check version for read instructions */
128:                 #define ABS_IND_Y_BYTE_READ(value) \
129:                 { \
130:                    ABS_IND_Y_ADDR(temp); \
131:                    PAGE_CROSS_CHECK(temp, Y); \
132:                    value = mem_readbyte(temp); \
133:                 }
134:                 
135:                 /* Zero-page */
136:                 #define ZERO_PAGE_ADDR(address) \
137:                 { \
138:                    IMMEDIATE_BYTE(address); \
139:                 }
140:                 
141:                 #define ZERO_PAGE(address, value) \
142:                 { \
143:                    ZERO_PAGE_ADDR(address); \
144:                    value = ZP_READBYTE(address); \
145:                 }
146:                 
147:                 #define ZERO_PAGE_BYTE(value) \
148:                 { \
149:                    ZERO_PAGE(btemp, value); \
150:                 }
151:                 
152:                 /* Zero-page indexed X */
153:                 #define ZP_IND_X_ADDR(address) \
154:                 { \
155:                    ZERO_PAGE_ADDR(address); \
156:                    address += X; \
157:                 }
158:                 
159:                 #define ZP_IND_X(address, value) \
160:                 { \
161:                    ZP_IND_X_ADDR(address); \
162:                    value = ZP_READBYTE(address); \
163:                 }
164:                 
165:                 #define ZP_IND_X_BYTE(value) \
166:                 { \
167:                    ZP_IND_X(btemp, value); \
168:                 }
169:                 
170:                 /* Zero-page indexed Y */
171:                 /* Not really an adressing mode, just for LDx/STx */
172:                 #define ZP_IND_Y_ADDR(address) \
173:                 { \
174:                    ZERO_PAGE_ADDR(address); \
175:                    address += Y; \
176:                 }
177:                 
178:                 #define ZP_IND_Y_BYTE(value) \
179:                 { \
180:                    ZP_IND_Y_ADDR(btemp); \
181:                    value = ZP_READBYTE(btemp); \
182:                 }  
183:                 
184:                 /* Indexed indirect */
185:                 #define INDIR_X_ADDR(address) \
186:                 { \
187:                    ZERO_PAGE_ADDR(btemp); \
188:                    btemp += X; \
189:                    address = zp_readword(btemp); \
190:                 }
191:                 
192:                 #define INDIR_X(address, value) \
193:                 { \
194:                    INDIR_X_ADDR(address); \
195:                    value = mem_readbyte(address); \
196:                 } 
197:                 
198:                 #define INDIR_X_BYTE(value) \
199:                 { \
200:                    INDIR_X(temp, value); \
201:                 }
202:                 
203:                 /* Indirect indexed */
204:                 #define INDIR_Y_ADDR(address) \
205:                 { \
206:                    ZERO_PAGE_ADDR(btemp); \
207:                    address = (zp_readword(btemp) + Y) & 0xFFFF; \
208:                 }
209:                 
210:                 #define INDIR_Y(address, value) \
211:                 { \
212:                    INDIR_Y_ADDR(address); \
213:                    value = mem_readbyte(address); \
214:                 } 
215:                 
216:                 #define INDIR_Y_BYTE(value) \
217:                 { \
218:                    INDIR_Y(temp, value); \
219:                 }
220:                 
221:                 /* special page-cross check version for read instructions */
222:                 #define INDIR_Y_BYTE_READ(value) \
223:                 { \
224:                    INDIR_Y_ADDR(temp); \
225:                    PAGE_CROSS_CHECK(temp, Y); \
226:                    value = mem_readbyte(temp); \
227:                 }
228:                 
229:                 
230:                 
231:                 /* Stack push/pull */
232:                 #define  PUSH(value)             stack[S--] = (uint8) (value)
233:                 #define  PULL()                  stack[++S]
234:                 
235:                 
236:                 /*
237:                 ** flag register helper macros
238:                 */
239:                 
240:                 /* Theory: Z and N flags are set in just about every
241:                 ** instruction, so we will just store the value in those
242:                 ** flag variables, and mask out the irrelevant data when
243:                 ** we need to check them (branches, etc).  This makes the
244:                 ** zero flag only really be 'set' when z_flag == 0.
245:                 ** The rest of the flags are stored as true booleans.
246:                 */
247:                 
248:                 /* Scatter flags to separate variables */
249:                 #define  SCATTER_FLAGS(value) \
250:                 { \
251:                    n_flag = (value) & N_FLAG; \
252:                    v_flag = (value) & V_FLAG; \
253:                    b_flag = (value) & B_FLAG; \
254:                    d_flag = (value) & D_FLAG; \
255:                    i_flag = (value) & I_FLAG; \
256:                    z_flag = (0 == ((value) & Z_FLAG)); \
257:                    c_flag = (value) & C_FLAG; \
258:                 }
259:                 
260:                 /* Combine flags into flag register */
261:                 #define  COMBINE_FLAGS() \
262:                 ( \
263:                    (n_flag & N_FLAG) \
264:                    | (v_flag ? V_FLAG : 0) \
265:                    | R_FLAG \
266:                    | (b_flag ? B_FLAG : 0) \
267:                    | (d_flag ? D_FLAG : 0) \
268:                    | (i_flag ? I_FLAG : 0) \
269:                    | (z_flag ? 0 : Z_FLAG) \
270:                    | c_flag \
271:                 )
272:                 
273:                 /* Set N and Z flags based on given value */
274:                 #define  SET_NZ_FLAGS(value)     n_flag = z_flag = (value);
275:                 
276:                 /* For BCC, BCS, BEQ, BMI, BNE, BPL, BVC, BVS */
277:                 #define RELATIVE_BRANCH(condition) \
278:                 { \
279:                    if (condition) \
280:                    { \
281:                       IMMEDIATE_BYTE(btemp); \
282:                       if (((int8) btemp + (PC & 0x00FF)) & 0x100) \
283:                          ADD_CYCLES(1); \
284:                       ADD_CYCLES(3); \
285:                       PC += (int8) btemp; \
286:                    } \
287:                    else \
288:                    { \
289:                       PC++; \
290:                       ADD_CYCLES(2); \
291:                    } \
292:                 }
293:                 
294:                 #define JUMP(address) \
295:                 { \
296:                    PC = bank_readword((address)); \
297:                 }
298:                 
299:                 /*
300:                 ** Interrupt macros
301:                 */
302:                 #define NMI_PROC() \
303:                 { \
304:                    PUSH(PC >> 8); \
305:                    PUSH(PC & 0xFF); \
306:                    b_flag = 0; \
307:                    PUSH(COMBINE_FLAGS()); \
308:                    i_flag = 1; \
309:                    JUMP(NMI_VECTOR); \
310:                 }
311:                 
312:                 #define IRQ_PROC() \
313:                 { \
314:                    PUSH(PC >> 8); \
315:                    PUSH(PC & 0xFF); \
316:                    b_flag = 0; \
317:                    PUSH(COMBINE_FLAGS()); \
318:                    i_flag = 1; \
319:                    JUMP(IRQ_VECTOR); \
320:                 }
321:                 
322:                 /*
323:                 ** Instruction macros
324:                 */
325:                 
326:                 /* Warning! NES CPU has no decimal mode, so by default this does no BCD! */
327:                 #ifdef NES6502_DECIMAL
328:                 #define ADC(cycles, read_func) \
329:                 { \
330:                    read_func(data); \
331:                    if (d_flag) \
332:                    { \
333:                       temp = (A & 0x0F) + (data & 0x0F) + c_flag; \
334:                       if (temp >= 10) \
335:                          temp = (temp - 10) | 0x10; \
336:                       temp += (A & 0xF0) + (data & 0xF0); \
337:                       z_flag = (A + data + c_flag) & 0xFF; \
338:                       n_flag = temp; \
339:                       v_flag = ((~(A ^ data)) & (A ^ temp) & 0x80); \
340:                       if (temp > 0x90) \
341:                       { \
342:                          temp += 0x60; \
343:                          c_flag = 1; \
344:                       } \
345:                       else \
346:                       { \
347:                          c_flag = 0; \
348:                       } \
349:                       A = (uint8) temp; \
350:                    } \
351:                    else \
352:                    { \
353:                       temp = A + data + c_flag; \
354:                       c_flag = (temp >> 8) & 1; \
355:                       v_flag = ((~(A ^ data)) & (A ^ temp) & 0x80); \
356:                       A = (uint8) temp; \
357:                       SET_NZ_FLAGS(A); \
358:                    }\
359:                    ADD_CYCLES(cycles); \
360:                 }
361:                 #else
362:                 #define ADC(cycles, read_func) \
363:                 { \
364:                    read_func(data); \
365:                    temp = A + data + c_flag; \
366:                    c_flag = (temp >> 8) & 1; \
367:                    v_flag = ((~(A ^ data)) & (A ^ temp) & 0x80); \
368:                    A = (uint8) temp; \
369:                    SET_NZ_FLAGS(A); \
370:                    ADD_CYCLES(cycles); \
371:                 }
372:                 #endif /* NES6502_DECIMAL */
373:                 
374:                 /* undocumented */
375:                 #define ANC(cycles, read_func) \
376:                 { \
377:                    read_func(data); \
378:                    A &= data; \
379:                    c_flag = (n_flag & N_FLAG) >> 7; \
380:                    SET_NZ_FLAGS(A); \
381:                    ADD_CYCLES(cycles); \
382:                 }
383:                 
384:                 #define AND(cycles, read_func) \
385:                 { \
386:                    read_func(data); \
387:                    A &= data; \
388:                    SET_NZ_FLAGS(A); \
389:                    ADD_CYCLES(cycles); \
390:                 }
391:                 
392:                 /* undocumented */
393:                 #define ANE(cycles, read_func) \
394:                 { \
395:                    read_func(data); \
396:                    A = (A | 0xEE) & X & data; \
397:                    SET_NZ_FLAGS(A); \
398:                    ADD_CYCLES(cycles); \
399:                 }
400:                 
401:                 /* undocumented */
402:                 #ifdef NES6502_DECIMAL
403:                 #define ARR(cycles, read_func) \
404:                 { \
405:                    read_func(data); \
406:                    data &= A; \
407:                    if (d_flag) \
408:                    { \
409:                       temp = (data >> 1) | (c_flag << 7); \
410:                       SET_NZ_FLAGS(temp); \
411:                       v_flag = (temp ^ data) & 0x40; \
412:                       if (((data & 0x0F) + (data & 0x01)) > 5) \
413:                          temp = (temp & 0xF0) | ((temp + 0x6) & 0x0F); \
414:                       if (((data & 0xF0) + (data & 0x10)) > 0x50) \
415:                       { \
416:                          temp = (temp & 0x0F) | ((temp + 0x60) & 0xF0); \
417:                          c_flag = 1; \
418:                       } \
419:                       else \
420:                       { \
421:                          c_flag = 0; \
422:                       } \
423:                       A = (uint8) temp; \
424:                    } \
425:                    else \
426:                    { \
427:                       A = (data >> 1) | (c_flag << 7); \
428:                       SET_NZ_FLAGS(A); \
429:                       c_flag = (A & 0x40) >> 6; \
430:                       v_flag = ((A >> 6) ^ (A >> 5)) & 1; \
431:                    }\
432:                    ADD_CYCLES(cycles); \
433:                 }
434:                 #else
435:                 #define ARR(cycles, read_func) \
436:                 { \
437:                    read_func(data); \
438:                    data &= A; \
439:                    A = (data >> 1) | (c_flag << 7); \
440:                    SET_NZ_FLAGS(A); \
441:                    c_flag = (A & 0x40) >> 6; \
442:                    v_flag = ((A >> 6) ^ (A >> 5)) & 1; \
443:                    ADD_CYCLES(cycles); \
444:                 }
445:                 #endif /* NES6502_DECIMAL */
446:                 
447:                 #define ASL(cycles, read_func, write_func, addr) \
448:                 { \
449:                    read_func(addr, data); \
450:                    c_flag = data >> 7; \
451:                    data <<= 1; \
452:                    write_func(addr, data); \
453:                    SET_NZ_FLAGS(data); \
454:                    ADD_CYCLES(cycles); \
455:                 }
456:                 
457:                 #define ASL_A() \
458:                 { \
459:                    c_flag = A >> 7; \
460:                    A <<= 1; \
461:                    SET_NZ_FLAGS(A); \
462:                    ADD_CYCLES(2); \
463:                 }
464:                 
465:                 /* undocumented */
466:                 #define ASR(cycles, read_func) \
467:                 { \
468:                    read_func(data); \
469:                    data &= A; \
470:                    c_flag = data & 1; \
471:                    A = data >> 1; \
472:                    SET_NZ_FLAGS(A); \
473:                    ADD_CYCLES(cycles); \
474:                 }
475:                 
476:                 #define BCC() \
477:                 { \
478:                    RELATIVE_BRANCH(0 == c_flag); \
479:                 }
480:                 
481:                 #define BCS() \
482:                 { \
483:                    RELATIVE_BRANCH(0 != c_flag); \
484:                 }
485:                 
486:                 #define BEQ() \
487:                 { \
488:                    RELATIVE_BRANCH(0 == z_flag); \
489:                 }
490:                 
491:                 /* bit 7/6 of data move into N/V flags */
492:                 #define BIT(cycles, read_func) \
493:                 { \
494:                    read_func(data); \
495:                    n_flag = data; \
496:                    v_flag = data & V_FLAG; \
497:                    z_flag = data & A; \
498:                    ADD_CYCLES(cycles); \
499:                 }
500:                 
501:                 #define BMI() \
502:                 { \
503:                    RELATIVE_BRANCH(n_flag & N_FLAG); \
504:                 }
505:                 
506:                 #define BNE() \
507:                 { \
508:                    RELATIVE_BRANCH(0 != z_flag); \
509:                 }
510:                 
511:                 #define BPL() \
512:                 { \
513:                    RELATIVE_BRANCH(0 == (n_flag & N_FLAG)); \
514:                 }
515:                 
516:                 /* Software interrupt type thang */
517:                 #define BRK() \
518:                 { \
519:                    PC++; \
520:                    PUSH(PC >> 8); \
521:                    PUSH(PC & 0xFF); \
522:                    b_flag = 1; \
523:                    PUSH(COMBINE_FLAGS()); \
524:                    i_flag = 1; \
525:                    JUMP(IRQ_VECTOR); \
526:                    ADD_CYCLES(7); \
527:                 }
528:                 
529:                 #define BVC() \
530:                 { \
531:                    RELATIVE_BRANCH(0 == v_flag); \
532:                 }
533:                 
534:                 #define BVS() \
535:                 { \
536:                    RELATIVE_BRANCH(0 != v_flag); \
537:                 }
538:                 
539:                 #define CLC() \
540:                 { \
541:                    c_flag = 0; \
542:                    ADD_CYCLES(2); \
543:                 }
544:                 
545:                 #define CLD() \
546:                 { \
547:                    d_flag = 0; \
548:                    ADD_CYCLES(2); \
549:                 }
550:                 
551:                 #define CLI() \
552:                 { \
553:                    i_flag = 0; \
554:                    ADD_CYCLES(2); \
555:                    if (cpu.int_pending && remaining_cycles > 0) \
556:                    { \
557:                       cpu.int_pending = 0; \
558:                       IRQ_PROC(); \
559:                       ADD_CYCLES(INT_CYCLES); \
560:                    } \
561:                 }
562:                 
563:                 #define CLV() \
564:                 { \
565:                    v_flag = 0; \
566:                    ADD_CYCLES(2); \
567:                 }
568:                 
569:                 /* C is clear when data > A */ 
570:                 #define _COMPARE(reg, value) \
571:                 { \
572:                    temp = (reg) - (value); \
573:                    c_flag = ((temp & 0x100) >> 8) ^ 1; \
574:                    SET_NZ_FLAGS((uint8) temp); \
575:                 }
576:                 
577:                 #define CMP(cycles, read_func) \
578:                 { \
579:                    read_func(data); \
580:                    _COMPARE(A, data); \
581:                    ADD_CYCLES(cycles); \
582:                 }
583:                 
584:                 #define CPX(cycles, read_func) \
585:                 { \
586:                    read_func(data); \
587:                    _COMPARE(X, data); \
588:                    ADD_CYCLES(cycles); \
589:                 }
590:                 
591:                 #define CPY(cycles, read_func) \
592:                 { \
593:                    read_func(data); \
594:                    _COMPARE(Y, data); \
595:                    ADD_CYCLES(cycles); \
596:                 }
597:                 
598:                 /* undocumented */
599:                 #define DCP(cycles, read_func, write_func, addr) \
600:                 { \
601:                    read_func(addr, data); \
602:                    data--; \
603:                    write_func(addr, data); \
604:                    CMP(cycles, EMPTY_READ); \
605:                 }
606:                 
607:                 #define DEC(cycles, read_func, write_func, addr) \
608:                 { \
609:                    read_func(addr, data); \
610:                    data--; \
611:                    write_func(addr, data); \
612:                    SET_NZ_FLAGS(data); \
613:                    ADD_CYCLES(cycles); \
614:                 }
615:                 
616:                 #define DEX() \
617:                 { \
618:                    X--; \
619:                    SET_NZ_FLAGS(X); \
620:                    ADD_CYCLES(2); \
621:                 }
622:                 
623:                 #define DEY() \
624:                 { \
625:                    Y--; \
626:                    SET_NZ_FLAGS(Y); \
627:                    ADD_CYCLES(2); \
628:                 }
629:                 
630:                 /* undocumented (double-NOP) */
631:                 #define DOP(cycles) \
632:                 { \
633:                    PC++; \
634:                    ADD_CYCLES(cycles); \
635:                 }
636:                 
637:                 #define EOR(cycles, read_func) \
638:                 { \
639:                    read_func(data); \
640:                    A ^= data; \
641:                    SET_NZ_FLAGS(A); \
642:                    ADD_CYCLES(cycles); \
643:                 }
644:                 
645:                 #define INC(cycles, read_func, write_func, addr) \
646:                 { \
647:                    read_func(addr, data); \
648:                    data++; \
649:                    write_func(addr, data); \
650:                    SET_NZ_FLAGS(data); \
651:                    ADD_CYCLES(cycles); \
652:                 }
653:                 
654:                 #define INX() \
655:                 { \
656:                    X++; \
657:                    SET_NZ_FLAGS(X); \
658:                    ADD_CYCLES(2); \
659:                 }
660:                 
661:                 #define INY() \
662:                 { \
663:                    Y++; \
664:                    SET_NZ_FLAGS(Y); \
665:                    ADD_CYCLES(2); \
666:                 }
667:                 
668:                 /* undocumented */
669:                 #define ISB(cycles, read_func, write_func, addr) \
670:                 { \
671:                    read_func(addr, data); \
672:                    data++; \
673:                    write_func(addr, data); \
674:                    SBC(cycles, EMPTY_READ); \
675:                 }
676:                 
677:                 /* TODO: make this a function callback */
678:                 #ifdef NES6502_TESTOPS
679:                 #define JAM() \
680:                 { \
681:                    cpu_Jam(); \
682:                 }
683:                 #else /* !NES6502_TESTOPS */
684:                 #define JAM() \
685:                 { \
686:                    PC--; \
687:                    cpu.jammed = true; \
688:                    cpu.int_pending = 0; \
689:                    ADD_CYCLES(2); \
690:                 }
691:                 #endif /* !NES6502_TESTOPS */
692:                 
693:                 #define JMP_INDIRECT() \
694:                 { \
695:                    temp = bank_readword(PC); \
696:                    /* bug in crossing page boundaries */ \
697:                    if (0xFF == (temp & 0xFF)) \
698:                       PC = (bank_readbyte(temp & 0xFF00) << 8) | bank_readbyte(temp); \
699:                    else \
700:                       JUMP(temp); \
701:                    ADD_CYCLES(5); \
702:                 }
703:                 
704:                 #define JMP_ABSOLUTE() \
705:                 { \
706:                    JUMP(PC); \
707:                    ADD_CYCLES(3); \
708:                 }
709:                 
710:                 #define JSR() \
711:                 { \
712:                    PC++; \
713:                    PUSH(PC >> 8); \
714:                    PUSH(PC & 0xFF); \
715:                    JUMP(PC - 1); \
716:                    ADD_CYCLES(6); \
717:                 }
718:                 
719:                 /* undocumented */
720:                 #define LAS(cycles, read_func) \
721:                 { \
722:                    read_func(data); \
723:                    A = X = S = (S & data); \
724:                    SET_NZ_FLAGS(A); \
725:                    ADD_CYCLES(cycles); \
726:                 }
727:                 
728:                 /* undocumented */
729:                 #define LAX(cycles, read_func) \
730:                 { \
731:                    read_func(A); \
732:                    X = A; \
733:                    SET_NZ_FLAGS(A); \
734:                    ADD_CYCLES(cycles); \
735:                 }
736:                 
737:                 #define LDA(cycles, read_func) \
738:                 { \
739:                    read_func(A); \
740:                    SET_NZ_FLAGS(A); \
741:                    ADD_CYCLES(cycles); \
742:                 }
743:                 
744:                 #define LDX(cycles, read_func) \
745:                 { \
746:                    read_func(X); \
747:                    SET_NZ_FLAGS(X);\
748:                    ADD_CYCLES(cycles); \
749:                 }
750:                 
751:                 #define LDY(cycles, read_func) \
752:                 { \
753:                    read_func(Y); \
754:                    SET_NZ_FLAGS(Y);\
755:                    ADD_CYCLES(cycles); \
756:                 }
757:                 
758:                 #define LSR(cycles, read_func, write_func, addr) \
759:                 { \
760:                    read_func(addr, data); \
761:                    c_flag = data & 1; \
762:                    data >>= 1; \
763:                    write_func(addr, data); \
764:                    SET_NZ_FLAGS(data); \
765:                    ADD_CYCLES(cycles); \
766:                 }
767:                 
768:                 #define LSR_A() \
769:                 { \
770:                    c_flag = A & 1; \
771:                    A >>= 1; \
772:                    SET_NZ_FLAGS(A); \
773:                    ADD_CYCLES(2); \
774:                 }
775:                 
776:                 /* undocumented */
777:                 #define LXA(cycles, read_func) \
778:                 { \
779:                    read_func(data); \
780:                    A = X = ((A | 0xEE) & data); \
781:                    SET_NZ_FLAGS(A); \
782:                    ADD_CYCLES(cycles); \
783:                 }
784:                 
785:                 #define NOP() \
786:                 { \
787:                    ADD_CYCLES(2); \
788:                 }
789:                 
790:                 #define ORA(cycles, read_func) \
791:                 { \
792:                    read_func(data); \
793:                    A |= data; \
794:                    SET_NZ_FLAGS(A);\
795:                    ADD_CYCLES(cycles); \
796:                 }
797:                 
798:                 #define PHA() \
799:                 { \
800:                    PUSH(A); \
801:                    ADD_CYCLES(3); \
802:                 }
803:                 
804:                 #define PHP() \
805:                 { \
806:                    /* B flag is pushed on stack as well */ \
807:                    PUSH(COMBINE_FLAGS() | B_FLAG); \
808:                    ADD_CYCLES(3); \
809:                 }
810:                 
811:                 #define PLA() \
812:                 { \
813:                    A = PULL(); \
814:                    SET_NZ_FLAGS(A); \
815:                    ADD_CYCLES(4); \
816:                 }
817:                 
818:                 #define PLP() \
819:                 { \
820:                    btemp = PULL(); \
821:                    SCATTER_FLAGS(btemp); \
822:                    ADD_CYCLES(4); \
823:                 }
824:                 
825:                 /* undocumented */
826:                 #define RLA(cycles, read_func, write_func, addr) \
827:                 { \
828:                    read_func(addr, data); \
829:                    btemp = c_flag; \
830:                    c_flag = data >> 7; \
831:                    data = (data << 1) | btemp; \
832:                    write_func(addr, data); \
833:                    A &= data; \
834:                    SET_NZ_FLAGS(A); \
835:                    ADD_CYCLES(cycles); \
836:                 }
837:                 
838:                 /* 9-bit rotation (carry flag used for rollover) */
839:                 #define ROL(cycles, read_func, write_func, addr) \
840:                 { \
841:                    read_func(addr, data); \
842:                    btemp = c_flag; \
843:                    c_flag = data >> 7; \
844:                    data = (data << 1) | btemp; \
845:                    write_func(addr, data); \
846:                    SET_NZ_FLAGS(data); \
847:                    ADD_CYCLES(cycles); \
848:                 }
849:                 
850:                 #define ROL_A() \
851:                 { \
852:                    btemp = c_flag; \
853:                    c_flag = A >> 7; \
854:                    A = (A << 1) | btemp; \
855:                    SET_NZ_FLAGS(A); \
856:                    ADD_CYCLES(2); \
857:                 }
858:                 
859:                 #define ROR(cycles, read_func, write_func, addr) \
860:                 { \
861:                    read_func(addr, data); \
862:                    btemp = c_flag << 7; \
863:                    c_flag = data & 1; \
864:                    data = (data >> 1) | btemp; \
865:                    write_func(addr, data); \
866:                    SET_NZ_FLAGS(data); \
867:                    ADD_CYCLES(cycles); \
868:                 }
869:                 
870:                 #define ROR_A() \
871:                 { \
872:                    btemp = c_flag << 7; \
873:                    c_flag = A & 1; \
874:                    A = (A >> 1) | btemp; \
875:                    SET_NZ_FLAGS(A); \
876:                    ADD_CYCLES(2); \
877:                 }
878:                 
879:                 /* undocumented */
880:                 #define RRA(cycles, read_func, write_func, addr) \
881:                 { \
882:                    read_func(addr, data); \
883:                    btemp = c_flag << 7; \
884:                    c_flag = data & 1; \
885:                    data = (data >> 1) | btemp; \
886:                    write_func(addr, data); \
887:                    ADC(cycles, EMPTY_READ); \
888:                 }
889:                 
890:                 #define RTI() \
891:                 { \
892:                    btemp = PULL(); \
893:                    SCATTER_FLAGS(btemp); \
894:                    PC = PULL(); \
895:                    PC |= PULL() << 8; \
896:                    ADD_CYCLES(6); \
897:                    if (0 == i_flag && cpu.int_pending && remaining_cycles > 0) \
898:                    { \
899:                       cpu.int_pending = 0; \
900:                       IRQ_PROC(); \
901:                       ADD_CYCLES(INT_CYCLES); \
902:                    } \
903:                 }
904:                 
905:                 #define RTS() \
906:                 { \
907:                    PC = PULL(); \
908:                    PC = (PC | (PULL() << 8)) + 1; \
909:                    ADD_CYCLES(6); \
910:                 }
911:                 
912:                 /* undocumented */
913:                 #define SAX(cycles, read_func, write_func, addr) \
914:                 { \
915:                    read_func(addr); \
916:                    data = A & X; \
917:                    write_func(addr, data); \
918:                    ADD_CYCLES(cycles); \
919:                 }
920:                 
921:                 /* Warning! NES CPU has no decimal mode, so by default this does no BCD! */
922:                 #ifdef NES6502_DECIMAL
923:                 #define SBC(cycles, read_func) \
924:                 { \
925:                    read_func(data); \
926:                    temp = A - data - (c_flag ^ 1); \
927:                    if (d_flag) \
928:                    { \
929:                       uint8 al, ah; \
930:                       al = (A & 0x0F) - (data & 0x0F) - (c_flag ^ 1); \
931:                       ah = (A >> 4) - (data >> 4); \
932:                       if (al & 0x10) \
933:                       { \
934:                          al -= 6; \
935:                          ah--; \
936:                       } \
937:                       if (ah & 0x10) \
938:                       { \
939:                          ah -= 6; \
940:                          c_flag = 0; \
941:                       } \
942:                       else \
943:                       { \
944:                          c_flag = 1; \
945:                       } \
946:                       v_flag = (A ^ temp) & (A ^ data) & 0x80; \
947:                       SET_NZ_FLAGS(temp & 0xFF); \
948:                       A = (ah << 4) | (al & 0x0F); \
949:                    } \
950:                    else \
951:                    { \
952:                       v_flag = (A ^ temp) & (A ^ data) & 0x80; \
953:                       c_flag = ((temp & 0x100) >> 8) ^ 1; \
954:                       A = (uint8) temp; \
955:                       SET_NZ_FLAGS(A & 0xFF); \
956:                    } \
957:                    ADD_CYCLES(cycles); \
958:                 }
959:                 #else
960:                 #define SBC(cycles, read_func) \
961:                 { \
962:                    read_func(data); \
963:                    temp = A - data - (c_flag ^ 1); \
964:                    v_flag = (A ^ data) & (A ^ temp) & 0x80; \
965:                    c_flag = ((temp >> 8) & 1) ^ 1; \
966:                    A = (uint8) temp; \
967:                    SET_NZ_FLAGS(A); \
968:                    ADD_CYCLES(cycles); \
969:                 }
970:                 #endif /* NES6502_DECIMAL */
971:                 
972:                 /* undocumented */
973:                 #define SBX(cycles, read_func) \
974:                 { \
975:                    read_func(data); \
976:                    temp = (A & X) - data; \
977:                    c_flag = ((temp >> 8) & 1) ^ 1; \
978:                    X = temp & 0xFF; \
979:                    SET_NZ_FLAGS(X); \
980:                    ADD_CYCLES(cycles); \
981:                 }
982:                 
983:                 #define SEC() \
984:                 { \
985:                    c_flag = 1; \
986:                    ADD_CYCLES(2); \
987:                 }
988:                 
989:                 #define SED() \
990:                 { \
991:                    d_flag = 1; \
992:                    ADD_CYCLES(2); \
993:                 }
994:                 
995:                 #define SEI() \
996:                 { \
997:                    i_flag = 1; \
998:                    ADD_CYCLES(2); \
999:                 }
1000:                
1001:                /* undocumented */
1002:                #define SHA(cycles, read_func, write_func, addr) \
1003:                { \
1004:                   read_func(addr); \
1005:                   data = A & X & ((uint8) ((addr >> 8) + 1)); \
1006:                   write_func(addr, data); \
1007:                   ADD_CYCLES(cycles); \
1008:                }
1009:                
1010:                /* undocumented */
1011:                #define SHS(cycles, read_func, write_func, addr) \
1012:                { \
1013:                   read_func(addr); \
1014:                   S = A & X; \
1015:                   data = S & ((uint8) ((addr >> 8) + 1)); \
1016:                   write_func(addr, data); \
1017:                   ADD_CYCLES(cycles); \
1018:                }
1019:                
1020:                /* undocumented */
1021:                #define SHX(cycles, read_func, write_func, addr) \
1022:                { \
1023:                   read_func(addr); \
1024:                   data = X & ((uint8) ((addr >> 8) + 1)); \
1025:                   write_func(addr, data); \
1026:                   ADD_CYCLES(cycles); \
1027:                }
1028:                
1029:                /* undocumented */
1030:                #define SHY(cycles, read_func, write_func, addr) \
1031:                { \
1032:                   read_func(addr); \
1033:                   data = Y & ((uint8) ((addr >> 8 ) + 1)); \
1034:                   write_func(addr, data); \
1035:                   ADD_CYCLES(cycles); \
1036:                }
1037:                
1038:                /* undocumented */
1039:                #define SLO(cycles, read_func, write_func, addr) \
1040:                { \
1041:                   read_func(addr, data); \
1042:                   c_flag = data >> 7; \
1043:                   data <<= 1; \
1044:                   write_func(addr, data); \
1045:                   A |= data; \
1046:                   SET_NZ_FLAGS(A); \
1047:                   ADD_CYCLES(cycles); \
1048:                }
1049:                
1050:                /* undocumented */
1051:                #define SRE(cycles, read_func, write_func, addr) \
1052:                { \
1053:                   read_func(addr, data); \
1054:                   c_flag = data & 1; \
1055:                   data >>= 1; \
1056:                   write_func(addr, data); \
1057:                   A ^= data; \
1058:                   SET_NZ_FLAGS(A); \
1059:                   ADD_CYCLES(cycles); \
1060:                }
1061:                
1062:                #define STA(cycles, read_func, write_func, addr) \
1063:                { \
1064:                   read_func(addr); \
1065:                   write_func(addr, A); \
1066:                   ADD_CYCLES(cycles); \
1067:                }
1068:                
1069:                #define STX(cycles, read_func, write_func, addr) \
1070:                { \
1071:                   read_func(addr); \
1072:                   write_func(addr, X); \
1073:                   ADD_CYCLES(cycles); \
1074:                }
1075:                
1076:                #define STY(cycles, read_func, write_func, addr) \
1077:                { \
1078:                   read_func(addr); \
1079:                   write_func(addr, Y); \
1080:                   ADD_CYCLES(cycles); \
1081:                }
1082:                
1083:                #define TAX() \
1084:                { \
1085:                   X = A; \
1086:                   SET_NZ_FLAGS(X);\
1087:                   ADD_CYCLES(2); \
1088:                }
1089:                
1090:                #define TAY() \
1091:                { \
1092:                   Y = A; \
1093:                   SET_NZ_FLAGS(Y);\
1094:                   ADD_CYCLES(2); \
1095:                }
1096:                
1097:                /* undocumented (triple-NOP) */
1098:                #define TOP() \
1099:                { \
1100:                   PC += 2; \
1101:                   ADD_CYCLES(4); \
1102:                }
1103:                
1104:                #define TSX() \
1105:                { \
1106:                   X = S; \
1107:                   SET_NZ_FLAGS(X);\
1108:                   ADD_CYCLES(2); \
1109:                }
1110:                
1111:                #define TXA() \
1112:                { \
1113:                   A = X; \
1114:                   SET_NZ_FLAGS(A);\
1115:                   ADD_CYCLES(2); \
1116:                }
1117:                
1118:                #define TXS() \
1119:                { \
1120:                   S = X; \
1121:                   ADD_CYCLES(2); \
1122:                }
1123:                
1124:                #define TYA() \
1125:                { \
1126:                   A = Y; \
1127:                   SET_NZ_FLAGS(A); \
1128:                   ADD_CYCLES(2); \
1129:                }
1130:                
1131:                
1132:                
1133:                /* internal CPU context */
1134:                static nes6502_context cpu;
1135:                static int remaining_cycles = 0; /* so we can release timeslice */
1136:                /* memory region pointers */
1137:                static uint8 *ram = NULL, *stack = NULL;
1138:                static uint8 null_page[NES6502_BANKSIZE];
1139:                
1140:                
1141:                /*
1142:                ** Zero-page helper macros
1143:                */
1144:                
1145:                #define  ZP_READBYTE(addr)          ram[(addr)]
1146:                #define  ZP_WRITEBYTE(addr, value)  ram[(addr)] = (uint8) (value)
1147:                
1148:                #ifdef HOST_LITTLE_ENDIAN
1149:                
1150:                /* NOTE: following two functions will fail on architectures
1151:                ** which do not support byte alignment
1152:                */
1153:                INLINE uint32 zp_readword(register uint8 address)
1154:                {
1155:                      return (uint32) (ram[address]) 
9D00A694  304200FF   ANDI V0, V0, 255
9D00A7C4  304200FF   ANDI V0, V0, 255
9D00A7DC  304200FF   ANDI V0, V0, 255
9D00A7E0  AFA2002C   SW V0, 44(SP)
9D00B02C  90420000   LBU V0, 0(V0)
9D00B044  308400FF   ANDI A0, A0, 255
9D00B118  90420000   LBU V0, 0(V0)
9D00B130  304200FF   ANDI V0, V0, 255
9D00B9A8  304200FF   ANDI V0, V0, 255
9D00BA5C  304200FF   ANDI V0, V0, 255
9D00BA74  304200FF   ANDI V0, V0, 255
9D00BA78  AFA2002C   SW V0, 44(SP)
9D00C334  90420000   LBU V0, 0(V0)
9D00C34C  308400FF   ANDI A0, A0, 255
9D00C420  90420000   LBU V0, 0(V0)
9D00C438  304200FF   ANDI V0, V0, 255
9D00CC74  304200FF   ANDI V0, V0, 255
9D00CD28  304200FF   ANDI V0, V0, 255
9D00CD40  304200FF   ANDI V0, V0, 255
9D00CD44  AFA2002C   SW V0, 44(SP)
9D00D4C0  90420000   LBU V0, 0(V0)
9D00D4D8  308400FF   ANDI A0, A0, 255
9D00D5B0  90420000   LBU V0, 0(V0)
9D00D5C8  304200FF   ANDI V0, V0, 255
9D00DD78  304200FF   ANDI V0, V0, 255
9D00DE50  304200FF   ANDI V0, V0, 255
9D00DE68  325200FF   ANDI S2, S2, 255
9D00E7A8  90420000   LBU V0, 0(V0)
9D00E7C0  308400FF   ANDI A0, A0, 255
9D00E8B8  90420000   LBU V0, 0(V0)
9D00E8D0  325200FF   ANDI S2, S2, 255
9D00F108  304200FF   ANDI V0, V0, 255
9D00F1B0  304200FF   ANDI V0, V0, 255
9D00F858  90420000   LBU V0, 0(V0)
9D00F870  308400FF   ANDI A0, A0, 255
9D00F904  90420000   LBU V0, 0(V0)
9D00F91C  308400FF   ANDI A0, A0, 255
9D010034  304200FF   ANDI V0, V0, 255
9D01016C  304200FF   ANDI V0, V0, 255
9D010958  90420000   LBU V0, 0(V0)
9D010970  308400FF   ANDI A0, A0, 255
9D010A3C  90420000   LBU V0, 0(V0)
9D010A54  308400FF   ANDI A0, A0, 255
9D011374  304200FF   ANDI V0, V0, 255
9D011428  304200FF   ANDI V0, V0, 255
9D011440  32F700FF   ANDI S7, S7, 255
9D011C88  90420000   LBU V0, 0(V0)
9D011CA0  308400FF   ANDI A0, A0, 255
9D011D74  90420000   LBU V0, 0(V0)
9D011D8C  32F700FF   ANDI S7, S7, 255
9D012474  304200FF   ANDI V0, V0, 255
9D012550  304200FF   ANDI V0, V0, 255
9D012568  325200FF   ANDI S2, S2, 255
9D012DE4  90420000   LBU V0, 0(V0)
9D012DFC  308400FF   ANDI A0, A0, 255
9D012EF4  90420000   LBU V0, 0(V0)
9D012F0C  325200FF   ANDI S2, S2, 255
1156:                           | (ram[(address+1)]);
9D00A698  8F838054   LW V1, -32684(GP)
9D00A7C8  8F838054   LW V1, -32684(GP)
9D00A7CC  00621021   ADDU V0, V1, V0
9D00A7D0  90430001   LBU V1, 1(V0)
9D00A7D4  90420000   LBU V0, 0(V0)
9D00A7D8  00621025   OR V0, V1, V0
9D00B030  8F838054   LW V1, -32684(GP)
9D00B034  00621021   ADDU V0, V1, V0
9D00B038  90440001   LBU A0, 1(V0)
9D00B03C  90420000   LBU V0, 0(V0)
9D00B040  00822025   OR A0, A0, V0
9D00B11C  8F838054   LW V1, -32684(GP)
9D00B120  00621021   ADDU V0, V1, V0
9D00B124  90430001   LBU V1, 1(V0)
9D00B128  90420000   LBU V0, 0(V0)
9D00B12C  00621025   OR V0, V1, V0
9D00B9AC  8F838054   LW V1, -32684(GP)
9D00B9B0  00621021   ADDU V0, V1, V0
9D00B9B4  90440001   LBU A0, 1(V0)
9D00B9B8  90420000   LBU V0, 0(V0)
9D00B9BC  00822025   OR A0, A0, V0
9D00BA60  8F838054   LW V1, -32684(GP)
9D00BA64  00621021   ADDU V0, V1, V0
9D00BA68  90430001   LBU V1, 1(V0)
9D00BA6C  90420000   LBU V0, 0(V0)
9D00BA70  00621025   OR V0, V1, V0
9D00C338  8F838054   LW V1, -32684(GP)
9D00C33C  00621021   ADDU V0, V1, V0
9D00C340  90440001   LBU A0, 1(V0)
9D00C344  90420000   LBU V0, 0(V0)
9D00C348  00822025   OR A0, A0, V0
9D00C424  8F838054   LW V1, -32684(GP)
9D00C428  00621021   ADDU V0, V1, V0
9D00C42C  90430001   LBU V1, 1(V0)
9D00C430  90420000   LBU V0, 0(V0)
9D00C434  00621025   OR V0, V1, V0
9D00CC78  8F838054   LW V1, -32684(GP)
9D00CC7C  00621021   ADDU V0, V1, V0
9D00CC80  90440001   LBU A0, 1(V0)
9D00CC84  90420000   LBU V0, 0(V0)
9D00CC88  00822025   OR A0, A0, V0
9D00CD2C  8F838054   LW V1, -32684(GP)
9D00CD30  00621021   ADDU V0, V1, V0
9D00CD34  90430001   LBU V1, 1(V0)
9D00CD38  90420000   LBU V0, 0(V0)
9D00CD3C  00621025   OR V0, V1, V0
9D00D4C4  8F838054   LW V1, -32684(GP)
9D00D4C8  00621021   ADDU V0, V1, V0
9D00D4CC  90440001   LBU A0, 1(V0)
9D00D4D0  90420000   LBU V0, 0(V0)
9D00D4D4  00822025   OR A0, A0, V0
9D00D5B4  8F838054   LW V1, -32684(GP)
9D00D5B8  00621021   ADDU V0, V1, V0
9D00D5BC  90430001   LBU V1, 1(V0)
9D00D5C0  90420000   LBU V0, 0(V0)
9D00D5C4  00621025   OR V0, V1, V0
9D00DD7C  8F838054   LW V1, -32684(GP)
9D00DD80  00621021   ADDU V0, V1, V0
9D00DD84  90440001   LBU A0, 1(V0)
9D00DD88  90420000   LBU V0, 0(V0)
9D00DD8C  00822025   OR A0, A0, V0
9D00DE54  8F838054   LW V1, -32684(GP)
9D00DE58  00621021   ADDU V0, V1, V0
9D00DE5C  90520001   LBU S2, 1(V0)
9D00DE60  90420000   LBU V0, 0(V0)
9D00DE64  02429025   OR S2, S2, V0
9D00E7AC  8F838054   LW V1, -32684(GP)
9D00E7B0  00621021   ADDU V0, V1, V0
9D00E7B4  90440001   LBU A0, 1(V0)
9D00E7B8  90420000   LBU V0, 0(V0)
9D00E7BC  00822025   OR A0, A0, V0
9D00E8BC  8F838054   LW V1, -32684(GP)
9D00E8C0  00621021   ADDU V0, V1, V0
9D00E8C4  90520001   LBU S2, 1(V0)
9D00E8C8  90420000   LBU V0, 0(V0)
9D00E8CC  02429025   OR S2, S2, V0
9D00F10C  8F838054   LW V1, -32684(GP)
9D00F110  00621021   ADDU V0, V1, V0
9D00F114  90440001   LBU A0, 1(V0)
9D00F118  90420000   LBU V0, 0(V0)
9D00F11C  00822025   OR A0, A0, V0
9D00F1B4  8F838054   LW V1, -32684(GP)
9D00F1B8  00621021   ADDU V0, V1, V0
9D00F1BC  90440001   LBU A0, 1(V0)
9D00F1C0  90420000   LBU V0, 0(V0)
9D00F1C4  00822025   OR A0, A0, V0
9D00F85C  8F838054   LW V1, -32684(GP)
9D00F860  00621021   ADDU V0, V1, V0
9D00F864  90440001   LBU A0, 1(V0)
9D00F868  90420000   LBU V0, 0(V0)
9D00F86C  00822025   OR A0, A0, V0
9D00F908  8F838054   LW V1, -32684(GP)
9D00F90C  00621021   ADDU V0, V1, V0
9D00F910  90440001   LBU A0, 1(V0)
9D00F914  90420000   LBU V0, 0(V0)
9D00F918  00822025   OR A0, A0, V0
9D010038  8F838054   LW V1, -32684(GP)
9D01003C  00621021   ADDU V0, V1, V0
9D010040  90440001   LBU A0, 1(V0)
9D010044  90420000   LBU V0, 0(V0)
9D010048  00822025   OR A0, A0, V0
9D010170  8F838054   LW V1, -32684(GP)
9D010174  00621021   ADDU V0, V1, V0
9D010178  90440001   LBU A0, 1(V0)
9D01017C  90420000   LBU V0, 0(V0)
9D010180  00822025   OR A0, A0, V0
9D01095C  8F838054   LW V1, -32684(GP)
9D010960  00621021   ADDU V0, V1, V0
9D010964  90440001   LBU A0, 1(V0)
9D010968  90420000   LBU V0, 0(V0)
9D01096C  00822025   OR A0, A0, V0
9D010A40  8F838054   LW V1, -32684(GP)
9D010A44  00621021   ADDU V0, V1, V0
9D010A48  90440001   LBU A0, 1(V0)
9D010A4C  90420000   LBU V0, 0(V0)
9D010A50  00822025   OR A0, A0, V0
9D011378  8F838054   LW V1, -32684(GP)
9D01137C  00621021   ADDU V0, V1, V0
9D011380  90440001   LBU A0, 1(V0)
9D011384  90420000   LBU V0, 0(V0)
9D011388  00822025   OR A0, A0, V0
9D01142C  8F838054   LW V1, -32684(GP)
9D011430  00621021   ADDU V0, V1, V0
9D011434  90570001   LBU S7, 1(V0)
9D011438  90420000   LBU V0, 0(V0)
9D01143C  02E2B825   OR S7, S7, V0
9D011C8C  8F838054   LW V1, -32684(GP)
9D011C90  00621021   ADDU V0, V1, V0
9D011C94  90440001   LBU A0, 1(V0)
9D011C98  90420000   LBU V0, 0(V0)
9D011C9C  00822025   OR A0, A0, V0
9D011D78  8F838054   LW V1, -32684(GP)
9D011D7C  00621021   ADDU V0, V1, V0
9D011D80  90570001   LBU S7, 1(V0)
9D011D84  90420000   LBU V0, 0(V0)
9D011D88  02E2B825   OR S7, S7, V0
9D012478  8F838054   LW V1, -32684(GP)
9D01247C  00621021   ADDU V0, V1, V0
9D012480  90440001   LBU A0, 1(V0)
9D012484  90420000   LBU V0, 0(V0)
9D012488  00822025   OR A0, A0, V0
9D012554  8F838054   LW V1, -32684(GP)
9D012558  00621021   ADDU V0, V1, V0
9D01255C  90520001   LBU S2, 1(V0)
9D012560  90420000   LBU V0, 0(V0)
9D012564  02429025   OR S2, S2, V0
9D012DE8  8F838054   LW V1, -32684(GP)
9D012DEC  00621021   ADDU V0, V1, V0
9D012DF0  90440001   LBU A0, 1(V0)
9D012DF4  90420000   LBU V0, 0(V0)
9D012DF8  00822025   OR A0, A0, V0
9D012EF8  8F838054   LW V1, -32684(GP)
9D012EFC  00621021   ADDU V0, V1, V0
9D012F00  90520001   LBU S2, 1(V0)
9D012F04  90420000   LBU V0, 0(V0)
9D012F08  02429025   OR S2, S2, V0
1157:                }
1158:                
1159:                int a;
1160:                uint32 bank_readword(register uint32 address)
1161:                {
1162:                   /* technically, this should fail if the address is $xFFF, but
1163:                   ** any code that does this would be suspect anyway, as it would
1164:                   ** be fetching a word across page boundaries, which only would
1165:                   ** make sense if the banks were physically consecutive.
1166:                   */ 
1167:                   return (uint32) (cpu.mem_page[address >> NES6502_BANKSHIFT][address & NES6502_BANKMASK]) 
9D00A1B0  00042B02   SRL A1, A0, 12
9D00A1B4  00052880   SLL A1, A1, 2
9D00A1B8  00A21021   ADDU V0, A1, V0
9D00A1BC  30840FFF   ANDI A0, A0, 4095
9D00A1C0  8C420000   LW V0, 0(V0)
9D00A1C4  00442021   ADDU A0, V0, A0
1168:                           | (cpu.mem_page[(address+1) >> NES6502_BANKSHIFT][(address+1) & NES6502_BANKMASK]);
9D00A18C  24830001   ADDIU V1, A0, 1
9D00A190  00032B02   SRL A1, V1, 12
9D00A194  00052880   SLL A1, A1, 2
9D00A198  3C02A001   LUI V0, -24575
9D00A19C  24428FD8   ADDIU V0, V0, -28712
9D00A1A0  00A22821   ADDU A1, A1, V0
9D00A1A4  30630FFF   ANDI V1, V1, 4095
9D00A1A8  8CA50000   LW A1, 0(A1)
9D00A1AC  00A31821   ADDU V1, A1, V1
9D00A1C8  90630000   LBU V1, 0(V1)
9D00A1CC  90820000   LBU V0, 0(A0)
9D00A1D0  00621025   OR V0, V1, V0
1169:                }
9D00A1D4  03E00008   JR RA
9D00A1D8  304200FF   ANDI V0, V0, 255
1170:                #else /* !HOST_LITTLE_ENDIAN */
1171:                
1172:                INLINE uint32 zp_readword(register uint8 address)
1173:                {
1174:                #ifdef TARGET_CPU_PPC
1175:                   return __lhbrx(ram, address);
1176:                #else /* !TARGET_CPU_PPC */
1177:                   uint32 x = (uint32) *(uint16 *)(ram + address);
1178:                   return (x << 8) | (x >> 8);
1179:                #endif /* !TARGET_CPU_PPC */
1180:                }
1181:                
1182:                INLINE uint32 bank_readword(register uint32 address)
1183:                {
1184:                #ifdef TARGET_CPU_PPC
1185:                   return __lhbrx(cpu.mem_page[address >> NES6502_BANKSHIFT], address & NES6502_BANKMASK);
1186:                #else /* !TARGET_CPU_PPC */
1187:                   uint32 x = (uint32) *(uint16 *)(cpu.mem_page[address >> NES6502_BANKSHIFT] + (address & NES6502_BANKMASK));
1188:                   return (x << 8) | (x >> 8);
1189:                #endif /* !TARGET_CPU_PPC */
1190:                }
1191:                
1192:                #endif /* !HOST_LITTLE_ENDIAN */
1193:                
1194:                INLINE uint8 bank_readbyte(register uint32 address)
1195:                {
1196:                   return cpu.mem_page[address >> NES6502_BANKSHIFT][address & NES6502_BANKMASK];
9D00A040  00041B02   SRL V1, A0, 12
9D00A0B8  00041B02   SRL V1, A0, 12
9D00A2F8  00041B02   SRL V1, A0, 12
9D00A2FC  00031880   SLL V1, V1, 2
9D00A300  3C02A001   LUI V0, -24575
9D00A304  24428FD8   ADDIU V0, V0, -28712
9D00A308  00621021   ADDU V0, V1, V0
9D00A30C  30840FFF   ANDI A0, A0, 4095
9D00A310  8C420000   LW V0, 0(V0)
9D00A314  00442021   ADDU A0, V0, A0
9D00A508  00111B02   SRL V1, S1, 12
9D00A62C  00111B02   SRL V1, S1, 12
9D00A670  00101B02   SRL V1, S0, 12
9D00A6E8  00111B02   SRL V1, S1, 12
9D00A7A0  00101B02   SRL V1, S0, 12
9D00A838  00111B02   SRL V1, S1, 12
9D00A83C  00031880   SLL V1, V1, 2
9D00A840  26628FD8   ADDIU V0, S3, -28712
9D00A844  00621021   ADDU V0, V1, V0
9D00A848  32310FFF   ANDI S1, S1, 4095
9D00A84C  8C420000   LW V0, 0(V0)
9D00A850  00511021   ADDU V0, V0, S1
9D00A8A0  00111B02   SRL V1, S1, 12
9D00A8A4  00031880   SLL V1, V1, 2
9D00A8A8  26628FD8   ADDIU V0, S3, -28712
9D00A8AC  00621021   ADDU V0, V1, V0
9D00A8B0  32310FFF   ANDI S1, S1, 4095
9D00A8B4  8C420000   LW V0, 0(V0)
9D00A8B8  00511021   ADDU V0, V0, S1
9D00A8D4  00102302   SRL A0, S0, 12
9D00A8D8  00042080   SLL A0, A0, 2
9D00A8DC  26628FD8   ADDIU V0, S3, -28712
9D00A8E0  00822021   ADDU A0, A0, V0
9D00A8E4  32030FFF   ANDI V1, S0, 4095
9D00A8E8  8C840000   LW A0, 0(A0)
9D00A8EC  00831821   ADDU V1, A0, V1
9D00A934  00111B02   SRL V1, S1, 12
9D00A938  00031880   SLL V1, V1, 2
9D00A93C  26628FD8   ADDIU V0, S3, -28712
9D00A940  00621021   ADDU V0, V1, V0
9D00A944  32310FFF   ANDI S1, S1, 4095
9D00A948  8C420000   LW V0, 0(V0)
9D00A94C  00511021   ADDU V0, V0, S1
9D00A970  00102302   SRL A0, S0, 12
9D00A974  00042080   SLL A0, A0, 2
9D00A978  26628FD8   ADDIU V0, S3, -28712
9D00A97C  00822021   ADDU A0, A0, V0
9D00A980  32030FFF   ANDI V1, S0, 4095
9D00A984  8C840000   LW A0, 0(A0)
9D00A988  00831821   ADDU V1, A0, V1
9D00A9D4  00111B02   SRL V1, S1, 12
9D00A9D8  00031880   SLL V1, V1, 2
9D00A9DC  26628FD8   ADDIU V0, S3, -28712
9D00A9E0  00621021   ADDU V0, V1, V0
9D00A9E4  32310FFF   ANDI S1, S1, 4095
9D00A9E8  8C420000   LW V0, 0(V0)
9D00A9EC  00511021   ADDU V0, V0, S1
9D00AA0C  00102302   SRL A0, S0, 12
9D00AA10  00042080   SLL A0, A0, 2
9D00AA14  26628FD8   ADDIU V0, S3, -28712
9D00AA18  00822021   ADDU A0, A0, V0
9D00AA1C  32030FFF   ANDI V1, S0, 4095
9D00AA20  8C840000   LW A0, 0(A0)
9D00AA24  00831821   ADDU V1, A0, V1
9D00AA7C  00111B02   SRL V1, S1, 12
9D00AA80  00031880   SLL V1, V1, 2
9D00AA84  26628FD8   ADDIU V0, S3, -28712
9D00AA88  00621021   ADDU V0, V1, V0
9D00AA8C  32310FFF   ANDI S1, S1, 4095
9D00AA90  8C420000   LW V0, 0(V0)
9D00AA94  00511021   ADDU V0, V0, S1
9D00AB5C  00101B02   SRL V1, S0, 12
9D00AB60  00031880   SLL V1, V1, 2
9D00AB64  26628FD8   ADDIU V0, S3, -28712
9D00AB68  00621821   ADDU V1, V1, V0
9D00AB6C  32020FFF   ANDI V0, S0, 4095
9D00AB70  8C630000   LW V1, 0(V1)
9D00AB74  00621021   ADDU V0, V1, V0
9D00AB98  00102302   SRL A0, S0, 12
9D00AB9C  00042080   SLL A0, A0, 2
9D00ABA0  26628FD8   ADDIU V0, S3, -28712
9D00ABA4  00822021   ADDU A0, A0, V0
9D00ABA8  32030FFF   ANDI V1, S0, 4095
9D00ABAC  8C840000   LW A0, 0(A0)
9D00ABB0  00831821   ADDU V1, A0, V1
9D00ABEC  00111B02   SRL V1, S1, 12
9D00ABF0  00031880   SLL V1, V1, 2
9D00ABF4  26628FD8   ADDIU V0, S3, -28712
9D00ABF8  00621021   ADDU V0, V1, V0
9D00ABFC  32310FFF   ANDI S1, S1, 4095
9D00AC00  8C420000   LW V0, 0(V0)
9D00AC04  00511021   ADDU V0, V0, S1
9D00AC60  00101B02   SRL V1, S0, 12
9D00AC64  00031880   SLL V1, V1, 2
9D00AC68  26628FD8   ADDIU V0, S3, -28712
9D00AC6C  00621821   ADDU V1, V1, V0
9D00AC70  32020FFF   ANDI V0, S0, 4095
9D00AC74  8C630000   LW V1, 0(V1)
9D00AC78  00621021   ADDU V0, V1, V0
9D00ACA0  00102302   SRL A0, S0, 12
9D00ACA4  00042080   SLL A0, A0, 2
9D00ACA8  26628FD8   ADDIU V0, S3, -28712
9D00ACAC  00822021   ADDU A0, A0, V0
9D00ACB0  32030FFF   ANDI V1, S0, 4095
9D00ACB4  8C840000   LW A0, 0(A0)
9D00ACB8  00831821   ADDU V1, A0, V1
9D00ACF4  00111B02   SRL V1, S1, 12
9D00ACF8  00031880   SLL V1, V1, 2
9D00ACFC  26628FD8   ADDIU V0, S3, -28712
9D00AD00  00621021   ADDU V0, V1, V0
9D00AD04  32310FFF   ANDI S1, S1, 4095
9D00AD08  8C420000   LW V0, 0(V0)
9D00AD0C  00511021   ADDU V0, V0, S1
9D00AD54  00111B02   SRL V1, S1, 12
9D00AD58  00031880   SLL V1, V1, 2
9D00AD5C  26628FD8   ADDIU V0, S3, -28712
9D00AD60  00621021   ADDU V0, V1, V0
9D00AD64  32310FFF   ANDI S1, S1, 4095
9D00AD68  8C420000   LW V0, 0(V0)
9D00AD6C  00511021   ADDU V0, V0, S1
9D00ADD0  00111B02   SRL V1, S1, 12
9D00ADD4  00031880   SLL V1, V1, 2
9D00ADD8  26628FD8   ADDIU V0, S3, -28712
9D00ADDC  00621021   ADDU V0, V1, V0
9D00ADE0  32310FFF   ANDI S1, S1, 4095
9D00ADE4  8C420000   LW V0, 0(V0)
9D00ADE8  00511021   ADDU V0, V0, S1
9D00AE64  00111B02   SRL V1, S1, 12
9D00AE68  00031880   SLL V1, V1, 2
9D00AE6C  26628FD8   ADDIU V0, S3, -28712
9D00AE70  00621021   ADDU V0, V1, V0
9D00AE74  32310FFF   ANDI S1, S1, 4095
9D00AE78  8C420000   LW V0, 0(V0)
9D00AE7C  00511021   ADDU V0, V0, S1
9D00AF00  00111B02   SRL V1, S1, 12
9D00AF04  00031880   SLL V1, V1, 2
9D00AF08  26628FD8   ADDIU V0, S3, -28712
9D00AF0C  00621021   ADDU V0, V1, V0
9D00AF10  32310FFF   ANDI S1, S1, 4095
9D00AF14  8C420000   LW V0, 0(V0)
9D00AF18  00511021   ADDU V0, V0, S1
9D00AF44  00102302   SRL A0, S0, 12
9D00AF48  00042080   SLL A0, A0, 2
9D00AF4C  26638FD8   ADDIU V1, S3, -28712
9D00AF50  00831821   ADDU V1, A0, V1
9D00AF54  32100FFF   ANDI S0, S0, 4095
9D00AF58  8C630000   LW V1, 0(V1)
9D00AF5C  00701821   ADDU V1, V1, S0
9D00AFE0  00111B02   SRL V1, S1, 12
9D00AFE4  00031880   SLL V1, V1, 2
9D00AFE8  26628FD8   ADDIU V0, S3, -28712
9D00AFEC  00621021   ADDU V0, V1, V0
9D00AFF0  32310FFF   ANDI S1, S1, 4095
9D00AFF4  8C420000   LW V0, 0(V0)
9D00AFF8  00511021   ADDU V0, V0, S1
9D00B010  00101B02   SRL V1, S0, 12
9D00B014  00031880   SLL V1, V1, 2
9D00B018  26628FD8   ADDIU V0, S3, -28712
9D00B01C  00621821   ADDU V1, V1, V0
9D00B020  32020FFF   ANDI V0, S0, 4095
9D00B024  8C630000   LW V1, 0(V1)
9D00B028  00621021   ADDU V0, V1, V0
9D00B0C0  00111B02   SRL V1, S1, 12
9D00B0C4  00031880   SLL V1, V1, 2
9D00B0C8  26628FD8   ADDIU V0, S3, -28712
9D00B0CC  00621021   ADDU V0, V1, V0
9D00B0D0  32310FFF   ANDI S1, S1, 4095
9D00B0D4  8C420000   LW V0, 0(V0)
9D00B0D8  00511021   ADDU V0, V0, S1
9D00B0FC  00101B02   SRL V1, S0, 12
9D00B100  00031880   SLL V1, V1, 2
9D00B104  26758FD8   ADDIU S5, S3, -28712
9D00B108  00751821   ADDU V1, V1, S5
9D00B10C  32020FFF   ANDI V0, S0, 4095
9D00B110  8C630000   LW V1, 0(V1)
9D00B114  00621021   ADDU V0, V1, V0
9D00B198  00111B02   SRL V1, S1, 12
9D00B19C  00031880   SLL V1, V1, 2
9D00B1A0  26628FD8   ADDIU V0, S3, -28712
9D00B1A4  00621021   ADDU V0, V1, V0
9D00B1A8  32310FFF   ANDI S1, S1, 4095
9D00B1AC  8C420000   LW V0, 0(V0)
9D00B1B0  00511021   ADDU V0, V0, S1
9D00B218  00111B02   SRL V1, S1, 12
9D00B21C  00031880   SLL V1, V1, 2
9D00B220  26628FD8   ADDIU V0, S3, -28712
9D00B224  00621021   ADDU V0, V1, V0
9D00B228  32310FFF   ANDI S1, S1, 4095
9D00B22C  8C420000   LW V0, 0(V0)
9D00B230  00518821   ADDU S1, V0, S1
9D00B24C  00102302   SRL A0, S0, 12
9D00B250  00042080   SLL A0, A0, 2
9D00B254  26628FD8   ADDIU V0, S3, -28712
9D00B258  00822021   ADDU A0, A0, V0
9D00B25C  32030FFF   ANDI V1, S0, 4095
9D00B260  8C840000   LW A0, 0(A0)
9D00B264  00831821   ADDU V1, A0, V1
9D00B2B4  00111B02   SRL V1, S1, 12
9D00B2B8  00031880   SLL V1, V1, 2
9D00B2BC  26628FD8   ADDIU V0, S3, -28712
9D00B2C0  00621021   ADDU V0, V1, V0
9D00B2C4  32310FFF   ANDI S1, S1, 4095
9D00B2C8  8C420000   LW V0, 0(V0)
9D00B2CC  00511021   ADDU V0, V0, S1
9D00B2F0  00102302   SRL A0, S0, 12
9D00B2F4  00042080   SLL A0, A0, 2
9D00B2F8  26628FD8   ADDIU V0, S3, -28712
9D00B2FC  00822021   ADDU A0, A0, V0
9D00B300  32030FFF   ANDI V1, S0, 4095
9D00B304  8C840000   LW A0, 0(A0)
9D00B308  00831821   ADDU V1, A0, V1
9D00B35C  00111B02   SRL V1, S1, 12
9D00B360  00031880   SLL V1, V1, 2
9D00B364  26628FD8   ADDIU V0, S3, -28712
9D00B368  00621021   ADDU V0, V1, V0
9D00B36C  32310FFF   ANDI S1, S1, 4095
9D00B370  8C420000   LW V0, 0(V0)
9D00B374  00511021   ADDU V0, V0, S1
9D00B394  00102302   SRL A0, S0, 12
9D00B398  00042080   SLL A0, A0, 2
9D00B39C  26628FD8   ADDIU V0, S3, -28712
9D00B3A0  00822021   ADDU A0, A0, V0
9D00B3A4  32030FFF   ANDI V1, S0, 4095
9D00B3A8  8C840000   LW A0, 0(A0)
9D00B3AC  00831821   ADDU V1, A0, V1
9D00B40C  00111B02   SRL V1, S1, 12
9D00B410  00031880   SLL V1, V1, 2
9D00B414  26628FD8   ADDIU V0, S3, -28712
9D00B418  00621021   ADDU V0, V1, V0
9D00B41C  32310FFF   ANDI S1, S1, 4095
9D00B420  8C420000   LW V0, 0(V0)
9D00B424  00511021   ADDU V0, V0, S1
9D00B470  00101B02   SRL V1, S0, 12
9D00B474  00031880   SLL V1, V1, 2
9D00B478  26628FD8   ADDIU V0, S3, -28712
9D00B47C  00621821   ADDU V1, V1, V0
9D00B480  32020FFF   ANDI V0, S0, 4095
9D00B484  8C630000   LW V1, 0(V1)
9D00B488  00621021   ADDU V0, V1, V0
9D00B528  00111B02   SRL V1, S1, 12
9D00B52C  00031880   SLL V1, V1, 2
9D00B530  26628FD8   ADDIU V0, S3, -28712
9D00B534  00621021   ADDU V0, V1, V0
9D00B538  32310FFF   ANDI S1, S1, 4095
9D00B53C  8C420000   LW V0, 0(V0)
9D00B540  00511021   ADDU V0, V0, S1
9D00B5A8  00101B02   SRL V1, S0, 12
9D00B5AC  00031880   SLL V1, V1, 2
9D00B5B0  26628FD8   ADDIU V0, S3, -28712
9D00B5B4  00621821   ADDU V1, V1, V0
9D00B5B8  32020FFF   ANDI V0, S0, 4095
9D00B5BC  8C630000   LW V1, 0(V1)
9D00B5C0  00621021   ADDU V0, V1, V0
9D00B64C  00111B02   SRL V1, S1, 12
9D00B650  00031880   SLL V1, V1, 2
9D00B654  26628FD8   ADDIU V0, S3, -28712
9D00B658  00621021   ADDU V0, V1, V0
9D00B65C  32310FFF   ANDI S1, S1, 4095
9D00B660  8C420000   LW V0, 0(V0)
9D00B664  00511021   ADDU V0, V0, S1
9D00B6CC  00111B02   SRL V1, S1, 12
9D00B6D0  00031880   SLL V1, V1, 2
9D00B6D4  26628FD8   ADDIU V0, S3, -28712
9D00B6D8  00621021   ADDU V0, V1, V0
9D00B6DC  32310FFF   ANDI S1, S1, 4095
9D00B6E0  8C420000   LW V0, 0(V0)
9D00B6E4  00518821   ADDU S1, V0, S1
9D00B778  00111B02   SRL V1, S1, 12
9D00B77C  00031880   SLL V1, V1, 2
9D00B780  26628FD8   ADDIU V0, S3, -28712
9D00B784  00621021   ADDU V0, V1, V0
9D00B788  32310FFF   ANDI S1, S1, 4095
9D00B78C  8C420000   LW V0, 0(V0)
9D00B790  00511021   ADDU V0, V0, S1
9D00B810  00111B02   SRL V1, S1, 12
9D00B814  00031880   SLL V1, V1, 2
9D00B818  26628FD8   ADDIU V0, S3, -28712
9D00B81C  00621021   ADDU V0, V1, V0
9D00B820  32310FFF   ANDI S1, S1, 4095
9D00B824  8C420000   LW V0, 0(V0)
9D00B828  00511021   ADDU V0, V0, S1
9D00B8B0  00111B02   SRL V1, S1, 12
9D00B8B4  00031880   SLL V1, V1, 2
9D00B8B8  26628FD8   ADDIU V0, S3, -28712
9D00B8BC  00621021   ADDU V0, V1, V0
9D00B8C0  32310FFF   ANDI S1, S1, 4095
9D00B8C4  8C420000   LW V0, 0(V0)
9D00B8C8  00511021   ADDU V0, V0, S1
9D00B950  00111B02   SRL V1, S1, 12
9D00B954  00031880   SLL V1, V1, 2
9D00B958  26628FD8   ADDIU V0, S3, -28712
9D00B95C  00621021   ADDU V0, V1, V0
9D00B960  32310FFF   ANDI S1, S1, 4095
9D00B964  8C420000   LW V0, 0(V0)
9D00B968  00511021   ADDU V0, V0, S1
9D00B984  00101B02   SRL V1, S0, 12
9D00B988  00031880   SLL V1, V1, 2
9D00B98C  26758FD8   ADDIU S5, S3, -28712
9D00B990  00751821   ADDU V1, V1, S5
9D00B994  32020FFF   ANDI V0, S0, 4095
9D00B998  8C630000   LW V1, 0(V1)
9D00B99C  00621021   ADDU V0, V1, V0
9D00B9FC  00111B02   SRL V1, S1, 12
9D00BA00  00031880   SLL V1, V1, 2
9D00BA04  26628FD8   ADDIU V0, S3, -28712
9D00BA08  00621021   ADDU V0, V1, V0
9D00BA0C  32310FFF   ANDI S1, S1, 4095
9D00BA10  8C420000   LW V0, 0(V0)
9D00BA14  00511021   ADDU V0, V0, S1
9D00BA38  00101B02   SRL V1, S0, 12
9D00BA3C  00031880   SLL V1, V1, 2
9D00BA40  26758FD8   ADDIU S5, S3, -28712
9D00BA44  00751821   ADDU V1, V1, S5
9D00BA48  32020FFF   ANDI V0, S0, 4095
9D00BA4C  8C630000   LW V1, 0(V1)
9D00BA50  00621021   ADDU V0, V1, V0
9D00BAD8  00111B02   SRL V1, S1, 12
9D00BADC  00031880   SLL V1, V1, 2
9D00BAE0  26628FD8   ADDIU V0, S3, -28712
9D00BAE4  00621021   ADDU V0, V1, V0
9D00BAE8  32310FFF   ANDI S1, S1, 4095
9D00BAEC  8C420000   LW V0, 0(V0)
9D00BAF0  00511021   ADDU V0, V0, S1
9D00BB18  00102302   SRL A0, S0, 12
9D00BB1C  00042080   SLL A0, A0, 2
9D00BB20  26628FD8   ADDIU V0, S3, -28712
9D00BB24  00822021   ADDU A0, A0, V0
9D00BB28  32030FFF   ANDI V1, S0, 4095
9D00BB2C  8C840000   LW A0, 0(A0)
9D00BB30  00831821   ADDU V1, A0, V1
9D00BB74  00111B02   SRL V1, S1, 12
9D00BB78  00031880   SLL V1, V1, 2
9D00BB7C  00621021   ADDU V0, V1, V0
9D00BB80  32310FFF   ANDI S1, S1, 4095
9D00BB84  8C420000   LW V0, 0(V0)
9D00BB88  00511021   ADDU V0, V0, S1
9D00BBA4  00102302   SRL A0, S0, 12
9D00BBA8  00042080   SLL A0, A0, 2
9D00BBAC  26628FD8   ADDIU V0, S3, -28712
9D00BBB0  00822021   ADDU A0, A0, V0
9D00BBB4  32030FFF   ANDI V1, S0, 4095
9D00BBB8  8C840000   LW A0, 0(A0)
9D00BBBC  00831821   ADDU V1, A0, V1
9D00BC00  00111B02   SRL V1, S1, 12
9D00BC04  00031880   SLL V1, V1, 2
9D00BC08  26628FD8   ADDIU V0, S3, -28712
9D00BC0C  00621021   ADDU V0, V1, V0
9D00BC10  32310FFF   ANDI S1, S1, 4095
9D00BC14  8C420000   LW V0, 0(V0)
9D00BC18  00511021   ADDU V0, V0, S1
9D00BC3C  00102302   SRL A0, S0, 12
9D00BC40  00042080   SLL A0, A0, 2
9D00BC44  26628FD8   ADDIU V0, S3, -28712
9D00BC48  00822021   ADDU A0, A0, V0
9D00BC4C  32030FFF   ANDI V1, S0, 4095
9D00BC50  8C840000   LW A0, 0(A0)
9D00BC54  00831821   ADDU V1, A0, V1
9D00BCA8  00111B02   SRL V1, S1, 12
9D00BCAC  00031880   SLL V1, V1, 2
9D00BCB0  26628FD8   ADDIU V0, S3, -28712
9D00BCB4  00621021   ADDU V0, V1, V0
9D00BCB8  32310FFF   ANDI S1, S1, 4095
9D00BCBC  8C420000   LW V0, 0(V0)
9D00BCC0  00511021   ADDU V0, V0, S1
9D00BCE4  00102302   SRL A0, S0, 12
9D00BCE8  00042080   SLL A0, A0, 2
9D00BCEC  26628FD8   ADDIU V0, S3, -28712
9D00BCF0  00822021   ADDU A0, A0, V0
9D00BCF4  32030FFF   ANDI V1, S0, 4095
9D00BCF8  8C840000   LW A0, 0(A0)
9D00BCFC  00831821   ADDU V1, A0, V1
9D00BD58  00111B02   SRL V1, S1, 12
9D00BD5C  00031880   SLL V1, V1, 2
9D00BD60  26628FD8   ADDIU V0, S3, -28712
9D00BD64  00621021   ADDU V0, V1, V0
9D00BD68  32310FFF   ANDI S1, S1, 4095
9D00BD6C  8C420000   LW V0, 0(V0)
9D00BD70  00511021   ADDU V0, V0, S1
9D00BE1C  00101B02   SRL V1, S0, 12
9D00BE20  00031880   SLL V1, V1, 2
9D00BE24  26628FD8   ADDIU V0, S3, -28712
9D00BE28  00621821   ADDU V1, V1, V0
9D00BE2C  32020FFF   ANDI V0, S0, 4095
9D00BE30  8C630000   LW V1, 0(V1)
9D00BE34  00621021   ADDU V0, V1, V0
9D00BE54  00102302   SRL A0, S0, 12
9D00BE58  00042080   SLL A0, A0, 2
9D00BE5C  26628FD8   ADDIU V0, S3, -28712
9D00BE60  00822021   ADDU A0, A0, V0
9D00BE64  32030FFF   ANDI V1, S0, 4095
9D00BE68  8C840000   LW A0, 0(A0)
9D00BE6C  00831821   ADDU V1, A0, V1
9D00BEA4  00111B02   SRL V1, S1, 12
9D00BEA8  00031880   SLL V1, V1, 2
9D00BEAC  26628FD8   ADDIU V0, S3, -28712
9D00BEB0  00621021   ADDU V0, V1, V0
9D00BEB4  32310FFF   ANDI S1, S1, 4095
9D00BEB8  8C420000   LW V0, 0(V0)
9D00BEBC  00511021   ADDU V0, V0, S1
9D00BF20  00101B02   SRL V1, S0, 12
9D00BF24  00031880   SLL V1, V1, 2
9D00BF28  26628FD8   ADDIU V0, S3, -28712
9D00BF2C  00621821   ADDU V1, V1, V0
9D00BF30  32020FFF   ANDI V0, S0, 4095
9D00BF34  8C630000   LW V1, 0(V1)
9D00BF38  00621021   ADDU V0, V1, V0
9D00BF64  00102302   SRL A0, S0, 12
9D00BF68  00042080   SLL A0, A0, 2
9D00BF6C  26628FD8   ADDIU V0, S3, -28712
9D00BF70  00822021   ADDU A0, A0, V0
9D00BF74  32030FFF   ANDI V1, S0, 4095
9D00BF78  8C840000   LW A0, 0(A0)
9D00BF7C  00831821   ADDU V1, A0, V1
9D00BFB8  00111B02   SRL V1, S1, 12
9D00BFBC  00031880   SLL V1, V1, 2
9D00BFC0  26628FD8   ADDIU V0, S3, -28712
9D00BFC4  00621021   ADDU V0, V1, V0
9D00BFC8  32310FFF   ANDI S1, S1, 4095
9D00BFCC  8C420000   LW V0, 0(V0)
9D00BFD0  00511021   ADDU V0, V0, S1
9D00C040  00111B02   SRL V1, S1, 12
9D00C044  00031880   SLL V1, V1, 2
9D00C048  26628FD8   ADDIU V0, S3, -28712
9D00C04C  00621021   ADDU V0, V1, V0
9D00C050  32310FFF   ANDI S1, S1, 4095
9D00C054  8C420000   LW V0, 0(V0)
9D00C058  00511021   ADDU V0, V0, S1
9D00C0BC  00111B02   SRL V1, S1, 12
9D00C0C0  00031880   SLL V1, V1, 2
9D00C0C4  26628FD8   ADDIU V0, S3, -28712
9D00C0C8  00621021   ADDU V0, V1, V0
9D00C0CC  32310FFF   ANDI S1, S1, 4095
9D00C0D0  8C420000   LW V0, 0(V0)
9D00C0D4  00511021   ADDU V0, V0, S1
9D00C15C  00111B02   SRL V1, S1, 12
9D00C160  00031880   SLL V1, V1, 2
9D00C164  26628FD8   ADDIU V0, S3, -28712
9D00C168  00621021   ADDU V0, V1, V0
9D00C16C  32310FFF   ANDI S1, S1, 4095
9D00C170  8C420000   LW V0, 0(V0)
9D00C174  00511021   ADDU V0, V0, S1
9D00C204  00111B02   SRL V1, S1, 12
9D00C208  00031880   SLL V1, V1, 2
9D00C20C  26628FD8   ADDIU V0, S3, -28712
9D00C210  00621021   ADDU V0, V1, V0
9D00C214  32310FFF   ANDI S1, S1, 4095
9D00C218  8C420000   LW V0, 0(V0)
9D00C21C  00511021   ADDU V0, V0, S1
9D00C250  00102302   SRL A0, S0, 12
9D00C254  00042080   SLL A0, A0, 2
9D00C258  26638FD8   ADDIU V1, S3, -28712
9D00C25C  00831821   ADDU V1, A0, V1
9D00C260  32100FFF   ANDI S0, S0, 4095
9D00C264  8C630000   LW V1, 0(V1)
9D00C268  00701821   ADDU V1, V1, S0
9D00C2E8  00111B02   SRL V1, S1, 12
9D00C2EC  00031880   SLL V1, V1, 2
9D00C2F0  26628FD8   ADDIU V0, S3, -28712
9D00C2F4  00621021   ADDU V0, V1, V0
9D00C2F8  32310FFF   ANDI S1, S1, 4095
9D00C2FC  8C420000   LW V0, 0(V0)
9D00C300  00511021   ADDU V0, V0, S1
9D00C318  00101B02   SRL V1, S0, 12
9D00C31C  00031880   SLL V1, V1, 2
9D00C320  26628FD8   ADDIU V0, S3, -28712
9D00C324  00621821   ADDU V1, V1, V0
9D00C328  32020FFF   ANDI V0, S0, 4095
9D00C32C  8C630000   LW V1, 0(V1)
9D00C330  00621021   ADDU V0, V1, V0
9D00C3C8  00111B02   SRL V1, S1, 12
9D00C3CC  00031880   SLL V1, V1, 2
9D00C3D0  26628FD8   ADDIU V0, S3, -28712
9D00C3D4  00621021   ADDU V0, V1, V0
9D00C3D8  32310FFF   ANDI S1, S1, 4095
9D00C3DC  8C420000   LW V0, 0(V0)
9D00C3E0  00511021   ADDU V0, V0, S1
9D00C404  00101B02   SRL V1, S0, 12
9D00C408  00031880   SLL V1, V1, 2
9D00C40C  26758FD8   ADDIU S5, S3, -28712
9D00C410  00751821   ADDU V1, V1, S5
9D00C414  32020FFF   ANDI V0, S0, 4095
9D00C418  8C630000   LW V1, 0(V1)
9D00C41C  00621021   ADDU V0, V1, V0
9D00C4A8  00111B02   SRL V1, S1, 12
9D00C4AC  00031880   SLL V1, V1, 2
9D00C4B0  26628FD8   ADDIU V0, S3, -28712
9D00C4B4  00621021   ADDU V0, V1, V0
9D00C4B8  32310FFF   ANDI S1, S1, 4095
9D00C4BC  8C420000   LW V0, 0(V0)
9D00C4C0  00511021   ADDU V0, V0, S1
9D00C4E8  00102302   SRL A0, S0, 12
9D00C4EC  00042080   SLL A0, A0, 2
9D00C4F0  26628FD8   ADDIU V0, S3, -28712
9D00C4F4  00822021   ADDU A0, A0, V0
9D00C4F8  32030FFF   ANDI V1, S0, 4095
9D00C4FC  8C840000   LW A0, 0(A0)
9D00C500  00831821   ADDU V1, A0, V1
9D00C54C  00111B02   SRL V1, S1, 12
9D00C550  00031880   SLL V1, V1, 2
9D00C554  26628FD8   ADDIU V0, S3, -28712
9D00C558  00621021   ADDU V0, V1, V0
9D00C55C  32310FFF   ANDI S1, S1, 4095
9D00C560  8C420000   LW V0, 0(V0)
9D00C564  00511021   ADDU V0, V0, S1
9D00C588  00102302   SRL A0, S0, 12
9D00C58C  00042080   SLL A0, A0, 2
9D00C590  26628FD8   ADDIU V0, S3, -28712
9D00C594  00822021   ADDU A0, A0, V0
9D00C598  32030FFF   ANDI V1, S0, 4095
9D00C59C  8C840000   LW A0, 0(A0)
9D00C5A0  00831821   ADDU V1, A0, V1
9D00C5FC  00111B02   SRL V1, S1, 12
9D00C600  00031880   SLL V1, V1, 2
9D00C604  26628FD8   ADDIU V0, S3, -28712
9D00C608  00621021   ADDU V0, V1, V0
9D00C60C  32310FFF   ANDI S1, S1, 4095
9D00C610  8C420000   LW V0, 0(V0)
9D00C614  00511021   ADDU V0, V0, S1
9D00C638  00102302   SRL A0, S0, 12
9D00C63C  00042080   SLL A0, A0, 2
9D00C640  26628FD8   ADDIU V0, S3, -28712
9D00C644  00822021   ADDU A0, A0, V0
9D00C648  32030FFF   ANDI V1, S0, 4095
9D00C64C  8C840000   LW A0, 0(A0)
9D00C650  00831821   ADDU V1, A0, V1
9D00C6B4  00111B02   SRL V1, S1, 12
9D00C6B8  00031880   SLL V1, V1, 2
9D00C6BC  26628FD8   ADDIU V0, S3, -28712
9D00C6C0  00621021   ADDU V0, V1, V0
9D00C6C4  32310FFF   ANDI S1, S1, 4095
9D00C6C8  8C420000   LW V0, 0(V0)
9D00C6CC  00511021   ADDU V0, V0, S1
9D00C71C  00101B02   SRL V1, S0, 12
9D00C720  00031880   SLL V1, V1, 2
9D00C724  26628FD8   ADDIU V0, S3, -28712
9D00C728  00621821   ADDU V1, V1, V0
9D00C72C  32020FFF   ANDI V0, S0, 4095
9D00C730  8C630000   LW V1, 0(V1)
9D00C734  00621021   ADDU V0, V1, V0
9D00C7D4  00111B02   SRL V1, S1, 12
9D00C7D8  00031880   SLL V1, V1, 2
9D00C7DC  26628FD8   ADDIU V0, S3, -28712
9D00C7E0  00621021   ADDU V0, V1, V0
9D00C7E4  32310FFF   ANDI S1, S1, 4095
9D00C7E8  8C420000   LW V0, 0(V0)
9D00C7EC  00511021   ADDU V0, V0, S1
9D00C884  00111B02   SRL V1, S1, 12
9D00C888  00031880   SLL V1, V1, 2
9D00C88C  26628FD8   ADDIU V0, S3, -28712
9D00C890  00621021   ADDU V0, V1, V0
9D00C894  32310FFF   ANDI S1, S1, 4095
9D00C898  8C420000   LW V0, 0(V0)
9D00C89C  00511021   ADDU V0, V0, S1
9D00C93C  00111B02   SRL V1, S1, 12
9D00C940  00031880   SLL V1, V1, 2
9D00C944  26628FD8   ADDIU V0, S3, -28712
9D00C948  00621021   ADDU V0, V1, V0
9D00C94C  32310FFF   ANDI S1, S1, 4095
9D00C950  8C420000   LW V0, 0(V0)
9D00C954  00511021   ADDU V0, V0, S1
9D00C9E0  00111B02   SRL V1, S1, 12
9D00C9E4  00031880   SLL V1, V1, 2
9D00C9E8  26628FD8   ADDIU V0, S3, -28712
9D00C9EC  00621021   ADDU V0, V1, V0
9D00C9F0  32310FFF   ANDI S1, S1, 4095
9D00C9F4  8C420000   LW V0, 0(V0)
9D00C9F8  00511021   ADDU V0, V0, S1
9D00CA8C  00111B02   SRL V1, S1, 12
9D00CA90  00031880   SLL V1, V1, 2
9D00CA94  26628FD8   ADDIU V0, S3, -28712
9D00CA98  00621021   ADDU V0, V1, V0
9D00CA9C  32310FFF   ANDI S1, S1, 4095
9D00CAA0  8C420000   LW V0, 0(V0)
9D00CAA4  00511021   ADDU V0, V0, S1
9D00CC18  00112302   SRL A0, S1, 12
9D00CC1C  00042080   SLL A0, A0, 2
9D00CC20  26628FD8   ADDIU V0, S3, -28712
9D00CC24  00821021   ADDU V0, A0, V0
9D00CC28  32310FFF   ANDI S1, S1, 4095
9D00CC2C  8C420000   LW V0, 0(V0)
9D00CC30  00511021   ADDU V0, V0, S1
9D00CC50  00101B02   SRL V1, S0, 12
9D00CC54  00031880   SLL V1, V1, 2
9D00CC58  26758FD8   ADDIU S5, S3, -28712
9D00CC5C  00751821   ADDU V1, V1, S5
9D00CC60  32020FFF   ANDI V0, S0, 4095
9D00CC64  8C630000   LW V1, 0(V1)
9D00CC68  00621021   ADDU V0, V1, V0
9D00CCC8  00111B02   SRL V1, S1, 12
9D00CCCC  00031880   SLL V1, V1, 2
9D00CCD0  26628FD8   ADDIU V0, S3, -28712
9D00CCD4  00621021   ADDU V0, V1, V0
9D00CCD8  32310FFF   ANDI S1, S1, 4095
9D00CCDC  8C420000   LW V0, 0(V0)
9D00CCE0  00511021   ADDU V0, V0, S1
9D00CD04  00101B02   SRL V1, S0, 12
9D00CD08  00031880   SLL V1, V1, 2
9D00CD0C  26758FD8   ADDIU S5, S3, -28712
9D00CD10  00751821   ADDU V1, V1, S5
9D00CD14  32020FFF   ANDI V0, S0, 4095
9D00CD18  8C630000   LW V1, 0(V1)
9D00CD1C  00621021   ADDU V0, V1, V0
9D00CD98  00111B02   SRL V1, S1, 12
9D00CD9C  00031880   SLL V1, V1, 2
9D00CDA0  26628FD8   ADDIU V0, S3, -28712
9D00CDA4  00621021   ADDU V0, V1, V0
9D00CDA8  32310FFF   ANDI S1, S1, 4095
9D00CDAC  8C420000   LW V0, 0(V0)
9D00CDB0  00511021   ADDU V0, V0, S1
9D00CDD4  00102302   SRL A0, S0, 12
9D00CDD8  00042080   SLL A0, A0, 2
9D00CDDC  26628FD8   ADDIU V0, S3, -28712
9D00CDE0  00822021   ADDU A0, A0, V0
9D00CDE4  32030FFF   ANDI V1, S0, 4095
9D00CDE8  8C840000   LW A0, 0(A0)
9D00CDEC  00831821   ADDU V1, A0, V1
9D00CE34  00111B02   SRL V1, S1, 12
9D00CE38  00031880   SLL V1, V1, 2
9D00CE3C  26628FD8   ADDIU V0, S3, -28712
9D00CE40  00621021   ADDU V0, V1, V0
9D00CE44  32310FFF   ANDI S1, S1, 4095
9D00CE48  8C420000   LW V0, 0(V0)
9D00CE4C  00511021   ADDU V0, V0, S1
9D00CE70  00102302   SRL A0, S0, 12
9D00CE74  00042080   SLL A0, A0, 2
9D00CE78  26628FD8   ADDIU V0, S3, -28712
9D00CE7C  00822021   ADDU A0, A0, V0
9D00CE80  32030FFF   ANDI V1, S0, 4095
9D00CE84  8C840000   LW A0, 0(A0)
9D00CE88  00831821   ADDU V1, A0, V1
9D00CED0  00111B02   SRL V1, S1, 12
9D00CED4  00031880   SLL V1, V1, 2
9D00CED8  26628FD8   ADDIU V0, S3, -28712
9D00CEDC  00621021   ADDU V0, V1, V0
9D00CEE0  32310FFF   ANDI S1, S1, 4095
9D00CEE4  8C420000   LW V0, 0(V0)
9D00CEE8  00511021   ADDU V0, V0, S1
9D00CF08  00102302   SRL A0, S0, 12
9D00CF0C  00042080   SLL A0, A0, 2
9D00CF10  26628FD8   ADDIU V0, S3, -28712
9D00CF14  00822021   ADDU A0, A0, V0
9D00CF18  32030FFF   ANDI V1, S0, 4095
9D00CF1C  8C840000   LW A0, 0(A0)
9D00CF20  00831821   ADDU V1, A0, V1
9D00CF74  00111B02   SRL V1, S1, 12
9D00CF78  00031880   SLL V1, V1, 2
9D00CF7C  26628FD8   ADDIU V0, S3, -28712
9D00CF80  00621021   ADDU V0, V1, V0
9D00CF84  32310FFF   ANDI S1, S1, 4095
9D00CF88  8C420000   LW V0, 0(V0)
9D00CF8C  00511021   ADDU V0, V0, S1
9D00CFF0  00101B02   SRL V1, S0, 12
9D00CFF4  00031880   SLL V1, V1, 2
9D00CFF8  26628FD8   ADDIU V0, S3, -28712
9D00CFFC  00621821   ADDU V1, V1, V0
9D00D000  32020FFF   ANDI V0, S0, 4095
9D00D004  8C630000   LW V1, 0(V1)
9D00D008  00621021   ADDU V0, V1, V0
9D00D02C  00102302   SRL A0, S0, 12
9D00D030  00042080   SLL A0, A0, 2
9D00D034  26628FD8   ADDIU V0, S3, -28712
9D00D038  00822021   ADDU A0, A0, V0
9D00D03C  32030FFF   ANDI V1, S0, 4095
9D00D040  8C840000   LW A0, 0(A0)
9D00D044  00831821   ADDU V1, A0, V1
9D00D080  00111B02   SRL V1, S1, 12
9D00D084  00031880   SLL V1, V1, 2
9D00D088  26628FD8   ADDIU V0, S3, -28712
9D00D08C  00621021   ADDU V0, V1, V0
9D00D090  32310FFF   ANDI S1, S1, 4095
9D00D094  8C420000   LW V0, 0(V0)
9D00D098  00511021   ADDU V0, V0, S1
9D00D0F0  00101B02   SRL V1, S0, 12
9D00D0F4  00031880   SLL V1, V1, 2
9D00D0F8  26628FD8   ADDIU V0, S3, -28712
9D00D0FC  00621821   ADDU V1, V1, V0
9D00D100  32020FFF   ANDI V0, S0, 4095
9D00D104  8C630000   LW V1, 0(V1)
9D00D108  00621021   ADDU V0, V1, V0
9D00D130  00102302   SRL A0, S0, 12
9D00D134  00042080   SLL A0, A0, 2
9D00D138  26628FD8   ADDIU V0, S3, -28712
9D00D13C  00822021   ADDU A0, A0, V0
9D00D140  32030FFF   ANDI V1, S0, 4095
9D00D144  8C840000   LW A0, 0(A0)
9D00D148  00831821   ADDU V1, A0, V1
9D00D188  00111B02   SRL V1, S1, 12
9D00D18C  00031880   SLL V1, V1, 2
9D00D190  26628FD8   ADDIU V0, S3, -28712
9D00D194  00621021   ADDU V0, V1, V0
9D00D198  32310FFF   ANDI S1, S1, 4095
9D00D19C  8C420000   LW V0, 0(V0)
9D00D1A0  00511021   ADDU V0, V0, S1
9D00D1F0  00111B02   SRL V1, S1, 12
9D00D1F4  00031880   SLL V1, V1, 2
9D00D1F8  26628FD8   ADDIU V0, S3, -28712
9D00D1FC  00621021   ADDU V0, V1, V0
9D00D200  32310FFF   ANDI S1, S1, 4095
9D00D204  8C420000   LW V0, 0(V0)
9D00D208  00511021   ADDU V0, V0, S1
9D00D26C  00111B02   SRL V1, S1, 12
9D00D270  00031880   SLL V1, V1, 2
9D00D274  26628FD8   ADDIU V0, S3, -28712
9D00D278  00621021   ADDU V0, V1, V0
9D00D27C  32310FFF   ANDI S1, S1, 4095
9D00D280  8C420000   LW V0, 0(V0)
9D00D284  00511021   ADDU V0, V0, S1
9D00D2FC  00111B02   SRL V1, S1, 12
9D00D300  00031880   SLL V1, V1, 2
9D00D304  26628FD8   ADDIU V0, S3, -28712
9D00D308  00621021   ADDU V0, V1, V0
9D00D30C  32310FFF   ANDI S1, S1, 4095
9D00D310  8C420000   LW V0, 0(V0)
9D00D314  00511021   ADDU V0, V0, S1
9D00D394  00111B02   SRL V1, S1, 12
9D00D398  00031880   SLL V1, V1, 2
9D00D39C  26628FD8   ADDIU V0, S3, -28712
9D00D3A0  00621021   ADDU V0, V1, V0
9D00D3A4  32310FFF   ANDI S1, S1, 4095
9D00D3A8  8C420000   LW V0, 0(V0)
9D00D3AC  00511021   ADDU V0, V0, S1
9D00D3DC  00102302   SRL A0, S0, 12
9D00D3E0  00042080   SLL A0, A0, 2
9D00D3E4  26638FD8   ADDIU V1, S3, -28712
9D00D3E8  00831821   ADDU V1, A0, V1
9D00D3EC  32100FFF   ANDI S0, S0, 4095
9D00D3F0  8C630000   LW V1, 0(V1)
9D00D3F4  00701821   ADDU V1, V1, S0
9D00D474  00111B02   SRL V1, S1, 12
9D00D478  00031880   SLL V1, V1, 2
9D00D47C  26628FD8   ADDIU V0, S3, -28712
9D00D480  00621021   ADDU V0, V1, V0
9D00D484  32310FFF   ANDI S1, S1, 4095
9D00D488  8C420000   LW V0, 0(V0)
9D00D48C  00511021   ADDU V0, V0, S1
9D00D4A4  00101B02   SRL V1, S0, 12
9D00D4A8  00031880   SLL V1, V1, 2
9D00D4AC  26628FD8   ADDIU V0, S3, -28712
9D00D4B0  00621821   ADDU V1, V1, V0
9D00D4B4  32020FFF   ANDI V0, S0, 4095
9D00D4B8  8C630000   LW V1, 0(V1)
9D00D4BC  00621021   ADDU V0, V1, V0
9D00D558  00111B02   SRL V1, S1, 12
9D00D55C  00031880   SLL V1, V1, 2
9D00D560  26628FD8   ADDIU V0, S3, -28712
9D00D564  00621021   ADDU V0, V1, V0
9D00D568  32310FFF   ANDI S1, S1, 4095
9D00D56C  8C420000   LW V0, 0(V0)
9D00D570  00511021   ADDU V0, V0, S1
9D00D594  00101B02   SRL V1, S0, 12
9D00D598  00031880   SLL V1, V1, 2
9D00D59C  26758FD8   ADDIU S5, S3, -28712
9D00D5A0  00751821   ADDU V1, V1, S5
9D00D5A4  32020FFF   ANDI V0, S0, 4095
9D00D5A8  8C630000   LW V1, 0(V1)
9D00D5AC  00621021   ADDU V0, V1, V0
9D00D62C  00111B02   SRL V1, S1, 12
9D00D630  00031880   SLL V1, V1, 2
9D00D634  26628FD8   ADDIU V0, S3, -28712
9D00D638  00621021   ADDU V0, V1, V0
9D00D63C  32310FFF   ANDI S1, S1, 4095
9D00D640  8C420000   LW V0, 0(V0)
9D00D644  00511021   ADDU V0, V0, S1
9D00D668  00102302   SRL A0, S0, 12
9D00D66C  00042080   SLL A0, A0, 2
9D00D670  26628FD8   ADDIU V0, S3, -28712
9D00D674  00822021   ADDU A0, A0, V0
9D00D678  32030FFF   ANDI V1, S0, 4095
9D00D67C  8C840000   LW A0, 0(A0)
9D00D680  00831821   ADDU V1, A0, V1
9D00D6D0  00111B02   SRL V1, S1, 12
9D00D6D4  00031880   SLL V1, V1, 2
9D00D6D8  26628FD8   ADDIU V0, S3, -28712
9D00D6DC  00621021   ADDU V0, V1, V0
9D00D6E0  32310FFF   ANDI S1, S1, 4095
9D00D6E4  8C420000   LW V0, 0(V0)
9D00D6E8  00511021   ADDU V0, V0, S1
9D00D70C  00102302   SRL A0, S0, 12
9D00D710  00042080   SLL A0, A0, 2
9D00D714  26628FD8   ADDIU V0, S3, -28712
9D00D718  00822021   ADDU A0, A0, V0
9D00D71C  32030FFF   ANDI V1, S0, 4095
9D00D720  8C840000   LW A0, 0(A0)
9D00D724  00831821   ADDU V1, A0, V1
9D00D774  00111B02   SRL V1, S1, 12
9D00D778  00031880   SLL V1, V1, 2
9D00D77C  26628FD8   ADDIU V0, S3, -28712
9D00D780  00621021   ADDU V0, V1, V0
9D00D784  32310FFF   ANDI S1, S1, 4095
9D00D788  8C420000   LW V0, 0(V0)
9D00D78C  00511021   ADDU V0, V0, S1
9D00D7AC  00102302   SRL A0, S0, 12
9D00D7B0  00042080   SLL A0, A0, 2
9D00D7B4  26628FD8   ADDIU V0, S3, -28712
9D00D7B8  00822021   ADDU A0, A0, V0
9D00D7BC  32030FFF   ANDI V1, S0, 4095
9D00D7C0  8C840000   LW A0, 0(A0)
9D00D7C4  00831821   ADDU V1, A0, V1
9D00D820  00111B02   SRL V1, S1, 12
9D00D824  00031880   SLL V1, V1, 2
9D00D828  26628FD8   ADDIU V0, S3, -28712
9D00D82C  00621021   ADDU V0, V1, V0
9D00D830  32310FFF   ANDI S1, S1, 4095
9D00D834  8C420000   LW V0, 0(V0)
9D00D838  00511021   ADDU V0, V0, S1
9D00D954  00031880   SLL V1, V1, 2
9D00D958  26628FD8   ADDIU V0, S3, -28712
9D00D95C  00621821   ADDU V1, V1, V0
9D00D960  32020FFF   ANDI V0, S0, 4095
9D00D964  8C630000   LW V1, 0(V1)
9D00D968  00621021   ADDU V0, V1, V0
9D00DA04  00111B02   SRL V1, S1, 12
9D00DA08  00031880   SLL V1, V1, 2
9D00DA0C  26628FD8   ADDIU V0, S3, -28712
9D00DA10  00621021   ADDU V0, V1, V0
9D00DA14  32310FFF   ANDI S1, S1, 4095
9D00DA18  8C420000   LW V0, 0(V0)
9D00DA1C  00511021   ADDU V0, V0, S1
9D00DAA8  00111B02   SRL V1, S1, 12
9D00DAAC  00031880   SLL V1, V1, 2
9D00DAB0  26628FD8   ADDIU V0, S3, -28712
9D00DAB4  00621021   ADDU V0, V1, V0
9D00DAB8  32310FFF   ANDI S1, S1, 4095
9D00DABC  8C420000   LW V0, 0(V0)
9D00DAC0  00511021   ADDU V0, V0, S1
9D00DB5C  00111B02   SRL V1, S1, 12
9D00DB60  00031880   SLL V1, V1, 2
9D00DB64  26628FD8   ADDIU V0, S3, -28712
9D00DB68  00621021   ADDU V0, V1, V0
9D00DB6C  32310FFF   ANDI S1, S1, 4095
9D00DB70  8C420000   LW V0, 0(V0)
9D00DB74  00511021   ADDU V0, V0, S1
9D00DBF0  00111B02   SRL V1, S1, 12
9D00DBF4  00031880   SLL V1, V1, 2
9D00DBF8  26628FD8   ADDIU V0, S3, -28712
9D00DBFC  00621021   ADDU V0, V1, V0
9D00DC00  32310FFF   ANDI S1, S1, 4095
9D00DC04  8C420000   LW V0, 0(V0)
9D00DC08  00511021   ADDU V0, V0, S1
9D00DC8C  00111B02   SRL V1, S1, 12
9D00DC90  00031880   SLL V1, V1, 2
9D00DC94  26628FD8   ADDIU V0, S3, -28712
9D00DC98  00621021   ADDU V0, V1, V0
9D00DC9C  32310FFF   ANDI S1, S1, 4095
9D00DCA0  8C420000   LW V0, 0(V0)
9D00DCA4  00511021   ADDU V0, V0, S1
9D00DD20  00111B02   SRL V1, S1, 12
9D00DD24  00031880   SLL V1, V1, 2
9D00DD28  26628FD8   ADDIU V0, S3, -28712
9D00DD2C  00621021   ADDU V0, V1, V0
9D00DD30  32310FFF   ANDI S1, S1, 4095
9D00DD34  8C420000   LW V0, 0(V0)
9D00DD38  00511021   ADDU V0, V0, S1
9D00DD54  00101B02   SRL V1, S0, 12
9D00DD58  00031880   SLL V1, V1, 2
9D00DD5C  26758FD8   ADDIU S5, S3, -28712
9D00DD60  00751821   ADDU V1, V1, S5
9D00DD64  32020FFF   ANDI V0, S0, 4095
9D00DD68  8C630000   LW V1, 0(V1)
9D00DD6C  00621021   ADDU V0, V1, V0
9D00DDF0  00111B02   SRL V1, S1, 12
9D00DDF4  00031880   SLL V1, V1, 2
9D00DDF8  26628FD8   ADDIU V0, S3, -28712
9D00DDFC  00621021   ADDU V0, V1, V0
9D00DE00  32310FFF   ANDI S1, S1, 4095
9D00DE04  8C420000   LW V0, 0(V0)
9D00DE08  00511021   ADDU V0, V0, S1
9D00DE2C  00101B02   SRL V1, S0, 12
9D00DE30  00031880   SLL V1, V1, 2
9D00DE34  26758FD8   ADDIU S5, S3, -28712
9D00DE38  00751821   ADDU V1, V1, S5
9D00DE3C  32020FFF   ANDI V0, S0, 4095
9D00DE40  8C630000   LW V1, 0(V1)
9D00DE44  00621021   ADDU V0, V1, V0
9D00DEFC  00111B02   SRL V1, S1, 12
9D00DF00  00031880   SLL V1, V1, 2
9D00DF04  26628FD8   ADDIU V0, S3, -28712
9D00DF08  00621021   ADDU V0, V1, V0
9D00DF0C  32310FFF   ANDI S1, S1, 4095
9D00DF10  8C420000   LW V0, 0(V0)
9D00DF14  00511021   ADDU V0, V0, S1
9D00DF38  00102302   SRL A0, S0, 12
9D00DF3C  00042080   SLL A0, A0, 2
9D00DF40  26628FD8   ADDIU V0, S3, -28712
9D00DF44  00822021   ADDU A0, A0, V0
9D00DF48  32030FFF   ANDI V1, S0, 4095
9D00DF4C  8C840000   LW A0, 0(A0)
9D00DF50  00831821   ADDU V1, A0, V1
9D00DFBC  00111B02   SRL V1, S1, 12
9D00DFC0  00031880   SLL V1, V1, 2
9D00DFC4  26628FD8   ADDIU V0, S3, -28712
9D00DFC8  00621021   ADDU V0, V1, V0
9D00DFCC  32310FFF   ANDI S1, S1, 4095
9D00DFD0  8C420000   LW V0, 0(V0)
9D00DFD4  00511021   ADDU V0, V0, S1
9D00DFF8  00102302   SRL A0, S0, 12
9D00DFFC  00042080   SLL A0, A0, 2
9D00E000  26628FD8   ADDIU V0, S3, -28712
9D00E004  00822021   ADDU A0, A0, V0
9D00E008  32030FFF   ANDI V1, S0, 4095
9D00E00C  8C840000   LW A0, 0(A0)
9D00E010  00831821   ADDU V1, A0, V1
9D00E064  00111B02   SRL V1, S1, 12
9D00E068  00031880   SLL V1, V1, 2
9D00E06C  26628FD8   ADDIU V0, S3, -28712
9D00E070  00621021   ADDU V0, V1, V0
9D00E074  32310FFF   ANDI S1, S1, 4095
9D00E078  8C420000   LW V0, 0(V0)
9D00E07C  00511021   ADDU V0, V0, S1
9D00E09C  00102302   SRL A0, S0, 12
9D00E0A0  00042080   SLL A0, A0, 2
9D00E0A4  26628FD8   ADDIU V0, S3, -28712
9D00E0A8  00822021   ADDU A0, A0, V0
9D00E0AC  32030FFF   ANDI V1, S0, 4095
9D00E0B0  8C840000   LW A0, 0(A0)
9D00E0B4  00831821   ADDU V1, A0, V1
9D00E138  00111B02   SRL V1, S1, 12
9D00E13C  00031880   SLL V1, V1, 2
9D00E140  26628FD8   ADDIU V0, S3, -28712
9D00E144  00621021   ADDU V0, V1, V0
9D00E148  32310FFF   ANDI S1, S1, 4095
9D00E14C  8C420000   LW V0, 0(V0)
9D00E150  00511021   ADDU V0, V0, S1
9D00E1C0  00101B02   SRL V1, S0, 12
9D00E1C4  00031880   SLL V1, V1, 2
9D00E1C8  26628FD8   ADDIU V0, S3, -28712
9D00E1CC  00621821   ADDU V1, V1, V0
9D00E1D0  32020FFF   ANDI V0, S0, 4095
9D00E1D4  8C630000   LW V1, 0(V1)
9D00E1D8  00621021   ADDU V0, V1, V0
9D00E200  00102302   SRL A0, S0, 12
9D00E204  00042080   SLL A0, A0, 2
9D00E208  26628FD8   ADDIU V0, S3, -28712
9D00E20C  00822021   ADDU A0, A0, V0
9D00E210  32030FFF   ANDI V1, S0, 4095
9D00E214  8C840000   LW A0, 0(A0)
9D00E218  00831821   ADDU V1, A0, V1
9D00E21C  90630000   LBU V1, 0(V1)
9D00E278  00111B02   SRL V1, S1, 12
9D00E27C  00031880   SLL V1, V1, 2
9D00E280  26628FD8   ADDIU V0, S3, -28712
9D00E284  00621021   ADDU V0, V1, V0
9D00E288  32310FFF   ANDI S1, S1, 4095
9D00E28C  8C420000   LW V0, 0(V0)
9D00E290  00511021   ADDU V0, V0, S1
9D00E2F4  00101B02   SRL V1, S0, 12
9D00E2F8  00031880   SLL V1, V1, 2
9D00E2FC  26628FD8   ADDIU V0, S3, -28712
9D00E300  00621821   ADDU V1, V1, V0
9D00E304  32020FFF   ANDI V0, S0, 4095
9D00E308  8C630000   LW V1, 0(V1)
9D00E30C  00621021   ADDU V0, V1, V0
9D00E334  00102302   SRL A0, S0, 12
9D00E338  00042080   SLL A0, A0, 2
9D00E33C  26628FD8   ADDIU V0, S3, -28712
9D00E340  00822021   ADDU A0, A0, V0
9D00E344  32030FFF   ANDI V1, S0, 4095
9D00E348  8C840000   LW A0, 0(A0)
9D00E34C  00831821   ADDU V1, A0, V1
9D00E3AC  00111B02   SRL V1, S1, 12
9D00E3B0  00031880   SLL V1, V1, 2
9D00E3B4  26628FD8   ADDIU V0, S3, -28712
9D00E3B8  00621021   ADDU V0, V1, V0
9D00E3BC  32310FFF   ANDI S1, S1, 4095
9D00E3C0  8C420000   LW V0, 0(V0)
9D00E3C4  00511021   ADDU V0, V0, S1
9D00E3FC  00052880   SLL A1, A1, 2
9D00E400  26638FD8   ADDIU V1, S3, -28712
9D00E404  00A32821   ADDU A1, A1, V1
9D00E408  30440F00   ANDI A0, V0, 3840
9D00E40C  8CA50000   LW A1, 0(A1)
9D00E410  00A42021   ADDU A0, A1, A0
9D00E41C  00022302   SRL A0, V0, 12
9D00E420  00042080   SLL A0, A0, 2
9D00E424  00831821   ADDU V1, A0, V1
9D00E428  30420FFF   ANDI V0, V0, 4095
9D00E42C  8C630000   LW V1, 0(V1)
9D00E430  00621021   ADDU V0, V1, V0
9D00E470  00111B02   SRL V1, S1, 12
9D00E474  00031880   SLL V1, V1, 2
9D00E478  26628FD8   ADDIU V0, S3, -28712
9D00E47C  00621021   ADDU V0, V1, V0
9D00E480  32310FFF   ANDI S1, S1, 4095
9D00E484  8C420000   LW V0, 0(V0)
9D00E488  00511021   ADDU V0, V0, S1
9D00E510  00111B02   SRL V1, S1, 12
9D00E514  00031880   SLL V1, V1, 2
9D00E518  26628FD8   ADDIU V0, S3, -28712
9D00E51C  00621021   ADDU V0, V1, V0
9D00E520  32310FFF   ANDI S1, S1, 4095
9D00E524  8C420000   LW V0, 0(V0)
9D00E528  00511021   ADDU V0, V0, S1
9D00E5AC  00111B02   SRL V1, S1, 12
9D00E5B0  00031880   SLL V1, V1, 2
9D00E5B4  26628FD8   ADDIU V0, S3, -28712
9D00E5B8  00621021   ADDU V0, V1, V0
9D00E5BC  32310FFF   ANDI S1, S1, 4095
9D00E5C0  8C420000   LW V0, 0(V0)
9D00E5C4  00511021   ADDU V0, V0, S1
9D00E67C  00111B02   SRL V1, S1, 12
9D00E680  00031880   SLL V1, V1, 2
9D00E684  26628FD8   ADDIU V0, S3, -28712
9D00E688  00621021   ADDU V0, V1, V0
9D00E68C  32310FFF   ANDI S1, S1, 4095
9D00E690  8C420000   LW V0, 0(V0)
9D00E694  00511021   ADDU V0, V0, S1
9D00E6C4  00102302   SRL A0, S0, 12
9D00E6C8  00042080   SLL A0, A0, 2
9D00E6CC  26638FD8   ADDIU V1, S3, -28712
9D00E6D0  00831821   ADDU V1, A0, V1
9D00E6D4  32100FFF   ANDI S0, S0, 4095
9D00E6D8  8C630000   LW V1, 0(V1)
9D00E6DC  00701821   ADDU V1, V1, S0
9D00E75C  00111B02   SRL V1, S1, 12
9D00E760  00031880   SLL V1, V1, 2
9D00E764  26628FD8   ADDIU V0, S3, -28712
9D00E768  00621021   ADDU V0, V1, V0
9D00E76C  32310FFF   ANDI S1, S1, 4095
9D00E770  8C420000   LW V0, 0(V0)
9D00E774  00511021   ADDU V0, V0, S1
9D00E78C  00101B02   SRL V1, S0, 12
9D00E790  00031880   SLL V1, V1, 2
9D00E794  26628FD8   ADDIU V0, S3, -28712
9D00E798  00621821   ADDU V1, V1, V0
9D00E79C  32020FFF   ANDI V0, S0, 4095
9D00E7A0  8C630000   LW V1, 0(V1)
9D00E7A4  00621021   ADDU V0, V1, V0
9D00E860  00111B02   SRL V1, S1, 12
9D00E864  00031880   SLL V1, V1, 2
9D00E868  26628FD8   ADDIU V0, S3, -28712
9D00E86C  00621021   ADDU V0, V1, V0
9D00E870  32310FFF   ANDI S1, S1, 4095
9D00E874  8C420000   LW V0, 0(V0)
9D00E878  00511021   ADDU V0, V0, S1
9D00E89C  00101B02   SRL V1, S0, 12
9D00E8A0  00031880   SLL V1, V1, 2
9D00E8A4  26758FD8   ADDIU S5, S3, -28712
9D00E8A8  00751821   ADDU V1, V1, S5
9D00E8AC  32020FFF   ANDI V0, S0, 4095
9D00E8B0  8C630000   LW V1, 0(V1)
9D00E8B4  00621021   ADDU V0, V1, V0
9D00E970  00111B02   SRL V1, S1, 12
9D00E974  00031880   SLL V1, V1, 2
9D00E978  26628FD8   ADDIU V0, S3, -28712
9D00E97C  00621021   ADDU V0, V1, V0
9D00E980  32310FFF   ANDI S1, S1, 4095
9D00E984  8C420000   LW V0, 0(V0)
9D00E988  00511021   ADDU V0, V0, S1
9D00E9AC  00102302   SRL A0, S0, 12
9D00E9B0  00042080   SLL A0, A0, 2
9D00E9B4  26628FD8   ADDIU V0, S3, -28712
9D00E9B8  00822021   ADDU A0, A0, V0
9D00E9BC  32030FFF   ANDI V1, S0, 4095
9D00E9C0  8C840000   LW A0, 0(A0)
9D00E9C4  00831821   ADDU V1, A0, V1
9D00EA38  00111B02   SRL V1, S1, 12
9D00EA3C  00031880   SLL V1, V1, 2
9D00EA40  26628FD8   ADDIU V0, S3, -28712
9D00EA44  00621021   ADDU V0, V1, V0
9D00EA48  32310FFF   ANDI S1, S1, 4095
9D00EA4C  8C420000   LW V0, 0(V0)
9D00EA50  00511021   ADDU V0, V0, S1
9D00EA74  00102302   SRL A0, S0, 12
9D00EA78  00042080   SLL A0, A0, 2
9D00EA7C  26628FD8   ADDIU V0, S3, -28712
9D00EA80  00822021   ADDU A0, A0, V0
9D00EA84  32030FFF   ANDI V1, S0, 4095
9D00EA88  8C840000   LW A0, 0(A0)
9D00EA8C  00831821   ADDU V1, A0, V1
9D00EAE8  00111B02   SRL V1, S1, 12
9D00EAEC  00031880   SLL V1, V1, 2
9D00EAF0  26628FD8   ADDIU V0, S3, -28712
9D00EAF4  00621021   ADDU V0, V1, V0
9D00EAF8  32310FFF   ANDI S1, S1, 4095
9D00EAFC  8C420000   LW V0, 0(V0)
9D00EB00  00511021   ADDU V0, V0, S1
9D00EB20  00102302   SRL A0, S0, 12
9D00EB24  00042080   SLL A0, A0, 2
9D00EB28  26628FD8   ADDIU V0, S3, -28712
9D00EB2C  00822021   ADDU A0, A0, V0
9D00EB30  32030FFF   ANDI V1, S0, 4095
9D00EB34  8C840000   LW A0, 0(A0)
9D00EB38  00831821   ADDU V1, A0, V1
9D00EBC4  00111B02   SRL V1, S1, 12
9D00EBC8  00031880   SLL V1, V1, 2
9D00EBCC  26628FD8   ADDIU V0, S3, -28712
9D00EBD0  00621021   ADDU V0, V1, V0
9D00EBD4  32310FFF   ANDI S1, S1, 4095
9D00EBD8  8C420000   LW V0, 0(V0)
9D00EBDC  00511021   ADDU V0, V0, S1
9D00EC2C  00101B02   SRL V1, S0, 12
9D00EC30  00031880   SLL V1, V1, 2
9D00EC34  26628FD8   ADDIU V0, S3, -28712
9D00EC38  00621821   ADDU V1, V1, V0
9D00EC3C  32020FFF   ANDI V0, S0, 4095
9D00EC40  8C630000   LW V1, 0(V1)
9D00EC44  00621021   ADDU V0, V1, V0
9D00ED0C  00111B02   SRL V1, S1, 12
9D00ED10  00031880   SLL V1, V1, 2
9D00ED14  26628FD8   ADDIU V0, S3, -28712
9D00ED18  00621021   ADDU V0, V1, V0
9D00ED1C  32310FFF   ANDI S1, S1, 4095
9D00ED20  8C420000   LW V0, 0(V0)
9D00ED24  00511021   ADDU V0, V0, S1
9D00EDE8  00111B02   SRL V1, S1, 12
9D00EDEC  00031880   SLL V1, V1, 2
9D00EDF0  26628FD8   ADDIU V0, S3, -28712
9D00EDF4  00621021   ADDU V0, V1, V0
9D00EDF8  32310FFF   ANDI S1, S1, 4095
9D00EDFC  8C420000   LW V0, 0(V0)
9D00EE00  00511021   ADDU V0, V0, S1
9D00EEC0  00111B02   SRL V1, S1, 12
9D00EEC4  00031880   SLL V1, V1, 2
9D00EEC8  26628FD8   ADDIU V0, S3, -28712
9D00EECC  00621021   ADDU V0, V1, V0
9D00EED0  32310FFF   ANDI S1, S1, 4095
9D00EED4  8C420000   LW V0, 0(V0)
9D00EED8  00511021   ADDU V0, V0, S1
9D00EF60  00111B02   SRL V1, S1, 12
9D00EF64  00031880   SLL V1, V1, 2
9D00EF68  26628FD8   ADDIU V0, S3, -28712
9D00EF6C  00621021   ADDU V0, V1, V0
9D00EF70  32310FFF   ANDI S1, S1, 4095
9D00EF74  8C420000   LW V0, 0(V0)
9D00EF78  00511021   ADDU V0, V0, S1
9D00F034  00111B02   SRL V1, S1, 12
9D00F038  00031880   SLL V1, V1, 2
9D00F03C  26628FD8   ADDIU V0, S3, -28712
9D00F040  00621021   ADDU V0, V1, V0
9D00F044  32310FFF   ANDI S1, S1, 4095
9D00F048  8C420000   LW V0, 0(V0)
9D00F04C  00511021   ADDU V0, V0, S1
9D00F0AC  00111B02   SRL V1, S1, 12
9D00F0B0  00031880   SLL V1, V1, 2
9D00F0B4  26628FD8   ADDIU V0, S3, -28712
9D00F0B8  00621021   ADDU V0, V1, V0
9D00F0BC  32310FFF   ANDI S1, S1, 4095
9D00F0C0  8C420000   LW V0, 0(V0)
9D00F0C4  00518821   ADDU S1, V0, S1
9D00F0E0  00101B02   SRL V1, S0, 12
9D00F0E4  00031880   SLL V1, V1, 2
9D00F0E8  3C06A001   LUI A2, -24575
9D00F0EC  24C68FD8   ADDIU A2, A2, -28712
9D00F0F0  00661821   ADDU V1, V1, A2
9D00F0F4  32020FFF   ANDI V0, S0, 4095
9D00F0F8  8C630000   LW V1, 0(V1)
9D00F0FC  00621021   ADDU V0, V1, V0
9D00F154  00111B02   SRL V1, S1, 12
9D00F158  00031880   SLL V1, V1, 2
9D00F15C  26628FD8   ADDIU V0, S3, -28712
9D00F160  00621021   ADDU V0, V1, V0
9D00F164  32310FFF   ANDI S1, S1, 4095
9D00F168  8C420000   LW V0, 0(V0)
9D00F16C  00511021   ADDU V0, V0, S1
9D00F188  00101B02   SRL V1, S0, 12
9D00F18C  00031880   SLL V1, V1, 2
9D00F190  3C02A001   LUI V0, -24575
9D00F194  24428FD8   ADDIU V0, V0, -28712
9D00F198  00621821   ADDU V1, V1, V0
9D00F19C  32020FFF   ANDI V0, S0, 4095
9D00F1A0  8C630000   LW V1, 0(V1)
9D00F1A4  00621021   ADDU V0, V1, V0
9D00F200  00111B02   SRL V1, S1, 12
9D00F204  00031880   SLL V1, V1, 2
9D00F208  26628FD8   ADDIU V0, S3, -28712
9D00F20C  00621021   ADDU V0, V1, V0
9D00F210  32310FFF   ANDI S1, S1, 4095
9D00F214  8C420000   LW V0, 0(V0)
9D00F218  00511021   ADDU V0, V0, S1
9D00F234  00102302   SRL A0, S0, 12
9D00F238  00042080   SLL A0, A0, 2
9D00F23C  26628FD8   ADDIU V0, S3, -28712
9D00F240  00822021   ADDU A0, A0, V0
9D00F244  32030FFF   ANDI V1, S0, 4095
9D00F248  8C840000   LW A0, 0(A0)
9D00F24C  00831821   ADDU V1, A0, V1
9D00F284  00111B02   SRL V1, S1, 12
9D00F288  00031880   SLL V1, V1, 2
9D00F28C  00621021   ADDU V0, V1, V0
9D00F290  32310FFF   ANDI S1, S1, 4095
9D00F294  8C420000   LW V0, 0(V0)
9D00F298  00511021   ADDU V0, V0, S1
9D00F2B4  00102302   SRL A0, S0, 12
9D00F2B8  00042080   SLL A0, A0, 2
9D00F2BC  26628FD8   ADDIU V0, S3, -28712
9D00F2C0  00822021   ADDU A0, A0, V0
9D00F2C4  32030FFF   ANDI V1, S0, 4095
9D00F2C8  8C840000   LW A0, 0(A0)
9D00F2CC  00831821   ADDU V1, A0, V1
9D00F300  00111B02   SRL V1, S1, 12
9D00F304  00031880   SLL V1, V1, 2
9D00F308  00621021   ADDU V0, V1, V0
9D00F30C  32310FFF   ANDI S1, S1, 4095
9D00F310  8C420000   LW V0, 0(V0)
9D00F314  00511021   ADDU V0, V0, S1
9D00F330  00102302   SRL A0, S0, 12
9D00F334  00042080   SLL A0, A0, 2
9D00F338  26628FD8   ADDIU V0, S3, -28712
9D00F33C  00822021   ADDU A0, A0, V0
9D00F340  32030FFF   ANDI V1, S0, 4095
9D00F344  8C840000   LW A0, 0(A0)
9D00F348  00831821   ADDU V1, A0, V1
9D00F37C  00111B02   SRL V1, S1, 12
9D00F380  00031880   SLL V1, V1, 2
9D00F384  00621021   ADDU V0, V1, V0
9D00F388  32310FFF   ANDI S1, S1, 4095
9D00F38C  8C420000   LW V0, 0(V0)
9D00F390  00511021   ADDU V0, V0, S1
9D00F3AC  00102302   SRL A0, S0, 12
9D00F3B0  00042080   SLL A0, A0, 2
9D00F3B4  26628FD8   ADDIU V0, S3, -28712
9D00F3B8  00822021   ADDU A0, A0, V0
9D00F3BC  32030FFF   ANDI V1, S0, 4095
9D00F3C0  8C840000   LW A0, 0(A0)
9D00F3C4  00831821   ADDU V1, A0, V1
9D00F3FC  00111B02   SRL V1, S1, 12
9D00F400  00031880   SLL V1, V1, 2
9D00F404  00621021   ADDU V0, V1, V0
9D00F408  32310FFF   ANDI S1, S1, 4095
9D00F40C  8C420000   LW V0, 0(V0)
9D00F410  00511021   ADDU V0, V0, S1
9D00F464  00101B02   SRL V1, S0, 12
9D00F468  00031880   SLL V1, V1, 2
9D00F46C  26628FD8   ADDIU V0, S3, -28712
9D00F470  00621821   ADDU V1, V1, V0
9D00F474  32020FFF   ANDI V0, S0, 4095
9D00F478  8C630000   LW V1, 0(V1)
9D00F47C  00621021   ADDU V0, V1, V0
9D00F4D4  00101B02   SRL V1, S0, 12
9D00F4D8  00031880   SLL V1, V1, 2
9D00F4DC  26628FD8   ADDIU V0, S3, -28712
9D00F4E0  00621821   ADDU V1, V1, V0
9D00F4E4  32020FFF   ANDI V0, S0, 4095
9D00F4E8  8C630000   LW V1, 0(V1)
9D00F4EC  00621021   ADDU V0, V1, V0
9D00F524  00102302   SRL A0, S0, 12
9D00F528  00042080   SLL A0, A0, 2
9D00F52C  26628FD8   ADDIU V0, S3, -28712
9D00F530  00822021   ADDU A0, A0, V0
9D00F534  32030FFF   ANDI V1, S0, 4095
9D00F538  8C840000   LW A0, 0(A0)
9D00F53C  00831821   ADDU V1, A0, V1
9D00F574  00111B02   SRL V1, S1, 12
9D00F578  00031880   SLL V1, V1, 2
9D00F57C  26628FD8   ADDIU V0, S3, -28712
9D00F580  00621021   ADDU V0, V1, V0
9D00F584  32310FFF   ANDI S1, S1, 4095
9D00F588  8C420000   LW V0, 0(V0)
9D00F58C  00511021   ADDU V0, V0, S1
9D00F5E8  00111B02   SRL V1, S1, 12
9D00F5EC  00031880   SLL V1, V1, 2
9D00F5F0  26628FD8   ADDIU V0, S3, -28712
9D00F5F4  00621021   ADDU V0, V1, V0
9D00F5F8  32310FFF   ANDI S1, S1, 4095
9D00F5FC  8C420000   LW V0, 0(V0)
9D00F600  00511021   ADDU V0, V0, S1
9D00F654  00111B02   SRL V1, S1, 12
9D00F658  00031880   SLL V1, V1, 2
9D00F65C  26628FD8   ADDIU V0, S3, -28712
9D00F660  00621021   ADDU V0, V1, V0
9D00F664  32310FFF   ANDI S1, S1, 4095
9D00F668  8C420000   LW V0, 0(V0)
9D00F66C  00511021   ADDU V0, V0, S1
9D00F6C0  00111B02   SRL V1, S1, 12
9D00F6C4  00031880   SLL V1, V1, 2
9D00F6C8  26628FD8   ADDIU V0, S3, -28712
9D00F6CC  00621021   ADDU V0, V1, V0
9D00F6D0  32310FFF   ANDI S1, S1, 4095
9D00F6D4  8C420000   LW V0, 0(V0)
9D00F6D8  00511021   ADDU V0, V0, S1
9D00F730  00111B02   SRL V1, S1, 12
9D00F734  00031880   SLL V1, V1, 2
9D00F738  26628FD8   ADDIU V0, S3, -28712
9D00F73C  00621021   ADDU V0, V1, V0
9D00F740  32310FFF   ANDI S1, S1, 4095
9D00F744  8C420000   LW V0, 0(V0)
9D00F748  00511021   ADDU V0, V0, S1
9D00F76C  00102302   SRL A0, S0, 12
9D00F770  00042080   SLL A0, A0, 2
9D00F774  26638FD8   ADDIU V1, S3, -28712
9D00F778  00831821   ADDU V1, A0, V1
9D00F77C  32100FFF   ANDI S0, S0, 4095
9D00F780  8C630000   LW V1, 0(V1)
9D00F784  00701821   ADDU V1, V1, S0
9D00F804  00111B02   SRL V1, S1, 12
9D00F808  00031880   SLL V1, V1, 2
9D00F80C  26628FD8   ADDIU V0, S3, -28712
9D00F810  00621021   ADDU V0, V1, V0
9D00F814  32310FFF   ANDI S1, S1, 4095
9D00F818  8C420000   LW V0, 0(V0)
9D00F81C  00511021   ADDU V0, V0, S1
9D00F838  00101B02   SRL V1, S0, 12
9D00F83C  00031880   SLL V1, V1, 2
9D00F840  3C02A001   LUI V0, -24575
9D00F844  24428FD8   ADDIU V0, V0, -28712
9D00F848  00621821   ADDU V1, V1, V0
9D00F84C  32020FFF   ANDI V0, S0, 4095
9D00F850  8C630000   LW V1, 0(V1)
9D00F854  00621021   ADDU V0, V1, V0
9D00F8B0  00111B02   SRL V1, S1, 12
9D00F8B4  00031880   SLL V1, V1, 2
9D00F8B8  26628FD8   ADDIU V0, S3, -28712
9D00F8BC  00621021   ADDU V0, V1, V0
9D00F8C0  32310FFF   ANDI S1, S1, 4095
9D00F8C4  8C420000   LW V0, 0(V0)
9D00F8C8  00511021   ADDU V0, V0, S1
9D00F8E4  00101B02   SRL V1, S0, 12
9D00F8E8  00031880   SLL V1, V1, 2
9D00F8EC  3C05A001   LUI A1, -24575
9D00F8F0  24A58FD8   ADDIU A1, A1, -28712
9D00F8F4  00651821   ADDU V1, V1, A1
9D00F8F8  32020FFF   ANDI V0, S0, 4095
9D00F8FC  8C630000   LW V1, 0(V1)
9D00F900  00621021   ADDU V0, V1, V0
9D00F96C  00111B02   SRL V1, S1, 12
9D00F970  00031880   SLL V1, V1, 2
9D00F974  26628FD8   ADDIU V0, S3, -28712
9D00F978  00621021   ADDU V0, V1, V0
9D00F97C  32310FFF   ANDI S1, S1, 4095
9D00F980  8C420000   LW V0, 0(V0)
9D00F984  00511021   ADDU V0, V0, S1
9D00F9A0  00102302   SRL A0, S0, 12
9D00F9A4  00042080   SLL A0, A0, 2
9D00F9A8  26628FD8   ADDIU V0, S3, -28712
9D00F9AC  00822021   ADDU A0, A0, V0
9D00F9B0  32030FFF   ANDI V1, S0, 4095
9D00F9B4  8C840000   LW A0, 0(A0)
9D00F9B8  00831821   ADDU V1, A0, V1
9D00F9F8  00111B02   SRL V1, S1, 12
9D00F9FC  00031880   SLL V1, V1, 2
9D00FA00  00621021   ADDU V0, V1, V0
9D00FA04  32310FFF   ANDI S1, S1, 4095
9D00FA08  8C420000   LW V0, 0(V0)
9D00FA0C  00511021   ADDU V0, V0, S1
9D00FA28  00102302   SRL A0, S0, 12
9D00FA2C  00042080   SLL A0, A0, 2
9D00FA30  26628FD8   ADDIU V0, S3, -28712
9D00FA34  00822021   ADDU A0, A0, V0
9D00FA38  32030FFF   ANDI V1, S0, 4095
9D00FA3C  8C840000   LW A0, 0(A0)
9D00FA40  00831821   ADDU V1, A0, V1
9D00FA7C  00111B02   SRL V1, S1, 12
9D00FA80  00031880   SLL V1, V1, 2
9D00FA84  00621021   ADDU V0, V1, V0
9D00FA88  32310FFF   ANDI S1, S1, 4095
9D00FA8C  8C420000   LW V0, 0(V0)
9D00FA90  00511021   ADDU V0, V0, S1
9D00FAAC  00102302   SRL A0, S0, 12
9D00FAB0  00042080   SLL A0, A0, 2
9D00FAB4  26628FD8   ADDIU V0, S3, -28712
9D00FAB8  00822021   ADDU A0, A0, V0
9D00FABC  32030FFF   ANDI V1, S0, 4095
9D00FAC0  8C840000   LW A0, 0(A0)
9D00FAC4  00831821   ADDU V1, A0, V1
9D00FB04  00111B02   SRL V1, S1, 12
9D00FB08  00031880   SLL V1, V1, 2
9D00FB0C  00621021   ADDU V0, V1, V0
9D00FB10  32310FFF   ANDI S1, S1, 4095
9D00FB14  8C420000   LW V0, 0(V0)
9D00FB18  00511021   ADDU V0, V0, S1
9D00FB34  00102302   SRL A0, S0, 12
9D00FB38  00042080   SLL A0, A0, 2
9D00FB3C  26628FD8   ADDIU V0, S3, -28712
9D00FB40  00822021   ADDU A0, A0, V0
9D00FB44  32030FFF   ANDI V1, S0, 4095
9D00FB48  8C840000   LW A0, 0(A0)
9D00FB4C  00831821   ADDU V1, A0, V1
9D00FB90  00111B02   SRL V1, S1, 12
9D00FB94  00031880   SLL V1, V1, 2
9D00FB98  00621021   ADDU V0, V1, V0
9D00FB9C  32310FFF   ANDI S1, S1, 4095
9D00FBA0  8C420000   LW V0, 0(V0)
9D00FBA4  00511021   ADDU V0, V0, S1
9D00FBF0  00101B02   SRL V1, S0, 12
9D00FBF4  00031880   SLL V1, V1, 2
9D00FBF8  26628FD8   ADDIU V0, S3, -28712
9D00FBFC  00621821   ADDU V1, V1, V0
9D00FC00  32020FFF   ANDI V0, S0, 4095
9D00FC04  8C630000   LW V1, 0(V1)
9D00FC08  00621021   ADDU V0, V1, V0
9D00FC74  00111B02   SRL V1, S1, 12
9D00FC78  00031880   SLL V1, V1, 2
9D00FC7C  26628FD8   ADDIU V0, S3, -28712
9D00FC80  00621021   ADDU V0, V1, V0
9D00FC84  32310FFF   ANDI S1, S1, 4095
9D00FC88  8C420000   LW V0, 0(V0)
9D00FC8C  00511021   ADDU V0, V0, S1
9D00FCD0  00101B02   SRL V1, S0, 12
9D00FCD4  00031880   SLL V1, V1, 2
9D00FCD8  26628FD8   ADDIU V0, S3, -28712
9D00FCDC  00621821   ADDU V1, V1, V0
9D00FCE0  32020FFF   ANDI V0, S0, 4095
9D00FCE4  8C630000   LW V1, 0(V1)
9D00FCE8  00621021   ADDU V0, V1, V0
9D00FD60  00111B02   SRL V1, S1, 12
9D00FD64  00031880   SLL V1, V1, 2
9D00FD68  26628FD8   ADDIU V0, S3, -28712
9D00FD6C  00621021   ADDU V0, V1, V0
9D00FD70  32310FFF   ANDI S1, S1, 4095
9D00FD74  8C420000   LW V0, 0(V0)
9D00FD78  00511021   ADDU V0, V0, S1
9D00FDE0  00111B02   SRL V1, S1, 12
9D00FDE4  00031880   SLL V1, V1, 2
9D00FDE8  26628FD8   ADDIU V0, S3, -28712
9D00FDEC  00621021   ADDU V0, V1, V0
9D00FDF0  32310FFF   ANDI S1, S1, 4095
9D00FDF4  8C420000   LW V0, 0(V0)
9D00FDF8  00511021   ADDU V0, V0, S1
9D00FE50  00111B02   SRL V1, S1, 12
9D00FE54  00031880   SLL V1, V1, 2
9D00FE58  26628FD8   ADDIU V0, S3, -28712
9D00FE5C  00621021   ADDU V0, V1, V0
9D00FE60  32310FFF   ANDI S1, S1, 4095
9D00FE64  8C420000   LW V0, 0(V0)
9D00FE68  00511021   ADDU V0, V0, S1
9D00FED0  00111B02   SRL V1, S1, 12
9D00FED4  00031880   SLL V1, V1, 2
9D00FED8  26628FD8   ADDIU V0, S3, -28712
9D00FEDC  00621021   ADDU V0, V1, V0
9D00FEE0  32310FFF   ANDI S1, S1, 4095
9D00FEE4  8C420000   LW V0, 0(V0)
9D00FEE8  00511021   ADDU V0, V0, S1
9D00FF54  00111B02   SRL V1, S1, 12
9D00FF58  00031880   SLL V1, V1, 2
9D00FF5C  26628FD8   ADDIU V0, S3, -28712
9D00FF60  00621021   ADDU V0, V1, V0
9D00FF64  32310FFF   ANDI S1, S1, 4095
9D00FF68  8C420000   LW V0, 0(V0)
9D00FF6C  00511021   ADDU V0, V0, S1
9D00FF88  00102302   SRL A0, S0, 12
9D00FF8C  00042080   SLL A0, A0, 2
9D00FF90  26628FD8   ADDIU V0, S3, -28712
9D00FF94  00822021   ADDU A0, A0, V0
9D00FF98  32030FFF   ANDI V1, S0, 4095
9D00FF9C  8C840000   LW A0, 0(A0)
9D00FFA0  00831821   ADDU V1, A0, V1
9D00FFA4  90720000   LBU S2, 0(V1)
9D00FFC4  AFB20010   SW S2, 16(SP)
9D00FFC8  0B404D98   J .L45
9D00FFCC  0240A821   ADDU S5, S2, ZERO
9D00FFD4  00111B02   SRL V1, S1, 12
9D00FFD8  00031880   SLL V1, V1, 2
9D00FFDC  26628FD8   ADDIU V0, S3, -28712
9D00FFE0  00621021   ADDU V0, V1, V0
9D00FFE4  32310FFF   ANDI S1, S1, 4095
9D00FFE8  8C420000   LW V0, 0(V0)
9D00FFEC  00511021   ADDU V0, V0, S1
9D010000  AFB20010   SW S2, 16(SP)
9D010010  00101B02   SRL V1, S0, 12
9D010014  00031880   SLL V1, V1, 2
9D010018  26748FD8   ADDIU S4, S3, -28712
9D01001C  00741821   ADDU V1, V1, S4
9D010020  32020FFF   ANDI V0, S0, 4095
9D010024  8C630000   LW V1, 0(V1)
9D010028  00621021   ADDU V0, V1, V0
9D010084  00111B02   SRL V1, S1, 12
9D010088  00031880   SLL V1, V1, 2
9D01008C  26628FD8   ADDIU V0, S3, -28712
9D010090  00621021   ADDU V0, V1, V0
9D010094  32310FFF   ANDI S1, S1, 4095
9D010098  8C420000   LW V0, 0(V0)
9D01009C  00511021   ADDU V0, V0, S1
9D0100C0  00102302   SRL A0, S0, 12
9D0100C4  00042080   SLL A0, A0, 2
9D0100C8  26628FD8   ADDIU V0, S3, -28712
9D0100CC  00822021   ADDU A0, A0, V0
9D0100D0  32030FFF   ANDI V1, S0, 4095
9D0100D4  8C840000   LW A0, 0(A0)
9D0100D8  00831821   ADDU V1, A0, V1
9D0100DC  90720000   LBU S2, 0(V1)
9D0100FC  0240F021   ADDU FP, S2, ZERO
9D010100  0B404D98   J .L45
9D010104  0240A821   ADDU S5, S2, ZERO
9D01010C  00111B02   SRL V1, S1, 12
9D010110  00031880   SLL V1, V1, 2
9D010114  26628FD8   ADDIU V0, S3, -28712
9D010118  00621021   ADDU V0, V1, V0
9D01011C  32310FFF   ANDI S1, S1, 4095
9D010120  8C420000   LW V0, 0(V0)
9D010124  00511021   ADDU V0, V0, S1
9D010138  0240F021   ADDU FP, S2, ZERO
9D010148  00101B02   SRL V1, S0, 12
9D01014C  00031880   SLL V1, V1, 2
9D010150  26748FD8   ADDIU S4, S3, -28712
9D010154  00741821   ADDU V1, V1, S4
9D010158  32020FFF   ANDI V0, S0, 4095
9D01015C  8C630000   LW V1, 0(V1)
9D010160  00621021   ADDU V0, V1, V0
9D0101C0  00111B02   SRL V1, S1, 12
9D0101C4  00031880   SLL V1, V1, 2
9D0101C8  26628FD8   ADDIU V0, S3, -28712
9D0101CC  00621021   ADDU V0, V1, V0
9D0101D0  32310FFF   ANDI S1, S1, 4095
9D0101D4  8C420000   LW V0, 0(V0)
9D0101D8  00511021   ADDU V0, V0, S1
9D010200  00102302   SRL A0, S0, 12
9D010204  00042080   SLL A0, A0, 2
9D010208  26628FD8   ADDIU V0, S3, -28712
9D01020C  00822021   ADDU A0, A0, V0
9D010210  32030FFF   ANDI V1, S0, 4095
9D010214  8C840000   LW A0, 0(A0)
9D010218  00831821   ADDU V1, A0, V1
9D010258  00111B02   SRL V1, S1, 12
9D01025C  00031880   SLL V1, V1, 2
9D010260  26628FD8   ADDIU V0, S3, -28712
9D010264  00621021   ADDU V0, V1, V0
9D010268  32310FFF   ANDI S1, S1, 4095
9D01026C  8C420000   LW V0, 0(V0)
9D010270  00511021   ADDU V0, V0, S1
9D010294  00102302   SRL A0, S0, 12
9D010298  00042080   SLL A0, A0, 2
9D01029C  26628FD8   ADDIU V0, S3, -28712
9D0102A0  00822021   ADDU A0, A0, V0
9D0102A4  32030FFF   ANDI V1, S0, 4095
9D0102A8  8C840000   LW A0, 0(A0)
9D0102AC  00831821   ADDU V1, A0, V1
9D0102EC  00111B02   SRL V1, S1, 12
9D0102F0  00031880   SLL V1, V1, 2
9D0102F4  26628FD8   ADDIU V0, S3, -28712
9D0102F8  00621021   ADDU V0, V1, V0
9D0102FC  32310FFF   ANDI S1, S1, 4095
9D010300  8C420000   LW V0, 0(V0)
9D010304  00511021   ADDU V0, V0, S1
9D010328  00102302   SRL A0, S0, 12
9D01032C  00042080   SLL A0, A0, 2
9D010330  26628FD8   ADDIU V0, S3, -28712
9D010334  00822021   ADDU A0, A0, V0
9D010338  32030FFF   ANDI V1, S0, 4095
9D01033C  8C840000   LW A0, 0(A0)
9D010340  00831821   ADDU V1, A0, V1
9D010380  00111B02   SRL V1, S1, 12
9D010384  00031880   SLL V1, V1, 2
9D010388  26628FD8   ADDIU V0, S3, -28712
9D01038C  00621021   ADDU V0, V1, V0
9D010390  32310FFF   ANDI S1, S1, 4095
9D010394  8C420000   LW V0, 0(V0)
9D010398  00511021   ADDU V0, V0, S1
9D0103BC  00102302   SRL A0, S0, 12
9D0103C0  00042080   SLL A0, A0, 2
9D0103C4  26628FD8   ADDIU V0, S3, -28712
9D0103C8  00822021   ADDU A0, A0, V0
9D0103CC  32030FFF   ANDI V1, S0, 4095
9D0103D0  8C840000   LW A0, 0(A0)
9D0103D4  00831821   ADDU V1, A0, V1
9D010418  00111B02   SRL V1, S1, 12
9D01041C  00031880   SLL V1, V1, 2
9D010420  26628FD8   ADDIU V0, S3, -28712
9D010424  00621021   ADDU V0, V1, V0
9D010428  32310FFF   ANDI S1, S1, 4095
9D01042C  8C420000   LW V0, 0(V0)
9D010430  00511021   ADDU V0, V0, S1
9D010488  00101B02   SRL V1, S0, 12
9D01048C  00031880   SLL V1, V1, 2
9D010490  26628FD8   ADDIU V0, S3, -28712
9D010494  00621821   ADDU V1, V1, V0
9D010498  32020FFF   ANDI V0, S0, 4095
9D01049C  8C630000   LW V1, 0(V1)
9D0104A0  00621021   ADDU V0, V1, V0
9D0104CC  00102302   SRL A0, S0, 12
9D0104D0  00042080   SLL A0, A0, 2
9D0104D4  26628FD8   ADDIU V0, S3, -28712
9D0104D8  00822021   ADDU A0, A0, V0
9D0104DC  32030FFF   ANDI V1, S0, 4095
9D0104E0  8C840000   LW A0, 0(A0)
9D0104E4  00831821   ADDU V1, A0, V1
9D0104E8  90720000   LBU S2, 0(V1)
9D010508  0240A021   ADDU S4, S2, ZERO
9D01050C  0B404D98   J .L45
9D010510  0240A821   ADDU S5, S2, ZERO
9D010518  00111B02   SRL V1, S1, 12
9D01051C  00031880   SLL V1, V1, 2
9D010520  26628FD8   ADDIU V0, S3, -28712
9D010524  00621021   ADDU V0, V1, V0
9D010528  32310FFF   ANDI S1, S1, 4095
9D01052C  8C420000   LW V0, 0(V0)
9D010530  00511021   ADDU V0, V0, S1
9D010544  0240A021   ADDU S4, S2, ZERO
9D010584  00101B02   SRL V1, S0, 12
9D010588  00031880   SLL V1, V1, 2
9D01058C  26628FD8   ADDIU V0, S3, -28712
9D010590  00621821   ADDU V1, V1, V0
9D010594  32020FFF   ANDI V0, S0, 4095
9D010598  8C630000   LW V1, 0(V1)
9D01059C  00621021   ADDU V0, V1, V0
9D0105D0  00102302   SRL A0, S0, 12
9D0105D4  00042080   SLL A0, A0, 2
9D0105D8  26628FD8   ADDIU V0, S3, -28712
9D0105DC  00822021   ADDU A0, A0, V0
9D0105E0  32030FFF   ANDI V1, S0, 4095
9D0105E4  8C840000   LW A0, 0(A0)
9D0105E8  00831821   ADDU V1, A0, V1
9D010624  00111B02   SRL V1, S1, 12
9D010628  00031880   SLL V1, V1, 2
9D01062C  26628FD8   ADDIU V0, S3, -28712
9D010630  00621021   ADDU V0, V1, V0
9D010634  32310FFF   ANDI S1, S1, 4095
9D010638  8C420000   LW V0, 0(V0)
9D01063C  00511021   ADDU V0, V0, S1
9D0106A8  00111B02   SRL V1, S1, 12
9D0106AC  00031880   SLL V1, V1, 2
9D0106B0  26628FD8   ADDIU V0, S3, -28712
9D0106B4  00621021   ADDU V0, V1, V0
9D0106B8  32310FFF   ANDI S1, S1, 4095
9D0106BC  8C420000   LW V0, 0(V0)
9D0106C0  00511021   ADDU V0, V0, S1
9D010728  00111B02   SRL V1, S1, 12
9D01072C  00031880   SLL V1, V1, 2
9D010730  26628FD8   ADDIU V0, S3, -28712
9D010734  00621021   ADDU V0, V1, V0
9D010738  32310FFF   ANDI S1, S1, 4095
9D01073C  8C420000   LW V0, 0(V0)
9D010740  00511021   ADDU V0, V0, S1
9D0107A8  00111B02   SRL V1, S1, 12
9D0107AC  00031880   SLL V1, V1, 2
9D0107B0  26628FD8   ADDIU V0, S3, -28712
9D0107B4  00621021   ADDU V0, V1, V0
9D0107B8  32310FFF   ANDI S1, S1, 4095
9D0107BC  8C420000   LW V0, 0(V0)
9D0107C0  00511021   ADDU V0, V0, S1
9D01082C  00111B02   SRL V1, S1, 12
9D010830  00031880   SLL V1, V1, 2
9D010834  26628FD8   ADDIU V0, S3, -28712
9D010838  00621021   ADDU V0, V1, V0
9D01083C  32310FFF   ANDI S1, S1, 4095
9D010840  8C420000   LW V0, 0(V0)
9D010844  00511021   ADDU V0, V0, S1
9D010874  00102302   SRL A0, S0, 12
9D010878  00042080   SLL A0, A0, 2
9D01087C  26638FD8   ADDIU V1, S3, -28712
9D010880  00831821   ADDU V1, A0, V1
9D010884  32100FFF   ANDI S0, S0, 4095
9D010888  8C630000   LW V1, 0(V1)
9D01088C  00701821   ADDU V1, V1, S0
9D01090C  00111B02   SRL V1, S1, 12
9D010910  00031880   SLL V1, V1, 2
9D010914  26628FD8   ADDIU V0, S3, -28712
9D010918  00621021   ADDU V0, V1, V0
9D01091C  32310FFF   ANDI S1, S1, 4095
9D010920  8C420000   LW V0, 0(V0)
9D010924  00511021   ADDU V0, V0, S1
9D01093C  00101B02   SRL V1, S0, 12
9D010940  00031880   SLL V1, V1, 2
9D010944  26628FD8   ADDIU V0, S3, -28712
9D010948  00621821   ADDU V1, V1, V0
9D01094C  32020FFF   ANDI V0, S0, 4095
9D010950  8C630000   LW V1, 0(V1)
9D010954  00621021   ADDU V0, V1, V0
9D0109E8  00111B02   SRL V1, S1, 12
9D0109EC  00031880   SLL V1, V1, 2
9D0109F0  26628FD8   ADDIU V0, S3, -28712
9D0109F4  00621021   ADDU V0, V1, V0
9D0109F8  32310FFF   ANDI S1, S1, 4095
9D0109FC  8C420000   LW V0, 0(V0)
9D010A00  00511021   ADDU V0, V0, S1
9D010A20  00101B02   SRL V1, S0, 12
9D010A24  00031880   SLL V1, V1, 2
9D010A28  26628FD8   ADDIU V0, S3, -28712
9D010A2C  00621821   ADDU V1, V1, V0
9D010A30  32020FFF   ANDI V0, S0, 4095
9D010A34  8C630000   LW V1, 0(V1)
9D010A38  00621021   ADDU V0, V1, V0
9D010AD0  00111B02   SRL V1, S1, 12
9D010AD4  00031880   SLL V1, V1, 2
9D010AD8  26628FD8   ADDIU V0, S3, -28712
9D010ADC  00621021   ADDU V0, V1, V0
9D010AE0  32310FFF   ANDI S1, S1, 4095
9D010AE4  8C420000   LW V0, 0(V0)
9D010AE8  00511021   ADDU V0, V0, S1
9D010B10  00102302   SRL A0, S0, 12
9D010B14  00042080   SLL A0, A0, 2
9D010B18  26628FD8   ADDIU V0, S3, -28712
9D010B1C  00822021   ADDU A0, A0, V0
9D010B20  32030FFF   ANDI V1, S0, 4095
9D010B24  8C840000   LW A0, 0(A0)
9D010B28  00831821   ADDU V1, A0, V1
9D010B70  00111B02   SRL V1, S1, 12
9D010B74  00031880   SLL V1, V1, 2
9D010B78  26628FD8   ADDIU V0, S3, -28712
9D010B7C  00621021   ADDU V0, V1, V0
9D010B80  32310FFF   ANDI S1, S1, 4095
9D010B84  8C420000   LW V0, 0(V0)
9D010B88  00511021   ADDU V0, V0, S1
9D010BAC  00102302   SRL A0, S0, 12
9D010BB0  00042080   SLL A0, A0, 2
9D010BB4  26628FD8   ADDIU V0, S3, -28712
9D010BB8  00822021   ADDU A0, A0, V0
9D010BBC  32030FFF   ANDI V1, S0, 4095
9D010BC0  8C840000   LW A0, 0(A0)
9D010BC4  00831821   ADDU V1, A0, V1
9D010C0C  00111B02   SRL V1, S1, 12
9D010C10  00031880   SLL V1, V1, 2
9D010C14  26628FD8   ADDIU V0, S3, -28712
9D010C18  00621021   ADDU V0, V1, V0
9D010C1C  32310FFF   ANDI S1, S1, 4095
9D010C20  8C420000   LW V0, 0(V0)
9D010C24  00511021   ADDU V0, V0, S1
9D010C48  00102302   SRL A0, S0, 12
9D010C4C  00042080   SLL A0, A0, 2
9D010C50  26628FD8   ADDIU V0, S3, -28712
9D010C54  00822021   ADDU A0, A0, V0
9D010C58  32030FFF   ANDI V1, S0, 4095
9D010C5C  8C840000   LW A0, 0(A0)
9D010C60  00831821   ADDU V1, A0, V1
9D010CAC  00111B02   SRL V1, S1, 12
9D010CB0  00031880   SLL V1, V1, 2
9D010CB4  26628FD8   ADDIU V0, S3, -28712
9D010CB8  00621021   ADDU V0, V1, V0
9D010CBC  32310FFF   ANDI S1, S1, 4095
9D010CC0  8C420000   LW V0, 0(V0)
9D010CC4  00511021   ADDU V0, V0, S1
9D010CE8  00102302   SRL A0, S0, 12
9D010CEC  00042080   SLL A0, A0, 2
9D010CF0  26628FD8   ADDIU V0, S3, -28712
9D010CF4  00822021   ADDU A0, A0, V0
9D010CF8  32030FFF   ANDI V1, S0, 4095
9D010CFC  8C840000   LW A0, 0(A0)
9D010D00  00831821   ADDU V1, A0, V1
9D010D50  00111B02   SRL V1, S1, 12
9D010D54  00031880   SLL V1, V1, 2
9D010D58  26628FD8   ADDIU V0, S3, -28712
9D010D5C  00621021   ADDU V0, V1, V0
9D010D60  32310FFF   ANDI S1, S1, 4095
9D010D64  8C420000   LW V0, 0(V0)
9D010D68  00511021   ADDU V0, V0, S1
9D010DB8  00101B02   SRL V1, S0, 12
9D010DBC  00031880   SLL V1, V1, 2
9D010DC0  26628FD8   ADDIU V0, S3, -28712
9D010DC4  00621821   ADDU V1, V1, V0
9D010DC8  32020FFF   ANDI V0, S0, 4095
9D010DCC  8C630000   LW V1, 0(V1)
9D010DD0  00621021   ADDU V0, V1, V0
9D010E6C  00111B02   SRL V1, S1, 12
9D010E70  00031880   SLL V1, V1, 2
9D010E74  26628FD8   ADDIU V0, S3, -28712
9D010E78  00621021   ADDU V0, V1, V0
9D010E7C  32310FFF   ANDI S1, S1, 4095
9D010E80  8C420000   LW V0, 0(V0)
9D010E84  00511021   ADDU V0, V0, S1
9D010ED8  00101B02   SRL V1, S0, 12
9D010EDC  00031880   SLL V1, V1, 2
9D010EE0  26628FD8   ADDIU V0, S3, -28712
9D010EE4  00621821   ADDU V1, V1, V0
9D010EE8  32020FFF   ANDI V0, S0, 4095
9D010EEC  8C630000   LW V1, 0(V1)
9D010EF0  00621021   ADDU V0, V1, V0
9D010FA4  00111B02   SRL V1, S1, 12
9D010FA8  00031880   SLL V1, V1, 2
9D010FAC  26628FD8   ADDIU V0, S3, -28712
9D010FB0  00621021   ADDU V0, V1, V0
9D010FB4  32310FFF   ANDI S1, S1, 4095
9D010FB8  8C420000   LW V0, 0(V0)
9D010FBC  00511021   ADDU V0, V0, S1
9D01105C  00111B02   SRL V1, S1, 12
9D011060  00031880   SLL V1, V1, 2
9D011064  26628FD8   ADDIU V0, S3, -28712
9D011068  00621021   ADDU V0, V1, V0
9D01106C  32310FFF   ANDI S1, S1, 4095
9D011070  8C420000   LW V0, 0(V0)
9D011074  00511021   ADDU V0, V0, S1
9D01110C  00111B02   SRL V1, S1, 12
9D011110  00031880   SLL V1, V1, 2
9D011114  26628FD8   ADDIU V0, S3, -28712
9D011118  00621021   ADDU V0, V1, V0
9D01111C  32310FFF   ANDI S1, S1, 4095
9D011120  8C420000   LW V0, 0(V0)
9D011124  00511021   ADDU V0, V0, S1
9D0111C0  00111B02   SRL V1, S1, 12
9D0111C4  00031880   SLL V1, V1, 2
9D0111C8  26628FD8   ADDIU V0, S3, -28712
9D0111CC  00621021   ADDU V0, V1, V0
9D0111D0  32310FFF   ANDI S1, S1, 4095
9D0111D4  8C420000   LW V0, 0(V0)
9D0111D8  00511021   ADDU V0, V0, S1
9D01127C  00111B02   SRL V1, S1, 12
9D011280  00031880   SLL V1, V1, 2
9D011284  26628FD8   ADDIU V0, S3, -28712
9D011288  00621021   ADDU V0, V1, V0
9D01128C  32310FFF   ANDI S1, S1, 4095
9D011290  8C420000   LW V0, 0(V0)
9D011294  00511021   ADDU V0, V0, S1
9D0112BC  00102302   SRL A0, S0, 12
9D0112C0  00042080   SLL A0, A0, 2
9D0112C4  26628FD8   ADDIU V0, S3, -28712
9D0112C8  00822021   ADDU A0, A0, V0
9D0112CC  32030FFF   ANDI V1, S0, 4095
9D0112D0  8C840000   LW A0, 0(A0)
9D0112D4  00831821   ADDU V1, A0, V1
9D011318  00111B02   SRL V1, S1, 12
9D01131C  00031880   SLL V1, V1, 2
9D011320  26628FD8   ADDIU V0, S3, -28712
9D011324  00621021   ADDU V0, V1, V0
9D011328  32310FFF   ANDI S1, S1, 4095
9D01132C  8C420000   LW V0, 0(V0)
9D011330  00511021   ADDU V0, V0, S1
9D011350  00101B02   SRL V1, S0, 12
9D011354  00031880   SLL V1, V1, 2
9D011358  26758FD8   ADDIU S5, S3, -28712
9D01135C  00751821   ADDU V1, V1, S5
9D011360  32020FFF   ANDI V0, S0, 4095
9D011364  8C630000   LW V1, 0(V1)
9D011368  00621021   ADDU V0, V1, V0
9D0113CC  00111B02   SRL V1, S1, 12
9D0113D0  00031880   SLL V1, V1, 2
9D0113D4  26628FD8   ADDIU V0, S3, -28712
9D0113D8  00621021   ADDU V0, V1, V0
9D0113DC  32310FFF   ANDI S1, S1, 4095
9D0113E0  8C420000   LW V0, 0(V0)
9D0113E4  00511021   ADDU V0, V0, S1
9D011404  00101B02   SRL V1, S0, 12
9D011408  00031880   SLL V1, V1, 2
9D01140C  26758FD8   ADDIU S5, S3, -28712
9D011410  00751821   ADDU V1, V1, S5
9D011414  32020FFF   ANDI V0, S0, 4095
9D011418  8C630000   LW V1, 0(V1)
9D01141C  00621021   ADDU V0, V1, V0
9D011498  00111B02   SRL V1, S1, 12
9D01149C  00031880   SLL V1, V1, 2
9D0114A0  26628FD8   ADDIU V0, S3, -28712
9D0114A4  00621021   ADDU V0, V1, V0
9D0114A8  32310FFF   ANDI S1, S1, 4095
9D0114AC  8C420000   LW V0, 0(V0)
9D0114B0  00511021   ADDU V0, V0, S1
9D0114D0  00102302   SRL A0, S0, 12
9D0114D4  00042080   SLL A0, A0, 2
9D0114D8  26628FD8   ADDIU V0, S3, -28712
9D0114DC  00822021   ADDU A0, A0, V0
9D0114E0  32030FFF   ANDI V1, S0, 4095
9D0114E4  8C840000   LW A0, 0(A0)
9D0114E8  00831821   ADDU V1, A0, V1
9D011538  00111B02   SRL V1, S1, 12
9D01153C  00031880   SLL V1, V1, 2
9D011540  26628FD8   ADDIU V0, S3, -28712
9D011544  00621021   ADDU V0, V1, V0
9D011548  32310FFF   ANDI S1, S1, 4095
9D01154C  8C420000   LW V0, 0(V0)
9D011550  00511021   ADDU V0, V0, S1
9D011570  00102302   SRL A0, S0, 12
9D011574  00042080   SLL A0, A0, 2
9D011578  26628FD8   ADDIU V0, S3, -28712
9D01157C  00822021   ADDU A0, A0, V0
9D011580  32030FFF   ANDI V1, S0, 4095
9D011584  8C840000   LW A0, 0(A0)
9D011588  00831821   ADDU V1, A0, V1
9D0115D4  00111B02   SRL V1, S1, 12
9D0115D8  00031880   SLL V1, V1, 2
9D0115DC  26628FD8   ADDIU V0, S3, -28712
9D0115E0  00621021   ADDU V0, V1, V0
9D0115E4  32310FFF   ANDI S1, S1, 4095
9D0115E8  8C420000   LW V0, 0(V0)
9D0115EC  00511021   ADDU V0, V0, S1
9D01160C  00102302   SRL A0, S0, 12
9D011610  00042080   SLL A0, A0, 2
9D011614  26628FD8   ADDIU V0, S3, -28712
9D011618  00822021   ADDU A0, A0, V0
9D01161C  32030FFF   ANDI V1, S0, 4095
9D011620  8C840000   LW A0, 0(A0)
9D011624  00831821   ADDU V1, A0, V1
9D01166C  00111B02   SRL V1, S1, 12
9D011670  00031880   SLL V1, V1, 2
9D011674  26628FD8   ADDIU V0, S3, -28712
9D011678  00621021   ADDU V0, V1, V0
9D01167C  32310FFF   ANDI S1, S1, 4095
9D011680  8C420000   LW V0, 0(V0)
9D011684  00511021   ADDU V0, V0, S1
9D0116A4  00102302   SRL A0, S0, 12
9D0116A8  00042080   SLL A0, A0, 2
9D0116AC  26628FD8   ADDIU V0, S3, -28712
9D0116B0  00822021   ADDU A0, A0, V0
9D0116B4  32030FFF   ANDI V1, S0, 4095
9D0116B8  8C840000   LW A0, 0(A0)
9D0116BC  00831821   ADDU V1, A0, V1
9D011714  00111B02   SRL V1, S1, 12
9D011718  00031880   SLL V1, V1, 2
9D01171C  26628FD8   ADDIU V0, S3, -28712
9D011720  00621021   ADDU V0, V1, V0
9D011724  32310FFF   ANDI S1, S1, 4095
9D011728  8C420000   LW V0, 0(V0)
9D01172C  00511021   ADDU V0, V0, S1
9D011784  00101B02   SRL V1, S0, 12
9D011788  00031880   SLL V1, V1, 2
9D01178C  26628FD8   ADDIU V0, S3, -28712
9D011790  00621821   ADDU V1, V1, V0
9D011794  32020FFF   ANDI V0, S0, 4095
9D011798  8C630000   LW V1, 0(V1)
9D01179C  00621021   ADDU V0, V1, V0
9D0117C4  00102302   SRL A0, S0, 12
9D0117C8  00042080   SLL A0, A0, 2
9D0117CC  26628FD8   ADDIU V0, S3, -28712
9D0117D0  00822021   ADDU A0, A0, V0
9D0117D4  32030FFF   ANDI V1, S0, 4095
9D0117D8  8C840000   LW A0, 0(A0)
9D0117DC  00831821   ADDU V1, A0, V1
9D01181C  00111B02   SRL V1, S1, 12
9D011820  00031880   SLL V1, V1, 2
9D011824  26628FD8   ADDIU V0, S3, -28712
9D011828  00621021   ADDU V0, V1, V0
9D01182C  32310FFF   ANDI S1, S1, 4095
9D011830  8C420000   LW V0, 0(V0)
9D011834  00511021   ADDU V0, V0, S1
9D011888  00101B02   SRL V1, S0, 12
9D01188C  00031880   SLL V1, V1, 2
9D011890  26628FD8   ADDIU V0, S3, -28712
9D011894  00621821   ADDU V1, V1, V0
9D011898  32020FFF   ANDI V0, S0, 4095
9D01189C  8C630000   LW V1, 0(V1)
9D0118A0  00621021   ADDU V0, V1, V0
9D0118D0  00102302   SRL A0, S0, 12
9D0118D4  00042080   SLL A0, A0, 2
9D0118D8  26628FD8   ADDIU V0, S3, -28712
9D0118DC  00822021   ADDU A0, A0, V0
9D0118E0  32030FFF   ANDI V1, S0, 4095
9D0118E4  8C840000   LW A0, 0(A0)
9D0118E8  00831821   ADDU V1, A0, V1
9D01192C  00111B02   SRL V1, S1, 12
9D011930  00031880   SLL V1, V1, 2
9D011934  26628FD8   ADDIU V0, S3, -28712
9D011938  00621021   ADDU V0, V1, V0
9D01193C  32310FFF   ANDI S1, S1, 4095
9D011940  8C420000   LW V0, 0(V0)
9D011944  00511021   ADDU V0, V0, S1
9D0119B8  00111B02   SRL V1, S1, 12
9D0119BC  00031880   SLL V1, V1, 2
9D0119C0  26628FD8   ADDIU V0, S3, -28712
9D0119C4  00621021   ADDU V0, V1, V0
9D0119C8  32310FFF   ANDI S1, S1, 4095
9D0119CC  8C420000   LW V0, 0(V0)
9D0119D0  00511021   ADDU V0, V0, S1
9D011A3C  00111B02   SRL V1, S1, 12
9D011A40  00031880   SLL V1, V1, 2
9D011A44  26628FD8   ADDIU V0, S3, -28712
9D011A48  00621021   ADDU V0, V1, V0
9D011A4C  32310FFF   ANDI S1, S1, 4095
9D011A50  8C420000   LW V0, 0(V0)
9D011A54  00511021   ADDU V0, V0, S1
9D011AC8  00111B02   SRL V1, S1, 12
9D011ACC  00031880   SLL V1, V1, 2
9D011AD0  26628FD8   ADDIU V0, S3, -28712
9D011AD4  00621021   ADDU V0, V1, V0
9D011AD8  32310FFF   ANDI S1, S1, 4095
9D011ADC  8C420000   LW V0, 0(V0)
9D011AE0  00511021   ADDU V0, V0, S1
9D011B64  00111B02   SRL V1, S1, 12
9D011B68  00031880   SLL V1, V1, 2
9D011B6C  26628FD8   ADDIU V0, S3, -28712
9D011B70  00621021   ADDU V0, V1, V0
9D011B74  32310FFF   ANDI S1, S1, 4095
9D011B78  8C420000   LW V0, 0(V0)
9D011B7C  00511021   ADDU V0, V0, S1
9D011BA4  00102302   SRL A0, S0, 12
9D011BA8  00042080   SLL A0, A0, 2
9D011BAC  26638FD8   ADDIU V1, S3, -28712
9D011BB0  00831821   ADDU V1, A0, V1
9D011BB4  32100FFF   ANDI S0, S0, 4095
9D011BB8  8C630000   LW V1, 0(V1)
9D011BBC  00701821   ADDU V1, V1, S0
9D011C3C  00111B02   SRL V1, S1, 12
9D011C40  00031880   SLL V1, V1, 2
9D011C44  26628FD8   ADDIU V0, S3, -28712
9D011C48  00621021   ADDU V0, V1, V0
9D011C4C  32310FFF   ANDI S1, S1, 4095
9D011C50  8C420000   LW V0, 0(V0)
9D011C54  00511021   ADDU V0, V0, S1
9D011C6C  00101B02   SRL V1, S0, 12
9D011C70  00031880   SLL V1, V1, 2
9D011C74  26628FD8   ADDIU V0, S3, -28712
9D011C78  00621821   ADDU V1, V1, V0
9D011C7C  32020FFF   ANDI V0, S0, 4095
9D011C80  8C630000   LW V1, 0(V1)
9D011C84  00621021   ADDU V0, V1, V0
9D011D20  00111B02   SRL V1, S1, 12
9D011D24  00031880   SLL V1, V1, 2
9D011D28  26628FD8   ADDIU V0, S3, -28712
9D011D2C  00621021   ADDU V0, V1, V0
9D011D30  32310FFF   ANDI S1, S1, 4095
9D011D34  8C420000   LW V0, 0(V0)
9D011D38  00511021   ADDU V0, V0, S1
9D011D58  00101B02   SRL V1, S0, 12
9D011D5C  00031880   SLL V1, V1, 2
9D011D60  26758FD8   ADDIU S5, S3, -28712
9D011D64  00751821   ADDU V1, V1, S5
9D011D68  32020FFF   ANDI V0, S0, 4095
9D011D6C  8C630000   LW V1, 0(V1)
9D011D70  00621021   ADDU V0, V1, V0
9D011DF0  00111B02   SRL V1, S1, 12
9D011DF4  00031880   SLL V1, V1, 2
9D011DF8  26628FD8   ADDIU V0, S3, -28712
9D011DFC  00621021   ADDU V0, V1, V0
9D011E00  32310FFF   ANDI S1, S1, 4095
9D011E04  8C420000   LW V0, 0(V0)
9D011E08  00511021   ADDU V0, V0, S1
9D011E28  00102302   SRL A0, S0, 12
9D011E2C  00042080   SLL A0, A0, 2
9D011E30  26628FD8   ADDIU V0, S3, -28712
9D011E34  00822021   ADDU A0, A0, V0
9D011E38  32030FFF   ANDI V1, S0, 4095
9D011E3C  8C840000   LW A0, 0(A0)
9D011E40  00831821   ADDU V1, A0, V1
9D011E94  00111B02   SRL V1, S1, 12
9D011E98  00031880   SLL V1, V1, 2
9D011E9C  26628FD8   ADDIU V0, S3, -28712
9D011EA0  00621021   ADDU V0, V1, V0
9D011EA4  32310FFF   ANDI S1, S1, 4095
9D011EA8  8C420000   LW V0, 0(V0)
9D011EAC  00511021   ADDU V0, V0, S1
9D011ECC  00102302   SRL A0, S0, 12
9D011ED0  00042080   SLL A0, A0, 2
9D011ED4  26628FD8   ADDIU V0, S3, -28712
9D011ED8  00822021   ADDU A0, A0, V0
9D011EDC  32030FFF   ANDI V1, S0, 4095
9D011EE0  8C840000   LW A0, 0(A0)
9D011EE4  00831821   ADDU V1, A0, V1
9D011F34  00111B02   SRL V1, S1, 12
9D011F38  00031880   SLL V1, V1, 2
9D011F3C  26628FD8   ADDIU V0, S3, -28712
9D011F40  00621021   ADDU V0, V1, V0
9D011F44  32310FFF   ANDI S1, S1, 4095
9D011F48  8C420000   LW V0, 0(V0)
9D011F4C  00511021   ADDU V0, V0, S1
9D011F6C  00102302   SRL A0, S0, 12
9D011F70  00042080   SLL A0, A0, 2
9D011F74  26628FD8   ADDIU V0, S3, -28712
9D011F78  00822021   ADDU A0, A0, V0
9D011F7C  32030FFF   ANDI V1, S0, 4095
9D011F80  8C840000   LW A0, 0(A0)
9D011F84  00831821   ADDU V1, A0, V1
9D011FE4  00111B02   SRL V1, S1, 12
9D011FE8  00031880   SLL V1, V1, 2
9D011FEC  26628FD8   ADDIU V0, S3, -28712
9D011FF0  00621021   ADDU V0, V1, V0
9D011FF4  32310FFF   ANDI S1, S1, 4095
9D011FF8  8C420000   LW V0, 0(V0)
9D011FFC  00511021   ADDU V0, V0, S1
9D012044  00101B02   SRL V1, S0, 12
9D012048  00031880   SLL V1, V1, 2
9D01204C  26628FD8   ADDIU V0, S3, -28712
9D012050  00621821   ADDU V1, V1, V0
9D012054  32020FFF   ANDI V0, S0, 4095
9D012058  8C630000   LW V1, 0(V1)
9D01205C  00621021   ADDU V0, V1, V0
9D012100  00111B02   SRL V1, S1, 12
9D012104  00031880   SLL V1, V1, 2
9D012108  26628FD8   ADDIU V0, S3, -28712
9D01210C  00621021   ADDU V0, V1, V0
9D012110  32310FFF   ANDI S1, S1, 4095
9D012114  8C420000   LW V0, 0(V0)
9D012118  00511021   ADDU V0, V0, S1
9D0121A4  00111B02   SRL V1, S1, 12
9D0121A8  00031880   SLL V1, V1, 2
9D0121AC  26628FD8   ADDIU V0, S3, -28712
9D0121B0  00621021   ADDU V0, V1, V0
9D0121B4  32310FFF   ANDI S1, S1, 4095
9D0121B8  8C420000   LW V0, 0(V0)
9D0121BC  00511021   ADDU V0, V0, S1
9D012258  00111B02   SRL V1, S1, 12
9D01225C  00031880   SLL V1, V1, 2
9D012260  26628FD8   ADDIU V0, S3, -28712
9D012264  00621021   ADDU V0, V1, V0
9D012268  32310FFF   ANDI S1, S1, 4095
9D01226C  8C420000   LW V0, 0(V0)
9D012270  00511021   ADDU V0, V0, S1
9D0122E8  00111B02   SRL V1, S1, 12
9D0122EC  00031880   SLL V1, V1, 2
9D0122F0  26628FD8   ADDIU V0, S3, -28712
9D0122F4  00621021   ADDU V0, V1, V0
9D0122F8  32310FFF   ANDI S1, S1, 4095
9D0122FC  8C420000   LW V0, 0(V0)
9D012300  00511021   ADDU V0, V0, S1
9D012388  00111B02   SRL V1, S1, 12
9D01238C  00031880   SLL V1, V1, 2
9D012390  26628FD8   ADDIU V0, S3, -28712
9D012394  00621021   ADDU V0, V1, V0
9D012398  32310FFF   ANDI S1, S1, 4095
9D01239C  8C420000   LW V0, 0(V0)
9D0123A0  00511021   ADDU V0, V0, S1
9D0123C0  00102302   SRL A0, S0, 12
9D0123C4  00042080   SLL A0, A0, 2
9D0123C8  26628FD8   ADDIU V0, S3, -28712
9D0123CC  00822021   ADDU A0, A0, V0
9D0123D0  32030FFF   ANDI V1, S0, 4095
9D0123D4  8C840000   LW A0, 0(A0)
9D0123D8  00831821   ADDU V1, A0, V1
9D012418  00111B02   SRL V1, S1, 12
9D01241C  00031880   SLL V1, V1, 2
9D012420  26628FD8   ADDIU V0, S3, -28712
9D012424  00621021   ADDU V0, V1, V0
9D012428  32310FFF   ANDI S1, S1, 4095
9D01242C  8C420000   LW V0, 0(V0)
9D012430  00511021   ADDU V0, V0, S1
9D012450  00101B02   SRL V1, S0, 12
9D012454  00031880   SLL V1, V1, 2
9D012458  26758FD8   ADDIU S5, S3, -28712
9D01245C  00751821   ADDU V1, V1, S5
9D012460  32020FFF   ANDI V0, S0, 4095
9D012464  8C630000   LW V1, 0(V1)
9D012468  00621021   ADDU V0, V1, V0
9D0124F0  00111B02   SRL V1, S1, 12
9D0124F4  00031880   SLL V1, V1, 2
9D0124F8  26628FD8   ADDIU V0, S3, -28712
9D0124FC  00621021   ADDU V0, V1, V0
9D012500  32310FFF   ANDI S1, S1, 4095
9D012504  8C420000   LW V0, 0(V0)
9D012508  00511021   ADDU V0, V0, S1
9D01252C  00101B02   SRL V1, S0, 12
9D012530  00031880   SLL V1, V1, 2
9D012534  26758FD8   ADDIU S5, S3, -28712
9D012538  00751821   ADDU V1, V1, S5
9D01253C  32020FFF   ANDI V0, S0, 4095
9D012540  8C630000   LW V1, 0(V1)
9D012544  00621021   ADDU V0, V1, V0
9D0125EC  00111B02   SRL V1, S1, 12
9D0125F0  00031880   SLL V1, V1, 2
9D0125F4  26628FD8   ADDIU V0, S3, -28712
9D0125F8  00621021   ADDU V0, V1, V0
9D0125FC  32310FFF   ANDI S1, S1, 4095
9D012600  8C420000   LW V0, 0(V0)
9D012604  00511021   ADDU V0, V0, S1
9D012628  00102302   SRL A0, S0, 12
9D01262C  00042080   SLL A0, A0, 2
9D012630  26628FD8   ADDIU V0, S3, -28712
9D012634  00822021   ADDU A0, A0, V0
9D012638  32030FFF   ANDI V1, S0, 4095
9D01263C  8C840000   LW A0, 0(A0)
9D012640  00831821   ADDU V1, A0, V1
9D01268C  00111B02   SRL V1, S1, 12
9D012690  00031880   SLL V1, V1, 2
9D012694  26628FD8   ADDIU V0, S3, -28712
9D012698  00621021   ADDU V0, V1, V0
9D01269C  32310FFF   ANDI S1, S1, 4095
9D0126A0  8C420000   LW V0, 0(V0)
9D0126A4  00511021   ADDU V0, V0, S1
9D0126C4  00102302   SRL A0, S0, 12
9D0126C8  00042080   SLL A0, A0, 2
9D0126CC  26628FD8   ADDIU V0, S3, -28712
9D0126D0  00822021   ADDU A0, A0, V0
9D0126D4  32030FFF   ANDI V1, S0, 4095
9D0126D8  8C840000   LW A0, 0(A0)
9D0126DC  00831821   ADDU V1, A0, V1
9D01274C  00111B02   SRL V1, S1, 12
9D012750  00031880   SLL V1, V1, 2
9D012754  26628FD8   ADDIU V0, S3, -28712
9D012758  00621021   ADDU V0, V1, V0
9D01275C  32310FFF   ANDI S1, S1, 4095
9D012760  8C420000   LW V0, 0(V0)
9D012764  00511021   ADDU V0, V0, S1
9D012788  00102302   SRL A0, S0, 12
9D01278C  00042080   SLL A0, A0, 2
9D012790  26628FD8   ADDIU V0, S3, -28712
9D012794  00822021   ADDU A0, A0, V0
9D012798  32030FFF   ANDI V1, S0, 4095
9D01279C  8C840000   LW A0, 0(A0)
9D0127A0  00831821   ADDU V1, A0, V1
9D0127E8  00111B02   SRL V1, S1, 12
9D0127EC  00031880   SLL V1, V1, 2
9D0127F0  26628FD8   ADDIU V0, S3, -28712
9D0127F4  00621021   ADDU V0, V1, V0
9D0127F8  32310FFF   ANDI S1, S1, 4095
9D0127FC  8C420000   LW V0, 0(V0)
9D012800  00511021   ADDU V0, V0, S1
9D012820  00102302   SRL A0, S0, 12
9D012824  00042080   SLL A0, A0, 2
9D012828  26628FD8   ADDIU V0, S3, -28712
9D01282C  00822021   ADDU A0, A0, V0
9D012830  32030FFF   ANDI V1, S0, 4095
9D012834  8C840000   LW A0, 0(A0)
9D012838  00831821   ADDU V1, A0, V1
9D0128B4  00111B02   SRL V1, S1, 12
9D0128B8  00031880   SLL V1, V1, 2
9D0128BC  26628FD8   ADDIU V0, S3, -28712
9D0128C0  00621021   ADDU V0, V1, V0
9D0128C4  32310FFF   ANDI S1, S1, 4095
9D0128C8  8C420000   LW V0, 0(V0)
9D0128CC  00511021   ADDU V0, V0, S1
9D012924  00101B02   SRL V1, S0, 12
9D012928  00031880   SLL V1, V1, 2
9D01292C  26628FD8   ADDIU V0, S3, -28712
9D012930  00621821   ADDU V1, V1, V0
9D012934  32020FFF   ANDI V0, S0, 4095
9D012938  8C630000   LW V1, 0(V1)
9D01293C  00621021   ADDU V0, V1, V0
9D012964  00102302   SRL A0, S0, 12
9D012968  00042080   SLL A0, A0, 2
9D01296C  26628FD8   ADDIU V0, S3, -28712
9D012970  00822021   ADDU A0, A0, V0
9D012974  32030FFF   ANDI V1, S0, 4095
9D012978  8C840000   LW A0, 0(A0)
9D01297C  00831821   ADDU V1, A0, V1
9D012980  90640000   LBU A0, 0(V1)
9D0129E0  00111B02   SRL V1, S1, 12
9D0129E4  00031880   SLL V1, V1, 2
9D0129E8  26628FD8   ADDIU V0, S3, -28712
9D0129EC  00621021   ADDU V0, V1, V0
9D0129F0  32310FFF   ANDI S1, S1, 4095
9D0129F4  8C420000   LW V0, 0(V0)
9D0129F8  00511021   ADDU V0, V0, S1
9D012A40  00101B02   SRL V1, S0, 12
9D012A44  00031880   SLL V1, V1, 2
9D012A48  26628FD8   ADDIU V0, S3, -28712
9D012A4C  00621821   ADDU V1, V1, V0
9D012A50  32020FFF   ANDI V0, S0, 4095
9D012A54  8C630000   LW V1, 0(V1)
9D012A58  00621021   ADDU V0, V1, V0
9D012AC4  00111B02   SRL V1, S1, 12
9D012AC8  00031880   SLL V1, V1, 2
9D012ACC  26628FD8   ADDIU V0, S3, -28712
9D012AD0  00621021   ADDU V0, V1, V0
9D012AD4  32310FFF   ANDI S1, S1, 4095
9D012AD8  8C420000   LW V0, 0(V0)
9D012ADC  00511021   ADDU V0, V0, S1
9D012B6C  00111B02   SRL V1, S1, 12
9D012B70  00031880   SLL V1, V1, 2
9D012B74  26628FD8   ADDIU V0, S3, -28712
9D012B78  00621021   ADDU V0, V1, V0
9D012B7C  32310FFF   ANDI S1, S1, 4095
9D012B80  8C420000   LW V0, 0(V0)
9D012B84  00511021   ADDU V0, V0, S1
9D012BFC  00111B02   SRL V1, S1, 12
9D012C00  00031880   SLL V1, V1, 2
9D012C04  26628FD8   ADDIU V0, S3, -28712
9D012C08  00621021   ADDU V0, V1, V0
9D012C0C  32310FFF   ANDI S1, S1, 4095
9D012C10  8C420000   LW V0, 0(V0)
9D012C14  00511021   ADDU V0, V0, S1
9D012CBC  00111B02   SRL V1, S1, 12
9D012CC0  00031880   SLL V1, V1, 2
9D012CC4  26628FD8   ADDIU V0, S3, -28712
9D012CC8  00621021   ADDU V0, V1, V0
9D012CCC  32310FFF   ANDI S1, S1, 4095
9D012CD0  8C420000   LW V0, 0(V0)
9D012CD4  00511021   ADDU V0, V0, S1
9D012D00  00102302   SRL A0, S0, 12
9D012D04  00042080   SLL A0, A0, 2
9D012D08  26638FD8   ADDIU V1, S3, -28712
9D012D0C  00831821   ADDU V1, A0, V1
9D012D10  32100FFF   ANDI S0, S0, 4095
9D012D14  8C630000   LW V1, 0(V1)
9D012D18  00701821   ADDU V1, V1, S0
9D012D98  00111B02   SRL V1, S1, 12
9D012D9C  00031880   SLL V1, V1, 2
9D012DA0  26628FD8   ADDIU V0, S3, -28712
9D012DA4  00621021   ADDU V0, V1, V0
9D012DA8  32310FFF   ANDI S1, S1, 4095
9D012DAC  8C420000   LW V0, 0(V0)
9D012DB0  00511021   ADDU V0, V0, S1
9D012DC8  00101B02   SRL V1, S0, 12
9D012DCC  00031880   SLL V1, V1, 2
9D012DD0  26628FD8   ADDIU V0, S3, -28712
9D012DD4  00621821   ADDU V1, V1, V0
9D012DD8  32020FFF   ANDI V0, S0, 4095
9D012DDC  8C630000   LW V1, 0(V1)
9D012DE0  00621021   ADDU V0, V1, V0
9D012E9C  00111B02   SRL V1, S1, 12
9D012EA0  00031880   SLL V1, V1, 2
9D012EA4  26628FD8   ADDIU V0, S3, -28712
9D012EA8  00621021   ADDU V0, V1, V0
9D012EAC  32310FFF   ANDI S1, S1, 4095
9D012EB0  8C420000   LW V0, 0(V0)
9D012EB4  00511021   ADDU V0, V0, S1
9D012ED8  00101B02   SRL V1, S0, 12
9D012EDC  00031880   SLL V1, V1, 2
9D012EE0  26758FD8   ADDIU S5, S3, -28712
9D012EE4  00751821   ADDU V1, V1, S5
9D012EE8  32020FFF   ANDI V0, S0, 4095
9D012EEC  8C630000   LW V1, 0(V1)
9D012EF0  00621021   ADDU V0, V1, V0
9D012F9C  00111B02   SRL V1, S1, 12
9D012FA0  00031880   SLL V1, V1, 2
9D012FA4  26628FD8   ADDIU V0, S3, -28712
9D012FA8  00621021   ADDU V0, V1, V0
9D012FAC  32310FFF   ANDI S1, S1, 4095
9D012FB0  8C420000   LW V0, 0(V0)
9D012FB4  00511021   ADDU V0, V0, S1
9D012FD8  00102302   SRL A0, S0, 12
9D012FDC  00042080   SLL A0, A0, 2
9D012FE0  26628FD8   ADDIU V0, S3, -28712
9D012FE4  00822021   ADDU A0, A0, V0
9D012FE8  32030FFF   ANDI V1, S0, 4095
9D012FEC  8C840000   LW A0, 0(A0)
9D012FF0  00831821   ADDU V1, A0, V1
9D013068  00111B02   SRL V1, S1, 12
9D01306C  00031880   SLL V1, V1, 2
9D013070  26628FD8   ADDIU V0, S3, -28712
9D013074  00621021   ADDU V0, V1, V0
9D013078  32310FFF   ANDI S1, S1, 4095
9D01307C  8C420000   LW V0, 0(V0)
9D013080  00511021   ADDU V0, V0, S1
9D0130A4  00102302   SRL A0, S0, 12
9D0130A8  00042080   SLL A0, A0, 2
9D0130AC  26628FD8   ADDIU V0, S3, -28712
9D0130B0  00822021   ADDU A0, A0, V0
9D0130B4  32030FFF   ANDI V1, S0, 4095
9D0130B8  8C840000   LW A0, 0(A0)
9D0130BC  00831821   ADDU V1, A0, V1
9D01310C  00111B02   SRL V1, S1, 12
9D013110  00031880   SLL V1, V1, 2
9D013114  26628FD8   ADDIU V0, S3, -28712
9D013118  00621021   ADDU V0, V1, V0
9D01311C  32310FFF   ANDI S1, S1, 4095
9D013120  8C420000   LW V0, 0(V0)
9D013124  00511021   ADDU V0, V0, S1
9D013144  00102302   SRL A0, S0, 12
9D013148  00042080   SLL A0, A0, 2
9D01314C  26628FD8   ADDIU V0, S3, -28712
9D013150  00822021   ADDU A0, A0, V0
9D013154  32030FFF   ANDI V1, S0, 4095
9D013158  8C840000   LW A0, 0(A0)
9D01315C  00831821   ADDU V1, A0, V1
9D0131E0  00111B02   SRL V1, S1, 12
9D0131E4  00031880   SLL V1, V1, 2
9D0131E8  26628FD8   ADDIU V0, S3, -28712
9D0131EC  00621021   ADDU V0, V1, V0
9D0131F0  32310FFF   ANDI S1, S1, 4095
9D0131F4  8C420000   LW V0, 0(V0)
9D0131F8  00511021   ADDU V0, V0, S1
9D013248  00101B02   SRL V1, S0, 12
9D01324C  00031880   SLL V1, V1, 2
9D013250  26628FD8   ADDIU V0, S3, -28712
9D013254  00621821   ADDU V1, V1, V0
9D013258  32020FFF   ANDI V0, S0, 4095
9D01325C  8C630000   LW V1, 0(V1)
9D013260  00621021   ADDU V0, V1, V0
9D01332C  00111B02   SRL V1, S1, 12
9D013330  00031880   SLL V1, V1, 2
9D013334  26628FD8   ADDIU V0, S3, -28712
9D013338  00621021   ADDU V0, V1, V0
9D01333C  32310FFF   ANDI S1, S1, 4095
9D013340  8C420000   LW V0, 0(V0)
9D013344  00511021   ADDU V0, V0, S1
9D0133F8  00111B02   SRL V1, S1, 12
9D0133FC  00031880   SLL V1, V1, 2
9D013400  26628FD8   ADDIU V0, S3, -28712
9D013404  00621021   ADDU V0, V1, V0
9D013408  32310FFF   ANDI S1, S1, 4095
9D01340C  8C420000   LW V0, 0(V0)
9D013410  00511021   ADDU V0, V0, S1
9D0134D0  00111B02   SRL V1, S1, 12
9D0134D4  00031880   SLL V1, V1, 2
9D0134D8  26628FD8   ADDIU V0, S3, -28712
9D0134DC  00621021   ADDU V0, V1, V0
9D0134E0  32310FFF   ANDI S1, S1, 4095
9D0134E4  8C420000   LW V0, 0(V0)
9D0134E8  00511021   ADDU V0, V0, S1
9D013564  00111B02   SRL V1, S1, 12
9D013568  00031880   SLL V1, V1, 2
9D01356C  26628FD8   ADDIU V0, S3, -28712
9D013570  00621021   ADDU V0, V1, V0
9D013574  32310FFF   ANDI S1, S1, 4095
9D013578  8C420000   LW V0, 0(V0)
9D01357C  00511021   ADDU V0, V0, S1
9D013628  00111B02   SRL V1, S1, 12
9D01362C  00031880   SLL V1, V1, 2
9D013630  26628FD8   ADDIU V0, S3, -28712
9D013634  00621021   ADDU V0, V1, V0
9D013638  32310FFF   ANDI S1, S1, 4095
9D01363C  8C420000   LW V0, 0(V0)
9D013640  00511021   ADDU V0, V0, S1
1197:                }
1198:                
1199:                INLINE void bank_writebyte(register uint32 address, register uint8 value)
1200:                {
1201:                   cpu.mem_page[address >> NES6502_BANKSHIFT][address & NES6502_BANKMASK] = value;
9D00A15C  00041B02   SRL V1, A0, 12
9D00A160  00031880   SLL V1, V1, 2
9D00A164  3C02A001   LUI V0, -24575
9D00A168  24428FD8   ADDIU V0, V0, -28712
9D00A16C  00621021   ADDU V0, V1, V0
9D00A170  30840FFF   ANDI A0, A0, 4095
9D00A174  8C420000   LW V0, 0(V0)
9D00A178  00442021   ADDU A0, V0, A0
9D00A17C  A0850000   SB A1, 0(A0)
1202:                }
1203:                
1204:                /* read a byte of 6502 memory */
1205:                static uint8 mem_readbyte(uint32 address)
1206:                {
9D00A010  27BDFFE8   ADDIU SP, SP, -24
1207:                   nes6502_memread *mr;
1208:                
1209:                   /* TODO: following 2 cases are N2A03-specific */
1210:                   if (address < 0x800)
9D00A014  2C820800   SLTIU V0, A0, 2048
9D00A018  10400005   BEQ V0, ZERO, 0x9D00A030
9D00A01C  AFBF0014   SW RA, 20(SP)
1211:                   {
1212:                      /* RAM */
1213:                      return ram[address];
9D00A020  8F828054   LW V0, -32684(GP)
9D00A024  00442021   ADDU A0, V0, A0
9D00A028  0B402837   J .LBE755
9D00A02C  90820000   LBU V0, 0(A0)
1214:                   }
1215:                   else if (address >= 0x8000)
9D00A030  34028000   ORI V0, ZERO, -32768
9D00A034  0082102B   SLTU V0, A0, V0
9D00A038  5440000B   BNEL V0, ZERO, 0x9D00A068
9D00A03C  3C02A001   LUI V0, -24575
1216:                   {
1217:                      /* always paged memory */
1218:                      return bank_readbyte(address);
9D00A060  0B402837   J .LBE755
9D00A064  90820000   LBU V0, 0(A0)
1219:                   }
1220:                   /* check memory range handlers */
1221:                   else
1222:                   {
1223:                      for (mr = cpu.read_handler; mr->min_range != 0xFFFFFFFF; mr++)
9D00A068  8C429018   LW V0, -28648(V0)
9D00A06C  8C430000   LW V1, 0(V0)
9D00A070  2405FFFF   ADDIU A1, ZERO, -1
9D00A074  50650011   BEQL V1, A1, 0x9D00A0BC
9D00A078  00041B02   SRL V1, A0, 12
9D00A0AC  8C430000   LW V1, 0(V0)
9D00A0B0  1465FFF3   BNE V1, A1, 0x9D00A080
9D00A0B4  0083182B   SLTU V1, A0, V1
1224:                      {
1225:                         if (address >= mr->min_range && address <= mr->max_range)
9D00A07C  0083182B   SLTU V1, A0, V1
9D00A080  5460000A   BNEL V1, ZERO, 0x9D00A0AC
9D00A084  2442000C   ADDIU V0, V0, 12
9D00A088  8C430004   LW V1, 4(V0)
9D00A08C  0064182B   SLTU V1, V1, A0
9D00A090  54600006   BNEL V1, ZERO, 0x9D00A0AC
9D00A094  2442000C   ADDIU V0, V0, 12
1226:                            return mr->read_func(address);
9D00A098  8C420008   LW V0, 8(V0)
9D00A09C  0040F809   JALR V0
9D00A0A0  00000000   NOP
9D00A0A4  0B402838   J 0x9D00A0E0
9D00A0A8  8FBF0014   LW RA, 20(SP)
1227:                      }
1228:                   }
1229:                
1230:                   /* return paged memory */
1231:                   return bank_readbyte(address);
1232:                }
9D00A0DC  8FBF0014   LW RA, 20(SP)
9D00A0E0  03E00008   JR RA
9D00A0E4  27BD0018   ADDIU SP, SP, 24
1233:                
1234:                /* write a byte of data to 6502 memory */
1235:                static void mem_writebyte(uint32 address, uint8 value)
1236:                {
9D00A0E8  27BDFFE8   ADDIU SP, SP, -24
1237:                   nes6502_memwrite *mw;
1238:                
1239:                   /* RAM */
1240:                   if (address < 0x800)
9D00A0EC  2C820800   SLTIU V0, A0, 2048
9D00A0F0  10400005   BEQ V0, ZERO, 0x9D00A108
9D00A0F4  AFBF0014   SW RA, 20(SP)
1241:                   {
1242:                      ram[address] = value;
9D00A0F8  8F828054   LW V0, -32684(GP)
9D00A0FC  00442021   ADDU A0, V0, A0
1243:                      return;
9D00A100  0B402860   J .LBE757
9D00A104  A0850000   SB A1, 0(A0)
1244:                   }
1245:                   /* check memory range handlers */
1246:                   else
1247:                   {
1248:                      for (mw = cpu.write_handler; mw->min_range != 0xFFFFFFFF; mw++)
9D00A108  3C02A001   LUI V0, -24575
9D00A10C  8C42901C   LW V0, -28644(V0)
9D00A110  8C430000   LW V1, 0(V0)
9D00A114  2406FFFF   ADDIU A2, ZERO, -1
9D00A118  50660011   BEQL V1, A2, 0x9D00A160
9D00A11C  00041B02   SRL V1, A0, 12
9D00A150  8C430000   LW V1, 0(V0)
9D00A154  1466FFF3   BNE V1, A2, 0x9D00A124
9D00A158  0083182B   SLTU V1, A0, V1
1249:                      {
1250:                         if (address >= mw->min_range && address <= mw->max_range)
9D00A120  0083182B   SLTU V1, A0, V1
9D00A124  5460000A   BNEL V1, ZERO, 0x9D00A150
9D00A128  2442000C   ADDIU V0, V0, 12
9D00A12C  8C430004   LW V1, 4(V0)
9D00A130  0064182B   SLTU V1, V1, A0
9D00A134  54600006   BNEL V1, ZERO, 0x9D00A150
9D00A138  2442000C   ADDIU V0, V0, 12
1251:                         {
1252:                            mw->write_func(address, value);
9D00A13C  8C420008   LW V0, 8(V0)
9D00A140  0040F809   JALR V0
9D00A144  00000000   NOP
1253:                            return;
9D00A148  0B402861   J 0x9D00A184
9D00A14C  8FBF0014   LW RA, 20(SP)
1254:                         }
1255:                      }
1256:                   }
1257:                
1258:                   /* write to paged memory */
1259:                   bank_writebyte(address, value);
1260:                }
9D00A180  8FBF0014   LW RA, 20(SP)
9D00A184  03E00008   JR RA
9D00A188  27BD0018   ADDIU SP, SP, 24
1261:                
1262:                /* set the current context */
1263:                void nes6502_setcontext(nes6502_context *context)
1264:                {
1265:                   int loop;
1266:                
1267:                   ASSERT(context);
1268:                
1269:                   cpu = *context;
9D00A1DC  00801021   ADDU V0, A0, ZERO
9D00A1E0  3C03A001   LUI V1, -24575
9D00A1E4  24638FD8   ADDIU V1, V1, -28712
9D00A1E8  24840050   ADDIU A0, A0, 80
9D00A1EC  8C480000   LW T0, 0(V0)
9D00A1F0  8C470004   LW A3, 4(V0)
9D00A1F4  8C460008   LW A2, 8(V0)
9D00A1F8  8C45000C   LW A1, 12(V0)
9D00A1FC  AC680000   SW T0, 0(V1)
9D00A200  AC670004   SW A3, 4(V1)
9D00A204  AC660008   SW A2, 8(V1)
9D00A208  AC65000C   SW A1, 12(V1)
9D00A20C  24420010   ADDIU V0, V0, 16
9D00A210  1444FFF6   BNE V0, A0, 0x9D00A1EC
9D00A214  24630010   ADDIU V1, V1, 16
9D00A218  8C450000   LW A1, 0(V0)
9D00A21C  8C440004   LW A0, 4(V0)
9D00A220  8C420008   LW V0, 8(V0)
9D00A224  AC650000   SW A1, 0(V1)
9D00A228  AC640004   SW A0, 4(V1)
9D00A22C  AC620008   SW V0, 8(V1)
9D00A230  3C02A001   LUI V0, -24575
9D00A234  24428FD8   ADDIU V0, V0, -28712
9D00A238  24440040   ADDIU A0, V0, 64
1270:                
1271:                   /* set dead page for all pages not pointed at anything */
1272:                   for (loop = 0; loop < NES6502_NUMBANKS; loop++)
9D00A254  5444FFFC   BNEL V0, A0, 0x9D00A248
9D00A258  8C430000   LW V1, 0(V0)
1273:                   {
1274:                      if (NULL == cpu.mem_page[loop])
9D00A244  8C430000   LW V1, 0(V0)
9D00A248  50600001   BEQL V1, ZERO, 0x9D00A250
9D00A24C  AC450000   SW A1, 0(V0)
9D00A250  24420004   ADDIU V0, V0, 4
1275:                         cpu.mem_page[loop] = null_page;
9D00A23C  3C05A000   LUI A1, -24576
9D00A240  24A57FD8   ADDIU A1, A1, 32728
1276:                   }
1277:                
1278:                   ram = cpu.mem_page[0];  /* quick zero-page/RAM references */
9D00A25C  3C02A001   LUI V0, -24575
9D00A260  8C428FD8   LW V0, -28712(V0)
9D00A264  AF828054   SW V0, -32684(GP)
1279:                   stack = ram + STACK_OFFSET;
9D00A268  24420100   ADDIU V0, V0, 256
9D00A26C  03E00008   JR RA
9D00A270  AF828050   SW V0, -32688(GP)
1280:                }
1281:                
1282:                /* get the current context */
1283:                void nes6502_getcontext(nes6502_context *context)
1284:                {
1285:                   int loop;
1286:                
1287:                   ASSERT(context);
1288:                
1289:                   *context = cpu;
9D00A274  3C02A001   LUI V0, -24575
9D00A278  24428FD8   ADDIU V0, V0, -28712
9D00A27C  00801821   ADDU V1, A0, ZERO
9D00A280  24450050   ADDIU A1, V0, 80
9D00A284  8C490000   LW T1, 0(V0)
9D00A288  8C480004   LW T0, 4(V0)
9D00A28C  8C470008   LW A3, 8(V0)
9D00A290  8C46000C   LW A2, 12(V0)
9D00A294  AC690000   SW T1, 0(V1)
9D00A298  AC680004   SW T0, 4(V1)
9D00A29C  AC670008   SW A3, 8(V1)
9D00A2A0  AC66000C   SW A2, 12(V1)
9D00A2A4  24420010   ADDIU V0, V0, 16
9D00A2A8  1445FFF6   BNE V0, A1, 0x9D00A284
9D00A2AC  24630010   ADDIU V1, V1, 16
9D00A2B0  8C460000   LW A2, 0(V0)
9D00A2B4  8C450004   LW A1, 4(V0)
9D00A2B8  8C420008   LW V0, 8(V0)
9D00A2BC  AC660000   SW A2, 0(V1)
9D00A2C0  AC650004   SW A1, 4(V1)
9D00A2C4  AC620008   SW V0, 8(V1)
1290:                
1291:                   /* reset dead pages to null */
1292:                   for (loop = 0; loop < NES6502_NUMBANKS; loop++)
9D00A2C8  00001021   ADDU V0, ZERO, ZERO
9D00A2D4  24050010   ADDIU A1, ZERO, 16
9D00A2E4  24420001   ADDIU V0, V0, 1
9D00A2E8  1445FFFB   BNE V0, A1, 0x9D00A2D8
9D00A2EC  24840004   ADDIU A0, A0, 4
1293:                   {
1294:                      if (null_page == context->mem_page[loop])
9D00A2CC  3C06A000   LUI A2, -24576
9D00A2D0  24C67FD8   ADDIU A2, A2, 32728
9D00A2D8  8C830000   LW V1, 0(A0)
9D00A2DC  50660001   BEQL V1, A2, 0x9D00A2E4
9D00A2E0  AC800000   SW ZERO, 0(A0)
1295:                         context->mem_page[loop] = NULL;
1296:                   }
1297:                }
9D00A2F0  03E00008   JR RA
9D00A2F4  00000000   NOP
1298:                
1299:                /* DMA a byte of data from ROM */
1300:                uint8 nes6502_getbyte(uint32 address)
1301:                {
1302:                   return bank_readbyte(address);
1303:                }
9D00A318  03E00008   JR RA
9D00A31C  90820000   LBU V0, 0(A0)
1304:                
1305:                /* get number of elapsed cycles */
1306:                uint32 nes6502_getcycles(bool reset_flag)
1307:                {
1308:                   uint32 cycles = cpu.total_cycles;
9D00A320  3C02A001   LUI V0, -24575
1309:                
1310:                   if (reset_flag)
9D00A324  10800003   BEQ A0, ZERO, 0x9D00A334
9D00A328  8C42902C   LW V0, -28628(V0)
1311:                      cpu.total_cycles = 0;
9D00A32C  3C03A001   LUI V1, -24575
9D00A330  AC60902C   SW ZERO, -28628(V1)
1312:                
1313:                   return cycles;
1314:                }
9D00A334  03E00008   JR RA
9D00A338  00000000   NOP
1315:                
1316:                #define  GET_GLOBAL_REGS() \
1317:                { \
1318:                   PC = cpu.pc_reg; \
1319:                   A = cpu.a_reg; \
1320:                   X = cpu.x_reg; \
1321:                   Y = cpu.y_reg; \
1322:                   SCATTER_FLAGS(cpu.p_reg); \
1323:                   S = cpu.s_reg; \
1324:                }
1325:                
1326:                #define  STORE_LOCAL_REGS() \
1327:                { \
1328:                   cpu.pc_reg = PC; \
1329:                   cpu.a_reg = A; \
1330:                   cpu.x_reg = X; \
1331:                   cpu.y_reg = Y; \
1332:                   cpu.p_reg = COMBINE_FLAGS(); \
1333:                   cpu.s_reg = S; \
1334:                }
1335:                
1336:                #define  MIN(a,b)    (((a) < (b)) ? (a) : (b))
1337:                
1338:                #ifdef NES6502_JUMPTABLE
1339:                
1340:                #define  OPCODE_BEGIN(xx)  op##xx:
1341:                #ifdef NES6502_DISASM
1342:                
1343:                #define  OPCODE_END \
1344:                   if (remaining_cycles <= 0) \
1345:                      goto end_execute; \
1346:                   log_printf(nes6502_disasm(PC, COMBINE_FLAGS(), A, X, Y, S)); \
1347:                   goto *opcode_table[bank_readbyte(PC++)];
1348:                
1349:                #else /* !NES6520_DISASM */
1350:                
1351:                #define  OPCODE_END \
1352:                   if (remaining_cycles <= 0) \
1353:                      goto end_execute; \
1354:                   goto *opcode_table[bank_readbyte(PC++)];
1355:                
1356:                #endif /* !NES6502_DISASM */
1357:                
1358:                #else /* !NES6502_JUMPTABLE */
1359:                #define  OPCODE_BEGIN(xx)  case 0x##xx:
1360:                #define  OPCODE_END        break;
1361:                #endif /* !NES6502_JUMPTABLE */
1362:                
1363:                
1364:                /* Execute instructions until count expires
1365:                **
1366:                ** Returns the number of cycles *actually* executed, which will be
1367:                ** anywhere from zero to timeslice_cycles + 6
1368:                */
1369:                int nes6502_execute(int timeslice_cycles)
1370:                {
9D00A33C  27BDFFA0   ADDIU SP, SP, -96
9D00A340  AFBF005C   SW RA, 92(SP)
9D00A344  AFBE0058   SW FP, 88(SP)
9D00A348  AFB70054   SW S7, 84(SP)
9D00A34C  AFB60050   SW S6, 80(SP)
9D00A350  AFB5004C   SW S5, 76(SP)
9D00A354  AFB40048   SW S4, 72(SP)
9D00A358  AFB30044   SW S3, 68(SP)
9D00A35C  AFB20040   SW S2, 64(SP)
9D00A360  AFB1003C   SW S1, 60(SP)
9D00A364  AFB00038   SW S0, 56(SP)
1371:                   int old_cycles = cpu.total_cycles;
9D00A368  3C02A001   LUI V0, -24575
9D00A36C  24428FD8   ADDIU V0, V0, -28712
9D00A370  8C430054   LW V1, 84(V0)
9D00A374  AFA30024   SW V1, 36(SP)
1372:                
1373:                   uint32 temp, addr; /* for macros */
1374:                   uint8 btemp, baddr; /* for macros */
1375:                   uint8 data;
1376:                
1377:                   /* flags */
1378:                   uint8 n_flag, v_flag, b_flag;
1379:                   uint8 d_flag, i_flag, z_flag, c_flag;
1380:                
1381:                   /* local copies of regs */
1382:                   uint32 PC;
1383:                   uint8 A, X, Y, S;
1384:                
1385:                #ifdef NES6502_JUMPTABLE
1386:                   
1387:                   static const void *opcode_table[256] =
1388:                   {
1389:                      &&op00, &&op01, &&op02, &&op03, &&op04, &&op05, &&op06, &&op07,
1390:                      &&op08, &&op09, &&op0A, &&op0B, &&op0C, &&op0D, &&op0E, &&op0F,
1391:                      &&op10, &&op11, &&op12, &&op13, &&op14, &&op15, &&op16, &&op17,
1392:                      &&op18, &&op19, &&op1A, &&op1B, &&op1C, &&op1D, &&op1E, &&op1F,
1393:                      &&op20, &&op21, &&op22, &&op23, &&op24, &&op25, &&op26, &&op27,
1394:                      &&op28, &&op29, &&op2A, &&op2B, &&op2C, &&op2D, &&op2E, &&op2F,
1395:                      &&op30, &&op31, &&op32, &&op33, &&op34, &&op35, &&op36, &&op37,
1396:                      &&op38, &&op39, &&op3A, &&op3B, &&op3C, &&op3D, &&op3E, &&op3F,
1397:                      &&op40, &&op41, &&op42, &&op43, &&op44, &&op45, &&op46, &&op47,
1398:                      &&op48, &&op49, &&op4A, &&op4B, &&op4C, &&op4D, &&op4E, &&op4F,
1399:                      &&op50, &&op51, &&op52, &&op53, &&op54, &&op55, &&op56, &&op57,
1400:                      &&op58, &&op59, &&op5A, &&op5B, &&op5C, &&op5D, &&op5E, &&op5F,
1401:                      &&op60, &&op61, &&op62, &&op63, &&op64, &&op65, &&op66, &&op67,
1402:                      &&op68, &&op69, &&op6A, &&op6B, &&op6C, &&op6D, &&op6E, &&op6F,
1403:                      &&op70, &&op71, &&op72, &&op73, &&op74, &&op75, &&op76, &&op77,
1404:                      &&op78, &&op79, &&op7A, &&op7B, &&op7C, &&op7D, &&op7E, &&op7F,
1405:                      &&op80, &&op81, &&op82, &&op83, &&op84, &&op85, &&op86, &&op87,
1406:                      &&op88, &&op89, &&op8A, &&op8B, &&op8C, &&op8D, &&op8E, &&op8F,
1407:                      &&op90, &&op91, &&op92, &&op93, &&op94, &&op95, &&op96, &&op97,
1408:                      &&op98, &&op99, &&op9A, &&op9B, &&op9C, &&op9D, &&op9E, &&op9F,
1409:                      &&opA0, &&opA1, &&opA2, &&opA3, &&opA4, &&opA5, &&opA6, &&opA7,
1410:                      &&opA8, &&opA9, &&opAA, &&opAB, &&opAC, &&opAD, &&opAE, &&opAF,
1411:                      &&opB0, &&opB1, &&opB2, &&opB3, &&opB4, &&opB5, &&opB6, &&opB7,
1412:                      &&opB8, &&opB9, &&opBA, &&opBB, &&opBC, &&opBD, &&opBE, &&opBF,
1413:                      &&opC0, &&opC1, &&opC2, &&opC3, &&opC4, &&opC5, &&opC6, &&opC7,
1414:                      &&opC8, &&opC9, &&opCA, &&opCB, &&opCC, &&opCD, &&opCE, &&opCF,
1415:                      &&opD0, &&opD1, &&opD2, &&opD3, &&opD4, &&opD5, &&opD6, &&opD7,
1416:                      &&opD8, &&opD9, &&opDA, &&opDB, &&opDC, &&opDD, &&opDE, &&opDF,
1417:                      &&opE0, &&opE1, &&opE2, &&opE3, &&opE4, &&opE5, &&opE6, &&opE7,
1418:                      &&opE8, &&opE9, &&opEA, &&opEB, &&opEC, &&opED, &&opEE, &&opEF,
1419:                      &&opF0, &&opF1, &&opF2, &&opF3, &&opF4, &&opF5, &&opF6, &&opF7,
1420:                      &&opF8, &&opF9, &&opFA, &&opFB, &&opFC, &&opFD, &&opFE, &&opFF
1421:                   };
1422:                
1423:                #endif /* NES6502_JUMPTABLE */
1424:                
1425:                   remaining_cycles = timeslice_cycles;
9D00A378  AF848058   SW A0, -32680(GP)
1426:                
1427:                   GET_GLOBAL_REGS();
9D00A37C  8C510048   LW S1, 72(V0)
9D00A380  9054004C   LBU S4, 76(V0)
9D00A384  905E004E   LBU FP, 78(V0)
9D00A388  9045004F   LBU A1, 79(V0)
9D00A38C  AFA50010   SW A1, 16(SP)
9D00A390  9057004D   LBU S7, 77(V0)
9D00A394  32F20080   ANDI S2, S7, 128
9D00A398  32E30040   ANDI V1, S7, 64
9D00A39C  306300FF   ANDI V1, V1, 255
9D00A3A0  AFA30014   SW V1, 20(SP)
9D00A3A4  32E30010   ANDI V1, S7, 16
9D00A3A8  306300FF   ANDI V1, V1, 255
9D00A3AC  AFA30028   SW V1, 40(SP)
9D00A3B0  32E30008   ANDI V1, S7, 8
9D00A3B4  306300FF   ANDI V1, V1, 255
9D00A3B8  AFA30020   SW V1, 32(SP)
9D00A3BC  32E30004   ANDI V1, S7, 4
9D00A3C0  306300FF   ANDI V1, V1, 255
9D00A3C4  AFA3001C   SW V1, 28(SP)
9D00A3C8  3AF50002   XORI S5, S7, 2
9D00A3CC  7EB50040   EXT S5, S5, 1, 1
9D00A3D0  90460050   LBU A2, 80(V0)
9D00A3D4  AFA60018   SW A2, 24(SP)
1428:                
1429:                   /* check for DMA cycle burning */
1430:                   if (cpu.burn_cycles && remaining_cycles > 0)
9D00A3D8  8C420058   LW V0, 88(V0)
9D00A3DC  1040000E   BEQ V0, ZERO, .LBE761
9D00A3E0  32F70001   ANDI S7, S7, 1
9D00A3E4  1880000C   BLEZ A0, .LBE761
9D00A3E8  0044182A   SLT V1, V0, A0
1431:                   {
1432:                      int burn_for;
1433:                      
1434:                      burn_for = MIN(remaining_cycles, cpu.burn_cycles);
9D00A3EC  00403821   ADDU A3, V0, ZERO
9D00A3F0  0083380A   MOVZ A3, A0, V1
1435:                      ADD_CYCLES(burn_for);
9D00A3F4  00872023   SUBU A0, A0, A3
9D00A3F8  AF848058   SW A0, -32680(GP)
9D00A3FC  3C04A001   LUI A0, -24575
9D00A400  24848FD8   ADDIU A0, A0, -28712
9D00A404  8FA60024   LW A2, 36(SP)
9D00A408  00C72821   ADDU A1, A2, A3
9D00A40C  AC850054   SW A1, 84(A0)
1436:                      cpu.burn_cycles -= burn_for;
9D00A410  00471023   SUBU V0, V0, A3
9D00A414  AC820058   SW V0, 88(A0)
1437:                   }
1438:                
1439:                   if (0 == i_flag && cpu.int_pending && remaining_cycles > 0)
9D00A418  8FA7001C   LW A3, 28(SP)
9D00A41C  14E00038   BNE A3, ZERO, 0x9D00A500
9D00A420  8F828058   LW V0, -32680(GP)
9D00A424  3C02A001   LUI V0, -24575
9D00A428  9042902A   LBU V0, -28630(V0)
9D00A42C  10400034   BEQ V0, ZERO, 0x9D00A500
9D00A430  8F828058   LW V0, -32680(GP)
9D00A434  8F908058   LW S0, -32680(GP)
9D00A438  1A002489   BLEZ S0, .L45
9D00A43C  3C02A001   LUI V0, -24575
1440:                   {
1441:                      cpu.int_pending = 0;
9D00A440  A040902A   SB ZERO, -28630(V0)
1442:                      IRQ_PROC();
9D00A444  8F828050   LW V0, -32688(GP)
9D00A448  8FA40018   LW A0, 24(SP)
9D00A44C  00441821   ADDU V1, V0, A0
9D00A450  00112202   SRL A0, S1, 8
9D00A454  A0640000   SB A0, 0(V1)
9D00A458  8FA50018   LW A1, 24(SP)
9D00A45C  24A3FFFE   ADDIU V1, A1, -2
9D00A460  306300FF   ANDI V1, V1, 255
9D00A464  24A4FFFF   ADDIU A0, A1, -1
9D00A468  308400FF   ANDI A0, A0, 255
9D00A46C  00442021   ADDU A0, V0, A0
9D00A470  A0910000   SB S1, 0(A0)
9D00A474  24A4FFFD   ADDIU A0, A1, -3
9D00A478  308400FF   ANDI A0, A0, 255
9D00A47C  AFA40018   SW A0, 24(SP)
9D00A480  00431021   ADDU V0, V0, V1
9D00A484  2406FF80   ADDIU A2, ZERO, -128
9D00A488  02463824   AND A3, S2, A2
9D00A48C  7C073C20   SEB A3, A3
9D00A490  24060040   ADDIU A2, ZERO, 64
9D00A494  8FA30014   LW V1, 20(SP)
9D00A498  0003300A   MOVZ A2, ZERO, V1
9D00A49C  24050008   ADDIU A1, ZERO, 8
9D00A4A0  8FA40020   LW A0, 32(SP)
9D00A4A4  0004280A   MOVZ A1, ZERO, A0
9D00A4A8  24040002   ADDIU A0, ZERO, 2
9D00A4AC  0015200B   MOVN A0, ZERO, S5
9D00A4B0  36E30020   ORI V1, S7, 32
9D00A4B4  00E31825   OR V1, A3, V1
9D00A4B8  00C31825   OR V1, A2, V1
9D00A4BC  00A31825   OR V1, A1, V1
9D00A4C0  00831825   OR V1, A0, V1
9D00A4C4  A0430000   SB V1, 0(V0)
9D00A4C8  0F402863   JAL bank_readword
9D00A4CC  3404FFFE   ORI A0, ZERO, -2
9D00A4D0  00408821   ADDU S1, V0, ZERO
9D00A4F0  24050001   ADDIU A1, ZERO, 1
9D00A4F4  AFA5001C   SW A1, 28(SP)
9D00A4F8  AFA00028   SW ZERO, 40(SP)
1443:                      ADD_CYCLES(INT_CYCLES);
9D00A4D4  2610FFF9   ADDIU S0, S0, -7
9D00A4D8  AF908058   SW S0, -32680(GP)
9D00A4DC  3C02A001   LUI V0, -24575
9D00A4E0  24428FD8   ADDIU V0, V0, -28712
9D00A4E4  8C430054   LW V1, 84(V0)
9D00A4E8  24630007   ADDIU V1, V1, 7
9D00A4EC  AC430054   SW V1, 84(V0)
1444:                   }
1445:                
1446:                #ifdef NES6502_JUMPTABLE
1447:                   /* fetch first instruction */
1448:                   OPCODE_END
9D00A4FC  8F828058   LW V0, -32680(GP)
9D00A500  18402457   BLEZ V0, .L45
9D00A504  26300001   ADDIU S0, S1, 1
9D00A528  92230000   LBU V1, 0(S1)
9D00A52C  00031880   SLL V1, V1, 2
9D00A530  3C029D03   LUI V0, -25341
9D00A534  2442F7F8   ADDIU V0, V0, -2056
9D00A538  00621021   ADDU V0, V1, V0
9D00A53C  8C420000   LW V0, 0(V0)
1449:                
1450:                #else /* !NES6502_JUMPTABLE */
1451:                
1452:                   /* Continue until we run out of cycles */
1453:                   while (remaining_cycles > 0)
1454:                   {
1455:                #ifdef NES6502_DISASM
1456:                      log_printf(nes6502_disasm(PC, COMBINE_FLAGS(), A, X, Y, S));
1457:                #endif /* NES6502_DISASM */
1458:                
1459:                      /* Fetch and execute instruction */
1460:                      switch (bank_readbyte(PC++))
1461:                      {
1462:                #endif /* !NES6502_JUMPTABLE */
1463:                
1464:                      OPCODE_BEGIN(00)  /* BRK */
1465:                         BRK();
9D00A554  26100001   ADDIU S0, S0, 1
9D00A558  8F828050   LW V0, -32688(GP)
9D00A55C  8FA60018   LW A2, 24(SP)
9D00A560  00461821   ADDU V1, V0, A2
9D00A564  00102202   SRL A0, S0, 8
9D00A568  A0640000   SB A0, 0(V1)
9D00A56C  24C3FFFE   ADDIU V1, A2, -2
9D00A570  306300FF   ANDI V1, V1, 255
9D00A574  24C4FFFF   ADDIU A0, A2, -1
9D00A578  308400FF   ANDI A0, A0, 255
9D00A57C  00442021   ADDU A0, V0, A0
9D00A580  A0900000   SB S0, 0(A0)
9D00A584  24C4FFFD   ADDIU A0, A2, -3
9D00A588  308400FF   ANDI A0, A0, 255
9D00A58C  AFA40018   SW A0, 24(SP)
9D00A590  00431021   ADDU V0, V0, V1
9D00A594  2407FF80   ADDIU A3, ZERO, -128
9D00A598  02474024   AND T0, S2, A3
9D00A59C  7C084420   SEB T0, T0
9D00A5A0  24070040   ADDIU A3, ZERO, 64
9D00A5A4  8FA30014   LW V1, 20(SP)
9D00A5A8  0003380A   MOVZ A3, ZERO, V1
9D00A5AC  24060008   ADDIU A2, ZERO, 8
9D00A5B0  8FA40020   LW A0, 32(SP)
9D00A5B4  0004300A   MOVZ A2, ZERO, A0
9D00A5B8  24050004   ADDIU A1, ZERO, 4
9D00A5BC  8FA3001C   LW V1, 28(SP)
9D00A5C0  0003280A   MOVZ A1, ZERO, V1
9D00A5C4  24040002   ADDIU A0, ZERO, 2
9D00A5C8  0015200B   MOVN A0, ZERO, S5
9D00A5CC  36E30030   ORI V1, S7, 48
9D00A5D0  01031825   OR V1, T0, V1
9D00A5D4  00E31825   OR V1, A3, V1
9D00A5D8  00C31825   OR V1, A2, V1
9D00A5DC  00A31825   OR V1, A1, V1
9D00A5E0  00831825   OR V1, A0, V1
9D00A5E4  A0430000   SB V1, 0(V0)
9D00A5E8  0F402863   JAL bank_readword
9D00A5EC  3404FFFE   ORI A0, ZERO, -2
9D00A5F0  00408821   ADDU S1, V0, ZERO
9D00A5F4  8F828058   LW V0, -32680(GP)
9D00A5F8  2442FFF9   ADDIU V0, V0, -7
9D00A5FC  AF828058   SW V0, -32680(GP)
9D00A600  26638FD8   ADDIU V1, S3, -28712
9D00A604  8C640054   LW A0, 84(V1)
9D00A608  24840007   ADDIU A0, A0, 7
9D00A614  24040001   ADDIU A0, ZERO, 1
9D00A618  AFA4001C   SW A0, 28(SP)
9D00A61C  24050001   ADDIU A1, ZERO, 1
9D00A620  0B404D98   J .L45
9D00A624  AFA50028   SW A1, 40(SP)
9D00A658  24060001   ADDIU A2, ZERO, 1
9D00A65C  AFA6001C   SW A2, 28(SP)
9D00A660  24070001   ADDIU A3, ZERO, 1
1466:                         OPCODE_END
9D00A60C  1C400006   BGTZ V0, 0x9D00A628
9D00A610  AC640054   SW A0, 84(V1)
9D00A628  26300001   ADDIU S0, S1, 1
9D00A648  90420000   LBU V0, 0(V0)
9D00A64C  00021080   SLL V0, V0, 2
9D00A650  00561021   ADDU V0, V0, S6
9D00A654  8C420000   LW V0, 0(V0)
9D00A664  0B402953   J 0x9D00A54C
9D00A668  AFA70028   SW A3, 40(SP)
1467:                
1468:                      OPCODE_BEGIN(01)  /* ORA ($nn,X) */
1469:                         ORA(6, INDIR_X_BYTE);
9D00A66C  26110001   ADDIU S1, S0, 1
9D00A68C  90420000   LBU V0, 0(V0)
9D00A690  03C21021   ADDU V0, FP, V0
9D00A6AC  0F402804   JAL mem_readbyte
9D00A6B0  308400FF   ANDI A0, A0, 255
9D00A6B4  00541025   OR V0, V0, S4
9D00A6B8  305200FF   ANDI S2, V0, 255
9D00A6BC  8F828058   LW V0, -32680(GP)
9D00A6C0  2442FFFA   ADDIU V0, V0, -6
9D00A6C4  AF828058   SW V0, -32680(GP)
9D00A6C8  8EA30054   LW V1, 84(S5)
9D00A6CC  24630006   ADDIU V1, V1, 6
9D00A6D8  0240A021   ADDU S4, S2, ZERO
9D00A6DC  0B404D98   J .L45
9D00A6E0  0240A821   ADDU S5, S2, ZERO
9D00A714  0240A021   ADDU S4, S2, ZERO
1470:                         OPCODE_END
9D00A6D0  1C400004   BGTZ V0, 0x9D00A6E4
9D00A6D4  AEA30054   SW V1, 84(S5)
9D00A6E4  26100002   ADDIU S0, S0, 2
9D00A704  90420000   LBU V0, 0(V0)
9D00A708  00021080   SLL V0, V0, 2
9D00A70C  00561021   ADDU V0, V0, S6
9D00A710  8C420000   LW V0, 0(V0)
9D00A718  0B402953   J 0x9D00A54C
9D00A71C  0240A821   ADDU S5, S2, ZERO
1471:                
1472:                      OPCODE_BEGIN(02)  /* JAM */
1473:                      OPCODE_BEGIN(12)  /* JAM */
1474:                      OPCODE_BEGIN(22)  /* JAM */
1475:                      OPCODE_BEGIN(32)  /* JAM */
1476:                      OPCODE_BEGIN(42)  /* JAM */
1477:                      OPCODE_BEGIN(52)  /* JAM */
1478:                      OPCODE_BEGIN(62)  /* JAM */
1479:                      OPCODE_BEGIN(72)  /* JAM */
1480:                      OPCODE_BEGIN(92)  /* JAM */
1481:                      OPCODE_BEGIN(B2)  /* JAM */
1482:                      OPCODE_BEGIN(D2)  /* JAM */
1483:                      OPCODE_BEGIN(F2)  /* JAM */
1484:                         JAM();
9D00A720  0B4029DD   J 0x9D00A774
9D00A724  2611FFFF   ADDIU S1, S0, -1
9D00A728  0B4029DD   J 0x9D00A774
9D00A72C  2611FFFF   ADDIU S1, S0, -1
9D00A730  0B4029DD   J 0x9D00A774
9D00A734  2611FFFF   ADDIU S1, S0, -1
9D00A738  0B4029DD   J 0x9D00A774
9D00A73C  2611FFFF   ADDIU S1, S0, -1
9D00A740  0B4029DD   J 0x9D00A774
9D00A744  2611FFFF   ADDIU S1, S0, -1
9D00A748  0B4029DD   J 0x9D00A774
9D00A74C  2611FFFF   ADDIU S1, S0, -1
9D00A750  0B4029DD   J 0x9D00A774
9D00A754  2611FFFF   ADDIU S1, S0, -1
9D00A758  0B4029DD   J 0x9D00A774
9D00A75C  2611FFFF   ADDIU S1, S0, -1
9D00A760  0B4029DD   J 0x9D00A774
9D00A764  2611FFFF   ADDIU S1, S0, -1
9D00A768  0B4029DD   J 0x9D00A774
9D00A76C  2611FFFF   ADDIU S1, S0, -1
9D00A770  2611FFFF   ADDIU S1, S0, -1
9D00A774  3C02A001   LUI V0, -24575
9D00A778  24428FD8   ADDIU V0, V0, -28712
9D00A77C  24030001   ADDIU V1, ZERO, 1
9D00A780  A0430051   SB V1, 81(V0)
9D00A784  A0400052   SB ZERO, 82(V0)
9D00A788  8C430054   LW V1, 84(V0)
9D00A78C  24630002   ADDIU V1, V1, 2
9D00A790  AC430054   SW V1, 84(V0)
9D00A794  0B404D98   J .L45
9D00A798  AF808058   SW ZERO, -32680(GP)
1485:                         /* kill the CPU */
1486:                         remaining_cycles = 0;
1487:                         OPCODE_END
1488:                
1489:                      OPCODE_BEGIN(03)  /* SLO ($nn,X) */
1490:                         SLO(8, INDIR_X, mem_writebyte, addr);
9D00A79C  26110001   ADDIU S1, S0, 1
9D00A7BC  90420000   LBU V0, 0(V0)
9D00A7C0  03C21021   ADDU V0, FP, V0
9D00A7E4  0F402804   JAL mem_readbyte
9D00A7E8  00402021   ADDU A0, V0, ZERO
9D00A7EC  7C5739C0   EXT S7, V0, 7, 8
9D00A7F0  00021040   SLL V0, V0, 1
9D00A7F4  305200FF   ANDI S2, V0, 255
9D00A7F8  8FA4002C   LW A0, 44(SP)
9D00A7FC  0F40283A   JAL mem_writebyte
9D00A800  02402821   ADDU A1, S2, ZERO
9D00A804  02549025   OR S2, S2, S4
9D00A808  325200FF   ANDI S2, S2, 255
9D00A80C  8F828058   LW V0, -32680(GP)
9D00A810  2442FFF8   ADDIU V0, V0, -8
9D00A814  AF828058   SW V0, -32680(GP)
9D00A818  8EA30054   LW V1, 84(S5)
9D00A81C  24630008   ADDIU V1, V1, 8
9D00A828  0240A021   ADDU S4, S2, ZERO
9D00A82C  0B404D98   J .L45
9D00A830  0240A821   ADDU S5, S2, ZERO
9D00A864  0240A021   ADDU S4, S2, ZERO
1491:                         OPCODE_END
9D00A820  1C400004   BGTZ V0, 0x9D00A834
9D00A824  AEA30054   SW V1, 84(S5)
9D00A834  26100002   ADDIU S0, S0, 2
9D00A854  90420000   LBU V0, 0(V0)
9D00A858  00021080   SLL V0, V0, 2
9D00A85C  00561021   ADDU V0, V0, S6
9D00A860  8C420000   LW V0, 0(V0)
9D00A868  0B402953   J 0x9D00A54C
9D00A86C  0240A821   ADDU S5, S2, ZERO
1492:                
1493:                      OPCODE_BEGIN(04)  /* NOP $nn */
1494:                      OPCODE_BEGIN(44)  /* NOP $nn */
1495:                      OPCODE_BEGIN(64)  /* NOP $nn */
1496:                         DOP(3);
9D00A870  0B402A1F   J 0x9D00A87C
9D00A874  26110001   ADDIU S1, S0, 1
9D00A878  26110001   ADDIU S1, S0, 1
9D00A87C  8F828058   LW V0, -32680(GP)
9D00A880  2442FFFD   ADDIU V0, V0, -3
9D00A884  AF828058   SW V0, -32680(GP)
9D00A888  26638FD8   ADDIU V1, S3, -28712
9D00A88C  8C640054   LW A0, 84(V1)
9D00A890  24840003   ADDIU A0, A0, 3
1497:                         OPCODE_END
9D00A894  18402372   BLEZ V0, .L45
9D00A898  AC640054   SW A0, 84(V1)
9D00A89C  26100002   ADDIU S0, S0, 2
9D00A8BC  90420000   LBU V0, 0(V0)
9D00A8C0  00021080   SLL V0, V0, 2
9D00A8C4  00561021   ADDU V0, V0, S6
9D00A8C8  0B402953   J 0x9D00A54C
9D00A8CC  8C420000   LW V0, 0(V0)
1498:                
1499:                      OPCODE_BEGIN(05)  /* ORA $nn */
1500:                         ORA(3, ZERO_PAGE_BYTE); 
9D00A8D0  26110001   ADDIU S1, S0, 1
9D00A8F0  90630000   LBU V1, 0(V1)
9D00A8F4  8F848054   LW A0, -32684(GP)
9D00A8F8  00831821   ADDU V1, A0, V1
9D00A8FC  90720000   LBU S2, 0(V1)
9D00A900  02929025   OR S2, S4, S2
9D00A904  325200FF   ANDI S2, S2, 255
9D00A908  8F838058   LW V1, -32680(GP)
9D00A90C  2463FFFD   ADDIU V1, V1, -3
9D00A910  AF838058   SW V1, -32680(GP)
9D00A914  8C440054   LW A0, 84(V0)
9D00A918  24840003   ADDIU A0, A0, 3
9D00A924  0240A021   ADDU S4, S2, ZERO
9D00A928  0B404D98   J .L45
9D00A92C  0240A821   ADDU S5, S2, ZERO
9D00A960  0240A021   ADDU S4, S2, ZERO
1501:                         OPCODE_END
9D00A91C  1C600004   BGTZ V1, 0x9D00A930
9D00A920  AC440054   SW A0, 84(V0)
9D00A930  26100002   ADDIU S0, S0, 2
9D00A950  90420000   LBU V0, 0(V0)
9D00A954  00021080   SLL V0, V0, 2
9D00A958  00561021   ADDU V0, V0, S6
9D00A95C  8C420000   LW V0, 0(V0)
9D00A964  0B402953   J 0x9D00A54C
9D00A968  0240A821   ADDU S5, S2, ZERO
1502:                
1503:                      OPCODE_BEGIN(06)  /* ASL $nn */
1504:                         ASL(5, ZERO_PAGE, ZP_WRITEBYTE, baddr);
9D00A96C  26110001   ADDIU S1, S0, 1
9D00A98C  90630000   LBU V1, 0(V1)
9D00A990  8F848054   LW A0, -32684(GP)
9D00A994  00831821   ADDU V1, A0, V1
9D00A998  90640000   LBU A0, 0(V1)
9D00A99C  0004B9C2   SRL S7, A0, 7
9D00A9A0  00042040   SLL A0, A0, 1
9D00A9A4  309200FF   ANDI S2, A0, 255
9D00A9A8  A0720000   SB S2, 0(V1)
9D00A9AC  8F838058   LW V1, -32680(GP)
9D00A9B0  2463FFFB   ADDIU V1, V1, -5
9D00A9B4  AF838058   SW V1, -32680(GP)
9D00A9B8  8C440054   LW A0, 84(V0)
9D00A9BC  24840005   ADDIU A0, A0, 5
9D00A9C8  0B404D98   J .L45
9D00A9CC  0240A821   ADDU S5, S2, ZERO
1505:                         OPCODE_END
9D00A9C0  1C600003   BGTZ V1, 0x9D00A9D0
9D00A9C4  AC440054   SW A0, 84(V0)
9D00A9D0  26100002   ADDIU S0, S0, 2
9D00A9F0  90420000   LBU V0, 0(V0)
9D00A9F4  00021080   SLL V0, V0, 2
9D00A9F8  00561021   ADDU V0, V0, S6
9D00A9FC  8C420000   LW V0, 0(V0)
9D00AA00  0B402953   J 0x9D00A54C
9D00AA04  0240A821   ADDU S5, S2, ZERO
1506:                
1507:                      OPCODE_BEGIN(07)  /* SLO $nn */
1508:                         SLO(5, ZERO_PAGE, ZP_WRITEBYTE, baddr);
9D00AA08  26110001   ADDIU S1, S0, 1
9D00AA28  90630000   LBU V1, 0(V1)
9D00AA2C  8F848054   LW A0, -32684(GP)
9D00AA30  00832021   ADDU A0, A0, V1
9D00AA34  90830000   LBU V1, 0(A0)
9D00AA38  0003B9C2   SRL S7, V1, 7
9D00AA3C  00031840   SLL V1, V1, 1
9D00AA40  306300FF   ANDI V1, V1, 255
9D00AA44  A0830000   SB V1, 0(A0)
9D00AA48  00741825   OR V1, V1, S4
9D00AA4C  307200FF   ANDI S2, V1, 255
9D00AA50  8F838058   LW V1, -32680(GP)
9D00AA54  2463FFFB   ADDIU V1, V1, -5
9D00AA58  AF838058   SW V1, -32680(GP)
9D00AA5C  8C440054   LW A0, 84(V0)
9D00AA60  24840005   ADDIU A0, A0, 5
9D00AA6C  0240A021   ADDU S4, S2, ZERO
9D00AA70  0B404D98   J .L45
9D00AA74  0240A821   ADDU S5, S2, ZERO
9D00AAA8  0240A021   ADDU S4, S2, ZERO
1509:                         OPCODE_END
9D00AA64  1C600004   BGTZ V1, 0x9D00AA78
9D00AA68  AC440054   SW A0, 84(V0)
9D00AA78  26100002   ADDIU S0, S0, 2
9D00AA98  90420000   LBU V0, 0(V0)
9D00AA9C  00021080   SLL V0, V0, 2
9D00AAA0  00561021   ADDU V0, V0, S6
9D00AAA4  8C420000   LW V0, 0(V0)
9D00AAAC  0B402953   J 0x9D00A54C
9D00AAB0  0240A821   ADDU S5, S2, ZERO
1510:                
1511:                      OPCODE_BEGIN(08)  /* PHP */
1512:                         PHP(); 
9D00AAB4  8FA20018   LW V0, 24(SP)
9D00AAB8  2444FFFF   ADDIU A0, V0, -1
9D00AABC  308400FF   ANDI A0, A0, 255
9D00AAC0  8F828050   LW V0, -32688(GP)
9D00AAC4  8FA30018   LW V1, 24(SP)
9D00AAC8  00431021   ADDU V0, V0, V1
9D00AACC  2405FF80   ADDIU A1, ZERO, -128
9D00AAD0  02455024   AND T2, S2, A1
9D00AAD4  7C0A5420   SEB T2, T2
9D00AAD8  24090040   ADDIU T1, ZERO, 64
9D00AADC  8FA60014   LW A2, 20(SP)
9D00AAE0  0006480A   MOVZ T1, ZERO, A2
9D00AAE4  24080010   ADDIU T0, ZERO, 16
9D00AAE8  8FA70028   LW A3, 40(SP)
9D00AAEC  0007400A   MOVZ T0, ZERO, A3
9D00AAF0  24070008   ADDIU A3, ZERO, 8
9D00AAF4  8FA30020   LW V1, 32(SP)
9D00AAF8  0003380A   MOVZ A3, ZERO, V1
9D00AAFC  24060004   ADDIU A2, ZERO, 4
9D00AB00  8FA5001C   LW A1, 28(SP)
9D00AB04  0005300A   MOVZ A2, ZERO, A1
9D00AB08  24050002   ADDIU A1, ZERO, 2
9D00AB0C  0015280B   MOVN A1, ZERO, S5
9D00AB10  36E30030   ORI V1, S7, 48
9D00AB14  01431825   OR V1, T2, V1
9D00AB18  01231825   OR V1, T1, V1
9D00AB1C  01031825   OR V1, T0, V1
9D00AB20  00E31825   OR V1, A3, V1
9D00AB24  00C31825   OR V1, A2, V1
9D00AB28  00A31825   OR V1, A1, V1
9D00AB2C  A0430000   SB V1, 0(V0)
9D00AB30  8F828058   LW V0, -32680(GP)
9D00AB34  2442FFFD   ADDIU V0, V0, -3
9D00AB38  AF828058   SW V0, -32680(GP)
9D00AB3C  26638FD8   ADDIU V1, S3, -28712
9D00AB40  8C650054   LW A1, 84(V1)
9D00AB44  24A50003   ADDIU A1, A1, 3
9D00AB50  AFA40018   SW A0, 24(SP)
9D00AB88  AFA40018   SW A0, 24(SP)
1513:                         OPCODE_END
9D00AB48  1C400004   BGTZ V0, .LBB792
9D00AB4C  AC650054   SW A1, 84(V1)
9D00AB54  0B404D98   J .L45
9D00AB58  02008821   ADDU S1, S0, ZERO
9D00AB78  90420000   LBU V0, 0(V0)
9D00AB7C  00021080   SLL V0, V0, 2
9D00AB80  00561021   ADDU V0, V0, S6
9D00AB84  8C420000   LW V0, 0(V0)
9D00AB8C  0B402953   J 0x9D00A54C
9D00AB90  26100001   ADDIU S0, S0, 1
1514:                
1515:                      OPCODE_BEGIN(09)  /* ORA #$nn */
1516:                         ORA(2, IMMEDIATE_BYTE);
9D00AB94  26110001   ADDIU S1, S0, 1
9D00ABB4  90720000   LBU S2, 0(V1)
9D00ABB8  02929025   OR S2, S4, S2
9D00ABBC  325200FF   ANDI S2, S2, 255
9D00ABC0  8F838058   LW V1, -32680(GP)
9D00ABC4  2463FFFE   ADDIU V1, V1, -2
9D00ABC8  AF838058   SW V1, -32680(GP)
9D00ABCC  8C440054   LW A0, 84(V0)
9D00ABD0  24840002   ADDIU A0, A0, 2
9D00ABDC  0240A021   ADDU S4, S2, ZERO
9D00ABE0  0B404D98   J .L45
9D00ABE4  0240A821   ADDU S5, S2, ZERO
9D00AC18  0240A021   ADDU S4, S2, ZERO
1517:                         OPCODE_END
9D00ABD4  1C600004   BGTZ V1, 0x9D00ABE8
9D00ABD8  AC440054   SW A0, 84(V0)
9D00ABE8  26100002   ADDIU S0, S0, 2
9D00AC08  90420000   LBU V0, 0(V0)
9D00AC0C  00021080   SLL V0, V0, 2
9D00AC10  00561021   ADDU V0, V0, S6
9D00AC14  8C420000   LW V0, 0(V0)
9D00AC1C  0B402953   J 0x9D00A54C
9D00AC20  0240A821   ADDU S5, S2, ZERO
1518:                
1519:                      OPCODE_BEGIN(0A)  /* ASL A */
1520:                         ASL_A();
9D00AC24  7E9739C0   EXT S7, S4, 7, 8
9D00AC28  00149040   SLL S2, S4, 1
9D00AC2C  325200FF   ANDI S2, S2, 255
9D00AC30  8F828058   LW V0, -32680(GP)
9D00AC34  2442FFFE   ADDIU V0, V0, -2
9D00AC38  AF828058   SW V0, -32680(GP)
9D00AC3C  26638FD8   ADDIU V1, S3, -28712
9D00AC40  8C640054   LW A0, 84(V1)
9D00AC44  24840002   ADDIU A0, A0, 2
9D00AC50  0240A021   ADDU S4, S2, ZERO
9D00AC58  0B404D98   J .L45
9D00AC5C  0240A821   ADDU S5, S2, ZERO
9D00AC8C  0240A021   ADDU S4, S2, ZERO
1521:                         OPCODE_END
9D00AC48  1C400005   BGTZ V0, .LBB798
9D00AC4C  AC640054   SW A0, 84(V1)
9D00AC54  02008821   ADDU S1, S0, ZERO
9D00AC7C  90420000   LBU V0, 0(V0)
9D00AC80  00021080   SLL V0, V0, 2
9D00AC84  00561021   ADDU V0, V0, S6
9D00AC88  8C420000   LW V0, 0(V0)
9D00AC90  26100001   ADDIU S0, S0, 1
9D00AC94  0B402953   J 0x9D00A54C
9D00AC98  0240A821   ADDU S5, S2, ZERO
1522:                
1523:                      OPCODE_BEGIN(0B)  /* ANC #$nn */
1524:                         ANC(2, IMMEDIATE_BYTE);
9D00AC9C  26110001   ADDIU S1, S0, 1
9D00ACBC  90750000   LBU S5, 0(V1)
9D00ACC0  0295A824   AND S5, S4, S5
9D00ACC4  7E5739C0   EXT S7, S2, 7, 8
9D00ACC8  8F838058   LW V1, -32680(GP)
9D00ACCC  2463FFFE   ADDIU V1, V1, -2
9D00ACD0  AF838058   SW V1, -32680(GP)
9D00ACD4  8C440054   LW A0, 84(V0)
9D00ACD8  24840002   ADDIU A0, A0, 2
9D00ACE4  02A0A021   ADDU S4, S5, ZERO
9D00ACE8  0B404D98   J .L45
9D00ACEC  02A09021   ADDU S2, S5, ZERO
9D00AD20  02A0A021   ADDU S4, S5, ZERO
1525:                         OPCODE_END
9D00ACDC  1C600004   BGTZ V1, 0x9D00ACF0
9D00ACE0  AC440054   SW A0, 84(V0)
9D00ACF0  26100002   ADDIU S0, S0, 2
9D00AD10  90420000   LBU V0, 0(V0)
9D00AD14  00021080   SLL V0, V0, 2
9D00AD18  00561021   ADDU V0, V0, S6
9D00AD1C  8C420000   LW V0, 0(V0)
9D00AD24  0B402953   J 0x9D00A54C
9D00AD28  02A09021   ADDU S2, S5, ZERO
1526:                
1527:                      OPCODE_BEGIN(0C)  /* NOP $nnnn */
1528:                         TOP(); 
9D00AD2C  26110002   ADDIU S1, S0, 2
9D00AD30  8F828058   LW V0, -32680(GP)
9D00AD34  2442FFFC   ADDIU V0, V0, -4
9D00AD38  AF828058   SW V0, -32680(GP)
9D00AD3C  26638FD8   ADDIU V1, S3, -28712
9D00AD40  8C640054   LW A0, 84(V1)
9D00AD44  24840004   ADDIU A0, A0, 4
1529:                         OPCODE_END
9D00AD48  18402245   BLEZ V0, .L45
9D00AD4C  AC640054   SW A0, 84(V1)
9D00AD50  26100003   ADDIU S0, S0, 3
9D00AD70  90420000   LBU V0, 0(V0)
9D00AD74  00021080   SLL V0, V0, 2
9D00AD78  00561021   ADDU V0, V0, S6
9D00AD7C  0B402953   J 0x9D00A54C
9D00AD80  8C420000   LW V0, 0(V0)
1530:                
1531:                      OPCODE_BEGIN(0D)  /* ORA $nnnn */
1532:                         ORA(4, ABSOLUTE_BYTE);
9D00AD84  0F402863   JAL bank_readword
9D00AD88  02002021   ADDU A0, S0, ZERO
9D00AD8C  26110002   ADDIU S1, S0, 2
9D00AD90  0F402804   JAL mem_readbyte
9D00AD94  00402021   ADDU A0, V0, ZERO
9D00AD98  00541025   OR V0, V0, S4
9D00AD9C  305200FF   ANDI S2, V0, 255
9D00ADA0  8F828058   LW V0, -32680(GP)
9D00ADA4  2442FFFC   ADDIU V0, V0, -4
9D00ADA8  AF828058   SW V0, -32680(GP)
9D00ADAC  26638FD8   ADDIU V1, S3, -28712
9D00ADB0  8C640054   LW A0, 84(V1)
9D00ADB4  24840004   ADDIU A0, A0, 4
9D00ADC0  0240A021   ADDU S4, S2, ZERO
9D00ADC4  0B404D98   J .L45
9D00ADC8  0240A821   ADDU S5, S2, ZERO
9D00ADFC  0240A021   ADDU S4, S2, ZERO
1533:                         OPCODE_END
9D00ADB8  1C400004   BGTZ V0, 0x9D00ADCC
9D00ADBC  AC640054   SW A0, 84(V1)
9D00ADCC  26100003   ADDIU S0, S0, 3
9D00ADEC  90420000   LBU V0, 0(V0)
9D00ADF0  00021080   SLL V0, V0, 2
9D00ADF4  00561021   ADDU V0, V0, S6
9D00ADF8  8C420000   LW V0, 0(V0)
9D00AE00  0B402953   J 0x9D00A54C
9D00AE04  0240A821   ADDU S5, S2, ZERO
1534:                
1535:                      OPCODE_BEGIN(0E)  /* ASL $nnnn */
1536:                         ASL(6, ABSOLUTE, mem_writebyte, addr);
9D00AE08  0F402863   JAL bank_readword
9D00AE0C  02002021   ADDU A0, S0, ZERO
9D00AE10  0040A821   ADDU S5, V0, ZERO
9D00AE14  26110002   ADDIU S1, S0, 2
9D00AE18  0F402804   JAL mem_readbyte
9D00AE1C  00402021   ADDU A0, V0, ZERO
9D00AE20  7C5739C0   EXT S7, V0, 7, 8
9D00AE24  00021040   SLL V0, V0, 1
9D00AE28  305200FF   ANDI S2, V0, 255
9D00AE2C  02A02021   ADDU A0, S5, ZERO
9D00AE30  0F40283A   JAL mem_writebyte
9D00AE34  02402821   ADDU A1, S2, ZERO
9D00AE38  8F828058   LW V0, -32680(GP)
9D00AE3C  2442FFFA   ADDIU V0, V0, -6
9D00AE40  AF828058   SW V0, -32680(GP)
9D00AE44  26638FD8   ADDIU V1, S3, -28712
9D00AE48  8C640054   LW A0, 84(V1)
9D00AE4C  24840006   ADDIU A0, A0, 6
9D00AE58  0B404D98   J .L45
9D00AE5C  0240A821   ADDU S5, S2, ZERO
1537:                         OPCODE_END
9D00AE50  1C400003   BGTZ V0, 0x9D00AE60
9D00AE54  AC640054   SW A0, 84(V1)
9D00AE60  26100003   ADDIU S0, S0, 3
9D00AE80  90420000   LBU V0, 0(V0)
9D00AE84  00021080   SLL V0, V0, 2
9D00AE88  00561021   ADDU V0, V0, S6
9D00AE8C  8C420000   LW V0, 0(V0)
9D00AE90  0B402953   J 0x9D00A54C
9D00AE94  0240A821   ADDU S5, S2, ZERO
1538:                
1539:                      OPCODE_BEGIN(0F)  /* SLO $nnnn */
1540:                         SLO(6, ABSOLUTE, mem_writebyte, addr);
9D00AE98  0F402863   JAL bank_readword
9D00AE9C  02002021   ADDU A0, S0, ZERO
9D00AEA0  0040A821   ADDU S5, V0, ZERO
9D00AEA4  26110002   ADDIU S1, S0, 2
9D00AEA8  0F402804   JAL mem_readbyte
9D00AEAC  00402021   ADDU A0, V0, ZERO
9D00AEB0  7C5739C0   EXT S7, V0, 7, 8
9D00AEB4  00021040   SLL V0, V0, 1
9D00AEB8  305200FF   ANDI S2, V0, 255
9D00AEBC  02A02021   ADDU A0, S5, ZERO
9D00AEC0  0F40283A   JAL mem_writebyte
9D00AEC4  02402821   ADDU A1, S2, ZERO
9D00AEC8  02549025   OR S2, S2, S4
9D00AECC  325200FF   ANDI S2, S2, 255
9D00AED0  8F828058   LW V0, -32680(GP)
9D00AED4  2442FFFA   ADDIU V0, V0, -6
9D00AED8  AF828058   SW V0, -32680(GP)
9D00AEDC  26638FD8   ADDIU V1, S3, -28712
9D00AEE0  8C640054   LW A0, 84(V1)
9D00AEE4  24840006   ADDIU A0, A0, 6
9D00AEF0  0240A021   ADDU S4, S2, ZERO
9D00AEF4  0B404D98   J .L45
9D00AEF8  0240A821   ADDU S5, S2, ZERO
9D00AF2C  0240A021   ADDU S4, S2, ZERO
1541:                         OPCODE_END
9D00AEE8  1C400004   BGTZ V0, 0x9D00AEFC
9D00AEEC  AC640054   SW A0, 84(V1)
9D00AEFC  26100003   ADDIU S0, S0, 3
9D00AF1C  90420000   LBU V0, 0(V0)
9D00AF20  00021080   SLL V0, V0, 2
9D00AF24  00561021   ADDU V0, V0, S6
9D00AF28  8C420000   LW V0, 0(V0)
9D00AF30  0B402953   J 0x9D00A54C
9D00AF34  0240A821   ADDU S5, S2, ZERO
1542:                
1543:                      OPCODE_BEGIN(10)  /* BPL $nnnn */
1544:                         BPL();
9D00AF38  7C121420   SEB V0, S2
9D00AF3C  0440001D   BLTZ V0, 0x9D00AFB4
9D00AF40  26020001   ADDIU V0, S0, 1
9D00AF60  80710000   LB S1, 0(V1)
9D00AF64  304300FF   ANDI V1, V0, 255
9D00AF68  02231821   ADDU V1, S1, V1
9D00AF6C  30630100   ANDI V1, V1, 256
9D00AF70  10600008   BEQ V1, ZERO, 0x9D00AF94
9D00AF74  8F838058   LW V1, -32680(GP)
9D00AF78  2463FFFF   ADDIU V1, V1, -1
9D00AF7C  AF838058   SW V1, -32680(GP)
9D00AF80  26638FD8   ADDIU V1, S3, -28712
9D00AF84  8C640054   LW A0, 84(V1)
9D00AF88  24840001   ADDIU A0, A0, 1
9D00AF8C  AC640054   SW A0, 84(V1)
9D00AF90  8F838058   LW V1, -32680(GP)
9D00AF94  2463FFFD   ADDIU V1, V1, -3
9D00AF98  AF838058   SW V1, -32680(GP)
9D00AF9C  26638FD8   ADDIU V1, S3, -28712
9D00AFA0  8C640054   LW A0, 84(V1)
9D00AFA4  24840003   ADDIU A0, A0, 3
9D00AFA8  AC640054   SW A0, 84(V1)
9D00AFAC  0B402BF5   J 0x9D00AFD4
9D00AFB0  02228821   ADDU S1, S1, V0
9D00AFB4  26110001   ADDIU S1, S0, 1
9D00AFB8  8F828058   LW V0, -32680(GP)
9D00AFBC  2442FFFE   ADDIU V0, V0, -2
9D00AFC0  AF828058   SW V0, -32680(GP)
9D00AFC4  26628FD8   ADDIU V0, S3, -28712
9D00AFC8  8C430054   LW V1, 84(V0)
9D00AFCC  24630002   ADDIU V1, V1, 2
9D00AFD0  AC430054   SW V1, 84(V0)
1545:                         OPCODE_END
9D00AFD4  8F828058   LW V0, -32680(GP)
9D00AFD8  184021A1   BLEZ V0, .L45
9D00AFDC  26300001   ADDIU S0, S1, 1
9D00AFFC  90420000   LBU V0, 0(V0)
9D00B000  00021080   SLL V0, V0, 2
9D00B004  00561021   ADDU V0, V0, S6
9D00B008  0B402953   J 0x9D00A54C
9D00B00C  8C420000   LW V0, 0(V0)
1546:                
1547:                      OPCODE_BEGIN(11)  /* ORA ($nn),Y */
1548:                         ORA(5, INDIR_Y_BYTE_READ);
9D00B048  8FA60010   LW A2, 16(SP)
9D00B04C  00862021   ADDU A0, A0, A2
9D00B050  3084FFFF   ANDI A0, A0, -1
9D00B054  308200FF   ANDI V0, A0, 255
9D00B058  0046102B   SLTU V0, V0, A2
9D00B05C  10400008   BEQ V0, ZERO, 0x9D00B080
9D00B060  26110001   ADDIU S1, S0, 1
9D00B064  8F828058   LW V0, -32680(GP)
9D00B068  2442FFFF   ADDIU V0, V0, -1
9D00B06C  AF828058   SW V0, -32680(GP)
9D00B070  26628FD8   ADDIU V0, S3, -28712
9D00B074  8C430054   LW V1, 84(V0)
9D00B078  24630001   ADDIU V1, V1, 1
9D00B07C  AC430054   SW V1, 84(V0)
9D00B080  0F402804   JAL mem_readbyte
9D00B084  00000000   NOP
9D00B088  00541025   OR V0, V0, S4
9D00B08C  305200FF   ANDI S2, V0, 255
9D00B090  8F828058   LW V0, -32680(GP)
9D00B094  2442FFFB   ADDIU V0, V0, -5
9D00B098  AF828058   SW V0, -32680(GP)
9D00B09C  26638FD8   ADDIU V1, S3, -28712
9D00B0A0  8C640054   LW A0, 84(V1)
9D00B0A4  24840005   ADDIU A0, A0, 5
9D00B0B0  0240A021   ADDU S4, S2, ZERO
9D00B0B4  0B404D98   J .L45
9D00B0B8  0240A821   ADDU S5, S2, ZERO
9D00B0EC  0240A021   ADDU S4, S2, ZERO
1549:                         OPCODE_END
9D00B0A8  1C400004   BGTZ V0, 0x9D00B0BC
9D00B0AC  AC640054   SW A0, 84(V1)
9D00B0BC  26100002   ADDIU S0, S0, 2
9D00B0DC  90420000   LBU V0, 0(V0)
9D00B0E0  00021080   SLL V0, V0, 2
9D00B0E4  00561021   ADDU V0, V0, S6
9D00B0E8  8C420000   LW V0, 0(V0)
9D00B0F0  0B402953   J 0x9D00A54C
9D00B0F4  0240A821   ADDU S5, S2, ZERO
1550:                      
1551:                      OPCODE_BEGIN(13)  /* SLO ($nn),Y */
1552:                         SLO(8, INDIR_Y, mem_writebyte, addr);
9D00B0F8  26110001   ADDIU S1, S0, 1
9D00B134  8FA70010   LW A3, 16(SP)
9D00B138  00471021   ADDU V0, V0, A3
9D00B13C  3042FFFF   ANDI V0, V0, -1
9D00B140  AFA2002C   SW V0, 44(SP)
9D00B144  0F402804   JAL mem_readbyte
9D00B148  00402021   ADDU A0, V0, ZERO
9D00B14C  7C5739C0   EXT S7, V0, 7, 8
9D00B150  00021040   SLL V0, V0, 1
9D00B154  305200FF   ANDI S2, V0, 255
9D00B158  8FA4002C   LW A0, 44(SP)
9D00B15C  0F40283A   JAL mem_writebyte
9D00B160  02402821   ADDU A1, S2, ZERO
9D00B164  02549025   OR S2, S2, S4
9D00B168  325200FF   ANDI S2, S2, 255
9D00B16C  8F828058   LW V0, -32680(GP)
9D00B170  2442FFF8   ADDIU V0, V0, -8
9D00B174  AF828058   SW V0, -32680(GP)
9D00B178  8EA30054   LW V1, 84(S5)
9D00B17C  24630008   ADDIU V1, V1, 8
9D00B188  0240A021   ADDU S4, S2, ZERO
9D00B18C  0B404D98   J .L45
9D00B190  0240A821   ADDU S5, S2, ZERO
9D00B1C4  0240A021   ADDU S4, S2, ZERO
1553:                         OPCODE_END
9D00B180  1C400004   BGTZ V0, 0x9D00B194
9D00B184  AEA30054   SW V1, 84(S5)
9D00B194  26100002   ADDIU S0, S0, 2
9D00B1B4  90420000   LBU V0, 0(V0)
9D00B1B8  00021080   SLL V0, V0, 2
9D00B1BC  00561021   ADDU V0, V0, S6
9D00B1C0  8C420000   LW V0, 0(V0)
9D00B1C8  0B402953   J 0x9D00A54C
9D00B1CC  0240A821   ADDU S5, S2, ZERO
1554:                
1555:                      OPCODE_BEGIN(14)  /* NOP $nn,X */
1556:                      OPCODE_BEGIN(34)  /* NOP */
1557:                      OPCODE_BEGIN(54)  /* NOP $nn,X */
1558:                      OPCODE_BEGIN(74)  /* NOP $nn,X */
1559:                      OPCODE_BEGIN(D4)  /* NOP $nn,X */
1560:                      OPCODE_BEGIN(F4)  /* NOP ($nn,X) */
1561:                         DOP(4);
9D00B1D0  0B402C7D   J 0x9D00B1F4
9D00B1D4  26110001   ADDIU S1, S0, 1
9D00B1D8  0B402C7D   J 0x9D00B1F4
9D00B1DC  26110001   ADDIU S1, S0, 1
9D00B1E0  0B402C7D   J 0x9D00B1F4
9D00B1E4  26110001   ADDIU S1, S0, 1
9D00B1E8  0B402C7D   J 0x9D00B1F4
9D00B1EC  26110001   ADDIU S1, S0, 1
9D00B1F0  26110001   ADDIU S1, S0, 1
9D00B1F4  8F828058   LW V0, -32680(GP)
9D00B1F8  2442FFFC   ADDIU V0, V0, -4
9D00B1FC  AF828058   SW V0, -32680(GP)
9D00B200  26638FD8   ADDIU V1, S3, -28712
9D00B204  8C640054   LW A0, 84(V1)
9D00B208  24840004   ADDIU A0, A0, 4
1562:                         OPCODE_END
9D00B20C  18402114   BLEZ V0, .L45
9D00B210  AC640054   SW A0, 84(V1)
9D00B214  26100002   ADDIU S0, S0, 2
9D00B234  92220000   LBU V0, 0(S1)
9D00B238  00021080   SLL V0, V0, 2
9D00B23C  00561021   ADDU V0, V0, S6
9D00B240  0B402953   J 0x9D00A54C
9D00B244  8C420000   LW V0, 0(V0)
1563:                
1564:                      OPCODE_BEGIN(15)  /* ORA $nn,X */
1565:                         ORA(4, ZP_IND_X_BYTE);
9D00B248  26110001   ADDIU S1, S0, 1
9D00B268  90630000   LBU V1, 0(V1)
9D00B26C  03C31821   ADDU V1, FP, V1
9D00B270  306300FF   ANDI V1, V1, 255
9D00B274  8F848054   LW A0, -32684(GP)
9D00B278  00831821   ADDU V1, A0, V1
9D00B27C  90720000   LBU S2, 0(V1)
9D00B280  02549025   OR S2, S2, S4
9D00B284  325200FF   ANDI S2, S2, 255
9D00B288  8F838058   LW V1, -32680(GP)
9D00B28C  2463FFFC   ADDIU V1, V1, -4
9D00B290  AF838058   SW V1, -32680(GP)
9D00B294  8C440054   LW A0, 84(V0)
9D00B298  24840004   ADDIU A0, A0, 4
9D00B2A4  0240A021   ADDU S4, S2, ZERO
9D00B2A8  0B404D98   J .L45
9D00B2AC  0240A821   ADDU S5, S2, ZERO
9D00B2E0  0240A021   ADDU S4, S2, ZERO
1566:                         OPCODE_END
9D00B29C  1C600004   BGTZ V1, 0x9D00B2B0
9D00B2A0  AC440054   SW A0, 84(V0)
9D00B2B0  26100002   ADDIU S0, S0, 2
9D00B2D0  90420000   LBU V0, 0(V0)
9D00B2D4  00021080   SLL V0, V0, 2
9D00B2D8  00561021   ADDU V0, V0, S6
9D00B2DC  8C420000   LW V0, 0(V0)
9D00B2E4  0B402953   J 0x9D00A54C
9D00B2E8  0240A821   ADDU S5, S2, ZERO
1567:                
1568:                      OPCODE_BEGIN(16)  /* ASL $nn,X */
1569:                         ASL(6, ZP_IND_X, ZP_WRITEBYTE, baddr);
9D00B2EC  26110001   ADDIU S1, S0, 1
9D00B30C  90630000   LBU V1, 0(V1)
9D00B310  03C31821   ADDU V1, FP, V1
9D00B314  306300FF   ANDI V1, V1, 255
9D00B318  8F848054   LW A0, -32684(GP)
9D00B31C  00831821   ADDU V1, A0, V1
9D00B320  90640000   LBU A0, 0(V1)
9D00B324  0004B9C2   SRL S7, A0, 7
9D00B328  00042040   SLL A0, A0, 1
9D00B32C  309200FF   ANDI S2, A0, 255
9D00B330  A0720000   SB S2, 0(V1)
9D00B334  8F838058   LW V1, -32680(GP)
9D00B338  2463FFFA   ADDIU V1, V1, -6
9D00B33C  AF838058   SW V1, -32680(GP)
9D00B340  8C440054   LW A0, 84(V0)
9D00B344  24840006   ADDIU A0, A0, 6
9D00B350  0B404D98   J .L45
9D00B354  0240A821   ADDU S5, S2, ZERO
1570:                         OPCODE_END
9D00B348  1C600003   BGTZ V1, 0x9D00B358
9D00B34C  AC440054   SW A0, 84(V0)
9D00B358  26100002   ADDIU S0, S0, 2
9D00B378  90420000   LBU V0, 0(V0)
9D00B37C  00021080   SLL V0, V0, 2
9D00B380  00561021   ADDU V0, V0, S6
9D00B384  8C420000   LW V0, 0(V0)
9D00B388  0B402953   J 0x9D00A54C
9D00B38C  0240A821   ADDU S5, S2, ZERO
1571:                
1572:                      OPCODE_BEGIN(17)  /* SLO $nn,X */
1573:                         SLO(6, ZP_IND_X, ZP_WRITEBYTE, baddr);
9D00B390  26110001   ADDIU S1, S0, 1
9D00B3B0  90630000   LBU V1, 0(V1)
9D00B3B4  03C31821   ADDU V1, FP, V1
9D00B3B8  306300FF   ANDI V1, V1, 255
9D00B3BC  8F848054   LW A0, -32684(GP)
9D00B3C0  00832021   ADDU A0, A0, V1
9D00B3C4  90830000   LBU V1, 0(A0)
9D00B3C8  0003B9C2   SRL S7, V1, 7
9D00B3CC  00031840   SLL V1, V1, 1
9D00B3D0  306300FF   ANDI V1, V1, 255
9D00B3D4  A0830000   SB V1, 0(A0)
9D00B3D8  00741825   OR V1, V1, S4
9D00B3DC  307200FF   ANDI S2, V1, 255
9D00B3E0  8F838058   LW V1, -32680(GP)
9D00B3E4  2463FFFA   ADDIU V1, V1, -6
9D00B3E8  AF838058   SW V1, -32680(GP)
9D00B3EC  8C440054   LW A0, 84(V0)
9D00B3F0  24840006   ADDIU A0, A0, 6
9D00B3FC  0240A021   ADDU S4, S2, ZERO
9D00B400  0B404D98   J .L45
9D00B404  0240A821   ADDU S5, S2, ZERO
9D00B438  0240A021   ADDU S4, S2, ZERO
1574:                         OPCODE_END
9D00B3F4  1C600004   BGTZ V1, 0x9D00B408
9D00B3F8  AC440054   SW A0, 84(V0)
9D00B408  26100002   ADDIU S0, S0, 2
9D00B428  90420000   LBU V0, 0(V0)
9D00B42C  00021080   SLL V0, V0, 2
9D00B430  00561021   ADDU V0, V0, S6
9D00B434  8C420000   LW V0, 0(V0)
9D00B43C  0B402953   J 0x9D00A54C
9D00B440  0240A821   ADDU S5, S2, ZERO
1575:                
1576:                      OPCODE_BEGIN(18)  /* CLC */
1577:                         CLC();
9D00B444  8F828058   LW V0, -32680(GP)
9D00B448  2442FFFE   ADDIU V0, V0, -2
9D00B44C  AF828058   SW V0, -32680(GP)
9D00B450  26638FD8   ADDIU V1, S3, -28712
9D00B454  8C640054   LW A0, 84(V1)
9D00B458  24840002   ADDIU A0, A0, 2
9D00B468  0B404D98   J .L45
9D00B46C  0000B821   ADDU S7, ZERO, ZERO
1578:                         OPCODE_END
9D00B45C  1C400004   BGTZ V0, .LBB842
9D00B460  AC640054   SW A0, 84(V1)
9D00B464  02008821   ADDU S1, S0, ZERO
9D00B48C  90420000   LBU V0, 0(V0)
9D00B490  00021080   SLL V0, V0, 2
9D00B494  00561021   ADDU V0, V0, S6
9D00B498  8C420000   LW V0, 0(V0)
9D00B49C  26100001   ADDIU S0, S0, 1
9D00B4A0  0B402953   J 0x9D00A54C
9D00B4A4  0000B821   ADDU S7, ZERO, ZERO
1579:                
1580:                      OPCODE_BEGIN(19)  /* ORA $nnnn,Y */
1581:                         ORA(4, ABS_IND_Y_BYTE_READ);
9D00B4A8  0F402863   JAL bank_readword
9D00B4AC  02002021   ADDU A0, S0, ZERO
9D00B4B0  8FA30010   LW V1, 16(SP)
9D00B4B4  00431021   ADDU V0, V0, V1
9D00B4B8  3044FFFF   ANDI A0, V0, -1
9D00B4BC  308200FF   ANDI V0, A0, 255
9D00B4C0  0043102B   SLTU V0, V0, V1
9D00B4C4  10400008   BEQ V0, ZERO, 0x9D00B4E8
9D00B4C8  26110002   ADDIU S1, S0, 2
9D00B4CC  8F828058   LW V0, -32680(GP)
9D00B4D0  2442FFFF   ADDIU V0, V0, -1
9D00B4D4  AF828058   SW V0, -32680(GP)
9D00B4D8  26628FD8   ADDIU V0, S3, -28712
9D00B4DC  8C430054   LW V1, 84(V0)
9D00B4E0  24630001   ADDIU V1, V1, 1
9D00B4E4  AC430054   SW V1, 84(V0)
9D00B4E8  0F402804   JAL mem_readbyte
9D00B4EC  00000000   NOP
9D00B4F0  00541025   OR V0, V0, S4
9D00B4F4  305200FF   ANDI S2, V0, 255
9D00B4F8  8F828058   LW V0, -32680(GP)
9D00B4FC  2442FFFC   ADDIU V0, V0, -4
9D00B500  AF828058   SW V0, -32680(GP)
9D00B504  26638FD8   ADDIU V1, S3, -28712
9D00B508  8C640054   LW A0, 84(V1)
9D00B50C  24840004   ADDIU A0, A0, 4
9D00B518  0240A021   ADDU S4, S2, ZERO
9D00B51C  0B404D98   J .L45
9D00B520  0240A821   ADDU S5, S2, ZERO
9D00B554  0240A021   ADDU S4, S2, ZERO
1582:                         OPCODE_END
9D00B510  1C400004   BGTZ V0, 0x9D00B524
9D00B514  AC640054   SW A0, 84(V1)
9D00B524  26100003   ADDIU S0, S0, 3
9D00B544  90420000   LBU V0, 0(V0)
9D00B548  00021080   SLL V0, V0, 2
9D00B54C  00561021   ADDU V0, V0, S6
9D00B550  8C420000   LW V0, 0(V0)
9D00B558  0B402953   J 0x9D00A54C
9D00B55C  0240A821   ADDU S5, S2, ZERO
1583:                      
1584:                      OPCODE_BEGIN(1A)  /* NOP */
1585:                      OPCODE_BEGIN(3A)  /* NOP */
1586:                      OPCODE_BEGIN(5A)  /* NOP */
1587:                      OPCODE_BEGIN(7A)  /* NOP */
1588:                      OPCODE_BEGIN(DA)  /* NOP */
1589:                      OPCODE_BEGIN(FA)  /* NOP */
1590:                         NOP();
9D00B560  0B402D61   J 0x9D00B584
9D00B564  8F828058   LW V0, -32680(GP)
9D00B568  0B402D61   J 0x9D00B584
9D00B56C  8F828058   LW V0, -32680(GP)
9D00B570  0B402D61   J 0x9D00B584
9D00B574  8F828058   LW V0, -32680(GP)
9D00B578  0B402D61   J 0x9D00B584
9D00B57C  8F828058   LW V0, -32680(GP)
9D00B580  8F828058   LW V0, -32680(GP)
9D00B584  2442FFFE   ADDIU V0, V0, -2
9D00B588  AF828058   SW V0, -32680(GP)
9D00B58C  26638FD8   ADDIU V1, S3, -28712
9D00B590  8C640054   LW A0, 84(V1)
9D00B594  24840002   ADDIU A0, A0, 2
1591:                         OPCODE_END
9D00B598  1C400003   BGTZ V0, .LBB846
9D00B59C  AC640054   SW A0, 84(V1)
9D00B5A0  0B404D98   J .L45
9D00B5A4  02008821   ADDU S1, S0, ZERO
9D00B5C4  90420000   LBU V0, 0(V0)
9D00B5C8  00021080   SLL V0, V0, 2
9D00B5CC  00561021   ADDU V0, V0, S6
9D00B5D0  8C420000   LW V0, 0(V0)
9D00B5D4  0B402953   J 0x9D00A54C
9D00B5D8  26100001   ADDIU S0, S0, 1
1592:                
1593:                      OPCODE_BEGIN(1B)  /* SLO $nnnn,Y */
1594:                         SLO(7, ABS_IND_Y, mem_writebyte, addr);
9D00B5DC  0F402863   JAL bank_readword
9D00B5E0  02002021   ADDU A0, S0, ZERO
9D00B5E4  26110002   ADDIU S1, S0, 2
9D00B5E8  8FA40010   LW A0, 16(SP)
9D00B5EC  00441021   ADDU V0, V0, A0
9D00B5F0  3055FFFF   ANDI S5, V0, -1
9D00B5F4  0F402804   JAL mem_readbyte
9D00B5F8  02A02021   ADDU A0, S5, ZERO
9D00B5FC  7C5739C0   EXT S7, V0, 7, 8
9D00B600  00021040   SLL V0, V0, 1
9D00B604  305200FF   ANDI S2, V0, 255
9D00B608  02A02021   ADDU A0, S5, ZERO
9D00B60C  0F40283A   JAL mem_writebyte
9D00B610  02402821   ADDU A1, S2, ZERO
9D00B614  02549025   OR S2, S2, S4
9D00B618  325200FF   ANDI S2, S2, 255
9D00B61C  8F828058   LW V0, -32680(GP)
9D00B620  2442FFF9   ADDIU V0, V0, -7
9D00B624  AF828058   SW V0, -32680(GP)
9D00B628  26638FD8   ADDIU V1, S3, -28712
9D00B62C  8C640054   LW A0, 84(V1)
9D00B630  24840007   ADDIU A0, A0, 7
9D00B63C  0240A021   ADDU S4, S2, ZERO
9D00B640  0B404D98   J .L45
9D00B644  0240A821   ADDU S5, S2, ZERO
9D00B678  0240A021   ADDU S4, S2, ZERO
1595:                         OPCODE_END
9D00B634  1C400004   BGTZ V0, 0x9D00B648
9D00B638  AC640054   SW A0, 84(V1)
9D00B648  26100003   ADDIU S0, S0, 3
9D00B668  90420000   LBU V0, 0(V0)
9D00B66C  00021080   SLL V0, V0, 2
9D00B670  00561021   ADDU V0, V0, S6
9D00B674  8C420000   LW V0, 0(V0)
9D00B67C  0B402953   J 0x9D00A54C
9D00B680  0240A821   ADDU S5, S2, ZERO
1596:                
1597:                      OPCODE_BEGIN(1C)  /* NOP $nnnn,X */
1598:                      OPCODE_BEGIN(3C)  /* NOP $nnnn,X */
1599:                      OPCODE_BEGIN(5C)  /* NOP $nnnn,X */
1600:                      OPCODE_BEGIN(7C)  /* NOP $nnnn,X */
1601:                      OPCODE_BEGIN(DC)  /* NOP $nnnn,X */
1602:                      OPCODE_BEGIN(FC)  /* NOP $nnnn,X */
1603:                         TOP();
9D00B684  0B402DAA   J 0x9D00B6A8
9D00B688  26110002   ADDIU S1, S0, 2
9D00B68C  0B402DAA   J 0x9D00B6A8
9D00B690  26110002   ADDIU S1, S0, 2
9D00B694  0B402DAA   J 0x9D00B6A8
9D00B698  26110002   ADDIU S1, S0, 2
9D00B69C  0B402DAA   J 0x9D00B6A8
9D00B6A0  26110002   ADDIU S1, S0, 2
9D00B6A4  26110002   ADDIU S1, S0, 2
9D00B6A8  8F828058   LW V0, -32680(GP)
9D00B6AC  2442FFFC   ADDIU V0, V0, -4
9D00B6B0  AF828058   SW V0, -32680(GP)
9D00B6B4  26638FD8   ADDIU V1, S3, -28712
9D00B6B8  8C640054   LW A0, 84(V1)
9D00B6BC  24840004   ADDIU A0, A0, 4
1604:                         OPCODE_END
9D00B6C0  18401FE7   BLEZ V0, .L45
9D00B6C4  AC640054   SW A0, 84(V1)
9D00B6C8  26100003   ADDIU S0, S0, 3
9D00B6E8  92220000   LBU V0, 0(S1)
9D00B6EC  00021080   SLL V0, V0, 2
9D00B6F0  00561021   ADDU V0, V0, S6
9D00B6F4  0B402953   J 0x9D00A54C
9D00B6F8  8C420000   LW V0, 0(V0)
1605:                
1606:                      OPCODE_BEGIN(1D)  /* ORA $nnnn,X */
1607:                         ORA(4, ABS_IND_X_BYTE_READ);
9D00B6FC  0F402863   JAL bank_readword
9D00B700  02002021   ADDU A0, S0, ZERO
9D00B704  005E1021   ADDU V0, V0, FP
9D00B708  3044FFFF   ANDI A0, V0, -1
9D00B70C  308200FF   ANDI V0, A0, 255
9D00B710  005E102B   SLTU V0, V0, FP
9D00B714  10400008   BEQ V0, ZERO, 0x9D00B738
9D00B718  26110002   ADDIU S1, S0, 2
9D00B71C  8F828058   LW V0, -32680(GP)
9D00B720  2442FFFF   ADDIU V0, V0, -1
9D00B724  AF828058   SW V0, -32680(GP)
9D00B728  26628FD8   ADDIU V0, S3, -28712
9D00B72C  8C430054   LW V1, 84(V0)
9D00B730  24630001   ADDIU V1, V1, 1
9D00B734  AC430054   SW V1, 84(V0)
9D00B738  0F402804   JAL mem_readbyte
9D00B73C  00000000   NOP
9D00B740  00541025   OR V0, V0, S4
9D00B744  305200FF   ANDI S2, V0, 255
9D00B748  8F828058   LW V0, -32680(GP)
9D00B74C  2442FFFC   ADDIU V0, V0, -4
9D00B750  AF828058   SW V0, -32680(GP)
9D00B754  26638FD8   ADDIU V1, S3, -28712
9D00B758  8C640054   LW A0, 84(V1)
9D00B75C  24840004   ADDIU A0, A0, 4
9D00B768  0240A021   ADDU S4, S2, ZERO
9D00B76C  0B404D98   J .L45
9D00B770  0240A821   ADDU S5, S2, ZERO
9D00B7A4  0240A021   ADDU S4, S2, ZERO
1608:                         OPCODE_END
9D00B760  1C400004   BGTZ V0, 0x9D00B774
9D00B764  AC640054   SW A0, 84(V1)
9D00B774  26100003   ADDIU S0, S0, 3
9D00B794  90420000   LBU V0, 0(V0)
9D00B798  00021080   SLL V0, V0, 2
9D00B79C  00561021   ADDU V0, V0, S6
9D00B7A0  8C420000   LW V0, 0(V0)
9D00B7A8  0B402953   J 0x9D00A54C
9D00B7AC  0240A821   ADDU S5, S2, ZERO
1609:                
1610:                      OPCODE_BEGIN(1E)  /* ASL $nnnn,X */
1611:                         ASL(7, ABS_IND_X, mem_writebyte, addr);
9D00B7B0  0F402863   JAL bank_readword
9D00B7B4  02002021   ADDU A0, S0, ZERO
9D00B7B8  26110002   ADDIU S1, S0, 2
9D00B7BC  005E1021   ADDU V0, V0, FP
9D00B7C0  3055FFFF   ANDI S5, V0, -1
9D00B7C4  0F402804   JAL mem_readbyte
9D00B7C8  02A02021   ADDU A0, S5, ZERO
9D00B7CC  7C5739C0   EXT S7, V0, 7, 8
9D00B7D0  00021040   SLL V0, V0, 1
9D00B7D4  305200FF   ANDI S2, V0, 255
9D00B7D8  02A02021   ADDU A0, S5, ZERO
9D00B7DC  0F40283A   JAL mem_writebyte
9D00B7E0  02402821   ADDU A1, S2, ZERO
9D00B7E4  8F828058   LW V0, -32680(GP)
9D00B7E8  2442FFF9   ADDIU V0, V0, -7
9D00B7EC  AF828058   SW V0, -32680(GP)
9D00B7F0  26638FD8   ADDIU V1, S3, -28712
9D00B7F4  8C640054   LW A0, 84(V1)
9D00B7F8  24840007   ADDIU A0, A0, 7
9D00B804  0B404D98   J .L45
9D00B808  0240A821   ADDU S5, S2, ZERO
1612:                         OPCODE_END
9D00B7FC  1C400003   BGTZ V0, 0x9D00B80C
9D00B800  AC640054   SW A0, 84(V1)
9D00B80C  26100003   ADDIU S0, S0, 3
9D00B82C  90420000   LBU V0, 0(V0)
9D00B830  00021080   SLL V0, V0, 2
9D00B834  00561021   ADDU V0, V0, S6
9D00B838  8C420000   LW V0, 0(V0)
9D00B83C  0B402953   J 0x9D00A54C
9D00B840  0240A821   ADDU S5, S2, ZERO
1613:                
1614:                      OPCODE_BEGIN(1F)  /* SLO $nnnn,X */
1615:                         SLO(7, ABS_IND_X, mem_writebyte, addr);
9D00B844  0F402863   JAL bank_readword
9D00B848  02002021   ADDU A0, S0, ZERO
9D00B84C  26110002   ADDIU S1, S0, 2
9D00B850  005E1021   ADDU V0, V0, FP
9D00B854  3055FFFF   ANDI S5, V0, -1
9D00B858  0F402804   JAL mem_readbyte
9D00B85C  02A02021   ADDU A0, S5, ZERO
9D00B860  7C5739C0   EXT S7, V0, 7, 8
9D00B864  00021040   SLL V0, V0, 1
9D00B868  305200FF   ANDI S2, V0, 255
9D00B86C  02A02021   ADDU A0, S5, ZERO
9D00B870  0F40283A   JAL mem_writebyte
9D00B874  02402821   ADDU A1, S2, ZERO
9D00B878  02549025   OR S2, S2, S4
9D00B87C  325200FF   ANDI S2, S2, 255
9D00B880  8F828058   LW V0, -32680(GP)
9D00B884  2442FFF9   ADDIU V0, V0, -7
9D00B888  AF828058   SW V0, -32680(GP)
9D00B88C  26638FD8   ADDIU V1, S3, -28712
9D00B890  8C640054   LW A0, 84(V1)
9D00B894  24840007   ADDIU A0, A0, 7
9D00B8A0  0240A021   ADDU S4, S2, ZERO
9D00B8A4  0B404D98   J .L45
9D00B8A8  0240A821   ADDU S5, S2, ZERO
9D00B8DC  0240A021   ADDU S4, S2, ZERO
1616:                         OPCODE_END
9D00B898  1C400004   BGTZ V0, 0x9D00B8AC
9D00B89C  AC640054   SW A0, 84(V1)
9D00B8AC  26100003   ADDIU S0, S0, 3
9D00B8CC  90420000   LBU V0, 0(V0)
9D00B8D0  00021080   SLL V0, V0, 2
9D00B8D4  00561021   ADDU V0, V0, S6
9D00B8D8  8C420000   LW V0, 0(V0)
9D00B8E0  0B402953   J 0x9D00A54C
9D00B8E4  0240A821   ADDU S5, S2, ZERO
1617:                      
1618:                      OPCODE_BEGIN(20)  /* JSR $nnnn */
1619:                         JSR();
9D00B8E8  26020001   ADDIU V0, S0, 1
9D00B8EC  8F838050   LW V1, -32688(GP)
9D00B8F0  8FA50018   LW A1, 24(SP)
9D00B8F4  24A4FFFF   ADDIU A0, A1, -1
9D00B8F8  308400FF   ANDI A0, A0, 255
9D00B8FC  00652821   ADDU A1, V1, A1
9D00B900  00023202   SRL A2, V0, 8
9D00B904  A0A60000   SB A2, 0(A1)
9D00B908  8FA60018   LW A2, 24(SP)
9D00B90C  24C5FFFE   ADDIU A1, A2, -2
9D00B910  30A500FF   ANDI A1, A1, 255
9D00B914  AFA50018   SW A1, 24(SP)
9D00B918  00641821   ADDU V1, V1, A0
9D00B91C  A0620000   SB V0, 0(V1)
9D00B920  0F402863   JAL bank_readword
9D00B924  02002021   ADDU A0, S0, ZERO
9D00B928  00408821   ADDU S1, V0, ZERO
9D00B92C  8F828058   LW V0, -32680(GP)
9D00B930  2442FFFA   ADDIU V0, V0, -6
9D00B934  AF828058   SW V0, -32680(GP)
9D00B938  26638FD8   ADDIU V1, S3, -28712
9D00B93C  8C640054   LW A0, 84(V1)
9D00B940  24840006   ADDIU A0, A0, 6
1620:                         OPCODE_END
9D00B944  18401F46   BLEZ V0, .L45
9D00B948  AC640054   SW A0, 84(V1)
9D00B94C  26300001   ADDIU S0, S1, 1
9D00B96C  90420000   LBU V0, 0(V0)
9D00B970  00021080   SLL V0, V0, 2
9D00B974  00561021   ADDU V0, V0, S6
9D00B978  0B402953   J 0x9D00A54C
9D00B97C  8C420000   LW V0, 0(V0)
1621:                
1622:                      OPCODE_BEGIN(21)  /* AND ($nn,X) */
1623:                         AND(6, INDIR_X_BYTE);
9D00B980  26110001   ADDIU S1, S0, 1
9D00B9A0  90420000   LBU V0, 0(V0)
9D00B9A4  03C21021   ADDU V0, FP, V0
9D00B9C0  0F402804   JAL mem_readbyte
9D00B9C4  308400FF   ANDI A0, A0, 255
9D00B9C8  00541024   AND V0, V0, S4
9D00B9CC  305200FF   ANDI S2, V0, 255
9D00B9D0  8F828058   LW V0, -32680(GP)
9D00B9D4  2442FFFA   ADDIU V0, V0, -6
9D00B9D8  AF828058   SW V0, -32680(GP)
9D00B9DC  8EA30054   LW V1, 84(S5)
9D00B9E0  24630006   ADDIU V1, V1, 6
9D00B9EC  0240A021   ADDU S4, S2, ZERO
9D00B9F0  0B404D98   J .L45
9D00B9F4  0240A821   ADDU S5, S2, ZERO
9D00BA28  0240A021   ADDU S4, S2, ZERO
1624:                         OPCODE_END
9D00B9E4  1C400004   BGTZ V0, 0x9D00B9F8
9D00B9E8  AEA30054   SW V1, 84(S5)
9D00B9F8  26100002   ADDIU S0, S0, 2
9D00BA18  90420000   LBU V0, 0(V0)
9D00BA1C  00021080   SLL V0, V0, 2
9D00BA20  00561021   ADDU V0, V0, S6
9D00BA24  8C420000   LW V0, 0(V0)
9D00BA2C  0B402953   J 0x9D00A54C
9D00BA30  0240A821   ADDU S5, S2, ZERO
1625:                
1626:                      OPCODE_BEGIN(23)  /* RLA ($nn,X) */
1627:                         RLA(8, INDIR_X, mem_writebyte, addr);
9D00BA34  26110001   ADDIU S1, S0, 1
9D00BA54  90420000   LBU V0, 0(V0)
9D00BA58  03C21021   ADDU V0, FP, V0
9D00BA7C  0F402804   JAL mem_readbyte
9D00BA80  00402021   ADDU A0, V0, ZERO
9D00BA84  7C4739C0   EXT A3, V0, 7, 8
9D00BA88  AFA70030   SW A3, 48(SP)
9D00BA8C  00021040   SLL V0, V0, 1
9D00BA90  00579025   OR S2, V0, S7
9D00BA94  325200FF   ANDI S2, S2, 255
9D00BA98  8FA4002C   LW A0, 44(SP)
9D00BA9C  0F40283A   JAL mem_writebyte
9D00BAA0  02402821   ADDU A1, S2, ZERO
9D00BAA4  02549024   AND S2, S2, S4
9D00BAA8  8F828058   LW V0, -32680(GP)
9D00BAAC  2442FFF8   ADDIU V0, V0, -8
9D00BAB0  AF828058   SW V0, -32680(GP)
9D00BAB4  8EA30054   LW V1, 84(S5)
9D00BAB8  24630008   ADDIU V1, V1, 8
9D00BAC4  0240A021   ADDU S4, S2, ZERO
9D00BAC8  8FB70030   LW S7, 48(SP)
9D00BACC  0B404D98   J .L45
9D00BAD0  0240A821   ADDU S5, S2, ZERO
9D00BB04  0240A021   ADDU S4, S2, ZERO
9D00BB08  8FB70030   LW S7, 48(SP)
1628:                         OPCODE_END
9D00BABC  1C400005   BGTZ V0, 0x9D00BAD4
9D00BAC0  AEA30054   SW V1, 84(S5)
9D00BAD4  26100002   ADDIU S0, S0, 2
9D00BAF4  90420000   LBU V0, 0(V0)
9D00BAF8  00021080   SLL V0, V0, 2
9D00BAFC  00561021   ADDU V0, V0, S6
9D00BB00  8C420000   LW V0, 0(V0)
9D00BB0C  0B402953   J 0x9D00A54C
9D00BB10  0240A821   ADDU S5, S2, ZERO
1629:                
1630:                      OPCODE_BEGIN(24)  /* BIT $nn */
1631:                         BIT(3, ZERO_PAGE_BYTE);
9D00BB14  26110001   ADDIU S1, S0, 1
9D00BB34  90630000   LBU V1, 0(V1)
9D00BB38  8F848054   LW A0, -32684(GP)
9D00BB3C  00831821   ADDU V1, A0, V1
9D00BB40  90720000   LBU S2, 0(V1)
9D00BB44  32430040   ANDI V1, S2, 64
9D00BB48  306300FF   ANDI V1, V1, 255
9D00BB4C  AFA30014   SW V1, 20(SP)
9D00BB50  0254A824   AND S5, S2, S4
9D00BB54  8F838058   LW V1, -32680(GP)
9D00BB58  2463FFFD   ADDIU V1, V1, -3
9D00BB5C  AF838058   SW V1, -32680(GP)
9D00BB60  8C440054   LW A0, 84(V0)
9D00BB64  24840003   ADDIU A0, A0, 3
1632:                         OPCODE_END
9D00BB68  18601EBD   BLEZ V1, .L45
9D00BB6C  AC440054   SW A0, 84(V0)
9D00BB70  26100002   ADDIU S0, S0, 2
9D00BB8C  90420000   LBU V0, 0(V0)
9D00BB90  00021080   SLL V0, V0, 2
9D00BB94  00561021   ADDU V0, V0, S6
9D00BB98  0B402953   J 0x9D00A54C
9D00BB9C  8C420000   LW V0, 0(V0)
1633:                
1634:                      OPCODE_BEGIN(25)  /* AND $nn */
1635:                         AND(3, ZERO_PAGE_BYTE);
9D00BBA0  26110001   ADDIU S1, S0, 1
9D00BBC0  90630000   LBU V1, 0(V1)
9D00BBC4  8F848054   LW A0, -32684(GP)
9D00BBC8  00831821   ADDU V1, A0, V1
9D00BBCC  90720000   LBU S2, 0(V1)
9D00BBD0  02929024   AND S2, S4, S2
9D00BBD4  8F838058   LW V1, -32680(GP)
9D00BBD8  2463FFFD   ADDIU V1, V1, -3
9D00BBDC  AF838058   SW V1, -32680(GP)
9D00BBE0  8C440054   LW A0, 84(V0)
9D00BBE4  24840003   ADDIU A0, A0, 3
9D00BBF0  0240A021   ADDU S4, S2, ZERO
9D00BBF4  0B404D98   J .L45
9D00BBF8  0240A821   ADDU S5, S2, ZERO
9D00BC2C  0240A021   ADDU S4, S2, ZERO
1636:                         OPCODE_END
9D00BBE8  1C600004   BGTZ V1, 0x9D00BBFC
9D00BBEC  AC440054   SW A0, 84(V0)
9D00BBFC  26100002   ADDIU S0, S0, 2
9D00BC1C  90420000   LBU V0, 0(V0)
9D00BC20  00021080   SLL V0, V0, 2
9D00BC24  00561021   ADDU V0, V0, S6
9D00BC28  8C420000   LW V0, 0(V0)
9D00BC30  0B402953   J 0x9D00A54C
9D00BC34  0240A821   ADDU S5, S2, ZERO
1637:                
1638:                      OPCODE_BEGIN(26)  /* ROL $nn */
1639:                         ROL(5, ZERO_PAGE, ZP_WRITEBYTE, baddr);
9D00BC38  26110001   ADDIU S1, S0, 1
9D00BC58  90630000   LBU V1, 0(V1)
9D00BC5C  8F848054   LW A0, -32684(GP)
9D00BC60  00831821   ADDU V1, A0, V1
9D00BC64  90640000   LBU A0, 0(V1)
9D00BC68  000429C2   SRL A1, A0, 7
9D00BC6C  00042040   SLL A0, A0, 1
9D00BC70  00979025   OR S2, A0, S7
9D00BC74  325200FF   ANDI S2, S2, 255
9D00BC78  A0720000   SB S2, 0(V1)
9D00BC7C  8F838058   LW V1, -32680(GP)
9D00BC80  2463FFFB   ADDIU V1, V1, -5
9D00BC84  AF838058   SW V1, -32680(GP)
9D00BC88  8C440054   LW A0, 84(V0)
9D00BC8C  24840005   ADDIU A0, A0, 5
9D00BC98  00A0B821   ADDU S7, A1, ZERO
9D00BC9C  0B404D98   J .L45
9D00BCA0  0240A821   ADDU S5, S2, ZERO
9D00BCD4  00A0B821   ADDU S7, A1, ZERO
1640:                         OPCODE_END
9D00BC90  1C600004   BGTZ V1, 0x9D00BCA4
9D00BC94  AC440054   SW A0, 84(V0)
9D00BCA4  26100002   ADDIU S0, S0, 2
9D00BCC4  90420000   LBU V0, 0(V0)
9D00BCC8  00021080   SLL V0, V0, 2
9D00BCCC  00561021   ADDU V0, V0, S6
9D00BCD0  8C420000   LW V0, 0(V0)
9D00BCD8  0B402953   J 0x9D00A54C
9D00BCDC  0240A821   ADDU S5, S2, ZERO
1641:                
1642:                      OPCODE_BEGIN(27)  /* RLA $nn */
1643:                         RLA(5, ZERO_PAGE, ZP_WRITEBYTE, baddr);
9D00BCE0  26110001   ADDIU S1, S0, 1
9D00BD00  90630000   LBU V1, 0(V1)
9D00BD04  8F848054   LW A0, -32684(GP)
9D00BD08  00831821   ADDU V1, A0, V1
9D00BD0C  90640000   LBU A0, 0(V1)
9D00BD10  000429C2   SRL A1, A0, 7
9D00BD14  00042040   SLL A0, A0, 1
9D00BD18  00979025   OR S2, A0, S7
9D00BD1C  325200FF   ANDI S2, S2, 255
9D00BD20  A0720000   SB S2, 0(V1)
9D00BD24  02549024   AND S2, S2, S4
9D00BD28  8F838058   LW V1, -32680(GP)
9D00BD2C  2463FFFB   ADDIU V1, V1, -5
9D00BD30  AF838058   SW V1, -32680(GP)
9D00BD34  8C440054   LW A0, 84(V0)
9D00BD38  24840005   ADDIU A0, A0, 5
9D00BD44  0240A021   ADDU S4, S2, ZERO
9D00BD48  00A0B821   ADDU S7, A1, ZERO
9D00BD4C  0B404D98   J .L45
9D00BD50  0240A821   ADDU S5, S2, ZERO
9D00BD84  0240A021   ADDU S4, S2, ZERO
9D00BD88  00A0B821   ADDU S7, A1, ZERO
1644:                         OPCODE_END
9D00BD3C  1C600005   BGTZ V1, 0x9D00BD54
9D00BD40  AC440054   SW A0, 84(V0)
9D00BD54  26100002   ADDIU S0, S0, 2
9D00BD74  90420000   LBU V0, 0(V0)
9D00BD78  00021080   SLL V0, V0, 2
9D00BD7C  00561021   ADDU V0, V0, S6
9D00BD80  8C420000   LW V0, 0(V0)
9D00BD8C  0B402953   J 0x9D00A54C
9D00BD90  0240A821   ADDU S5, S2, ZERO
1645:                
1646:                      OPCODE_BEGIN(28)  /* PLP */
1647:                         PLP();
9D00BD94  8FA30018   LW V1, 24(SP)
9D00BD98  24620001   ADDIU V0, V1, 1
9D00BD9C  304200FF   ANDI V0, V0, 255
9D00BDA0  AFA20018   SW V0, 24(SP)
9D00BDA4  8F828050   LW V0, -32688(GP)
9D00BDA8  8FA40018   LW A0, 24(SP)
9D00BDAC  00441021   ADDU V0, V0, A0
9D00BDB0  90570000   LBU S7, 0(V0)
9D00BDB4  32F20080   ANDI S2, S7, 128
9D00BDB8  32E20040   ANDI V0, S7, 64
9D00BDBC  304200FF   ANDI V0, V0, 255
9D00BDC0  AFA20014   SW V0, 20(SP)
9D00BDC4  32E20010   ANDI V0, S7, 16
9D00BDC8  304200FF   ANDI V0, V0, 255
9D00BDCC  AFA20028   SW V0, 40(SP)
9D00BDD0  32E20008   ANDI V0, S7, 8
9D00BDD4  304200FF   ANDI V0, V0, 255
9D00BDD8  AFA20020   SW V0, 32(SP)
9D00BDDC  32E20004   ANDI V0, S7, 4
9D00BDE0  304200FF   ANDI V0, V0, 255
9D00BDE4  AFA2001C   SW V0, 28(SP)
9D00BDE8  3AF50002   XORI S5, S7, 2
9D00BDEC  7EB50040   EXT S5, S5, 1, 1
9D00BDF0  32F70001   ANDI S7, S7, 1
9D00BDF4  8F828058   LW V0, -32680(GP)
9D00BDF8  2442FFFC   ADDIU V0, V0, -4
9D00BDFC  AF828058   SW V0, -32680(GP)
9D00BE00  26638FD8   ADDIU V1, S3, -28712
9D00BE04  8C640054   LW A0, 84(V1)
9D00BE08  24840004   ADDIU A0, A0, 4
1648:                         OPCODE_END
9D00BE0C  1C400003   BGTZ V0, .LBB888
9D00BE10  AC640054   SW A0, 84(V1)
9D00BE14  0B404D98   J .L45
9D00BE18  02008821   ADDU S1, S0, ZERO
9D00BE38  90420000   LBU V0, 0(V0)
9D00BE3C  00021080   SLL V0, V0, 2
9D00BE40  00561021   ADDU V0, V0, S6
9D00BE44  8C420000   LW V0, 0(V0)
9D00BE48  0B402953   J 0x9D00A54C
9D00BE4C  26100001   ADDIU S0, S0, 1
1649:                
1650:                      OPCODE_BEGIN(29)  /* AND #$nn */
1651:                         AND(2, IMMEDIATE_BYTE);
9D00BE50  26110001   ADDIU S1, S0, 1
9D00BE70  90720000   LBU S2, 0(V1)
9D00BE74  02929024   AND S2, S4, S2
9D00BE78  8F838058   LW V1, -32680(GP)
9D00BE7C  2463FFFE   ADDIU V1, V1, -2
9D00BE80  AF838058   SW V1, -32680(GP)
9D00BE84  8C440054   LW A0, 84(V0)
9D00BE88  24840002   ADDIU A0, A0, 2
9D00BE94  0240A021   ADDU S4, S2, ZERO
9D00BE98  0B404D98   J .L45
9D00BE9C  0240A821   ADDU S5, S2, ZERO
9D00BED0  0240A021   ADDU S4, S2, ZERO
1652:                         OPCODE_END
9D00BE8C  1C600004   BGTZ V1, 0x9D00BEA0
9D00BE90  AC440054   SW A0, 84(V0)
9D00BEA0  26100002   ADDIU S0, S0, 2
9D00BEC0  90420000   LBU V0, 0(V0)
9D00BEC4  00021080   SLL V0, V0, 2
9D00BEC8  00561021   ADDU V0, V0, S6
9D00BECC  8C420000   LW V0, 0(V0)
9D00BED4  0B402953   J 0x9D00A54C
9D00BED8  0240A821   ADDU S5, S2, ZERO
1653:                
1654:                      OPCODE_BEGIN(2A)  /* ROL A */
1655:                         ROL_A();
9D00BEDC  7E8439C0   EXT A0, S4, 7, 8
9D00BEE0  00149040   SLL S2, S4, 1
9D00BEE4  02579025   OR S2, S2, S7
9D00BEE8  325200FF   ANDI S2, S2, 255
9D00BEEC  8F828058   LW V0, -32680(GP)
9D00BEF0  2442FFFE   ADDIU V0, V0, -2
9D00BEF4  AF828058   SW V0, -32680(GP)
9D00BEF8  26638FD8   ADDIU V1, S3, -28712
9D00BEFC  8C650054   LW A1, 84(V1)
9D00BF00  24A50002   ADDIU A1, A1, 2
9D00BF0C  0240A021   ADDU S4, S2, ZERO
9D00BF14  0080B821   ADDU S7, A0, ZERO
9D00BF18  0B404D98   J .L45
9D00BF1C  0240A821   ADDU S5, S2, ZERO
9D00BF4C  0240A021   ADDU S4, S2, ZERO
9D00BF54  0080B821   ADDU S7, A0, ZERO
1656:                         OPCODE_END
9D00BF04  1C400006   BGTZ V0, .LBB894
9D00BF08  AC650054   SW A1, 84(V1)
9D00BF10  02008821   ADDU S1, S0, ZERO
9D00BF3C  90420000   LBU V0, 0(V0)
9D00BF40  00021080   SLL V0, V0, 2
9D00BF44  00561021   ADDU V0, V0, S6
9D00BF48  8C420000   LW V0, 0(V0)
9D00BF50  26100001   ADDIU S0, S0, 1
9D00BF58  0B402953   J 0x9D00A54C
9D00BF5C  0240A821   ADDU S5, S2, ZERO
1657:                
1658:                      OPCODE_BEGIN(2B)  /* ANC #$nn */
1659:                         ANC(2, IMMEDIATE_BYTE);
9D00BF60  26110001   ADDIU S1, S0, 1
9D00BF80  90750000   LBU S5, 0(V1)
9D00BF84  0295A824   AND S5, S4, S5
9D00BF88  7E5739C0   EXT S7, S2, 7, 8
9D00BF8C  8F838058   LW V1, -32680(GP)
9D00BF90  2463FFFE   ADDIU V1, V1, -2
9D00BF94  AF838058   SW V1, -32680(GP)
9D00BF98  8C440054   LW A0, 84(V0)
9D00BF9C  24840002   ADDIU A0, A0, 2
9D00BFA8  02A0A021   ADDU S4, S5, ZERO
9D00BFAC  0B404D98   J .L45
9D00BFB0  02A09021   ADDU S2, S5, ZERO
9D00BFE4  02A0A021   ADDU S4, S5, ZERO
1660:                         OPCODE_END
9D00BFA0  1C600004   BGTZ V1, 0x9D00BFB4
9D00BFA4  AC440054   SW A0, 84(V0)
9D00BFB4  26100002   ADDIU S0, S0, 2
9D00BFD4  90420000   LBU V0, 0(V0)
9D00BFD8  00021080   SLL V0, V0, 2
9D00BFDC  00561021   ADDU V0, V0, S6
9D00BFE0  8C420000   LW V0, 0(V0)
9D00BFE8  0B402953   J 0x9D00A54C
9D00BFEC  02A09021   ADDU S2, S5, ZERO
1661:                
1662:                      OPCODE_BEGIN(2C)  /* BIT $nnnn */
1663:                         BIT(4, ABSOLUTE_BYTE);
9D00BFF0  0F402863   JAL bank_readword
9D00BFF4  02002021   ADDU A0, S0, ZERO
9D00BFF8  26110002   ADDIU S1, S0, 2
9D00BFFC  0F402804   JAL mem_readbyte
9D00C000  00402021   ADDU A0, V0, ZERO
9D00C004  00409021   ADDU S2, V0, ZERO
9D00C008  30420040   ANDI V0, V0, 64
9D00C00C  304200FF   ANDI V0, V0, 255
9D00C010  AFA20014   SW V0, 20(SP)
9D00C014  0254A824   AND S5, S2, S4
9D00C018  32B500FF   ANDI S5, S5, 255
9D00C01C  8F828058   LW V0, -32680(GP)
9D00C020  2442FFFC   ADDIU V0, V0, -4
9D00C024  AF828058   SW V0, -32680(GP)
9D00C028  26638FD8   ADDIU V1, S3, -28712
9D00C02C  8C640054   LW A0, 84(V1)
9D00C030  24840004   ADDIU A0, A0, 4
1664:                         OPCODE_END
9D00C034  18401D8A   BLEZ V0, .L45
9D00C038  AC640054   SW A0, 84(V1)
9D00C03C  26100003   ADDIU S0, S0, 3
9D00C05C  90420000   LBU V0, 0(V0)
9D00C060  00021080   SLL V0, V0, 2
9D00C064  00561021   ADDU V0, V0, S6
9D00C068  0B402953   J 0x9D00A54C
9D00C06C  8C420000   LW V0, 0(V0)
1665:                
1666:                      OPCODE_BEGIN(2D)  /* AND $nnnn */
1667:                         AND(4, ABSOLUTE_BYTE);
9D00C070  0F402863   JAL bank_readword
9D00C074  02002021   ADDU A0, S0, ZERO
9D00C078  26110002   ADDIU S1, S0, 2
9D00C07C  0F402804   JAL mem_readbyte
9D00C080  00402021   ADDU A0, V0, ZERO
9D00C084  00541024   AND V0, V0, S4
9D00C088  305200FF   ANDI S2, V0, 255
9D00C08C  8F828058   LW V0, -32680(GP)
9D00C090  2442FFFC   ADDIU V0, V0, -4
9D00C094  AF828058   SW V0, -32680(GP)
9D00C098  26638FD8   ADDIU V1, S3, -28712
9D00C09C  8C640054   LW A0, 84(V1)
9D00C0A0  24840004   ADDIU A0, A0, 4
9D00C0AC  0240A021   ADDU S4, S2, ZERO
9D00C0B0  0B404D98   J .L45
9D00C0B4  0240A821   ADDU S5, S2, ZERO
9D00C0E8  0240A021   ADDU S4, S2, ZERO
1668:                         OPCODE_END
9D00C0A4  1C400004   BGTZ V0, 0x9D00C0B8
9D00C0A8  AC640054   SW A0, 84(V1)
9D00C0B8  26100003   ADDIU S0, S0, 3
9D00C0D8  90420000   LBU V0, 0(V0)
9D00C0DC  00021080   SLL V0, V0, 2
9D00C0E0  00561021   ADDU V0, V0, S6
9D00C0E4  8C420000   LW V0, 0(V0)
9D00C0EC  0B402953   J 0x9D00A54C
9D00C0F0  0240A821   ADDU S5, S2, ZERO
1669:                
1670:                      OPCODE_BEGIN(2E)  /* ROL $nnnn */
1671:                         ROL(6, ABSOLUTE, mem_writebyte, addr);
9D00C0F4  0F402863   JAL bank_readword
9D00C0F8  02002021   ADDU A0, S0, ZERO
9D00C0FC  0040A821   ADDU S5, V0, ZERO
9D00C100  26110002   ADDIU S1, S0, 2
9D00C104  0F402804   JAL mem_readbyte
9D00C108  00402021   ADDU A0, V0, ZERO
9D00C10C  7C4539C0   EXT A1, V0, 7, 8
9D00C110  AFA5002C   SW A1, 44(SP)
9D00C114  00021040   SLL V0, V0, 1
9D00C118  00579025   OR S2, V0, S7
9D00C11C  325200FF   ANDI S2, S2, 255
9D00C120  02A02021   ADDU A0, S5, ZERO
9D00C124  0F40283A   JAL mem_writebyte
9D00C128  02402821   ADDU A1, S2, ZERO
9D00C12C  8F828058   LW V0, -32680(GP)
9D00C130  2442FFFA   ADDIU V0, V0, -6
9D00C134  AF828058   SW V0, -32680(GP)
9D00C138  26638FD8   ADDIU V1, S3, -28712
9D00C13C  8C640054   LW A0, 84(V1)
9D00C140  24840006   ADDIU A0, A0, 6
9D00C14C  8FB7002C   LW S7, 44(SP)
9D00C150  0B404D98   J .L45
9D00C154  0240A821   ADDU S5, S2, ZERO
9D00C188  8FB7002C   LW S7, 44(SP)
1672:                         OPCODE_END
9D00C144  1C400004   BGTZ V0, 0x9D00C158
9D00C148  AC640054   SW A0, 84(V1)
9D00C158  26100003   ADDIU S0, S0, 3
9D00C178  90420000   LBU V0, 0(V0)
9D00C17C  00021080   SLL V0, V0, 2
9D00C180  00561021   ADDU V0, V0, S6
9D00C184  8C420000   LW V0, 0(V0)
9D00C18C  0B402953   J 0x9D00A54C
9D00C190  0240A821   ADDU S5, S2, ZERO
1673:                
1674:                      OPCODE_BEGIN(2F)  /* RLA $nnnn */
1675:                         RLA(6, ABSOLUTE, mem_writebyte, addr);
9D00C194  0F402863   JAL bank_readword
9D00C198  02002021   ADDU A0, S0, ZERO
9D00C19C  0040A821   ADDU S5, V0, ZERO
9D00C1A0  26110002   ADDIU S1, S0, 2
9D00C1A4  0F402804   JAL mem_readbyte
9D00C1A8  00402021   ADDU A0, V0, ZERO
9D00C1AC  7C4639C0   EXT A2, V0, 7, 8
9D00C1B0  AFA6002C   SW A2, 44(SP)
9D00C1B4  00021040   SLL V0, V0, 1
9D00C1B8  00579025   OR S2, V0, S7
9D00C1BC  325200FF   ANDI S2, S2, 255
9D00C1C0  02A02021   ADDU A0, S5, ZERO
9D00C1C4  0F40283A   JAL mem_writebyte
9D00C1C8  02402821   ADDU A1, S2, ZERO
9D00C1CC  02549024   AND S2, S2, S4
9D00C1D0  8F828058   LW V0, -32680(GP)
9D00C1D4  2442FFFA   ADDIU V0, V0, -6
9D00C1D8  AF828058   SW V0, -32680(GP)
9D00C1DC  26638FD8   ADDIU V1, S3, -28712
9D00C1E0  8C640054   LW A0, 84(V1)
9D00C1E4  24840006   ADDIU A0, A0, 6
9D00C1F0  0240A021   ADDU S4, S2, ZERO
9D00C1F4  8FB7002C   LW S7, 44(SP)
9D00C1F8  0B404D98   J .L45
9D00C1FC  0240A821   ADDU S5, S2, ZERO
9D00C230  0240A021   ADDU S4, S2, ZERO
9D00C234  8FB7002C   LW S7, 44(SP)
1676:                         OPCODE_END
9D00C1E8  1C400005   BGTZ V0, 0x9D00C200
9D00C1EC  AC640054   SW A0, 84(V1)
9D00C200  26100003   ADDIU S0, S0, 3
9D00C220  90420000   LBU V0, 0(V0)
9D00C224  00021080   SLL V0, V0, 2
9D00C228  00561021   ADDU V0, V0, S6
9D00C22C  8C420000   LW V0, 0(V0)
9D00C238  0B402953   J 0x9D00A54C
9D00C23C  0240A821   ADDU S5, S2, ZERO
1677:                
1678:                      OPCODE_BEGIN(30)  /* BMI $nnnn */
1679:                         BMI();
9D00C240  7C121420   SEB V0, S2
9D00C244  0441001E   BGEZ V0, 0x9D00C2C0
9D00C248  26110001   ADDIU S1, S0, 1
9D00C24C  26020001   ADDIU V0, S0, 1
9D00C26C  80710000   LB S1, 0(V1)
9D00C270  304300FF   ANDI V1, V0, 255
9D00C274  02231821   ADDU V1, S1, V1
9D00C278  30630100   ANDI V1, V1, 256
9D00C27C  10600008   BEQ V1, ZERO, 0x9D00C2A0
9D00C280  8F838058   LW V1, -32680(GP)
9D00C284  2463FFFF   ADDIU V1, V1, -1
9D00C288  AF838058   SW V1, -32680(GP)
9D00C28C  26638FD8   ADDIU V1, S3, -28712
9D00C290  8C640054   LW A0, 84(V1)
9D00C294  24840001   ADDIU A0, A0, 1
9D00C298  AC640054   SW A0, 84(V1)
9D00C29C  8F838058   LW V1, -32680(GP)
9D00C2A0  2463FFFD   ADDIU V1, V1, -3
9D00C2A4  AF838058   SW V1, -32680(GP)
9D00C2A8  26638FD8   ADDIU V1, S3, -28712
9D00C2AC  8C640054   LW A0, 84(V1)
9D00C2B0  24840003   ADDIU A0, A0, 3
9D00C2B4  AC640054   SW A0, 84(V1)
9D00C2B8  0B4030B7   J 0x9D00C2DC
9D00C2BC  02228821   ADDU S1, S1, V0
9D00C2C0  8F828058   LW V0, -32680(GP)
9D00C2C4  2442FFFE   ADDIU V0, V0, -2
9D00C2C8  AF828058   SW V0, -32680(GP)
9D00C2CC  26628FD8   ADDIU V0, S3, -28712
9D00C2D0  8C430054   LW V1, 84(V0)
9D00C2D4  24630002   ADDIU V1, V1, 2
9D00C2D8  AC430054   SW V1, 84(V0)
1680:                         OPCODE_END
9D00C2DC  8F828058   LW V0, -32680(GP)
9D00C2E0  18401CDF   BLEZ V0, .L45
9D00C2E4  26300001   ADDIU S0, S1, 1
9D00C304  90420000   LBU V0, 0(V0)
9D00C308  00021080   SLL V0, V0, 2
9D00C30C  00561021   ADDU V0, V0, S6
9D00C310  0B402953   J 0x9D00A54C
9D00C314  8C420000   LW V0, 0(V0)
1681:                
1682:                      OPCODE_BEGIN(31)  /* AND ($nn),Y */
1683:                         AND(5, INDIR_Y_BYTE_READ);
9D00C350  8FA70010   LW A3, 16(SP)
9D00C354  00872021   ADDU A0, A0, A3
9D00C358  3084FFFF   ANDI A0, A0, -1
9D00C35C  308200FF   ANDI V0, A0, 255
9D00C360  0047102B   SLTU V0, V0, A3
9D00C364  10400008   BEQ V0, ZERO, 0x9D00C388
9D00C368  26110001   ADDIU S1, S0, 1
9D00C36C  8F828058   LW V0, -32680(GP)
9D00C370  2442FFFF   ADDIU V0, V0, -1
9D00C374  AF828058   SW V0, -32680(GP)
9D00C378  26628FD8   ADDIU V0, S3, -28712
9D00C37C  8C430054   LW V1, 84(V0)
9D00C380  24630001   ADDIU V1, V1, 1
9D00C384  AC430054   SW V1, 84(V0)
9D00C388  0F402804   JAL mem_readbyte
9D00C38C  00000000   NOP
9D00C390  00541024   AND V0, V0, S4
9D00C394  305200FF   ANDI S2, V0, 255
9D00C398  8F828058   LW V0, -32680(GP)
9D00C39C  2442FFFB   ADDIU V0, V0, -5
9D00C3A0  AF828058   SW V0, -32680(GP)
9D00C3A4  26638FD8   ADDIU V1, S3, -28712
9D00C3A8  8C640054   LW A0, 84(V1)
9D00C3AC  24840005   ADDIU A0, A0, 5
9D00C3B8  0240A021   ADDU S4, S2, ZERO
9D00C3BC  0B404D98   J .L45
9D00C3C0  0240A821   ADDU S5, S2, ZERO
9D00C3F4  0240A021   ADDU S4, S2, ZERO
1684:                         OPCODE_END
9D00C3B0  1C400004   BGTZ V0, 0x9D00C3C4
9D00C3B4  AC640054   SW A0, 84(V1)
9D00C3C4  26100002   ADDIU S0, S0, 2
9D00C3E4  90420000   LBU V0, 0(V0)
9D00C3E8  00021080   SLL V0, V0, 2
9D00C3EC  00561021   ADDU V0, V0, S6
9D00C3F0  8C420000   LW V0, 0(V0)
9D00C3F8  0B402953   J 0x9D00A54C
9D00C3FC  0240A821   ADDU S5, S2, ZERO
1685:                
1686:                      OPCODE_BEGIN(33)  /* RLA ($nn),Y */
1687:                         RLA(8, INDIR_Y, mem_writebyte, addr);
9D00C400  26110001   ADDIU S1, S0, 1
9D00C43C  8FA30010   LW V1, 16(SP)
9D00C440  00431021   ADDU V0, V0, V1
9D00C444  3042FFFF   ANDI V0, V0, -1
9D00C448  AFA2002C   SW V0, 44(SP)
9D00C44C  0F402804   JAL mem_readbyte
9D00C450  00402021   ADDU A0, V0, ZERO
9D00C454  7C4439C0   EXT A0, V0, 7, 8
9D00C458  AFA40030   SW A0, 48(SP)
9D00C45C  00021040   SLL V0, V0, 1
9D00C460  00579025   OR S2, V0, S7
9D00C464  325200FF   ANDI S2, S2, 255
9D00C468  8FA4002C   LW A0, 44(SP)
9D00C46C  0F40283A   JAL mem_writebyte
9D00C470  02402821   ADDU A1, S2, ZERO
9D00C474  02549024   AND S2, S2, S4
9D00C478  8F828058   LW V0, -32680(GP)
9D00C47C  2442FFF8   ADDIU V0, V0, -8
9D00C480  AF828058   SW V0, -32680(GP)
9D00C484  8EA30054   LW V1, 84(S5)
9D00C488  24630008   ADDIU V1, V1, 8
9D00C494  0240A021   ADDU S4, S2, ZERO
9D00C498  8FB70030   LW S7, 48(SP)
9D00C49C  0B404D98   J .L45
9D00C4A0  0240A821   ADDU S5, S2, ZERO
9D00C4D4  0240A021   ADDU S4, S2, ZERO
9D00C4D8  8FB70030   LW S7, 48(SP)
1688:                         OPCODE_END
9D00C48C  1C400005   BGTZ V0, 0x9D00C4A4
9D00C490  AEA30054   SW V1, 84(S5)
9D00C4A4  26100002   ADDIU S0, S0, 2
9D00C4C4  90420000   LBU V0, 0(V0)
9D00C4C8  00021080   SLL V0, V0, 2
9D00C4CC  00561021   ADDU V0, V0, S6
9D00C4D0  8C420000   LW V0, 0(V0)
9D00C4DC  0B402953   J 0x9D00A54C
9D00C4E0  0240A821   ADDU S5, S2, ZERO
1689:                
1690:                      OPCODE_BEGIN(35)  /* AND $nn,X */
1691:                         AND(4, ZP_IND_X_BYTE);
9D00C4E4  26110001   ADDIU S1, S0, 1
9D00C504  90630000   LBU V1, 0(V1)
9D00C508  03C31821   ADDU V1, FP, V1
9D00C50C  306300FF   ANDI V1, V1, 255
9D00C510  8F848054   LW A0, -32684(GP)
9D00C514  00831821   ADDU V1, A0, V1
9D00C518  90720000   LBU S2, 0(V1)
9D00C51C  02549024   AND S2, S2, S4
9D00C520  8F838058   LW V1, -32680(GP)
9D00C524  2463FFFC   ADDIU V1, V1, -4
9D00C528  AF838058   SW V1, -32680(GP)
9D00C52C  8C440054   LW A0, 84(V0)
9D00C530  24840004   ADDIU A0, A0, 4
9D00C53C  0240A021   ADDU S4, S2, ZERO
9D00C540  0B404D98   J .L45
9D00C544  0240A821   ADDU S5, S2, ZERO
9D00C578  0240A021   ADDU S4, S2, ZERO
1692:                         OPCODE_END
9D00C534  1C600004   BGTZ V1, 0x9D00C548
9D00C538  AC440054   SW A0, 84(V0)
9D00C548  26100002   ADDIU S0, S0, 2
9D00C568  90420000   LBU V0, 0(V0)
9D00C56C  00021080   SLL V0, V0, 2
9D00C570  00561021   ADDU V0, V0, S6
9D00C574  8C420000   LW V0, 0(V0)
9D00C57C  0B402953   J 0x9D00A54C
9D00C580  0240A821   ADDU S5, S2, ZERO
1693:                
1694:                      OPCODE_BEGIN(36)  /* ROL $nn,X */
1695:                         ROL(6, ZP_IND_X, ZP_WRITEBYTE, baddr);
9D00C584  26110001   ADDIU S1, S0, 1
9D00C5A4  90630000   LBU V1, 0(V1)
9D00C5A8  03C31821   ADDU V1, FP, V1
9D00C5AC  306300FF   ANDI V1, V1, 255
9D00C5B0  8F848054   LW A0, -32684(GP)
9D00C5B4  00831821   ADDU V1, A0, V1
9D00C5B8  90640000   LBU A0, 0(V1)
9D00C5BC  000429C2   SRL A1, A0, 7
9D00C5C0  00042040   SLL A0, A0, 1
9D00C5C4  00979025   OR S2, A0, S7
9D00C5C8  325200FF   ANDI S2, S2, 255
9D00C5CC  A0720000   SB S2, 0(V1)
9D00C5D0  8F838058   LW V1, -32680(GP)
9D00C5D4  2463FFFA   ADDIU V1, V1, -6
9D00C5D8  AF838058   SW V1, -32680(GP)
9D00C5DC  8C440054   LW A0, 84(V0)
9D00C5E0  24840006   ADDIU A0, A0, 6
9D00C5EC  00A0B821   ADDU S7, A1, ZERO
9D00C5F0  0B404D98   J .L45
9D00C5F4  0240A821   ADDU S5, S2, ZERO
9D00C628  00A0B821   ADDU S7, A1, ZERO
1696:                         OPCODE_END
9D00C5E4  1C600004   BGTZ V1, 0x9D00C5F8
9D00C5E8  AC440054   SW A0, 84(V0)
9D00C5F8  26100002   ADDIU S0, S0, 2
9D00C618  90420000   LBU V0, 0(V0)
9D00C61C  00021080   SLL V0, V0, 2
9D00C620  00561021   ADDU V0, V0, S6
9D00C624  8C420000   LW V0, 0(V0)
9D00C62C  0B402953   J 0x9D00A54C
9D00C630  0240A821   ADDU S5, S2, ZERO
1697:                
1698:                      OPCODE_BEGIN(37)  /* RLA $nn,X */
1699:                         RLA(6, ZP_IND_X, ZP_WRITEBYTE, baddr);
9D00C634  26110001   ADDIU S1, S0, 1
9D00C654  90630000   LBU V1, 0(V1)
9D00C658  03C31821   ADDU V1, FP, V1
9D00C65C  306300FF   ANDI V1, V1, 255
9D00C660  8F848054   LW A0, -32684(GP)
9D00C664  00831821   ADDU V1, A0, V1
9D00C668  90640000   LBU A0, 0(V1)
9D00C66C  000429C2   SRL A1, A0, 7
9D00C670  00042040   SLL A0, A0, 1
9D00C674  00979025   OR S2, A0, S7
9D00C678  325200FF   ANDI S2, S2, 255
9D00C67C  A0720000   SB S2, 0(V1)
9D00C680  02549024   AND S2, S2, S4
9D00C684  8F838058   LW V1, -32680(GP)
9D00C688  2463FFFA   ADDIU V1, V1, -6
9D00C68C  AF838058   SW V1, -32680(GP)
9D00C690  8C440054   LW A0, 84(V0)
9D00C694  24840006   ADDIU A0, A0, 6
9D00C6A0  0240A021   ADDU S4, S2, ZERO
9D00C6A4  00A0B821   ADDU S7, A1, ZERO
9D00C6A8  0B404D98   J .L45
9D00C6AC  0240A821   ADDU S5, S2, ZERO
9D00C6E0  0240A021   ADDU S4, S2, ZERO
9D00C6E4  00A0B821   ADDU S7, A1, ZERO
1700:                         OPCODE_END
9D00C698  1C600005   BGTZ V1, 0x9D00C6B0
9D00C69C  AC440054   SW A0, 84(V0)
9D00C6B0  26100002   ADDIU S0, S0, 2
9D00C6D0  90420000   LBU V0, 0(V0)
9D00C6D4  00021080   SLL V0, V0, 2
9D00C6D8  00561021   ADDU V0, V0, S6
9D00C6DC  8C420000   LW V0, 0(V0)
9D00C6E8  0B402953   J 0x9D00A54C
9D00C6EC  0240A821   ADDU S5, S2, ZERO
1701:                
1702:                      OPCODE_BEGIN(38)  /* SEC */
1703:                         SEC();
9D00C6F0  8F828058   LW V0, -32680(GP)
9D00C6F4  2442FFFE   ADDIU V0, V0, -2
9D00C6F8  AF828058   SW V0, -32680(GP)
9D00C6FC  26638FD8   ADDIU V1, S3, -28712
9D00C700  8C640054   LW A0, 84(V1)
9D00C704  24840002   ADDIU A0, A0, 2
9D00C714  0B404D98   J .L45
9D00C718  24170001   ADDIU S7, ZERO, 1
1704:                         OPCODE_END
9D00C708  1C400004   BGTZ V0, .LBB936
9D00C70C  AC640054   SW A0, 84(V1)
9D00C710  02008821   ADDU S1, S0, ZERO
9D00C738  90420000   LBU V0, 0(V0)
9D00C73C  00021080   SLL V0, V0, 2
9D00C740  00561021   ADDU V0, V0, S6
9D00C744  8C420000   LW V0, 0(V0)
9D00C748  26100001   ADDIU S0, S0, 1
9D00C74C  0B402953   J 0x9D00A54C
9D00C750  24170001   ADDIU S7, ZERO, 1
1705:                
1706:                      OPCODE_BEGIN(39)  /* AND $nnnn,Y */
1707:                         AND(4, ABS_IND_Y_BYTE_READ);
9D00C754  0F402863   JAL bank_readword
9D00C758  02002021   ADDU A0, S0, ZERO
9D00C75C  8FA50010   LW A1, 16(SP)
9D00C760  00451021   ADDU V0, V0, A1
9D00C764  3044FFFF   ANDI A0, V0, -1
9D00C768  308200FF   ANDI V0, A0, 255
9D00C76C  0045102B   SLTU V0, V0, A1
9D00C770  10400008   BEQ V0, ZERO, 0x9D00C794
9D00C774  26110002   ADDIU S1, S0, 2
9D00C778  8F828058   LW V0, -32680(GP)
9D00C77C  2442FFFF   ADDIU V0, V0, -1
9D00C780  AF828058   SW V0, -32680(GP)
9D00C784  26628FD8   ADDIU V0, S3, -28712
9D00C788  8C430054   LW V1, 84(V0)
9D00C78C  24630001   ADDIU V1, V1, 1
9D00C790  AC430054   SW V1, 84(V0)
9D00C794  0F402804   JAL mem_readbyte
9D00C798  00000000   NOP
9D00C79C  00541024   AND V0, V0, S4
9D00C7A0  305200FF   ANDI S2, V0, 255
9D00C7A4  8F828058   LW V0, -32680(GP)
9D00C7A8  2442FFFC   ADDIU V0, V0, -4
9D00C7AC  AF828058   SW V0, -32680(GP)
9D00C7B0  26638FD8   ADDIU V1, S3, -28712
9D00C7B4  8C640054   LW A0, 84(V1)
9D00C7B8  24840004   ADDIU A0, A0, 4
9D00C7C4  0240A021   ADDU S4, S2, ZERO
9D00C7C8  0B404D98   J .L45
9D00C7CC  0240A821   ADDU S5, S2, ZERO
9D00C800  0240A021   ADDU S4, S2, ZERO
1708:                         OPCODE_END
9D00C7BC  1C400004   BGTZ V0, 0x9D00C7D0
9D00C7C0  AC640054   SW A0, 84(V1)
9D00C7D0  26100003   ADDIU S0, S0, 3
9D00C7F0  90420000   LBU V0, 0(V0)
9D00C7F4  00021080   SLL V0, V0, 2
9D00C7F8  00561021   ADDU V0, V0, S6
9D00C7FC  8C420000   LW V0, 0(V0)
9D00C804  0B402953   J 0x9D00A54C
9D00C808  0240A821   ADDU S5, S2, ZERO
1709:                
1710:                      OPCODE_BEGIN(3B)  /* RLA $nnnn,Y */
1711:                         RLA(7, ABS_IND_Y, mem_writebyte, addr);
9D00C80C  0F402863   JAL bank_readword
9D00C810  02002021   ADDU A0, S0, ZERO
9D00C814  26110002   ADDIU S1, S0, 2
9D00C818  8FA60010   LW A2, 16(SP)
9D00C81C  00461021   ADDU V0, V0, A2
9D00C820  3055FFFF   ANDI S5, V0, -1
9D00C824  0F402804   JAL mem_readbyte
9D00C828  02A02021   ADDU A0, S5, ZERO
9D00C82C  7C4739C0   EXT A3, V0, 7, 8
9D00C830  AFA7002C   SW A3, 44(SP)
9D00C834  00021040   SLL V0, V0, 1
9D00C838  00579025   OR S2, V0, S7
9D00C83C  325200FF   ANDI S2, S2, 255
9D00C840  02A02021   ADDU A0, S5, ZERO
9D00C844  0F40283A   JAL mem_writebyte
9D00C848  02402821   ADDU A1, S2, ZERO
9D00C84C  02549024   AND S2, S2, S4
9D00C850  8F828058   LW V0, -32680(GP)
9D00C854  2442FFF9   ADDIU V0, V0, -7
9D00C858  AF828058   SW V0, -32680(GP)
9D00C85C  26638FD8   ADDIU V1, S3, -28712
9D00C860  8C640054   LW A0, 84(V1)
9D00C864  24840007   ADDIU A0, A0, 7
9D00C870  0240A021   ADDU S4, S2, ZERO
9D00C874  8FB7002C   LW S7, 44(SP)
9D00C878  0B404D98   J .L45
9D00C87C  0240A821   ADDU S5, S2, ZERO
9D00C8B0  0240A021   ADDU S4, S2, ZERO
9D00C8B4  8FB7002C   LW S7, 44(SP)
1712:                         OPCODE_END
9D00C868  1C400005   BGTZ V0, 0x9D00C880
9D00C86C  AC640054   SW A0, 84(V1)
9D00C880  26100003   ADDIU S0, S0, 3
9D00C8A0  90420000   LBU V0, 0(V0)
9D00C8A4  00021080   SLL V0, V0, 2
9D00C8A8  00561021   ADDU V0, V0, S6
9D00C8AC  8C420000   LW V0, 0(V0)
9D00C8B8  0B402953   J 0x9D00A54C
9D00C8BC  0240A821   ADDU S5, S2, ZERO
1713:                
1714:                      OPCODE_BEGIN(3D)  /* AND $nnnn,X */
1715:                         AND(4, ABS_IND_X_BYTE_READ);
9D00C8C0  0F402863   JAL bank_readword
9D00C8C4  02002021   ADDU A0, S0, ZERO
9D00C8C8  005E1021   ADDU V0, V0, FP
9D00C8CC  3044FFFF   ANDI A0, V0, -1
9D00C8D0  308200FF   ANDI V0, A0, 255
9D00C8D4  005E102B   SLTU V0, V0, FP
9D00C8D8  10400008   BEQ V0, ZERO, 0x9D00C8FC
9D00C8DC  26110002   ADDIU S1, S0, 2
9D00C8E0  8F828058   LW V0, -32680(GP)
9D00C8E4  2442FFFF   ADDIU V0, V0, -1
9D00C8E8  AF828058   SW V0, -32680(GP)
9D00C8EC  26628FD8   ADDIU V0, S3, -28712
9D00C8F0  8C430054   LW V1, 84(V0)
9D00C8F4  24630001   ADDIU V1, V1, 1
9D00C8F8  AC430054   SW V1, 84(V0)
9D00C8FC  0F402804   JAL mem_readbyte
9D00C900  00000000   NOP
9D00C904  00541024   AND V0, V0, S4
9D00C908  305200FF   ANDI S2, V0, 255
9D00C90C  8F828058   LW V0, -32680(GP)
9D00C910  2442FFFC   ADDIU V0, V0, -4
9D00C914  AF828058   SW V0, -32680(GP)
9D00C918  26638FD8   ADDIU V1, S3, -28712
9D00C91C  8C640054   LW A0, 84(V1)
9D00C920  24840004   ADDIU A0, A0, 4
9D00C92C  0240A021   ADDU S4, S2, ZERO
9D00C930  0B404D98   J .L45
9D00C934  0240A821   ADDU S5, S2, ZERO
9D00C968  0240A021   ADDU S4, S2, ZERO
1716:                         OPCODE_END
9D00C924  1C400004   BGTZ V0, 0x9D00C938
9D00C928  AC640054   SW A0, 84(V1)
9D00C938  26100003   ADDIU S0, S0, 3
9D00C958  90420000   LBU V0, 0(V0)
9D00C95C  00021080   SLL V0, V0, 2
9D00C960  00561021   ADDU V0, V0, S6
9D00C964  8C420000   LW V0, 0(V0)
9D00C96C  0B402953   J 0x9D00A54C
9D00C970  0240A821   ADDU S5, S2, ZERO
1717:                
1718:                      OPCODE_BEGIN(3E)  /* ROL $nnnn,X */
1719:                         ROL(7, ABS_IND_X, mem_writebyte, addr);
9D00C974  0F402863   JAL bank_readword
9D00C978  02002021   ADDU A0, S0, ZERO
9D00C97C  26110002   ADDIU S1, S0, 2
9D00C980  005E1021   ADDU V0, V0, FP
9D00C984  3055FFFF   ANDI S5, V0, -1
9D00C988  0F402804   JAL mem_readbyte
9D00C98C  02A02021   ADDU A0, S5, ZERO
9D00C990  7C4339C0   EXT V1, V0, 7, 8
9D00C994  AFA3002C   SW V1, 44(SP)
9D00C998  00021040   SLL V0, V0, 1
9D00C99C  00579025   OR S2, V0, S7
9D00C9A0  325200FF   ANDI S2, S2, 255
9D00C9A4  02A02021   ADDU A0, S5, ZERO
9D00C9A8  0F40283A   JAL mem_writebyte
9D00C9AC  02402821   ADDU A1, S2, ZERO
9D00C9B0  8F828058   LW V0, -32680(GP)
9D00C9B4  2442FFF9   ADDIU V0, V0, -7
9D00C9B8  AF828058   SW V0, -32680(GP)
9D00C9BC  26638FD8   ADDIU V1, S3, -28712
9D00C9C0  8C640054   LW A0, 84(V1)
9D00C9C4  24840007   ADDIU A0, A0, 7
9D00C9D0  8FB7002C   LW S7, 44(SP)
9D00C9D4  0B404D98   J .L45
9D00C9D8  0240A821   ADDU S5, S2, ZERO
9D00CA0C  8FB7002C   LW S7, 44(SP)
1720:                         OPCODE_END
9D00C9C8  1C400004   BGTZ V0, 0x9D00C9DC
9D00C9CC  AC640054   SW A0, 84(V1)
9D00C9DC  26100003   ADDIU S0, S0, 3
9D00C9FC  90420000   LBU V0, 0(V0)
9D00CA00  00021080   SLL V0, V0, 2
9D00CA04  00561021   ADDU V0, V0, S6
9D00CA08  8C420000   LW V0, 0(V0)
9D00CA10  0B402953   J 0x9D00A54C
9D00CA14  0240A821   ADDU S5, S2, ZERO
1721:                
1722:                      OPCODE_BEGIN(3F)  /* RLA $nnnn,X */
1723:                         RLA(7, ABS_IND_X, mem_writebyte, addr);
9D00CA18  0F402863   JAL bank_readword
9D00CA1C  02002021   ADDU A0, S0, ZERO
9D00CA20  26110002   ADDIU S1, S0, 2
9D00CA24  005E1021   ADDU V0, V0, FP
9D00CA28  3055FFFF   ANDI S5, V0, -1
9D00CA2C  0F402804   JAL mem_readbyte
9D00CA30  02A02021   ADDU A0, S5, ZERO
9D00CA34  7C4439C0   EXT A0, V0, 7, 8
9D00CA38  AFA4002C   SW A0, 44(SP)
9D00CA3C  00021040   SLL V0, V0, 1
9D00CA40  00579025   OR S2, V0, S7
9D00CA44  325200FF   ANDI S2, S2, 255
9D00CA48  02A02021   ADDU A0, S5, ZERO
9D00CA4C  0F40283A   JAL mem_writebyte
9D00CA50  02402821   ADDU A1, S2, ZERO
9D00CA54  02549024   AND S2, S2, S4
9D00CA58  8F828058   LW V0, -32680(GP)
9D00CA5C  2442FFF9   ADDIU V0, V0, -7
9D00CA60  AF828058   SW V0, -32680(GP)
9D00CA64  26638FD8   ADDIU V1, S3, -28712
9D00CA68  8C640054   LW A0, 84(V1)
9D00CA6C  24840007   ADDIU A0, A0, 7
9D00CA78  0240A021   ADDU S4, S2, ZERO
9D00CA7C  8FB7002C   LW S7, 44(SP)
9D00CA80  0B404D98   J .L45
9D00CA84  0240A821   ADDU S5, S2, ZERO
9D00CAB8  0240A021   ADDU S4, S2, ZERO
9D00CABC  8FB7002C   LW S7, 44(SP)
1724:                         OPCODE_END
9D00CA70  1C400005   BGTZ V0, 0x9D00CA88
9D00CA74  AC640054   SW A0, 84(V1)
9D00CA88  26100003   ADDIU S0, S0, 3
9D00CAA8  90420000   LBU V0, 0(V0)
9D00CAAC  00021080   SLL V0, V0, 2
9D00CAB0  00561021   ADDU V0, V0, S6
9D00CAB4  8C420000   LW V0, 0(V0)
9D00CAC0  0B402953   J 0x9D00A54C
9D00CAC4  0240A821   ADDU S5, S2, ZERO
1725:                
1726:                      OPCODE_BEGIN(40)  /* RTI */
1727:                         RTI();
9D00CAC8  8F828050   LW V0, -32688(GP)
9D00CACC  8FA60018   LW A2, 24(SP)
9D00CAD0  24C50001   ADDIU A1, A2, 1
9D00CAD4  30A500FF   ANDI A1, A1, 255
9D00CAD8  00452821   ADDU A1, V0, A1
9D00CADC  90B70000   LBU S7, 0(A1)
9D00CAE0  32F20080   ANDI S2, S7, 128
9D00CAE4  32E30040   ANDI V1, S7, 64
9D00CAE8  306300FF   ANDI V1, V1, 255
9D00CAEC  AFA30014   SW V1, 20(SP)
9D00CAF0  32E30010   ANDI V1, S7, 16
9D00CAF4  306300FF   ANDI V1, V1, 255
9D00CAF8  AFA30028   SW V1, 40(SP)
9D00CAFC  32E30008   ANDI V1, S7, 8
9D00CB00  306300FF   ANDI V1, V1, 255
9D00CB04  AFA30020   SW V1, 32(SP)
9D00CB08  32E30004   ANDI V1, S7, 4
9D00CB0C  306300FF   ANDI V1, V1, 255
9D00CB10  AFA3001C   SW V1, 28(SP)
9D00CB14  3AF50002   XORI S5, S7, 2
9D00CB18  7EB50040   EXT S5, S5, 1, 1
9D00CB1C  24C60002   ADDIU A2, A2, 2
9D00CB20  30C600FF   ANDI A2, A2, 255
9D00CB24  00463021   ADDU A2, V0, A2
9D00CB28  90C40000   LBU A0, 0(A2)
9D00CB2C  8FA70018   LW A3, 24(SP)
9D00CB30  24E30003   ADDIU V1, A3, 3
9D00CB34  306300FF   ANDI V1, V1, 255
9D00CB38  00431021   ADDU V0, V0, V1
9D00CB3C  90510000   LBU S1, 0(V0)
9D00CB40  00118A00   SLL S1, S1, 8
9D00CB44  02248825   OR S1, S1, A0
9D00CB48  8F908058   LW S0, -32680(GP)
9D00CB4C  2607FFFA   ADDIU A3, S0, -6
9D00CB50  AF878058   SW A3, -32680(GP)
9D00CB54  26648FD8   ADDIU A0, S3, -28712
9D00CB58  8C880054   LW T0, 84(A0)
9D00CB5C  25080006   ADDIU T0, T0, 6
9D00CB60  AC880054   SW T0, 84(A0)
9D00CB64  8FA4001C   LW A0, 28(SP)
9D00CB68  14800026   BNE A0, ZERO, 0x9D00CC04
9D00CB6C  32F70001   ANDI S7, S7, 1
9D00CB70  26648FD8   ADDIU A0, S3, -28712
9D00CB74  90840052   LBU A0, 82(A0)
9D00CB78  50800023   BEQL A0, ZERO, 0x9D00CC08
9D00CB7C  8F828058   LW V0, -32680(GP)
9D00CB80  58E00021   BLEZL A3, 0x9D00CC08
9D00CB84  8F828058   LW V0, -32680(GP)
9D00CB88  26638FD8   ADDIU V1, S3, -28712
9D00CB8C  A0600052   SB ZERO, 82(V1)
9D00CB90  00111A02   SRL V1, S1, 8
9D00CB94  A0430000   SB V1, 0(V0)
9D00CB98  A0D10000   SB S1, 0(A2)
9D00CB9C  2406FF80   ADDIU A2, ZERO, -128
9D00CBA0  02462024   AND A0, S2, A2
9D00CBA4  7C042420   SEB A0, A0
9D00CBA8  24030002   ADDIU V1, ZERO, 2
9D00CBAC  0015180B   MOVN V1, ZERO, S5
9D00CBB0  36E20020   ORI V0, S7, 32
9D00CBB4  00821025   OR V0, A0, V0
9D00CBB8  8FA70014   LW A3, 20(SP)
9D00CBBC  00E21025   OR V0, A3, V0
9D00CBC0  8FA40020   LW A0, 32(SP)
9D00CBC4  00821025   OR V0, A0, V0
9D00CBC8  00621025   OR V0, V1, V0
9D00CBCC  A0A20000   SB V0, 0(A1)
9D00CBD0  0F402863   JAL bank_readword
9D00CBD4  3404FFFE   ORI A0, ZERO, -2
9D00CBD8  00408821   ADDU S1, V0, ZERO
9D00CBDC  2610FFF3   ADDIU S0, S0, -13
9D00CBE0  AF908058   SW S0, -32680(GP)
9D00CBE4  26628FD8   ADDIU V0, S3, -28712
9D00CBE8  8C430054   LW V1, 84(V0)
9D00CBEC  24630007   ADDIU V1, V1, 7
9D00CBF0  AC430054   SW V1, 84(V0)
9D00CBF4  8FA30018   LW V1, 24(SP)
9D00CBF8  24050001   ADDIU A1, ZERO, 1
9D00CBFC  AFA5001C   SW A1, 28(SP)
9D00CC00  AFA00028   SW ZERO, 40(SP)
1728:                         OPCODE_END
9D00CC04  8F828058   LW V0, -32680(GP)
9D00CC08  1C400003   BGTZ V0, .LBB948
9D00CC0C  26300001   ADDIU S0, S1, 1
9D00CC10  0B404D98   J .L45
9D00CC14  AFA30018   SW V1, 24(SP)
9D00CC34  90420000   LBU V0, 0(V0)
9D00CC38  00021080   SLL V0, V0, 2
9D00CC3C  00561021   ADDU V0, V0, S6
9D00CC40  8C420000   LW V0, 0(V0)
9D00CC44  0B402953   J 0x9D00A54C
9D00CC48  AFA30018   SW V1, 24(SP)
1729:                
1730:                      OPCODE_BEGIN(41)  /* EOR ($nn,X) */
1731:                         EOR(6, INDIR_X_BYTE);
9D00CC4C  26110001   ADDIU S1, S0, 1
9D00CC6C  90420000   LBU V0, 0(V0)
9D00CC70  03C21021   ADDU V0, FP, V0
9D00CC8C  0F402804   JAL mem_readbyte
9D00CC90  308400FF   ANDI A0, A0, 255
9D00CC94  00541026   XOR V0, V0, S4
9D00CC98  305200FF   ANDI S2, V0, 255
9D00CC9C  8F828058   LW V0, -32680(GP)
9D00CCA0  2442FFFA   ADDIU V0, V0, -6
9D00CCA4  AF828058   SW V0, -32680(GP)
9D00CCA8  8EA30054   LW V1, 84(S5)
9D00CCAC  24630006   ADDIU V1, V1, 6
9D00CCB8  0240A021   ADDU S4, S2, ZERO
9D00CCBC  0B404D98   J .L45
9D00CCC0  0240A821   ADDU S5, S2, ZERO
9D00CCF4  0240A021   ADDU S4, S2, ZERO
1732:                         OPCODE_END
9D00CCB0  1C400004   BGTZ V0, 0x9D00CCC4
9D00CCB4  AEA30054   SW V1, 84(S5)
9D00CCC4  26100002   ADDIU S0, S0, 2
9D00CCE4  90420000   LBU V0, 0(V0)
9D00CCE8  00021080   SLL V0, V0, 2
9D00CCEC  00561021   ADDU V0, V0, S6
9D00CCF0  8C420000   LW V0, 0(V0)
9D00CCF8  0B402953   J 0x9D00A54C
9D00CCFC  0240A821   ADDU S5, S2, ZERO
1733:                
1734:                      OPCODE_BEGIN(43)  /* SRE ($nn,X) */
1735:                         SRE(8, INDIR_X, mem_writebyte, addr);
9D00CD00  26110001   ADDIU S1, S0, 1
9D00CD20  90420000   LBU V0, 0(V0)
9D00CD24  03C21021   ADDU V0, FP, V0
9D00CD48  0F402804   JAL mem_readbyte
9D00CD4C  00402021   ADDU A0, V0, ZERO
9D00CD50  30570001   ANDI S7, V0, 1
9D00CD54  7C523840   EXT S2, V0, 1, 8
9D00CD58  8FA4002C   LW A0, 44(SP)
9D00CD5C  0F40283A   JAL mem_writebyte
9D00CD60  02402821   ADDU A1, S2, ZERO
9D00CD64  02549026   XOR S2, S2, S4
9D00CD68  325200FF   ANDI S2, S2, 255
9D00CD6C  8F828058   LW V0, -32680(GP)
9D00CD70  2442FFF8   ADDIU V0, V0, -8
9D00CD74  AF828058   SW V0, -32680(GP)
9D00CD78  8EA30054   LW V1, 84(S5)
9D00CD7C  24630008   ADDIU V1, V1, 8
9D00CD88  0240A021   ADDU S4, S2, ZERO
9D00CD8C  0B404D98   J .L45
9D00CD90  0240A821   ADDU S5, S2, ZERO
9D00CDC4  0240A021   ADDU S4, S2, ZERO
1736:                         OPCODE_END
9D00CD80  1C400004   BGTZ V0, 0x9D00CD94
9D00CD84  AEA30054   SW V1, 84(S5)
9D00CD94  26100002   ADDIU S0, S0, 2
9D00CDB4  90420000   LBU V0, 0(V0)
9D00CDB8  00021080   SLL V0, V0, 2
9D00CDBC  00561021   ADDU V0, V0, S6
9D00CDC0  8C420000   LW V0, 0(V0)
9D00CDC8  0B402953   J 0x9D00A54C
9D00CDCC  0240A821   ADDU S5, S2, ZERO
1737:                
1738:                      OPCODE_BEGIN(45)  /* EOR $nn */
1739:                         EOR(3, ZERO_PAGE_BYTE);
9D00CDD0  26110001   ADDIU S1, S0, 1
9D00CDF0  90630000   LBU V1, 0(V1)
9D00CDF4  8F848054   LW A0, -32684(GP)
9D00CDF8  00831821   ADDU V1, A0, V1
9D00CDFC  90720000   LBU S2, 0(V1)
9D00CE00  02929026   XOR S2, S4, S2
9D00CE04  325200FF   ANDI S2, S2, 255
9D00CE08  8F838058   LW V1, -32680(GP)
9D00CE0C  2463FFFD   ADDIU V1, V1, -3
9D00CE10  AF838058   SW V1, -32680(GP)
9D00CE14  8C440054   LW A0, 84(V0)
9D00CE18  24840003   ADDIU A0, A0, 3
9D00CE24  0240A021   ADDU S4, S2, ZERO
9D00CE28  0B404D98   J .L45
9D00CE2C  0240A821   ADDU S5, S2, ZERO
9D00CE60  0240A021   ADDU S4, S2, ZERO
1740:                         OPCODE_END
9D00CE1C  1C600004   BGTZ V1, 0x9D00CE30
9D00CE20  AC440054   SW A0, 84(V0)
9D00CE30  26100002   ADDIU S0, S0, 2
9D00CE50  90420000   LBU V0, 0(V0)
9D00CE54  00021080   SLL V0, V0, 2
9D00CE58  00561021   ADDU V0, V0, S6
9D00CE5C  8C420000   LW V0, 0(V0)
9D00CE64  0B402953   J 0x9D00A54C
9D00CE68  0240A821   ADDU S5, S2, ZERO
1741:                
1742:                      OPCODE_BEGIN(46)  /* LSR $nn */
1743:                         LSR(5, ZERO_PAGE, ZP_WRITEBYTE, baddr);
9D00CE6C  26110001   ADDIU S1, S0, 1
9D00CE8C  90630000   LBU V1, 0(V1)
9D00CE90  8F848054   LW A0, -32684(GP)
9D00CE94  00831821   ADDU V1, A0, V1
9D00CE98  90720000   LBU S2, 0(V1)
9D00CE9C  32570001   ANDI S7, S2, 1
9D00CEA0  00129042   SRL S2, S2, 1
9D00CEA4  A0720000   SB S2, 0(V1)
9D00CEA8  8F838058   LW V1, -32680(GP)
9D00CEAC  2463FFFB   ADDIU V1, V1, -5
9D00CEB0  AF838058   SW V1, -32680(GP)
9D00CEB4  8C440054   LW A0, 84(V0)
9D00CEB8  24840005   ADDIU A0, A0, 5
9D00CEC4  0B404D98   J .L45
9D00CEC8  0240A821   ADDU S5, S2, ZERO
1744:                         OPCODE_END
9D00CEBC  1C600003   BGTZ V1, 0x9D00CECC
9D00CEC0  AC440054   SW A0, 84(V0)
9D00CECC  26100002   ADDIU S0, S0, 2
9D00CEEC  90420000   LBU V0, 0(V0)
9D00CEF0  00021080   SLL V0, V0, 2
9D00CEF4  00561021   ADDU V0, V0, S6
9D00CEF8  8C420000   LW V0, 0(V0)
9D00CEFC  0B402953   J 0x9D00A54C
9D00CF00  0240A821   ADDU S5, S2, ZERO
1745:                
1746:                      OPCODE_BEGIN(47)  /* SRE $nn */
1747:                         SRE(5, ZERO_PAGE, ZP_WRITEBYTE, baddr);
9D00CF04  26110001   ADDIU S1, S0, 1
9D00CF24  90630000   LBU V1, 0(V1)
9D00CF28  8F848054   LW A0, -32684(GP)
9D00CF2C  00832021   ADDU A0, A0, V1
9D00CF30  90830000   LBU V1, 0(A0)
9D00CF34  30770001   ANDI S7, V1, 1
9D00CF38  00031842   SRL V1, V1, 1
9D00CF3C  A0830000   SB V1, 0(A0)
9D00CF40  00741826   XOR V1, V1, S4
9D00CF44  307200FF   ANDI S2, V1, 255
9D00CF48  8F838058   LW V1, -32680(GP)
9D00CF4C  2463FFFB   ADDIU V1, V1, -5
9D00CF50  AF838058   SW V1, -32680(GP)
9D00CF54  8C440054   LW A0, 84(V0)
9D00CF58  24840005   ADDIU A0, A0, 5
9D00CF64  0240A021   ADDU S4, S2, ZERO
9D00CF68  0B404D98   J .L45
9D00CF6C  0240A821   ADDU S5, S2, ZERO
9D00CFA0  0240A021   ADDU S4, S2, ZERO
1748:                         OPCODE_END
9D00CF5C  1C600004   BGTZ V1, 0x9D00CF70
9D00CF60  AC440054   SW A0, 84(V0)
9D00CF70  26100002   ADDIU S0, S0, 2
9D00CF90  90420000   LBU V0, 0(V0)
9D00CF94  00021080   SLL V0, V0, 2
9D00CF98  00561021   ADDU V0, V0, S6
9D00CF9C  8C420000   LW V0, 0(V0)
9D00CFA4  0B402953   J 0x9D00A54C
9D00CFA8  0240A821   ADDU S5, S2, ZERO
1749:                
1750:                      OPCODE_BEGIN(48)  /* PHA */
1751:                         PHA();
9D00CFAC  8FA60018   LW A2, 24(SP)
9D00CFB0  24C4FFFF   ADDIU A0, A2, -1
9D00CFB4  308400FF   ANDI A0, A0, 255
9D00CFB8  8F828050   LW V0, -32688(GP)
9D00CFBC  00461021   ADDU V0, V0, A2
9D00CFC0  A0540000   SB S4, 0(V0)
9D00CFC4  8F828058   LW V0, -32680(GP)
9D00CFC8  2442FFFD   ADDIU V0, V0, -3
9D00CFCC  AF828058   SW V0, -32680(GP)
9D00CFD0  26638FD8   ADDIU V1, S3, -28712
9D00CFD4  8C650054   LW A1, 84(V1)
9D00CFD8  24A50003   ADDIU A1, A1, 3
9D00CFE4  AFA40018   SW A0, 24(SP)
9D00D01C  AFA40018   SW A0, 24(SP)
1752:                         OPCODE_END
9D00CFDC  1C400004   BGTZ V0, .LBB974
9D00CFE0  AC650054   SW A1, 84(V1)
9D00CFE8  0B404D98   J .L45
9D00CFEC  02008821   ADDU S1, S0, ZERO
9D00D00C  90420000   LBU V0, 0(V0)
9D00D010  00021080   SLL V0, V0, 2
9D00D014  00561021   ADDU V0, V0, S6
9D00D018  8C420000   LW V0, 0(V0)
9D00D020  0B402953   J 0x9D00A54C
9D00D024  26100001   ADDIU S0, S0, 1
1753:                
1754:                      OPCODE_BEGIN(49)  /* EOR #$nn */
1755:                         EOR(2, IMMEDIATE_BYTE);
9D00D028  26110001   ADDIU S1, S0, 1
9D00D048  90720000   LBU S2, 0(V1)
9D00D04C  02929026   XOR S2, S4, S2
9D00D050  325200FF   ANDI S2, S2, 255
9D00D054  8F838058   LW V1, -32680(GP)
9D00D058  2463FFFE   ADDIU V1, V1, -2
9D00D05C  AF838058   SW V1, -32680(GP)
9D00D060  8C440054   LW A0, 84(V0)
9D00D064  24840002   ADDIU A0, A0, 2
9D00D070  0240A021   ADDU S4, S2, ZERO
9D00D074  0B404D98   J .L45
9D00D078  0240A821   ADDU S5, S2, ZERO
9D00D0AC  0240A021   ADDU S4, S2, ZERO
1756:                         OPCODE_END
9D00D068  1C600004   BGTZ V1, 0x9D00D07C
9D00D06C  AC440054   SW A0, 84(V0)
9D00D07C  26100002   ADDIU S0, S0, 2
9D00D09C  90420000   LBU V0, 0(V0)
9D00D0A0  00021080   SLL V0, V0, 2
9D00D0A4  00561021   ADDU V0, V0, S6
9D00D0A8  8C420000   LW V0, 0(V0)
9D00D0B0  0B402953   J 0x9D00A54C
9D00D0B4  0240A821   ADDU S5, S2, ZERO
1757:                
1758:                      OPCODE_BEGIN(4A)  /* LSR A */
1759:                         LSR_A();
9D00D0B8  32970001   ANDI S7, S4, 1
9D00D0BC  7E923840   EXT S2, S4, 1, 8
9D00D0C0  8F828058   LW V0, -32680(GP)
9D00D0C4  2442FFFE   ADDIU V0, V0, -2
9D00D0C8  AF828058   SW V0, -32680(GP)
9D00D0CC  26638FD8   ADDIU V1, S3, -28712
9D00D0D0  8C640054   LW A0, 84(V1)
9D00D0D4  24840002   ADDIU A0, A0, 2
9D00D0E0  0240A021   ADDU S4, S2, ZERO
9D00D0E8  0B404D98   J .L45
9D00D0EC  0240A821   ADDU S5, S2, ZERO
9D00D11C  0240A021   ADDU S4, S2, ZERO
1760:                         OPCODE_END
9D00D0D8  1C400005   BGTZ V0, .LBB980
9D00D0DC  AC640054   SW A0, 84(V1)
9D00D0E4  02008821   ADDU S1, S0, ZERO
9D00D10C  90420000   LBU V0, 0(V0)
9D00D110  00021080   SLL V0, V0, 2
9D00D114  00561021   ADDU V0, V0, S6
9D00D118  8C420000   LW V0, 0(V0)
9D00D120  26100001   ADDIU S0, S0, 1
9D00D124  0B402953   J 0x9D00A54C
9D00D128  0240A821   ADDU S5, S2, ZERO
1761:                
1762:                      OPCODE_BEGIN(4B)  /* ASR #$nn */
1763:                         ASR(2, IMMEDIATE_BYTE);
9D00D12C  26110001   ADDIU S1, S0, 1
9D00D14C  90720000   LBU S2, 0(V1)
9D00D150  02929024   AND S2, S4, S2
9D00D154  32570001   ANDI S7, S2, 1
9D00D158  00129042   SRL S2, S2, 1
9D00D15C  8F838058   LW V1, -32680(GP)
9D00D160  2463FFFE   ADDIU V1, V1, -2
9D00D164  AF838058   SW V1, -32680(GP)
9D00D168  8C440054   LW A0, 84(V0)
9D00D16C  24840002   ADDIU A0, A0, 2
9D00D178  0240A021   ADDU S4, S2, ZERO
9D00D17C  0B404D98   J .L45
9D00D180  0240A821   ADDU S5, S2, ZERO
9D00D1B4  0240A021   ADDU S4, S2, ZERO
1764:                         OPCODE_END
9D00D170  1C600004   BGTZ V1, 0x9D00D184
9D00D174  AC440054   SW A0, 84(V0)
9D00D184  26100002   ADDIU S0, S0, 2
9D00D1A4  90420000   LBU V0, 0(V0)
9D00D1A8  00021080   SLL V0, V0, 2
9D00D1AC  00561021   ADDU V0, V0, S6
9D00D1B0  8C420000   LW V0, 0(V0)
9D00D1B8  0B402953   J 0x9D00A54C
9D00D1BC  0240A821   ADDU S5, S2, ZERO
1765:                
1766:                      OPCODE_BEGIN(4C)  /* JMP $nnnn */
1767:                         JMP_ABSOLUTE();
9D00D1C0  0F402863   JAL bank_readword
9D00D1C4  02002021   ADDU A0, S0, ZERO
9D00D1C8  00408821   ADDU S1, V0, ZERO
9D00D1CC  8F828058   LW V0, -32680(GP)
9D00D1D0  2442FFFD   ADDIU V0, V0, -3
9D00D1D4  AF828058   SW V0, -32680(GP)
9D00D1D8  26638FD8   ADDIU V1, S3, -28712
9D00D1DC  8C640054   LW A0, 84(V1)
9D00D1E0  24840003   ADDIU A0, A0, 3
1768:                         OPCODE_END
9D00D1E4  1840191E   BLEZ V0, .L45
9D00D1E8  AC640054   SW A0, 84(V1)
9D00D1EC  26300001   ADDIU S0, S1, 1
9D00D20C  90420000   LBU V0, 0(V0)
9D00D210  00021080   SLL V0, V0, 2
9D00D214  00561021   ADDU V0, V0, S6
9D00D218  0B402953   J 0x9D00A54C
9D00D21C  8C420000   LW V0, 0(V0)
1769:                
1770:                      OPCODE_BEGIN(4D)  /* EOR $nnnn */
1771:                         EOR(4, ABSOLUTE_BYTE);
9D00D220  0F402863   JAL bank_readword
9D00D224  02002021   ADDU A0, S0, ZERO
9D00D228  26110002   ADDIU S1, S0, 2
9D00D22C  0F402804   JAL mem_readbyte
9D00D230  00402021   ADDU A0, V0, ZERO
9D00D234  00541026   XOR V0, V0, S4
9D00D238  305200FF   ANDI S2, V0, 255
9D00D23C  8F828058   LW V0, -32680(GP)
9D00D240  2442FFFC   ADDIU V0, V0, -4
9D00D244  AF828058   SW V0, -32680(GP)
9D00D248  26638FD8   ADDIU V1, S3, -28712
9D00D24C  8C640054   LW A0, 84(V1)
9D00D250  24840004   ADDIU A0, A0, 4
9D00D25C  0240A021   ADDU S4, S2, ZERO
9D00D260  0B404D98   J .L45
9D00D264  0240A821   ADDU S5, S2, ZERO
9D00D298  0240A021   ADDU S4, S2, ZERO
1772:                         OPCODE_END
9D00D254  1C400004   BGTZ V0, 0x9D00D268
9D00D258  AC640054   SW A0, 84(V1)
9D00D268  26100003   ADDIU S0, S0, 3
9D00D288  90420000   LBU V0, 0(V0)
9D00D28C  00021080   SLL V0, V0, 2
9D00D290  00561021   ADDU V0, V0, S6
9D00D294  8C420000   LW V0, 0(V0)
9D00D29C  0B402953   J 0x9D00A54C
9D00D2A0  0240A821   ADDU S5, S2, ZERO
1773:                
1774:                      OPCODE_BEGIN(4E)  /* LSR $nnnn */
1775:                         LSR(6, ABSOLUTE, mem_writebyte, addr);
9D00D2A4  0F402863   JAL bank_readword
9D00D2A8  02002021   ADDU A0, S0, ZERO
9D00D2AC  0040A821   ADDU S5, V0, ZERO
9D00D2B0  26110002   ADDIU S1, S0, 2
9D00D2B4  0F402804   JAL mem_readbyte
9D00D2B8  00402021   ADDU A0, V0, ZERO
9D00D2BC  30570001   ANDI S7, V0, 1
9D00D2C0  7C523840   EXT S2, V0, 1, 8
9D00D2C4  02A02021   ADDU A0, S5, ZERO
9D00D2C8  0F40283A   JAL mem_writebyte
9D00D2CC  02402821   ADDU A1, S2, ZERO
9D00D2D0  8F828058   LW V0, -32680(GP)
9D00D2D4  2442FFFA   ADDIU V0, V0, -6
9D00D2D8  AF828058   SW V0, -32680(GP)
9D00D2DC  26638FD8   ADDIU V1, S3, -28712
9D00D2E0  8C640054   LW A0, 84(V1)
9D00D2E4  24840006   ADDIU A0, A0, 6
9D00D2F0  0B404D98   J .L45
9D00D2F4  0240A821   ADDU S5, S2, ZERO
1776:                         OPCODE_END
9D00D2E8  1C400003   BGTZ V0, 0x9D00D2F8
9D00D2EC  AC640054   SW A0, 84(V1)
9D00D2F8  26100003   ADDIU S0, S0, 3
9D00D318  90420000   LBU V0, 0(V0)
9D00D31C  00021080   SLL V0, V0, 2
9D00D320  00561021   ADDU V0, V0, S6
9D00D324  8C420000   LW V0, 0(V0)
9D00D328  0B402953   J 0x9D00A54C
9D00D32C  0240A821   ADDU S5, S2, ZERO
1777:                
1778:                      OPCODE_BEGIN(4F)  /* SRE $nnnn */
1779:                         SRE(6, ABSOLUTE, mem_writebyte, addr);
9D00D330  0F402863   JAL bank_readword
9D00D334  02002021   ADDU A0, S0, ZERO
9D00D338  0040A821   ADDU S5, V0, ZERO
9D00D33C  26110002   ADDIU S1, S0, 2
9D00D340  0F402804   JAL mem_readbyte
9D00D344  00402021   ADDU A0, V0, ZERO
9D00D348  30570001   ANDI S7, V0, 1
9D00D34C  7C523840   EXT S2, V0, 1, 8
9D00D350  02A02021   ADDU A0, S5, ZERO
9D00D354  0F40283A   JAL mem_writebyte
9D00D358  02402821   ADDU A1, S2, ZERO
9D00D35C  02549026   XOR S2, S2, S4
9D00D360  325200FF   ANDI S2, S2, 255
9D00D364  8F828058   LW V0, -32680(GP)
9D00D368  2442FFFA   ADDIU V0, V0, -6
9D00D36C  AF828058   SW V0, -32680(GP)
9D00D370  26638FD8   ADDIU V1, S3, -28712
9D00D374  8C640054   LW A0, 84(V1)
9D00D378  24840006   ADDIU A0, A0, 6
9D00D384  0240A021   ADDU S4, S2, ZERO
9D00D388  0B404D98   J .L45
9D00D38C  0240A821   ADDU S5, S2, ZERO
9D00D3C0  0240A021   ADDU S4, S2, ZERO
1780:                         OPCODE_END
9D00D37C  1C400004   BGTZ V0, 0x9D00D390
9D00D380  AC640054   SW A0, 84(V1)
9D00D390  26100003   ADDIU S0, S0, 3
9D00D3B0  90420000   LBU V0, 0(V0)
9D00D3B4  00021080   SLL V0, V0, 2
9D00D3B8  00561021   ADDU V0, V0, S6
9D00D3BC  8C420000   LW V0, 0(V0)
9D00D3C4  0B402953   J 0x9D00A54C
9D00D3C8  0240A821   ADDU S5, S2, ZERO
1781:                
1782:                      OPCODE_BEGIN(50)  /* BVC $nnnn */
1783:                         BVC();
9D00D3CC  8FA70014   LW A3, 20(SP)
9D00D3D0  14E0001E   BNE A3, ZERO, 0x9D00D44C
9D00D3D4  26110001   ADDIU S1, S0, 1
9D00D3D8  26020001   ADDIU V0, S0, 1
9D00D3F8  80710000   LB S1, 0(V1)
9D00D3FC  304300FF   ANDI V1, V0, 255
9D00D400  02231821   ADDU V1, S1, V1
9D00D404  30630100   ANDI V1, V1, 256
9D00D408  10600008   BEQ V1, ZERO, 0x9D00D42C
9D00D40C  8F838058   LW V1, -32680(GP)
9D00D410  2463FFFF   ADDIU V1, V1, -1
9D00D414  AF838058   SW V1, -32680(GP)
9D00D418  26638FD8   ADDIU V1, S3, -28712
9D00D41C  8C640054   LW A0, 84(V1)
9D00D420  24840001   ADDIU A0, A0, 1
9D00D424  AC640054   SW A0, 84(V1)
9D00D428  8F838058   LW V1, -32680(GP)
9D00D42C  2463FFFD   ADDIU V1, V1, -3
9D00D430  AF838058   SW V1, -32680(GP)
9D00D434  26638FD8   ADDIU V1, S3, -28712
9D00D438  8C640054   LW A0, 84(V1)
9D00D43C  24840003   ADDIU A0, A0, 3
9D00D440  AC640054   SW A0, 84(V1)
9D00D444  0B40351A   J 0x9D00D468
9D00D448  02228821   ADDU S1, S1, V0
9D00D44C  8F828058   LW V0, -32680(GP)
9D00D450  2442FFFE   ADDIU V0, V0, -2
9D00D454  AF828058   SW V0, -32680(GP)
9D00D458  26628FD8   ADDIU V0, S3, -28712
9D00D45C  8C430054   LW V1, 84(V0)
9D00D460  24630002   ADDIU V1, V1, 2
9D00D464  AC430054   SW V1, 84(V0)
1784:                         OPCODE_END
9D00D468  8F828058   LW V0, -32680(GP)
9D00D46C  1840187C   BLEZ V0, .L45
9D00D470  26300001   ADDIU S0, S1, 1
9D00D490  90420000   LBU V0, 0(V0)
9D00D494  00021080   SLL V0, V0, 2
9D00D498  00561021   ADDU V0, V0, S6
9D00D49C  0B402953   J 0x9D00A54C
9D00D4A0  8C420000   LW V0, 0(V0)
1785:                
1786:                      OPCODE_BEGIN(51)  /* EOR ($nn),Y */
1787:                         EOR(5, INDIR_Y_BYTE_READ);
9D00D4DC  8FA20010   LW V0, 16(SP)
9D00D4E0  00822021   ADDU A0, A0, V0
9D00D4E4  3084FFFF   ANDI A0, A0, -1
9D00D4E8  308200FF   ANDI V0, A0, 255
9D00D4EC  8FA30010   LW V1, 16(SP)
9D00D4F0  0043102B   SLTU V0, V0, V1
9D00D4F4  10400008   BEQ V0, ZERO, 0x9D00D518
9D00D4F8  26110001   ADDIU S1, S0, 1
9D00D4FC  8F828058   LW V0, -32680(GP)
9D00D500  2442FFFF   ADDIU V0, V0, -1
9D00D504  AF828058   SW V0, -32680(GP)
9D00D508  26628FD8   ADDIU V0, S3, -28712
9D00D50C  8C430054   LW V1, 84(V0)
9D00D510  24630001   ADDIU V1, V1, 1
9D00D514  AC430054   SW V1, 84(V0)
9D00D518  0F402804   JAL mem_readbyte
9D00D51C  00000000   NOP
9D00D520  00541026   XOR V0, V0, S4
9D00D524  305200FF   ANDI S2, V0, 255
9D00D528  8F828058   LW V0, -32680(GP)
9D00D52C  2442FFFB   ADDIU V0, V0, -5
9D00D530  AF828058   SW V0, -32680(GP)
9D00D534  26638FD8   ADDIU V1, S3, -28712
9D00D538  8C640054   LW A0, 84(V1)
9D00D53C  24840005   ADDIU A0, A0, 5
9D00D548  0240A021   ADDU S4, S2, ZERO
9D00D54C  0B404D98   J .L45
9D00D550  0240A821   ADDU S5, S2, ZERO
9D00D584  0240A021   ADDU S4, S2, ZERO
1788:                         OPCODE_END
9D00D540  1C400004   BGTZ V0, 0x9D00D554
9D00D544  AC640054   SW A0, 84(V1)
9D00D554  26100002   ADDIU S0, S0, 2
9D00D574  90420000   LBU V0, 0(V0)
9D00D578  00021080   SLL V0, V0, 2
9D00D57C  00561021   ADDU V0, V0, S6
9D00D580  8C420000   LW V0, 0(V0)
9D00D588  0B402953   J 0x9D00A54C
9D00D58C  0240A821   ADDU S5, S2, ZERO
1789:                
1790:                      OPCODE_BEGIN(53)  /* SRE ($nn),Y */
1791:                         SRE(8, INDIR_Y, mem_writebyte, addr);
9D00D590  26110001   ADDIU S1, S0, 1
9D00D5CC  8FA40010   LW A0, 16(SP)
9D00D5D0  00441021   ADDU V0, V0, A0
9D00D5D4  3042FFFF   ANDI V0, V0, -1
9D00D5D8  AFA2002C   SW V0, 44(SP)
9D00D5DC  0F402804   JAL mem_readbyte
9D00D5E0  00402021   ADDU A0, V0, ZERO
9D00D5E4  30570001   ANDI S7, V0, 1
9D00D5E8  7C523840   EXT S2, V0, 1, 8
9D00D5EC  8FA4002C   LW A0, 44(SP)
9D00D5F0  0F40283A   JAL mem_writebyte
9D00D5F4  02402821   ADDU A1, S2, ZERO
9D00D5F8  02549026   XOR S2, S2, S4
9D00D5FC  325200FF   ANDI S2, S2, 255
9D00D600  8F828058   LW V0, -32680(GP)
9D00D604  2442FFF8   ADDIU V0, V0, -8
9D00D608  AF828058   SW V0, -32680(GP)
9D00D60C  8EA30054   LW V1, 84(S5)
9D00D610  24630008   ADDIU V1, V1, 8
9D00D61C  0240A021   ADDU S4, S2, ZERO
9D00D620  0B404D98   J .L45
9D00D624  0240A821   ADDU S5, S2, ZERO
9D00D658  0240A021   ADDU S4, S2, ZERO
1792:                         OPCODE_END
9D00D614  1C400004   BGTZ V0, 0x9D00D628
9D00D618  AEA30054   SW V1, 84(S5)
9D00D628  26100002   ADDIU S0, S0, 2
9D00D648  90420000   LBU V0, 0(V0)
9D00D64C  00021080   SLL V0, V0, 2
9D00D650  00561021   ADDU V0, V0, S6
9D00D654  8C420000   LW V0, 0(V0)
9D00D65C  0B402953   J 0x9D00A54C
9D00D660  0240A821   ADDU S5, S2, ZERO
1793:                
1794:                      OPCODE_BEGIN(55)  /* EOR $nn,X */
1795:                         EOR(4, ZP_IND_X_BYTE);
9D00D664  26110001   ADDIU S1, S0, 1
9D00D684  90630000   LBU V1, 0(V1)
9D00D688  03C31821   ADDU V1, FP, V1
9D00D68C  306300FF   ANDI V1, V1, 255
9D00D690  8F848054   LW A0, -32684(GP)
9D00D694  00831821   ADDU V1, A0, V1
9D00D698  90720000   LBU S2, 0(V1)
9D00D69C  02549026   XOR S2, S2, S4
9D00D6A0  325200FF   ANDI S2, S2, 255
9D00D6A4  8F838058   LW V1, -32680(GP)
9D00D6A8  2463FFFC   ADDIU V1, V1, -4
9D00D6AC  AF838058   SW V1, -32680(GP)
9D00D6B0  8C440054   LW A0, 84(V0)
9D00D6B4  24840004   ADDIU A0, A0, 4
9D00D6C0  0240A021   ADDU S4, S2, ZERO
9D00D6C4  0B404D98   J .L45
9D00D6C8  0240A821   ADDU S5, S2, ZERO
9D00D6FC  0240A021   ADDU S4, S2, ZERO
1796:                         OPCODE_END
9D00D6B8  1C600004   BGTZ V1, 0x9D00D6CC
9D00D6BC  AC440054   SW A0, 84(V0)
9D00D6CC  26100002   ADDIU S0, S0, 2
9D00D6EC  90420000   LBU V0, 0(V0)
9D00D6F0  00021080   SLL V0, V0, 2
9D00D6F4  00561021   ADDU V0, V0, S6
9D00D6F8  8C420000   LW V0, 0(V0)
9D00D700  0B402953   J 0x9D00A54C
9D00D704  0240A821   ADDU S5, S2, ZERO
1797:                
1798:                      OPCODE_BEGIN(56)  /* LSR $nn,X */
1799:                         LSR(6, ZP_IND_X, ZP_WRITEBYTE, baddr);
9D00D708  26110001   ADDIU S1, S0, 1
9D00D728  90630000   LBU V1, 0(V1)
9D00D72C  03C31821   ADDU V1, FP, V1
9D00D730  306300FF   ANDI V1, V1, 255
9D00D734  8F848054   LW A0, -32684(GP)
9D00D738  00831821   ADDU V1, A0, V1
9D00D73C  90720000   LBU S2, 0(V1)
9D00D740  32570001   ANDI S7, S2, 1
9D00D744  00129042   SRL S2, S2, 1
9D00D748  A0720000   SB S2, 0(V1)
9D00D74C  8F838058   LW V1, -32680(GP)
9D00D750  2463FFFA   ADDIU V1, V1, -6
9D00D754  AF838058   SW V1, -32680(GP)
9D00D758  8C440054   LW A0, 84(V0)
9D00D75C  24840006   ADDIU A0, A0, 6
9D00D768  0B404D98   J .L45
9D00D76C  0240A821   ADDU S5, S2, ZERO
1800:                         OPCODE_END
9D00D760  1C600003   BGTZ V1, 0x9D00D770
9D00D764  AC440054   SW A0, 84(V0)
9D00D770  26100002   ADDIU S0, S0, 2
9D00D790  90420000   LBU V0, 0(V0)
9D00D794  00021080   SLL V0, V0, 2
9D00D798  00561021   ADDU V0, V0, S6
9D00D79C  8C420000   LW V0, 0(V0)
9D00D7A0  0B402953   J 0x9D00A54C
9D00D7A4  0240A821   ADDU S5, S2, ZERO
1801:                
1802:                      OPCODE_BEGIN(57)  /* SRE $nn,X */
1803:                         SRE(6, ZP_IND_X, ZP_WRITEBYTE, baddr);
9D00D7A8  26110001   ADDIU S1, S0, 1
9D00D7C8  90630000   LBU V1, 0(V1)
9D00D7CC  03C31821   ADDU V1, FP, V1
9D00D7D0  306300FF   ANDI V1, V1, 255
9D00D7D4  8F848054   LW A0, -32684(GP)
9D00D7D8  00832021   ADDU A0, A0, V1
9D00D7DC  90830000   LBU V1, 0(A0)
9D00D7E0  30770001   ANDI S7, V1, 1
9D00D7E4  00031842   SRL V1, V1, 1
9D00D7E8  A0830000   SB V1, 0(A0)
9D00D7EC  00741826   XOR V1, V1, S4
9D00D7F0  307200FF   ANDI S2, V1, 255
9D00D7F4  8F838058   LW V1, -32680(GP)
9D00D7F8  2463FFFA   ADDIU V1, V1, -6
9D00D7FC  AF838058   SW V1, -32680(GP)
9D00D800  8C440054   LW A0, 84(V0)
9D00D804  24840006   ADDIU A0, A0, 6
9D00D810  0240A021   ADDU S4, S2, ZERO
9D00D814  0B404D98   J .L45
9D00D818  0240A821   ADDU S5, S2, ZERO
9D00D84C  0240A021   ADDU S4, S2, ZERO
1804:                         OPCODE_END
9D00D808  1C600004   BGTZ V1, 0x9D00D81C
9D00D80C  AC440054   SW A0, 84(V0)
9D00D81C  26100002   ADDIU S0, S0, 2
9D00D83C  90420000   LBU V0, 0(V0)
9D00D840  00021080   SLL V0, V0, 2
9D00D844  00561021   ADDU V0, V0, S6
9D00D848  8C420000   LW V0, 0(V0)
9D00D850  0B402953   J 0x9D00A54C
9D00D854  0240A821   ADDU S5, S2, ZERO
1805:                
1806:                      OPCODE_BEGIN(58)  /* CLI */
1807:                         CLI();
9D00D858  8F918058   LW S1, -32680(GP)
9D00D85C  2623FFFE   ADDIU V1, S1, -2
9D00D860  AF838058   SW V1, -32680(GP)
9D00D864  26628FD8   ADDIU V0, S3, -28712
9D00D868  8C440054   LW A0, 84(V0)
9D00D86C  24840002   ADDIU A0, A0, 2
9D00D870  AC440054   SW A0, 84(V0)
9D00D874  90420052   LBU V0, 82(V0)
9D00D878  10400031   BEQ V0, ZERO, 0x9D00D940
9D00D87C  AFA0001C   SW ZERO, 28(SP)
9D00D880  1860002F   BLEZ V1, 0x9D00D940
9D00D884  26628FD8   ADDIU V0, S3, -28712
9D00D888  A0400052   SB ZERO, 82(V0)
9D00D88C  8F828050   LW V0, -32688(GP)
9D00D890  8FA50018   LW A1, 24(SP)
9D00D894  00451821   ADDU V1, V0, A1
9D00D898  00102202   SRL A0, S0, 8
9D00D89C  A0640000   SB A0, 0(V1)
9D00D8A0  24A3FFFE   ADDIU V1, A1, -2
9D00D8A4  306300FF   ANDI V1, V1, 255
9D00D8A8  24A4FFFF   ADDIU A0, A1, -1
9D00D8AC  308400FF   ANDI A0, A0, 255
9D00D8B0  00442021   ADDU A0, V0, A0
9D00D8B4  A0900000   SB S0, 0(A0)
9D00D8B8  24A4FFFD   ADDIU A0, A1, -3
9D00D8BC  308400FF   ANDI A0, A0, 255
9D00D8C0  AFA40018   SW A0, 24(SP)
9D00D8C4  00431021   ADDU V0, V0, V1
9D00D8C8  2406FF80   ADDIU A2, ZERO, -128
9D00D8CC  02463824   AND A3, S2, A2
9D00D8D0  7C073C20   SEB A3, A3
9D00D8D4  24060040   ADDIU A2, ZERO, 64
9D00D8D8  8FA30014   LW V1, 20(SP)
9D00D8DC  0003300A   MOVZ A2, ZERO, V1
9D00D8E0  24050008   ADDIU A1, ZERO, 8
9D00D8E4  8FA40020   LW A0, 32(SP)
9D00D8E8  0004280A   MOVZ A1, ZERO, A0
9D00D8EC  24040002   ADDIU A0, ZERO, 2
9D00D8F0  0015200B   MOVN A0, ZERO, S5
9D00D8F4  36E30020   ORI V1, S7, 32
9D00D8F8  00E31825   OR V1, A3, V1
9D00D8FC  00C31825   OR V1, A2, V1
9D00D900  00A31825   OR V1, A1, V1
9D00D904  00831825   OR V1, A0, V1
9D00D908  A0430000   SB V1, 0(V0)
9D00D90C  0F402863   JAL bank_readword
9D00D910  3404FFFE   ORI A0, ZERO, -2
9D00D914  00408021   ADDU S0, V0, ZERO
9D00D918  2631FFF7   ADDIU S1, S1, -9
9D00D91C  AF918058   SW S1, -32680(GP)
9D00D920  26628FD8   ADDIU V0, S3, -28712
9D00D924  8C430054   LW V1, 84(V0)
9D00D928  24630007   ADDIU V1, V1, 7
9D00D92C  AC430054   SW V1, 84(V0)
9D00D930  24050001   ADDIU A1, ZERO, 1
9D00D934  AFA5001C   SW A1, 28(SP)
9D00D938  0B403650   J 0x9D00D940
9D00D93C  AFA00028   SW ZERO, 40(SP)
1808:                         OPCODE_END
9D00D940  8F828058   LW V0, -32680(GP)
9D00D944  1C400003   BGTZ V0, .LBB1022
9D00D948  00101B02   SRL V1, S0, 12
9D00D94C  0B404D98   J .L45
9D00D950  02008821   ADDU S1, S0, ZERO
9D00D96C  90420000   LBU V0, 0(V0)
9D00D970  00021080   SLL V0, V0, 2
9D00D974  00561021   ADDU V0, V0, S6
9D00D978  8C420000   LW V0, 0(V0)
9D00D97C  0B402953   J 0x9D00A54C
9D00D980  26100001   ADDIU S0, S0, 1
1809:                
1810:                      OPCODE_BEGIN(59)  /* EOR $nnnn,Y */
1811:                         EOR(4, ABS_IND_Y_BYTE_READ);
9D00D984  0F402863   JAL bank_readword
9D00D988  02002021   ADDU A0, S0, ZERO
9D00D98C  8FA60010   LW A2, 16(SP)
9D00D990  00461021   ADDU V0, V0, A2
9D00D994  3044FFFF   ANDI A0, V0, -1
9D00D998  308200FF   ANDI V0, A0, 255
9D00D99C  0046102B   SLTU V0, V0, A2
9D00D9A0  10400008   BEQ V0, ZERO, 0x9D00D9C4
9D00D9A4  26110002   ADDIU S1, S0, 2
9D00D9A8  8F828058   LW V0, -32680(GP)
9D00D9AC  2442FFFF   ADDIU V0, V0, -1
9D00D9B0  AF828058   SW V0, -32680(GP)
9D00D9B4  26628FD8   ADDIU V0, S3, -28712
9D00D9B8  8C430054   LW V1, 84(V0)
9D00D9BC  24630001   ADDIU V1, V1, 1
9D00D9C0  AC430054   SW V1, 84(V0)
9D00D9C4  0F402804   JAL mem_readbyte
9D00D9C8  00000000   NOP
9D00D9CC  00541026   XOR V0, V0, S4
9D00D9D0  305200FF   ANDI S2, V0, 255
9D00D9D4  8F828058   LW V0, -32680(GP)
9D00D9D8  2442FFFC   ADDIU V0, V0, -4
9D00D9DC  AF828058   SW V0, -32680(GP)
9D00D9E0  26638FD8   ADDIU V1, S3, -28712
9D00D9E4  8C640054   LW A0, 84(V1)
9D00D9E8  24840004   ADDIU A0, A0, 4
9D00D9F4  0240A021   ADDU S4, S2, ZERO
9D00D9F8  0B404D98   J .L45
9D00D9FC  0240A821   ADDU S5, S2, ZERO
9D00DA30  0240A021   ADDU S4, S2, ZERO
1812:                         OPCODE_END
9D00D9EC  1C400004   BGTZ V0, 0x9D00DA00
9D00D9F0  AC640054   SW A0, 84(V1)
9D00DA00  26100003   ADDIU S0, S0, 3
9D00DA20  90420000   LBU V0, 0(V0)
9D00DA24  00021080   SLL V0, V0, 2
9D00DA28  00561021   ADDU V0, V0, S6
9D00DA2C  8C420000   LW V0, 0(V0)
9D00DA34  0B402953   J 0x9D00A54C
9D00DA38  0240A821   ADDU S5, S2, ZERO
1813:                
1814:                      OPCODE_BEGIN(5B)  /* SRE $nnnn,Y */
1815:                         SRE(7, ABS_IND_Y, mem_writebyte, addr);
9D00DA3C  0F402863   JAL bank_readword
9D00DA40  02002021   ADDU A0, S0, ZERO
9D00DA44  26110002   ADDIU S1, S0, 2
9D00DA48  8FA70010   LW A3, 16(SP)
9D00DA4C  00471021   ADDU V0, V0, A3
9D00DA50  3055FFFF   ANDI S5, V0, -1
9D00DA54  0F402804   JAL mem_readbyte
9D00DA58  02A02021   ADDU A0, S5, ZERO
9D00DA5C  30570001   ANDI S7, V0, 1
9D00DA60  7C523840   EXT S2, V0, 1, 8
9D00DA64  02A02021   ADDU A0, S5, ZERO
9D00DA68  0F40283A   JAL mem_writebyte
9D00DA6C  02402821   ADDU A1, S2, ZERO
9D00DA70  02549026   XOR S2, S2, S4
9D00DA74  325200FF   ANDI S2, S2, 255
9D00DA78  8F828058   LW V0, -32680(GP)
9D00DA7C  2442FFF9   ADDIU V0, V0, -7
9D00DA80  AF828058   SW V0, -32680(GP)
9D00DA84  26638FD8   ADDIU V1, S3, -28712
9D00DA88  8C640054   LW A0, 84(V1)
9D00DA8C  24840007   ADDIU A0, A0, 7
9D00DA98  0240A021   ADDU S4, S2, ZERO
9D00DA9C  0B404D98   J .L45
9D00DAA0  0240A821   ADDU S5, S2, ZERO
9D00DAD4  0240A021   ADDU S4, S2, ZERO
1816:                         OPCODE_END
9D00DA90  1C400004   BGTZ V0, 0x9D00DAA4
9D00DA94  AC640054   SW A0, 84(V1)
9D00DAA4  26100003   ADDIU S0, S0, 3
9D00DAC4  90420000   LBU V0, 0(V0)
9D00DAC8  00021080   SLL V0, V0, 2
9D00DACC  00561021   ADDU V0, V0, S6
9D00DAD0  8C420000   LW V0, 0(V0)
9D00DAD8  0B402953   J 0x9D00A54C
9D00DADC  0240A821   ADDU S5, S2, ZERO
1817:                
1818:                      OPCODE_BEGIN(5D)  /* EOR $nnnn,X */
1819:                         EOR(4, ABS_IND_X_BYTE_READ);
9D00DAE0  0F402863   JAL bank_readword
9D00DAE4  02002021   ADDU A0, S0, ZERO
9D00DAE8  005E1021   ADDU V0, V0, FP
9D00DAEC  3044FFFF   ANDI A0, V0, -1
9D00DAF0  308200FF   ANDI V0, A0, 255
9D00DAF4  005E102B   SLTU V0, V0, FP
9D00DAF8  10400008   BEQ V0, ZERO, 0x9D00DB1C
9D00DAFC  26110002   ADDIU S1, S0, 2
9D00DB00  8F828058   LW V0, -32680(GP)
9D00DB04  2442FFFF   ADDIU V0, V0, -1
9D00DB08  AF828058   SW V0, -32680(GP)
9D00DB0C  26628FD8   ADDIU V0, S3, -28712
9D00DB10  8C430054   LW V1, 84(V0)
9D00DB14  24630001   ADDIU V1, V1, 1
9D00DB18  AC430054   SW V1, 84(V0)
9D00DB1C  0F402804   JAL mem_readbyte
9D00DB20  00000000   NOP
9D00DB24  00541026   XOR V0, V0, S4
9D00DB28  305200FF   ANDI S2, V0, 255
9D00DB2C  8F828058   LW V0, -32680(GP)
9D00DB30  2442FFFC   ADDIU V0, V0, -4
9D00DB34  AF828058   SW V0, -32680(GP)
9D00DB38  26638FD8   ADDIU V1, S3, -28712
9D00DB3C  8C640054   LW A0, 84(V1)
9D00DB40  24840004   ADDIU A0, A0, 4
9D00DB4C  0240A021   ADDU S4, S2, ZERO
9D00DB50  0B404D98   J .L45
9D00DB54  0240A821   ADDU S5, S2, ZERO
9D00DB88  0240A021   ADDU S4, S2, ZERO
1820:                         OPCODE_END
9D00DB44  1C400004   BGTZ V0, 0x9D00DB58
9D00DB48  AC640054   SW A0, 84(V1)
9D00DB58  26100003   ADDIU S0, S0, 3
9D00DB78  90420000   LBU V0, 0(V0)
9D00DB7C  00021080   SLL V0, V0, 2
9D00DB80  00561021   ADDU V0, V0, S6
9D00DB84  8C420000   LW V0, 0(V0)
9D00DB8C  0B402953   J 0x9D00A54C
9D00DB90  0240A821   ADDU S5, S2, ZERO
1821:                
1822:                      OPCODE_BEGIN(5E)  /* LSR $nnnn,X */
1823:                         LSR(7, ABS_IND_X, mem_writebyte, addr);
9D00DB94  0F402863   JAL bank_readword
9D00DB98  02002021   ADDU A0, S0, ZERO
9D00DB9C  26110002   ADDIU S1, S0, 2
9D00DBA0  005E1021   ADDU V0, V0, FP
9D00DBA4  3055FFFF   ANDI S5, V0, -1
9D00DBA8  0F402804   JAL mem_readbyte
9D00DBAC  02A02021   ADDU A0, S5, ZERO
9D00DBB0  30570001   ANDI S7, V0, 1
9D00DBB4  7C523840   EXT S2, V0, 1, 8
9D00DBB8  02A02021   ADDU A0, S5, ZERO
9D00DBBC  0F40283A   JAL mem_writebyte
9D00DBC0  02402821   ADDU A1, S2, ZERO
9D00DBC4  8F828058   LW V0, -32680(GP)
9D00DBC8  2442FFF9   ADDIU V0, V0, -7
9D00DBCC  AF828058   SW V0, -32680(GP)
9D00DBD0  26638FD8   ADDIU V1, S3, -28712
9D00DBD4  8C640054   LW A0, 84(V1)
9D00DBD8  24840007   ADDIU A0, A0, 7
9D00DBE4  0B404D98   J .L45
9D00DBE8  0240A821   ADDU S5, S2, ZERO
1824:                         OPCODE_END
9D00DBDC  1C400003   BGTZ V0, 0x9D00DBEC
9D00DBE0  AC640054   SW A0, 84(V1)
9D00DBEC  26100003   ADDIU S0, S0, 3
9D00DC0C  90420000   LBU V0, 0(V0)
9D00DC10  00021080   SLL V0, V0, 2
9D00DC14  00561021   ADDU V0, V0, S6
9D00DC18  8C420000   LW V0, 0(V0)
9D00DC1C  0B402953   J 0x9D00A54C
9D00DC20  0240A821   ADDU S5, S2, ZERO
1825:                
1826:                      OPCODE_BEGIN(5F)  /* SRE $nnnn,X */
1827:                         SRE(7, ABS_IND_X, mem_writebyte, addr);
9D00DC24  0F402863   JAL bank_readword
9D00DC28  02002021   ADDU A0, S0, ZERO
9D00DC2C  26110002   ADDIU S1, S0, 2
9D00DC30  005E1021   ADDU V0, V0, FP
9D00DC34  3055FFFF   ANDI S5, V0, -1
9D00DC38  0F402804   JAL mem_readbyte
9D00DC3C  02A02021   ADDU A0, S5, ZERO
9D00DC40  30570001   ANDI S7, V0, 1
9D00DC44  7C523840   EXT S2, V0, 1, 8
9D00DC48  02A02021   ADDU A0, S5, ZERO
9D00DC4C  0F40283A   JAL mem_writebyte
9D00DC50  02402821   ADDU A1, S2, ZERO
9D00DC54  02549026   XOR S2, S2, S4
9D00DC58  325200FF   ANDI S2, S2, 255
9D00DC5C  8F828058   LW V0, -32680(GP)
9D00DC60  2442FFF9   ADDIU V0, V0, -7
9D00DC64  AF828058   SW V0, -32680(GP)
9D00DC68  26638FD8   ADDIU V1, S3, -28712
9D00DC6C  8C640054   LW A0, 84(V1)
9D00DC70  24840007   ADDIU A0, A0, 7
9D00DC7C  0240A021   ADDU S4, S2, ZERO
9D00DC80  0B404D98   J .L45
9D00DC84  0240A821   ADDU S5, S2, ZERO
9D00DCB8  0240A021   ADDU S4, S2, ZERO
1828:                         OPCODE_END
9D00DC74  1C400004   BGTZ V0, 0x9D00DC88
9D00DC78  AC640054   SW A0, 84(V1)
9D00DC88  26100003   ADDIU S0, S0, 3
9D00DCA8  90420000   LBU V0, 0(V0)
9D00DCAC  00021080   SLL V0, V0, 2
9D00DCB0  00561021   ADDU V0, V0, S6
9D00DCB4  8C420000   LW V0, 0(V0)
9D00DCBC  0B402953   J 0x9D00A54C
9D00DCC0  0240A821   ADDU S5, S2, ZERO
1829:                
1830:                      OPCODE_BEGIN(60)  /* RTS */
1831:                         RTS();
9D00DCC4  8F828050   LW V0, -32688(GP)
9D00DCC8  8FA40018   LW A0, 24(SP)
9D00DCCC  24830001   ADDIU V1, A0, 1
9D00DCD0  306300FF   ANDI V1, V1, 255
9D00DCD4  00431821   ADDU V1, V0, V1
9D00DCD8  90630000   LBU V1, 0(V1)
9D00DCDC  24840002   ADDIU A0, A0, 2
9D00DCE0  308400FF   ANDI A0, A0, 255
9D00DCE4  AFA40018   SW A0, 24(SP)
9D00DCE8  00441021   ADDU V0, V0, A0
9D00DCEC  90500000   LBU S0, 0(V0)
9D00DCF0  00108200   SLL S0, S0, 8
9D00DCF4  02038025   OR S0, S0, V1
9D00DCF8  26110001   ADDIU S1, S0, 1
9D00DCFC  8F828058   LW V0, -32680(GP)
9D00DD00  2442FFFA   ADDIU V0, V0, -6
9D00DD04  AF828058   SW V0, -32680(GP)
9D00DD08  26638FD8   ADDIU V1, S3, -28712
9D00DD0C  8C640054   LW A0, 84(V1)
9D00DD10  24840006   ADDIU A0, A0, 6
1832:                         OPCODE_END
9D00DD14  18401652   BLEZ V0, .L45
9D00DD18  AC640054   SW A0, 84(V1)
9D00DD1C  26100002   ADDIU S0, S0, 2
9D00DD3C  90420000   LBU V0, 0(V0)
9D00DD40  00021080   SLL V0, V0, 2
9D00DD44  00561021   ADDU V0, V0, S6
9D00DD48  0B402953   J 0x9D00A54C
9D00DD4C  8C420000   LW V0, 0(V0)
1833:                
1834:                      OPCODE_BEGIN(61)  /* ADC ($nn,X) */
1835:                         ADC(6, INDIR_X_BYTE);
9D00DD50  26110001   ADDIU S1, S0, 1
9D00DD70  90420000   LBU V0, 0(V0)
9D00DD74  03C21021   ADDU V0, FP, V0
9D00DD90  0F402804   JAL mem_readbyte
9D00DD94  308400FF   ANDI A0, A0, 255
9D00DD98  02829021   ADDU S2, S4, V0
9D00DD9C  02579021   ADDU S2, S2, S7
9D00DDA0  7E570200   EXT S7, S2, 8, 1
9D00DDA4  325200FF   ANDI S2, S2, 255
9D00DDA8  00541026   XOR V0, V0, S4
9D00DDAC  00021027   NOR V0, ZERO, V0
9D00DDB0  7C023004   INS V0, ZERO, 0, 7
9D00DDB4  0254A026   XOR S4, S2, S4
9D00DDB8  00541024   AND V0, V0, S4
9D00DDBC  304200FF   ANDI V0, V0, 255
9D00DDC0  AFA20014   SW V0, 20(SP)
9D00DDC4  8F828058   LW V0, -32680(GP)
9D00DDC8  2442FFFA   ADDIU V0, V0, -6
9D00DDCC  AF828058   SW V0, -32680(GP)
9D00DDD0  8EA30054   LW V1, 84(S5)
9D00DDD4  24630006   ADDIU V1, V1, 6
9D00DDE0  0240A021   ADDU S4, S2, ZERO
9D00DDE4  0B404D98   J .L45
9D00DDE8  0240A821   ADDU S5, S2, ZERO
9D00DE1C  0240A021   ADDU S4, S2, ZERO
1836:                         OPCODE_END
9D00DDD8  1C400004   BGTZ V0, 0x9D00DDEC
9D00DDDC  AEA30054   SW V1, 84(S5)
9D00DDEC  26100002   ADDIU S0, S0, 2
9D00DE0C  90420000   LBU V0, 0(V0)
9D00DE10  00021080   SLL V0, V0, 2
9D00DE14  00561021   ADDU V0, V0, S6
9D00DE18  8C420000   LW V0, 0(V0)
9D00DE20  0B402953   J 0x9D00A54C
9D00DE24  0240A821   ADDU S5, S2, ZERO
1837:                
1838:                      OPCODE_BEGIN(63)  /* RRA ($nn,X) */
1839:                         RRA(8, INDIR_X, mem_writebyte, addr);
9D00DE28  26110001   ADDIU S1, S0, 1
9D00DE48  90420000   LBU V0, 0(V0)
9D00DE4C  03C21021   ADDU V0, FP, V0
9D00DE6C  0F402804   JAL mem_readbyte
9D00DE70  02402021   ADDU A0, S2, ZERO
9D00DE74  AFA2002C   SW V0, 44(SP)
9D00DE78  7C423840   EXT V0, V0, 1, 8
9D00DE7C  0017B9C0   SLL S7, S7, 7
9D00DE80  00571025   OR V0, V0, S7
9D00DE84  304200FF   ANDI V0, V0, 255
9D00DE88  AFA20014   SW V0, 20(SP)
9D00DE8C  02402021   ADDU A0, S2, ZERO
9D00DE90  0F40283A   JAL mem_writebyte
9D00DE94  00402821   ADDU A1, V0, ZERO
9D00DE98  8FA50014   LW A1, 20(SP)
9D00DE9C  02859021   ADDU S2, S4, A1
9D00DEA0  8FA6002C   LW A2, 44(SP)
9D00DEA4  30C20001   ANDI V0, A2, 1
9D00DEA8  02429021   ADDU S2, S2, V0
9D00DEAC  7E570200   EXT S7, S2, 8, 1
9D00DEB0  325200FF   ANDI S2, S2, 255
9D00DEB4  00B41026   XOR V0, A1, S4
9D00DEB8  00021027   NOR V0, ZERO, V0
9D00DEBC  7C023004   INS V0, ZERO, 0, 7
9D00DEC0  0254A026   XOR S4, S2, S4
9D00DEC4  00541024   AND V0, V0, S4
9D00DEC8  304200FF   ANDI V0, V0, 255
9D00DECC  AFA20014   SW V0, 20(SP)
9D00DED0  8F828058   LW V0, -32680(GP)
9D00DED4  2442FFF8   ADDIU V0, V0, -8
9D00DED8  AF828058   SW V0, -32680(GP)
9D00DEDC  8EA30054   LW V1, 84(S5)
9D00DEE0  24630008   ADDIU V1, V1, 8
9D00DEEC  0240A021   ADDU S4, S2, ZERO
9D00DEF0  0B404D98   J .L45
9D00DEF4  0240A821   ADDU S5, S2, ZERO
9D00DF28  0240A021   ADDU S4, S2, ZERO
1840:                         OPCODE_END
9D00DEE4  1C400004   BGTZ V0, 0x9D00DEF8
9D00DEE8  AEA30054   SW V1, 84(S5)
9D00DEF8  26100002   ADDIU S0, S0, 2
9D00DF18  90420000   LBU V0, 0(V0)
9D00DF1C  00021080   SLL V0, V0, 2
9D00DF20  00561021   ADDU V0, V0, S6
9D00DF24  8C420000   LW V0, 0(V0)
9D00DF2C  0B402953   J 0x9D00A54C
9D00DF30  0240A821   ADDU S5, S2, ZERO
1841:                
1842:                      OPCODE_BEGIN(65)  /* ADC $nn */
1843:                         ADC(3, ZERO_PAGE_BYTE);
9D00DF34  26110001   ADDIU S1, S0, 1
9D00DF54  90630000   LBU V1, 0(V1)
9D00DF58  8F848054   LW A0, -32684(GP)
9D00DF5C  00831821   ADDU V1, A0, V1
9D00DF60  90630000   LBU V1, 0(V1)
9D00DF64  02839021   ADDU S2, S4, V1
9D00DF68  02579021   ADDU S2, S2, S7
9D00DF6C  7E570200   EXT S7, S2, 8, 1
9D00DF70  325200FF   ANDI S2, S2, 255
9D00DF74  00741826   XOR V1, V1, S4
9D00DF78  00031827   NOR V1, ZERO, V1
9D00DF7C  7C033004   INS V1, ZERO, 0, 7
9D00DF80  0254A026   XOR S4, S2, S4
9D00DF84  00741824   AND V1, V1, S4
9D00DF88  306300FF   ANDI V1, V1, 255
9D00DF8C  AFA30014   SW V1, 20(SP)
9D00DF90  8F838058   LW V1, -32680(GP)
9D00DF94  2463FFFD   ADDIU V1, V1, -3
9D00DF98  AF838058   SW V1, -32680(GP)
9D00DF9C  8C440054   LW A0, 84(V0)
9D00DFA0  24840003   ADDIU A0, A0, 3
9D00DFAC  0240A021   ADDU S4, S2, ZERO
9D00DFB0  0B404D98   J .L45
9D00DFB4  0240A821   ADDU S5, S2, ZERO
9D00DFE8  0240A021   ADDU S4, S2, ZERO
1844:                         OPCODE_END
9D00DFA4  1C600004   BGTZ V1, 0x9D00DFB8
9D00DFA8  AC440054   SW A0, 84(V0)
9D00DFB8  26100002   ADDIU S0, S0, 2
9D00DFD8  90420000   LBU V0, 0(V0)
9D00DFDC  00021080   SLL V0, V0, 2
9D00DFE0  00561021   ADDU V0, V0, S6
9D00DFE4  8C420000   LW V0, 0(V0)
9D00DFEC  0B402953   J 0x9D00A54C
9D00DFF0  0240A821   ADDU S5, S2, ZERO
1845:                
1846:                      OPCODE_BEGIN(66)  /* ROR $nn */
1847:                         ROR(5, ZERO_PAGE, ZP_WRITEBYTE, baddr);
9D00DFF4  26110001   ADDIU S1, S0, 1
9D00E014  90630000   LBU V1, 0(V1)
9D00E018  8F848054   LW A0, -32684(GP)
9D00E01C  00831821   ADDU V1, A0, V1
9D00E020  90640000   LBU A0, 0(V1)
9D00E024  001791C0   SLL S2, S7, 7
9D00E028  325200FF   ANDI S2, S2, 255
9D00E02C  30970001   ANDI S7, A0, 1
9D00E030  00042042   SRL A0, A0, 1
9D00E034  02449025   OR S2, S2, A0
9D00E038  A0720000   SB S2, 0(V1)
9D00E03C  8F838058   LW V1, -32680(GP)
9D00E040  2463FFFB   ADDIU V1, V1, -5
9D00E044  AF838058   SW V1, -32680(GP)
9D00E048  8C440054   LW A0, 84(V0)
9D00E04C  24840005   ADDIU A0, A0, 5
9D00E058  0B404D98   J .L45
9D00E05C  0240A821   ADDU S5, S2, ZERO
1848:                         OPCODE_END
9D00E050  1C600003   BGTZ V1, 0x9D00E060
9D00E054  AC440054   SW A0, 84(V0)
9D00E060  26100002   ADDIU S0, S0, 2
9D00E080  90420000   LBU V0, 0(V0)
9D00E084  00021080   SLL V0, V0, 2
9D00E088  00561021   ADDU V0, V0, S6
9D00E08C  8C420000   LW V0, 0(V0)
9D00E090  0B402953   J 0x9D00A54C
9D00E094  0240A821   ADDU S5, S2, ZERO
1849:                
1850:                      OPCODE_BEGIN(67)  /* RRA $nn */
1851:                         RRA(5, ZERO_PAGE, ZP_WRITEBYTE, baddr);
9D00E098  26110001   ADDIU S1, S0, 1
9D00E0B8  90630000   LBU V1, 0(V1)
9D00E0BC  8F858054   LW A1, -32684(GP)
9D00E0C0  00A32821   ADDU A1, A1, V1
9D00E0C4  90A40000   LBU A0, 0(A1)
9D00E0C8  00041842   SRL V1, A0, 1
9D00E0CC  0017B9C0   SLL S7, S7, 7
9D00E0D0  00771825   OR V1, V1, S7
9D00E0D4  306300FF   ANDI V1, V1, 255
9D00E0D8  A0A30000   SB V1, 0(A1)
9D00E0DC  02839021   ADDU S2, S4, V1
9D00E0E0  30840001   ANDI A0, A0, 1
9D00E0E4  02449021   ADDU S2, S2, A0
9D00E0E8  7E570200   EXT S7, S2, 8, 1
9D00E0EC  325200FF   ANDI S2, S2, 255
9D00E0F0  00741826   XOR V1, V1, S4
9D00E0F4  00031827   NOR V1, ZERO, V1
9D00E0F8  7C033004   INS V1, ZERO, 0, 7
9D00E0FC  0254A026   XOR S4, S2, S4
9D00E100  00741824   AND V1, V1, S4
9D00E104  306300FF   ANDI V1, V1, 255
9D00E108  AFA30014   SW V1, 20(SP)
9D00E10C  8F838058   LW V1, -32680(GP)
9D00E110  2463FFFB   ADDIU V1, V1, -5
9D00E114  AF838058   SW V1, -32680(GP)
9D00E118  8C440054   LW A0, 84(V0)
9D00E11C  24840005   ADDIU A0, A0, 5
9D00E128  0240A021   ADDU S4, S2, ZERO
9D00E12C  0B404D98   J .L45
9D00E130  0240A821   ADDU S5, S2, ZERO
9D00E164  0240A021   ADDU S4, S2, ZERO
1852:                         OPCODE_END
9D00E120  1C600004   BGTZ V1, 0x9D00E134
9D00E124  AC440054   SW A0, 84(V0)
9D00E134  26100002   ADDIU S0, S0, 2
9D00E154  90420000   LBU V0, 0(V0)
9D00E158  00021080   SLL V0, V0, 2
9D00E15C  00561021   ADDU V0, V0, S6
9D00E160  8C420000   LW V0, 0(V0)
9D00E168  0B402953   J 0x9D00A54C
9D00E16C  0240A821   ADDU S5, S2, ZERO
1853:                
1854:                      OPCODE_BEGIN(68)  /* PLA */
1855:                         PLA();
9D00E170  8FA70018   LW A3, 24(SP)
9D00E174  24E20001   ADDIU V0, A3, 1
9D00E178  304200FF   ANDI V0, V0, 255
9D00E17C  AFA20018   SW V0, 24(SP)
9D00E180  8F828050   LW V0, -32688(GP)
9D00E184  8FA30018   LW V1, 24(SP)
9D00E188  00431021   ADDU V0, V0, V1
9D00E18C  90520000   LBU S2, 0(V0)
9D00E190  8F828058   LW V0, -32680(GP)
9D00E194  2442FFFC   ADDIU V0, V0, -4
9D00E198  AF828058   SW V0, -32680(GP)
9D00E19C  26638FD8   ADDIU V1, S3, -28712
9D00E1A0  8C640054   LW A0, 84(V1)
9D00E1A4  24840004   ADDIU A0, A0, 4
9D00E1B0  0240A021   ADDU S4, S2, ZERO
9D00E1B8  0B404D98   J .L45
9D00E1BC  0240A821   ADDU S5, S2, ZERO
9D00E1EC  0240A021   ADDU S4, S2, ZERO
1856:                         OPCODE_END
9D00E1A8  1C400005   BGTZ V0, .LBB1060
9D00E1AC  AC640054   SW A0, 84(V1)
9D00E1B4  02008821   ADDU S1, S0, ZERO
9D00E1DC  90420000   LBU V0, 0(V0)
9D00E1E0  00021080   SLL V0, V0, 2
9D00E1E4  00561021   ADDU V0, V0, S6
9D00E1E8  8C420000   LW V0, 0(V0)
9D00E1F0  26100001   ADDIU S0, S0, 1
9D00E1F4  0B402953   J 0x9D00A54C
9D00E1F8  0240A821   ADDU S5, S2, ZERO
1857:                
1858:                      OPCODE_BEGIN(69)  /* ADC #$nn */
1859:                         ADC(2, IMMEDIATE_BYTE);
9D00E1FC  26110001   ADDIU S1, S0, 1
9D00E220  02839021   ADDU S2, S4, V1
9D00E224  02579021   ADDU S2, S2, S7
9D00E228  7E570200   EXT S7, S2, 8, 1
9D00E22C  325200FF   ANDI S2, S2, 255
9D00E230  00741826   XOR V1, V1, S4
9D00E234  00031827   NOR V1, ZERO, V1
9D00E238  7C033004   INS V1, ZERO, 0, 7
9D00E23C  0254A026   XOR S4, S2, S4
9D00E240  00741824   AND V1, V1, S4
9D00E244  306300FF   ANDI V1, V1, 255
9D00E248  AFA30014   SW V1, 20(SP)
9D00E24C  8F838058   LW V1, -32680(GP)
9D00E250  2463FFFE   ADDIU V1, V1, -2
9D00E254  AF838058   SW V1, -32680(GP)
9D00E258  8C440054   LW A0, 84(V0)
9D00E25C  24840002   ADDIU A0, A0, 2
9D00E268  0240A021   ADDU S4, S2, ZERO
9D00E26C  0B404D98   J .L45
9D00E270  0240A821   ADDU S5, S2, ZERO
9D00E2A4  0240A021   ADDU S4, S2, ZERO
1860:                         OPCODE_END
9D00E260  1C600004   BGTZ V1, 0x9D00E274
9D00E264  AC440054   SW A0, 84(V0)
9D00E274  26100002   ADDIU S0, S0, 2
9D00E294  90420000   LBU V0, 0(V0)
9D00E298  00021080   SLL V0, V0, 2
9D00E29C  00561021   ADDU V0, V0, S6
9D00E2A0  8C420000   LW V0, 0(V0)
9D00E2A8  0B402953   J 0x9D00A54C
9D00E2AC  0240A821   ADDU S5, S2, ZERO
1861:                
1862:                      OPCODE_BEGIN(6A)  /* ROR A */
1863:                         ROR_A();
9D00E2B0  001711C0   SLL V0, S7, 7
9D00E2B4  304200FF   ANDI V0, V0, 255
9D00E2B8  32970001   ANDI S7, S4, 1
9D00E2BC  7E923840   EXT S2, S4, 1, 8
9D00E2C0  02429025   OR S2, S2, V0
9D00E2C4  8F828058   LW V0, -32680(GP)
9D00E2C8  2442FFFE   ADDIU V0, V0, -2
9D00E2CC  AF828058   SW V0, -32680(GP)
9D00E2D0  26638FD8   ADDIU V1, S3, -28712
9D00E2D4  8C640054   LW A0, 84(V1)
9D00E2D8  24840002   ADDIU A0, A0, 2
9D00E2E4  0240A021   ADDU S4, S2, ZERO
9D00E2EC  0B404D98   J .L45
9D00E2F0  0240A821   ADDU S5, S2, ZERO
9D00E320  0240A021   ADDU S4, S2, ZERO
1864:                         OPCODE_END
9D00E2DC  1C400005   BGTZ V0, .LBB1066
9D00E2E0  AC640054   SW A0, 84(V1)
9D00E2E8  02008821   ADDU S1, S0, ZERO
9D00E310  90420000   LBU V0, 0(V0)
9D00E314  00021080   SLL V0, V0, 2
9D00E318  00561021   ADDU V0, V0, S6
9D00E31C  8C420000   LW V0, 0(V0)
9D00E324  26100001   ADDIU S0, S0, 1
9D00E328  0B402953   J 0x9D00A54C
9D00E32C  0240A821   ADDU S5, S2, ZERO
1865:                
1866:                      OPCODE_BEGIN(6B)  /* ARR #$nn */
1867:                         ARR(2, IMMEDIATE_BYTE);
9D00E330  26110001   ADDIU S1, S0, 1
9D00E350  90720000   LBU S2, 0(V1)
9D00E354  02929024   AND S2, S4, S2
9D00E358  00129042   SRL S2, S2, 1
9D00E35C  0017B9C0   SLL S7, S7, 7
9D00E360  02579025   OR S2, S2, S7
9D00E364  325200FF   ANDI S2, S2, 255
9D00E368  7E570180   EXT S7, S2, 6, 1
9D00E36C  00122142   SRL A0, S2, 5
9D00E370  00121982   SRL V1, S2, 6
9D00E374  00831826   XOR V1, A0, V1
9D00E378  30630001   ANDI V1, V1, 1
9D00E37C  AFA30014   SW V1, 20(SP)
9D00E380  8F838058   LW V1, -32680(GP)
9D00E384  2463FFFE   ADDIU V1, V1, -2
9D00E388  AF838058   SW V1, -32680(GP)
9D00E38C  8C440054   LW A0, 84(V0)
9D00E390  24840002   ADDIU A0, A0, 2
9D00E39C  0240A021   ADDU S4, S2, ZERO
9D00E3A0  0B404D98   J .L45
9D00E3A4  0240A821   ADDU S5, S2, ZERO
9D00E3D8  0240A021   ADDU S4, S2, ZERO
1868:                         OPCODE_END
9D00E394  1C600004   BGTZ V1, 0x9D00E3A8
9D00E398  AC440054   SW A0, 84(V0)
9D00E3A8  26100002   ADDIU S0, S0, 2
9D00E3C8  90420000   LBU V0, 0(V0)
9D00E3CC  00021080   SLL V0, V0, 2
9D00E3D0  00561021   ADDU V0, V0, S6
9D00E3D4  8C420000   LW V0, 0(V0)
9D00E3DC  0B402953   J 0x9D00A54C
9D00E3E0  0240A821   ADDU S5, S2, ZERO
1869:                
1870:                      OPCODE_BEGIN(6C)  /* JMP ($nnnn) */
1871:                         JMP_INDIRECT();
9D00E3E4  0F402863   JAL bank_readword
9D00E3E8  02002021   ADDU A0, S0, ZERO
9D00E3EC  304300FF   ANDI V1, V0, 255
9D00E3F0  240400FF   ADDIU A0, ZERO, 255
9D00E3F4  14640012   BNE V1, A0, 0x9D00E440
9D00E3F8  7C451B00   EXT A1, V0, 12, 4
9D00E414  90910000   LBU S1, 0(A0)
9D00E418  00118A00   SLL S1, S1, 8
9D00E434  90420000   LBU V0, 0(V0)
9D00E438  0B403913   J 0x9D00E44C
9D00E43C  02228825   OR S1, S1, V0
9D00E440  0F402863   JAL bank_readword
9D00E444  00402021   ADDU A0, V0, ZERO
9D00E448  00408821   ADDU S1, V0, ZERO
9D00E44C  8F828058   LW V0, -32680(GP)
9D00E450  2442FFFB   ADDIU V0, V0, -5
9D00E454  AF828058   SW V0, -32680(GP)
9D00E458  26638FD8   ADDIU V1, S3, -28712
9D00E45C  8C640054   LW A0, 84(V1)
9D00E460  24840005   ADDIU A0, A0, 5
1872:                         OPCODE_END
9D00E464  1840147E   BLEZ V0, .L45
9D00E468  AC640054   SW A0, 84(V1)
9D00E46C  26300001   ADDIU S0, S1, 1
9D00E48C  90420000   LBU V0, 0(V0)
9D00E490  00021080   SLL V0, V0, 2
9D00E494  00561021   ADDU V0, V0, S6
9D00E498  0B402953   J 0x9D00A54C
9D00E49C  8C420000   LW V0, 0(V0)
1873:                
1874:                      OPCODE_BEGIN(6D)  /* ADC $nnnn */
1875:                         ADC(4, ABSOLUTE_BYTE);
9D00E4A0  0F402863   JAL bank_readword
9D00E4A4  02002021   ADDU A0, S0, ZERO
9D00E4A8  26110002   ADDIU S1, S0, 2
9D00E4AC  0F402804   JAL mem_readbyte
9D00E4B0  00402021   ADDU A0, V0, ZERO
9D00E4B4  02829021   ADDU S2, S4, V0
9D00E4B8  02579021   ADDU S2, S2, S7
9D00E4BC  7E570200   EXT S7, S2, 8, 1
9D00E4C0  325200FF   ANDI S2, S2, 255
9D00E4C4  00541026   XOR V0, V0, S4
9D00E4C8  00021027   NOR V0, ZERO, V0
9D00E4CC  7C023004   INS V0, ZERO, 0, 7
9D00E4D0  0254A026   XOR S4, S2, S4
9D00E4D4  00541024   AND V0, V0, S4
9D00E4D8  304200FF   ANDI V0, V0, 255
9D00E4DC  AFA20014   SW V0, 20(SP)
9D00E4E0  8F828058   LW V0, -32680(GP)
9D00E4E4  2442FFFC   ADDIU V0, V0, -4
9D00E4E8  AF828058   SW V0, -32680(GP)
9D00E4EC  26638FD8   ADDIU V1, S3, -28712
9D00E4F0  8C640054   LW A0, 84(V1)
9D00E4F4  24840004   ADDIU A0, A0, 4
9D00E500  0240A021   ADDU S4, S2, ZERO
9D00E504  0B404D98   J .L45
9D00E508  0240A821   ADDU S5, S2, ZERO
9D00E53C  0240A021   ADDU S4, S2, ZERO
1876:                         OPCODE_END
9D00E4F8  1C400004   BGTZ V0, 0x9D00E50C
9D00E4FC  AC640054   SW A0, 84(V1)
9D00E50C  26100003   ADDIU S0, S0, 3
9D00E52C  90420000   LBU V0, 0(V0)
9D00E530  00021080   SLL V0, V0, 2
9D00E534  00561021   ADDU V0, V0, S6
9D00E538  8C420000   LW V0, 0(V0)
9D00E540  0B402953   J 0x9D00A54C
9D00E544  0240A821   ADDU S5, S2, ZERO
1877:                
1878:                      OPCODE_BEGIN(6E)  /* ROR $nnnn */
1879:                         ROR(6, ABSOLUTE, mem_writebyte, addr);
9D00E548  0F402863   JAL bank_readword
9D00E54C  02002021   ADDU A0, S0, ZERO
9D00E550  0040A821   ADDU S5, V0, ZERO
9D00E554  26110002   ADDIU S1, S0, 2
9D00E558  0F402804   JAL mem_readbyte
9D00E55C  00402021   ADDU A0, V0, ZERO
9D00E560  001719C0   SLL V1, S7, 7
9D00E564  306300FF   ANDI V1, V1, 255
9D00E568  30570001   ANDI S7, V0, 1
9D00E56C  7C423840   EXT V0, V0, 1, 8
9D00E570  00439025   OR S2, V0, V1
9D00E574  02A02021   ADDU A0, S5, ZERO
9D00E578  0F40283A   JAL mem_writebyte
9D00E57C  02402821   ADDU A1, S2, ZERO
9D00E580  8F828058   LW V0, -32680(GP)
9D00E584  2442FFFA   ADDIU V0, V0, -6
9D00E588  AF828058   SW V0, -32680(GP)
9D00E58C  26638FD8   ADDIU V1, S3, -28712
9D00E590  8C640054   LW A0, 84(V1)
9D00E594  24840006   ADDIU A0, A0, 6
9D00E5A0  0B404D98   J .L45
9D00E5A4  0240A821   ADDU S5, S2, ZERO
1880:                         OPCODE_END
9D00E598  1C400003   BGTZ V0, 0x9D00E5A8
9D00E59C  AC640054   SW A0, 84(V1)
9D00E5A8  26100003   ADDIU S0, S0, 3
9D00E5C8  90420000   LBU V0, 0(V0)
9D00E5CC  00021080   SLL V0, V0, 2
9D00E5D0  00561021   ADDU V0, V0, S6
9D00E5D4  8C420000   LW V0, 0(V0)
9D00E5D8  0B402953   J 0x9D00A54C
9D00E5DC  0240A821   ADDU S5, S2, ZERO
1881:                
1882:                      OPCODE_BEGIN(6F)  /* RRA $nnnn */
1883:                         RRA(6, ABSOLUTE, mem_writebyte, addr);
9D00E5E0  0F402863   JAL bank_readword
9D00E5E4  02002021   ADDU A0, S0, ZERO
9D00E5E8  00409021   ADDU S2, V0, ZERO
9D00E5EC  26110002   ADDIU S1, S0, 2
9D00E5F0  0F402804   JAL mem_readbyte
9D00E5F4  00402021   ADDU A0, V0, ZERO
9D00E5F8  AFA20014   SW V0, 20(SP)
9D00E5FC  7C553840   EXT S5, V0, 1, 8
9D00E600  0017B9C0   SLL S7, S7, 7
9D00E604  02B7A825   OR S5, S5, S7
9D00E608  32B500FF   ANDI S5, S5, 255
9D00E60C  02402021   ADDU A0, S2, ZERO
9D00E610  0F40283A   JAL mem_writebyte
9D00E614  02A02821   ADDU A1, S5, ZERO
9D00E618  02959021   ADDU S2, S4, S5
9D00E61C  8FA50014   LW A1, 20(SP)
9D00E620  30A20001   ANDI V0, A1, 1
9D00E624  02429021   ADDU S2, S2, V0
9D00E628  7E570200   EXT S7, S2, 8, 1
9D00E62C  325200FF   ANDI S2, S2, 255
9D00E630  02B41026   XOR V0, S5, S4
9D00E634  00021027   NOR V0, ZERO, V0
9D00E638  7C023004   INS V0, ZERO, 0, 7
9D00E63C  0254A026   XOR S4, S2, S4
9D00E640  00541024   AND V0, V0, S4
9D00E644  304200FF   ANDI V0, V0, 255
9D00E648  AFA20014   SW V0, 20(SP)
9D00E64C  8F828058   LW V0, -32680(GP)
9D00E650  2442FFFA   ADDIU V0, V0, -6
9D00E654  AF828058   SW V0, -32680(GP)
9D00E658  26638FD8   ADDIU V1, S3, -28712
9D00E65C  8C640054   LW A0, 84(V1)
9D00E660  24840006   ADDIU A0, A0, 6
9D00E66C  0240A021   ADDU S4, S2, ZERO
9D00E670  0B404D98   J .L45
9D00E674  0240A821   ADDU S5, S2, ZERO
9D00E6A8  0240A021   ADDU S4, S2, ZERO
1884:                         OPCODE_END
9D00E664  1C400004   BGTZ V0, 0x9D00E678
9D00E668  AC640054   SW A0, 84(V1)
9D00E678  26100003   ADDIU S0, S0, 3
9D00E698  90420000   LBU V0, 0(V0)
9D00E69C  00021080   SLL V0, V0, 2
9D00E6A0  00561021   ADDU V0, V0, S6
9D00E6A4  8C420000   LW V0, 0(V0)
9D00E6AC  0B402953   J 0x9D00A54C
9D00E6B0  0240A821   ADDU S5, S2, ZERO
1885:                
1886:                      OPCODE_BEGIN(70)  /* BVS $nnnn */
1887:                         BVS();
9D00E6B4  8FA60014   LW A2, 20(SP)
9D00E6B8  10C0001E   BEQ A2, ZERO, 0x9D00E734
9D00E6BC  26110001   ADDIU S1, S0, 1
9D00E6C0  26020001   ADDIU V0, S0, 1
9D00E6E0  80710000   LB S1, 0(V1)
9D00E6E4  304300FF   ANDI V1, V0, 255
9D00E6E8  02231821   ADDU V1, S1, V1
9D00E6EC  30630100   ANDI V1, V1, 256
9D00E6F0  10600008   BEQ V1, ZERO, 0x9D00E714
9D00E6F4  8F838058   LW V1, -32680(GP)
9D00E6F8  2463FFFF   ADDIU V1, V1, -1
9D00E6FC  AF838058   SW V1, -32680(GP)
9D00E700  26638FD8   ADDIU V1, S3, -28712
9D00E704  8C640054   LW A0, 84(V1)
9D00E708  24840001   ADDIU A0, A0, 1
9D00E70C  AC640054   SW A0, 84(V1)
9D00E710  8F838058   LW V1, -32680(GP)
9D00E714  2463FFFD   ADDIU V1, V1, -3
9D00E718  AF838058   SW V1, -32680(GP)
9D00E71C  26638FD8   ADDIU V1, S3, -28712
9D00E720  8C640054   LW A0, 84(V1)
9D00E724  24840003   ADDIU A0, A0, 3
9D00E728  AC640054   SW A0, 84(V1)
9D00E72C  0B4039D4   J 0x9D00E750
9D00E730  02228821   ADDU S1, S1, V0
9D00E734  8F828058   LW V0, -32680(GP)
9D00E738  2442FFFE   ADDIU V0, V0, -2
9D00E73C  AF828058   SW V0, -32680(GP)
9D00E740  26628FD8   ADDIU V0, S3, -28712
9D00E744  8C430054   LW V1, 84(V0)
9D00E748  24630002   ADDIU V1, V1, 2
9D00E74C  AC430054   SW V1, 84(V0)
1888:                         OPCODE_END
9D00E750  8F828058   LW V0, -32680(GP)
9D00E754  184013C2   BLEZ V0, .L45
9D00E758  26300001   ADDIU S0, S1, 1
9D00E778  90420000   LBU V0, 0(V0)
9D00E77C  00021080   SLL V0, V0, 2
9D00E780  00561021   ADDU V0, V0, S6
9D00E784  0B402953   J 0x9D00A54C
9D00E788  8C420000   LW V0, 0(V0)
1889:                
1890:                      OPCODE_BEGIN(71)  /* ADC ($nn),Y */
1891:                         ADC(5, INDIR_Y_BYTE_READ);
9D00E7C4  8FA70010   LW A3, 16(SP)
9D00E7C8  00872021   ADDU A0, A0, A3
9D00E7CC  3084FFFF   ANDI A0, A0, -1
9D00E7D0  308200FF   ANDI V0, A0, 255
9D00E7D4  0047102B   SLTU V0, V0, A3
9D00E7D8  10400008   BEQ V0, ZERO, 0x9D00E7FC
9D00E7DC  26110001   ADDIU S1, S0, 1
9D00E7E0  8F828058   LW V0, -32680(GP)
9D00E7E4  2442FFFF   ADDIU V0, V0, -1
9D00E7E8  AF828058   SW V0, -32680(GP)
9D00E7EC  26628FD8   ADDIU V0, S3, -28712
9D00E7F0  8C430054   LW V1, 84(V0)
9D00E7F4  24630001   ADDIU V1, V1, 1
9D00E7F8  AC430054   SW V1, 84(V0)
9D00E7FC  0F402804   JAL mem_readbyte
9D00E800  00000000   NOP
9D00E804  02829021   ADDU S2, S4, V0
9D00E808  02579021   ADDU S2, S2, S7
9D00E80C  7E570200   EXT S7, S2, 8, 1
9D00E810  325200FF   ANDI S2, S2, 255
9D00E814  00541026   XOR V0, V0, S4
9D00E818  00021027   NOR V0, ZERO, V0
9D00E81C  7C023004   INS V0, ZERO, 0, 7
9D00E820  0254A026   XOR S4, S2, S4
9D00E824  00541024   AND V0, V0, S4
9D00E828  304200FF   ANDI V0, V0, 255
9D00E82C  AFA20014   SW V0, 20(SP)
9D00E830  8F828058   LW V0, -32680(GP)
9D00E834  2442FFFB   ADDIU V0, V0, -5
9D00E838  AF828058   SW V0, -32680(GP)
9D00E83C  26638FD8   ADDIU V1, S3, -28712
9D00E840  8C640054   LW A0, 84(V1)
9D00E844  24840005   ADDIU A0, A0, 5
9D00E850  0240A021   ADDU S4, S2, ZERO
9D00E854  0B404D98   J .L45
9D00E858  0240A821   ADDU S5, S2, ZERO
9D00E88C  0240A021   ADDU S4, S2, ZERO
1892:                         OPCODE_END
9D00E848  1C400004   BGTZ V0, 0x9D00E85C
9D00E84C  AC640054   SW A0, 84(V1)
9D00E85C  26100002   ADDIU S0, S0, 2
9D00E87C  90420000   LBU V0, 0(V0)
9D00E880  00021080   SLL V0, V0, 2
9D00E884  00561021   ADDU V0, V0, S6
9D00E888  8C420000   LW V0, 0(V0)
9D00E890  0B402953   J 0x9D00A54C
9D00E894  0240A821   ADDU S5, S2, ZERO
1893:                
1894:                      OPCODE_BEGIN(73)  /* RRA ($nn),Y */
1895:                         RRA(8, INDIR_Y, mem_writebyte, addr);
9D00E898  26110001   ADDIU S1, S0, 1
9D00E8D4  8FA20010   LW V0, 16(SP)
9D00E8D8  02429021   ADDU S2, S2, V0
9D00E8DC  3252FFFF   ANDI S2, S2, -1
9D00E8E0  0F402804   JAL mem_readbyte
9D00E8E4  02402021   ADDU A0, S2, ZERO
9D00E8E8  AFA2002C   SW V0, 44(SP)
9D00E8EC  7C423840   EXT V0, V0, 1, 8
9D00E8F0  0017B9C0   SLL S7, S7, 7
9D00E8F4  00571025   OR V0, V0, S7
9D00E8F8  304200FF   ANDI V0, V0, 255
9D00E8FC  AFA20014   SW V0, 20(SP)
9D00E900  02402021   ADDU A0, S2, ZERO
9D00E904  0F40283A   JAL mem_writebyte
9D00E908  00402821   ADDU A1, V0, ZERO
9D00E90C  8FA30014   LW V1, 20(SP)
9D00E910  02839021   ADDU S2, S4, V1
9D00E914  8FA4002C   LW A0, 44(SP)
9D00E918  30820001   ANDI V0, A0, 1
9D00E91C  02429021   ADDU S2, S2, V0
9D00E920  7E570200   EXT S7, S2, 8, 1
9D00E924  325200FF   ANDI S2, S2, 255
9D00E928  00741026   XOR V0, V1, S4
9D00E92C  00021027   NOR V0, ZERO, V0
9D00E930  7C023004   INS V0, ZERO, 0, 7
9D00E934  0254A026   XOR S4, S2, S4
9D00E938  00541024   AND V0, V0, S4
9D00E93C  304200FF   ANDI V0, V0, 255
9D00E940  AFA20014   SW V0, 20(SP)
9D00E944  8F828058   LW V0, -32680(GP)
9D00E948  2442FFF8   ADDIU V0, V0, -8
9D00E94C  AF828058   SW V0, -32680(GP)
9D00E950  8EA30054   LW V1, 84(S5)
9D00E954  24630008   ADDIU V1, V1, 8
9D00E960  0240A021   ADDU S4, S2, ZERO
9D00E964  0B404D98   J .L45
9D00E968  0240A821   ADDU S5, S2, ZERO
9D00E99C  0240A021   ADDU S4, S2, ZERO
1896:                         OPCODE_END
9D00E958  1C400004   BGTZ V0, 0x9D00E96C
9D00E95C  AEA30054   SW V1, 84(S5)
9D00E96C  26100002   ADDIU S0, S0, 2
9D00E98C  90420000   LBU V0, 0(V0)
9D00E990  00021080   SLL V0, V0, 2
9D00E994  00561021   ADDU V0, V0, S6
9D00E998  8C420000   LW V0, 0(V0)
9D00E9A0  0B402953   J 0x9D00A54C
9D00E9A4  0240A821   ADDU S5, S2, ZERO
1897:                
1898:                      OPCODE_BEGIN(75)  /* ADC $nn,X */
1899:                         ADC(4, ZP_IND_X_BYTE);
9D00E9A8  26110001   ADDIU S1, S0, 1
9D00E9C8  90630000   LBU V1, 0(V1)
9D00E9CC  03C31821   ADDU V1, FP, V1
9D00E9D0  306300FF   ANDI V1, V1, 255
9D00E9D4  8F848054   LW A0, -32684(GP)
9D00E9D8  00831821   ADDU V1, A0, V1
9D00E9DC  90630000   LBU V1, 0(V1)
9D00E9E0  02839021   ADDU S2, S4, V1
9D00E9E4  02579021   ADDU S2, S2, S7
9D00E9E8  7E570200   EXT S7, S2, 8, 1
9D00E9EC  325200FF   ANDI S2, S2, 255
9D00E9F0  00741826   XOR V1, V1, S4
9D00E9F4  00031827   NOR V1, ZERO, V1
9D00E9F8  7C033004   INS V1, ZERO, 0, 7
9D00E9FC  0254A026   XOR S4, S2, S4
9D00EA00  00741824   AND V1, V1, S4
9D00EA04  306300FF   ANDI V1, V1, 255
9D00EA08  AFA30014   SW V1, 20(SP)
9D00EA0C  8F838058   LW V1, -32680(GP)
9D00EA10  2463FFFC   ADDIU V1, V1, -4
9D00EA14  AF838058   SW V1, -32680(GP)
9D00EA18  8C440054   LW A0, 84(V0)
9D00EA1C  24840004   ADDIU A0, A0, 4
9D00EA28  0240A021   ADDU S4, S2, ZERO
9D00EA2C  0B404D98   J .L45
9D00EA30  0240A821   ADDU S5, S2, ZERO
9D00EA64  0240A021   ADDU S4, S2, ZERO
1900:                         OPCODE_END
9D00EA20  1C600004   BGTZ V1, 0x9D00EA34
9D00EA24  AC440054   SW A0, 84(V0)
9D00EA34  26100002   ADDIU S0, S0, 2
9D00EA54  90420000   LBU V0, 0(V0)
9D00EA58  00021080   SLL V0, V0, 2
9D00EA5C  00561021   ADDU V0, V0, S6
9D00EA60  8C420000   LW V0, 0(V0)
9D00EA68  0B402953   J 0x9D00A54C
9D00EA6C  0240A821   ADDU S5, S2, ZERO
1901:                
1902:                      OPCODE_BEGIN(76)  /* ROR $nn,X */
1903:                         ROR(6, ZP_IND_X, ZP_WRITEBYTE, baddr);
9D00EA70  26110001   ADDIU S1, S0, 1
9D00EA90  90630000   LBU V1, 0(V1)
9D00EA94  03C31821   ADDU V1, FP, V1
9D00EA98  306300FF   ANDI V1, V1, 255
9D00EA9C  8F848054   LW A0, -32684(GP)
9D00EAA0  00831821   ADDU V1, A0, V1
9D00EAA4  90640000   LBU A0, 0(V1)
9D00EAA8  001791C0   SLL S2, S7, 7
9D00EAAC  325200FF   ANDI S2, S2, 255
9D00EAB0  30970001   ANDI S7, A0, 1
9D00EAB4  00042042   SRL A0, A0, 1
9D00EAB8  02449025   OR S2, S2, A0
9D00EABC  A0720000   SB S2, 0(V1)
9D00EAC0  8F838058   LW V1, -32680(GP)
9D00EAC4  2463FFFA   ADDIU V1, V1, -6
9D00EAC8  AF838058   SW V1, -32680(GP)
9D00EACC  8C440054   LW A0, 84(V0)
9D00EAD0  24840006   ADDIU A0, A0, 6
9D00EADC  0B404D98   J .L45
9D00EAE0  0240A821   ADDU S5, S2, ZERO
1904:                         OPCODE_END
9D00EAD4  1C600003   BGTZ V1, 0x9D00EAE4
9D00EAD8  AC440054   SW A0, 84(V0)
9D00EAE4  26100002   ADDIU S0, S0, 2
9D00EB04  90420000   LBU V0, 0(V0)
9D00EB08  00021080   SLL V0, V0, 2
9D00EB0C  00561021   ADDU V0, V0, S6
9D00EB10  8C420000   LW V0, 0(V0)
9D00EB14  0B402953   J 0x9D00A54C
9D00EB18  0240A821   ADDU S5, S2, ZERO
1905:                
1906:                      OPCODE_BEGIN(77)  /* RRA $nn,X */
1907:                         RRA(6, ZP_IND_X, ZP_WRITEBYTE, baddr);
9D00EB1C  26110001   ADDIU S1, S0, 1
9D00EB3C  90630000   LBU V1, 0(V1)
9D00EB40  03C31821   ADDU V1, FP, V1
9D00EB44  306300FF   ANDI V1, V1, 255
9D00EB48  8F858054   LW A1, -32684(GP)
9D00EB4C  00A32821   ADDU A1, A1, V1
9D00EB50  90A40000   LBU A0, 0(A1)
9D00EB54  00041842   SRL V1, A0, 1
9D00EB58  0017B9C0   SLL S7, S7, 7
9D00EB5C  00771825   OR V1, V1, S7
9D00EB60  306300FF   ANDI V1, V1, 255
9D00EB64  A0A30000   SB V1, 0(A1)
9D00EB68  02839021   ADDU S2, S4, V1
9D00EB6C  30840001   ANDI A0, A0, 1
9D00EB70  02449021   ADDU S2, S2, A0
9D00EB74  7E570200   EXT S7, S2, 8, 1
9D00EB78  325200FF   ANDI S2, S2, 255
9D00EB7C  00741826   XOR V1, V1, S4
9D00EB80  00031827   NOR V1, ZERO, V1
9D00EB84  7C033004   INS V1, ZERO, 0, 7
9D00EB88  0254A026   XOR S4, S2, S4
9D00EB8C  00741824   AND V1, V1, S4
9D00EB90  306300FF   ANDI V1, V1, 255
9D00EB94  AFA30014   SW V1, 20(SP)
9D00EB98  8F838058   LW V1, -32680(GP)
9D00EB9C  2463FFFA   ADDIU V1, V1, -6
9D00EBA0  AF838058   SW V1, -32680(GP)
9D00EBA4  8C440054   LW A0, 84(V0)
9D00EBA8  24840006   ADDIU A0, A0, 6
9D00EBB4  0240A021   ADDU S4, S2, ZERO
9D00EBB8  0B404D98   J .L45
9D00EBBC  0240A821   ADDU S5, S2, ZERO
9D00EBF0  0240A021   ADDU S4, S2, ZERO
1908:                         OPCODE_END
9D00EBAC  1C600004   BGTZ V1, 0x9D00EBC0
9D00EBB0  AC440054   SW A0, 84(V0)
9D00EBC0  26100002   ADDIU S0, S0, 2
9D00EBE0  90420000   LBU V0, 0(V0)
9D00EBE4  00021080   SLL V0, V0, 2
9D00EBE8  00561021   ADDU V0, V0, S6
9D00EBEC  8C420000   LW V0, 0(V0)
9D00EBF4  0B402953   J 0x9D00A54C
9D00EBF8  0240A821   ADDU S5, S2, ZERO
1909:                
1910:                      OPCODE_BEGIN(78)  /* SEI */
1911:                         SEI();
9D00EBFC  8F828058   LW V0, -32680(GP)
9D00EC00  2442FFFE   ADDIU V0, V0, -2
9D00EC04  AF828058   SW V0, -32680(GP)
9D00EC08  26638FD8   ADDIU V1, S3, -28712
9D00EC0C  8C640054   LW A0, 84(V1)
9D00EC10  24840002   ADDIU A0, A0, 2
9D00EC20  24050001   ADDIU A1, ZERO, 1
9D00EC24  0B404D98   J .L45
9D00EC28  AFA5001C   SW A1, 28(SP)
9D00EC5C  24060001   ADDIU A2, ZERO, 1
1912:                         OPCODE_END
9D00EC14  1C400005   BGTZ V0, .LBB1112
9D00EC18  AC640054   SW A0, 84(V1)
9D00EC1C  02008821   ADDU S1, S0, ZERO
9D00EC48  90420000   LBU V0, 0(V0)
9D00EC4C  00021080   SLL V0, V0, 2
9D00EC50  00561021   ADDU V0, V0, S6
9D00EC54  8C420000   LW V0, 0(V0)
9D00EC58  26100001   ADDIU S0, S0, 1
9D00EC60  0B402953   J 0x9D00A54C
9D00EC64  AFA6001C   SW A2, 28(SP)
1913:                
1914:                      OPCODE_BEGIN(79)  /* ADC $nnnn,Y */
1915:                         ADC(4, ABS_IND_Y_BYTE_READ);
9D00EC68  0F402863   JAL bank_readword
9D00EC6C  02002021   ADDU A0, S0, ZERO
9D00EC70  8FA70010   LW A3, 16(SP)
9D00EC74  00471021   ADDU V0, V0, A3
9D00EC78  3044FFFF   ANDI A0, V0, -1
9D00EC7C  308200FF   ANDI V0, A0, 255
9D00EC80  0047102B   SLTU V0, V0, A3
9D00EC84  10400008   BEQ V0, ZERO, 0x9D00ECA8
9D00EC88  26110002   ADDIU S1, S0, 2
9D00EC8C  8F828058   LW V0, -32680(GP)
9D00EC90  2442FFFF   ADDIU V0, V0, -1
9D00EC94  AF828058   SW V0, -32680(GP)
9D00EC98  26628FD8   ADDIU V0, S3, -28712
9D00EC9C  8C430054   LW V1, 84(V0)
9D00ECA0  24630001   ADDIU V1, V1, 1
9D00ECA4  AC430054   SW V1, 84(V0)
9D00ECA8  0F402804   JAL mem_readbyte
9D00ECAC  00000000   NOP
9D00ECB0  02829021   ADDU S2, S4, V0
9D00ECB4  02579021   ADDU S2, S2, S7
9D00ECB8  7E570200   EXT S7, S2, 8, 1
9D00ECBC  325200FF   ANDI S2, S2, 255
9D00ECC0  00541026   XOR V0, V0, S4
9D00ECC4  00021027   NOR V0, ZERO, V0
9D00ECC8  7C023004   INS V0, ZERO, 0, 7
9D00ECCC  0254A026   XOR S4, S2, S4
9D00ECD0  00541024   AND V0, V0, S4
9D00ECD4  304200FF   ANDI V0, V0, 255
9D00ECD8  AFA20014   SW V0, 20(SP)
9D00ECDC  8F828058   LW V0, -32680(GP)
9D00ECE0  2442FFFC   ADDIU V0, V0, -4
9D00ECE4  AF828058   SW V0, -32680(GP)
9D00ECE8  26638FD8   ADDIU V1, S3, -28712
9D00ECEC  8C640054   LW A0, 84(V1)
9D00ECF0  24840004   ADDIU A0, A0, 4
9D00ECFC  0240A021   ADDU S4, S2, ZERO
9D00ED00  0B404D98   J .L45
9D00ED04  0240A821   ADDU S5, S2, ZERO
9D00ED38  0240A021   ADDU S4, S2, ZERO
1916:                         OPCODE_END
9D00ECF4  1C400004   BGTZ V0, 0x9D00ED08
9D00ECF8  AC640054   SW A0, 84(V1)
9D00ED08  26100003   ADDIU S0, S0, 3
9D00ED28  90420000   LBU V0, 0(V0)
9D00ED2C  00021080   SLL V0, V0, 2
9D00ED30  00561021   ADDU V0, V0, S6
9D00ED34  8C420000   LW V0, 0(V0)
9D00ED3C  0B402953   J 0x9D00A54C
9D00ED40  0240A821   ADDU S5, S2, ZERO
1917:                
1918:                      OPCODE_BEGIN(7B)  /* RRA $nnnn,Y */
1919:                         RRA(7, ABS_IND_Y, mem_writebyte, addr);
9D00ED44  0F402863   JAL bank_readword
9D00ED48  02002021   ADDU A0, S0, ZERO
9D00ED4C  26110002   ADDIU S1, S0, 2
9D00ED50  8FA30010   LW V1, 16(SP)
9D00ED54  00431021   ADDU V0, V0, V1
9D00ED58  3052FFFF   ANDI S2, V0, -1
9D00ED5C  0F402804   JAL mem_readbyte
9D00ED60  02402021   ADDU A0, S2, ZERO
9D00ED64  AFA20014   SW V0, 20(SP)
9D00ED68  7C553840   EXT S5, V0, 1, 8
9D00ED6C  0017B9C0   SLL S7, S7, 7
9D00ED70  02B7A825   OR S5, S5, S7
9D00ED74  32B500FF   ANDI S5, S5, 255
9D00ED78  02402021   ADDU A0, S2, ZERO
9D00ED7C  0F40283A   JAL mem_writebyte
9D00ED80  02A02821   ADDU A1, S5, ZERO
9D00ED84  02959021   ADDU S2, S4, S5
9D00ED88  8FA40014   LW A0, 20(SP)
9D00ED8C  30820001   ANDI V0, A0, 1
9D00ED90  02429021   ADDU S2, S2, V0
9D00ED94  7E570200   EXT S7, S2, 8, 1
9D00ED98  325200FF   ANDI S2, S2, 255
9D00ED9C  02B41026   XOR V0, S5, S4
9D00EDA0  00021027   NOR V0, ZERO, V0
9D00EDA4  7C023004   INS V0, ZERO, 0, 7
9D00EDA8  0254A026   XOR S4, S2, S4
9D00EDAC  00541024   AND V0, V0, S4
9D00EDB0  304200FF   ANDI V0, V0, 255
9D00EDB4  AFA20014   SW V0, 20(SP)
9D00EDB8  8F828058   LW V0, -32680(GP)
9D00EDBC  2442FFF9   ADDIU V0, V0, -7
9D00EDC0  AF828058   SW V0, -32680(GP)
9D00EDC4  26638FD8   ADDIU V1, S3, -28712
9D00EDC8  8C640054   LW A0, 84(V1)
9D00EDCC  24840007   ADDIU A0, A0, 7
9D00EDD8  0240A021   ADDU S4, S2, ZERO
9D00EDDC  0B404D98   J .L45
9D00EDE0  0240A821   ADDU S5, S2, ZERO
9D00EE14  0240A021   ADDU S4, S2, ZERO
1920:                         OPCODE_END
9D00EDD0  1C400004   BGTZ V0, 0x9D00EDE4
9D00EDD4  AC640054   SW A0, 84(V1)
9D00EDE4  26100003   ADDIU S0, S0, 3
9D00EE04  90420000   LBU V0, 0(V0)
9D00EE08  00021080   SLL V0, V0, 2
9D00EE0C  00561021   ADDU V0, V0, S6
9D00EE10  8C420000   LW V0, 0(V0)
9D00EE18  0B402953   J 0x9D00A54C
9D00EE1C  0240A821   ADDU S5, S2, ZERO
1921:                
1922:                      OPCODE_BEGIN(7D)  /* ADC $nnnn,X */
1923:                         ADC(4, ABS_IND_X_BYTE_READ);
9D00EE20  0F402863   JAL bank_readword
9D00EE24  02002021   ADDU A0, S0, ZERO
9D00EE28  005E1021   ADDU V0, V0, FP
9D00EE2C  3044FFFF   ANDI A0, V0, -1
9D00EE30  308200FF   ANDI V0, A0, 255
9D00EE34  005E102B   SLTU V0, V0, FP
9D00EE38  10400008   BEQ V0, ZERO, 0x9D00EE5C
9D00EE3C  26110002   ADDIU S1, S0, 2
9D00EE40  8F828058   LW V0, -32680(GP)
9D00EE44  2442FFFF   ADDIU V0, V0, -1
9D00EE48  AF828058   SW V0, -32680(GP)
9D00EE4C  26628FD8   ADDIU V0, S3, -28712
9D00EE50  8C430054   LW V1, 84(V0)
9D00EE54  24630001   ADDIU V1, V1, 1
9D00EE58  AC430054   SW V1, 84(V0)
9D00EE5C  0F402804   JAL mem_readbyte
9D00EE60  00000000   NOP
9D00EE64  02829021   ADDU S2, S4, V0
9D00EE68  02579021   ADDU S2, S2, S7
9D00EE6C  7E570200   EXT S7, S2, 8, 1
9D00EE70  325200FF   ANDI S2, S2, 255
9D00EE74  00541026   XOR V0, V0, S4
9D00EE78  00021027   NOR V0, ZERO, V0
9D00EE7C  7C023004   INS V0, ZERO, 0, 7
9D00EE80  0254A026   XOR S4, S2, S4
9D00EE84  00541024   AND V0, V0, S4
9D00EE88  304200FF   ANDI V0, V0, 255
9D00EE8C  AFA20014   SW V0, 20(SP)
9D00EE90  8F828058   LW V0, -32680(GP)
9D00EE94  2442FFFC   ADDIU V0, V0, -4
9D00EE98  AF828058   SW V0, -32680(GP)
9D00EE9C  26638FD8   ADDIU V1, S3, -28712
9D00EEA0  8C640054   LW A0, 84(V1)
9D00EEA4  24840004   ADDIU A0, A0, 4
9D00EEB0  0240A021   ADDU S4, S2, ZERO
9D00EEB4  0B404D98   J .L45
9D00EEB8  0240A821   ADDU S5, S2, ZERO
9D00EEEC  0240A021   ADDU S4, S2, ZERO
1924:                         OPCODE_END
9D00EEA8  1C400004   BGTZ V0, 0x9D00EEBC
9D00EEAC  AC640054   SW A0, 84(V1)
9D00EEBC  26100003   ADDIU S0, S0, 3
9D00EEDC  90420000   LBU V0, 0(V0)
9D00EEE0  00021080   SLL V0, V0, 2
9D00EEE4  00561021   ADDU V0, V0, S6
9D00EEE8  8C420000   LW V0, 0(V0)
9D00EEF0  0B402953   J 0x9D00A54C
9D00EEF4  0240A821   ADDU S5, S2, ZERO
1925:                
1926:                      OPCODE_BEGIN(7E)  /* ROR $nnnn,X */
1927:                         ROR(7, ABS_IND_X, mem_writebyte, addr);
9D00EEF8  0F402863   JAL bank_readword
9D00EEFC  02002021   ADDU A0, S0, ZERO
9D00EF00  26110002   ADDIU S1, S0, 2
9D00EF04  005E1021   ADDU V0, V0, FP
9D00EF08  3055FFFF   ANDI S5, V0, -1
9D00EF0C  0F402804   JAL mem_readbyte
9D00EF10  02A02021   ADDU A0, S5, ZERO
9D00EF14  001719C0   SLL V1, S7, 7
9D00EF18  306300FF   ANDI V1, V1, 255
9D00EF1C  30570001   ANDI S7, V0, 1
9D00EF20  7C423840   EXT V0, V0, 1, 8
9D00EF24  00439025   OR S2, V0, V1
9D00EF28  02A02021   ADDU A0, S5, ZERO
9D00EF2C  0F40283A   JAL mem_writebyte
9D00EF30  02402821   ADDU A1, S2, ZERO
9D00EF34  8F828058   LW V0, -32680(GP)
9D00EF38  2442FFF9   ADDIU V0, V0, -7
9D00EF3C  AF828058   SW V0, -32680(GP)
9D00EF40  26638FD8   ADDIU V1, S3, -28712
9D00EF44  8C640054   LW A0, 84(V1)
9D00EF48  24840007   ADDIU A0, A0, 7
9D00EF54  0B404D98   J .L45
9D00EF58  0240A821   ADDU S5, S2, ZERO
1928:                         OPCODE_END
9D00EF4C  1C400003   BGTZ V0, 0x9D00EF5C
9D00EF50  AC640054   SW A0, 84(V1)
9D00EF5C  26100003   ADDIU S0, S0, 3
9D00EF7C  90420000   LBU V0, 0(V0)
9D00EF80  00021080   SLL V0, V0, 2
9D00EF84  00561021   ADDU V0, V0, S6
9D00EF88  8C420000   LW V0, 0(V0)
9D00EF8C  0B402953   J 0x9D00A54C
9D00EF90  0240A821   ADDU S5, S2, ZERO
1929:                
1930:                      OPCODE_BEGIN(7F)  /* RRA $nnnn,X */
1931:                         RRA(7, ABS_IND_X, mem_writebyte, addr);
9D00EF94  0F402863   JAL bank_readword
9D00EF98  02002021   ADDU A0, S0, ZERO
9D00EF9C  26110002   ADDIU S1, S0, 2
9D00EFA0  005E1021   ADDU V0, V0, FP
9D00EFA4  3052FFFF   ANDI S2, V0, -1
9D00EFA8  0F402804   JAL mem_readbyte
9D00EFAC  02402021   ADDU A0, S2, ZERO
9D00EFB0  AFA20014   SW V0, 20(SP)
9D00EFB4  7C553840   EXT S5, V0, 1, 8
9D00EFB8  0017B9C0   SLL S7, S7, 7
9D00EFBC  02B7A825   OR S5, S5, S7
9D00EFC0  32B500FF   ANDI S5, S5, 255
9D00EFC4  02402021   ADDU A0, S2, ZERO
9D00EFC8  0F40283A   JAL mem_writebyte
9D00EFCC  02A02821   ADDU A1, S5, ZERO
9D00EFD0  02959021   ADDU S2, S4, S5
9D00EFD4  8FA50014   LW A1, 20(SP)
9D00EFD8  30A20001   ANDI V0, A1, 1
9D00EFDC  02429021   ADDU S2, S2, V0
9D00EFE0  7E570200   EXT S7, S2, 8, 1
9D00EFE4  325200FF   ANDI S2, S2, 255
9D00EFE8  02B41026   XOR V0, S5, S4
9D00EFEC  00021027   NOR V0, ZERO, V0
9D00EFF0  7C023004   INS V0, ZERO, 0, 7
9D00EFF4  0254A026   XOR S4, S2, S4
9D00EFF8  00541024   AND V0, V0, S4
9D00EFFC  304200FF   ANDI V0, V0, 255
9D00F000  AFA20014   SW V0, 20(SP)
9D00F004  8F828058   LW V0, -32680(GP)
9D00F008  2442FFF9   ADDIU V0, V0, -7
9D00F00C  AF828058   SW V0, -32680(GP)
9D00F010  26638FD8   ADDIU V1, S3, -28712
9D00F014  8C640054   LW A0, 84(V1)
9D00F018  24840007   ADDIU A0, A0, 7
9D00F024  0240A021   ADDU S4, S2, ZERO
9D00F028  0B404D98   J .L45
9D00F02C  0240A821   ADDU S5, S2, ZERO
9D00F060  0240A021   ADDU S4, S2, ZERO
1932:                         OPCODE_END
9D00F01C  1C400004   BGTZ V0, 0x9D00F030
9D00F020  AC640054   SW A0, 84(V1)
9D00F030  26100003   ADDIU S0, S0, 3
9D00F050  90420000   LBU V0, 0(V0)
9D00F054  00021080   SLL V0, V0, 2
9D00F058  00561021   ADDU V0, V0, S6
9D00F05C  8C420000   LW V0, 0(V0)
9D00F064  0B402953   J 0x9D00A54C
9D00F068  0240A821   ADDU S5, S2, ZERO
1933:                
1934:                      OPCODE_BEGIN(80)  /* NOP #$nn */
1935:                      OPCODE_BEGIN(82)  /* NOP #$nn */
1936:                      OPCODE_BEGIN(89)  /* NOP #$nn */
1937:                      OPCODE_BEGIN(C2)  /* NOP #$nn */
1938:                      OPCODE_BEGIN(E2)  /* NOP #$nn */
1939:                         DOP(2);
9D00F06C  0B403C22   J 0x9D00F088
9D00F070  26110001   ADDIU S1, S0, 1
9D00F074  0B403C22   J 0x9D00F088
9D00F078  26110001   ADDIU S1, S0, 1
9D00F07C  0B403C22   J 0x9D00F088
9D00F080  26110001   ADDIU S1, S0, 1
9D00F084  26110001   ADDIU S1, S0, 1
9D00F088  8F828058   LW V0, -32680(GP)
9D00F08C  2442FFFE   ADDIU V0, V0, -2
9D00F090  AF828058   SW V0, -32680(GP)
9D00F094  26638FD8   ADDIU V1, S3, -28712
9D00F098  8C640054   LW A0, 84(V1)
9D00F09C  24840002   ADDIU A0, A0, 2
1940:                         OPCODE_END
9D00F0A0  1840116F   BLEZ V0, .L45
9D00F0A4  AC640054   SW A0, 84(V1)
9D00F0A8  26100002   ADDIU S0, S0, 2
9D00F0C8  92220000   LBU V0, 0(S1)
9D00F0CC  00021080   SLL V0, V0, 2
9D00F0D0  00561021   ADDU V0, V0, S6
9D00F0D4  0B402953   J 0x9D00A54C
9D00F0D8  8C420000   LW V0, 0(V0)
1941:                
1942:                      OPCODE_BEGIN(81)  /* STA ($nn,X) */
1943:                         STA(6, INDIR_X_ADDR, mem_writebyte, addr);
9D00F0DC  26110001   ADDIU S1, S0, 1
9D00F100  90420000   LBU V0, 0(V0)
9D00F104  03C21021   ADDU V0, FP, V0
9D00F120  308400FF   ANDI A0, A0, 255
9D00F124  0F40283A   JAL mem_writebyte
9D00F128  02802821   ADDU A1, S4, ZERO
9D00F12C  8F828058   LW V0, -32680(GP)
9D00F130  2442FFFA   ADDIU V0, V0, -6
9D00F134  AF828058   SW V0, -32680(GP)
9D00F138  3C07A001   LUI A3, -24575
9D00F13C  24E78FD8   ADDIU A3, A3, -28712
9D00F140  8CE30054   LW V1, 84(A3)
9D00F144  24630006   ADDIU V1, V1, 6
1944:                         OPCODE_END
9D00F148  18401145   BLEZ V0, .L45
9D00F14C  ACE30054   SW V1, 84(A3)
9D00F150  26100002   ADDIU S0, S0, 2
9D00F170  90420000   LBU V0, 0(V0)
9D00F174  00021080   SLL V0, V0, 2
9D00F178  00561021   ADDU V0, V0, S6
9D00F17C  0B402953   J 0x9D00A54C
9D00F180  8C420000   LW V0, 0(V0)
1945:                
1946:                      OPCODE_BEGIN(83)  /* SAX ($nn,X) */
1947:                         SAX(6, INDIR_X_ADDR, mem_writebyte, addr);
9D00F184  26110001   ADDIU S1, S0, 1
9D00F1A8  90420000   LBU V0, 0(V0)
9D00F1AC  03C21021   ADDU V0, FP, V0
9D00F1C8  03D42824   AND A1, FP, S4
9D00F1CC  308400FF   ANDI A0, A0, 255
9D00F1D0  0F40283A   JAL mem_writebyte
9D00F1D4  30A500FF   ANDI A1, A1, 255
9D00F1D8  8F828058   LW V0, -32680(GP)
9D00F1DC  2442FFFA   ADDIU V0, V0, -6
9D00F1E0  AF828058   SW V0, -32680(GP)
9D00F1E4  3C04A001   LUI A0, -24575
9D00F1E8  24848FD8   ADDIU A0, A0, -28712
9D00F1EC  8C830054   LW V1, 84(A0)
9D00F1F0  24630006   ADDIU V1, V1, 6
1948:                         OPCODE_END
9D00F1F4  1840111A   BLEZ V0, .L45
9D00F1F8  AC830054   SW V1, 84(A0)
9D00F1FC  26100002   ADDIU S0, S0, 2
9D00F21C  90420000   LBU V0, 0(V0)
9D00F220  00021080   SLL V0, V0, 2
9D00F224  00561021   ADDU V0, V0, S6
9D00F228  0B402953   J 0x9D00A54C
9D00F22C  8C420000   LW V0, 0(V0)
1949:                
1950:                      OPCODE_BEGIN(84)  /* STY $nn */
1951:                         STY(3, ZERO_PAGE_ADDR, ZP_WRITEBYTE, baddr);
9D00F230  26110001   ADDIU S1, S0, 1
9D00F250  90630000   LBU V1, 0(V1)
9D00F254  8F848054   LW A0, -32684(GP)
9D00F258  00831821   ADDU V1, A0, V1
9D00F25C  8FA50010   LW A1, 16(SP)
9D00F260  A0650000   SB A1, 0(V1)
9D00F264  8F838058   LW V1, -32680(GP)
9D00F268  2463FFFD   ADDIU V1, V1, -3
9D00F26C  AF838058   SW V1, -32680(GP)
9D00F270  8C440054   LW A0, 84(V0)
9D00F274  24840003   ADDIU A0, A0, 3
1952:                         OPCODE_END
9D00F278  186010F9   BLEZ V1, .L45
9D00F27C  AC440054   SW A0, 84(V0)
9D00F280  26100002   ADDIU S0, S0, 2
9D00F29C  90420000   LBU V0, 0(V0)
9D00F2A0  00021080   SLL V0, V0, 2
9D00F2A4  00561021   ADDU V0, V0, S6
9D00F2A8  0B402953   J 0x9D00A54C
9D00F2AC  8C420000   LW V0, 0(V0)
1953:                
1954:                      OPCODE_BEGIN(85)  /* STA $nn */
1955:                         STA(3, ZERO_PAGE_ADDR, ZP_WRITEBYTE, baddr);
9D00F2B0  26110001   ADDIU S1, S0, 1
9D00F2D0  90630000   LBU V1, 0(V1)
9D00F2D4  8F848054   LW A0, -32684(GP)
9D00F2D8  00831821   ADDU V1, A0, V1
9D00F2DC  A0740000   SB S4, 0(V1)
9D00F2E0  8F838058   LW V1, -32680(GP)
9D00F2E4  2463FFFD   ADDIU V1, V1, -3
9D00F2E8  AF838058   SW V1, -32680(GP)
9D00F2EC  8C440054   LW A0, 84(V0)
9D00F2F0  24840003   ADDIU A0, A0, 3
1956:                         OPCODE_END
9D00F2F4  186010DA   BLEZ V1, .L45
9D00F2F8  AC440054   SW A0, 84(V0)
9D00F2FC  26100002   ADDIU S0, S0, 2
9D00F318  90420000   LBU V0, 0(V0)
9D00F31C  00021080   SLL V0, V0, 2
9D00F320  00561021   ADDU V0, V0, S6
9D00F324  0B402953   J 0x9D00A54C
9D00F328  8C420000   LW V0, 0(V0)
1957:                
1958:                      OPCODE_BEGIN(86)  /* STX $nn */
1959:                         STX(3, ZERO_PAGE_ADDR, ZP_WRITEBYTE, baddr);
9D00F32C  26110001   ADDIU S1, S0, 1
9D00F34C  90630000   LBU V1, 0(V1)
9D00F350  8F848054   LW A0, -32684(GP)
9D00F354  00831821   ADDU V1, A0, V1
9D00F358  A07E0000   SB FP, 0(V1)
9D00F35C  8F838058   LW V1, -32680(GP)
9D00F360  2463FFFD   ADDIU V1, V1, -3
9D00F364  AF838058   SW V1, -32680(GP)
9D00F368  8C440054   LW A0, 84(V0)
9D00F36C  24840003   ADDIU A0, A0, 3
1960:                         OPCODE_END
9D00F370  186010BB   BLEZ V1, .L45
9D00F374  AC440054   SW A0, 84(V0)
9D00F378  26100002   ADDIU S0, S0, 2
9D00F394  90420000   LBU V0, 0(V0)
9D00F398  00021080   SLL V0, V0, 2
9D00F39C  00561021   ADDU V0, V0, S6
9D00F3A0  0B402953   J 0x9D00A54C
9D00F3A4  8C420000   LW V0, 0(V0)
1961:                
1962:                      OPCODE_BEGIN(87)  /* SAX $nn */
1963:                         SAX(3, ZERO_PAGE_ADDR, ZP_WRITEBYTE, baddr);
9D00F3A8  26110001   ADDIU S1, S0, 1
9D00F3C8  90630000   LBU V1, 0(V1)
9D00F3CC  8F848054   LW A0, -32684(GP)
9D00F3D0  00831821   ADDU V1, A0, V1
9D00F3D4  03D42024   AND A0, FP, S4
9D00F3D8  A0640000   SB A0, 0(V1)
9D00F3DC  8F838058   LW V1, -32680(GP)
9D00F3E0  2463FFFD   ADDIU V1, V1, -3
9D00F3E4  AF838058   SW V1, -32680(GP)
9D00F3E8  8C440054   LW A0, 84(V0)
9D00F3EC  24840003   ADDIU A0, A0, 3
1964:                         OPCODE_END
9D00F3F0  1860109B   BLEZ V1, .L45
9D00F3F4  AC440054   SW A0, 84(V0)
9D00F3F8  26100002   ADDIU S0, S0, 2
9D00F414  90420000   LBU V0, 0(V0)
9D00F418  00021080   SLL V0, V0, 2
9D00F41C  00561021   ADDU V0, V0, S6
9D00F420  0B402953   J 0x9D00A54C
9D00F424  8C420000   LW V0, 0(V0)
1965:                
1966:                      OPCODE_BEGIN(88)  /* DEY */
1967:                         DEY();
9D00F428  8FA60010   LW A2, 16(SP)
9D00F42C  24D2FFFF   ADDIU S2, A2, -1
9D00F430  325200FF   ANDI S2, S2, 255
9D00F434  8F828058   LW V0, -32680(GP)
9D00F438  2442FFFE   ADDIU V0, V0, -2
9D00F43C  AF828058   SW V0, -32680(GP)
9D00F440  26638FD8   ADDIU V1, S3, -28712
9D00F444  8C640054   LW A0, 84(V1)
9D00F448  24840002   ADDIU A0, A0, 2
9D00F454  AFB20010   SW S2, 16(SP)
9D00F45C  0B404D98   J .L45
9D00F460  0240A821   ADDU S5, S2, ZERO
9D00F490  AFB20010   SW S2, 16(SP)
1968:                         OPCODE_END
9D00F44C  1C400005   BGTZ V0, .LBB1154
9D00F450  AC640054   SW A0, 84(V1)
9D00F458  02008821   ADDU S1, S0, ZERO
9D00F480  90420000   LBU V0, 0(V0)
9D00F484  00021080   SLL V0, V0, 2
9D00F488  00561021   ADDU V0, V0, S6
9D00F48C  8C420000   LW V0, 0(V0)
9D00F494  26100001   ADDIU S0, S0, 1
9D00F498  0B402953   J 0x9D00A54C
9D00F49C  0240A821   ADDU S5, S2, ZERO
1969:                
1970:                      OPCODE_BEGIN(8A)  /* TXA */
1971:                         TXA();
9D00F4A0  8F828058   LW V0, -32680(GP)
9D00F4A4  2442FFFE   ADDIU V0, V0, -2
9D00F4A8  AF828058   SW V0, -32680(GP)
9D00F4AC  26638FD8   ADDIU V1, S3, -28712
9D00F4B0  8C640054   LW A0, 84(V1)
9D00F4B4  24840002   ADDIU A0, A0, 2
1972:                         OPCODE_END
9D00F4B8  1C400006   BGTZ V0, .LBB1156
9D00F4BC  AC640054   SW A0, 84(V1)
9D00F4C0  03C09021   ADDU S2, FP, ZERO
9D00F4C4  03C0A021   ADDU S4, FP, ZERO
9D00F4C8  02008821   ADDU S1, S0, ZERO
9D00F4CC  0B404D98   J .L45
9D00F4D0  03C0A821   ADDU S5, FP, ZERO
9D00F4F0  90420000   LBU V0, 0(V0)
9D00F4F4  00021080   SLL V0, V0, 2
9D00F4F8  00561021   ADDU V0, V0, S6
9D00F4FC  8C420000   LW V0, 0(V0)
9D00F500  03C0A021   ADDU S4, FP, ZERO
9D00F504  26100001   ADDIU S0, S0, 1
9D00F508  03C0A821   ADDU S5, FP, ZERO
9D00F50C  0B402953   J 0x9D00A54C
9D00F510  03C09021   ADDU S2, FP, ZERO
1973:                
1974:                      OPCODE_BEGIN(8B)  /* ANE #$nn */
1975:                         ANE(2, IMMEDIATE_BYTE);
9D00F514  26110001   ADDIU S1, S0, 1
9D00F518  2407FFEE   ADDIU A3, ZERO, -18
9D00F51C  02879025   OR S2, S4, A3
9D00F520  03D29024   AND S2, FP, S2
9D00F540  90630000   LBU V1, 0(V1)
9D00F544  02439024   AND S2, S2, V1
9D00F548  8F838058   LW V1, -32680(GP)
9D00F54C  2463FFFE   ADDIU V1, V1, -2
9D00F550  AF838058   SW V1, -32680(GP)
9D00F554  8C440054   LW A0, 84(V0)
9D00F558  24840002   ADDIU A0, A0, 2
9D00F564  0240A021   ADDU S4, S2, ZERO
9D00F568  0B404D98   J .L45
9D00F56C  0240A821   ADDU S5, S2, ZERO
9D00F5A0  0240A021   ADDU S4, S2, ZERO
1976:                         OPCODE_END
9D00F55C  1C600004   BGTZ V1, 0x9D00F570
9D00F560  AC440054   SW A0, 84(V0)
9D00F570  26100002   ADDIU S0, S0, 2
9D00F590  90420000   LBU V0, 0(V0)
9D00F594  00021080   SLL V0, V0, 2
9D00F598  00561021   ADDU V0, V0, S6
9D00F59C  8C420000   LW V0, 0(V0)
9D00F5A4  0B402953   J 0x9D00A54C
9D00F5A8  0240A821   ADDU S5, S2, ZERO
1977:                
1978:                      OPCODE_BEGIN(8C)  /* STY $nnnn */
1979:                         STY(4, ABSOLUTE_ADDR, mem_writebyte, addr);
9D00F5AC  0F402863   JAL bank_readword
9D00F5B0  02002021   ADDU A0, S0, ZERO
9D00F5B4  26110002   ADDIU S1, S0, 2
9D00F5B8  00402021   ADDU A0, V0, ZERO
9D00F5BC  0F40283A   JAL mem_writebyte
9D00F5C0  8FA50010   LW A1, 16(SP)
9D00F5C4  8F828058   LW V0, -32680(GP)
9D00F5C8  2442FFFC   ADDIU V0, V0, -4
9D00F5CC  AF828058   SW V0, -32680(GP)
9D00F5D0  26638FD8   ADDIU V1, S3, -28712
9D00F5D4  8C640054   LW A0, 84(V1)
9D00F5D8  24840004   ADDIU A0, A0, 4
1980:                         OPCODE_END
9D00F5DC  18401020   BLEZ V0, .L45
9D00F5E0  AC640054   SW A0, 84(V1)
9D00F5E4  26100003   ADDIU S0, S0, 3
9D00F604  90420000   LBU V0, 0(V0)
9D00F608  00021080   SLL V0, V0, 2
9D00F60C  00561021   ADDU V0, V0, S6
9D00F610  0B402953   J 0x9D00A54C
9D00F614  8C420000   LW V0, 0(V0)
1981:                
1982:                      OPCODE_BEGIN(8D)  /* STA $nnnn */
1983:                         STA(4, ABSOLUTE_ADDR, mem_writebyte, addr);
9D00F618  0F402863   JAL bank_readword
9D00F61C  02002021   ADDU A0, S0, ZERO
9D00F620  26110002   ADDIU S1, S0, 2
9D00F624  00402021   ADDU A0, V0, ZERO
9D00F628  0F40283A   JAL mem_writebyte
9D00F62C  02802821   ADDU A1, S4, ZERO
9D00F630  8F828058   LW V0, -32680(GP)
9D00F634  2442FFFC   ADDIU V0, V0, -4
9D00F638  AF828058   SW V0, -32680(GP)
9D00F63C  26638FD8   ADDIU V1, S3, -28712
9D00F640  8C640054   LW A0, 84(V1)
9D00F644  24840004   ADDIU A0, A0, 4
1984:                         OPCODE_END
9D00F648  18401005   BLEZ V0, .L45
9D00F64C  AC640054   SW A0, 84(V1)
9D00F650  26100003   ADDIU S0, S0, 3
9D00F670  90420000   LBU V0, 0(V0)
9D00F674  00021080   SLL V0, V0, 2
9D00F678  00561021   ADDU V0, V0, S6
9D00F67C  0B402953   J 0x9D00A54C
9D00F680  8C420000   LW V0, 0(V0)
1985:                
1986:                      OPCODE_BEGIN(8E)  /* STX $nnnn */
1987:                         STX(4, ABSOLUTE_ADDR, mem_writebyte, addr);
9D00F684  0F402863   JAL bank_readword
9D00F688  02002021   ADDU A0, S0, ZERO
9D00F68C  26110002   ADDIU S1, S0, 2
9D00F690  00402021   ADDU A0, V0, ZERO
9D00F694  0F40283A   JAL mem_writebyte
9D00F698  03C02821   ADDU A1, FP, ZERO
9D00F69C  8F828058   LW V0, -32680(GP)
9D00F6A0  2442FFFC   ADDIU V0, V0, -4
9D00F6A4  AF828058   SW V0, -32680(GP)
9D00F6A8  26638FD8   ADDIU V1, S3, -28712
9D00F6AC  8C640054   LW A0, 84(V1)
9D00F6B0  24840004   ADDIU A0, A0, 4
1988:                         OPCODE_END
9D00F6B4  18400FEA   BLEZ V0, .L45
9D00F6B8  AC640054   SW A0, 84(V1)
9D00F6BC  26100003   ADDIU S0, S0, 3
9D00F6DC  90420000   LBU V0, 0(V0)
9D00F6E0  00021080   SLL V0, V0, 2
9D00F6E4  00561021   ADDU V0, V0, S6
9D00F6E8  0B402953   J 0x9D00A54C
9D00F6EC  8C420000   LW V0, 0(V0)
1989:                      
1990:                      OPCODE_BEGIN(8F)  /* SAX $nnnn */
1991:                         SAX(4, ABSOLUTE_ADDR, mem_writebyte, addr);
9D00F6F0  0F402863   JAL bank_readword
9D00F6F4  02002021   ADDU A0, S0, ZERO
9D00F6F8  26110002   ADDIU S1, S0, 2
9D00F6FC  03D41824   AND V1, FP, S4
9D00F700  00402021   ADDU A0, V0, ZERO
9D00F704  0F40283A   JAL mem_writebyte
9D00F708  306500FF   ANDI A1, V1, 255
9D00F70C  8F828058   LW V0, -32680(GP)
9D00F710  2442FFFC   ADDIU V0, V0, -4
9D00F714  AF828058   SW V0, -32680(GP)
9D00F718  26638FD8   ADDIU V1, S3, -28712
9D00F71C  8C640054   LW A0, 84(V1)
9D00F720  24840004   ADDIU A0, A0, 4
1992:                         OPCODE_END
9D00F724  18400FCE   BLEZ V0, .L45
9D00F728  AC640054   SW A0, 84(V1)
9D00F72C  26100003   ADDIU S0, S0, 3
9D00F74C  90420000   LBU V0, 0(V0)
9D00F750  00021080   SLL V0, V0, 2
9D00F754  00561021   ADDU V0, V0, S6
9D00F758  0B402953   J 0x9D00A54C
9D00F75C  8C420000   LW V0, 0(V0)
1993:                
1994:                      OPCODE_BEGIN(90)  /* BCC $nnnn */
1995:                         BCC();
9D00F760  16E0001E   BNE S7, ZERO, 0x9D00F7DC
9D00F764  26110001   ADDIU S1, S0, 1
9D00F768  26020001   ADDIU V0, S0, 1
9D00F788  80710000   LB S1, 0(V1)
9D00F78C  304300FF   ANDI V1, V0, 255
9D00F790  02231821   ADDU V1, S1, V1
9D00F794  30630100   ANDI V1, V1, 256
9D00F798  10600008   BEQ V1, ZERO, 0x9D00F7BC
9D00F79C  8F838058   LW V1, -32680(GP)
9D00F7A0  2463FFFF   ADDIU V1, V1, -1
9D00F7A4  AF838058   SW V1, -32680(GP)
9D00F7A8  26638FD8   ADDIU V1, S3, -28712
9D00F7AC  8C640054   LW A0, 84(V1)
9D00F7B0  24840001   ADDIU A0, A0, 1
9D00F7B4  AC640054   SW A0, 84(V1)
9D00F7B8  8F838058   LW V1, -32680(GP)
9D00F7BC  2463FFFD   ADDIU V1, V1, -3
9D00F7C0  AF838058   SW V1, -32680(GP)
9D00F7C4  26638FD8   ADDIU V1, S3, -28712
9D00F7C8  8C640054   LW A0, 84(V1)
9D00F7CC  24840003   ADDIU A0, A0, 3
9D00F7D0  AC640054   SW A0, 84(V1)
9D00F7D4  0B403DFE   J 0x9D00F7F8
9D00F7D8  02228821   ADDU S1, S1, V0
9D00F7DC  8F828058   LW V0, -32680(GP)
9D00F7E0  2442FFFE   ADDIU V0, V0, -2
9D00F7E4  AF828058   SW V0, -32680(GP)
9D00F7E8  26628FD8   ADDIU V0, S3, -28712
9D00F7EC  8C430054   LW V1, 84(V0)
9D00F7F0  24630002   ADDIU V1, V1, 2
9D00F7F4  AC430054   SW V1, 84(V0)
1996:                         OPCODE_END
9D00F7F8  8F828058   LW V0, -32680(GP)
9D00F7FC  18400F98   BLEZ V0, .L45
9D00F800  26300001   ADDIU S0, S1, 1
9D00F820  90420000   LBU V0, 0(V0)
9D00F824  00021080   SLL V0, V0, 2
9D00F828  00561021   ADDU V0, V0, S6
9D00F82C  0B402953   J 0x9D00A54C
9D00F830  8C420000   LW V0, 0(V0)
1997:                
1998:                      OPCODE_BEGIN(91)  /* STA ($nn),Y */
1999:                         STA(6, INDIR_Y_ADDR, mem_writebyte, addr);
9D00F834  26110001   ADDIU S1, S0, 1
9D00F874  8FA30010   LW V1, 16(SP)
9D00F878  00832021   ADDU A0, A0, V1
9D00F87C  3084FFFF   ANDI A0, A0, -1
9D00F880  0F40283A   JAL mem_writebyte
9D00F884  02802821   ADDU A1, S4, ZERO
9D00F888  8F828058   LW V0, -32680(GP)
9D00F88C  2442FFFA   ADDIU V0, V0, -6
9D00F890  AF828058   SW V0, -32680(GP)
9D00F894  3C04A001   LUI A0, -24575
9D00F898  24848FD8   ADDIU A0, A0, -28712
9D00F89C  8C830054   LW V1, 84(A0)
9D00F8A0  24630006   ADDIU V1, V1, 6
2000:                         OPCODE_END
9D00F8A4  18400F6E   BLEZ V0, .L45
9D00F8A8  AC830054   SW V1, 84(A0)
9D00F8AC  26100002   ADDIU S0, S0, 2
9D00F8CC  90420000   LBU V0, 0(V0)
9D00F8D0  00021080   SLL V0, V0, 2
9D00F8D4  00561021   ADDU V0, V0, S6
9D00F8D8  0B402953   J 0x9D00A54C
9D00F8DC  8C420000   LW V0, 0(V0)
2001:                
2002:                      OPCODE_BEGIN(93)  /* SHA ($nn),Y */
2003:                         SHA(6, INDIR_Y_ADDR, mem_writebyte, addr);
9D00F8E0  26110001   ADDIU S1, S0, 1
9D00F920  8FA60010   LW A2, 16(SP)
9D00F924  00862021   ADDU A0, A0, A2
9D00F928  3084FFFF   ANDI A0, A0, -1
9D00F92C  03D42824   AND A1, FP, S4
9D00F930  00041202   SRL V0, A0, 8
9D00F934  24420001   ADDIU V0, V0, 1
9D00F938  00A22824   AND A1, A1, V0
9D00F93C  0F40283A   JAL mem_writebyte
9D00F940  30A500FF   ANDI A1, A1, 255
9D00F944  8F828058   LW V0, -32680(GP)
9D00F948  2442FFFA   ADDIU V0, V0, -6
9D00F94C  AF828058   SW V0, -32680(GP)
9D00F950  3C07A001   LUI A3, -24575
9D00F954  24E78FD8   ADDIU A3, A3, -28712
9D00F958  8CE30054   LW V1, 84(A3)
9D00F95C  24630006   ADDIU V1, V1, 6
2004:                         OPCODE_END
9D00F960  18400F3F   BLEZ V0, .L45
9D00F964  ACE30054   SW V1, 84(A3)
9D00F968  26100002   ADDIU S0, S0, 2
9D00F988  90420000   LBU V0, 0(V0)
9D00F98C  00021080   SLL V0, V0, 2
9D00F990  00561021   ADDU V0, V0, S6
9D00F994  0B402953   J 0x9D00A54C
9D00F998  8C420000   LW V0, 0(V0)
2005:                
2006:                      OPCODE_BEGIN(94)  /* STY $nn,X */
2007:                         STY(4, ZP_IND_X_ADDR, ZP_WRITEBYTE, baddr);
9D00F99C  26110001   ADDIU S1, S0, 1
9D00F9BC  90630000   LBU V1, 0(V1)
9D00F9C0  03C31821   ADDU V1, FP, V1
9D00F9C4  306300FF   ANDI V1, V1, 255
9D00F9C8  8F848054   LW A0, -32684(GP)
9D00F9CC  00831821   ADDU V1, A0, V1
9D00F9D0  8FA40010   LW A0, 16(SP)
9D00F9D4  A0640000   SB A0, 0(V1)
9D00F9D8  8F838058   LW V1, -32680(GP)
9D00F9DC  2463FFFC   ADDIU V1, V1, -4
9D00F9E0  AF838058   SW V1, -32680(GP)
9D00F9E4  8C440054   LW A0, 84(V0)
9D00F9E8  24840004   ADDIU A0, A0, 4
2008:                         OPCODE_END
9D00F9EC  18600F1C   BLEZ V1, .L45
9D00F9F0  AC440054   SW A0, 84(V0)
9D00F9F4  26100002   ADDIU S0, S0, 2
9D00FA10  90420000   LBU V0, 0(V0)
9D00FA14  00021080   SLL V0, V0, 2
9D00FA18  00561021   ADDU V0, V0, S6
9D00FA1C  0B402953   J 0x9D00A54C
9D00FA20  8C420000   LW V0, 0(V0)
2009:                
2010:                      OPCODE_BEGIN(95)  /* STA $nn,X */
2011:                         STA(4, ZP_IND_X_ADDR, ZP_WRITEBYTE, baddr);
9D00FA24  26110001   ADDIU S1, S0, 1
9D00FA44  90630000   LBU V1, 0(V1)
9D00FA48  03C31821   ADDU V1, FP, V1
9D00FA4C  306300FF   ANDI V1, V1, 255
9D00FA50  8F848054   LW A0, -32684(GP)
9D00FA54  00831821   ADDU V1, A0, V1
9D00FA58  A0740000   SB S4, 0(V1)
9D00FA5C  8F838058   LW V1, -32680(GP)
9D00FA60  2463FFFC   ADDIU V1, V1, -4
9D00FA64  AF838058   SW V1, -32680(GP)
9D00FA68  8C440054   LW A0, 84(V0)
9D00FA6C  24840004   ADDIU A0, A0, 4
2012:                         OPCODE_END
9D00FA70  18600EFB   BLEZ V1, .L45
9D00FA74  AC440054   SW A0, 84(V0)
9D00FA78  26100002   ADDIU S0, S0, 2
9D00FA94  90420000   LBU V0, 0(V0)
9D00FA98  00021080   SLL V0, V0, 2
9D00FA9C  00561021   ADDU V0, V0, S6
9D00FAA0  0B402953   J 0x9D00A54C
9D00FAA4  8C420000   LW V0, 0(V0)
2013:                
2014:                      OPCODE_BEGIN(96)  /* STX $nn,Y */
2015:                         STX(4, ZP_IND_Y_ADDR, ZP_WRITEBYTE, baddr);
9D00FAA8  26110001   ADDIU S1, S0, 1
9D00FAC8  90630000   LBU V1, 0(V1)
9D00FACC  8FA50010   LW A1, 16(SP)
9D00FAD0  00A31821   ADDU V1, A1, V1
9D00FAD4  306300FF   ANDI V1, V1, 255
9D00FAD8  8F848054   LW A0, -32684(GP)
9D00FADC  00831821   ADDU V1, A0, V1
9D00FAE0  A07E0000   SB FP, 0(V1)
9D00FAE4  8F838058   LW V1, -32680(GP)
9D00FAE8  2463FFFC   ADDIU V1, V1, -4
9D00FAEC  AF838058   SW V1, -32680(GP)
9D00FAF0  8C440054   LW A0, 84(V0)
9D00FAF4  24840004   ADDIU A0, A0, 4
2016:                         OPCODE_END
9D00FAF8  18600ED9   BLEZ V1, .L45
9D00FAFC  AC440054   SW A0, 84(V0)
9D00FB00  26100002   ADDIU S0, S0, 2
9D00FB1C  90420000   LBU V0, 0(V0)
9D00FB20  00021080   SLL V0, V0, 2
9D00FB24  00561021   ADDU V0, V0, S6
9D00FB28  0B402953   J 0x9D00A54C
9D00FB2C  8C420000   LW V0, 0(V0)
2017:                
2018:                      OPCODE_BEGIN(97)  /* SAX $nn,Y */
2019:                         SAX(4, ZP_IND_Y_ADDR, ZP_WRITEBYTE, baddr);
9D00FB30  26110001   ADDIU S1, S0, 1
9D00FB50  90630000   LBU V1, 0(V1)
9D00FB54  8FA60010   LW A2, 16(SP)
9D00FB58  00C31821   ADDU V1, A2, V1
9D00FB5C  306300FF   ANDI V1, V1, 255
9D00FB60  8F848054   LW A0, -32684(GP)
9D00FB64  00831821   ADDU V1, A0, V1
9D00FB68  03D42024   AND A0, FP, S4
9D00FB6C  A0640000   SB A0, 0(V1)
9D00FB70  8F838058   LW V1, -32680(GP)
9D00FB74  2463FFFC   ADDIU V1, V1, -4
9D00FB78  AF838058   SW V1, -32680(GP)
9D00FB7C  8C440054   LW A0, 84(V0)
9D00FB80  24840004   ADDIU A0, A0, 4
2020:                         OPCODE_END
9D00FB84  18600EB6   BLEZ V1, .L45
9D00FB88  AC440054   SW A0, 84(V0)
9D00FB8C  26100002   ADDIU S0, S0, 2
9D00FBA8  90420000   LBU V0, 0(V0)
9D00FBAC  00021080   SLL V0, V0, 2
9D00FBB0  00561021   ADDU V0, V0, S6
9D00FBB4  0B402953   J 0x9D00A54C
9D00FBB8  8C420000   LW V0, 0(V0)
2021:                
2022:                      OPCODE_BEGIN(98)  /* TYA */
2023:                         TYA();
9D00FBBC  8F828058   LW V0, -32680(GP)
9D00FBC0  2442FFFE   ADDIU V0, V0, -2
9D00FBC4  AF828058   SW V0, -32680(GP)
9D00FBC8  26638FD8   ADDIU V1, S3, -28712
9D00FBCC  8C640054   LW A0, 84(V1)
9D00FBD0  24840002   ADDIU A0, A0, 2
2024:                         OPCODE_END
9D00FBD4  1C400006   BGTZ V0, .LBB1202
9D00FBD8  AC640054   SW A0, 84(V1)
9D00FBDC  8FB20010   LW S2, 16(SP)
9D00FBE0  0240A021   ADDU S4, S2, ZERO
9D00FBE4  02008821   ADDU S1, S0, ZERO
9D00FBE8  0B404D98   J .L45
9D00FBEC  0240A821   ADDU S5, S2, ZERO
9D00FC0C  90420000   LBU V0, 0(V0)
9D00FC10  00021080   SLL V0, V0, 2
9D00FC14  00561021   ADDU V0, V0, S6
9D00FC18  8C420000   LW V0, 0(V0)
9D00FC1C  8FB40010   LW S4, 16(SP)
9D00FC20  26100001   ADDIU S0, S0, 1
9D00FC24  0280A821   ADDU S5, S4, ZERO
9D00FC28  0B402953   J 0x9D00A54C
9D00FC2C  02809021   ADDU S2, S4, ZERO
2025:                
2026:                      OPCODE_BEGIN(99)  /* STA $nnnn,Y */
2027:                         STA(5, ABS_IND_Y_ADDR, mem_writebyte, addr);
9D00FC30  0F402863   JAL bank_readword
9D00FC34  02002021   ADDU A0, S0, ZERO
9D00FC38  26110002   ADDIU S1, S0, 2
9D00FC3C  8FA70010   LW A3, 16(SP)
9D00FC40  00471021   ADDU V0, V0, A3
9D00FC44  3044FFFF   ANDI A0, V0, -1
9D00FC48  0F40283A   JAL mem_writebyte
9D00FC4C  02802821   ADDU A1, S4, ZERO
9D00FC50  8F828058   LW V0, -32680(GP)
9D00FC54  2442FFFB   ADDIU V0, V0, -5
9D00FC58  AF828058   SW V0, -32680(GP)
9D00FC5C  26638FD8   ADDIU V1, S3, -28712
9D00FC60  8C640054   LW A0, 84(V1)
9D00FC64  24840005   ADDIU A0, A0, 5
2028:                         OPCODE_END
9D00FC68  18400E7D   BLEZ V0, .L45
9D00FC6C  AC640054   SW A0, 84(V1)
9D00FC70  26100003   ADDIU S0, S0, 3
9D00FC90  90420000   LBU V0, 0(V0)
9D00FC94  00021080   SLL V0, V0, 2
9D00FC98  00561021   ADDU V0, V0, S6
9D00FC9C  0B402953   J 0x9D00A54C
9D00FCA0  8C420000   LW V0, 0(V0)
2029:                
2030:                      OPCODE_BEGIN(9A)  /* TXS */
2031:                         TXS();
9D00FCA4  8F828058   LW V0, -32680(GP)
9D00FCA8  2442FFFE   ADDIU V0, V0, -2
9D00FCAC  AF828058   SW V0, -32680(GP)
9D00FCB0  26638FD8   ADDIU V1, S3, -28712
9D00FCB4  8C640054   LW A0, 84(V1)
9D00FCB8  24840002   ADDIU A0, A0, 2
2032:                         OPCODE_END
9D00FCBC  1C400004   BGTZ V0, .LBB1206
9D00FCC0  AC640054   SW A0, 84(V1)
9D00FCC4  AFBE0018   SW FP, 24(SP)
9D00FCC8  0B404D98   J .L45
9D00FCCC  02008821   ADDU S1, S0, ZERO
9D00FCEC  90420000   LBU V0, 0(V0)
9D00FCF0  00021080   SLL V0, V0, 2
9D00FCF4  00561021   ADDU V0, V0, S6
9D00FCF8  8C420000   LW V0, 0(V0)
9D00FCFC  AFBE0018   SW FP, 24(SP)
9D00FD00  0B402953   J 0x9D00A54C
9D00FD04  26100001   ADDIU S0, S0, 1
2033:                
2034:                      OPCODE_BEGIN(9B)  /* SHS $nnnn,Y */
2035:                         SHS(5, ABS_IND_Y_ADDR, mem_writebyte, addr);
9D00FD08  0F402863   JAL bank_readword
9D00FD0C  02002021   ADDU A0, S0, ZERO
9D00FD10  26110002   ADDIU S1, S0, 2
9D00FD14  8FA30010   LW V1, 16(SP)
9D00FD18  00431021   ADDU V0, V0, V1
9D00FD1C  3044FFFF   ANDI A0, V0, -1
9D00FD20  03D41024   AND V0, FP, S4
9D00FD24  304200FF   ANDI V0, V0, 255
9D00FD28  AFA20018   SW V0, 24(SP)
9D00FD2C  00042A02   SRL A1, A0, 8
9D00FD30  24A50001   ADDIU A1, A1, 1
9D00FD34  0F40283A   JAL mem_writebyte
9D00FD38  00452824   AND A1, V0, A1
9D00FD3C  8F828058   LW V0, -32680(GP)
9D00FD40  2442FFFB   ADDIU V0, V0, -5
9D00FD44  AF828058   SW V0, -32680(GP)
9D00FD48  26638FD8   ADDIU V1, S3, -28712
9D00FD4C  8C640054   LW A0, 84(V1)
9D00FD50  24840005   ADDIU A0, A0, 5
2036:                         OPCODE_END
9D00FD54  18400E42   BLEZ V0, .L45
9D00FD58  AC640054   SW A0, 84(V1)
9D00FD5C  26100003   ADDIU S0, S0, 3
9D00FD7C  90420000   LBU V0, 0(V0)
9D00FD80  00021080   SLL V0, V0, 2
9D00FD84  00561021   ADDU V0, V0, S6
9D00FD88  0B402953   J 0x9D00A54C
9D00FD8C  8C420000   LW V0, 0(V0)
2037:                
2038:                      OPCODE_BEGIN(9C)  /* SHY $nnnn,X */
2039:                         SHY(5, ABS_IND_X_ADDR, mem_writebyte, addr);
9D00FD90  0F402863   JAL bank_readword
9D00FD94  02002021   ADDU A0, S0, ZERO
9D00FD98  26110002   ADDIU S1, S0, 2
9D00FD9C  005E1021   ADDU V0, V0, FP
9D00FDA0  3044FFFF   ANDI A0, V0, -1
9D00FDA4  00042A02   SRL A1, A0, 8
9D00FDA8  24A50001   ADDIU A1, A1, 1
9D00FDAC  8FA60010   LW A2, 16(SP)
9D00FDB0  00C52824   AND A1, A2, A1
9D00FDB4  0F40283A   JAL mem_writebyte
9D00FDB8  30A500FF   ANDI A1, A1, 255
9D00FDBC  8F828058   LW V0, -32680(GP)
9D00FDC0  2442FFFB   ADDIU V0, V0, -5
9D00FDC4  AF828058   SW V0, -32680(GP)
9D00FDC8  26638FD8   ADDIU V1, S3, -28712
9D00FDCC  8C640054   LW A0, 84(V1)
9D00FDD0  24840005   ADDIU A0, A0, 5
2040:                         OPCODE_END
9D00FDD4  18400E22   BLEZ V0, .L45
9D00FDD8  AC640054   SW A0, 84(V1)
9D00FDDC  26100003   ADDIU S0, S0, 3
9D00FDFC  90420000   LBU V0, 0(V0)
9D00FE00  00021080   SLL V0, V0, 2
9D00FE04  00561021   ADDU V0, V0, S6
9D00FE08  0B402953   J 0x9D00A54C
9D00FE0C  8C420000   LW V0, 0(V0)
2041:                
2042:                      OPCODE_BEGIN(9D)  /* STA $nnnn,X */
2043:                         STA(5, ABS_IND_X_ADDR, mem_writebyte, addr);
9D00FE10  0F402863   JAL bank_readword
9D00FE14  02002021   ADDU A0, S0, ZERO
9D00FE18  26110002   ADDIU S1, S0, 2
9D00FE1C  005E1021   ADDU V0, V0, FP
9D00FE20  3044FFFF   ANDI A0, V0, -1
9D00FE24  0F40283A   JAL mem_writebyte
9D00FE28  02802821   ADDU A1, S4, ZERO
9D00FE2C  8F828058   LW V0, -32680(GP)
9D00FE30  2442FFFB   ADDIU V0, V0, -5
9D00FE34  AF828058   SW V0, -32680(GP)
9D00FE38  26638FD8   ADDIU V1, S3, -28712
9D00FE3C  8C640054   LW A0, 84(V1)
9D00FE40  24840005   ADDIU A0, A0, 5
2044:                         OPCODE_END
9D00FE44  18400E06   BLEZ V0, .L45
9D00FE48  AC640054   SW A0, 84(V1)
9D00FE4C  26100003   ADDIU S0, S0, 3
9D00FE6C  90420000   LBU V0, 0(V0)
9D00FE70  00021080   SLL V0, V0, 2
9D00FE74  00561021   ADDU V0, V0, S6
9D00FE78  0B402953   J 0x9D00A54C
9D00FE7C  8C420000   LW V0, 0(V0)
2045:                
2046:                      OPCODE_BEGIN(9E)  /* SHX $nnnn,Y */
2047:                         SHX(5, ABS_IND_Y_ADDR, mem_writebyte, addr);
9D00FE80  0F402863   JAL bank_readword
9D00FE84  02002021   ADDU A0, S0, ZERO
9D00FE88  26110002   ADDIU S1, S0, 2
9D00FE8C  8FA70010   LW A3, 16(SP)
9D00FE90  00471021   ADDU V0, V0, A3
9D00FE94  3044FFFF   ANDI A0, V0, -1
9D00FE98  00042A02   SRL A1, A0, 8
9D00FE9C  24A50001   ADDIU A1, A1, 1
9D00FEA0  03C52824   AND A1, FP, A1
9D00FEA4  0F40283A   JAL mem_writebyte
9D00FEA8  30A500FF   ANDI A1, A1, 255
9D00FEAC  8F828058   LW V0, -32680(GP)
9D00FEB0  2442FFFB   ADDIU V0, V0, -5
9D00FEB4  AF828058   SW V0, -32680(GP)
9D00FEB8  26638FD8   ADDIU V1, S3, -28712
9D00FEBC  8C640054   LW A0, 84(V1)
9D00FEC0  24840005   ADDIU A0, A0, 5
2048:                         OPCODE_END
9D00FEC4  18400DE6   BLEZ V0, .L45
9D00FEC8  AC640054   SW A0, 84(V1)
9D00FECC  26100003   ADDIU S0, S0, 3
9D00FEEC  90420000   LBU V0, 0(V0)
9D00FEF0  00021080   SLL V0, V0, 2
9D00FEF4  00561021   ADDU V0, V0, S6
9D00FEF8  0B402953   J 0x9D00A54C
9D00FEFC  8C420000   LW V0, 0(V0)
2049:                
2050:                      OPCODE_BEGIN(9F)  /* SHA $nnnn,Y */
2051:                         SHA(5, ABS_IND_Y_ADDR, mem_writebyte, addr);
9D00FF00  0F402863   JAL bank_readword
9D00FF04  02002021   ADDU A0, S0, ZERO
9D00FF08  26110002   ADDIU S1, S0, 2
9D00FF0C  8FA30010   LW V1, 16(SP)
9D00FF10  00431021   ADDU V0, V0, V1
9D00FF14  3044FFFF   ANDI A0, V0, -1
9D00FF18  03D42824   AND A1, FP, S4
9D00FF1C  00041202   SRL V0, A0, 8
9D00FF20  24420001   ADDIU V0, V0, 1
9D00FF24  00A22824   AND A1, A1, V0
9D00FF28  0F40283A   JAL mem_writebyte
9D00FF2C  30A500FF   ANDI A1, A1, 255
9D00FF30  8F828058   LW V0, -32680(GP)
9D00FF34  2442FFFB   ADDIU V0, V0, -5
9D00FF38  AF828058   SW V0, -32680(GP)
9D00FF3C  26638FD8   ADDIU V1, S3, -28712
9D00FF40  8C640054   LW A0, 84(V1)
9D00FF44  24840005   ADDIU A0, A0, 5
2052:                         OPCODE_END
9D00FF48  18400DC5   BLEZ V0, .L45
9D00FF4C  AC640054   SW A0, 84(V1)
9D00FF50  26100003   ADDIU S0, S0, 3
9D00FF70  90420000   LBU V0, 0(V0)
9D00FF74  00021080   SLL V0, V0, 2
9D00FF78  00561021   ADDU V0, V0, S6
9D00FF7C  0B402953   J 0x9D00A54C
9D00FF80  8C420000   LW V0, 0(V0)
2053:                      
2054:                      OPCODE_BEGIN(A0)  /* LDY #$nn */
2055:                         LDY(2, IMMEDIATE_BYTE);
9D00FF84  26110001   ADDIU S1, S0, 1
9D00FFA8  8F838058   LW V1, -32680(GP)
9D00FFAC  2463FFFE   ADDIU V1, V1, -2
9D00FFB0  AF838058   SW V1, -32680(GP)
9D00FFB4  8C440054   LW A0, 84(V0)
9D00FFB8  24840002   ADDIU A0, A0, 2
2056:                         OPCODE_END
9D00FFBC  1C600004   BGTZ V1, 0x9D00FFD0
9D00FFC0  AC440054   SW A0, 84(V0)
9D00FFD0  26100002   ADDIU S0, S0, 2
9D00FFF0  90420000   LBU V0, 0(V0)
9D00FFF4  00021080   SLL V0, V0, 2
9D00FFF8  00561021   ADDU V0, V0, S6
9D00FFFC  8C420000   LW V0, 0(V0)
9D010004  0B402953   J 0x9D00A54C
9D010008  0240A821   ADDU S5, S2, ZERO
2057:                
2058:                      OPCODE_BEGIN(A1)  /* LDA ($nn,X) */
2059:                         LDA(6, INDIR_X_BYTE);
9D01000C  26110001   ADDIU S1, S0, 1
9D01002C  90420000   LBU V0, 0(V0)
9D010030  03C21021   ADDU V0, FP, V0
9D01004C  0F402804   JAL mem_readbyte
9D010050  308400FF   ANDI A0, A0, 255
9D010054  00409021   ADDU S2, V0, ZERO
9D010058  8F828058   LW V0, -32680(GP)
9D01005C  2442FFFA   ADDIU V0, V0, -6
9D010060  AF828058   SW V0, -32680(GP)
9D010064  8E830054   LW V1, 84(S4)
9D010068  24630006   ADDIU V1, V1, 6
9D010074  0240A021   ADDU S4, S2, ZERO
9D010078  0B404D98   J .L45
9D01007C  0240A821   ADDU S5, S2, ZERO
9D0100B0  0240A021   ADDU S4, S2, ZERO
2060:                         OPCODE_END
9D01006C  1C400004   BGTZ V0, 0x9D010080
9D010070  AE830054   SW V1, 84(S4)
9D010080  26100002   ADDIU S0, S0, 2
9D0100A0  90420000   LBU V0, 0(V0)
9D0100A4  00021080   SLL V0, V0, 2
9D0100A8  00561021   ADDU V0, V0, S6
9D0100AC  8C420000   LW V0, 0(V0)
9D0100B4  0B402953   J 0x9D00A54C
9D0100B8  0240A821   ADDU S5, S2, ZERO
2061:                
2062:                      OPCODE_BEGIN(A2)  /* LDX #$nn */
2063:                         LDX(2, IMMEDIATE_BYTE);
9D0100BC  26110001   ADDIU S1, S0, 1
9D0100E0  8F838058   LW V1, -32680(GP)
9D0100E4  2463FFFE   ADDIU V1, V1, -2
9D0100E8  AF838058   SW V1, -32680(GP)
9D0100EC  8C440054   LW A0, 84(V0)
9D0100F0  24840002   ADDIU A0, A0, 2
2064:                         OPCODE_END
9D0100F4  1C600004   BGTZ V1, 0x9D010108
9D0100F8  AC440054   SW A0, 84(V0)
9D010108  26100002   ADDIU S0, S0, 2
9D010128  90420000   LBU V0, 0(V0)
9D01012C  00021080   SLL V0, V0, 2
9D010130  00561021   ADDU V0, V0, S6
9D010134  8C420000   LW V0, 0(V0)
9D01013C  0B402953   J 0x9D00A54C
9D010140  0240A821   ADDU S5, S2, ZERO
2065:                
2066:                      OPCODE_BEGIN(A3)  /* LAX ($nn,X) */
2067:                         LAX(6, INDIR_X_BYTE);
9D010144  26110001   ADDIU S1, S0, 1
9D010164  90420000   LBU V0, 0(V0)
9D010168  03C21021   ADDU V0, FP, V0
9D010184  0F402804   JAL mem_readbyte
9D010188  308400FF   ANDI A0, A0, 255
9D01018C  00409021   ADDU S2, V0, ZERO
9D010190  8F828058   LW V0, -32680(GP)
9D010194  2442FFFA   ADDIU V0, V0, -6
9D010198  AF828058   SW V0, -32680(GP)
9D01019C  8E830054   LW V1, 84(S4)
9D0101A0  24630006   ADDIU V1, V1, 6
9D0101AC  0240F021   ADDU FP, S2, ZERO
9D0101B0  0240A021   ADDU S4, S2, ZERO
9D0101B4  0B404D98   J .L45
9D0101B8  0240A821   ADDU S5, S2, ZERO
9D0101EC  0240F021   ADDU FP, S2, ZERO
9D0101F0  0240A021   ADDU S4, S2, ZERO
2068:                         OPCODE_END
9D0101A4  1C400005   BGTZ V0, 0x9D0101BC
9D0101A8  AE830054   SW V1, 84(S4)
9D0101BC  26100002   ADDIU S0, S0, 2
9D0101DC  90420000   LBU V0, 0(V0)
9D0101E0  00021080   SLL V0, V0, 2
9D0101E4  00561021   ADDU V0, V0, S6
9D0101E8  8C420000   LW V0, 0(V0)
9D0101F4  0B402953   J 0x9D00A54C
9D0101F8  0240A821   ADDU S5, S2, ZERO
2069:                
2070:                      OPCODE_BEGIN(A4)  /* LDY $nn */
2071:                         LDY(3, ZERO_PAGE_BYTE);
9D0101FC  26110001   ADDIU S1, S0, 1
9D01021C  90630000   LBU V1, 0(V1)
9D010220  8F848054   LW A0, -32684(GP)
9D010224  00831821   ADDU V1, A0, V1
9D010228  90720000   LBU S2, 0(V1)
9D01022C  8F838058   LW V1, -32680(GP)
9D010230  2463FFFD   ADDIU V1, V1, -3
9D010234  AF838058   SW V1, -32680(GP)
9D010238  8C440054   LW A0, 84(V0)
9D01023C  24840003   ADDIU A0, A0, 3
9D010248  AFB20010   SW S2, 16(SP)
9D01024C  0B404D98   J .L45
9D010250  0240A821   ADDU S5, S2, ZERO
9D010284  AFB20010   SW S2, 16(SP)
2072:                         OPCODE_END
9D010240  1C600004   BGTZ V1, 0x9D010254
9D010244  AC440054   SW A0, 84(V0)
9D010254  26100002   ADDIU S0, S0, 2
9D010274  90420000   LBU V0, 0(V0)
9D010278  00021080   SLL V0, V0, 2
9D01027C  00561021   ADDU V0, V0, S6
9D010280  8C420000   LW V0, 0(V0)
9D010288  0B402953   J 0x9D00A54C
9D01028C  0240A821   ADDU S5, S2, ZERO
2073:                
2074:                      OPCODE_BEGIN(A5)  /* LDA $nn */
2075:                         LDA(3, ZERO_PAGE_BYTE);
9D010290  26110001   ADDIU S1, S0, 1
9D0102B0  90630000   LBU V1, 0(V1)
9D0102B4  8F848054   LW A0, -32684(GP)
9D0102B8  00831821   ADDU V1, A0, V1
9D0102BC  90720000   LBU S2, 0(V1)
9D0102C0  8F838058   LW V1, -32680(GP)
9D0102C4  2463FFFD   ADDIU V1, V1, -3
9D0102C8  AF838058   SW V1, -32680(GP)
9D0102CC  8C440054   LW A0, 84(V0)
9D0102D0  24840003   ADDIU A0, A0, 3
9D0102DC  0240A021   ADDU S4, S2, ZERO
9D0102E0  0B404D98   J .L45
9D0102E4  0240A821   ADDU S5, S2, ZERO
9D010318  0240A021   ADDU S4, S2, ZERO
2076:                         OPCODE_END
9D0102D4  1C600004   BGTZ V1, 0x9D0102E8
9D0102D8  AC440054   SW A0, 84(V0)
9D0102E8  26100002   ADDIU S0, S0, 2
9D010308  90420000   LBU V0, 0(V0)
9D01030C  00021080   SLL V0, V0, 2
9D010310  00561021   ADDU V0, V0, S6
9D010314  8C420000   LW V0, 0(V0)
9D01031C  0B402953   J 0x9D00A54C
9D010320  0240A821   ADDU S5, S2, ZERO
2077:                
2078:                      OPCODE_BEGIN(A6)  /* LDX $nn */
2079:                         LDX(3, ZERO_PAGE_BYTE);
9D010324  26110001   ADDIU S1, S0, 1
9D010344  90630000   LBU V1, 0(V1)
9D010348  8F848054   LW A0, -32684(GP)
9D01034C  00831821   ADDU V1, A0, V1
9D010350  90720000   LBU S2, 0(V1)
9D010354  8F838058   LW V1, -32680(GP)
9D010358  2463FFFD   ADDIU V1, V1, -3
9D01035C  AF838058   SW V1, -32680(GP)
9D010360  8C440054   LW A0, 84(V0)
9D010364  24840003   ADDIU A0, A0, 3
9D010370  0240F021   ADDU FP, S2, ZERO
9D010374  0B404D98   J .L45
9D010378  0240A821   ADDU S5, S2, ZERO
9D0103AC  0240F021   ADDU FP, S2, ZERO
2080:                         OPCODE_END
9D010368  1C600004   BGTZ V1, 0x9D01037C
9D01036C  AC440054   SW A0, 84(V0)
9D01037C  26100002   ADDIU S0, S0, 2
9D01039C  90420000   LBU V0, 0(V0)
9D0103A0  00021080   SLL V0, V0, 2
9D0103A4  00561021   ADDU V0, V0, S6
9D0103A8  8C420000   LW V0, 0(V0)
9D0103B0  0B402953   J 0x9D00A54C
9D0103B4  0240A821   ADDU S5, S2, ZERO
2081:                
2082:                      OPCODE_BEGIN(A7)  /* LAX $nn */
2083:                         LAX(3, ZERO_PAGE_BYTE);
9D0103B8  26110001   ADDIU S1, S0, 1
9D0103D8  90630000   LBU V1, 0(V1)
9D0103DC  8F848054   LW A0, -32684(GP)
9D0103E0  00831821   ADDU V1, A0, V1
9D0103E4  90720000   LBU S2, 0(V1)
9D0103E8  8F838058   LW V1, -32680(GP)
9D0103EC  2463FFFD   ADDIU V1, V1, -3
9D0103F0  AF838058   SW V1, -32680(GP)
9D0103F4  8C440054   LW A0, 84(V0)
9D0103F8  24840003   ADDIU A0, A0, 3
9D010404  0240F021   ADDU FP, S2, ZERO
9D010408  0240A021   ADDU S4, S2, ZERO
9D01040C  0B404D98   J .L45
9D010410  0240A821   ADDU S5, S2, ZERO
9D010444  0240F021   ADDU FP, S2, ZERO
9D010448  0240A021   ADDU S4, S2, ZERO
2084:                         OPCODE_END
9D0103FC  1C600005   BGTZ V1, 0x9D010414
9D010400  AC440054   SW A0, 84(V0)
9D010414  26100002   ADDIU S0, S0, 2
9D010434  90420000   LBU V0, 0(V0)
9D010438  00021080   SLL V0, V0, 2
9D01043C  00561021   ADDU V0, V0, S6
9D010440  8C420000   LW V0, 0(V0)
9D01044C  0B402953   J 0x9D00A54C
9D010450  0240A821   ADDU S5, S2, ZERO
2085:                
2086:                      OPCODE_BEGIN(A8)  /* TAY */
2087:                         TAY();
9D010454  8F828058   LW V0, -32680(GP)
9D010458  2442FFFE   ADDIU V0, V0, -2
9D01045C  AF828058   SW V0, -32680(GP)
9D010460  26638FD8   ADDIU V1, S3, -28712
9D010464  8C640054   LW A0, 84(V1)
9D010468  24840002   ADDIU A0, A0, 2
2088:                         OPCODE_END
9D01046C  1C400006   BGTZ V0, .LBB1262
9D010470  AC640054   SW A0, 84(V1)
9D010474  02809021   ADDU S2, S4, ZERO
9D010478  AFB40010   SW S4, 16(SP)
9D01047C  02008821   ADDU S1, S0, ZERO
9D010480  0B404D98   J .L45
9D010484  0280A821   ADDU S5, S4, ZERO
9D0104A4  90420000   LBU V0, 0(V0)
9D0104A8  00021080   SLL V0, V0, 2
9D0104AC  00561021   ADDU V0, V0, S6
9D0104B0  8C420000   LW V0, 0(V0)
9D0104B4  AFB40010   SW S4, 16(SP)
9D0104B8  26100001   ADDIU S0, S0, 1
9D0104BC  0280A821   ADDU S5, S4, ZERO
9D0104C0  0B402953   J 0x9D00A54C
9D0104C4  02809021   ADDU S2, S4, ZERO
2089:                
2090:                      OPCODE_BEGIN(A9)  /* LDA #$nn */
2091:                         LDA(2, IMMEDIATE_BYTE);
9D0104C8  26110001   ADDIU S1, S0, 1
9D0104EC  8F838058   LW V1, -32680(GP)
9D0104F0  2463FFFE   ADDIU V1, V1, -2
9D0104F4  AF838058   SW V1, -32680(GP)
9D0104F8  8C440054   LW A0, 84(V0)
9D0104FC  24840002   ADDIU A0, A0, 2
2092:                         OPCODE_END
9D010500  1C600004   BGTZ V1, 0x9D010514
9D010504  AC440054   SW A0, 84(V0)
9D010514  26100002   ADDIU S0, S0, 2
9D010534  90420000   LBU V0, 0(V0)
9D010538  00021080   SLL V0, V0, 2
9D01053C  00561021   ADDU V0, V0, S6
9D010540  8C420000   LW V0, 0(V0)
9D010548  0B402953   J 0x9D00A54C
9D01054C  0240A821   ADDU S5, S2, ZERO
2093:                
2094:                      OPCODE_BEGIN(AA)  /* TAX */
2095:                         TAX();
9D010550  8F828058   LW V0, -32680(GP)
9D010554  2442FFFE   ADDIU V0, V0, -2
9D010558  AF828058   SW V0, -32680(GP)
9D01055C  26638FD8   ADDIU V1, S3, -28712
9D010560  8C640054   LW A0, 84(V1)
9D010564  24840002   ADDIU A0, A0, 2
2096:                         OPCODE_END
9D010568  1C400006   BGTZ V0, .LBB1272
9D01056C  AC640054   SW A0, 84(V1)
9D010570  02809021   ADDU S2, S4, ZERO
9D010574  0280F021   ADDU FP, S4, ZERO
9D010578  02008821   ADDU S1, S0, ZERO
9D01057C  0B404D98   J .L45
9D010580  0280A821   ADDU S5, S4, ZERO
9D0105A0  90420000   LBU V0, 0(V0)
9D0105A4  00021080   SLL V0, V0, 2
9D0105A8  00561021   ADDU V0, V0, S6
9D0105AC  8C420000   LW V0, 0(V0)
9D0105B0  0280F021   ADDU FP, S4, ZERO
9D0105B4  26100001   ADDIU S0, S0, 1
9D0105B8  0280A821   ADDU S5, S4, ZERO
9D0105BC  0B402953   J 0x9D00A54C
9D0105C0  02809021   ADDU S2, S4, ZERO
2097:                
2098:                      OPCODE_BEGIN(AB)  /* LXA #$nn */
2099:                         LXA(2, IMMEDIATE_BYTE);
9D0105C4  26110001   ADDIU S1, S0, 1
9D0105C8  2404FFEE   ADDIU A0, ZERO, -18
9D0105CC  02849025   OR S2, S4, A0
9D0105EC  90630000   LBU V1, 0(V1)
9D0105F0  02439024   AND S2, S2, V1
9D0105F4  8F838058   LW V1, -32680(GP)
9D0105F8  2463FFFE   ADDIU V1, V1, -2
9D0105FC  AF838058   SW V1, -32680(GP)
9D010600  8C440054   LW A0, 84(V0)
9D010604  24840002   ADDIU A0, A0, 2
9D010610  0240F021   ADDU FP, S2, ZERO
9D010614  0240A021   ADDU S4, S2, ZERO
9D010618  0B404D98   J .L45
9D01061C  0240A821   ADDU S5, S2, ZERO
9D010650  0240F021   ADDU FP, S2, ZERO
9D010654  0240A021   ADDU S4, S2, ZERO
2100:                         OPCODE_END
9D010608  1C600005   BGTZ V1, 0x9D010620
9D01060C  AC440054   SW A0, 84(V0)
9D010620  26100002   ADDIU S0, S0, 2
9D010640  90420000   LBU V0, 0(V0)
9D010644  00021080   SLL V0, V0, 2
9D010648  00561021   ADDU V0, V0, S6
9D01064C  8C420000   LW V0, 0(V0)
9D010658  0B402953   J 0x9D00A54C
9D01065C  0240A821   ADDU S5, S2, ZERO
2101:                
2102:                      OPCODE_BEGIN(AC)  /* LDY $nnnn */
2103:                         LDY(4, ABSOLUTE_BYTE);
9D010660  0F402863   JAL bank_readword
9D010664  02002021   ADDU A0, S0, ZERO
9D010668  26110002   ADDIU S1, S0, 2
9D01066C  0F402804   JAL mem_readbyte
9D010670  00402021   ADDU A0, V0, ZERO
9D010674  00409021   ADDU S2, V0, ZERO
9D010678  8F828058   LW V0, -32680(GP)
9D01067C  2442FFFC   ADDIU V0, V0, -4
9D010680  AF828058   SW V0, -32680(GP)
9D010684  26638FD8   ADDIU V1, S3, -28712
9D010688  8C640054   LW A0, 84(V1)
9D01068C  24840004   ADDIU A0, A0, 4
9D010698  AFB20010   SW S2, 16(SP)
9D01069C  0B404D98   J .L45
9D0106A0  0240A821   ADDU S5, S2, ZERO
9D0106D4  AFB20010   SW S2, 16(SP)
2104:                         OPCODE_END
9D010690  1C400004   BGTZ V0, 0x9D0106A4
9D010694  AC640054   SW A0, 84(V1)
9D0106A4  26100003   ADDIU S0, S0, 3
9D0106C4  90420000   LBU V0, 0(V0)
9D0106C8  00021080   SLL V0, V0, 2
9D0106CC  00561021   ADDU V0, V0, S6
9D0106D0  8C420000   LW V0, 0(V0)
9D0106D8  0B402953   J 0x9D00A54C
9D0106DC  0240A821   ADDU S5, S2, ZERO
2105:                
2106:                      OPCODE_BEGIN(AD)  /* LDA $nnnn */
2107:                         LDA(4, ABSOLUTE_BYTE);
9D0106E0  0F402863   JAL bank_readword
9D0106E4  02002021   ADDU A0, S0, ZERO
9D0106E8  26110002   ADDIU S1, S0, 2
9D0106EC  0F402804   JAL mem_readbyte
9D0106F0  00402021   ADDU A0, V0, ZERO
9D0106F4  00409021   ADDU S2, V0, ZERO
9D0106F8  8F828058   LW V0, -32680(GP)
9D0106FC  2442FFFC   ADDIU V0, V0, -4
9D010700  AF828058   SW V0, -32680(GP)
9D010704  26638FD8   ADDIU V1, S3, -28712
9D010708  8C640054   LW A0, 84(V1)
9D01070C  24840004   ADDIU A0, A0, 4
9D010718  0240A021   ADDU S4, S2, ZERO
9D01071C  0B404D98   J .L45
9D010720  0240A821   ADDU S5, S2, ZERO
9D010754  0240A021   ADDU S4, S2, ZERO
2108:                         OPCODE_END
9D010710  1C400004   BGTZ V0, 0x9D010724
9D010714  AC640054   SW A0, 84(V1)
9D010724  26100003   ADDIU S0, S0, 3
9D010744  90420000   LBU V0, 0(V0)
9D010748  00021080   SLL V0, V0, 2
9D01074C  00561021   ADDU V0, V0, S6
9D010750  8C420000   LW V0, 0(V0)
9D010758  0B402953   J 0x9D00A54C
9D01075C  0240A821   ADDU S5, S2, ZERO
2109:                      
2110:                      OPCODE_BEGIN(AE)  /* LDX $nnnn */
2111:                         LDX(4, ABSOLUTE_BYTE);
9D010760  0F402863   JAL bank_readword
9D010764  02002021   ADDU A0, S0, ZERO
9D010768  26110002   ADDIU S1, S0, 2
9D01076C  0F402804   JAL mem_readbyte
9D010770  00402021   ADDU A0, V0, ZERO
9D010774  00409021   ADDU S2, V0, ZERO
9D010778  8F828058   LW V0, -32680(GP)
9D01077C  2442FFFC   ADDIU V0, V0, -4
9D010780  AF828058   SW V0, -32680(GP)
9D010784  26638FD8   ADDIU V1, S3, -28712
9D010788  8C640054   LW A0, 84(V1)
9D01078C  24840004   ADDIU A0, A0, 4
9D010798  0240F021   ADDU FP, S2, ZERO
9D01079C  0B404D98   J .L45
9D0107A0  0240A821   ADDU S5, S2, ZERO
9D0107D4  0240F021   ADDU FP, S2, ZERO
2112:                         OPCODE_END
9D010790  1C400004   BGTZ V0, 0x9D0107A4
9D010794  AC640054   SW A0, 84(V1)
9D0107A4  26100003   ADDIU S0, S0, 3
9D0107C4  90420000   LBU V0, 0(V0)
9D0107C8  00021080   SLL V0, V0, 2
9D0107CC  00561021   ADDU V0, V0, S6
9D0107D0  8C420000   LW V0, 0(V0)
9D0107D8  0B402953   J 0x9D00A54C
9D0107DC  0240A821   ADDU S5, S2, ZERO
2113:                
2114:                      OPCODE_BEGIN(AF)  /* LAX $nnnn */
2115:                         LAX(4, ABSOLUTE_BYTE);
9D0107E0  0F402863   JAL bank_readword
9D0107E4  02002021   ADDU A0, S0, ZERO
9D0107E8  26110002   ADDIU S1, S0, 2
9D0107EC  0F402804   JAL mem_readbyte
9D0107F0  00402021   ADDU A0, V0, ZERO
9D0107F4  00409021   ADDU S2, V0, ZERO
9D0107F8  8F828058   LW V0, -32680(GP)
9D0107FC  2442FFFC   ADDIU V0, V0, -4
9D010800  AF828058   SW V0, -32680(GP)
9D010804  26638FD8   ADDIU V1, S3, -28712
9D010808  8C640054   LW A0, 84(V1)
9D01080C  24840004   ADDIU A0, A0, 4
9D010818  0240F021   ADDU FP, S2, ZERO
9D01081C  0240A021   ADDU S4, S2, ZERO
9D010820  0B404D98   J .L45
9D010824  0240A821   ADDU S5, S2, ZERO
9D010858  0240F021   ADDU FP, S2, ZERO
9D01085C  0240A021   ADDU S4, S2, ZERO
2116:                         OPCODE_END
9D010810  1C400005   BGTZ V0, 0x9D010828
9D010814  AC640054   SW A0, 84(V1)
9D010828  26100003   ADDIU S0, S0, 3
9D010848  90420000   LBU V0, 0(V0)
9D01084C  00021080   SLL V0, V0, 2
9D010850  00561021   ADDU V0, V0, S6
9D010854  8C420000   LW V0, 0(V0)
9D010860  0B402953   J 0x9D00A54C
9D010864  0240A821   ADDU S5, S2, ZERO
2117:                
2118:                      OPCODE_BEGIN(B0)  /* BCS $nnnn */
2119:                         BCS();
9D010868  12E0001E   BEQ S7, ZERO, 0x9D0108E4
9D01086C  26110001   ADDIU S1, S0, 1
9D010870  26020001   ADDIU V0, S0, 1
9D010890  80710000   LB S1, 0(V1)
9D010894  304300FF   ANDI V1, V0, 255
9D010898  02231821   ADDU V1, S1, V1
9D01089C  30630100   ANDI V1, V1, 256
9D0108A0  10600008   BEQ V1, ZERO, 0x9D0108C4
9D0108A4  8F838058   LW V1, -32680(GP)
9D0108A8  2463FFFF   ADDIU V1, V1, -1
9D0108AC  AF838058   SW V1, -32680(GP)
9D0108B0  26638FD8   ADDIU V1, S3, -28712
9D0108B4  8C640054   LW A0, 84(V1)
9D0108B8  24840001   ADDIU A0, A0, 1
9D0108BC  AC640054   SW A0, 84(V1)
9D0108C0  8F838058   LW V1, -32680(GP)
9D0108C4  2463FFFD   ADDIU V1, V1, -3
9D0108C8  AF838058   SW V1, -32680(GP)
9D0108CC  26638FD8   ADDIU V1, S3, -28712
9D0108D0  8C640054   LW A0, 84(V1)
9D0108D4  24840003   ADDIU A0, A0, 3
9D0108D8  AC640054   SW A0, 84(V1)
9D0108DC  0B404240   J 0x9D010900
9D0108E0  02228821   ADDU S1, S1, V0
9D0108E4  8F828058   LW V0, -32680(GP)
9D0108E8  2442FFFE   ADDIU V0, V0, -2
9D0108EC  AF828058   SW V0, -32680(GP)
9D0108F0  26628FD8   ADDIU V0, S3, -28712
9D0108F4  8C430054   LW V1, 84(V0)
9D0108F8  24630002   ADDIU V1, V1, 2
9D0108FC  AC430054   SW V1, 84(V0)
2120:                         OPCODE_END
9D010900  8F828058   LW V0, -32680(GP)
9D010904  18400B56   BLEZ V0, .L45
9D010908  26300001   ADDIU S0, S1, 1
9D010928  90420000   LBU V0, 0(V0)
9D01092C  00021080   SLL V0, V0, 2
9D010930  00561021   ADDU V0, V0, S6
9D010934  0B402953   J 0x9D00A54C
9D010938  8C420000   LW V0, 0(V0)
2121:                
2122:                      OPCODE_BEGIN(B1)  /* LDA ($nn),Y */
2123:                         LDA(5, INDIR_Y_BYTE_READ);
9D010974  8FA50010   LW A1, 16(SP)
9D010978  00852021   ADDU A0, A0, A1
9D01097C  3084FFFF   ANDI A0, A0, -1
9D010980  308200FF   ANDI V0, A0, 255
9D010984  0045102B   SLTU V0, V0, A1
9D010988  10400008   BEQ V0, ZERO, 0x9D0109AC
9D01098C  26110001   ADDIU S1, S0, 1
9D010990  8F828058   LW V0, -32680(GP)
9D010994  2442FFFF   ADDIU V0, V0, -1
9D010998  AF828058   SW V0, -32680(GP)
9D01099C  26628FD8   ADDIU V0, S3, -28712
9D0109A0  8C430054   LW V1, 84(V0)
9D0109A4  24630001   ADDIU V1, V1, 1
9D0109A8  AC430054   SW V1, 84(V0)
9D0109AC  0F402804   JAL mem_readbyte
9D0109B0  00000000   NOP
9D0109B4  00409021   ADDU S2, V0, ZERO
9D0109B8  8F828058   LW V0, -32680(GP)
9D0109BC  2442FFFB   ADDIU V0, V0, -5
9D0109C0  AF828058   SW V0, -32680(GP)
9D0109C4  26638FD8   ADDIU V1, S3, -28712
9D0109C8  8C640054   LW A0, 84(V1)
9D0109CC  24840005   ADDIU A0, A0, 5
9D0109D8  0240A021   ADDU S4, S2, ZERO
9D0109DC  0B404D98   J .L45
9D0109E0  0240A821   ADDU S5, S2, ZERO
9D010A14  0240A021   ADDU S4, S2, ZERO
2124:                         OPCODE_END
9D0109D0  1C400004   BGTZ V0, 0x9D0109E4
9D0109D4  AC640054   SW A0, 84(V1)
9D0109E4  26100002   ADDIU S0, S0, 2
9D010A04  90420000   LBU V0, 0(V0)
9D010A08  00021080   SLL V0, V0, 2
9D010A0C  00561021   ADDU V0, V0, S6
9D010A10  8C420000   LW V0, 0(V0)
9D010A18  0B402953   J 0x9D00A54C
9D010A1C  0240A821   ADDU S5, S2, ZERO
2125:                
2126:                      OPCODE_BEGIN(B3)  /* LAX ($nn),Y */
2127:                         LAX(5, INDIR_Y_BYTE_READ);
9D010A58  8FA60010   LW A2, 16(SP)
9D010A5C  00862021   ADDU A0, A0, A2
9D010A60  3084FFFF   ANDI A0, A0, -1
9D010A64  308200FF   ANDI V0, A0, 255
9D010A68  0046102B   SLTU V0, V0, A2
9D010A6C  10400008   BEQ V0, ZERO, 0x9D010A90
9D010A70  26110001   ADDIU S1, S0, 1
9D010A74  8F828058   LW V0, -32680(GP)
9D010A78  2442FFFF   ADDIU V0, V0, -1
9D010A7C  AF828058   SW V0, -32680(GP)
9D010A80  26628FD8   ADDIU V0, S3, -28712
9D010A84  8C430054   LW V1, 84(V0)
9D010A88  24630001   ADDIU V1, V1, 1
9D010A8C  AC430054   SW V1, 84(V0)
9D010A90  0F402804   JAL mem_readbyte
9D010A94  00000000   NOP
9D010A98  00409021   ADDU S2, V0, ZERO
9D010A9C  8F828058   LW V0, -32680(GP)
9D010AA0  2442FFFB   ADDIU V0, V0, -5
9D010AA4  AF828058   SW V0, -32680(GP)
9D010AA8  26638FD8   ADDIU V1, S3, -28712
9D010AAC  8C640054   LW A0, 84(V1)
9D010AB0  24840005   ADDIU A0, A0, 5
9D010ABC  0240F021   ADDU FP, S2, ZERO
9D010AC0  0240A021   ADDU S4, S2, ZERO
9D010AC4  0B404D98   J .L45
9D010AC8  0240A821   ADDU S5, S2, ZERO
9D010AFC  0240F021   ADDU FP, S2, ZERO
9D010B00  0240A021   ADDU S4, S2, ZERO
2128:                         OPCODE_END
9D010AB4  1C400005   BGTZ V0, 0x9D010ACC
9D010AB8  AC640054   SW A0, 84(V1)
9D010ACC  26100002   ADDIU S0, S0, 2
9D010AEC  90420000   LBU V0, 0(V0)
9D010AF0  00021080   SLL V0, V0, 2
9D010AF4  00561021   ADDU V0, V0, S6
9D010AF8  8C420000   LW V0, 0(V0)
9D010B04  0B402953   J 0x9D00A54C
9D010B08  0240A821   ADDU S5, S2, ZERO
2129:                
2130:                      OPCODE_BEGIN(B4)  /* LDY $nn,X */
2131:                         LDY(4, ZP_IND_X_BYTE);
9D010B0C  26110001   ADDIU S1, S0, 1
9D010B2C  90630000   LBU V1, 0(V1)
9D010B30  03C31821   ADDU V1, FP, V1
9D010B34  306300FF   ANDI V1, V1, 255
9D010B38  8F848054   LW A0, -32684(GP)
9D010B3C  00831821   ADDU V1, A0, V1
9D010B40  90720000   LBU S2, 0(V1)
9D010B44  8F838058   LW V1, -32680(GP)
9D010B48  2463FFFC   ADDIU V1, V1, -4
9D010B4C  AF838058   SW V1, -32680(GP)
9D010B50  8C440054   LW A0, 84(V0)
9D010B54  24840004   ADDIU A0, A0, 4
9D010B60  AFB20010   SW S2, 16(SP)
9D010B64  0B404D98   J .L45
9D010B68  0240A821   ADDU S5, S2, ZERO
9D010B9C  AFB20010   SW S2, 16(SP)
2132:                         OPCODE_END
9D010B58  1C600004   BGTZ V1, 0x9D010B6C
9D010B5C  AC440054   SW A0, 84(V0)
9D010B6C  26100002   ADDIU S0, S0, 2
9D010B8C  90420000   LBU V0, 0(V0)
9D010B90  00021080   SLL V0, V0, 2
9D010B94  00561021   ADDU V0, V0, S6
9D010B98  8C420000   LW V0, 0(V0)
9D010BA0  0B402953   J 0x9D00A54C
9D010BA4  0240A821   ADDU S5, S2, ZERO
2133:                
2134:                      OPCODE_BEGIN(B5)  /* LDA $nn,X */
2135:                         LDA(4, ZP_IND_X_BYTE);
9D010BA8  26110001   ADDIU S1, S0, 1
9D010BC8  90630000   LBU V1, 0(V1)
9D010BCC  03C31821   ADDU V1, FP, V1
9D010BD0  306300FF   ANDI V1, V1, 255
9D010BD4  8F848054   LW A0, -32684(GP)
9D010BD8  00831821   ADDU V1, A0, V1
9D010BDC  90720000   LBU S2, 0(V1)
9D010BE0  8F838058   LW V1, -32680(GP)
9D010BE4  2463FFFC   ADDIU V1, V1, -4
9D010BE8  AF838058   SW V1, -32680(GP)
9D010BEC  8C440054   LW A0, 84(V0)
9D010BF0  24840004   ADDIU A0, A0, 4
9D010BFC  0240A021   ADDU S4, S2, ZERO
9D010C00  0B404D98   J .L45
9D010C04  0240A821   ADDU S5, S2, ZERO
9D010C38  0240A021   ADDU S4, S2, ZERO
2136:                         OPCODE_END
9D010BF4  1C600004   BGTZ V1, 0x9D010C08
9D010BF8  AC440054   SW A0, 84(V0)
9D010C08  26100002   ADDIU S0, S0, 2
9D010C28  90420000   LBU V0, 0(V0)
9D010C2C  00021080   SLL V0, V0, 2
9D010C30  00561021   ADDU V0, V0, S6
9D010C34  8C420000   LW V0, 0(V0)
9D010C3C  0B402953   J 0x9D00A54C
9D010C40  0240A821   ADDU S5, S2, ZERO
2137:                
2138:                      OPCODE_BEGIN(B6)  /* LDX $nn,Y */
2139:                         LDX(4, ZP_IND_Y_BYTE);
9D010C44  26110001   ADDIU S1, S0, 1
9D010C64  90630000   LBU V1, 0(V1)
9D010C68  8FA70010   LW A3, 16(SP)
9D010C6C  00E31821   ADDU V1, A3, V1
9D010C70  306300FF   ANDI V1, V1, 255
9D010C74  8F848054   LW A0, -32684(GP)
9D010C78  00831821   ADDU V1, A0, V1
9D010C7C  90720000   LBU S2, 0(V1)
9D010C80  8F838058   LW V1, -32680(GP)
9D010C84  2463FFFC   ADDIU V1, V1, -4
9D010C88  AF838058   SW V1, -32680(GP)
9D010C8C  8C440054   LW A0, 84(V0)
9D010C90  24840004   ADDIU A0, A0, 4
9D010C9C  0240F021   ADDU FP, S2, ZERO
9D010CA0  0B404D98   J .L45
9D010CA4  0240A821   ADDU S5, S2, ZERO
9D010CD8  0240F021   ADDU FP, S2, ZERO
2140:                         OPCODE_END
9D010C94  1C600004   BGTZ V1, 0x9D010CA8
9D010C98  AC440054   SW A0, 84(V0)
9D010CA8  26100002   ADDIU S0, S0, 2
9D010CC8  90420000   LBU V0, 0(V0)
9D010CCC  00021080   SLL V0, V0, 2
9D010CD0  00561021   ADDU V0, V0, S6
9D010CD4  8C420000   LW V0, 0(V0)
9D010CDC  0B402953   J 0x9D00A54C
9D010CE0  0240A821   ADDU S5, S2, ZERO
2141:                
2142:                      OPCODE_BEGIN(B7)  /* LAX $nn,Y */
2143:                         LAX(4, ZP_IND_Y_BYTE);
9D010CE4  26110001   ADDIU S1, S0, 1
9D010D04  90630000   LBU V1, 0(V1)
9D010D08  8FA40010   LW A0, 16(SP)
9D010D0C  00831821   ADDU V1, A0, V1
9D010D10  306300FF   ANDI V1, V1, 255
9D010D14  8F848054   LW A0, -32684(GP)
9D010D18  00831821   ADDU V1, A0, V1
9D010D1C  90720000   LBU S2, 0(V1)
9D010D20  8F838058   LW V1, -32680(GP)
9D010D24  2463FFFC   ADDIU V1, V1, -4
9D010D28  AF838058   SW V1, -32680(GP)
9D010D2C  8C440054   LW A0, 84(V0)
9D010D30  24840004   ADDIU A0, A0, 4
9D010D3C  0240F021   ADDU FP, S2, ZERO
9D010D40  0240A021   ADDU S4, S2, ZERO
9D010D44  0B404D98   J .L45
9D010D48  0240A821   ADDU S5, S2, ZERO
9D010D7C  0240F021   ADDU FP, S2, ZERO
9D010D80  0240A021   ADDU S4, S2, ZERO
2144:                         OPCODE_END
9D010D34  1C600005   BGTZ V1, 0x9D010D4C
9D010D38  AC440054   SW A0, 84(V0)
9D010D4C  26100002   ADDIU S0, S0, 2
9D010D6C  90420000   LBU V0, 0(V0)
9D010D70  00021080   SLL V0, V0, 2
9D010D74  00561021   ADDU V0, V0, S6
9D010D78  8C420000   LW V0, 0(V0)
9D010D84  0B402953   J 0x9D00A54C
9D010D88  0240A821   ADDU S5, S2, ZERO
2145:                
2146:                      OPCODE_BEGIN(B8)  /* CLV */
2147:                         CLV();
9D010D8C  8F828058   LW V0, -32680(GP)
9D010D90  2442FFFE   ADDIU V0, V0, -2
9D010D94  AF828058   SW V0, -32680(GP)
9D010D98  26638FD8   ADDIU V1, S3, -28712
9D010D9C  8C640054   LW A0, 84(V1)
9D010DA0  24840002   ADDIU A0, A0, 2
9D010DB0  0B404D98   J .L45
9D010DB4  AFA00014   SW ZERO, 20(SP)
2148:                         OPCODE_END
9D010DA4  1C400004   BGTZ V0, .LBB1318
9D010DA8  AC640054   SW A0, 84(V1)
9D010DAC  02008821   ADDU S1, S0, ZERO
9D010DD4  90420000   LBU V0, 0(V0)
9D010DD8  00021080   SLL V0, V0, 2
9D010DDC  00561021   ADDU V0, V0, S6
9D010DE0  8C420000   LW V0, 0(V0)
9D010DE4  26100001   ADDIU S0, S0, 1
9D010DE8  0B402953   J 0x9D00A54C
9D010DEC  AFA00014   SW ZERO, 20(SP)
2149:                
2150:                      OPCODE_BEGIN(B9)  /* LDA $nnnn,Y */
2151:                         LDA(4, ABS_IND_Y_BYTE_READ);
9D010DF0  0F402863   JAL bank_readword
9D010DF4  02002021   ADDU A0, S0, ZERO
9D010DF8  8FA50010   LW A1, 16(SP)
9D010DFC  00451021   ADDU V0, V0, A1
9D010E00  3044FFFF   ANDI A0, V0, -1
9D010E04  308200FF   ANDI V0, A0, 255
9D010E08  0045102B   SLTU V0, V0, A1
9D010E0C  10400008   BEQ V0, ZERO, 0x9D010E30
9D010E10  26110002   ADDIU S1, S0, 2
9D010E14  8F828058   LW V0, -32680(GP)
9D010E18  2442FFFF   ADDIU V0, V0, -1
9D010E1C  AF828058   SW V0, -32680(GP)
9D010E20  26628FD8   ADDIU V0, S3, -28712
9D010E24  8C430054   LW V1, 84(V0)
9D010E28  24630001   ADDIU V1, V1, 1
9D010E2C  AC430054   SW V1, 84(V0)
9D010E30  0F402804   JAL mem_readbyte
9D010E34  00000000   NOP
9D010E38  00409021   ADDU S2, V0, ZERO
9D010E3C  8F828058   LW V0, -32680(GP)
9D010E40  2442FFFC   ADDIU V0, V0, -4
9D010E44  AF828058   SW V0, -32680(GP)
9D010E48  26638FD8   ADDIU V1, S3, -28712
9D010E4C  8C640054   LW A0, 84(V1)
9D010E50  24840004   ADDIU A0, A0, 4
9D010E5C  0240A021   ADDU S4, S2, ZERO
9D010E60  0B404D98   J .L45
9D010E64  0240A821   ADDU S5, S2, ZERO
9D010E98  0240A021   ADDU S4, S2, ZERO
2152:                         OPCODE_END
9D010E54  1C400004   BGTZ V0, 0x9D010E68
9D010E58  AC640054   SW A0, 84(V1)
9D010E68  26100003   ADDIU S0, S0, 3
9D010E88  90420000   LBU V0, 0(V0)
9D010E8C  00021080   SLL V0, V0, 2
9D010E90  00561021   ADDU V0, V0, S6
9D010E94  8C420000   LW V0, 0(V0)
9D010E9C  0B402953   J 0x9D00A54C
9D010EA0  0240A821   ADDU S5, S2, ZERO
2153:                
2154:                      OPCODE_BEGIN(BA)  /* TSX */
2155:                         TSX();
9D010EA4  8F828058   LW V0, -32680(GP)
9D010EA8  2442FFFE   ADDIU V0, V0, -2
9D010EAC  AF828058   SW V0, -32680(GP)
9D010EB0  26638FD8   ADDIU V1, S3, -28712
9D010EB4  8C640054   LW A0, 84(V1)
9D010EB8  24840002   ADDIU A0, A0, 2
2156:                         OPCODE_END
9D010EBC  1C400006   BGTZ V0, .LBB1322
9D010EC0  AC640054   SW A0, 84(V1)
9D010EC4  8FB20018   LW S2, 24(SP)
9D010EC8  0240F021   ADDU FP, S2, ZERO
9D010ECC  02008821   ADDU S1, S0, ZERO
9D010ED0  0B404D98   J .L45
9D010ED4  0240A821   ADDU S5, S2, ZERO
9D010EF4  90420000   LBU V0, 0(V0)
9D010EF8  00021080   SLL V0, V0, 2
9D010EFC  00561021   ADDU V0, V0, S6
9D010F00  8C420000   LW V0, 0(V0)
9D010F04  8FBE0018   LW FP, 24(SP)
9D010F08  26100001   ADDIU S0, S0, 1
9D010F0C  03C0A821   ADDU S5, FP, ZERO
9D010F10  0B402953   J 0x9D00A54C
9D010F14  03C09021   ADDU S2, FP, ZERO
2157:                
2158:                      OPCODE_BEGIN(BB)  /* LAS $nnnn,Y */
2159:                         LAS(4, ABS_IND_Y_BYTE_READ);
9D010F18  0F402863   JAL bank_readword
9D010F1C  02002021   ADDU A0, S0, ZERO
9D010F20  8FA60010   LW A2, 16(SP)
9D010F24  00461021   ADDU V0, V0, A2
9D010F28  3044FFFF   ANDI A0, V0, -1
9D010F2C  308200FF   ANDI V0, A0, 255
9D010F30  0046102B   SLTU V0, V0, A2
9D010F34  10400008   BEQ V0, ZERO, 0x9D010F58
9D010F38  26110002   ADDIU S1, S0, 2
9D010F3C  8F828058   LW V0, -32680(GP)
9D010F40  2442FFFF   ADDIU V0, V0, -1
9D010F44  AF828058   SW V0, -32680(GP)
9D010F48  26628FD8   ADDIU V0, S3, -28712
9D010F4C  8C430054   LW V1, 84(V0)
9D010F50  24630001   ADDIU V1, V1, 1
9D010F54  AC430054   SW V1, 84(V0)
9D010F58  0F402804   JAL mem_readbyte
9D010F5C  00000000   NOP
9D010F60  8FA70018   LW A3, 24(SP)
9D010F64  00471024   AND V0, V0, A3
9D010F68  305200FF   ANDI S2, V0, 255
9D010F6C  8F828058   LW V0, -32680(GP)
9D010F70  2442FFFC   ADDIU V0, V0, -4
9D010F74  AF828058   SW V0, -32680(GP)
9D010F78  26638FD8   ADDIU V1, S3, -28712
9D010F7C  8C640054   LW A0, 84(V1)
9D010F80  24840004   ADDIU A0, A0, 4
9D010F8C  AFB20018   SW S2, 24(SP)
9D010F90  0240F021   ADDU FP, S2, ZERO
9D010F94  0240A021   ADDU S4, S2, ZERO
9D010F98  0B404D98   J .L45
9D010F9C  0240A821   ADDU S5, S2, ZERO
9D010FD0  AFB20018   SW S2, 24(SP)
9D010FD4  0240F021   ADDU FP, S2, ZERO
9D010FD8  0240A021   ADDU S4, S2, ZERO
2160:                         OPCODE_END
9D010F84  1C400006   BGTZ V0, 0x9D010FA0
9D010F88  AC640054   SW A0, 84(V1)
9D010FA0  26100003   ADDIU S0, S0, 3
9D010FC0  90420000   LBU V0, 0(V0)
9D010FC4  00021080   SLL V0, V0, 2
9D010FC8  00561021   ADDU V0, V0, S6
9D010FCC  8C420000   LW V0, 0(V0)
9D010FDC  0B402953   J 0x9D00A54C
9D010FE0  0240A821   ADDU S5, S2, ZERO
2161:                
2162:                      OPCODE_BEGIN(BC)  /* LDY $nnnn,X */
2163:                         LDY(4, ABS_IND_X_BYTE_READ);
9D010FE4  0F402863   JAL bank_readword
9D010FE8  02002021   ADDU A0, S0, ZERO
9D010FEC  005E1021   ADDU V0, V0, FP
9D010FF0  3044FFFF   ANDI A0, V0, -1
9D010FF4  308200FF   ANDI V0, A0, 255
9D010FF8  005E102B   SLTU V0, V0, FP
9D010FFC  10400008   BEQ V0, ZERO, 0x9D011020
9D011000  26110002   ADDIU S1, S0, 2
9D011004  8F828058   LW V0, -32680(GP)
9D011008  2442FFFF   ADDIU V0, V0, -1
9D01100C  AF828058   SW V0, -32680(GP)
9D011010  26628FD8   ADDIU V0, S3, -28712
9D011014  8C430054   LW V1, 84(V0)
9D011018  24630001   ADDIU V1, V1, 1
9D01101C  AC430054   SW V1, 84(V0)
9D011020  0F402804   JAL mem_readbyte
9D011024  00000000   NOP
9D011028  00409021   ADDU S2, V0, ZERO
9D01102C  8F828058   LW V0, -32680(GP)
9D011030  2442FFFC   ADDIU V0, V0, -4
9D011034  AF828058   SW V0, -32680(GP)
9D011038  26638FD8   ADDIU V1, S3, -28712
9D01103C  8C640054   LW A0, 84(V1)
9D011040  24840004   ADDIU A0, A0, 4
9D01104C  AFB20010   SW S2, 16(SP)
9D011050  0B404D98   J .L45
9D011054  0240A821   ADDU S5, S2, ZERO
9D011088  AFB20010   SW S2, 16(SP)
2164:                         OPCODE_END
9D011044  1C400004   BGTZ V0, 0x9D011058
9D011048  AC640054   SW A0, 84(V1)
9D011058  26100003   ADDIU S0, S0, 3
9D011078  90420000   LBU V0, 0(V0)
9D01107C  00021080   SLL V0, V0, 2
9D011080  00561021   ADDU V0, V0, S6
9D011084  8C420000   LW V0, 0(V0)
9D01108C  0B402953   J 0x9D00A54C
9D011090  0240A821   ADDU S5, S2, ZERO
2165:                
2166:                      OPCODE_BEGIN(BD)  /* LDA $nnnn,X */
2167:                         LDA(4, ABS_IND_X_BYTE_READ);
9D011094  0F402863   JAL bank_readword
9D011098  02002021   ADDU A0, S0, ZERO
9D01109C  005E1021   ADDU V0, V0, FP
9D0110A0  3044FFFF   ANDI A0, V0, -1
9D0110A4  308200FF   ANDI V0, A0, 255
9D0110A8  005E102B   SLTU V0, V0, FP
9D0110AC  10400008   BEQ V0, ZERO, 0x9D0110D0
9D0110B0  26110002   ADDIU S1, S0, 2
9D0110B4  8F828058   LW V0, -32680(GP)
9D0110B8  2442FFFF   ADDIU V0, V0, -1
9D0110BC  AF828058   SW V0, -32680(GP)
9D0110C0  26628FD8   ADDIU V0, S3, -28712
9D0110C4  8C430054   LW V1, 84(V0)
9D0110C8  24630001   ADDIU V1, V1, 1
9D0110CC  AC430054   SW V1, 84(V0)
9D0110D0  0F402804   JAL mem_readbyte
9D0110D4  00000000   NOP
9D0110D8  00409021   ADDU S2, V0, ZERO
9D0110DC  8F828058   LW V0, -32680(GP)
9D0110E0  2442FFFC   ADDIU V0, V0, -4
9D0110E4  AF828058   SW V0, -32680(GP)
9D0110E8  26638FD8   ADDIU V1, S3, -28712
9D0110EC  8C640054   LW A0, 84(V1)
9D0110F0  24840004   ADDIU A0, A0, 4
9D0110FC  0240A021   ADDU S4, S2, ZERO
9D011100  0B404D98   J .L45
9D011104  0240A821   ADDU S5, S2, ZERO
9D011138  0240A021   ADDU S4, S2, ZERO
2168:                         OPCODE_END
9D0110F4  1C400004   BGTZ V0, 0x9D011108
9D0110F8  AC640054   SW A0, 84(V1)
9D011108  26100003   ADDIU S0, S0, 3
9D011128  90420000   LBU V0, 0(V0)
9D01112C  00021080   SLL V0, V0, 2
9D011130  00561021   ADDU V0, V0, S6
9D011134  8C420000   LW V0, 0(V0)
9D01113C  0B402953   J 0x9D00A54C
9D011140  0240A821   ADDU S5, S2, ZERO
2169:                
2170:                      OPCODE_BEGIN(BE)  /* LDX $nnnn,Y */
2171:                         LDX(4, ABS_IND_Y_BYTE_READ);
9D011144  0F402863   JAL bank_readword
9D011148  02002021   ADDU A0, S0, ZERO
9D01114C  8FA30010   LW V1, 16(SP)
9D011150  00431021   ADDU V0, V0, V1
9D011154  3044FFFF   ANDI A0, V0, -1
9D011158  308200FF   ANDI V0, A0, 255
9D01115C  0043102B   SLTU V0, V0, V1
9D011160  10400008   BEQ V0, ZERO, 0x9D011184
9D011164  26110002   ADDIU S1, S0, 2
9D011168  8F828058   LW V0, -32680(GP)
9D01116C  2442FFFF   ADDIU V0, V0, -1
9D011170  AF828058   SW V0, -32680(GP)
9D011174  26628FD8   ADDIU V0, S3, -28712
9D011178  8C430054   LW V1, 84(V0)
9D01117C  24630001   ADDIU V1, V1, 1
9D011180  AC430054   SW V1, 84(V0)
9D011184  0F402804   JAL mem_readbyte
9D011188  00000000   NOP
9D01118C  00409021   ADDU S2, V0, ZERO
9D011190  8F828058   LW V0, -32680(GP)
9D011194  2442FFFC   ADDIU V0, V0, -4
9D011198  AF828058   SW V0, -32680(GP)
9D01119C  26638FD8   ADDIU V1, S3, -28712
9D0111A0  8C640054   LW A0, 84(V1)
9D0111A4  24840004   ADDIU A0, A0, 4
9D0111B0  0240F021   ADDU FP, S2, ZERO
9D0111B4  0B404D98   J .L45
9D0111B8  0240A821   ADDU S5, S2, ZERO
9D0111EC  0240F021   ADDU FP, S2, ZERO
2172:                         OPCODE_END
9D0111A8  1C400004   BGTZ V0, 0x9D0111BC
9D0111AC  AC640054   SW A0, 84(V1)
9D0111BC  26100003   ADDIU S0, S0, 3
9D0111DC  90420000   LBU V0, 0(V0)
9D0111E0  00021080   SLL V0, V0, 2
9D0111E4  00561021   ADDU V0, V0, S6
9D0111E8  8C420000   LW V0, 0(V0)
9D0111F0  0B402953   J 0x9D00A54C
9D0111F4  0240A821   ADDU S5, S2, ZERO
2173:                
2174:                      OPCODE_BEGIN(BF)  /* LAX $nnnn,Y */
2175:                         LAX(4, ABS_IND_Y_BYTE_READ);
9D0111F8  0F402863   JAL bank_readword
9D0111FC  02002021   ADDU A0, S0, ZERO
9D011200  8FA40010   LW A0, 16(SP)
9D011204  00441021   ADDU V0, V0, A0
9D011208  3044FFFF   ANDI A0, V0, -1
9D01120C  308200FF   ANDI V0, A0, 255
9D011210  8FA50010   LW A1, 16(SP)
9D011214  0045102B   SLTU V0, V0, A1
9D011218  10400008   BEQ V0, ZERO, 0x9D01123C
9D01121C  26110002   ADDIU S1, S0, 2
9D011220  8F828058   LW V0, -32680(GP)
9D011224  2442FFFF   ADDIU V0, V0, -1
9D011228  AF828058   SW V0, -32680(GP)
9D01122C  26628FD8   ADDIU V0, S3, -28712
9D011230  8C430054   LW V1, 84(V0)
9D011234  24630001   ADDIU V1, V1, 1
9D011238  AC430054   SW V1, 84(V0)
9D01123C  0F402804   JAL mem_readbyte
9D011240  00000000   NOP
9D011244  00409021   ADDU S2, V0, ZERO
9D011248  8F828058   LW V0, -32680(GP)
9D01124C  2442FFFC   ADDIU V0, V0, -4
9D011250  AF828058   SW V0, -32680(GP)
9D011254  26638FD8   ADDIU V1, S3, -28712
9D011258  8C640054   LW A0, 84(V1)
9D01125C  24840004   ADDIU A0, A0, 4
9D011268  0240F021   ADDU FP, S2, ZERO
9D01126C  0240A021   ADDU S4, S2, ZERO
9D011270  0B404D98   J .L45
9D011274  0240A821   ADDU S5, S2, ZERO
9D0112A8  0240F021   ADDU FP, S2, ZERO
9D0112AC  0240A021   ADDU S4, S2, ZERO
2176:                         OPCODE_END
9D011260  1C400005   BGTZ V0, 0x9D011278
9D011264  AC640054   SW A0, 84(V1)
9D011278  26100003   ADDIU S0, S0, 3
9D011298  90420000   LBU V0, 0(V0)
9D01129C  00021080   SLL V0, V0, 2
9D0112A0  00561021   ADDU V0, V0, S6
9D0112A4  8C420000   LW V0, 0(V0)
9D0112B0  0B402953   J 0x9D00A54C
9D0112B4  0240A821   ADDU S5, S2, ZERO
2177:                
2178:                      OPCODE_BEGIN(C0)  /* CPY #$nn */
2179:                         CPY(2, IMMEDIATE_BYTE);
9D0112B8  26110001   ADDIU S1, S0, 1
9D0112D8  90720000   LBU S2, 0(V1)
9D0112DC  8FA60010   LW A2, 16(SP)
9D0112E0  00D29023   SUBU S2, A2, S2
9D0112E4  7E570200   EXT S7, S2, 8, 1
9D0112E8  3AF70001   XORI S7, S7, 1
9D0112EC  325200FF   ANDI S2, S2, 255
9D0112F0  8F838058   LW V1, -32680(GP)
9D0112F4  2463FFFE   ADDIU V1, V1, -2
9D0112F8  AF838058   SW V1, -32680(GP)
9D0112FC  8C440054   LW A0, 84(V0)
9D011300  24840002   ADDIU A0, A0, 2
9D01130C  0B404D98   J .L45
9D011310  0240A821   ADDU S5, S2, ZERO
2180:                         OPCODE_END
9D011304  1C600003   BGTZ V1, 0x9D011314
9D011308  AC440054   SW A0, 84(V0)
9D011314  26100002   ADDIU S0, S0, 2
9D011334  90420000   LBU V0, 0(V0)
9D011338  00021080   SLL V0, V0, 2
9D01133C  00561021   ADDU V0, V0, S6
9D011340  8C420000   LW V0, 0(V0)
9D011344  0B402953   J 0x9D00A54C
9D011348  0240A821   ADDU S5, S2, ZERO
2181:                
2182:                      OPCODE_BEGIN(C1)  /* CMP ($nn,X) */
2183:                         CMP(6, INDIR_X_BYTE);
9D01134C  26110001   ADDIU S1, S0, 1
9D01136C  90420000   LBU V0, 0(V0)
9D011370  03C21021   ADDU V0, FP, V0
9D01138C  0F402804   JAL mem_readbyte
9D011390  308400FF   ANDI A0, A0, 255
9D011394  02821023   SUBU V0, S4, V0
9D011398  7C570200   EXT S7, V0, 8, 1
9D01139C  3AF70001   XORI S7, S7, 1
9D0113A0  305200FF   ANDI S2, V0, 255
9D0113A4  8F828058   LW V0, -32680(GP)
9D0113A8  2442FFFA   ADDIU V0, V0, -6
9D0113AC  AF828058   SW V0, -32680(GP)
9D0113B0  8EA30054   LW V1, 84(S5)
9D0113B4  24630006   ADDIU V1, V1, 6
9D0113C0  0B404D98   J .L45
9D0113C4  0240A821   ADDU S5, S2, ZERO
2184:                         OPCODE_END
9D0113B8  1C400003   BGTZ V0, 0x9D0113C8
9D0113BC  AEA30054   SW V1, 84(S5)
9D0113C8  26100002   ADDIU S0, S0, 2
9D0113E8  90420000   LBU V0, 0(V0)
9D0113EC  00021080   SLL V0, V0, 2
9D0113F0  00561021   ADDU V0, V0, S6
9D0113F4  8C420000   LW V0, 0(V0)
9D0113F8  0B402953   J 0x9D00A54C
9D0113FC  0240A821   ADDU S5, S2, ZERO
2185:                
2186:                      OPCODE_BEGIN(C3)  /* DCP ($nn,X) */
2187:                         DCP(8, INDIR_X, mem_writebyte, addr);
9D011400  26110001   ADDIU S1, S0, 1
9D011420  90420000   LBU V0, 0(V0)
9D011424  03C21021   ADDU V0, FP, V0
9D011444  0F402804   JAL mem_readbyte
9D011448  02E02021   ADDU A0, S7, ZERO
9D01144C  2442FFFF   ADDIU V0, V0, -1
9D011450  305200FF   ANDI S2, V0, 255
9D011454  02E02021   ADDU A0, S7, ZERO
9D011458  0F40283A   JAL mem_writebyte
9D01145C  02402821   ADDU A1, S2, ZERO
9D011460  02929023   SUBU S2, S4, S2
9D011464  7E570200   EXT S7, S2, 8, 1
9D011468  3AF70001   XORI S7, S7, 1
9D01146C  325200FF   ANDI S2, S2, 255
9D011470  8F828058   LW V0, -32680(GP)
9D011474  2442FFF8   ADDIU V0, V0, -8
9D011478  AF828058   SW V0, -32680(GP)
9D01147C  8EA30054   LW V1, 84(S5)
9D011480  24630008   ADDIU V1, V1, 8
9D01148C  0B404D98   J .L45
9D011490  0240A821   ADDU S5, S2, ZERO
2188:                         OPCODE_END
9D011484  1C400003   BGTZ V0, 0x9D011494
9D011488  AEA30054   SW V1, 84(S5)
9D011494  26100002   ADDIU S0, S0, 2
9D0114B4  90420000   LBU V0, 0(V0)
9D0114B8  00021080   SLL V0, V0, 2
9D0114BC  00561021   ADDU V0, V0, S6
9D0114C0  8C420000   LW V0, 0(V0)
9D0114C4  0B402953   J 0x9D00A54C
9D0114C8  0240A821   ADDU S5, S2, ZERO
2189:                
2190:                      OPCODE_BEGIN(C4)  /* CPY $nn */
2191:                         CPY(3, ZERO_PAGE_BYTE);
9D0114CC  26110001   ADDIU S1, S0, 1
9D0114EC  90630000   LBU V1, 0(V1)
9D0114F0  8F848054   LW A0, -32684(GP)
9D0114F4  00831821   ADDU V1, A0, V1
9D0114F8  90720000   LBU S2, 0(V1)
9D0114FC  8FA70010   LW A3, 16(SP)
9D011500  00F29023   SUBU S2, A3, S2
9D011504  7E570200   EXT S7, S2, 8, 1
9D011508  3AF70001   XORI S7, S7, 1
9D01150C  325200FF   ANDI S2, S2, 255
9D011510  8F838058   LW V1, -32680(GP)
9D011514  2463FFFD   ADDIU V1, V1, -3
9D011518  AF838058   SW V1, -32680(GP)
9D01151C  8C440054   LW A0, 84(V0)
9D011520  24840003   ADDIU A0, A0, 3
9D01152C  0B404D98   J .L45
9D011530  0240A821   ADDU S5, S2, ZERO
2192:                         OPCODE_END
9D011524  1C600003   BGTZ V1, 0x9D011534
9D011528  AC440054   SW A0, 84(V0)
9D011534  26100002   ADDIU S0, S0, 2
9D011554  90420000   LBU V0, 0(V0)
9D011558  00021080   SLL V0, V0, 2
9D01155C  00561021   ADDU V0, V0, S6
9D011560  8C420000   LW V0, 0(V0)
9D011564  0B402953   J 0x9D00A54C
9D011568  0240A821   ADDU S5, S2, ZERO
2193:                
2194:                      OPCODE_BEGIN(C5)  /* CMP $nn */
2195:                         CMP(3, ZERO_PAGE_BYTE);
9D01156C  26110001   ADDIU S1, S0, 1
9D01158C  90630000   LBU V1, 0(V1)
9D011590  8F848054   LW A0, -32684(GP)
9D011594  00831821   ADDU V1, A0, V1
9D011598  90720000   LBU S2, 0(V1)
9D01159C  02929023   SUBU S2, S4, S2
9D0115A0  7E570200   EXT S7, S2, 8, 1
9D0115A4  3AF70001   XORI S7, S7, 1
9D0115A8  325200FF   ANDI S2, S2, 255
9D0115AC  8F838058   LW V1, -32680(GP)
9D0115B0  2463FFFD   ADDIU V1, V1, -3
9D0115B4  AF838058   SW V1, -32680(GP)
9D0115B8  8C440054   LW A0, 84(V0)
9D0115BC  24840003   ADDIU A0, A0, 3
9D0115C8  0B404D98   J .L45
9D0115CC  0240A821   ADDU S5, S2, ZERO
2196:                         OPCODE_END
9D0115C0  1C600003   BGTZ V1, 0x9D0115D0
9D0115C4  AC440054   SW A0, 84(V0)
9D0115D0  26100002   ADDIU S0, S0, 2
9D0115F0  90420000   LBU V0, 0(V0)
9D0115F4  00021080   SLL V0, V0, 2
9D0115F8  00561021   ADDU V0, V0, S6
9D0115FC  8C420000   LW V0, 0(V0)
9D011600  0B402953   J 0x9D00A54C
9D011604  0240A821   ADDU S5, S2, ZERO
2197:                
2198:                      OPCODE_BEGIN(C6)  /* DEC $nn */
2199:                         DEC(5, ZERO_PAGE, ZP_WRITEBYTE, baddr);
9D011608  26110001   ADDIU S1, S0, 1
9D011628  90630000   LBU V1, 0(V1)
9D01162C  8F848054   LW A0, -32684(GP)
9D011630  00831821   ADDU V1, A0, V1
9D011634  90720000   LBU S2, 0(V1)
9D011638  2652FFFF   ADDIU S2, S2, -1
9D01163C  325200FF   ANDI S2, S2, 255
9D011640  A0720000   SB S2, 0(V1)
9D011644  8F838058   LW V1, -32680(GP)
9D011648  2463FFFB   ADDIU V1, V1, -5
9D01164C  AF838058   SW V1, -32680(GP)
9D011650  8C440054   LW A0, 84(V0)
9D011654  24840005   ADDIU A0, A0, 5
9D011660  0B404D98   J .L45
9D011664  0240A821   ADDU S5, S2, ZERO
2200:                         OPCODE_END
9D011658  1C600003   BGTZ V1, 0x9D011668
9D01165C  AC440054   SW A0, 84(V0)
9D011668  26100002   ADDIU S0, S0, 2
9D011688  90420000   LBU V0, 0(V0)
9D01168C  00021080   SLL V0, V0, 2
9D011690  00561021   ADDU V0, V0, S6
9D011694  8C420000   LW V0, 0(V0)
9D011698  0B402953   J 0x9D00A54C
9D01169C  0240A821   ADDU S5, S2, ZERO
2201:                
2202:                      OPCODE_BEGIN(C7)  /* DCP $nn */
2203:                         DCP(5, ZERO_PAGE, ZP_WRITEBYTE, baddr);
9D0116A0  26110001   ADDIU S1, S0, 1
9D0116C0  90630000   LBU V1, 0(V1)
9D0116C4  8F848054   LW A0, -32684(GP)
9D0116C8  00831821   ADDU V1, A0, V1
9D0116CC  90720000   LBU S2, 0(V1)
9D0116D0  2652FFFF   ADDIU S2, S2, -1
9D0116D4  325200FF   ANDI S2, S2, 255
9D0116D8  A0720000   SB S2, 0(V1)
9D0116DC  02929023   SUBU S2, S4, S2
9D0116E0  7E570200   EXT S7, S2, 8, 1
9D0116E4  3AF70001   XORI S7, S7, 1
9D0116E8  325200FF   ANDI S2, S2, 255
9D0116EC  8F838058   LW V1, -32680(GP)
9D0116F0  2463FFFB   ADDIU V1, V1, -5
9D0116F4  AF838058   SW V1, -32680(GP)
9D0116F8  8C440054   LW A0, 84(V0)
9D0116FC  24840005   ADDIU A0, A0, 5
9D011708  0B404D98   J .L45
9D01170C  0240A821   ADDU S5, S2, ZERO
2204:                         OPCODE_END
9D011700  1C600003   BGTZ V1, 0x9D011710
9D011704  AC440054   SW A0, 84(V0)
9D011710  26100002   ADDIU S0, S0, 2
9D011730  90420000   LBU V0, 0(V0)
9D011734  00021080   SLL V0, V0, 2
9D011738  00561021   ADDU V0, V0, S6
9D01173C  8C420000   LW V0, 0(V0)
9D011740  0B402953   J 0x9D00A54C
9D011744  0240A821   ADDU S5, S2, ZERO
2205:                
2206:                      OPCODE_BEGIN(C8)  /* INY */
2207:                         INY();
9D011748  8FA20010   LW V0, 16(SP)
9D01174C  24520001   ADDIU S2, V0, 1
9D011750  325200FF   ANDI S2, S2, 255
9D011754  8F828058   LW V0, -32680(GP)
9D011758  2442FFFE   ADDIU V0, V0, -2
9D01175C  AF828058   SW V0, -32680(GP)
9D011760  26638FD8   ADDIU V1, S3, -28712
9D011764  8C640054   LW A0, 84(V1)
9D011768  24840002   ADDIU A0, A0, 2
9D011774  AFB20010   SW S2, 16(SP)
9D01177C  0B404D98   J .L45
9D011780  0240A821   ADDU S5, S2, ZERO
9D0117B0  AFB20010   SW S2, 16(SP)
2208:                         OPCODE_END
9D01176C  1C400005   BGTZ V0, .LBB1366
9D011770  AC640054   SW A0, 84(V1)
9D011778  02008821   ADDU S1, S0, ZERO
9D0117A0  90420000   LBU V0, 0(V0)
9D0117A4  00021080   SLL V0, V0, 2
9D0117A8  00561021   ADDU V0, V0, S6
9D0117AC  8C420000   LW V0, 0(V0)
9D0117B4  26100001   ADDIU S0, S0, 1
9D0117B8  0B402953   J 0x9D00A54C
9D0117BC  0240A821   ADDU S5, S2, ZERO
2209:                
2210:                      OPCODE_BEGIN(C9)  /* CMP #$nn */
2211:                         CMP(2, IMMEDIATE_BYTE);
9D0117C0  26110001   ADDIU S1, S0, 1
9D0117E0  90720000   LBU S2, 0(V1)
9D0117E4  02929023   SUBU S2, S4, S2
9D0117E8  7E570200   EXT S7, S2, 8, 1
9D0117EC  3AF70001   XORI S7, S7, 1
9D0117F0  325200FF   ANDI S2, S2, 255
9D0117F4  8F838058   LW V1, -32680(GP)
9D0117F8  2463FFFE   ADDIU V1, V1, -2
9D0117FC  AF838058   SW V1, -32680(GP)
9D011800  8C440054   LW A0, 84(V0)
9D011804  24840002   ADDIU A0, A0, 2
9D011810  0B404D98   J .L45
9D011814  0240A821   ADDU S5, S2, ZERO
2212:                         OPCODE_END
9D011808  1C600003   BGTZ V1, 0x9D011818
9D01180C  AC440054   SW A0, 84(V0)
9D011818  26100002   ADDIU S0, S0, 2
9D011838  90420000   LBU V0, 0(V0)
9D01183C  00021080   SLL V0, V0, 2
9D011840  00561021   ADDU V0, V0, S6
9D011844  8C420000   LW V0, 0(V0)
9D011848  0B402953   J 0x9D00A54C
9D01184C  0240A821   ADDU S5, S2, ZERO
2213:                
2214:                      OPCODE_BEGIN(CA)  /* DEX */
2215:                         DEX();
9D011850  27D2FFFF   ADDIU S2, FP, -1
9D011854  325200FF   ANDI S2, S2, 255
9D011858  8F828058   LW V0, -32680(GP)
9D01185C  2442FFFE   ADDIU V0, V0, -2
9D011860  AF828058   SW V0, -32680(GP)
9D011864  26638FD8   ADDIU V1, S3, -28712
9D011868  8C640054   LW A0, 84(V1)
9D01186C  24840002   ADDIU A0, A0, 2
9D011878  0240F021   ADDU FP, S2, ZERO
9D011880  0B404D98   J .L45
9D011884  0240A821   ADDU S5, S2, ZERO
9D0118B4  0240F021   ADDU FP, S2, ZERO
2216:                         OPCODE_END
9D011870  1C400005   BGTZ V0, .LBB1372
9D011874  AC640054   SW A0, 84(V1)
9D01187C  02008821   ADDU S1, S0, ZERO
9D0118A4  90420000   LBU V0, 0(V0)
9D0118A8  00021080   SLL V0, V0, 2
9D0118AC  00561021   ADDU V0, V0, S6
9D0118B0  8C420000   LW V0, 0(V0)
9D0118B8  26100001   ADDIU S0, S0, 1
9D0118BC  0B402953   J 0x9D00A54C
9D0118C0  0240A821   ADDU S5, S2, ZERO
2217:                
2218:                      OPCODE_BEGIN(CB)  /* SBX #$nn */
2219:                         SBX(2, IMMEDIATE_BYTE);
9D0118C4  26110001   ADDIU S1, S0, 1
9D0118C8  03D49024   AND S2, FP, S4
9D0118CC  325200FF   ANDI S2, S2, 255
9D0118EC  90630000   LBU V1, 0(V1)
9D0118F0  02439023   SUBU S2, S2, V1
9D0118F4  3A570100   XORI S7, S2, 256
9D0118F8  7EF70200   EXT S7, S7, 8, 1
9D0118FC  325200FF   ANDI S2, S2, 255
9D011900  8F838058   LW V1, -32680(GP)
9D011904  2463FFFE   ADDIU V1, V1, -2
9D011908  AF838058   SW V1, -32680(GP)
9D01190C  8C440054   LW A0, 84(V0)
9D011910  24840002   ADDIU A0, A0, 2
9D01191C  0240F021   ADDU FP, S2, ZERO
9D011920  0B404D98   J .L45
9D011924  0240A821   ADDU S5, S2, ZERO
9D011958  0240F021   ADDU FP, S2, ZERO
2220:                         OPCODE_END
9D011914  1C600004   BGTZ V1, 0x9D011928
9D011918  AC440054   SW A0, 84(V0)
9D011928  26100002   ADDIU S0, S0, 2
9D011948  90420000   LBU V0, 0(V0)
9D01194C  00021080   SLL V0, V0, 2
9D011950  00561021   ADDU V0, V0, S6
9D011954  8C420000   LW V0, 0(V0)
9D01195C  0B402953   J 0x9D00A54C
9D011960  0240A821   ADDU S5, S2, ZERO
2221:                
2222:                      OPCODE_BEGIN(CC)  /* CPY $nnnn */
2223:                         CPY(4, ABSOLUTE_BYTE);
9D011964  0F402863   JAL bank_readword
9D011968  02002021   ADDU A0, S0, ZERO
9D01196C  26110002   ADDIU S1, S0, 2
9D011970  0F402804   JAL mem_readbyte
9D011974  00402021   ADDU A0, V0, ZERO
9D011978  8FA30010   LW V1, 16(SP)
9D01197C  00621023   SUBU V0, V1, V0
9D011980  7C570200   EXT S7, V0, 8, 1
9D011984  3AF70001   XORI S7, S7, 1
9D011988  305200FF   ANDI S2, V0, 255
9D01198C  8F828058   LW V0, -32680(GP)
9D011990  2442FFFC   ADDIU V0, V0, -4
9D011994  AF828058   SW V0, -32680(GP)
9D011998  26638FD8   ADDIU V1, S3, -28712
9D01199C  8C640054   LW A0, 84(V1)
9D0119A0  24840004   ADDIU A0, A0, 4
9D0119AC  0B404D98   J .L45
9D0119B0  0240A821   ADDU S5, S2, ZERO
2224:                         OPCODE_END
9D0119A4  1C400003   BGTZ V0, 0x9D0119B4
9D0119A8  AC640054   SW A0, 84(V1)
9D0119B4  26100003   ADDIU S0, S0, 3
9D0119D4  90420000   LBU V0, 0(V0)
9D0119D8  00021080   SLL V0, V0, 2
9D0119DC  00561021   ADDU V0, V0, S6
9D0119E0  8C420000   LW V0, 0(V0)
9D0119E4  0B402953   J 0x9D00A54C
9D0119E8  0240A821   ADDU S5, S2, ZERO
2225:                
2226:                      OPCODE_BEGIN(CD)  /* CMP $nnnn */
2227:                         CMP(4, ABSOLUTE_BYTE);
9D0119EC  0F402863   JAL bank_readword
9D0119F0  02002021   ADDU A0, S0, ZERO
9D0119F4  26110002   ADDIU S1, S0, 2
9D0119F8  0F402804   JAL mem_readbyte
9D0119FC  00402021   ADDU A0, V0, ZERO
9D011A00  02821023   SUBU V0, S4, V0
9D011A04  7C570200   EXT S7, V0, 8, 1
9D011A08  3AF70001   XORI S7, S7, 1
9D011A0C  305200FF   ANDI S2, V0, 255
9D011A10  8F828058   LW V0, -32680(GP)
9D011A14  2442FFFC   ADDIU V0, V0, -4
9D011A18  AF828058   SW V0, -32680(GP)
9D011A1C  26638FD8   ADDIU V1, S3, -28712
9D011A20  8C640054   LW A0, 84(V1)
9D011A24  24840004   ADDIU A0, A0, 4
9D011A30  0B404D98   J .L45
9D011A34  0240A821   ADDU S5, S2, ZERO
2228:                         OPCODE_END
9D011A28  1C400003   BGTZ V0, 0x9D011A38
9D011A2C  AC640054   SW A0, 84(V1)
9D011A38  26100003   ADDIU S0, S0, 3
9D011A58  90420000   LBU V0, 0(V0)
9D011A5C  00021080   SLL V0, V0, 2
9D011A60  00561021   ADDU V0, V0, S6
9D011A64  8C420000   LW V0, 0(V0)
9D011A68  0B402953   J 0x9D00A54C
9D011A6C  0240A821   ADDU S5, S2, ZERO
2229:                
2230:                      OPCODE_BEGIN(CE)  /* DEC $nnnn */
2231:                         DEC(6, ABSOLUTE, mem_writebyte, addr);
9D011A70  0F402863   JAL bank_readword
9D011A74  02002021   ADDU A0, S0, ZERO
9D011A78  0040A821   ADDU S5, V0, ZERO
9D011A7C  26110002   ADDIU S1, S0, 2
9D011A80  0F402804   JAL mem_readbyte
9D011A84  00402021   ADDU A0, V0, ZERO
9D011A88  2442FFFF   ADDIU V0, V0, -1
9D011A8C  305200FF   ANDI S2, V0, 255
9D011A90  02A02021   ADDU A0, S5, ZERO
9D011A94  0F40283A   JAL mem_writebyte
9D011A98  02402821   ADDU A1, S2, ZERO
9D011A9C  8F828058   LW V0, -32680(GP)
9D011AA0  2442FFFA   ADDIU V0, V0, -6
9D011AA4  AF828058   SW V0, -32680(GP)
9D011AA8  26638FD8   ADDIU V1, S3, -28712
9D011AAC  8C640054   LW A0, 84(V1)
9D011AB0  24840006   ADDIU A0, A0, 6
9D011ABC  0B404D98   J .L45
9D011AC0  0240A821   ADDU S5, S2, ZERO
2232:                         OPCODE_END
9D011AB4  1C400003   BGTZ V0, 0x9D011AC4
9D011AB8  AC640054   SW A0, 84(V1)
9D011AC4  26100003   ADDIU S0, S0, 3
9D011AE4  90420000   LBU V0, 0(V0)
9D011AE8  00021080   SLL V0, V0, 2
9D011AEC  00561021   ADDU V0, V0, S6
9D011AF0  8C420000   LW V0, 0(V0)
9D011AF4  0B402953   J 0x9D00A54C
9D011AF8  0240A821   ADDU S5, S2, ZERO
2233:                
2234:                      OPCODE_BEGIN(CF)  /* DCP $nnnn */
2235:                         DCP(6, ABSOLUTE, mem_writebyte, addr);
9D011AFC  0F402863   JAL bank_readword
9D011B00  02002021   ADDU A0, S0, ZERO
9D011B04  0040A821   ADDU S5, V0, ZERO
9D011B08  26110002   ADDIU S1, S0, 2
9D011B0C  0F402804   JAL mem_readbyte
9D011B10  00402021   ADDU A0, V0, ZERO
9D011B14  2442FFFF   ADDIU V0, V0, -1
9D011B18  305200FF   ANDI S2, V0, 255
9D011B1C  02A02021   ADDU A0, S5, ZERO
9D011B20  0F40283A   JAL mem_writebyte
9D011B24  02402821   ADDU A1, S2, ZERO
9D011B28  02929023   SUBU S2, S4, S2
9D011B2C  7E570200   EXT S7, S2, 8, 1
9D011B30  3AF70001   XORI S7, S7, 1
9D011B34  325200FF   ANDI S2, S2, 255
9D011B38  8F828058   LW V0, -32680(GP)
9D011B3C  2442FFFA   ADDIU V0, V0, -6
9D011B40  AF828058   SW V0, -32680(GP)
9D011B44  26638FD8   ADDIU V1, S3, -28712
9D011B48  8C640054   LW A0, 84(V1)
9D011B4C  24840006   ADDIU A0, A0, 6
9D011B58  0B404D98   J .L45
9D011B5C  0240A821   ADDU S5, S2, ZERO
2236:                         OPCODE_END
9D011B50  1C400003   BGTZ V0, 0x9D011B60
9D011B54  AC640054   SW A0, 84(V1)
9D011B60  26100003   ADDIU S0, S0, 3
9D011B80  90420000   LBU V0, 0(V0)
9D011B84  00021080   SLL V0, V0, 2
9D011B88  00561021   ADDU V0, V0, S6
9D011B8C  8C420000   LW V0, 0(V0)
9D011B90  0B402953   J 0x9D00A54C
9D011B94  0240A821   ADDU S5, S2, ZERO
2237:                      
2238:                      OPCODE_BEGIN(D0)  /* BNE $nnnn */
2239:                         BNE();
9D011B98  12A0001E   BEQ S5, ZERO, 0x9D011C14
9D011B9C  26110001   ADDIU S1, S0, 1
9D011BA0  26020001   ADDIU V0, S0, 1
9D011BC0  80710000   LB S1, 0(V1)
9D011BC4  304300FF   ANDI V1, V0, 255
9D011BC8  02231821   ADDU V1, S1, V1
9D011BCC  30630100   ANDI V1, V1, 256
9D011BD0  10600008   BEQ V1, ZERO, 0x9D011BF4
9D011BD4  8F838058   LW V1, -32680(GP)
9D011BD8  2463FFFF   ADDIU V1, V1, -1
9D011BDC  AF838058   SW V1, -32680(GP)
9D011BE0  26638FD8   ADDIU V1, S3, -28712
9D011BE4  8C640054   LW A0, 84(V1)
9D011BE8  24840001   ADDIU A0, A0, 1
9D011BEC  AC640054   SW A0, 84(V1)
9D011BF0  8F838058   LW V1, -32680(GP)
9D011BF4  2463FFFD   ADDIU V1, V1, -3
9D011BF8  AF838058   SW V1, -32680(GP)
9D011BFC  26638FD8   ADDIU V1, S3, -28712
9D011C00  8C640054   LW A0, 84(V1)
9D011C04  24840003   ADDIU A0, A0, 3
9D011C08  AC640054   SW A0, 84(V1)
9D011C0C  0B40470C   J 0x9D011C30
9D011C10  02228821   ADDU S1, S1, V0
9D011C14  8F828058   LW V0, -32680(GP)
9D011C18  2442FFFE   ADDIU V0, V0, -2
9D011C1C  AF828058   SW V0, -32680(GP)
9D011C20  26628FD8   ADDIU V0, S3, -28712
9D011C24  8C430054   LW V1, 84(V0)
9D011C28  24630002   ADDIU V1, V1, 2
9D011C2C  AC430054   SW V1, 84(V0)
2240:                         OPCODE_END
9D011C30  8F828058   LW V0, -32680(GP)
9D011C34  1840068A   BLEZ V0, .L45
9D011C38  26300001   ADDIU S0, S1, 1
9D011C58  90420000   LBU V0, 0(V0)
9D011C5C  00021080   SLL V0, V0, 2
9D011C60  00561021   ADDU V0, V0, S6
9D011C64  0B402953   J 0x9D00A54C
9D011C68  8C420000   LW V0, 0(V0)
2241:                
2242:                      OPCODE_BEGIN(D1)  /* CMP ($nn),Y */
2243:                         CMP(5, INDIR_Y_BYTE_READ);
9D011CA4  8FA50010   LW A1, 16(SP)
9D011CA8  00852021   ADDU A0, A0, A1
9D011CAC  3084FFFF   ANDI A0, A0, -1
9D011CB0  308200FF   ANDI V0, A0, 255
9D011CB4  0045102B   SLTU V0, V0, A1
9D011CB8  10400008   BEQ V0, ZERO, 0x9D011CDC
9D011CBC  26110001   ADDIU S1, S0, 1
9D011CC0  8F828058   LW V0, -32680(GP)
9D011CC4  2442FFFF   ADDIU V0, V0, -1
9D011CC8  AF828058   SW V0, -32680(GP)
9D011CCC  26628FD8   ADDIU V0, S3, -28712
9D011CD0  8C430054   LW V1, 84(V0)
9D011CD4  24630001   ADDIU V1, V1, 1
9D011CD8  AC430054   SW V1, 84(V0)
9D011CDC  0F402804   JAL mem_readbyte
9D011CE0  00000000   NOP
9D011CE4  02821023   SUBU V0, S4, V0
9D011CE8  7C570200   EXT S7, V0, 8, 1
9D011CEC  3AF70001   XORI S7, S7, 1
9D011CF0  305200FF   ANDI S2, V0, 255
9D011CF4  8F828058   LW V0, -32680(GP)
9D011CF8  2442FFFB   ADDIU V0, V0, -5
9D011CFC  AF828058   SW V0, -32680(GP)
9D011D00  26638FD8   ADDIU V1, S3, -28712
9D011D04  8C640054   LW A0, 84(V1)
9D011D08  24840005   ADDIU A0, A0, 5
9D011D14  0B404D98   J .L45
9D011D18  0240A821   ADDU S5, S2, ZERO
2244:                         OPCODE_END
9D011D0C  1C400003   BGTZ V0, 0x9D011D1C
9D011D10  AC640054   SW A0, 84(V1)
9D011D1C  26100002   ADDIU S0, S0, 2
9D011D3C  90420000   LBU V0, 0(V0)
9D011D40  00021080   SLL V0, V0, 2
9D011D44  00561021   ADDU V0, V0, S6
9D011D48  8C420000   LW V0, 0(V0)
9D011D4C  0B402953   J 0x9D00A54C
9D011D50  0240A821   ADDU S5, S2, ZERO
2245:                
2246:                      OPCODE_BEGIN(D3)  /* DCP ($nn),Y */
2247:                         DCP(8, INDIR_Y, mem_writebyte, addr);
9D011D54  26110001   ADDIU S1, S0, 1
9D011D90  8FA60010   LW A2, 16(SP)
9D011D94  02E6B821   ADDU S7, S7, A2
9D011D98  32F7FFFF   ANDI S7, S7, -1
9D011D9C  0F402804   JAL mem_readbyte
9D011DA0  02E02021   ADDU A0, S7, ZERO
9D011DA4  2442FFFF   ADDIU V0, V0, -1
9D011DA8  305200FF   ANDI S2, V0, 255
9D011DAC  02E02021   ADDU A0, S7, ZERO
9D011DB0  0F40283A   JAL mem_writebyte
9D011DB4  02402821   ADDU A1, S2, ZERO
9D011DB8  02929023   SUBU S2, S4, S2
9D011DBC  7E570200   EXT S7, S2, 8, 1
9D011DC0  3AF70001   XORI S7, S7, 1
9D011DC4  325200FF   ANDI S2, S2, 255
9D011DC8  8F828058   LW V0, -32680(GP)
9D011DCC  2442FFF8   ADDIU V0, V0, -8
9D011DD0  AF828058   SW V0, -32680(GP)
9D011DD4  8EA30054   LW V1, 84(S5)
9D011DD8  24630008   ADDIU V1, V1, 8
9D011DE4  0B404D98   J .L45
9D011DE8  0240A821   ADDU S5, S2, ZERO
2248:                         OPCODE_END
9D011DDC  1C400003   BGTZ V0, 0x9D011DEC
9D011DE0  AEA30054   SW V1, 84(S5)
9D011DEC  26100002   ADDIU S0, S0, 2
9D011E0C  90420000   LBU V0, 0(V0)
9D011E10  00021080   SLL V0, V0, 2
9D011E14  00561021   ADDU V0, V0, S6
9D011E18  8C420000   LW V0, 0(V0)
9D011E1C  0B402953   J 0x9D00A54C
9D011E20  0240A821   ADDU S5, S2, ZERO
2249:                
2250:                      OPCODE_BEGIN(D5)  /* CMP $nn,X */
2251:                         CMP(4, ZP_IND_X_BYTE);
9D011E24  26110001   ADDIU S1, S0, 1
9D011E44  90630000   LBU V1, 0(V1)
9D011E48  03C31821   ADDU V1, FP, V1
9D011E4C  306300FF   ANDI V1, V1, 255
9D011E50  8F848054   LW A0, -32684(GP)
9D011E54  00831821   ADDU V1, A0, V1
9D011E58  90720000   LBU S2, 0(V1)
9D011E5C  02929023   SUBU S2, S4, S2
9D011E60  7E570200   EXT S7, S2, 8, 1
9D011E64  3AF70001   XORI S7, S7, 1
9D011E68  325200FF   ANDI S2, S2, 255
9D011E6C  8F838058   LW V1, -32680(GP)
9D011E70  2463FFFC   ADDIU V1, V1, -4
9D011E74  AF838058   SW V1, -32680(GP)
9D011E78  8C440054   LW A0, 84(V0)
9D011E7C  24840004   ADDIU A0, A0, 4
9D011E88  0B404D98   J .L45
9D011E8C  0240A821   ADDU S5, S2, ZERO
2252:                         OPCODE_END
9D011E80  1C600003   BGTZ V1, 0x9D011E90
9D011E84  AC440054   SW A0, 84(V0)
9D011E90  26100002   ADDIU S0, S0, 2
9D011EB0  90420000   LBU V0, 0(V0)
9D011EB4  00021080   SLL V0, V0, 2
9D011EB8  00561021   ADDU V0, V0, S6
9D011EBC  8C420000   LW V0, 0(V0)
9D011EC0  0B402953   J 0x9D00A54C
9D011EC4  0240A821   ADDU S5, S2, ZERO
2253:                
2254:                      OPCODE_BEGIN(D6)  /* DEC $nn,X */
2255:                         DEC(6, ZP_IND_X, ZP_WRITEBYTE, baddr);
9D011EC8  26110001   ADDIU S1, S0, 1
9D011EE8  90630000   LBU V1, 0(V1)
9D011EEC  03C31821   ADDU V1, FP, V1
9D011EF0  306300FF   ANDI V1, V1, 255
9D011EF4  8F848054   LW A0, -32684(GP)
9D011EF8  00831821   ADDU V1, A0, V1
9D011EFC  90720000   LBU S2, 0(V1)
9D011F00  2652FFFF   ADDIU S2, S2, -1
9D011F04  325200FF   ANDI S2, S2, 255
9D011F08  A0720000   SB S2, 0(V1)
9D011F0C  8F838058   LW V1, -32680(GP)
9D011F10  2463FFFA   ADDIU V1, V1, -6
9D011F14  AF838058   SW V1, -32680(GP)
9D011F18  8C440054   LW A0, 84(V0)
9D011F1C  24840006   ADDIU A0, A0, 6
9D011F28  0B404D98   J .L45
9D011F2C  0240A821   ADDU S5, S2, ZERO
2256:                         OPCODE_END
9D011F20  1C600003   BGTZ V1, 0x9D011F30
9D011F24  AC440054   SW A0, 84(V0)
9D011F30  26100002   ADDIU S0, S0, 2
9D011F50  90420000   LBU V0, 0(V0)
9D011F54  00021080   SLL V0, V0, 2
9D011F58  00561021   ADDU V0, V0, S6
9D011F5C  8C420000   LW V0, 0(V0)
9D011F60  0B402953   J 0x9D00A54C
9D011F64  0240A821   ADDU S5, S2, ZERO
2257:                
2258:                      OPCODE_BEGIN(D7)  /* DCP $nn,X */
2259:                         DCP(6, ZP_IND_X, ZP_WRITEBYTE, baddr);
9D011F68  26110001   ADDIU S1, S0, 1
9D011F88  90630000   LBU V1, 0(V1)
9D011F8C  03C31821   ADDU V1, FP, V1
9D011F90  306300FF   ANDI V1, V1, 255
9D011F94  8F848054   LW A0, -32684(GP)
9D011F98  00831821   ADDU V1, A0, V1
9D011F9C  90720000   LBU S2, 0(V1)
9D011FA0  2652FFFF   ADDIU S2, S2, -1
9D011FA4  325200FF   ANDI S2, S2, 255
9D011FA8  A0720000   SB S2, 0(V1)
9D011FAC  02929023   SUBU S2, S4, S2
9D011FB0  7E570200   EXT S7, S2, 8, 1
9D011FB4  3AF70001   XORI S7, S7, 1
9D011FB8  325200FF   ANDI S2, S2, 255
9D011FBC  8F838058   LW V1, -32680(GP)
9D011FC0  2463FFFA   ADDIU V1, V1, -6
9D011FC4  AF838058   SW V1, -32680(GP)
9D011FC8  8C440054   LW A0, 84(V0)
9D011FCC  24840006   ADDIU A0, A0, 6
9D011FD8  0B404D98   J .L45
9D011FDC  0240A821   ADDU S5, S2, ZERO
2260:                         OPCODE_END
9D011FD0  1C600003   BGTZ V1, 0x9D011FE0
9D011FD4  AC440054   SW A0, 84(V0)
9D011FE0  26100002   ADDIU S0, S0, 2
9D012000  90420000   LBU V0, 0(V0)
9D012004  00021080   SLL V0, V0, 2
9D012008  00561021   ADDU V0, V0, S6
9D01200C  8C420000   LW V0, 0(V0)
9D012010  0B402953   J 0x9D00A54C
9D012014  0240A821   ADDU S5, S2, ZERO
2261:                
2262:                      OPCODE_BEGIN(D8)  /* CLD */
2263:                         CLD();
9D012018  8F828058   LW V0, -32680(GP)
9D01201C  2442FFFE   ADDIU V0, V0, -2
9D012020  AF828058   SW V0, -32680(GP)
9D012024  26638FD8   ADDIU V1, S3, -28712
9D012028  8C640054   LW A0, 84(V1)
9D01202C  24840002   ADDIU A0, A0, 2
9D01203C  0B404D98   J .L45
9D012040  AFA00020   SW ZERO, 32(SP)
2264:                         OPCODE_END
9D012030  1C400004   BGTZ V0, .LBB1414
9D012034  AC640054   SW A0, 84(V1)
9D012038  02008821   ADDU S1, S0, ZERO
9D012060  90420000   LBU V0, 0(V0)
9D012064  00021080   SLL V0, V0, 2
9D012068  00561021   ADDU V0, V0, S6
9D01206C  8C420000   LW V0, 0(V0)
9D012070  26100001   ADDIU S0, S0, 1
9D012074  0B402953   J 0x9D00A54C
9D012078  AFA00020   SW ZERO, 32(SP)
2265:                
2266:                      OPCODE_BEGIN(D9)  /* CMP $nnnn,Y */
2267:                         CMP(4, ABS_IND_Y_BYTE_READ);
9D01207C  0F402863   JAL bank_readword
9D012080  02002021   ADDU A0, S0, ZERO
9D012084  8FA70010   LW A3, 16(SP)
9D012088  00471021   ADDU V0, V0, A3
9D01208C  3044FFFF   ANDI A0, V0, -1
9D012090  308200FF   ANDI V0, A0, 255
9D012094  0047102B   SLTU V0, V0, A3
9D012098  10400008   BEQ V0, ZERO, 0x9D0120BC
9D01209C  26110002   ADDIU S1, S0, 2
9D0120A0  8F828058   LW V0, -32680(GP)
9D0120A4  2442FFFF   ADDIU V0, V0, -1
9D0120A8  AF828058   SW V0, -32680(GP)
9D0120AC  26628FD8   ADDIU V0, S3, -28712
9D0120B0  8C430054   LW V1, 84(V0)
9D0120B4  24630001   ADDIU V1, V1, 1
9D0120B8  AC430054   SW V1, 84(V0)
9D0120BC  0F402804   JAL mem_readbyte
9D0120C0  00000000   NOP
9D0120C4  02821023   SUBU V0, S4, V0
9D0120C8  7C570200   EXT S7, V0, 8, 1
9D0120CC  3AF70001   XORI S7, S7, 1
9D0120D0  305200FF   ANDI S2, V0, 255
9D0120D4  8F828058   LW V0, -32680(GP)
9D0120D8  2442FFFC   ADDIU V0, V0, -4
9D0120DC  AF828058   SW V0, -32680(GP)
9D0120E0  26638FD8   ADDIU V1, S3, -28712
9D0120E4  8C640054   LW A0, 84(V1)
9D0120E8  24840004   ADDIU A0, A0, 4
9D0120F4  0B404D98   J .L45
9D0120F8  0240A821   ADDU S5, S2, ZERO
2268:                         OPCODE_END
9D0120EC  1C400003   BGTZ V0, 0x9D0120FC
9D0120F0  AC640054   SW A0, 84(V1)
9D0120FC  26100003   ADDIU S0, S0, 3
9D01211C  90420000   LBU V0, 0(V0)
9D012120  00021080   SLL V0, V0, 2
9D012124  00561021   ADDU V0, V0, S6
9D012128  8C420000   LW V0, 0(V0)
9D01212C  0B402953   J 0x9D00A54C
9D012130  0240A821   ADDU S5, S2, ZERO
2269:                
2270:                      OPCODE_BEGIN(DB)  /* DCP $nnnn,Y */
2271:                         DCP(7, ABS_IND_Y, mem_writebyte, addr);
9D012134  0F402863   JAL bank_readword
9D012138  02002021   ADDU A0, S0, ZERO
9D01213C  26110002   ADDIU S1, S0, 2
9D012140  8FA30010   LW V1, 16(SP)
9D012144  00431021   ADDU V0, V0, V1
9D012148  3055FFFF   ANDI S5, V0, -1
9D01214C  0F402804   JAL mem_readbyte
9D012150  02A02021   ADDU A0, S5, ZERO
9D012154  2442FFFF   ADDIU V0, V0, -1
9D012158  305200FF   ANDI S2, V0, 255
9D01215C  02A02021   ADDU A0, S5, ZERO
9D012160  0F40283A   JAL mem_writebyte
9D012164  02402821   ADDU A1, S2, ZERO
9D012168  02929023   SUBU S2, S4, S2
9D01216C  7E570200   EXT S7, S2, 8, 1
9D012170  3AF70001   XORI S7, S7, 1
9D012174  325200FF   ANDI S2, S2, 255
9D012178  8F828058   LW V0, -32680(GP)
9D01217C  2442FFF9   ADDIU V0, V0, -7
9D012180  AF828058   SW V0, -32680(GP)
9D012184  26638FD8   ADDIU V1, S3, -28712
9D012188  8C640054   LW A0, 84(V1)
9D01218C  24840007   ADDIU A0, A0, 7
9D012198  0B404D98   J .L45
9D01219C  0240A821   ADDU S5, S2, ZERO
2272:                         OPCODE_END                  
9D012190  1C400003   BGTZ V0, 0x9D0121A0
9D012194  AC640054   SW A0, 84(V1)
9D0121A0  26100003   ADDIU S0, S0, 3
9D0121C0  90420000   LBU V0, 0(V0)
9D0121C4  00021080   SLL V0, V0, 2
9D0121C8  00561021   ADDU V0, V0, S6
9D0121CC  8C420000   LW V0, 0(V0)
9D0121D0  0B402953   J 0x9D00A54C
9D0121D4  0240A821   ADDU S5, S2, ZERO
2273:                
2274:                      OPCODE_BEGIN(DD)  /* CMP $nnnn,X */
2275:                         CMP(4, ABS_IND_X_BYTE_READ);
9D0121D8  0F402863   JAL bank_readword
9D0121DC  02002021   ADDU A0, S0, ZERO
9D0121E0  005E1021   ADDU V0, V0, FP
9D0121E4  3044FFFF   ANDI A0, V0, -1
9D0121E8  308200FF   ANDI V0, A0, 255
9D0121EC  005E102B   SLTU V0, V0, FP
9D0121F0  10400008   BEQ V0, ZERO, 0x9D012214
9D0121F4  26110002   ADDIU S1, S0, 2
9D0121F8  8F828058   LW V0, -32680(GP)
9D0121FC  2442FFFF   ADDIU V0, V0, -1
9D012200  AF828058   SW V0, -32680(GP)
9D012204  26628FD8   ADDIU V0, S3, -28712
9D012208  8C430054   LW V1, 84(V0)
9D01220C  24630001   ADDIU V1, V1, 1
9D012210  AC430054   SW V1, 84(V0)
9D012214  0F402804   JAL mem_readbyte
9D012218  00000000   NOP
9D01221C  02821023   SUBU V0, S4, V0
9D012220  7C570200   EXT S7, V0, 8, 1
9D012224  3AF70001   XORI S7, S7, 1
9D012228  305200FF   ANDI S2, V0, 255
9D01222C  8F828058   LW V0, -32680(GP)
9D012230  2442FFFC   ADDIU V0, V0, -4
9D012234  AF828058   SW V0, -32680(GP)
9D012238  26638FD8   ADDIU V1, S3, -28712
9D01223C  8C640054   LW A0, 84(V1)
9D012240  24840004   ADDIU A0, A0, 4
9D01224C  0B404D98   J .L45
9D012250  0240A821   ADDU S5, S2, ZERO
2276:                         OPCODE_END
9D012244  1C400003   BGTZ V0, 0x9D012254
9D012248  AC640054   SW A0, 84(V1)
9D012254  26100003   ADDIU S0, S0, 3
9D012274  90420000   LBU V0, 0(V0)
9D012278  00021080   SLL V0, V0, 2
9D01227C  00561021   ADDU V0, V0, S6
9D012280  8C420000   LW V0, 0(V0)
9D012284  0B402953   J 0x9D00A54C
9D012288  0240A821   ADDU S5, S2, ZERO
2277:                
2278:                      OPCODE_BEGIN(DE)  /* DEC $nnnn,X */
2279:                         DEC(7, ABS_IND_X, mem_writebyte, addr);
9D01228C  0F402863   JAL bank_readword
9D012290  02002021   ADDU A0, S0, ZERO
9D012294  26110002   ADDIU S1, S0, 2
9D012298  005E1021   ADDU V0, V0, FP
9D01229C  3055FFFF   ANDI S5, V0, -1
9D0122A0  0F402804   JAL mem_readbyte
9D0122A4  02A02021   ADDU A0, S5, ZERO
9D0122A8  2442FFFF   ADDIU V0, V0, -1
9D0122AC  305200FF   ANDI S2, V0, 255
9D0122B0  02A02021   ADDU A0, S5, ZERO
9D0122B4  0F40283A   JAL mem_writebyte
9D0122B8  02402821   ADDU A1, S2, ZERO
9D0122BC  8F828058   LW V0, -32680(GP)
9D0122C0  2442FFF9   ADDIU V0, V0, -7
9D0122C4  AF828058   SW V0, -32680(GP)
9D0122C8  26638FD8   ADDIU V1, S3, -28712
9D0122CC  8C640054   LW A0, 84(V1)
9D0122D0  24840007   ADDIU A0, A0, 7
9D0122DC  0B404D98   J .L45
9D0122E0  0240A821   ADDU S5, S2, ZERO
2280:                         OPCODE_END
9D0122D4  1C400003   BGTZ V0, 0x9D0122E4
9D0122D8  AC640054   SW A0, 84(V1)
9D0122E4  26100003   ADDIU S0, S0, 3
9D012304  90420000   LBU V0, 0(V0)
9D012308  00021080   SLL V0, V0, 2
9D01230C  00561021   ADDU V0, V0, S6
9D012310  8C420000   LW V0, 0(V0)
9D012314  0B402953   J 0x9D00A54C
9D012318  0240A821   ADDU S5, S2, ZERO
2281:                
2282:                      OPCODE_BEGIN(DF)  /* DCP $nnnn,X */
2283:                         DCP(7, ABS_IND_X, mem_writebyte, addr);
9D01231C  0F402863   JAL bank_readword
9D012320  02002021   ADDU A0, S0, ZERO
9D012324  26110002   ADDIU S1, S0, 2
9D012328  005E1021   ADDU V0, V0, FP
9D01232C  3055FFFF   ANDI S5, V0, -1
9D012330  0F402804   JAL mem_readbyte
9D012334  02A02021   ADDU A0, S5, ZERO
9D012338  2442FFFF   ADDIU V0, V0, -1
9D01233C  305200FF   ANDI S2, V0, 255
9D012340  02A02021   ADDU A0, S5, ZERO
9D012344  0F40283A   JAL mem_writebyte
9D012348  02402821   ADDU A1, S2, ZERO
9D01234C  02929023   SUBU S2, S4, S2
9D012350  7E570200   EXT S7, S2, 8, 1
9D012354  3AF70001   XORI S7, S7, 1
9D012358  325200FF   ANDI S2, S2, 255
9D01235C  8F828058   LW V0, -32680(GP)
9D012360  2442FFF9   ADDIU V0, V0, -7
9D012364  AF828058   SW V0, -32680(GP)
9D012368  26638FD8   ADDIU V1, S3, -28712
9D01236C  8C640054   LW A0, 84(V1)
9D012370  24840007   ADDIU A0, A0, 7
9D01237C  0B404D98   J .L45
9D012380  0240A821   ADDU S5, S2, ZERO
2284:                         OPCODE_END
9D012374  1C400003   BGTZ V0, 0x9D012384
9D012378  AC640054   SW A0, 84(V1)
9D012384  26100003   ADDIU S0, S0, 3
9D0123A4  90420000   LBU V0, 0(V0)
9D0123A8  00021080   SLL V0, V0, 2
9D0123AC  00561021   ADDU V0, V0, S6
9D0123B0  8C420000   LW V0, 0(V0)
9D0123B4  0B402953   J 0x9D00A54C
9D0123B8  0240A821   ADDU S5, S2, ZERO
2285:                
2286:                      OPCODE_BEGIN(E0)  /* CPX #$nn */
2287:                         CPX(2, IMMEDIATE_BYTE);
9D0123BC  26110001   ADDIU S1, S0, 1
9D0123DC  90720000   LBU S2, 0(V1)
9D0123E0  03D29023   SUBU S2, FP, S2
9D0123E4  7E570200   EXT S7, S2, 8, 1
9D0123E8  3AF70001   XORI S7, S7, 1
9D0123EC  325200FF   ANDI S2, S2, 255
9D0123F0  8F838058   LW V1, -32680(GP)
9D0123F4  2463FFFE   ADDIU V1, V1, -2
9D0123F8  AF838058   SW V1, -32680(GP)
9D0123FC  8C440054   LW A0, 84(V0)
9D012400  24840002   ADDIU A0, A0, 2
9D01240C  0B404D98   J .L45
9D012410  0240A821   ADDU S5, S2, ZERO
2288:                         OPCODE_END
9D012404  1C600003   BGTZ V1, 0x9D012414
9D012408  AC440054   SW A0, 84(V0)
9D012414  26100002   ADDIU S0, S0, 2
9D012434  90420000   LBU V0, 0(V0)
9D012438  00021080   SLL V0, V0, 2
9D01243C  00561021   ADDU V0, V0, S6
9D012440  8C420000   LW V0, 0(V0)
9D012444  0B402953   J 0x9D00A54C
9D012448  0240A821   ADDU S5, S2, ZERO
2289:                
2290:                      OPCODE_BEGIN(E1)  /* SBC ($nn,X) */
2291:                         SBC(6, INDIR_X_BYTE);
9D01244C  26110001   ADDIU S1, S0, 1
9D01246C  90420000   LBU V0, 0(V0)
9D012470  03C21021   ADDU V0, FP, V0
9D01248C  0F402804   JAL mem_readbyte
9D012490  308400FF   ANDI A0, A0, 255
9D012494  02821823   SUBU V1, S4, V0
9D012498  3AF70001   XORI S7, S7, 1
9D01249C  00771823   SUBU V1, V1, S7
9D0124A0  307200FF   ANDI S2, V1, 255
9D0124A4  00541026   XOR V0, V0, S4
9D0124A8  7C023004   INS V0, ZERO, 0, 7
9D0124AC  0254A026   XOR S4, S2, S4
9D0124B0  00541024   AND V0, V0, S4
9D0124B4  304200FF   ANDI V0, V0, 255
9D0124B8  AFA20014   SW V0, 20(SP)
9D0124BC  38630100   XORI V1, V1, 256
9D0124C0  7C770200   EXT S7, V1, 8, 1
9D0124C4  8F828058   LW V0, -32680(GP)
9D0124C8  2442FFFA   ADDIU V0, V0, -6
9D0124CC  AF828058   SW V0, -32680(GP)
9D0124D0  8EA30054   LW V1, 84(S5)
9D0124D4  24630006   ADDIU V1, V1, 6
9D0124E0  0240A021   ADDU S4, S2, ZERO
9D0124E4  0B404D98   J .L45
9D0124E8  0240A821   ADDU S5, S2, ZERO
9D01251C  0240A021   ADDU S4, S2, ZERO
2292:                         OPCODE_END
9D0124D8  1C400004   BGTZ V0, 0x9D0124EC
9D0124DC  AEA30054   SW V1, 84(S5)
9D0124EC  26100002   ADDIU S0, S0, 2
9D01250C  90420000   LBU V0, 0(V0)
9D012510  00021080   SLL V0, V0, 2
9D012514  00561021   ADDU V0, V0, S6
9D012518  8C420000   LW V0, 0(V0)
9D012520  0B402953   J 0x9D00A54C
9D012524  0240A821   ADDU S5, S2, ZERO
2293:                
2294:                      OPCODE_BEGIN(E3)  /* ISB ($nn,X) */
2295:                         ISB(8, INDIR_X, mem_writebyte, addr);
9D012528  26110001   ADDIU S1, S0, 1
9D012548  90420000   LBU V0, 0(V0)
9D01254C  03C21021   ADDU V0, FP, V0
9D01256C  0F402804   JAL mem_readbyte
9D012570  02402021   ADDU A0, S2, ZERO
9D012574  24420001   ADDIU V0, V0, 1
9D012578  304200FF   ANDI V0, V0, 255
9D01257C  AFA20014   SW V0, 20(SP)
9D012580  02402021   ADDU A0, S2, ZERO
9D012584  0F40283A   JAL mem_writebyte
9D012588  00402821   ADDU A1, V0, ZERO
9D01258C  8FA40014   LW A0, 20(SP)
9D012590  02841023   SUBU V0, S4, A0
9D012594  3AF70001   XORI S7, S7, 1
9D012598  00571023   SUBU V0, V0, S7
9D01259C  305200FF   ANDI S2, V0, 255
9D0125A0  00941826   XOR V1, A0, S4
9D0125A4  7C033004   INS V1, ZERO, 0, 7
9D0125A8  0254A026   XOR S4, S2, S4
9D0125AC  00741824   AND V1, V1, S4
9D0125B0  306300FF   ANDI V1, V1, 255
9D0125B4  AFA30014   SW V1, 20(SP)
9D0125B8  38420100   XORI V0, V0, 256
9D0125BC  7C570200   EXT S7, V0, 8, 1
9D0125C0  8F828058   LW V0, -32680(GP)
9D0125C4  2442FFF8   ADDIU V0, V0, -8
9D0125C8  AF828058   SW V0, -32680(GP)
9D0125CC  8EA30054   LW V1, 84(S5)
9D0125D0  24630008   ADDIU V1, V1, 8
9D0125DC  0240A021   ADDU S4, S2, ZERO
9D0125E0  0B404D98   J .L45
9D0125E4  0240A821   ADDU S5, S2, ZERO
9D012618  0240A021   ADDU S4, S2, ZERO
2296:                         OPCODE_END
9D0125D4  1C400004   BGTZ V0, 0x9D0125E8
9D0125D8  AEA30054   SW V1, 84(S5)
9D0125E8  26100002   ADDIU S0, S0, 2
9D012608  90420000   LBU V0, 0(V0)
9D01260C  00021080   SLL V0, V0, 2
9D012610  00561021   ADDU V0, V0, S6
9D012614  8C420000   LW V0, 0(V0)
9D01261C  0B402953   J 0x9D00A54C
9D012620  0240A821   ADDU S5, S2, ZERO
2297:                
2298:                      OPCODE_BEGIN(E4)  /* CPX $nn */
2299:                         CPX(3, ZERO_PAGE_BYTE);
9D012624  26110001   ADDIU S1, S0, 1
9D012644  90630000   LBU V1, 0(V1)
9D012648  8F848054   LW A0, -32684(GP)
9D01264C  00831821   ADDU V1, A0, V1
9D012650  90720000   LBU S2, 0(V1)
9D012654  03D29023   SUBU S2, FP, S2
9D012658  7E570200   EXT S7, S2, 8, 1
9D01265C  3AF70001   XORI S7, S7, 1
9D012660  325200FF   ANDI S2, S2, 255
9D012664  8F838058   LW V1, -32680(GP)
9D012668  2463FFFD   ADDIU V1, V1, -3
9D01266C  AF838058   SW V1, -32680(GP)
9D012670  8C440054   LW A0, 84(V0)
9D012674  24840003   ADDIU A0, A0, 3
9D012680  0B404D98   J .L45
9D012684  0240A821   ADDU S5, S2, ZERO
2300:                         OPCODE_END
9D012678  1C600003   BGTZ V1, 0x9D012688
9D01267C  AC440054   SW A0, 84(V0)
9D012688  26100002   ADDIU S0, S0, 2
9D0126A8  90420000   LBU V0, 0(V0)
9D0126AC  00021080   SLL V0, V0, 2
9D0126B0  00561021   ADDU V0, V0, S6
9D0126B4  8C420000   LW V0, 0(V0)
9D0126B8  0B402953   J 0x9D00A54C
9D0126BC  0240A821   ADDU S5, S2, ZERO
2301:                
2302:                      OPCODE_BEGIN(E5)  /* SBC $nn */
2303:                         SBC(3, ZERO_PAGE_BYTE);
9D0126C0  26110001   ADDIU S1, S0, 1
9D0126E0  90630000   LBU V1, 0(V1)
9D0126E4  8F848054   LW A0, -32684(GP)
9D0126E8  00831821   ADDU V1, A0, V1
9D0126EC  90640000   LBU A0, 0(V1)
9D0126F0  02841823   SUBU V1, S4, A0
9D0126F4  3AF70001   XORI S7, S7, 1
9D0126F8  00771823   SUBU V1, V1, S7
9D0126FC  307200FF   ANDI S2, V1, 255
9D012700  00942026   XOR A0, A0, S4
9D012704  7C043004   INS A0, ZERO, 0, 7
9D012708  0254A026   XOR S4, S2, S4
9D01270C  00942024   AND A0, A0, S4
9D012710  308400FF   ANDI A0, A0, 255
9D012714  AFA40014   SW A0, 20(SP)
9D012718  38630100   XORI V1, V1, 256
9D01271C  7C770200   EXT S7, V1, 8, 1
9D012720  8F838058   LW V1, -32680(GP)
9D012724  2463FFFD   ADDIU V1, V1, -3
9D012728  AF838058   SW V1, -32680(GP)
9D01272C  8C440054   LW A0, 84(V0)
9D012730  24840003   ADDIU A0, A0, 3
9D01273C  0240A021   ADDU S4, S2, ZERO
9D012740  0B404D98   J .L45
9D012744  0240A821   ADDU S5, S2, ZERO
9D012778  0240A021   ADDU S4, S2, ZERO
2304:                         OPCODE_END
9D012734  1C600004   BGTZ V1, 0x9D012748
9D012738  AC440054   SW A0, 84(V0)
9D012748  26100002   ADDIU S0, S0, 2
9D012768  90420000   LBU V0, 0(V0)
9D01276C  00021080   SLL V0, V0, 2
9D012770  00561021   ADDU V0, V0, S6
9D012774  8C420000   LW V0, 0(V0)
9D01277C  0B402953   J 0x9D00A54C
9D012780  0240A821   ADDU S5, S2, ZERO
2305:                
2306:                      OPCODE_BEGIN(E6)  /* INC $nn */
2307:                         INC(5, ZERO_PAGE, ZP_WRITEBYTE, baddr);
9D012784  26110001   ADDIU S1, S0, 1
9D0127A4  90630000   LBU V1, 0(V1)
9D0127A8  8F848054   LW A0, -32684(GP)
9D0127AC  00831821   ADDU V1, A0, V1
9D0127B0  90720000   LBU S2, 0(V1)
9D0127B4  26520001   ADDIU S2, S2, 1
9D0127B8  325200FF   ANDI S2, S2, 255
9D0127BC  A0720000   SB S2, 0(V1)
9D0127C0  8F838058   LW V1, -32680(GP)
9D0127C4  2463FFFB   ADDIU V1, V1, -5
9D0127C8  AF838058   SW V1, -32680(GP)
9D0127CC  8C440054   LW A0, 84(V0)
9D0127D0  24840005   ADDIU A0, A0, 5
9D0127DC  0B404D98   J .L45
9D0127E0  0240A821   ADDU S5, S2, ZERO
2308:                         OPCODE_END
9D0127D4  1C600003   BGTZ V1, 0x9D0127E4
9D0127D8  AC440054   SW A0, 84(V0)
9D0127E4  26100002   ADDIU S0, S0, 2
9D012804  90420000   LBU V0, 0(V0)
9D012808  00021080   SLL V0, V0, 2
9D01280C  00561021   ADDU V0, V0, S6
9D012810  8C420000   LW V0, 0(V0)
9D012814  0B402953   J 0x9D00A54C
9D012818  0240A821   ADDU S5, S2, ZERO
2309:                
2310:                      OPCODE_BEGIN(E7)  /* ISB $nn */
2311:                         ISB(5, ZERO_PAGE, ZP_WRITEBYTE, baddr);
9D01281C  26110001   ADDIU S1, S0, 1
9D01283C  90630000   LBU V1, 0(V1)
9D012840  8F848054   LW A0, -32684(GP)
9D012844  00832021   ADDU A0, A0, V1
9D012848  90830000   LBU V1, 0(A0)
9D01284C  24630001   ADDIU V1, V1, 1
9D012850  306300FF   ANDI V1, V1, 255
9D012854  A0830000   SB V1, 0(A0)
9D012858  02832023   SUBU A0, S4, V1
9D01285C  3AF70001   XORI S7, S7, 1
9D012860  00972023   SUBU A0, A0, S7
9D012864  309200FF   ANDI S2, A0, 255
9D012868  00741826   XOR V1, V1, S4
9D01286C  7C033004   INS V1, ZERO, 0, 7
9D012870  0254A026   XOR S4, S2, S4
9D012874  00741824   AND V1, V1, S4
9D012878  306300FF   ANDI V1, V1, 255
9D01287C  AFA30014   SW V1, 20(SP)
9D012880  38840100   XORI A0, A0, 256
9D012884  7C970200   EXT S7, A0, 8, 1
9D012888  8F838058   LW V1, -32680(GP)
9D01288C  2463FFFB   ADDIU V1, V1, -5
9D012890  AF838058   SW V1, -32680(GP)
9D012894  8C440054   LW A0, 84(V0)
9D012898  24840005   ADDIU A0, A0, 5
9D0128A4  0240A021   ADDU S4, S2, ZERO
9D0128A8  0B404D98   J .L45
9D0128AC  0240A821   ADDU S5, S2, ZERO
9D0128E0  0240A021   ADDU S4, S2, ZERO
2312:                         OPCODE_END
9D01289C  1C600004   BGTZ V1, 0x9D0128B0
9D0128A0  AC440054   SW A0, 84(V0)
9D0128B0  26100002   ADDIU S0, S0, 2
9D0128D0  90420000   LBU V0, 0(V0)
9D0128D4  00021080   SLL V0, V0, 2
9D0128D8  00561021   ADDU V0, V0, S6
9D0128DC  8C420000   LW V0, 0(V0)
9D0128E4  0B402953   J 0x9D00A54C
9D0128E8  0240A821   ADDU S5, S2, ZERO
2313:                
2314:                      OPCODE_BEGIN(E8)  /* INX */
2315:                         INX();
9D0128EC  27D20001   ADDIU S2, FP, 1
9D0128F0  325200FF   ANDI S2, S2, 255
9D0128F4  8F828058   LW V0, -32680(GP)
9D0128F8  2442FFFE   ADDIU V0, V0, -2
9D0128FC  AF828058   SW V0, -32680(GP)
9D012900  26638FD8   ADDIU V1, S3, -28712
9D012904  8C640054   LW A0, 84(V1)
9D012908  24840002   ADDIU A0, A0, 2
9D012914  0240F021   ADDU FP, S2, ZERO
9D01291C  0B404D98   J .L45
9D012920  0240A821   ADDU S5, S2, ZERO
9D012950  0240F021   ADDU FP, S2, ZERO
2316:                         OPCODE_END
9D01290C  1C400005   BGTZ V0, .LBB1458
9D012910  AC640054   SW A0, 84(V1)
9D012918  02008821   ADDU S1, S0, ZERO
9D012940  90420000   LBU V0, 0(V0)
9D012944  00021080   SLL V0, V0, 2
9D012948  00561021   ADDU V0, V0, S6
9D01294C  8C420000   LW V0, 0(V0)
9D012954  26100001   ADDIU S0, S0, 1
9D012958  0B402953   J 0x9D00A54C
9D01295C  0240A821   ADDU S5, S2, ZERO
2317:                
2318:                      OPCODE_BEGIN(E9)  /* SBC #$nn */
2319:                      OPCODE_BEGIN(EB)  /* USBC #$nn */
2320:                         SBC(2, IMMEDIATE_BYTE);
9D012960  26110001   ADDIU S1, S0, 1
9D012984  02841823   SUBU V1, S4, A0
9D012988  3AF70001   XORI S7, S7, 1
9D01298C  00771823   SUBU V1, V1, S7
9D012990  307200FF   ANDI S2, V1, 255
9D012994  00942026   XOR A0, A0, S4
9D012998  7C043004   INS A0, ZERO, 0, 7
9D01299C  0254A026   XOR S4, S2, S4
9D0129A0  00942024   AND A0, A0, S4
9D0129A4  308400FF   ANDI A0, A0, 255
9D0129A8  AFA40014   SW A0, 20(SP)
9D0129AC  38630100   XORI V1, V1, 256
9D0129B0  7C770200   EXT S7, V1, 8, 1
9D0129B4  8F838058   LW V1, -32680(GP)
9D0129B8  2463FFFE   ADDIU V1, V1, -2
9D0129BC  AF838058   SW V1, -32680(GP)
9D0129C0  8C440054   LW A0, 84(V0)
9D0129C4  24840002   ADDIU A0, A0, 2
9D0129D0  0240A021   ADDU S4, S2, ZERO
9D0129D4  0B404D98   J .L45
9D0129D8  0240A821   ADDU S5, S2, ZERO
9D012A0C  0240A021   ADDU S4, S2, ZERO
2321:                         OPCODE_END
9D0129C8  1C600004   BGTZ V1, 0x9D0129DC
9D0129CC  AC440054   SW A0, 84(V0)
9D0129DC  26100002   ADDIU S0, S0, 2
9D0129FC  90420000   LBU V0, 0(V0)
9D012A00  00021080   SLL V0, V0, 2
9D012A04  00561021   ADDU V0, V0, S6
9D012A08  8C420000   LW V0, 0(V0)
9D012A10  0B402953   J 0x9D00A54C
9D012A14  0240A821   ADDU S5, S2, ZERO
2322:                
2323:                      OPCODE_BEGIN(EA)  /* NOP */
2324:                         NOP();
9D012A18  8F828058   LW V0, -32680(GP)
9D012A1C  2442FFFE   ADDIU V0, V0, -2
9D012A20  AF828058   SW V0, -32680(GP)
9D012A24  26638FD8   ADDIU V1, S3, -28712
9D012A28  8C640054   LW A0, 84(V1)
9D012A2C  24840002   ADDIU A0, A0, 2
2325:                         OPCODE_END
9D012A30  1C400003   BGTZ V0, .LBB1464
9D012A34  AC640054   SW A0, 84(V1)
9D012A38  0B404D98   J .L45
9D012A3C  02008821   ADDU S1, S0, ZERO
9D012A5C  90420000   LBU V0, 0(V0)
9D012A60  00021080   SLL V0, V0, 2
9D012A64  00561021   ADDU V0, V0, S6
9D012A68  8C420000   LW V0, 0(V0)
9D012A6C  0B402953   J 0x9D00A54C
9D012A70  26100001   ADDIU S0, S0, 1
2326:                
2327:                      OPCODE_BEGIN(EC)  /* CPX $nnnn */
2328:                         CPX(4, ABSOLUTE_BYTE);
9D012A74  0F402863   JAL bank_readword
9D012A78  02002021   ADDU A0, S0, ZERO
9D012A7C  26110002   ADDIU S1, S0, 2
9D012A80  0F402804   JAL mem_readbyte
9D012A84  00402021   ADDU A0, V0, ZERO
9D012A88  03C21023   SUBU V0, FP, V0
9D012A8C  7C570200   EXT S7, V0, 8, 1
9D012A90  3AF70001   XORI S7, S7, 1
9D012A94  305200FF   ANDI S2, V0, 255
9D012A98  8F828058   LW V0, -32680(GP)
9D012A9C  2442FFFC   ADDIU V0, V0, -4
9D012AA0  AF828058   SW V0, -32680(GP)
9D012AA4  26638FD8   ADDIU V1, S3, -28712
9D012AA8  8C640054   LW A0, 84(V1)
9D012AAC  24840004   ADDIU A0, A0, 4
9D012AB8  0B404D98   J .L45
9D012ABC  0240A821   ADDU S5, S2, ZERO
2329:                         OPCODE_END
9D012AB0  1C400003   BGTZ V0, 0x9D012AC0
9D012AB4  AC640054   SW A0, 84(V1)
9D012AC0  26100003   ADDIU S0, S0, 3
9D012AE0  90420000   LBU V0, 0(V0)
9D012AE4  00021080   SLL V0, V0, 2
9D012AE8  00561021   ADDU V0, V0, S6
9D012AEC  8C420000   LW V0, 0(V0)
9D012AF0  0B402953   J 0x9D00A54C
9D012AF4  0240A821   ADDU S5, S2, ZERO
2330:                
2331:                      OPCODE_BEGIN(ED)  /* SBC $nnnn */
2332:                         SBC(4, ABSOLUTE_BYTE);
9D012AF8  0F402863   JAL bank_readword
9D012AFC  02002021   ADDU A0, S0, ZERO
9D012B00  26110002   ADDIU S1, S0, 2
9D012B04  0F402804   JAL mem_readbyte
9D012B08  00402021   ADDU A0, V0, ZERO
9D012B0C  02821823   SUBU V1, S4, V0
9D012B10  3AF70001   XORI S7, S7, 1
9D012B14  00771823   SUBU V1, V1, S7
9D012B18  307200FF   ANDI S2, V1, 255
9D012B1C  00541026   XOR V0, V0, S4
9D012B20  7C023004   INS V0, ZERO, 0, 7
9D012B24  0254A026   XOR S4, S2, S4
9D012B28  00541024   AND V0, V0, S4
9D012B2C  304200FF   ANDI V0, V0, 255
9D012B30  AFA20014   SW V0, 20(SP)
9D012B34  38630100   XORI V1, V1, 256
9D012B38  7C770200   EXT S7, V1, 8, 1
9D012B3C  8F828058   LW V0, -32680(GP)
9D012B40  2442FFFC   ADDIU V0, V0, -4
9D012B44  AF828058   SW V0, -32680(GP)
9D012B48  26638FD8   ADDIU V1, S3, -28712
9D012B4C  8C640054   LW A0, 84(V1)
9D012B50  24840004   ADDIU A0, A0, 4
9D012B5C  0240A021   ADDU S4, S2, ZERO
9D012B60  0B404D98   J .L45
9D012B64  0240A821   ADDU S5, S2, ZERO
9D012B98  0240A021   ADDU S4, S2, ZERO
2333:                         OPCODE_END
9D012B54  1C400004   BGTZ V0, 0x9D012B68
9D012B58  AC640054   SW A0, 84(V1)
9D012B68  26100003   ADDIU S0, S0, 3
9D012B88  90420000   LBU V0, 0(V0)
9D012B8C  00021080   SLL V0, V0, 2
9D012B90  00561021   ADDU V0, V0, S6
9D012B94  8C420000   LW V0, 0(V0)
9D012B9C  0B402953   J 0x9D00A54C
9D012BA0  0240A821   ADDU S5, S2, ZERO
2334:                
2335:                      OPCODE_BEGIN(EE)  /* INC $nnnn */
2336:                         INC(6, ABSOLUTE, mem_writebyte, addr);
9D012BA4  0F402863   JAL bank_readword
9D012BA8  02002021   ADDU A0, S0, ZERO
9D012BAC  0040A821   ADDU S5, V0, ZERO
9D012BB0  26110002   ADDIU S1, S0, 2
9D012BB4  0F402804   JAL mem_readbyte
9D012BB8  00402021   ADDU A0, V0, ZERO
9D012BBC  24420001   ADDIU V0, V0, 1
9D012BC0  305200FF   ANDI S2, V0, 255
9D012BC4  02A02021   ADDU A0, S5, ZERO
9D012BC8  0F40283A   JAL mem_writebyte
9D012BCC  02402821   ADDU A1, S2, ZERO
9D012BD0  8F828058   LW V0, -32680(GP)
9D012BD4  2442FFFA   ADDIU V0, V0, -6
9D012BD8  AF828058   SW V0, -32680(GP)
9D012BDC  26638FD8   ADDIU V1, S3, -28712
9D012BE0  8C640054   LW A0, 84(V1)
9D012BE4  24840006   ADDIU A0, A0, 6
9D012BF0  0B404D98   J .L45
9D012BF4  0240A821   ADDU S5, S2, ZERO
2337:                         OPCODE_END
9D012BE8  1C400003   BGTZ V0, 0x9D012BF8
9D012BEC  AC640054   SW A0, 84(V1)
9D012BF8  26100003   ADDIU S0, S0, 3
9D012C18  90420000   LBU V0, 0(V0)
9D012C1C  00021080   SLL V0, V0, 2
9D012C20  00561021   ADDU V0, V0, S6
9D012C24  8C420000   LW V0, 0(V0)
9D012C28  0B402953   J 0x9D00A54C
9D012C2C  0240A821   ADDU S5, S2, ZERO
2338:                
2339:                      OPCODE_BEGIN(EF)  /* ISB $nnnn */
2340:                         ISB(6, ABSOLUTE, mem_writebyte, addr);
9D012C30  0F402863   JAL bank_readword
9D012C34  02002021   ADDU A0, S0, ZERO
9D012C38  00409021   ADDU S2, V0, ZERO
9D012C3C  26110002   ADDIU S1, S0, 2
9D012C40  0F402804   JAL mem_readbyte
9D012C44  00402021   ADDU A0, V0, ZERO
9D012C48  24420001   ADDIU V0, V0, 1
9D012C4C  305500FF   ANDI S5, V0, 255
9D012C50  02402021   ADDU A0, S2, ZERO
9D012C54  0F40283A   JAL mem_writebyte
9D012C58  02A02821   ADDU A1, S5, ZERO
9D012C5C  02951023   SUBU V0, S4, S5
9D012C60  3AF70001   XORI S7, S7, 1
9D012C64  00571023   SUBU V0, V0, S7
9D012C68  305200FF   ANDI S2, V0, 255
9D012C6C  02B41826   XOR V1, S5, S4
9D012C70  7C033004   INS V1, ZERO, 0, 7
9D012C74  0254A026   XOR S4, S2, S4
9D012C78  00741824   AND V1, V1, S4
9D012C7C  306300FF   ANDI V1, V1, 255
9D012C80  AFA30014   SW V1, 20(SP)
9D012C84  38420100   XORI V0, V0, 256
9D012C88  7C570200   EXT S7, V0, 8, 1
9D012C8C  8F828058   LW V0, -32680(GP)
9D012C90  2442FFFA   ADDIU V0, V0, -6
9D012C94  AF828058   SW V0, -32680(GP)
9D012C98  26638FD8   ADDIU V1, S3, -28712
9D012C9C  8C640054   LW A0, 84(V1)
9D012CA0  24840006   ADDIU A0, A0, 6
9D012CAC  0240A021   ADDU S4, S2, ZERO
9D012CB0  0B404D98   J .L45
9D012CB4  0240A821   ADDU S5, S2, ZERO
9D012CE8  0240A021   ADDU S4, S2, ZERO
2341:                         OPCODE_END
9D012CA4  1C400004   BGTZ V0, 0x9D012CB8
9D012CA8  AC640054   SW A0, 84(V1)
9D012CB8  26100003   ADDIU S0, S0, 3
9D012CD8  90420000   LBU V0, 0(V0)
9D012CDC  00021080   SLL V0, V0, 2
9D012CE0  00561021   ADDU V0, V0, S6
9D012CE4  8C420000   LW V0, 0(V0)
9D012CEC  0B402953   J 0x9D00A54C
9D012CF0  0240A821   ADDU S5, S2, ZERO
2342:                
2343:                      OPCODE_BEGIN(F0)  /* BEQ $nnnn */
2344:                         BEQ();
9D012CF4  16A0001E   BNE S5, ZERO, 0x9D012D70
9D012CF8  26110001   ADDIU S1, S0, 1
9D012CFC  26020001   ADDIU V0, S0, 1
9D012D1C  80710000   LB S1, 0(V1)
9D012D20  304300FF   ANDI V1, V0, 255
9D012D24  02231821   ADDU V1, S1, V1
9D012D28  30630100   ANDI V1, V1, 256
9D012D2C  10600008   BEQ V1, ZERO, 0x9D012D50
9D012D30  8F838058   LW V1, -32680(GP)
9D012D34  2463FFFF   ADDIU V1, V1, -1
9D012D38  AF838058   SW V1, -32680(GP)
9D012D3C  26638FD8   ADDIU V1, S3, -28712
9D012D40  8C640054   LW A0, 84(V1)
9D012D44  24840001   ADDIU A0, A0, 1
9D012D48  AC640054   SW A0, 84(V1)
9D012D4C  8F838058   LW V1, -32680(GP)
9D012D50  2463FFFD   ADDIU V1, V1, -3
9D012D54  AF838058   SW V1, -32680(GP)
9D012D58  26638FD8   ADDIU V1, S3, -28712
9D012D5C  8C640054   LW A0, 84(V1)
9D012D60  24840003   ADDIU A0, A0, 3
9D012D64  AC640054   SW A0, 84(V1)
9D012D68  0B404B63   J 0x9D012D8C
9D012D6C  02228821   ADDU S1, S1, V0
9D012D70  8F828058   LW V0, -32680(GP)
9D012D74  2442FFFE   ADDIU V0, V0, -2
9D012D78  AF828058   SW V0, -32680(GP)
9D012D7C  26628FD8   ADDIU V0, S3, -28712
9D012D80  8C430054   LW V1, 84(V0)
9D012D84  24630002   ADDIU V1, V1, 2
9D012D88  AC430054   SW V1, 84(V0)
2345:                         OPCODE_END
9D012D8C  8F828058   LW V0, -32680(GP)
9D012D90  18400233   BLEZ V0, .L45
9D012D94  26300001   ADDIU S0, S1, 1
9D012DB4  90420000   LBU V0, 0(V0)
9D012DB8  00021080   SLL V0, V0, 2
9D012DBC  00561021   ADDU V0, V0, S6
9D012DC0  0B402953   J 0x9D00A54C
9D012DC4  8C420000   LW V0, 0(V0)
2346:                
2347:                      OPCODE_BEGIN(F1)  /* SBC ($nn),Y */
2348:                         SBC(5, INDIR_Y_BYTE_READ);
9D012E00  8FA50010   LW A1, 16(SP)
9D012E04  00852021   ADDU A0, A0, A1
9D012E08  3084FFFF   ANDI A0, A0, -1
9D012E0C  308200FF   ANDI V0, A0, 255
9D012E10  0045102B   SLTU V0, V0, A1
9D012E14  10400008   BEQ V0, ZERO, 0x9D012E38
9D012E18  26110001   ADDIU S1, S0, 1
9D012E1C  8F828058   LW V0, -32680(GP)
9D012E20  2442FFFF   ADDIU V0, V0, -1
9D012E24  AF828058   SW V0, -32680(GP)
9D012E28  26628FD8   ADDIU V0, S3, -28712
9D012E2C  8C430054   LW V1, 84(V0)
9D012E30  24630001   ADDIU V1, V1, 1
9D012E34  AC430054   SW V1, 84(V0)
9D012E38  0F402804   JAL mem_readbyte
9D012E3C  3AF70001   XORI S7, S7, 1
9D012E40  02821823   SUBU V1, S4, V0
9D012E44  00771823   SUBU V1, V1, S7
9D012E48  307200FF   ANDI S2, V1, 255
9D012E4C  00541026   XOR V0, V0, S4
9D012E50  7C023004   INS V0, ZERO, 0, 7
9D012E54  0254A026   XOR S4, S2, S4
9D012E58  00541024   AND V0, V0, S4
9D012E5C  304200FF   ANDI V0, V0, 255
9D012E60  AFA20014   SW V0, 20(SP)
9D012E64  38630100   XORI V1, V1, 256
9D012E68  7C770200   EXT S7, V1, 8, 1
9D012E6C  8F828058   LW V0, -32680(GP)
9D012E70  2442FFFB   ADDIU V0, V0, -5
9D012E74  AF828058   SW V0, -32680(GP)
9D012E78  26638FD8   ADDIU V1, S3, -28712
9D012E7C  8C640054   LW A0, 84(V1)
9D012E80  24840005   ADDIU A0, A0, 5
9D012E8C  0240A021   ADDU S4, S2, ZERO
9D012E90  0B404D98   J .L45
9D012E94  0240A821   ADDU S5, S2, ZERO
9D012EC8  0240A021   ADDU S4, S2, ZERO
2349:                         OPCODE_END
9D012E84  1C400004   BGTZ V0, 0x9D012E98
9D012E88  AC640054   SW A0, 84(V1)
9D012E98  26100002   ADDIU S0, S0, 2
9D012EB8  90420000   LBU V0, 0(V0)
9D012EBC  00021080   SLL V0, V0, 2
9D012EC0  00561021   ADDU V0, V0, S6
9D012EC4  8C420000   LW V0, 0(V0)
9D012ECC  0B402953   J 0x9D00A54C
9D012ED0  0240A821   ADDU S5, S2, ZERO
2350:                
2351:                      OPCODE_BEGIN(F3)  /* ISB ($nn),Y */
2352:                         ISB(8, INDIR_Y, mem_writebyte, addr);
9D012ED4  26110001   ADDIU S1, S0, 1
9D012F10  8FA60010   LW A2, 16(SP)
9D012F14  02469021   ADDU S2, S2, A2
9D012F18  3252FFFF   ANDI S2, S2, -1
9D012F1C  0F402804   JAL mem_readbyte
9D012F20  02402021   ADDU A0, S2, ZERO
9D012F24  24420001   ADDIU V0, V0, 1
9D012F28  304200FF   ANDI V0, V0, 255
9D012F2C  AFA20014   SW V0, 20(SP)
9D012F30  02402021   ADDU A0, S2, ZERO
9D012F34  0F40283A   JAL mem_writebyte
9D012F38  00402821   ADDU A1, V0, ZERO
9D012F3C  8FA70014   LW A3, 20(SP)
9D012F40  02871023   SUBU V0, S4, A3
9D012F44  3AF70001   XORI S7, S7, 1
9D012F48  00571023   SUBU V0, V0, S7
9D012F4C  305200FF   ANDI S2, V0, 255
9D012F50  00F41826   XOR V1, A3, S4
9D012F54  7C033004   INS V1, ZERO, 0, 7
9D012F58  0254A026   XOR S4, S2, S4
9D012F5C  00741824   AND V1, V1, S4
9D012F60  306300FF   ANDI V1, V1, 255
9D012F64  AFA30014   SW V1, 20(SP)
9D012F68  38420100   XORI V0, V0, 256
9D012F6C  7C570200   EXT S7, V0, 8, 1
9D012F70  8F828058   LW V0, -32680(GP)
9D012F74  2442FFF8   ADDIU V0, V0, -8
9D012F78  AF828058   SW V0, -32680(GP)
9D012F7C  8EA30054   LW V1, 84(S5)
9D012F80  24630008   ADDIU V1, V1, 8
9D012F8C  0240A021   ADDU S4, S2, ZERO
9D012F90  0B404D98   J .L45
9D012F94  0240A821   ADDU S5, S2, ZERO
9D012FC8  0240A021   ADDU S4, S2, ZERO
2353:                         OPCODE_END
9D012F84  1C400004   BGTZ V0, 0x9D012F98
9D012F88  AEA30054   SW V1, 84(S5)
9D012F98  26100002   ADDIU S0, S0, 2
9D012FB8  90420000   LBU V0, 0(V0)
9D012FBC  00021080   SLL V0, V0, 2
9D012FC0  00561021   ADDU V0, V0, S6
9D012FC4  8C420000   LW V0, 0(V0)
9D012FCC  0B402953   J 0x9D00A54C
9D012FD0  0240A821   ADDU S5, S2, ZERO
2354:                
2355:                      OPCODE_BEGIN(F5)  /* SBC $nn,X */
2356:                         SBC(4, ZP_IND_X_BYTE);
9D012FD4  26110001   ADDIU S1, S0, 1
9D012FF4  90630000   LBU V1, 0(V1)
9D012FF8  03C31821   ADDU V1, FP, V1
9D012FFC  306300FF   ANDI V1, V1, 255
9D013000  8F848054   LW A0, -32684(GP)
9D013004  00831821   ADDU V1, A0, V1
9D013008  90640000   LBU A0, 0(V1)
9D01300C  02841823   SUBU V1, S4, A0
9D013010  3AF70001   XORI S7, S7, 1
9D013014  00771823   SUBU V1, V1, S7
9D013018  307200FF   ANDI S2, V1, 255
9D01301C  00942026   XOR A0, A0, S4
9D013020  7C043004   INS A0, ZERO, 0, 7
9D013024  0254A026   XOR S4, S2, S4
9D013028  00942024   AND A0, A0, S4
9D01302C  308400FF   ANDI A0, A0, 255
9D013030  AFA40014   SW A0, 20(SP)
9D013034  38630100   XORI V1, V1, 256
9D013038  7C770200   EXT S7, V1, 8, 1
9D01303C  8F838058   LW V1, -32680(GP)
9D013040  2463FFFC   ADDIU V1, V1, -4
9D013044  AF838058   SW V1, -32680(GP)
9D013048  8C440054   LW A0, 84(V0)
9D01304C  24840004   ADDIU A0, A0, 4
9D013058  0240A021   ADDU S4, S2, ZERO
9D01305C  0B404D98   J .L45
9D013060  0240A821   ADDU S5, S2, ZERO
9D013094  0240A021   ADDU S4, S2, ZERO
2357:                         OPCODE_END
9D013050  1C600004   BGTZ V1, 0x9D013064
9D013054  AC440054   SW A0, 84(V0)
9D013064  26100002   ADDIU S0, S0, 2
9D013084  90420000   LBU V0, 0(V0)
9D013088  00021080   SLL V0, V0, 2
9D01308C  00561021   ADDU V0, V0, S6
9D013090  8C420000   LW V0, 0(V0)
9D013098  0B402953   J 0x9D00A54C
9D01309C  0240A821   ADDU S5, S2, ZERO
2358:                
2359:                      OPCODE_BEGIN(F6)  /* INC $nn,X */
2360:                         INC(6, ZP_IND_X, ZP_WRITEBYTE, baddr);
9D0130A0  26110001   ADDIU S1, S0, 1
9D0130C0  90630000   LBU V1, 0(V1)
9D0130C4  03C31821   ADDU V1, FP, V1
9D0130C8  306300FF   ANDI V1, V1, 255
9D0130CC  8F848054   LW A0, -32684(GP)
9D0130D0  00831821   ADDU V1, A0, V1
9D0130D4  90720000   LBU S2, 0(V1)
9D0130D8  26520001   ADDIU S2, S2, 1
9D0130DC  325200FF   ANDI S2, S2, 255
9D0130E0  A0720000   SB S2, 0(V1)
9D0130E4  8F838058   LW V1, -32680(GP)
9D0130E8  2463FFFA   ADDIU V1, V1, -6
9D0130EC  AF838058   SW V1, -32680(GP)
9D0130F0  8C440054   LW A0, 84(V0)
9D0130F4  24840006   ADDIU A0, A0, 6
9D013100  0B404D98   J .L45
9D013104  0240A821   ADDU S5, S2, ZERO
2361:                         OPCODE_END
9D0130F8  1C600003   BGTZ V1, 0x9D013108
9D0130FC  AC440054   SW A0, 84(V0)
9D013108  26100002   ADDIU S0, S0, 2
9D013128  90420000   LBU V0, 0(V0)
9D01312C  00021080   SLL V0, V0, 2
9D013130  00561021   ADDU V0, V0, S6
9D013134  8C420000   LW V0, 0(V0)
9D013138  0B402953   J 0x9D00A54C
9D01313C  0240A821   ADDU S5, S2, ZERO
2362:                
2363:                      OPCODE_BEGIN(F7)  /* ISB $nn,X */
2364:                         ISB(6, ZP_IND_X, ZP_WRITEBYTE, baddr);
9D013140  26110001   ADDIU S1, S0, 1
9D013160  90630000   LBU V1, 0(V1)
9D013164  03C31821   ADDU V1, FP, V1
9D013168  306300FF   ANDI V1, V1, 255
9D01316C  8F848054   LW A0, -32684(GP)
9D013170  00832021   ADDU A0, A0, V1
9D013174  90830000   LBU V1, 0(A0)
9D013178  24630001   ADDIU V1, V1, 1
9D01317C  306300FF   ANDI V1, V1, 255
9D013180  A0830000   SB V1, 0(A0)
9D013184  02832023   SUBU A0, S4, V1
9D013188  3AF70001   XORI S7, S7, 1
9D01318C  00972023   SUBU A0, A0, S7
9D013190  309200FF   ANDI S2, A0, 255
9D013194  00741826   XOR V1, V1, S4
9D013198  7C033004   INS V1, ZERO, 0, 7
9D01319C  0254A026   XOR S4, S2, S4
9D0131A0  00741824   AND V1, V1, S4
9D0131A4  306300FF   ANDI V1, V1, 255
9D0131A8  AFA30014   SW V1, 20(SP)
9D0131AC  38840100   XORI A0, A0, 256
9D0131B0  7C970200   EXT S7, A0, 8, 1
9D0131B4  8F838058   LW V1, -32680(GP)
9D0131B8  2463FFFA   ADDIU V1, V1, -6
9D0131BC  AF838058   SW V1, -32680(GP)
9D0131C0  8C440054   LW A0, 84(V0)
9D0131C4  24840006   ADDIU A0, A0, 6
9D0131D0  0240A021   ADDU S4, S2, ZERO
9D0131D4  0B404D98   J .L45
9D0131D8  0240A821   ADDU S5, S2, ZERO
9D01320C  0240A021   ADDU S4, S2, ZERO
2365:                         OPCODE_END
9D0131C8  1C600004   BGTZ V1, 0x9D0131DC
9D0131CC  AC440054   SW A0, 84(V0)
9D0131DC  26100002   ADDIU S0, S0, 2
9D0131FC  90420000   LBU V0, 0(V0)
9D013200  00021080   SLL V0, V0, 2
9D013204  00561021   ADDU V0, V0, S6
9D013208  8C420000   LW V0, 0(V0)
9D013210  0B402953   J 0x9D00A54C
9D013214  0240A821   ADDU S5, S2, ZERO
2366:                
2367:                      OPCODE_BEGIN(F8)  /* SED */
2368:                         SED();
9D013218  8F828058   LW V0, -32680(GP)
9D01321C  2442FFFE   ADDIU V0, V0, -2
9D013220  AF828058   SW V0, -32680(GP)
9D013224  26638FD8   ADDIU V1, S3, -28712
9D013228  8C640054   LW A0, 84(V1)
9D01322C  24840002   ADDIU A0, A0, 2
9D01323C  24020001   ADDIU V0, ZERO, 1
9D013240  0B404D98   J .L45
9D013244  AFA20020   SW V0, 32(SP)
9D013278  24030001   ADDIU V1, ZERO, 1
2369:                         OPCODE_END
9D013230  1C400005   BGTZ V0, .LBB1502
9D013234  AC640054   SW A0, 84(V1)
9D013238  02008821   ADDU S1, S0, ZERO
9D013264  90420000   LBU V0, 0(V0)
9D013268  00021080   SLL V0, V0, 2
9D01326C  00561021   ADDU V0, V0, S6
9D013270  8C420000   LW V0, 0(V0)
9D013274  26100001   ADDIU S0, S0, 1
9D01327C  0B402953   J 0x9D00A54C
9D013280  AFA30020   SW V1, 32(SP)
2370:                
2371:                      OPCODE_BEGIN(F9)  /* SBC $nnnn,Y */
2372:                         SBC(4, ABS_IND_Y_BYTE_READ);
9D013284  0F402863   JAL bank_readword
9D013288  02002021   ADDU A0, S0, ZERO
9D01328C  8FA40010   LW A0, 16(SP)
9D013290  00441021   ADDU V0, V0, A0
9D013294  3044FFFF   ANDI A0, V0, -1
9D013298  308200FF   ANDI V0, A0, 255
9D01329C  8FA50010   LW A1, 16(SP)
9D0132A0  0045102B   SLTU V0, V0, A1
9D0132A4  10400008   BEQ V0, ZERO, 0x9D0132C8
9D0132A8  26110002   ADDIU S1, S0, 2
9D0132AC  8F828058   LW V0, -32680(GP)
9D0132B0  2442FFFF   ADDIU V0, V0, -1
9D0132B4  AF828058   SW V0, -32680(GP)
9D0132B8  26628FD8   ADDIU V0, S3, -28712
9D0132BC  8C430054   LW V1, 84(V0)
9D0132C0  24630001   ADDIU V1, V1, 1
9D0132C4  AC430054   SW V1, 84(V0)
9D0132C8  0F402804   JAL mem_readbyte
9D0132CC  3AF70001   XORI S7, S7, 1
9D0132D0  02821823   SUBU V1, S4, V0
9D0132D4  00771823   SUBU V1, V1, S7
9D0132D8  307200FF   ANDI S2, V1, 255
9D0132DC  00541026   XOR V0, V0, S4
9D0132E0  7C023004   INS V0, ZERO, 0, 7
9D0132E4  0254A026   XOR S4, S2, S4
9D0132E8  00541024   AND V0, V0, S4
9D0132EC  304200FF   ANDI V0, V0, 255
9D0132F0  AFA20014   SW V0, 20(SP)
9D0132F4  38630100   XORI V1, V1, 256
9D0132F8  7C770200   EXT S7, V1, 8, 1
9D0132FC  8F828058   LW V0, -32680(GP)
9D013300  2442FFFC   ADDIU V0, V0, -4
9D013304  AF828058   SW V0, -32680(GP)
9D013308  26638FD8   ADDIU V1, S3, -28712
9D01330C  8C640054   LW A0, 84(V1)
9D013310  24840004   ADDIU A0, A0, 4
9D01331C  0240A021   ADDU S4, S2, ZERO
9D013320  0B404D98   J .L45
9D013324  0240A821   ADDU S5, S2, ZERO
9D013358  0240A021   ADDU S4, S2, ZERO
2373:                         OPCODE_END
9D013314  1C400004   BGTZ V0, 0x9D013328
9D013318  AC640054   SW A0, 84(V1)
9D013328  26100003   ADDIU S0, S0, 3
9D013348  90420000   LBU V0, 0(V0)
9D01334C  00021080   SLL V0, V0, 2
9D013350  00561021   ADDU V0, V0, S6
9D013354  8C420000   LW V0, 0(V0)
9D01335C  0B402953   J 0x9D00A54C
9D013360  0240A821   ADDU S5, S2, ZERO
2374:                
2375:                      OPCODE_BEGIN(FB)  /* ISB $nnnn,Y */
2376:                         ISB(7, ABS_IND_Y, mem_writebyte, addr);
9D013364  0F402863   JAL bank_readword
9D013368  02002021   ADDU A0, S0, ZERO
9D01336C  26110002   ADDIU S1, S0, 2
9D013370  8FA60010   LW A2, 16(SP)
9D013374  00461021   ADDU V0, V0, A2
9D013378  3052FFFF   ANDI S2, V0, -1
9D01337C  0F402804   JAL mem_readbyte
9D013380  02402021   ADDU A0, S2, ZERO
9D013384  24420001   ADDIU V0, V0, 1
9D013388  305500FF   ANDI S5, V0, 255
9D01338C  02402021   ADDU A0, S2, ZERO
9D013390  0F40283A   JAL mem_writebyte
9D013394  02A02821   ADDU A1, S5, ZERO
9D013398  02951023   SUBU V0, S4, S5
9D01339C  3AF70001   XORI S7, S7, 1
9D0133A0  00571023   SUBU V0, V0, S7
9D0133A4  305200FF   ANDI S2, V0, 255
9D0133A8  02B41826   XOR V1, S5, S4
9D0133AC  7C033004   INS V1, ZERO, 0, 7
9D0133B0  0254A026   XOR S4, S2, S4
9D0133B4  00741824   AND V1, V1, S4
9D0133B8  306300FF   ANDI V1, V1, 255
9D0133BC  AFA30014   SW V1, 20(SP)
9D0133C0  38420100   XORI V0, V0, 256
9D0133C4  7C570200   EXT S7, V0, 8, 1
9D0133C8  8F828058   LW V0, -32680(GP)
9D0133CC  2442FFF9   ADDIU V0, V0, -7
9D0133D0  AF828058   SW V0, -32680(GP)
9D0133D4  26638FD8   ADDIU V1, S3, -28712
9D0133D8  8C640054   LW A0, 84(V1)
9D0133DC  24840007   ADDIU A0, A0, 7
9D0133E8  0240A021   ADDU S4, S2, ZERO
9D0133EC  0B404D98   J .L45
9D0133F0  0240A821   ADDU S5, S2, ZERO
9D013424  0240A021   ADDU S4, S2, ZERO
2377:                         OPCODE_END
9D0133E0  1C400004   BGTZ V0, 0x9D0133F4
9D0133E4  AC640054   SW A0, 84(V1)
9D0133F4  26100003   ADDIU S0, S0, 3
9D013414  90420000   LBU V0, 0(V0)
9D013418  00021080   SLL V0, V0, 2
9D01341C  00561021   ADDU V0, V0, S6
9D013420  8C420000   LW V0, 0(V0)
9D013428  0B402953   J 0x9D00A54C
9D01342C  0240A821   ADDU S5, S2, ZERO
2378:                
2379:                      OPCODE_BEGIN(FD)  /* SBC $nnnn,X */
2380:                         SBC(4, ABS_IND_X_BYTE_READ);
9D013430  0F402863   JAL bank_readword
9D013434  02002021   ADDU A0, S0, ZERO
9D013438  005E1021   ADDU V0, V0, FP
9D01343C  3044FFFF   ANDI A0, V0, -1
9D013440  308200FF   ANDI V0, A0, 255
9D013444  005E102B   SLTU V0, V0, FP
9D013448  10400008   BEQ V0, ZERO, 0x9D01346C
9D01344C  26110002   ADDIU S1, S0, 2
9D013450  8F828058   LW V0, -32680(GP)
9D013454  2442FFFF   ADDIU V0, V0, -1
9D013458  AF828058   SW V0, -32680(GP)
9D01345C  26628FD8   ADDIU V0, S3, -28712
9D013460  8C430054   LW V1, 84(V0)
9D013464  24630001   ADDIU V1, V1, 1
9D013468  AC430054   SW V1, 84(V0)
9D01346C  0F402804   JAL mem_readbyte
9D013470  3AF70001   XORI S7, S7, 1
9D013474  02821823   SUBU V1, S4, V0
9D013478  00771823   SUBU V1, V1, S7
9D01347C  307200FF   ANDI S2, V1, 255
9D013480  00541026   XOR V0, V0, S4
9D013484  7C023004   INS V0, ZERO, 0, 7
9D013488  0254A026   XOR S4, S2, S4
9D01348C  00541024   AND V0, V0, S4
9D013490  304200FF   ANDI V0, V0, 255
9D013494  AFA20014   SW V0, 20(SP)
9D013498  38630100   XORI V1, V1, 256
9D01349C  7C770200   EXT S7, V1, 8, 1
9D0134A0  8F828058   LW V0, -32680(GP)
9D0134A4  2442FFFC   ADDIU V0, V0, -4
9D0134A8  AF828058   SW V0, -32680(GP)
9D0134AC  26638FD8   ADDIU V1, S3, -28712
9D0134B0  8C640054   LW A0, 84(V1)
9D0134B4  24840004   ADDIU A0, A0, 4
9D0134C0  0240A021   ADDU S4, S2, ZERO
9D0134C4  0B404D98   J .L45
9D0134C8  0240A821   ADDU S5, S2, ZERO
9D0134FC  0240A021   ADDU S4, S2, ZERO
2381:                         OPCODE_END
9D0134B8  1C400004   BGTZ V0, 0x9D0134CC
9D0134BC  AC640054   SW A0, 84(V1)
9D0134CC  26100003   ADDIU S0, S0, 3
9D0134EC  90420000   LBU V0, 0(V0)
9D0134F0  00021080   SLL V0, V0, 2
9D0134F4  00561021   ADDU V0, V0, S6
9D0134F8  8C420000   LW V0, 0(V0)
9D013500  0B402953   J 0x9D00A54C
9D013504  0240A821   ADDU S5, S2, ZERO
2382:                
2383:                      OPCODE_BEGIN(FE)  /* INC $nnnn,X */
2384:                         INC(7, ABS_IND_X, mem_writebyte, addr);
9D013508  0F402863   JAL bank_readword
9D01350C  02002021   ADDU A0, S0, ZERO
9D013510  26110002   ADDIU S1, S0, 2
9D013514  005E1021   ADDU V0, V0, FP
9D013518  3055FFFF   ANDI S5, V0, -1
9D01351C  0F402804   JAL mem_readbyte
9D013520  02A02021   ADDU A0, S5, ZERO
9D013524  24420001   ADDIU V0, V0, 1
9D013528  305200FF   ANDI S2, V0, 255
9D01352C  02A02021   ADDU A0, S5, ZERO
9D013530  0F40283A   JAL mem_writebyte
9D013534  02402821   ADDU A1, S2, ZERO
9D013538  8F828058   LW V0, -32680(GP)
9D01353C  2442FFF9   ADDIU V0, V0, -7
9D013540  AF828058   SW V0, -32680(GP)
9D013544  26638FD8   ADDIU V1, S3, -28712
9D013548  8C640054   LW A0, 84(V1)
9D01354C  24840007   ADDIU A0, A0, 7
9D013558  0B404D98   J .L45
9D01355C  0240A821   ADDU S5, S2, ZERO
2385:                         OPCODE_END
9D013550  1C400003   BGTZ V0, 0x9D013560
9D013554  AC640054   SW A0, 84(V1)
9D013560  26100003   ADDIU S0, S0, 3
9D013580  90420000   LBU V0, 0(V0)
9D013584  00021080   SLL V0, V0, 2
9D013588  00561021   ADDU V0, V0, S6
9D01358C  8C420000   LW V0, 0(V0)
9D013590  0B402953   J 0x9D00A54C
9D013594  0240A821   ADDU S5, S2, ZERO
2386:                
2387:                      OPCODE_BEGIN(FF)  /* ISB $nnnn,X */
2388:                         ISB(7, ABS_IND_X, mem_writebyte, addr);
9D00A540  3C13A001   LUI S3, -24575
9D013598  0F402863   JAL bank_readword
9D01359C  02002021   ADDU A0, S0, ZERO
9D0135A0  26110002   ADDIU S1, S0, 2
9D0135A4  005E1021   ADDU V0, V0, FP
9D0135A8  3052FFFF   ANDI S2, V0, -1
9D0135AC  0F402804   JAL mem_readbyte
9D0135B0  02402021   ADDU A0, S2, ZERO
9D0135B4  24420001   ADDIU V0, V0, 1
9D0135B8  305500FF   ANDI S5, V0, 255
9D0135BC  02402021   ADDU A0, S2, ZERO
9D0135C0  0F40283A   JAL mem_writebyte
9D0135C4  02A02821   ADDU A1, S5, ZERO
9D0135C8  02951023   SUBU V0, S4, S5
9D0135CC  3AF70001   XORI S7, S7, 1
9D0135D0  00571023   SUBU V0, V0, S7
9D0135D4  305200FF   ANDI S2, V0, 255
9D0135D8  02B41826   XOR V1, S5, S4
9D0135DC  7C033004   INS V1, ZERO, 0, 7
9D0135E0  0254A026   XOR S4, S2, S4
9D0135E4  00741824   AND V1, V1, S4
9D0135E8  306300FF   ANDI V1, V1, 255
9D0135EC  AFA30014   SW V1, 20(SP)
9D0135F0  38420100   XORI V0, V0, 256
9D0135F4  7C570200   EXT S7, V0, 8, 1
9D0135F8  8F828058   LW V0, -32680(GP)
9D0135FC  2442FFF9   ADDIU V0, V0, -7
9D013600  AF828058   SW V0, -32680(GP)
9D013604  26638FD8   ADDIU V1, S3, -28712
9D013608  8C640054   LW A0, 84(V1)
9D01360C  24840007   ADDIU A0, A0, 7
9D013618  0240A021   ADDU S4, S2, ZERO
9D01361C  0B404D98   J .L45
9D013620  0240A821   ADDU S5, S2, ZERO
9D013654  0240A021   ADDU S4, S2, ZERO
2389:                         OPCODE_END
9D00A544  3C169D03   LUI S6, -25341
9D00A548  26D6F7F8   ADDIU S6, S6, -2056
9D00A54C  00400008   JR V0
9D00A550  00000000   NOP
9D013610  1C400004   BGTZ V0, 0x9D013624
9D013614  AC640054   SW A0, 84(V1)
9D013624  26100003   ADDIU S0, S0, 3
9D013644  90420000   LBU V0, 0(V0)
9D013648  00021080   SLL V0, V0, 2
9D01364C  00561021   ADDU V0, V0, S6
9D013650  8C420000   LW V0, 0(V0)
9D013658  0B402953   J 0x9D00A54C
9D01365C  0240A821   ADDU S5, S2, ZERO
2390:                
2391:                #ifdef NES6502_JUMPTABLE
2392:                end_execute:
2393:                
2394:                #else /* !NES6502_JUMPTABLE */
2395:                      }
2396:                   }
2397:                #endif /* !NES6502_JUMPTABLE */
2398:                
2399:                   /* store local copy of regs */
2400:                   STORE_LOCAL_REGS();
9D013660  3C02A001   LUI V0, -24575
9D013664  24428FD8   ADDIU V0, V0, -28712
9D013668  AC510048   SW S1, 72(V0)
9D01366C  A054004C   SB S4, 76(V0)
9D013670  A05E004E   SB FP, 78(V0)
9D013674  8FA70010   LW A3, 16(SP)
9D013678  A047004F   SB A3, 79(V0)
9D01367C  7C123004   INS S2, ZERO, 0, 7
9D013680  7C129420   SEB S2, S2
9D013684  24030040   ADDIU V1, ZERO, 64
9D013688  8FA20014   LW V0, 20(SP)
9D01368C  0002180A   MOVZ V1, ZERO, V0
9D013690  24060010   ADDIU A2, ZERO, 16
9D013694  8FA40028   LW A0, 40(SP)
9D013698  0004300A   MOVZ A2, ZERO, A0
9D01369C  24050008   ADDIU A1, ZERO, 8
9D0136A0  8FA70020   LW A3, 32(SP)
9D0136A4  0007280A   MOVZ A1, ZERO, A3
9D0136A8  24040004   ADDIU A0, ZERO, 4
9D0136AC  8FA2001C   LW V0, 28(SP)
9D0136B0  0002200A   MOVZ A0, ZERO, V0
9D0136B4  24020002   ADDIU V0, ZERO, 2
9D0136B8  0015100B   MOVN V0, ZERO, S5
9D0136BC  0040A821   ADDU S5, V0, ZERO
9D0136C0  3C02A001   LUI V0, -24575
9D0136C4  24428FD8   ADDIU V0, V0, -28712
9D0136C8  36F70020   ORI S7, S7, 32
9D0136CC  0257B825   OR S7, S2, S7
9D0136D0  00771825   OR V1, V1, S7
9D0136D4  00C31825   OR V1, A2, V1
9D0136D8  00A31825   OR V1, A1, V1
9D0136DC  00831825   OR V1, A0, V1
9D0136E0  02A3A825   OR S5, S5, V1
9D0136E4  A055004D   SB S5, 77(V0)
9D0136E8  8FA30018   LW V1, 24(SP)
9D0136EC  A0430050   SB V1, 80(V0)
2401:                
2402:                   /* Return our actual amount of executed cycles */
2403:                   return (cpu.total_cycles - old_cycles);
9D0136F0  8C420054   LW V0, 84(V0)
2404:                }
9D0136F4  8FA40024   LW A0, 36(SP)
9D0136F8  00441023   SUBU V0, V0, A0
9D0136FC  8FBF005C   LW RA, 92(SP)
9D013700  8FBE0058   LW FP, 88(SP)
9D013704  8FB70054   LW S7, 84(SP)
9D013708  8FB60050   LW S6, 80(SP)
9D01370C  8FB5004C   LW S5, 76(SP)
9D013710  8FB40048   LW S4, 72(SP)
9D013714  8FB30044   LW S3, 68(SP)
9D013718  8FB20040   LW S2, 64(SP)
9D01371C  8FB1003C   LW S1, 60(SP)
9D013720  8FB00038   LW S0, 56(SP)
9D013724  03E00008   JR RA
9D013728  27BD0060   ADDIU SP, SP, 96
2405:                
2406:                /* Issue a CPU Reset */
2407:                void nes6502_reset(void)
2408:                {
9D01372C  27BDFFE8   ADDIU SP, SP, -24
9D013730  AFBF0014   SW RA, 20(SP)
9D013734  AFB00010   SW S0, 16(SP)
2409:                   cpu.p_reg = Z_FLAG | R_FLAG | I_FLAG;     /* Reserved bit always 1 */
9D013738  3C10A001   LUI S0, -24575
9D01373C  26108FD8   ADDIU S0, S0, -28712
9D013740  24020026   ADDIU V0, ZERO, 38
9D013744  A202004D   SB V0, 77(S0)
2410:                   cpu.int_pending = 0;                      /* No pending interrupts */
9D013748  A2000052   SB ZERO, 82(S0)
2411:                   cpu.int_latency = 0;                      /* No latent interrupts */
9D01374C  A2000053   SB ZERO, 83(S0)
2412:                   cpu.pc_reg = bank_readword(RESET_VECTOR); /* Fetch reset vector */
9D013750  0F402863   JAL bank_readword
9D013754  3404FFFC   ORI A0, ZERO, -4
9D013758  AE020048   SW V0, 72(S0)
2413:                   cpu.burn_cycles = RESET_CYCLES;
9D01375C  24020006   ADDIU V0, ZERO, 6
9D013760  AE020058   SW V0, 88(S0)
2414:                   cpu.jammed = false;
9D013764  A2000051   SB ZERO, 81(S0)
2415:                }
9D013768  8FBF0014   LW RA, 20(SP)
9D01376C  8FB00010   LW S0, 16(SP)
9D013770  03E00008   JR RA
9D013774  27BD0018   ADDIU SP, SP, 24
2416:                
2417:                /* following macro is used for below 2 functions */
2418:                #define  DECLARE_LOCAL_REGS \
2419:                   uint32 PC; \
2420:                   uint8 A, X, Y, S; \
2421:                   uint8 n_flag, v_flag, b_flag; \
2422:                   uint8 d_flag, i_flag, z_flag, c_flag;
2423:                
2424:                /* Non-maskable interrupt */
2425:                void nes6502_nmi(void)
2426:                {
9D013788  27BDFFC8   ADDIU SP, SP, -56
9D01378C  AFBF0034   SW RA, 52(SP)
9D013790  AFBE0030   SW FP, 48(SP)
9D013794  AFB7002C   SW S7, 44(SP)
9D013798  AFB60028   SW S6, 40(SP)
9D01379C  AFB50024   SW S5, 36(SP)
9D0137A0  AFB40020   SW S4, 32(SP)
9D0137A4  AFB3001C   SW S3, 28(SP)
9D0137A8  AFB20018   SW S2, 24(SP)
9D0137AC  AFB10014   SW S1, 20(SP)
9D0137B0  AFB00010   SW S0, 16(SP)
2427:                   DECLARE_LOCAL_REGS
2428:                
2429:                   if (false == cpu.jammed)
9D013778  3C02A001   LUI V0, -24575
9D01377C  90429029   LBU V0, -28631(V0)
9D013780  14400053   BNE V0, ZERO, 0x9D0138D0
9D013784  3C02A001   LUI V0, -24575
2430:                   {
2431:                      GET_GLOBAL_REGS();
9D0137B4  24428FD8   ADDIU V0, V0, -28712
9D0137B8  8C440048   LW A0, 72(V0)
9D0137BC  905E004C   LBU FP, 76(V0)
9D0137C0  9057004E   LBU S7, 78(V0)
9D0137C4  9056004F   LBU S6, 79(V0)
9D0137C8  9053004D   LBU S3, 77(V0)
9D0137CC  32710040   ANDI S1, S3, 64
9D0137D0  323100FF   ANDI S1, S1, 255
9D0137D4  32700008   ANDI S0, S3, 8
9D0137D8  321000FF   ANDI S0, S0, 255
9D0137DC  3A740002   XORI S4, S3, 2
9D0137E0  7E940040   EXT S4, S4, 1, 1
9D0137E4  90420050   LBU V0, 80(V0)
2432:                      NMI_PROC();
9D0137E8  8F838050   LW V1, -32688(GP)
9D0137EC  00622821   ADDU A1, V1, V0
9D0137F0  00043202   SRL A2, A0, 8
9D0137F4  A0A60000   SB A2, 0(A1)
9D0137F8  2445FFFF   ADDIU A1, V0, -1
9D0137FC  30A500FF   ANDI A1, A1, 255
9D013800  00652821   ADDU A1, V1, A1
9D013804  A0A40000   SB A0, 0(A1)
9D013808  2455FFFD   ADDIU S5, V0, -3
9D01380C  32B500FF   ANDI S5, S5, 255
9D013810  2442FFFE   ADDIU V0, V0, -2
9D013814  304200FF   ANDI V0, V0, 255
9D013818  00621821   ADDU V1, V1, V0
9D01381C  32720080   ANDI S2, S3, 128
9D013820  7C129420   SEB S2, S2
9D013824  32650004   ANDI A1, S3, 4
9D013828  24040002   ADDIU A0, ZERO, 2
9D01382C  0014200B   MOVN A0, ZERO, S4
9D013830  32730001   ANDI S3, S3, 1
9D013834  36620020   ORI V0, S3, 32
9D013838  02421025   OR V0, S2, V0
9D01383C  02221025   OR V0, S1, V0
9D013840  02021025   OR V0, S0, V0
9D013844  00A21025   OR V0, A1, V0
9D013848  00821025   OR V0, A0, V0
9D01384C  A0620000   SB V0, 0(V1)
9D013850  0F402863   JAL bank_readword
9D013854  3404FFFA   ORI A0, ZERO, -6
2433:                      cpu.burn_cycles += INT_CYCLES;
9D013858  3C03A001   LUI V1, -24575
9D01385C  24638FD8   ADDIU V1, V1, -28712
9D013860  8C640058   LW A0, 88(V1)
9D013864  24840007   ADDIU A0, A0, 7
9D013868  AC640058   SW A0, 88(V1)
2434:                      STORE_LOCAL_REGS();
9D01386C  AC620048   SW V0, 72(V1)
9D013870  A07E004C   SB FP, 76(V1)
9D013874  A077004E   SB S7, 78(V1)
9D013878  A076004F   SB S6, 79(V1)
9D01387C  24020002   ADDIU V0, ZERO, 2
9D013880  0014100B   MOVN V0, ZERO, S4
9D013884  0040A021   ADDU S4, V0, ZERO
9D013888  36730024   ORI S3, S3, 36
9D01388C  02539025   OR S2, S2, S3
9D013890  02328825   OR S1, S1, S2
9D013894  02118025   OR S0, S0, S1
9D013898  02908025   OR S0, S4, S0
9D01389C  A070004D   SB S0, 77(V1)
9D0138A0  A0750050   SB S5, 80(V1)
2435:                   }
2436:                }
9D0138A4  8FBF0034   LW RA, 52(SP)
9D0138A8  8FBE0030   LW FP, 48(SP)
9D0138AC  8FB7002C   LW S7, 44(SP)
9D0138B0  8FB60028   LW S6, 40(SP)
9D0138B4  8FB50024   LW S5, 36(SP)
9D0138B8  8FB40020   LW S4, 32(SP)
9D0138BC  8FB3001C   LW S3, 28(SP)
9D0138C0  8FB20018   LW S2, 24(SP)
9D0138C4  8FB10014   LW S1, 20(SP)
9D0138C8  8FB00010   LW S0, 16(SP)
9D0138CC  27BD0038   ADDIU SP, SP, 56
9D0138D0  03E00008   JR RA
9D0138D4  00000000   NOP
2437:                
2438:                /* Interrupt request */
2439:                void nes6502_irq(void)
2440:                {
9D0138E8  27BDFFC8   ADDIU SP, SP, -56
9D0138EC  AFBF0034   SW RA, 52(SP)
9D0138F0  AFBE0030   SW FP, 48(SP)
9D0138F4  AFB7002C   SW S7, 44(SP)
9D0138F8  AFB60028   SW S6, 40(SP)
9D0138FC  AFB50024   SW S5, 36(SP)
9D013900  AFB40020   SW S4, 32(SP)
9D013904  AFB3001C   SW S3, 28(SP)
9D013908  AFB20018   SW S2, 24(SP)
9D01390C  AFB10014   SW S1, 20(SP)
9D013910  AFB00010   SW S0, 16(SP)
2441:                   DECLARE_LOCAL_REGS
2442:                
2443:                   if (false == cpu.jammed)
9D0138D8  3C02A001   LUI V0, -24575
9D0138DC  90429029   LBU V0, -28631(V0)
9D0138E0  14400067   BNE V0, ZERO, 0x9D013A80
9D0138E4  3C04A001   LUI A0, -24575
2444:                   {
2445:                      GET_GLOBAL_REGS();
9D013914  24848FD8   ADDIU A0, A0, -28712
9D013918  8C820048   LW V0, 72(A0)
9D01391C  909E004C   LBU FP, 76(A0)
9D013920  9097004E   LBU S7, 78(A0)
9D013924  9096004F   LBU S6, 79(A0)
9D013928  9083004D   LBU V1, 77(A0)
9D01392C  30750080   ANDI S5, V1, 128
9D013930  30720040   ANDI S2, V1, 64
9D013934  325200FF   ANDI S2, S2, 255
9D013938  30710008   ANDI S1, V1, 8
9D01393C  323100FF   ANDI S1, S1, 255
9D013940  30650004   ANDI A1, V1, 4
9D013944  30A500FF   ANDI A1, A1, 255
9D013948  38740002   XORI S4, V1, 2
9D01394C  7E940040   EXT S4, S4, 1, 1
9D013950  30730001   ANDI S3, V1, 1
9D0139E4  30630010   ANDI V1, V1, 16
9D0139E8  306300FF   ANDI V1, V1, 255
2446:                      if (0 == i_flag)
9D013954  14A00023   BNE A1, ZERO, 0x9D0139E4
9D013958  90900050   LBU S0, 80(A0)
2447:                      {
2448:                         IRQ_PROC();
9D01395C  8F838050   LW V1, -32688(GP)
9D013960  00702021   ADDU A0, V1, S0
9D013964  00022A02   SRL A1, V0, 8
9D013968  A0850000   SB A1, 0(A0)
9D01396C  2604FFFE   ADDIU A0, S0, -2
9D013970  308400FF   ANDI A0, A0, 255
9D013974  2605FFFF   ADDIU A1, S0, -1
9D013978  30A500FF   ANDI A1, A1, 255
9D01397C  00652821   ADDU A1, V1, A1
9D013980  A0A20000   SB V0, 0(A1)
9D013984  2610FFFD   ADDIU S0, S0, -3
9D013988  321000FF   ANDI S0, S0, 255
9D01398C  00641821   ADDU V1, V1, A0
9D013990  2404FF80   ADDIU A0, ZERO, -128
9D013994  02A41024   AND V0, S5, A0
9D013998  7C021420   SEB V0, V0
9D01399C  24040002   ADDIU A0, ZERO, 2
9D0139A0  0014200B   MOVN A0, ZERO, S4
9D0139A4  36650020   ORI A1, S3, 32
9D0139A8  00451025   OR V0, V0, A1
9D0139AC  02421025   OR V0, S2, V0
9D0139B0  02221025   OR V0, S1, V0
9D0139B4  00821025   OR V0, A0, V0
9D0139B8  A0620000   SB V0, 0(V1)
9D0139BC  0F402863   JAL bank_readword
9D0139C0  3404FFFE   ORI A0, ZERO, -2
9D0139D8  24050001   ADDIU A1, ZERO, 1
9D0139DC  0B404E7E   J 0x9D0139F8
9D0139E0  00001821   ADDU V1, ZERO, ZERO
2449:                         cpu.burn_cycles += INT_CYCLES;
9D0139C4  3C03A001   LUI V1, -24575
9D0139C8  24638FD8   ADDIU V1, V1, -28712
9D0139CC  8C640058   LW A0, 88(V1)
9D0139D0  24840007   ADDIU A0, A0, 7
9D0139D4  AC640058   SW A0, 88(V1)
2450:                      }
2451:                      else
2452:                      {
2453:                         cpu.int_pending = 1;
9D0139EC  24060001   ADDIU A2, ZERO, 1
9D0139F0  3C04A001   LUI A0, -24575
9D0139F4  A086902A   SB A2, -28630(A0)
2454:                      }
2455:                      STORE_LOCAL_REGS();
9D0139F8  3C04A001   LUI A0, -24575
9D0139FC  24848FD8   ADDIU A0, A0, -28712
9D013A00  AC820048   SW V0, 72(A0)
9D013A04  A09E004C   SB FP, 76(A0)
9D013A08  A097004E   SB S7, 78(A0)
9D013A0C  A096004F   SB S6, 79(A0)
9D013A10  7C153004   INS S5, ZERO, 0, 7
9D013A14  7C15AC20   SEB S5, S5
9D013A18  24020004   ADDIU V0, ZERO, 4
9D013A1C  0005100A   MOVZ V0, ZERO, A1
9D013A20  00402821   ADDU A1, V0, ZERO
9D013A24  24020002   ADDIU V0, ZERO, 2
9D013A28  0014100B   MOVN V0, ZERO, S4
9D013A2C  0040A021   ADDU S4, V0, ZERO
9D013A30  36730020   ORI S3, S3, 32
9D013A34  02B39825   OR S3, S5, S3
9D013A38  02539025   OR S2, S2, S3
9D013A3C  00729025   OR S2, V1, S2
9D013A40  02328825   OR S1, S1, S2
9D013A44  00B12825   OR A1, A1, S1
9D013A48  0285A025   OR S4, S4, A1
9D013A4C  A094004D   SB S4, 77(A0)
9D013A50  A0900050   SB S0, 80(A0)
2456:                   }
2457:                }
9D013A54  8FBF0034   LW RA, 52(SP)
9D013A58  8FBE0030   LW FP, 48(SP)
9D013A5C  8FB7002C   LW S7, 44(SP)
9D013A60  8FB60028   LW S6, 40(SP)
9D013A64  8FB50024   LW S5, 36(SP)
9D013A68  8FB40020   LW S4, 32(SP)
9D013A6C  8FB3001C   LW S3, 28(SP)
9D013A70  8FB20018   LW S2, 24(SP)
9D013A74  8FB10014   LW S1, 20(SP)
9D013A78  8FB00010   LW S0, 16(SP)
9D013A7C  27BD0038   ADDIU SP, SP, 56
9D013A80  03E00008   JR RA
9D013A84  00000000   NOP
2458:                
2459:                /* Set dead cycle period */
2460:                void nes6502_burn(int cycles)
2461:                {
2462:                   cpu.burn_cycles += cycles;
9D013A88  3C02A001   LUI V0, -24575
9D013A8C  24428FD8   ADDIU V0, V0, -28712
9D013A90  8C430058   LW V1, 88(V0)
9D013A94  00642021   ADDU A0, V1, A0
9D013A98  03E00008   JR RA
9D013A9C  AC440058   SW A0, 88(V0)
2463:                }
2464:                
2465:                /* Release our timeslice */
2466:                void nes6502_release(void)
2467:                {
2468:                   remaining_cycles = 0;
9D013AA0  03E00008   JR RA
2469:                }
2470:                
2471:                /*
2472:                ** $Log: nes6502.c,v $
2473:                ** Revision 1.2  2001/04/27 14:37:11  neil
2474:                ** wheeee
2475:                **
2476:                ** Revision 1.1  2001/04/27 12:54:39  neil
2477:                ** blah
2478:                **
2479:                ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
2480:                ** initial
2481:                **
2482:                ** Revision 1.34  2000/11/27 19:33:07  matt
2483:                ** concise interrupts
2484:                **
2485:                ** Revision 1.33  2000/11/26 15:39:54  matt
2486:                ** timing fixes
2487:                **
2488:                ** Revision 1.32  2000/11/20 13:22:51  matt
2489:                ** added note about word fetches across page boundaries
2490:                **
2491:                ** Revision 1.31  2000/11/13 00:57:39  matt
2492:                ** trying to add 1-instruction interrupt latency... and failing.
2493:                **
2494:                ** Revision 1.30  2000/10/10 13:58:14  matt
2495:                ** stroustrup squeezing his way in the door
2496:                **
2497:                ** Revision 1.29  2000/10/10 13:05:05  matt
2498:                ** Mr. Clean makes a guest appearance
2499:                **
2500:                ** Revision 1.28  2000/10/08 17:55:41  matt
2501:                ** check burn cycles before ints
2502:                **
2503:                ** Revision 1.27  2000/09/15 03:42:32  matt
2504:                ** nes6502_release to release current timeslice
2505:                **
2506:                ** Revision 1.26  2000/09/15 03:16:17  matt
2507:                ** optimized C flag handling, and ADC/SBC/ROL/ROR macros
2508:                **
2509:                ** Revision 1.25  2000/09/14 02:12:03  matt
2510:                ** disassembling now works with goto table, and removed memcpy from context get/set
2511:                **
2512:                ** Revision 1.24  2000/09/11 03:55:57  matt
2513:                ** cosmetics
2514:                **
2515:                ** Revision 1.23  2000/09/11 01:45:45  matt
2516:                ** flag optimizations.  this thing is fast!
2517:                **
2518:                ** Revision 1.22  2000/09/08 13:29:25  matt
2519:                ** added switch()-less execution for gcc
2520:                **
2521:                ** Revision 1.21  2000/09/08 11:54:48  matt
2522:                ** optimize
2523:                **
2524:                ** Revision 1.20  2000/09/07 21:58:18  matt
2525:                ** api change for nes6502_burn, optimized core
2526:                **
2527:                ** Revision 1.19  2000/09/07 13:39:01  matt
2528:                ** resolved a few conflicts
2529:                **
2530:                ** Revision 1.18  2000/09/07 01:34:55  matt
2531:                ** nes6502_init deprecated, moved flag regs to separate vars
2532:                **
2533:                ** Revision 1.17  2000/08/31 13:26:35  matt
2534:                ** added DISASM flag, to sync with asm version
2535:                **
2536:                ** Revision 1.16  2000/08/29 05:38:00  matt
2537:                ** removed faulty failure note
2538:                **
2539:                ** Revision 1.15  2000/08/28 12:53:44  matt
2540:                ** fixes for disassembler
2541:                **
2542:                ** Revision 1.14  2000/08/28 04:32:28  matt
2543:                ** naming convention changes
2544:                **
2545:                ** Revision 1.13  2000/08/28 01:46:15  matt
2546:                ** moved some of them defines around, cleaned up jamming code
2547:                **
2548:                ** Revision 1.12  2000/08/16 04:56:37  matt
2549:                ** accurate CPU jamming, added dead page emulation
2550:                **
2551:                ** Revision 1.11  2000/07/30 04:32:00  matt
2552:                ** now emulates the NES frame IRQ
2553:                **
2554:                ** Revision 1.10  2000/07/17 01:52:28  matt
2555:                ** made sure last line of all source files is a newline
2556:                **
2557:                ** Revision 1.9  2000/07/11 04:27:18  matt
2558:                ** new disassembler calling convention
2559:                **
2560:                ** Revision 1.8  2000/07/10 05:26:38  matt
2561:                ** cosmetic
2562:                **
2563:                ** Revision 1.7  2000/07/06 17:10:51  matt
2564:                ** minor (er, spelling) error fixed
2565:                **
2566:                ** Revision 1.6  2000/07/04 04:50:07  matt
2567:                ** minor change to includes
2568:                **
2569:                ** Revision 1.5  2000/07/03 02:18:16  matt
2570:                ** added a few notes about potential failure cases
2571:                **
2572:                ** Revision 1.4  2000/06/09 15:12:25  matt
2573:                ** initial revision
2574:                **
2575:                */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/config.c  ----------------------------------
1:                   /* Nofrendo Configuration Braindead Sample Implementation
2:                   **
3:                   ** $Id: config.c,v 1.2 2001/04/27 14:37:11 neil Exp $
4:                   */
5:                   
6:                   #include <ctype.h>
7:                   #include <string.h>
8:                   #include <stdlib.h>
9:                   #include <stdio.h>
10:                  
11:                  #include <noftypes.h>
12:                  #include <log.h>
13:                  #include <osd.h>
14:                  #include <nofconfig.h>
15:                  #include <version.h>
16:                  
17:                  typedef struct myvar_s
18:                  {
19:                     struct myvar_s *less, *greater;
20:                     char *group, *key, *value;
21:                  } myvar_t;
22:                  
23:                  static myvar_t *myVars = NULL;
24:                  static bool mySaveNeeded = false;
25:                  
26:                  
27:                  static void my_destroy(myvar_t **var)
28:                  {
9D029ED0  27BDFFE8   ADDIU SP, SP, -24
9D029ED4  AFBF0014   SW RA, 20(SP)
9D029ED8  AFB00010   SW S0, 16(SP)
9D029EDC  00808021   ADDU S0, A0, ZERO
29:                     ASSERT(*var);
30:                  
31:                     if ((*var)->group) 
9D029EE0  8C840000   LW A0, 0(A0)
9D029EE4  8C820008   LW V0, 8(A0)
9D029EE8  50400004   BEQL V0, ZERO, 0x9D029EFC
9D029EEC  8E040000   LW A0, 0(S0)
32:                        free((*var)->group);
9D029EF0  0F40DB97   JAL _my_free
9D029EF4  24840008   ADDIU A0, A0, 8
33:                     if ((*var)->key)
9D029EF8  8E040000   LW A0, 0(S0)
9D029EFC  8C82000C   LW V0, 12(A0)
9D029F00  50400004   BEQL V0, ZERO, 0x9D029F14
9D029F04  8E040000   LW A0, 0(S0)
34:                        free((*var)->key);
9D029F08  0F40DB97   JAL _my_free
9D029F0C  2484000C   ADDIU A0, A0, 12
35:                     if ((*var)->value)
9D029F10  8E040000   LW A0, 0(S0)
9D029F14  8C820010   LW V0, 16(A0)
9D029F18  10400003   BEQ V0, ZERO, .LVL4
9D029F1C  00000000   NOP
36:                        free((*var)->value);
9D029F20  0F40DB97   JAL _my_free
9D029F24  24840010   ADDIU A0, A0, 16
37:                     free(*var);
9D029F28  0F40DB97   JAL _my_free
9D029F2C  02002021   ADDU A0, S0, ZERO
38:                  }
9D029F30  8FBF0014   LW RA, 20(SP)
9D029F34  8FB00010   LW S0, 16(SP)
9D029F38  03E00008   JR RA
9D029F3C  27BD0018   ADDIU SP, SP, 24
39:                  
40:                  static myvar_t *my_create(const char *group, const char *key, const char *value)
41:                  {
9D029F40  27BDFFD0   ADDIU SP, SP, -48
9D029F44  AFBF002C   SW RA, 44(SP)
9D029F48  AFB30028   SW S3, 40(SP)
9D029F4C  AFB20024   SW S2, 36(SP)
9D029F50  AFB10020   SW S1, 32(SP)
9D029F54  AFB0001C   SW S0, 28(SP)
9D029F58  00808821   ADDU S1, A0, ZERO
9D029F5C  00A09021   ADDU S2, A1, ZERO
9D029F60  00C09821   ADDU S3, A2, ZERO
42:                     myvar_t *var;
43:                  
44:                     var = malloc(sizeof(*var));
9D029F64  0F40DB84   JAL _my_malloc
9D029F68  24040014   ADDIU A0, ZERO, 20
45:                     if (NULL == var)
9D029F6C  1040002D   BEQ V0, ZERO, 0x9D02A024
9D029F70  AFA20010   SW V0, 16(SP)
46:                     {
47:                        return 0;
9D02A024  00001021   ADDU V0, ZERO, ZERO
48:                     }
49:                  
50:                     var->less = var->greater = NULL;
9D029F74  AC400004   SW ZERO, 4(V0)
9D029F78  AC400000   SW ZERO, 0(V0)
51:                     var->group = var->key = var->value = NULL;
9D029F7C  8FB00010   LW S0, 16(SP)
9D029F80  AE000010   SW ZERO, 16(S0)
9D029F84  AE00000C   SW ZERO, 12(S0)
9D029F88  AE000008   SW ZERO, 8(S0)
52:                  
53:                     if ((var->group = malloc(strlen(group) + 1))
9D029F8C  0F40D9CB   JAL strlen
9D029F90  02202021   ADDU A0, S1, ZERO
9D029F94  0F40DB84   JAL _my_malloc
9D029F98  24440001   ADDIU A0, V0, 1
9D029F9C  1040001D   BEQ V0, ZERO, 0x9D02A014
9D029FA0  AE020008   SW V0, 8(S0)
54:                         && (var->key = malloc(strlen(key) + 1))
9D029FA4  8FB00010   LW S0, 16(SP)
9D029FA8  0F40D9CB   JAL strlen
9D029FAC  02402021   ADDU A0, S2, ZERO
9D029FB0  0F40DB84   JAL _my_malloc
9D029FB4  24440001   ADDIU A0, V0, 1
9D029FB8  10400016   BEQ V0, ZERO, 0x9D02A014
9D029FBC  AE02000C   SW V0, 12(S0)
55:                         && (var->value = malloc(strlen(value) + 1)))
9D029FC0  8FB00010   LW S0, 16(SP)
9D029FC4  0F40D9CB   JAL strlen
9D029FC8  02602021   ADDU A0, S3, ZERO
9D029FCC  0F40DB84   JAL _my_malloc
9D029FD0  24440001   ADDIU A0, V0, 1
9D029FD4  1040000F   BEQ V0, ZERO, 0x9D02A014
9D029FD8  AE020010   SW V0, 16(S0)
56:                     {
57:                        strcpy(var->group, group);
9D029FDC  8FA20010   LW V0, 16(SP)
9D029FE0  8C440008   LW A0, 8(V0)
9D029FE4  0F40D714   JAL .LFE23, strcpy
9D029FE8  02202821   ADDU A1, S1, ZERO
58:                        strcpy(var->key, key);
9D029FEC  8FA20010   LW V0, 16(SP)
9D029FF0  8C44000C   LW A0, 12(V0)
9D029FF4  0F40D714   JAL .LFE23, strcpy
9D029FF8  02402821   ADDU A1, S2, ZERO
59:                        strcpy(var->value, value);
9D029FFC  8FA20010   LW V0, 16(SP)
9D02A000  8C440010   LW A0, 16(V0)
9D02A004  0F40D714   JAL .LFE23, strcpy
9D02A008  02602821   ADDU A1, S3, ZERO
60:                        return var;
9D02A00C  0B40A80A   J 0x9D02A028
9D02A010  8FA20010   LW V0, 16(SP)
61:                     }
62:                  
63:                     my_destroy(&var);
9D02A014  0F40A7B4   JAL .LFB8, my_destroy, .Ltext0
9D02A018  27A40010   ADDIU A0, SP, 16
64:                     return NULL;
9D02A01C  0B40A80A   J 0x9D02A028
9D02A020  00001021   ADDU V0, ZERO, ZERO
65:                  }
9D02A028  8FBF002C   LW RA, 44(SP)
9D02A02C  8FB30028   LW S3, 40(SP)
9D02A030  8FB20024   LW S2, 36(SP)
9D02A034  8FB10020   LW S1, 32(SP)
9D02A038  8FB0001C   LW S0, 28(SP)
9D02A03C  03E00008   JR RA
9D02A040  27BD0030   ADDIU SP, SP, 48
66:                  
67:                  static myvar_t *my_lookup(const char *group, const char *key) 
68:                  {
9D02A164  27BDFFE0   ADDIU SP, SP, -32
9D02A168  AFBF001C   SW RA, 28(SP)
9D02A16C  AFB20018   SW S2, 24(SP)
9D02A170  AFB10014   SW S1, 20(SP)
9D02A174  AFB00010   SW S0, 16(SP)
9D02A178  00808821   ADDU S1, A0, ZERO
69:                     int cmp;
70:                     myvar_t *current = myVars;
9D02A17C  8F908168   LW S0, -32408(GP)
71:                  
72:                     while (current
9D02A180  16000008   BNE S0, ZERO, 0x9D02A1A4
9D02A184  00A09021   ADDU S2, A1, ZERO
9D02A19C  1200000B   BEQ S0, ZERO, 0x9D02A1CC
9D02A1A0  02001021   ADDU V0, S0, ZERO
73:                            && ((cmp = stricmp(group, current->group))
9D02A1A4  02202021   ADDU A0, S1, ZERO
9D02A1A8  0F40EE2B   JAL .LFE5, strcasecmp
9D02A1AC  8E050008   LW A1, 8(S0)
9D02A1B0  1440FFF7   BNE V0, ZERO, 0x9D02A190
9D02A1B4  02402021   ADDU A0, S2, ZERO
74:                                || (cmp = stricmp(key, current->key))))
9D02A1B8  0F40EE2B   JAL .LFE5, strcasecmp
9D02A1BC  8E05000C   LW A1, 12(S0)
9D02A1C0  1440FFF3   BNE V0, ZERO, 0x9D02A190
9D02A1C4  00000000   NOP
75:                     {
76:                        if (cmp < 0)
9D02A190  04430002   BGEZL V0, 0x9D02A19C
9D02A194  8E100004   LW S0, 4(S0)
9D02A198  8E100000   LW S0, 0(S0)
77:                           current = current->less;
78:                        else
79:                           current = current->greater;
80:                     }
81:                  
82:                     return current;
83:                  }
9D02A188  0B40A873   J 0x9D02A1CC
9D02A18C  02001021   ADDU V0, S0, ZERO
9D02A1C8  02001021   ADDU V0, S0, ZERO
9D02A1CC  8FBF001C   LW RA, 28(SP)
9D02A1D0  8FB20018   LW S2, 24(SP)
9D02A1D4  8FB10014   LW S1, 20(SP)
9D02A1D8  8FB00010   LW S0, 16(SP)
9D02A1DC  03E00008   JR RA
9D02A1E0  27BD0020   ADDIU SP, SP, 32
84:                  
85:                  static void my_insert(myvar_t *var)
86:                  {
9D02A07C  27BDFFE0   ADDIU SP, SP, -32
9D02A080  AFBF001C   SW RA, 28(SP)
9D02A084  AFB20018   SW S2, 24(SP)
9D02A088  AFB10014   SW S1, 20(SP)
9D02A08C  AFB00010   SW S0, 16(SP)
9D02A090  00809021   ADDU S2, A0, ZERO
87:                     int cmp;
88:                     myvar_t **current = &myVars;
89:                  
90:                     while (*current
9D02A094  0B40A82A   J 0x9D02A0A8
9D02A098  27918168   ADDIU S1, GP, -32408
9D02A0A8  8E300000   LW S0, 0(S1)
9D02A0AC  52000014   BEQL S0, ZERO, 0x9D02A100
9D02A0B0  AE400004   SW ZERO, 4(S2)
91:                            && ((cmp = stricmp(var->group, (*current)->group))
9D02A0B4  8E440008   LW A0, 8(S2)
9D02A0B8  0F40EE2B   JAL .LFE5, strcasecmp
9D02A0BC  8E050008   LW A1, 8(S0)
9D02A0C0  1440FFF6   BNE V0, ZERO, 0x9D02A09C
9D02A0C4  26030004   ADDIU V1, S0, 4
92:                                || (cmp = stricmp(var->key, (*current)->key))))
9D02A0C8  8E44000C   LW A0, 12(S2)
9D02A0CC  0F40EE2B   JAL .LFE5, strcasecmp
9D02A0D0  8E05000C   LW A1, 12(S0)
9D02A0D4  1440FFF1   BNE V0, ZERO, 0x9D02A09C
9D02A0D8  26030004   ADDIU V1, S0, 4
93:                     {
94:                        current = (cmp < 0) ? &(*current)->less : &(*current)->greater;
9D02A09C  28420000   SLTI V0, V0, 0
9D02A0A0  00608821   ADDU S1, V1, ZERO
9D02A0A4  0202880B   MOVN S1, S0, V0
95:                     }
96:                  
97:                     if (*current)
98:                     {
99:                        var->less = (*current)->less;
9D02A0DC  8E020000   LW V0, 0(S0)
9D02A0E0  AE420000   SW V0, 0(S2)
100:                       var->greater = (*current)->greater;
9D02A0E4  8E220000   LW V0, 0(S1)
9D02A0E8  8C420004   LW V0, 4(V0)
9D02A0EC  AE420004   SW V0, 4(S2)
101:                       my_destroy(current);
9D02A0F0  0F40A7B4   JAL .LFB8, my_destroy, .Ltext0
9D02A0F4  02202021   ADDU A0, S1, ZERO
9D02A0F8  0B40A842   J 0x9D02A108
9D02A0FC  AE320000   SW S2, 0(S1)
102:                    }
103:                    else
104:                    {
105:                       var->less = var->greater = NULL;
9D02A100  AE400000   SW ZERO, 0(S2)
106:                    }
107:                 
108:                    *current = var;
9D02A104  AE320000   SW S2, 0(S1)
109:                 }
9D02A108  8FBF001C   LW RA, 28(SP)
9D02A10C  8FB20018   LW S2, 24(SP)
9D02A110  8FB10014   LW S1, 20(SP)
9D02A114  8FB00010   LW S0, 16(SP)
9D02A118  03E00008   JR RA
9D02A11C  27BD0020   ADDIU SP, SP, 32
110:                 
111:                 static void my_save(FILE *stream, myvar_t *var, char **group)
112:                 {
9D02A328  27BDFFD8   ADDIU SP, SP, -40
9D02A32C  AFBF0024   SW RA, 36(SP)
9D02A330  AFB30020   SW S3, 32(SP)
9D02A334  AFB2001C   SW S2, 28(SP)
9D02A338  AFB10018   SW S1, 24(SP)
9D02A33C  AFB00014   SW S0, 20(SP)
113:                    if (NULL == var)
9D02A340  10A0001B   BEQ A1, ZERO, .LVL85
9D02A344  00A08021   ADDU S0, A1, ZERO
9D02A348  00809021   ADDU S2, A0, ZERO
9D02A34C  00C08821   ADDU S1, A2, ZERO
114:                       return;
115:                 
116:                    my_save(stream, var->less, group);
9D02A350  0F40A8CA   JAL .LFB12, my_save, .LFE20
9D02A354  8CA50000   LW A1, 0(A1)
117:                    
118:                    if (stricmp(*group, var->group))
9D02A358  8E130008   LW S3, 8(S0)
9D02A35C  8E240000   LW A0, 0(S1)
9D02A360  0F40EE2B   JAL .LFE5, strcasecmp
9D02A364  02602821   ADDU A1, S3, ZERO
9D02A368  10400008   BEQ V0, ZERO, 0x9D02A38C
9D02A36C  02402021   ADDU A0, S2, ZERO
119:                    {
120:                       fprintf(stream, "\n[%s]\n", var->group);
9D02A370  3C059D03   LUI A1, -25341
9D02A374  24A57B4C   ADDIU A1, A1, 31564
9D02A378  0F40EF41   JAL _fprintf_s, _fprintf_0
9D02A37C  02603021   ADDU A2, S3, ZERO
121:                       *group = var->group;
9D02A380  8E020008   LW V0, 8(S0)
9D02A384  AE220000   SW V0, 0(S1)
122:                    }
123:                    
124:                    fprintf(stream, "%s=%s\n", var->key, var->value);
9D02A388  02402021   ADDU A0, S2, ZERO
9D02A38C  3C059D03   LUI A1, -25341
9D02A390  24A57B54   ADDIU A1, A1, 31572
9D02A394  8E06000C   LW A2, 12(S0)
9D02A398  0F40EF41   JAL _fprintf_s, _fprintf_0
9D02A39C  8E070010   LW A3, 16(S0)
125:                    
126:                    my_save(stream, var->greater, group);
9D02A3A0  02402021   ADDU A0, S2, ZERO
9D02A3A4  8E050004   LW A1, 4(S0)
9D02A3A8  0F40A8CA   JAL .LFB12, my_save, .LFE20
9D02A3AC  02203021   ADDU A2, S1, ZERO
127:                 }
9D02A3B0  8FBF0024   LW RA, 36(SP)
9D02A3B4  8FB30020   LW S3, 32(SP)
9D02A3B8  8FB2001C   LW S2, 28(SP)
9D02A3BC  8FB10018   LW S1, 24(SP)
9D02A3C0  8FB00014   LW S0, 20(SP)
9D02A3C4  03E00008   JR RA
9D02A3C8  27BD0028   ADDIU SP, SP, 40
128:                 
129:                 static void my_cleanup(myvar_t *var)
130:                 {
9D02A044  27BDFFE8   ADDIU SP, SP, -24
9D02A048  AFBF0014   SW RA, 20(SP)
131:                    if (NULL == var)
9D02A04C  10800008   BEQ A0, ZERO, .LVL27
9D02A050  AFA40018   SW A0, 24(SP)
132:                       return;
133:                 
134:                    my_cleanup(var->less);
9D02A054  0F40A811   JAL .LFB13, my_cleanup, .LFE9
9D02A058  8C840000   LW A0, 0(A0)
135:                    my_cleanup(var->greater);
9D02A05C  8FA20018   LW V0, 24(SP)
9D02A060  0F40A811   JAL .LFB13, my_cleanup, .LFE9
9D02A064  8C440004   LW A0, 4(V0)
136:                    my_destroy(&var);
9D02A068  0F40A7B4   JAL .LFB8, my_destroy, .Ltext0
9D02A06C  27A40018   ADDIU A0, SP, 24
137:                 }
9D02A070  8FBF0014   LW RA, 20(SP)
9D02A074  03E00008   JR RA
9D02A078  27BD0018   ADDIU SP, SP, 24
138:                 
139:                 static char *my_getline(FILE *stream)
140:                 {
9D02A480  27BDFBD8   ADDIU SP, SP, -1064
9D02A484  AFBF0424   SW RA, 1060(SP)
9D02A488  AFB20420   SW S2, 1056(SP)
9D02A48C  AFB1041C   SW S1, 1052(SP)
9D02A490  AFB00418   SW S0, 1048(SP)
9D02A494  00808821   ADDU S1, A0, ZERO
141:                    char buf[1024];
142:                    char *dynamic = NULL;
9D02A498  AFA00410   SW ZERO, 1040(SP)
143:                 
144:                    do
145:                    {
146:                       if (NULL == (fgets(buf, sizeof(buf), stream)))
9D02A4A0  27A40010   ADDIU A0, SP, 16
9D02A4A4  24050400   ADDIU A1, ZERO, 1024
9D02A4A8  0F40E402   JAL fgets
9D02A4AC  02203021   ADDU A2, S1, ZERO
9D02A4B0  14400008   BNE V0, ZERO, 0x9D02A4D4
9D02A4B4  00408021   ADDU S0, V0, ZERO
147:                       {
148:                          if (dynamic)
9D02A4B8  8FA20410   LW V0, 1040(SP)
9D02A4BC  50400039   BEQL V0, ZERO, 0x9D02A5A4
9D02A4C0  02001021   ADDU V0, S0, ZERO
149:                             free(dynamic);
9D02A4C4  0F40DB97   JAL _my_free
9D02A4C8  27A40410   ADDIU A0, SP, 1040
150:                          return 0;
151:                       }
152:                 
153:                       if (NULL == dynamic)
9D02A4D4  8FA40410   LW A0, 1040(SP)
9D02A4D8  1480000C   BNE A0, ZERO, 0x9D02A50C
9D02A4DC  00000000   NOP
154:                       {
155:                          dynamic = malloc(strlen(buf) + 1);
9D02A4E0  0F40D9CB   JAL strlen
9D02A4E4  27A40010   ADDIU A0, SP, 16
9D02A4E8  0F40DB84   JAL _my_malloc
9D02A4EC  24440001   ADDIU A0, V0, 1
156:                          if (NULL == dynamic)
9D02A4F0  10400028   BEQ V0, ZERO, 0x9D02A594
9D02A4F4  AFA20410   SW V0, 1040(SP)
157:                          {
158:                             return 0;
9D02A594  0B40A968   J 0x9D02A5A0
9D02A598  00008021   ADDU S0, ZERO, ZERO
159:                          }
160:                          strcpy(dynamic, buf);
9D02A4F8  00402021   ADDU A0, V0, ZERO
9D02A4FC  0F40D714   JAL .LFE23, strcpy
9D02A500  27A50010   ADDIU A1, SP, 16
9D02A504  0B40A957   J 0x9D02A55C
9D02A508  96220010   LHU V0, 16(S1)
161:                       }
162:                       else
163:                       {
164:                          /* a mini-version of realloc that works with our memory manager */
165:                          char *temp = NULL;
166:                          temp = malloc(strlen(dynamic) + strlen(buf) + 1);
9D02A50C  0F40D9CB   JAL strlen
9D02A510  00000000   NOP
9D02A514  00408021   ADDU S0, V0, ZERO
9D02A518  0F40D9CB   JAL strlen
9D02A51C  27A40010   ADDIU A0, SP, 16
9D02A520  02021021   ADDU V0, S0, V0
9D02A524  0F40DB84   JAL _my_malloc
9D02A528  24440001   ADDIU A0, V0, 1
167:                          if (NULL == temp)
9D02A52C  1040001B   BEQ V0, ZERO, 0x9D02A59C
9D02A530  00408021   ADDU S0, V0, ZERO
168:                             return 0;
9D02A59C  00008021   ADDU S0, ZERO, ZERO
169:                 
170:                          strcpy(temp, dynamic);
9D02A534  00402021   ADDU A0, V0, ZERO
9D02A538  0F40D714   JAL .LFE23, strcpy
9D02A53C  8FA50410   LW A1, 1040(SP)
171:                          free(dynamic);
9D02A540  0F40DB97   JAL _my_free
9D02A544  27A40410   ADDIU A0, SP, 1040
172:                          dynamic = temp;
9D02A548  AFB00410   SW S0, 1040(SP)
173:                 
174:                          strcat(dynamic, buf);
9D02A54C  02002021   ADDU A0, S0, ZERO
9D02A550  0F40E86E   JAL strcat
9D02A554  27A50010   ADDIU A1, SP, 16
175:                       }
176:                 
177:                       if (feof(stream))
9D02A558  96220010   LHU V0, 16(S1)
9D02A55C  30420020   ANDI V0, V0, 32
9D02A560  3042FFFF   ANDI V0, V0, -1
9D02A564  10400003   BEQ V0, ZERO, 0x9D02A574
9D02A568  8FB00410   LW S0, 1040(SP)
178:                       {
179:                          return dynamic;
9D02A56C  0B40A969   J 0x9D02A5A4
9D02A570  02001021   ADDU V0, S0, ZERO
180:                       }
181:                    } 
182:                    while (dynamic[strlen(dynamic) - 1] != '\n');
9D02A49C  2412000A   ADDIU S2, ZERO, 10
9D02A574  0F40D9CB   JAL strlen
9D02A578  02002021   ADDU A0, S0, ZERO
9D02A57C  02021021   ADDU V0, S0, V0
9D02A580  8042FFFF   LB V0, -1(V0)
9D02A584  5452FFC7   BNEL V0, S2, 0x9D02A4A4
9D02A588  27A40010   ADDIU A0, SP, 16
9D02A58C  0B40A969   J 0x9D02A5A4
9D02A590  02001021   ADDU V0, S0, ZERO
183:                 
184:                    return dynamic;
185:                 }
9D02A4CC  0B40A969   J 0x9D02A5A4
9D02A4D0  02001021   ADDU V0, S0, ZERO
9D02A5A0  02001021   ADDU V0, S0, ZERO
9D02A5A4  8FBF0424   LW RA, 1060(SP)
9D02A5A8  8FB20420   LW S2, 1056(SP)
9D02A5AC  8FB1041C   LW S1, 1052(SP)
9D02A5B0  8FB00418   LW S0, 1048(SP)
9D02A5B4  03E00008   JR RA
9D02A5B8  27BD0428   ADDIU SP, SP, 1064
186:                 
187:                 /* load_config loads from the disk the saved configuration. */
188:                 static int load_config(char *filename)
189:                 {
190:                    FILE *config_file;
191:                 
192:                    if ((config_file = fopen(filename, "r")))
9D02A5E4  3C02A001   LUI V0, -24575
9D02A5E8  8C44B850   LW A0, -18352(V0)
9D02A5EC  3C059D03   LUI A1, -25341
9D02A5F0  0F40DA7E   JAL .Letext0, .LFE3, fopen
9D02A5F4  24A57BB4   ADDIU A1, A1, 31668
9D02A5F8  104000A9   BEQ V0, ZERO, 0x9D02A8A0
9D02A5FC  0040A821   ADDU S5, V0, ZERO
193:                    {
194:                       char *line;
195:                       char *group = NULL, *key = NULL, *value = NULL;
9D02A600  AFA00010   SW ZERO, 16(SP)
196:                 
197:                       mySaveNeeded = true;
9D02A604  24020001   ADDIU V0, ZERO, 1
9D02A608  AF828164   SW V0, -32412(GP)
198:                       while ((line = my_getline(config_file)))
9D02A868  0F40A920   JAL .LFB14, my_getline, .LFE18
9D02A86C  02A02021   ADDU A0, S5, ZERO
9D02A870  00408021   ADDU S0, V0, ZERO
9D02A874  1440FF6D   BNE V0, ZERO, 0x9D02A62C
9D02A878  AFA20014   SW V0, 20(SP)
199:                       {
200:                          char *s;
201:                          
202:                          if ('\n' == line[strlen(line) - 1])
9D02A62C  0F40D9CB   JAL strlen
9D02A630  02002021   ADDU A0, S0, ZERO
9D02A634  2442FFFF   ADDIU V0, V0, -1
9D02A638  02028021   ADDU S0, S0, V0
9D02A63C  82030000   LB V1, 0(S0)
9D02A640  2402000A   ADDIU V0, ZERO, 10
9D02A644  50620001   BEQL V1, V0, 0x9D02A64C
9D02A648  A2000000   SB ZERO, 0(S0)
203:                             line[strlen(line) - 1] = '\0';
204:                          
205:                          s = line;
9D02A64C  8FB10014   LW S1, 20(SP)
9D02A650  24130023   ADDIU S3, ZERO, 35
206:                 
207:                          do 
208:                          {
209:                             /* eat up whitespace */
210:                             while (isspace(*s))
9D02A60C  3C129D04   LUI S2, -25340
9D02A610  26528181   ADDIU S2, S2, -32383
9D02A654  82220000   LB V0, 0(S1)
9D02A658  00521821   ADDU V1, V0, S2
9D02A65C  80630000   LB V1, 0(V1)
9D02A660  30630088   ANDI V1, V1, 136
9D02A664  5460FFFB   BNEL V1, ZERO, 0x9D02A654
9D02A668  26310001   ADDIU S1, S1, 1
211:                                s++;
212:                 
213:                             switch (*s) 
9D02A66C  1053000D   BEQ V0, S3, 0x9D02A6A4
9D02A670  28430024   SLTI V1, V0, 36
9D02A674  10600005   BEQ V1, ZERO, 0x9D02A68C
9D02A678  2403003B   ADDIU V1, ZERO, 59
9D02A67C  14400028   BNE V0, ZERO, 0x9D02A720
9D02A680  02202021   ADDU A0, S1, ZERO
9D02A68C  10430005   BEQ V0, V1, 0x9D02A6A4
9D02A690  2403005B   ADDIU V1, ZERO, 91
9D02A694  10430005   BEQ V0, V1, 0x9D02A6AC
9D02A698  8FA20010   LW V0, 16(SP)
214:                             {
215:                             case ';':
216:                             case '#':
217:                             case '\0':
218:                                *s = '\0';
9D02A684  0B40AA18   J 0x9D02A860
9D02A688  A2200000   SB ZERO, 0(S1)
9D02A6A4  0B40AA18   J 0x9D02A860
9D02A6A8  A2200000   SB ZERO, 0(S1)
219:                                break;
220:                 
221:                             case '[':
222:                                if (group)
9D02A6AC  10400004   BEQ V0, ZERO, 0x9D02A6C0
9D02A6B0  26240001   ADDIU A0, S1, 1
223:                                   free(group);
9D02A6B4  0F40DB97   JAL _my_free
9D02A6B8  27A40010   ADDIU A0, SP, 16
224:                 
225:                                group = ++s;
9D02A6BC  26240001   ADDIU A0, S1, 1
9D02A6C0  AFA40010   SW A0, 16(SP)
226:                 
227:                                s = strchr(s, ']');
9D02A6C4  0F40E2E0   JAL strchr
9D02A6C8  2405005D   ADDIU A1, ZERO, 93
228:                                if (NULL == s)
9D02A6CC  54400008   BNEL V0, ZERO, 0x9D02A6F0
9D02A6D0  24510001   ADDIU S1, V0, 1
229:                                {
230:                                   log_printf("load_config: missing ']' after group\n");
9D02A620  3C169D03   LUI S6, -25341
9D02A624  0B40AA1A   J .LVL147
9D02A628  26D67BB8   ADDIU S6, S6, 31672
9D02A6D4  0F40EEE8   JAL log_printf
9D02A6D8  02C02021   ADDU A0, S6, ZERO
231:                                   s = group + strlen(group);
9D02A6DC  8FB10010   LW S1, 16(SP)
9D02A6E0  0F40D9CB   JAL strlen
9D02A6E4  02202021   ADDU A0, S1, ZERO
9D02A6E8  0B40A9BD   J 0x9D02A6F4
9D02A6EC  02228821   ADDU S1, S1, V0
232:                                }
233:                                else
234:                                {
235:                                   *s++ = '\0';
9D02A6F0  A0400000   SB ZERO, 0(V0)
236:                                }
237:                 
238:                                if ((value = malloc(strlen(group) + 1)))
9D02A6F4  0F40D9CB   JAL strlen
9D02A6F8  8FA40010   LW A0, 16(SP)
9D02A6FC  0F40DB84   JAL _my_malloc
9D02A700  24440001   ADDIU A0, V0, 1
9D02A704  10400004   BEQ V0, ZERO, .LVL130
9D02A708  00408021   ADDU S0, V0, ZERO
239:                                {
240:                                   strcpy(value, group);
9D02A70C  00402021   ADDU A0, V0, ZERO
9D02A710  0F40D714   JAL .LFE23, strcpy
9D02A714  8FA50010   LW A1, 16(SP)
241:                                }
242:                                group = value;
9D02A718  0B40AA15   J 0x9D02A854
9D02A71C  AFB00010   SW S0, 16(SP)
243:                                break;
244:                 
245:                             default:
246:                                key = s;
247:                                s = strchr(s, '=');
9D02A69C  0B40A9C8   J 0x9D02A720
9D02A6A0  02202021   ADDU A0, S1, ZERO
9D02A720  0F40E2E0   JAL strchr
9D02A724  2405003D   ADDIU A1, ZERO, 61
248:                                if (NULL == s)
9D02A728  1440000B   BNE V0, ZERO, 0x9D02A758
9D02A72C  24500001   ADDIU S0, V0, 1
249:                                {
250:                                   log_printf("load_config: missing '=' after key\n");
9D02A618  3C179D03   LUI S7, -25341
9D02A61C  26F77BE0   ADDIU S7, S7, 31712
9D02A730  0F40EEE8   JAL log_printf
9D02A734  02E02021   ADDU A0, S7, ZERO
251:                                   s = key + strlen(key);
9D02A738  0F40D9CB   JAL strlen
9D02A73C  02202021   ADDU A0, S1, ZERO
9D02A740  02228021   ADDU S0, S1, V0
252:                                }
253:                                else
254:                                {
255:                                   *s++ = '\0';
9D02A758  0B40A9D1   J 0x9D02A744
9D02A75C  A0400000   SB ZERO, 0(V0)
256:                                }
257:                 
258:                                while (strlen(key) && isspace(key[strlen(key) - 1])) 
9D02A744  82220000   LB V0, 0(S1)
9D02A748  50400013   BEQL V0, ZERO, 0x9D02A798
9D02A74C  82020000   LB V0, 0(S0)
9D02A750  0B40A9DB   J 0x9D02A76C
9D02A754  00000000   NOP
9D02A760  82220000   LB V0, 0(S1)
9D02A764  5040000C   BEQL V0, ZERO, 0x9D02A798
9D02A768  82020000   LB V0, 0(S0)
9D02A76C  0F40D9CB   JAL strlen
9D02A770  02202021   ADDU A0, S1, ZERO
9D02A774  2442FFFF   ADDIU V0, V0, -1
9D02A778  02221021   ADDU V0, S1, V0
9D02A77C  80430000   LB V1, 0(V0)
9D02A780  00721821   ADDU V1, V1, S2
9D02A784  80630000   LB V1, 0(V1)
9D02A788  30630088   ANDI V1, V1, 136
9D02A78C  5460FFF4   BNEL V1, ZERO, 0x9D02A760
9D02A790  A0400000   SB ZERO, 0(V0)
259:                                   key[strlen(key) - 1] = '\0';
260:                 
261:                                while (isspace(*s)) 
9D02A794  82020000   LB V0, 0(S0)
9D02A798  00521021   ADDU V0, V0, S2
9D02A79C  80420000   LB V0, 0(V0)
9D02A7A0  30420088   ANDI V0, V0, 136
9D02A7A4  50400009   BEQL V0, ZERO, 0x9D02A7CC
9D02A7A8  82020000   LB V0, 0(S0)
9D02A7B0  82020000   LB V0, 0(S0)
9D02A7B4  00521021   ADDU V0, V0, S2
9D02A7B8  80420000   LB V0, 0(V0)
9D02A7BC  30420088   ANDI V0, V0, 136
9D02A7C0  5440FFFB   BNEL V0, ZERO, 0x9D02A7B0
9D02A7C4  26100001   ADDIU S0, S0, 1
262:                                   s++;
9D02A7AC  26100001   ADDIU S0, S0, 1
263:                                
264:                                while (strlen(s) && isspace(s[strlen(s) - 1])) 
9D02A7C8  82020000   LB V0, 0(S0)
9D02A7CC  10400011   BEQ V0, ZERO, 0x9D02A814
9D02A7D0  8FA20010   LW V0, 16(SP)
9D02A7D4  0B40A9FA   J 0x9D02A7E8
9D02A7D8  00000000   NOP
9D02A7DC  82020000   LB V0, 0(S0)
9D02A7E0  1040000C   BEQ V0, ZERO, 0x9D02A814
9D02A7E4  8FA20010   LW V0, 16(SP)
9D02A7E8  0F40D9CB   JAL strlen
9D02A7EC  02002021   ADDU A0, S0, ZERO
9D02A7F0  2442FFFF   ADDIU V0, V0, -1
9D02A7F4  02021821   ADDU V1, S0, V0
9D02A7F8  80620000   LB V0, 0(V1)
9D02A7FC  00521021   ADDU V0, V0, S2
9D02A800  80420000   LB V0, 0(V0)
9D02A804  30420088   ANDI V0, V0, 136
9D02A808  5440FFF4   BNEL V0, ZERO, 0x9D02A7DC
9D02A80C  A0600000   SB ZERO, 0(V1)
265:                                   s[strlen(s) - 1]='\0';
266:                 
267:                                {
268:                                   myvar_t *var = my_create(group ? group : "", key, s);
9D02A614  3C149D03   LUI S4, -25341
9D02A810  8FA20010   LW V0, 16(SP)
9D02A814  26847B5C   ADDIU A0, S4, 31580
9D02A818  0042200B   MOVN A0, V0, V0
9D02A81C  02202821   ADDU A1, S1, ZERO
9D02A820  0F40A7D0   JAL .LFB9, my_create, .LFE8
9D02A824  02003021   ADDU A2, S0, ZERO
269:                                   if (NULL == var)
9D02A828  14400005   BNE V0, ZERO, 0x9D02A840
9D02A82C  3C049D03   LUI A0, -25341
270:                                   {
271:                                      log_printf("load_config: my_create failed\n");
9D02A830  0F40EEE8   JAL log_printf
9D02A834  24847C04   ADDIU A0, A0, 31748
272:                                      return -1;
9D02A838  0B40AA29   J 0x9D02A8A4
9D02A83C  2402FFFF   ADDIU V0, ZERO, -1
273:                                   }
274:                 
275:                                   my_insert(var);
9D02A840  0F40A81F   JAL .LFB11, my_insert, .LFE13
9D02A844  00402021   ADDU A0, V0, ZERO
276:                                }
277:                                s += strlen(s);
9D02A848  0F40D9CB   JAL strlen
9D02A84C  02002021   ADDU A0, S0, ZERO
9D02A850  02028821   ADDU S1, S0, V0
278:                             }
279:                          } while (*s);
9D02A854  82220000   LB V0, 0(S1)
9D02A858  1440FF80   BNE V0, ZERO, 0x9D02A65C
9D02A85C  00521821   ADDU V1, V0, S2
280:                 
281:                          free(line);
9D02A860  0F40DB97   JAL _my_free
9D02A864  27A40014   ADDIU A0, SP, 20
282:                       }
283:                 
284:                       if (group) 
9D02A87C  8FA20010   LW V0, 16(SP)
9D02A880  10400003   BEQ V0, ZERO, .LVL149
9D02A884  00000000   NOP
285:                          free(group);
9D02A888  0F40DB97   JAL _my_free
9D02A88C  27A40010   ADDIU A0, SP, 16
286:                 
287:                       fclose(config_file);
9D02A890  0F40E9A2   JAL .Letext0, .LFE1, fclose
9D02A894  02A02021   ADDU A0, S5, ZERO
288:                    }
289:                 
290:                    return 0;
9D02A898  0B40AA29   J 0x9D02A8A4
9D02A89C  00001021   ADDU V0, ZERO, ZERO
9D02A8A0  00001021   ADDU V0, ZERO, ZERO
291:                 }
292:                 
293:                 /* save_config saves the current configuration to disk.*/
294:                 static int save_config(char *filename)
295:                 {
296:                    FILE *config_file;
297:                    char *group = "";
9D02A3EC  3C029D03   LUI V0, -25341
298:                 
299:                    config_file = fopen(filename, "w");
9D02A3F8  3C059D03   LUI A1, -25341
300:                    if (NULL == config_file)
9D02A404  14400006   BNE V0, ZERO, 0x9D02A420
301:                    {
302:                       log_printf("save_config failed\n");
9D02A40C  3C049D03   LUI A0, -25341
303:                       return -1;
304:                    }
305:                 
306:                    fprintf(config_file, ";; " APP_STRING " " APP_VERSION "\n");
9D02A420  3C049D03   LUI A0, -25341
307:                    fprintf(config_file, ";; NOTE: comments are not preserved.\n");
9D02A438  3C049D03   LUI A0, -25341
308:                    my_save(config_file, myVars, &group);
9D02A450  02002021   ADDU A0, S0, ZERO
309:                    fclose(config_file);
9D02A460  0F40E9A2   JAL .Letext0, .LFE1, fclose
9D02A464  02002021   ADDU A0, S0, ZERO
310:                 
311:                    return 0;
312:                 }
313:                 
314:                 static bool open_config(void)
315:                 {
9D02A5BC  27BDFFC0   ADDIU SP, SP, -64
9D02A5C0  AFBF003C   SW RA, 60(SP)
9D02A5C4  AFB70038   SW S7, 56(SP)
9D02A5C8  AFB60034   SW S6, 52(SP)
9D02A5CC  AFB50030   SW S5, 48(SP)
9D02A5D0  AFB4002C   SW S4, 44(SP)
9D02A5D4  AFB30028   SW S3, 40(SP)
9D02A5D8  AFB20024   SW S2, 36(SP)
9D02A5DC  AFB10020   SW S1, 32(SP)
9D02A5E0  AFB0001C   SW S0, 28(SP)
316:                    return load_config(config.filename);
317:                 }
9D02A8A4  8FBF003C   LW RA, 60(SP)
9D02A8A8  8FB70038   LW S7, 56(SP)
9D02A8AC  8FB60034   LW S6, 52(SP)
9D02A8B0  8FB50030   LW S5, 48(SP)
9D02A8B4  8FB4002C   LW S4, 44(SP)
9D02A8B8  8FB30028   LW S3, 40(SP)
9D02A8BC  8FB20024   LW S2, 36(SP)
9D02A8C0  8FB10020   LW S1, 32(SP)
9D02A8C4  8FB0001C   LW S0, 28(SP)
9D02A8C8  03E00008   JR RA
9D02A8CC  27BD0040   ADDIU SP, SP, 64
318:                 
319:                 static void close_config(void)
320:                 {
9D02A3CC  27BDFFE0   ADDIU SP, SP, -32
9D02A3D0  AFBF001C   SW RA, 28(SP)
9D02A3D4  AFB00018   SW S0, 24(SP)
321:                    if (true == mySaveNeeded) 
9D02A3D8  24020001   ADDIU V0, ZERO, 1
9D02A3DC  8F838164   LW V1, -32412(GP)
9D02A3E0  14620021   BNE V1, V0, .LVL94, .LBE5, .LBE4
9D02A3E4  3C02A001   LUI V0, -24575
322:                    {
323:                       save_config(config.filename);
9D02A3E8  8C44B850   LW A0, -18352(V0)
324:                    }
325:                 
326:                    my_cleanup(myVars);
9D02A468  0F40A811   JAL .LFB13, my_cleanup, .LFE9
9D02A46C  8F848168   LW A0, -32408(GP)
327:                 }
9D02A470  8FBF001C   LW RA, 28(SP)
9D02A474  8FB00018   LW S0, 24(SP)
9D02A478  03E00008   JR RA
9D02A47C  27BD0020   ADDIU SP, SP, 32
328:                 
329:                 static void write_int(const char *group, const char *key, int value)
330:                 {
9D02A248  27BDFFC8   ADDIU SP, SP, -56
9D02A24C  AFBF0034   SW RA, 52(SP)
9D02A250  AFB10030   SW S1, 48(SP)
9D02A254  AFB0002C   SW S0, 44(SP)
9D02A258  00808821   ADDU S1, A0, ZERO
9D02A25C  00A08021   ADDU S0, A1, ZERO
331:                    char buf[24];
332:                    static myvar_t *var;
333:                 
334:                    sprintf(buf, "%d", value);
9D02A260  27A40010   ADDIU A0, SP, 16
9D02A264  3C059D03   LUI A1, -25341
9D02A268  0F40EBB1   JAL _sprintf_cdnopuxX, _sprintf_cdnopsuxX
9D02A26C  24A57B34   ADDIU A1, A1, 31540
335:                    buf[sizeof(buf) - 1] = '\0';
9D02A270  A3A00027   SB ZERO, 39(SP)
336:                 
337:                    var = my_create(group, key, buf);
9D02A274  02202021   ADDU A0, S1, ZERO
9D02A278  02002821   ADDU A1, S0, ZERO
9D02A27C  0F40A7D0   JAL .LFB9, my_create, .LFE8
9D02A280  27A60010   ADDIU A2, SP, 16
338:                    if (NULL == var)
9D02A284  14400005   BNE V0, ZERO, 0x9D02A29C
9D02A288  3C049D03   LUI A0, -25341
339:                    {
340:                       log_printf("write_int failed\n");
9D02A28C  0F40EEE8   JAL log_printf
9D02A290  24847B38   ADDIU A0, A0, 31544
341:                       return;
342:                    }
343:                 
344:                    my_insert(var);
9D02A29C  0F40A81F   JAL .LFB11, my_insert, .LFE13
9D02A2A0  00402021   ADDU A0, V0, ZERO
345:                    mySaveNeeded = true;
9D02A2A4  24020001   ADDIU V0, ZERO, 1
9D02A2A8  AF828164   SW V0, -32412(GP)
346:                 }
9D02A294  0B40A8AC   J 0x9D02A2B0
9D02A298  8FBF0034   LW RA, 52(SP)
9D02A2AC  8FBF0034   LW RA, 52(SP)
9D02A2B0  8FB10030   LW S1, 48(SP)
9D02A2B4  8FB0002C   LW S0, 44(SP)
9D02A2B8  03E00008   JR RA
9D02A2BC  27BD0038   ADDIU SP, SP, 56
347:                 
348:                 /* read_int loads an integer from the configuration into "value"
349:                 **
350:                 ** If the specified "key" does not exist, the "def"ault is returned
351:                 */
352:                 static int read_int(const char *group, const char *key, int def)
353:                 {
9D02A2C0  27BDFFE0   ADDIU SP, SP, -32
9D02A2C4  AFBF001C   SW RA, 28(SP)
9D02A2C8  AFB20018   SW S2, 24(SP)
9D02A2CC  AFB10014   SW S1, 20(SP)
9D02A2D0  AFB00010   SW S0, 16(SP)
9D02A2D4  00809021   ADDU S2, A0, ZERO
9D02A2D8  00A08821   ADDU S1, A1, ZERO
354:                    static myvar_t *var;
355:                 
356:                    var = my_lookup(group, key);
9D02A2DC  0F40A859   JAL .LFB10, my_lookup, .LFE21
9D02A2E0  00C08021   ADDU S0, A2, ZERO
357:                    if (NULL == var)
9D02A2E4  54400007   BNEL V0, ZERO, 0x9D02A304
9D02A2E8  8C440010   LW A0, 16(V0)
358:                    {
359:                       write_int(group, key, def);
9D02A2EC  02402021   ADDU A0, S2, ZERO
9D02A2F0  02202821   ADDU A1, S1, ZERO
9D02A2F4  0F40A892   JAL .LFB19, write_int, .LFE22
9D02A2F8  02003021   ADDU A2, S0, ZERO
360:                       
361:                       return def;
9D02A2FC  0B40A8C4   J .LVL75
9D02A300  02001021   ADDU V0, S0, ZERO
362:                    }
363:                 
364:                    return strtoul(var->value, 0, 0);
9D02A304  00002821   ADDU A1, ZERO, ZERO
9D02A308  0F40CE1A   JAL strtoul
9D02A30C  00003021   ADDU A2, ZERO, ZERO
365:                 }
9D02A310  8FBF001C   LW RA, 28(SP)
9D02A314  8FB20018   LW S2, 24(SP)
9D02A318  8FB10014   LW S1, 20(SP)
9D02A31C  8FB00010   LW S0, 16(SP)
9D02A320  03E00008   JR RA
9D02A324  27BD0020   ADDIU SP, SP, 32
366:                 
367:                 static void write_string(const char *group, const char *key, const char *value)
368:                 {
9D02A120  27BDFFE8   ADDIU SP, SP, -24
9D02A124  AFBF0014   SW RA, 20(SP)
369:                    static myvar_t *var;
370:                 
371:                    var = my_create(group, key, value);
9D02A128  0F40A7D0   JAL .LFB9, my_create, .LFE8
9D02A12C  00000000   NOP
372:                    if (NULL == var)
9D02A130  14400005   BNE V0, ZERO, 0x9D02A148
9D02A134  3C049D03   LUI A0, -25341
373:                    {
374:                       log_printf("write_string failed\n");
9D02A138  0F40EEE8   JAL log_printf
9D02A13C  24847B1C   ADDIU A0, A0, 31516
375:                       return;
9D02A140  0B40A857   J 0x9D02A15C
9D02A144  8FBF0014   LW RA, 20(SP)
376:                    }
377:                 
378:                    my_insert(var);
9D02A148  0F40A81F   JAL .LFB11, my_insert, .LFE13
9D02A14C  00402021   ADDU A0, V0, ZERO
379:                    mySaveNeeded = true;
9D02A150  24020001   ADDIU V0, ZERO, 1
9D02A154  AF828164   SW V0, -32412(GP)
380:                 }
9D02A158  8FBF0014   LW RA, 20(SP)
9D02A15C  03E00008   JR RA
9D02A160  27BD0018   ADDIU SP, SP, 24
381:                 
382:                 /* read_string copies a string from the configuration into "value"
383:                 **
384:                 ** If the specified "key" does not exist, the "def"ault is returned
385:                 */
386:                 static const char *read_string(const char *group, const char *key, const char *def)
387:                 {
9D02A1E4  27BDFFE0   ADDIU SP, SP, -32
9D02A1E8  AFBF001C   SW RA, 28(SP)
9D02A1EC  AFB20018   SW S2, 24(SP)
9D02A1F0  AFB10014   SW S1, 20(SP)
9D02A1F4  AFB00010   SW S0, 16(SP)
9D02A1F8  00809021   ADDU S2, A0, ZERO
9D02A1FC  00A08821   ADDU S1, A1, ZERO
388:                    static myvar_t *var;
389:                 
390:                    var = my_lookup(group, key);
9D02A200  0F40A859   JAL .LFB10, my_lookup, .LFE21
9D02A204  00C08021   ADDU S0, A2, ZERO
391:                    if (NULL == var)
9D02A208  54400009   BNEL V0, ZERO, 0x9D02A230
9D02A20C  8C420010   LW V0, 16(V0)
392:                    {
393:                       if (def != NULL)
9D02A210  12000006   BEQ S0, ZERO, 0x9D02A22C
9D02A214  02402021   ADDU A0, S2, ZERO
394:                          write_string(group, key, def);
9D02A218  02202821   ADDU A1, S1, ZERO
9D02A21C  0F40A848   JAL .LFB21, write_string, .LFE11
9D02A220  02003021   ADDU A2, S0, ZERO
395:                 
396:                       return def;
9D02A224  0B40A88C   J 0x9D02A230
9D02A228  02001021   ADDU V0, S0, ZERO
9D02A22C  02001021   ADDU V0, S0, ZERO
397:                    }
398:                 
399:                    return var->value;
400:                 }
9D02A230  8FBF001C   LW RA, 28(SP)
9D02A234  8FB20018   LW S2, 24(SP)
9D02A238  8FB10014   LW S1, 20(SP)
9D02A23C  8FB00010   LW S0, 16(SP)
9D02A240  03E00008   JR RA
9D02A244  27BD0020   ADDIU SP, SP, 32
401:                 
402:                 /* interface */
403:                 config_t config =
404:                 {
405:                    open_config,
406:                    close_config,
407:                    read_int,
408:                    read_string,
409:                    write_int,
410:                    write_string,
411:                    CONFIG_FILE
412:                 };
413:                 
414:                 /*
415:                 ** $Log: config.c,v $
416:                 ** Revision 1.2  2001/04/27 14:37:11  neil
417:                 ** wheeee
418:                 **
419:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
420:                 ** initial
421:                 **
422:                 ** Revision 1.14  2000/11/05 06:23:10  matt
423:                 ** realloc was incompatible with memguard
424:                 **
425:                 ** Revision 1.13  2000/10/10 13:58:13  matt
426:                 ** stroustrup squeezing his way in the door
427:                 **
428:                 ** Revision 1.12  2000/09/20 01:13:28  matt
429:                 ** damn tabs
430:                 **
431:                 ** Revision 1.11  2000/08/04 12:41:04  neil
432:                 ** current not a bug
433:                 **
434:                 ** Revision 1.10  2000/07/31 04:28:46  matt
435:                 ** one million cleanups
436:                 **
437:                 ** Revision 1.9  2000/07/24 04:30:42  matt
438:                 ** slight cleanup
439:                 **
440:                 ** Revision 1.8  2000/07/23 15:16:08  matt
441:                 ** changed strcasecmp to stricmp
442:                 **
443:                 ** Revision 1.7  2000/07/19 15:58:55  neil
444:                 ** config file now configurable (ha)
445:                 **
446:                 ** Revision 1.6  2000/07/18 03:28:32  matt
447:                 ** help me!  I'm a complete mess!
448:                 **
449:                 ** Revision 1.5  2000/07/12 11:03:08  neil
450:                 ** Always write a config, even if no defaults are changed
451:                 **
452:                 ** Revision 1.4  2000/07/11 15:09:30  matt
453:                 ** suppressed all warnings
454:                 **
455:                 ** Revision 1.3  2000/07/11 14:59:27  matt
456:                 ** minor cosmetics.. =)
457:                 **
458:                 ** Revision 1.2  2000/07/11 13:35:38  bsittler
459:                 ** Changed the config API, implemented config file "nofrendo.cfg". The
460:                 ** GGI drivers use the group [GGI]. Visual= and Mode= keys are understood.
461:                 **
462:                 ** Revision 1.1  2000/07/11 09:21:10  bsittler
463:                 ** This is a skeletal configuration system.
464:                 **
465:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/nofrendo/bitmap.c  ----------------------------------
1:                   /*
2:                   ** Nofrendo (c) 1998-2000 Matthew Conte (matt@conte.com)
3:                   **
4:                   **
5:                   ** This program is free software; you can redistribute it and/or
6:                   ** modify it under the terms of version 2 of the GNU Library General 
7:                   ** Public License as published by the Free Software Foundation.
8:                   **
9:                   ** This program is distributed in the hope that it will be useful, 
10:                  ** but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                  ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
12:                  ** Library General Public License for more details.  To obtain a 
13:                  ** copy of the GNU Library General Public License, write to the Free 
14:                  ** Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
15:                  **
16:                  ** Any permitted reproduction of these routines, in whole or in part,
17:                  ** must bear this legend.
18:                  **
19:                  **
20:                  ** bitmap.c
21:                  **
22:                  ** Bitmap object manipulation routines
23:                  ** $Id: bitmap.c,v 1.2 2001/04/27 14:37:11 neil Exp $
24:                  */
25:                  
26:                  #include <stdio.h>
27:                  #include <string.h>
28:                  #include <noftypes.h>
29:                  #include <bitmap.h>
30:                  
31:                  void bmp_clear(const bitmap_t *bitmap, uint8 color)
32:                  {
9D034E50  27BDFFE8   ADDIU SP, SP, -24
9D034E54  AFBF0014   SW RA, 20(SP)
33:                     memset(bitmap->data, color, bitmap->pitch * bitmap->height);
9D034E58  8C860008   LW A2, 8(A0)
9D034E5C  8C820004   LW V0, 4(A0)
9D034E60  8C840010   LW A0, 16(A0)
9D034E64  0F40E7C9   JAL .Letext0, .LFE0, memset
9D034E68  70C23002   MUL A2, A2, V0
34:                  }
9D034E6C  8FBF0014   LW RA, 20(SP)
9D034E70  03E00008   JR RA
9D034E74  27BD0018   ADDIU SP, SP, 24
35:                  
36:                  static bitmap_t *_make_bitmap(uint8 *data_addr, bool hw, int width, 
37:                                                int height, int pitch, int overdraw)
38:                  {
9D034D60  27BDFFD8   ADDIU SP, SP, -40
9D034D64  AFBF0024   SW RA, 36(SP)
9D034D68  AFB40020   SW S4, 32(SP)
9D034D6C  AFB3001C   SW S3, 28(SP)
9D034D70  AFB20018   SW S2, 24(SP)
9D034D74  AFB10014   SW S1, 20(SP)
9D034D78  AFB00010   SW S0, 16(SP)
9D034D7C  00808821   ADDU S1, A0, ZERO
39:                     bitmap_t *bitmap;
40:                     int i;
41:                  
42:                     /* quick safety check */
43:                     if (NULL == data_addr)
9D034D80  10800028   BEQ A0, ZERO, 0x9D034E24
9D034D84  8FB2003C   LW S2, 60(SP)
9D034D88  00A09821   ADDU S3, A1, ZERO
9D034D8C  00C0A021   ADDU S4, A2, ZERO
9D034D90  00E08021   ADDU S0, A3, ZERO
44:                        return NULL;
9D034E24  0B40D38C   J 0x9D034E30
9D034E28  00001021   ADDU V0, ZERO, ZERO
45:                  
46:                     /* Make sure to add in space for line pointers */
47:                     bitmap = malloc(sizeof(bitmap_t) + (sizeof(uint8 *) * height));
9D034D94  24E40005   ADDIU A0, A3, 5
9D034D98  0F40DB84   JAL _my_malloc
9D034D9C  00042080   SLL A0, A0, 2
48:                     if (NULL == bitmap)
9D034DA0  10400022   BEQ V0, ZERO, 0x9D034E2C
9D034DA4  00122040   SLL A0, S2, 1
49:                        return NULL;
9D034E2C  00001021   ADDU V0, ZERO, ZERO
50:                  
51:                     bitmap->hardware = hw;
9D034DA8  AC53000C   SW S3, 12(V0)
52:                     bitmap->height = height;
9D034DAC  AC500004   SW S0, 4(V0)
53:                     bitmap->width = width;
9D034DB0  AC540000   SW S4, 0(V0)
54:                     bitmap->data = data_addr;
9D034DB4  AC510010   SW S1, 16(V0)
55:                     bitmap->pitch = pitch + (overdraw * 2);
9D034DB8  8FA30038   LW V1, 56(SP)
9D034DBC  00831821   ADDU V1, A0, V1
56:                  
57:                     /* Set up line pointers */
58:                     /* we want to make some 32-bit aligned adjustment
59:                     ** if we haven't been given a hardware bitmap
60:                     */
61:                     if (false == bitmap->hardware)
9D034DC0  16600009   BNE S3, ZERO, 0x9D034DE8
9D034DC4  AC430008   SW V1, 8(V0)
62:                     {
63:                        bitmap->pitch = (bitmap->pitch + 3) & ~3;
9D034DC8  24630003   ADDIU V1, V1, 3
9D034DCC  7C030804   INS V1, ZERO, 0, 2
9D034DD0  AC430008   SW V1, 8(V0)
64:                        bitmap->line[0] = (uint8 *) (((uint32) bitmap->data + overdraw + 3) & ~3);
9D034DD4  26520003   ADDIU S2, S2, 3
9D034DD8  02328821   ADDU S1, S1, S2
9D034DDC  7C110804   INS S1, ZERO, 0, 2
9D034DE0  0B40D37C   J 0x9D034DF0
9D034DE4  AC510014   SW S1, 20(V0)
65:                     }
66:                     else
67:                     { 
68:                        bitmap->line[0] = bitmap->data + overdraw;
9D034DE8  02328821   ADDU S1, S1, S2
9D034DEC  AC510014   SW S1, 20(V0)
69:                     }
70:                  
71:                     for (i = 1; i < height; i++)
9D034DF0  2A030002   SLTI V1, S0, 2
9D034DF4  1460000E   BNE V1, ZERO, 0x9D034E30
9D034DF8  00401821   ADDU V1, V0, ZERO
9D034E10  24840001   ADDIU A0, A0, 1
9D034E14  1490FFFB   BNE A0, S0, 0x9D034E04
9D034E18  24630004   ADDIU V1, V1, 4
9D034E1C  0B40D38D   J 0x9D034E34
9D034E20  8FBF0024   LW RA, 36(SP)
72:                        bitmap->line[i] = bitmap->line[i - 1] + bitmap->pitch;
9D034DFC  8C460008   LW A2, 8(V0)
9D034E00  24040001   ADDIU A0, ZERO, 1
9D034E04  8C650014   LW A1, 20(V1)
9D034E08  00A62821   ADDU A1, A1, A2
9D034E0C  AC650018   SW A1, 24(V1)
73:                  
74:                     return bitmap;
75:                  }
9D034E30  8FBF0024   LW RA, 36(SP)
9D034E34  8FB40020   LW S4, 32(SP)
9D034E38  8FB3001C   LW S3, 28(SP)
9D034E3C  8FB20018   LW S2, 24(SP)
9D034E40  8FB10014   LW S1, 20(SP)
9D034E44  8FB00010   LW S0, 16(SP)
9D034E48  03E00008   JR RA
9D034E4C  27BD0028   ADDIU SP, SP, 40
76:                  
77:                  /* Allocate and initialize a bitmap structure */
78:                  bitmap_t *bmp_create(int width, int height, int overdraw)
79:                  {
9D034E78  27BDFFD8   ADDIU SP, SP, -40
9D034E7C  AFBF0024   SW RA, 36(SP)
9D034E80  AFB20020   SW S2, 32(SP)
9D034E84  AFB1001C   SW S1, 28(SP)
9D034E88  AFB00018   SW S0, 24(SP)
9D034E8C  00808021   ADDU S0, A0, ZERO
9D034E90  00A08821   ADDU S1, A1, ZERO
9D034E94  00C09021   ADDU S2, A2, ZERO
80:                     uint8 *addr;
81:                     int pitch;
82:                  
83:                     pitch = width + (overdraw * 2); /* left and right */
9D034E98  00062040   SLL A0, A2, 1
9D034E9C  00902021   ADDU A0, A0, S0
84:                     addr = malloc((pitch * height) + 3); /* add max 32-bit aligned adjustment */
9D034EA0  70852002   MUL A0, A0, A1
9D034EA4  0F40DB84   JAL _my_malloc
9D034EA8  24840003   ADDIU A0, A0, 3
85:                     if (NULL == addr)
9D034EAC  10400009   BEQ V0, ZERO, 0x9D034ED4
9D034EB0  00402021   ADDU A0, V0, ZERO
86:                        return NULL;
9D034ED4  00001021   ADDU V0, ZERO, ZERO
87:                  
88:                     return _make_bitmap(addr, false, width, height, width, overdraw);
9D034EB4  AFB00010   SW S0, 16(SP)
9D034EB8  AFB20014   SW S2, 20(SP)
9D034EBC  00002821   ADDU A1, ZERO, ZERO
9D034EC0  02003021   ADDU A2, S0, ZERO
9D034EC4  0F40D358   JAL .Letext0, .LFE1, .LFB6, _make_bitmap, .Ltext0
9D034EC8  02203821   ADDU A3, S1, ZERO
9D034ECC  0B40D3B7   J 0x9D034EDC
9D034ED0  8FBF0024   LW RA, 36(SP)
89:                  }
9D034ED8  8FBF0024   LW RA, 36(SP)
9D034EDC  8FB20020   LW S2, 32(SP)
9D034EE0  8FB1001C   LW S1, 28(SP)
9D034EE4  8FB00018   LW S0, 24(SP)
9D034EE8  03E00008   JR RA
9D034EEC  27BD0028   ADDIU SP, SP, 40
90:                  
91:                  /* allocate and initialize a hardware bitmap */
92:                  bitmap_t *bmp_createhw(uint8 *addr, int width, int height, int pitch)
93:                  {
9D034EF0  27BDFFE0   ADDIU SP, SP, -32
9D034EF4  AFBF001C   SW RA, 28(SP)
9D034EF8  00A01821   ADDU V1, A1, ZERO
9D034EFC  00C01021   ADDU V0, A2, ZERO
94:                     return _make_bitmap(addr, true, width, height, pitch, 0); /* zero overdraw */
9D034F00  AFA70010   SW A3, 16(SP)
9D034F04  AFA00014   SW ZERO, 20(SP)
9D034F08  24050001   ADDIU A1, ZERO, 1
9D034F0C  00603021   ADDU A2, V1, ZERO
9D034F10  0F40D358   JAL .Letext0, .LFE1, .LFB6, _make_bitmap, .Ltext0
9D034F14  00403821   ADDU A3, V0, ZERO
95:                  }
9D034F18  8FBF001C   LW RA, 28(SP)
9D034F1C  03E00008   JR RA
9D034F20  27BD0020   ADDIU SP, SP, 32
96:                  
97:                  /* Deallocate space for a bitmap structure */
98:                  void bmp_destroy(bitmap_t **bitmap)
99:                  {
9D034F24  27BDFFE8   ADDIU SP, SP, -24
9D034F28  AFBF0014   SW RA, 20(SP)
9D034F2C  AFB00010   SW S0, 16(SP)
9D034F30  00808021   ADDU S0, A0, ZERO
100:                    if (*bitmap)
9D034F34  8C840000   LW A0, 0(A0)
9D034F38  5080000D   BEQL A0, ZERO, 0x9D034F70
9D034F3C  8FBF0014   LW RA, 20(SP)
101:                    {
102:                       if ((*bitmap)->data && false == (*bitmap)->hardware)
9D034F40  8C830010   LW V1, 16(A0)
9D034F44  10600006   BEQ V1, ZERO, .LVL34
9D034F48  00000000   NOP
9D034F4C  8C83000C   LW V1, 12(A0)
9D034F50  14600003   BNE V1, ZERO, .LVL34
9D034F54  00000000   NOP
103:                          free((*bitmap)->data);
9D034F58  0F40DB97   JAL _my_free
9D034F5C  24840010   ADDIU A0, A0, 16
104:                       free(*bitmap);
9D034F60  0F40DB97   JAL _my_free
9D034F64  02002021   ADDU A0, S0, ZERO
105:                       *bitmap = NULL;
9D034F68  AE000000   SW ZERO, 0(S0)
106:                    }
107:                 }
9D034F6C  8FBF0014   LW RA, 20(SP)
9D034F70  8FB00010   LW S0, 16(SP)
9D034F74  03E00008   JR RA
9D034F78  27BD0018   ADDIU SP, SP, 24
108:                 
109:                 /*
110:                 ** $Log: bitmap.c,v $
111:                 ** Revision 1.2  2001/04/27 14:37:11  neil
112:                 ** wheeee
113:                 **
114:                 ** Revision 1.1.1.1  2001/04/27 07:03:54  neil
115:                 ** initial
116:                 **
117:                 ** Revision 1.16  2000/11/05 16:37:18  matt
118:                 ** rolled rgb.h into bitmap.h
119:                 **
120:                 ** Revision 1.15  2000/10/10 13:58:13  matt
121:                 ** stroustrup squeezing his way in the door
122:                 **
123:                 ** Revision 1.14  2000/09/18 02:06:48  matt
124:                 ** -pedantic is your friend
125:                 **
126:                 ** Revision 1.13  2000/08/13 13:16:30  matt
127:                 ** bugfix for alignment adjustment
128:                 **
129:                 ** Revision 1.12  2000/07/24 04:31:43  matt
130:                 ** pitch/data area on non-hw bitmaps get padded to 32-bit boundaries
131:                 **
132:                 ** Revision 1.11  2000/07/17 01:52:27  matt
133:                 ** made sure last line of all source files is a newline
134:                 **
135:                 ** Revision 1.10  2000/07/09 14:43:01  matt
136:                 ** pitch is now configurable for bmp_createhw()
137:                 **
138:                 ** Revision 1.9  2000/07/06 17:55:57  matt
139:                 ** two big bugs fixed
140:                 **
141:                 ** Revision 1.8  2000/07/06 17:38:11  matt
142:                 ** replaced missing string.h include
143:                 **
144:                 ** Revision 1.7  2000/07/06 16:46:57  matt
145:                 ** added bmp_clear() routine
146:                 **
147:                 ** Revision 1.6  2000/06/26 04:56:24  matt
148:                 ** minor cleanup
149:                 **
150:                 ** Revision 1.5  2000/06/09 15:12:25  matt
151:                 ** initial revision
152:                 **
153:                 */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/main.c  ---------------------------------------------
1:                   #include <xc.h>
2:                   #include "badge_settings.h"
3:                   #include "badge.h"
4:                   #include "hw.h"
5:                   #include "post.h"
6:                   #include "nofrendo/nofrendo.h"
7:                   
8:                   int16_t main(void)
9:                   {
9D03BDC4  27BDFFE8   ADDIU SP, SP, -24
9D03BDC8  AFBF0014   SW RA, 20(SP)
10:                      int i;
11:                  	hw_init();
9D03BDCC  0F4079A6   JAL hw_init
9D03BDD0  00000000   NOP
12:                  	badge_init();
9D03BDD4  0F406DE4   JAL badge_init
9D03BDD8  00000000   NOP
13:                      nofrendo_main(0, NULL);
9D03BDDC  00002021   ADDU A0, ZERO, ZERO
9D03BDE0  0F40CC1F   JAL nofrendo_main
9D03BDE4  00002821   ADDU A1, ZERO, ZERO
9D03BDE8  0B40EF7A   J .LVL2
9D03BDEC  00000000   NOP
14:                  	//if (KEY_BRK==0) post();
15:                  	//if ((SHOW_SPLASH)&(K_SHIFTR==1)) boot_animation();
16:                  	//badge_menu();
17:                  	while (1)
18:                      {
19:                          //tft_fill_area(0,0,320,240,CIPHER_BACKGROUND);
20:                          //wait_ms(1000);
21:                          //tft_fill_area(0,0,320,240,CIPHER_CURSOR);
22:                          //wait_ms(1000);
23:                      }
24:                  }
25:                  
26:                  
27:                  
28:                  
29:                  
30:                  /*
31:                   * Interesting places to take look at, in MPLABX use CtrlCtrl+Shift+F to search in all files
32:                   * for those "bookmarks"
33:                   * 
34:                   * ----------------badge stuff----------------
35:                   * After reset, badge checks whether BRK key is pressed. In case it is, test routine starts, see
36:                   * B_BDG001
37:                   * If not, B_BDG002 is the place to jump. Welcome screen is painstakingly drawn via lot of setxy
38:                   * and print commands. Then it waits for user input. All interaction with user is done mainly via
39:                   * stdio functions, that can be redirected either to local screen or serial port, available on pins
40:                   * C13 and C14 of expansion port. There is also stdio buffer that can be written from software, 
41:                   * for specific purposes
42:                   * The four stdio functions are under B_BDG003
43:                   *
44:                   * For this badge, I opted to refresh display from interrupt handler linked to timer5, set to fire
45:                   * every 12ms - B_BDG003. This is heartbeat of badge, where both partial display refresh (two 
46:                   * lines at once) and keyboard scanning tasks do take place. Notice, one can disable refreshing 
47:                   * the display if needed via function B_BDG004 or manipulating the variable handle_display 
48:                   * directly. Timer 1 runs with 1ms period, and increments variable ticks, available via function
49:                   * millis().
50:                   * 
51:                   * User can write its own programs to be incorporated within "big firmware" of badge, see B_BDG006
52:                   * and B_BDG007 and B_BDG008. Badge can be turned on or off via power button. This erases display.
53:                   * Since badge doesn't have graphic framebuffer (it has terminal text buffer though), the user should 
54:                   * refresh the display in appropriate function, set up via function pointer, see B_BDG005 and B_BDG009
55:                   * Currently, there is about 16kB of RAM and 45kB of FLASH free to use for user
56:                   * If some CP/M features are disabled, see B_BDG010, user can gain additional quarter of megabyte of 
57:                   * FLASH space and about 22kB of RAM.
58:                   * 
59:                   * Other than that, simple firmware skeleton will be provided too, so user doesn't need to use
60:                   * software infrastructure of badge firmware, with all its dependencies; uncovering full hardware 
61:                   * potential of badge.
62:                   * 
63:                   * 
64:                   * ----------------BASIC interpreter----------------
65:                   * 
66:                   * B_BAS001: This is where BASIC tokens are defined, have you want to add your word, add one
67:                   * into this list, then go to B_BAS002 to define appropriate action. Of course, don't forget
68:                   * to add the token number into list in B_BAS003
69:                   * This way you can make words like LED, invoked as LED 2,1
70:                   * If you want to add word returning value like RND in form of LET A = RND 10, take a look how it's
71:                   * made in B_BAS004
72:                   * 
73:                   * A lot of things around BASIC happens outside the interpreter itself. After invoking BASIC, the first
74:                   * function to be called is B_BAS005 where everything is set to run BASIC loop in B_BAS006
75:                   * It basically (no pun intended) collects users input and once buffer si full, it is sent to decide what 
76:                   * it is - B_BAS007
77:                   * If it appears to be valid line of BASIC program, including line number, it goes to be added to
78:                   * current program B_BAS008
79:                   * If not, program flows through series of comparisons to determine whether the thing that user wrote is 
80:                   * something from a few commands that command interpreter can execute. One of them is RUN that sets up 
81:                   * interpreter in B_BAS009 and runs main loop in B_BAS010.
82:                   * Program buffer is set to 16kB, so you can't have programs longer than that. You may redefine buffer 
83:                   * length (see badge_settings.h), you may want to check save/load routines, see B_BAS011
84:                   * 
85:                   * 
86:                   * 
87:                   * ----------------CP/M machine----------------
88:                   * 
89:                   * This one runs on Z80 interpreter, written by Udo Munk. It is directory /Z80, along with two other files,
90:                   * defining memory and hardware configuration of this virtual machine, files hwz.c and iosim.c
91:                   * 
92:                   * iosim.c defines the memory map. I wrote the BIOS for CP/M machine to be extremely simple, with more 
93:                   * automation and intelligence on software side, not achievable with classic hardware means. For example,
94:                   * writing to address 0xFF triggers CP/M system reload. so BIOS hook can be as simple as writing single byte 
95:                   * into this address. Classic BIOS needed a lot of more Z80 instructions to achieve th same.
96:                   * On address 0x68 (+0x6D) is implemented simple UART, linked to UART3 of badge (available on C13 and C14 of
97:                   * expansion port). This UART is utilized in XMODEM program (available at drive B:), so user can transfer 
98:                   * CP/M binaries from PC via any compatible Xmodem terminal. I used moserial and cutecom in linux, or teraterm
99:                   * in windows.
100:                  * CP/M machine is setup to use six different drives:
101:                  * A: - 22kB in size, RAM disk. Fast, no wearout, ideal for temporary storage. Trashed on reboot.
102:                  * B: - 128kB ROM disk, contains a lot of goodies. You could pack a lot of software into 128kB then.
103:                  * C: - 128kB ROM dosk, contains Zork and Sargon. You know, games.
104:                  * D: - 512kB FLASH disk, free for your use
105:                  * hwz.c contains all stuff to access disks and devices of CP/M machine, like disk byte read and write
106:                  * functions, called directly by BIOS via addresses 0x07 and 0x08, with 0x05 and 0x06 setting track and
107:                  * sector of drive selected via 0x04.
108:                  *
109:                  * CP/M defines some standard IO devices - reader, puncher for your punch cards and list device to print 
110:                  * out your program listings. Those are not implemented in badge hardware iosim.c, see B_CPM001 and B_CPM002
111:                  * If defined, you can - for example - list files directly from CP/M via virtual printer, or make virtual
112:                  * punch card reader/puncher to EEPROM, thumb drive, PC, FTP server via ESP32 or anything you can connect 
113:                  * to bitbanged interface on badge expansion port.
114:                  * 
115:                  */
---  /Users/nitro/basic-badge/firmware/badge1.X/src/hw.c  -----------------------------------------------
1:                   #include <xc.h>
2:                   #include "hw.h"
3:                   #include "Z80/hwz.h"
4:                   #include <plib.h>
5:                   #include <peripheral/pps.h>
6:                   #include <stdint.h>
7:                   
8:                   // DEVCFG3
9:                   // USERID = No Setting
10:                  #pragma config FSRSSEL = PRIORITY_7     // Shadow Register Set Priority Select (SRS Priority 7)
11:                  #pragma config PMDL1WAY = OFF           // Peripheral Module Disable Configuration (Allow multiple reconfigurations)
12:                  #pragma config IOL1WAY = OFF            // Peripheral Pin Select Configuration (Allow multiple reconfigurations)
13:                  
14:                  // DEVCFG2
15:                  #pragma config FPLLIDIV = DIV_1//DIV_2         // PLL Input Divider (2x Divider)
16:                  #pragma config FPLLMUL = MUL_15//MUL_24         // PLL Multiplier (24x Multiplier)
17:                  #pragma config FPLLODIV = DIV_1//DIV_2         // System PLL Output Clock Divider (PLL Divide by 2)
18:                  
19:                  // DEVCFG1
20:                  #pragma config FNOSC = FRCPLL           // Oscillator Selection Bits (Fast RC Osc with PLL)
21:                  #pragma config FSOSCEN = OFF            // Secondary Oscillator Enable (Disabled)
22:                  #pragma config IESO = ON                // Internal/External Switch Over (Enabled)
23:                  #pragma config POSCMOD = OFF            // Primary Oscillator Configuration (Primary osc disabled)
24:                  #pragma config OSCIOFNC = OFF           // CLKO Output Signal Active on the OSCO Pin (Disabled)
25:                  #pragma config FPBDIV = DIV_1           // Peripheral Clock Divisor (Pb_Clk is Sys_Clk/1)
26:                  #pragma config FCKSM = CSDCMD           // Clock Switching and Monitor Selection (Clock Switch Disable, FSCM Disabled)
27:                  #pragma config WDTPS = PS1048576        // Watchdog Timer Postscaler (1:1048576)
28:                  #pragma config WINDIS = OFF             // Watchdog Timer Window Enable (Watchdog Timer is in Non-Window Mode)
29:                  #pragma config FWDTEN = OFF             // Watchdog Timer Enable (WDT Disabled (SWDTEN Bit Controls))
30:                  #pragma config FWDTWINSZ = WINSZ_25     // Watchdog Timer Window Size (Window Size is 25%)
31:                  
32:                  // DEVCFG0
33:                  #pragma config DEBUG = OFF              // Background Debugger Enable (Debugger is Disabled)
34:                  #pragma config JTAGEN = OFF             // JTAG Enable (JTAG Disabled)
35:                  #pragma config ICESEL = ICS_PGx1        // ICE/ICD Comm Channel Select (Communicate on PGEC1/PGED1)
36:                  #pragma config PWP = OFF                // Program Flash Write Protect (Disable)
37:                  #pragma config BWP = OFF                // Boot Flash Write Protect bit (Protection Disabled)
38:                  #pragma config CP = OFF                 // Code Protect (Protection Disabled)
39:                  
40:                  uint8_t key_state=0,key_last,key,led_state=0;
41:                  uint16_t rnd_var1,rnd_var2,rnd_var3;
42:                  
43:                  const int8_t keys_normal[50] = 
44:                  	{
45:                  	'3','4','2','5','1','9','6','7','0','8',
46:                  	'e','r','w','t','q','o','y','u','p','i',
47:                  	's','d','a','f','/','k','g','h','l','j',
48:                  	'x','c','z','v',' ',0x2c,'b','n','.','m',
49:                  	K_DN,K_RT,K_LT,';',K_UP,K_DEL,'=',K_ENT,BACKSPACE,'-',
50:                  	};
51:                  
52:                  const int8_t keys_shift_l[50] = 
53:                  	{
54:                  	'#','$','@','%','!','(',' ','&',')','*',
55:                  	'E','R','W','T','Q','O','Y','U','P','I',
56:                  	'S','D','A','F','?','K','G','H','L','J',
57:                  	'X','C','Z','V',' ','<','B','N','>','M',
58:                  	K_DN,K_RT,K_LT,':',K_UP,K_DEL,'+',K_ECR,BACKSPACE,'"',
59:                  	};
60:                  const int8_t keys_shift_r[50] = 
61:                  	{
62:                  	'#','$','@','%','!','(',' ','&',')','*',
63:                  	'E','R','W','T','Q','O','Y','U','P','I',
64:                  	'S','D','A','F','?','K','G','H','L','J',
65:                  	'X','C','Z','V',' ','<','B','N','>','M',
66:                  	K_DN,K_RT,K_LT,':',K_UP,K_DEL,'+',K_ECR,BACKSPACE,'_',
67:                  	};
68:                  
69:                  int8_t key_char;
70:                  
71:                  
72:                  const uint16_t tone_pr_table[128] = 
73:                  	{
74:                  	0, //No Note
75:                  	/* Sacrifice this for 0 to be 'no note' 366927, // 0 | C-1 | 8.176Hz */
76:                  	/* Lowest notes have timer values too big for uint16_t so setting to 0 as workaround*/
77:                  	0, //346340, // 1 | C?/D?-1 | 8.662Hz
78:                  	0, //326904, // 2 | D-1 | 9.177Hz
79:                  	0, //308546, // 3 | E?/D?-1 | 9.723Hz
80:                  	0, //291233, // 4 | E-1 | 10.301Hz
81:                  	0, //274876, // 5 | F-1 | 10.914Hz
82:                  	0, //259448, // 6 | F?/G?-1 | 11.563Hz
83:                  	0, //244897, // 7 | G-1 | 12.25Hz
84:                  	0, //231142, // 8 | A?/G?-1 | 12.979Hz
85:                  	0, //218181, // 9 | A-1 | 13.75Hz
86:                  	0, //205930, // 10 | B?/A?-1 | 14.568Hz
87:                  	0, //194376, // 11 | B-1 | 15.434Hz
88:                  	0, //183463, // 12 | C0 | 16.352Hz
89:                  	0, //173170, // 13 | C?/D?0 | 17.324Hz
90:                  	0, //163452, // 14 | D0 | 18.354Hz
91:                  	0, //154281, // 15 | E?/D?0 | 19.445Hz
92:                  	0, //145616, // 16 | E0 | 20.602Hz
93:                  	0, //137444, // 17 | F0 | 21.827Hz
94:                  	0, //129729, // 18 | F?/G?0 | 23.125Hz
95:                  	0, //122448, // 19 | G0 | 24.5Hz
96:                  	0, //115575, // 20 | A?/G?0 | 25.957Hz
97:                  	0, //109090, // 21 | A0 | 27.5Hz
98:                  	0, //102968, // 22 | B?/A?0 | 29.135Hz
99:                  	0, //97188, // 23 | B0 | 30.868Hz
100:                 	0, //91734, // 24 | C1 | 32.703Hz
101:                 	0, //86585, // 25 | C?/D?1 | 34.648Hz
102:                 	0, //81726, // 26 | D1 | 36.708Hz
103:                 	0, //77138, // 27 | E?/D?1 | 38.891Hz
104:                 	0, //72810, // 28 | E1 | 41.203Hz
105:                 	0, //68722, // 29 | F1 | 43.654Hz
106:                 	64866, // 30 | F?/G?1 | 46.249Hz
107:                 	61225, // 31 | G1 | 48.999Hz
108:                 	57788, // 32 | A?/G?1 | 51.913Hz
109:                 	54545, // 33 | A1 | 55.0Hz
110:                 	51484, // 34 | B?/A?1 | 58.27Hz
111:                 	48594, // 35 | B1 | 61.735Hz
112:                 	45867, // 36 | C2 | 65.406Hz
113:                 	43292, // 37 | C?/D?2 | 69.296Hz
114:                 	40863, // 38 | D2 | 73.416Hz
115:                 	38569, // 39 | E?/D?2 | 77.782Hz
116:                 	36404, // 40 | E2 | 82.407Hz
117:                 	34361, // 41 | F2 | 87.307Hz
118:                 	32432, // 42 | F?/G?2 | 92.499Hz
119:                 	30612, // 43 | G2 | 97.999Hz
120:                 	28893, // 44 | A?/G?2 | 103.83Hz
121:                 	27272, // 45 | A2 | 110.0Hz
122:                 	25742, // 46 | B?/A?2 | 116.54Hz
123:                 	24297, // 47 | B2 | 123.47Hz
124:                 	22934, // 48 | C3 | 130.81Hz
125:                 	21646, // 49 | C?/D?3 | 138.59Hz
126:                 	20431, // 50 | D3 | 146.83Hz
127:                 	19285, // 51 | E?/D?3 | 155.56Hz
128:                 	18202, // 52 | E3 | 164.81Hz
129:                 	17181, // 53 | F3 | 174.61Hz
130:                 	16216, // 54 | F?/G?3 | 185.0Hz
131:                 	15306, // 55 | G3 | 196.0Hz
132:                 	14447, // 56 | A?/G?3 | 207.65Hz
133:                 	13636, // 57 | A3 | 220.0Hz
134:                 	12871, // 58 | B?/A?3 | 233.08Hz
135:                 	12148, // 59 | B3 | 246.94Hz
136:                 	11466, // 60 | C4 | 261.63Hz
137:                 	10823, // 61 | C?/D?4 | 277.18Hz
138:                 	10215, // 62 | D4 | 293.66Hz
139:                 	9642, // 63 | E?/D?4 | 311.13Hz
140:                 	9101, // 64 | E4 | 329.63Hz
141:                 	8590, // 65 | F4 | 349.23Hz
142:                 	8108, // 66 | F?/G?4 | 369.99Hz
143:                 	7653, // 67 | G4 | 392.0Hz
144:                 	7223, // 68 | A?/G?4 | 415.3Hz
145:                 	6818, // 69 | A4 | 440.0Hz
146:                 	6435, // 70 | B?/A?4 | 466.16Hz
147:                 	6074, // 71 | B4 | 493.88Hz
148:                 	5733, // 72 | C5 | 523.25Hz
149:                 	5411, // 73 | C?/D?5 | 554.37Hz
150:                 	5107, // 74 | D5 | 587.33Hz
151:                 	4821, // 75 | E?/D?5 | 622.25Hz
152:                 	4550, // 76 | E5 | 659.26Hz
153:                 	4295, // 77 | F5 | 698.46Hz
154:                 	4054, // 78 | F?/G?5 | 739.99Hz
155:                 	3826, // 79 | G5 | 783.99Hz
156:                 	3611, // 80 | A?/G?5 | 830.61Hz
157:                 	3409, // 81 | A5 | 880.0Hz
158:                 	3217, // 82 | B?/A?5 | 932.33Hz
159:                 	3037, // 83 | B5 | 987.77Hz
160:                 	2866, // 84 | C6 | 1046.5Hz
161:                 	2705, // 85 | C?/D?6 | 1108.7Hz
162:                 	2553, // 86 | D6 | 1174.7Hz
163:                 	2410, // 87 | E?/D?6 | 1244.5Hz
164:                 	2275, // 88 | E6 | 1318.5Hz
165:                 	2147, // 89 | F6 | 1396.9Hz
166:                 	2027, // 90 | F?/G?6 | 1480.0Hz
167:                 	1913, // 91 | G6 | 1568.0Hz
168:                 	1805, // 92 | A?/G?6 | 1661.2Hz
169:                 	1704, // 93 | A6 | 1760.0Hz
170:                 	1608, // 94 | B?/A?6 | 1864.7Hz
171:                 	1518, // 95 | B6 | 1975.5Hz
172:                 	1433, // 96 | C7 | 2093.0Hz
173:                 	1352, // 97 | C?/D?7 | 2217.5Hz
174:                 	1276, // 98 | D7 | 2349.3Hz
175:                 	1205, // 99 | E?/D?7 | 2489.0Hz
176:                 	1137, // 100 | E7 | 2637.0Hz
177:                 	1073, // 101 | F7 | 2793.8Hz
178:                 	1013, // 102 | F?/G?7 | 2960.0Hz
179:                 	956, // 103 | G7 | 3136.0Hz
180:                 	902, // 104 | A?/G?7 | 3322.4Hz
181:                 	852, // 105 | A7 | 3520.0Hz
182:                 	804, // 106 | B?/A?7 | 3729.3Hz
183:                 	759, // 107 | B7 | 3951.1Hz
184:                 	716, // 108 | C8 | 4186.0Hz
185:                 	676, // 109 | C?/D?8 | 4434.9Hz
186:                 	638, // 110 | D8 | 4698.6Hz
187:                 	602, // 111 | E?/D?8 | 4978.0Hz
188:                 	568, // 112 | E8 | 5274.0Hz
189:                 	536, // 113 | F8 | 5587.7Hz
190:                 	506, // 114 | F?/G?8 | 5919.9Hz
191:                 	478, // 115 | G8 | 6271.9Hz
192:                 	451, // 116 | A?/G?8 | 6644.9Hz
193:                 	426, // 117 | A8 | 7040.0Hz
194:                 	402, // 118 | B?/A?8 | 7458.6Hz
195:                 	379, // 119 | B8 | 7902.1Hz
196:                 	358, // 120 | C9 | 8372.0Hz
197:                 	338, // 121 | C?/D?9 | 8869.8Hz
198:                 	319, // 122 | D9 | 9397.3Hz
199:                 	301, // 123 | E?/D?9 | 9956.1Hz
200:                 	284, // 124 | E9 | 10548.1Hz
201:                 	268, // 125 | F9 | 11175.3Hz
202:                 	253, // 126 | F?/G?9 | 11839.8Hz
203:                 	239, // 127 | G9 | 12543.9Hz
204:                 	};
205:                 
206:                 uint8_t get_led_word(void)
207:                 	{
208:                 	uint8_t retval = 0;
9D01E414  7C420180   EXT V0, V0, 6, 1
209:                 	if (LED_R) retval = retval | 0x01;
9D01E40C  3C02BF88   LUI V0, -16504
9D01E410  8C426330   LW V0, 25392(V0)
210:                 	if (LED_G) retval = retval | 0x02;
9D01E418  3C03BF88   LUI V1, -16504
9D01E41C  8C636530   LW V1, 25904(V1)
9D01E420  30630002   ANDI V1, V1, 2
9D01E424  10600003   BEQ V1, ZERO, 0x9D01E434
9D01E428  3C03BF88   LUI V1, -16504
9D01E42C  34420002   ORI V0, V0, 2
9D01E430  304200FF   ANDI V0, V0, 255
211:                 	if (LED_B) retval = retval | 0x04;
9D01E434  8C646330   LW A0, 25392(V1)
9D01E438  30840080   ANDI A0, A0, 128
9D01E43C  34430004   ORI V1, V0, 4
212:                 	return retval;
213:                 	}
9D01E440  03E00008   JR RA
9D01E444  0064100B   MOVN V0, V1, A0
214:                 
215:                 void set_led_word (uint8_t val)
216:                 	{
217:                 	if (val&0x01) LED_R = 1;
9D01E448  30820001   ANDI V0, A0, 1
9D01E44C  10400007   BEQ V0, ZERO, 0x9D01E46C
9D01E450  3C02BF88   LUI V0, -16504
9D01E454  94436330   LHU V1, 25392(V0)
9D01E458  24050001   ADDIU A1, ZERO, 1
9D01E45C  7CA33184   INS V1, A1, 6, 1
9D01E460  A4436330   SH V1, 25392(V0)
9D01E464  0B40791F   J 0x9D01E47C
9D01E468  30820002   ANDI V0, A0, 2
218:                 		else LED_R = 0;
9D01E46C  94436330   LHU V1, 25392(V0)
9D01E470  7C033184   INS V1, ZERO, 6, 1
9D01E474  A4436330   SH V1, 25392(V0)
219:                 	if (val&0x02) LED_G = 1;
9D01E478  30820002   ANDI V0, A0, 2
9D01E47C  304200FF   ANDI V0, V0, 255
9D01E480  10400007   BEQ V0, ZERO, 0x9D01E4A0
9D01E484  3C02BF88   LUI V0, -16504
9D01E488  90436530   LBU V1, 25904(V0)
9D01E48C  24050001   ADDIU A1, ZERO, 1
9D01E490  7CA30844   INS V1, A1, 1, 1
9D01E494  A0436530   SB V1, 25904(V0)
9D01E498  0B40792C   J 0x9D01E4B0
9D01E49C  30840004   ANDI A0, A0, 4
220:                 		else LED_G = 0;
9D01E4A0  90436530   LBU V1, 25904(V0)
9D01E4A4  7C030844   INS V1, ZERO, 1, 1
9D01E4A8  A0436530   SB V1, 25904(V0)
221:                 	if (val&0x04) LED_B = 1;
9D01E4AC  30840004   ANDI A0, A0, 4
9D01E4B0  308400FF   ANDI A0, A0, 255
9D01E4B4  10800007   BEQ A0, ZERO, 0x9D01E4D4
9D01E4B8  3C02BF88   LUI V0, -16504
9D01E4BC  94436330   LHU V1, 25392(V0)
9D01E4C0  24040001   ADDIU A0, ZERO, 1
9D01E4C4  7C8339C4   INS V1, A0, 7, 1
9D01E4C8  A4436330   SH V1, 25392(V0)
9D01E4CC  03E00008   JR RA
9D01E4D0  00000000   NOP
222:                 		else LED_B = 0;
9D01E4D4  94436330   LHU V1, 25392(V0)
9D01E4D8  7C0339C4   INS V1, ZERO, 7, 1
9D01E4DC  A4436330   SH V1, 25392(V0)
9D01E4E0  03E00008   JR RA
9D01E4E4  00000000   NOP
223:                 	}
224:                 
225:                 void set_led (uint8_t led_n, uint8_t led_v)
226:                 	{
227:                 	if (led_n==0)
9D01E4E8  14800007   BNE A0, ZERO, 0x9D01E508
9D01E4EC  24020001   ADDIU V0, ZERO, 1
228:                 		LED_R = led_v;
9D01E4F0  3C02BF88   LUI V0, -16504
9D01E4F4  94436330   LHU V1, 25392(V0)
9D01E4F8  7CA33184   INS V1, A1, 6, 1
9D01E4FC  A4436330   SH V1, 25392(V0)
9D01E500  03E00008   JR RA
9D01E504  00000000   NOP
229:                 	if (led_n==1)
9D01E508  14820006   BNE A0, V0, 0x9D01E524
9D01E50C  3C02BF88   LUI V0, -16504
230:                 		LED_G = led_v;	
9D01E510  90436530   LBU V1, 25904(V0)
9D01E514  7CA30844   INS V1, A1, 1, 1
9D01E518  A0436530   SB V1, 25904(V0)
9D01E51C  03E00008   JR RA
9D01E520  00000000   NOP
231:                 	if (led_n==2)
9D01E524  24020002   ADDIU V0, ZERO, 2
9D01E528  1482FFF5   BNE A0, V0, 0x9D01E500
9D01E52C  3C02BF88   LUI V0, -16504
232:                 		LED_B = led_v;	
9D01E530  94436330   LHU V1, 25392(V0)
9D01E534  7CA339C4   INS V1, A1, 7, 1
9D01E538  A4436330   SH V1, 25392(V0)
9D01E53C  03E00008   JR RA
9D01E540  00000000   NOP
233:                 	}
234:                 
235:                 void sound_play_notes (uint8_t note1, uint8_t note2, uint8_t note3, uint16_t wait)
236:                 	{
9D01F23C  27BDFFD8   ADDIU SP, SP, -40
9D01F240  AFBF0024   SW RA, 36(SP)
9D01F244  AFB30020   SW S3, 32(SP)
9D01F248  AFB2001C   SW S2, 28(SP)
9D01F24C  AFB10018   SW S1, 24(SP)
9D01F250  AFB00014   SW S0, 20(SP)
9D01F254  00A09821   ADDU S3, A1, ZERO
9D01F258  00C09021   ADDU S2, A2, ZERO
9D01F25C  00E08821   ADDU S1, A3, ZERO
237:                 	IEC0bits.T5IE = 0;		//sound is a bit shaky without this
9D01F260  3C10BF88   LUI S0, -16504
9D01F264  8E021060   LW V0, 4192(S0)
9D01F268  7C02C604   INS V0, ZERO, 24, 1
9D01F26C  AE021060   SW V0, 4192(S0)
238:                 							//quick hack, needs more debugging
239:                 	sound_set_note(note1,0);
9D01F270  0F40799B   JAL sound_set_note
9D01F274  00002821   ADDU A1, ZERO, ZERO
240:                 	sound_set_note(note2,1);
9D01F278  02602021   ADDU A0, S3, ZERO
9D01F27C  0F40799B   JAL sound_set_note
9D01F280  24050001   ADDIU A1, ZERO, 1
241:                 	sound_set_note(note3,2);
9D01F284  02402021   ADDU A0, S2, ZERO
9D01F288  0F40799B   JAL sound_set_note
9D01F28C  24050002   ADDIU A1, ZERO, 2
242:                 	wait_ms(wait);
9D01F290  0F407C7E   JAL wait_ms
9D01F294  02202021   ADDU A0, S1, ZERO
243:                 	sound_set_note(0,0);
9D01F298  00002021   ADDU A0, ZERO, ZERO
9D01F29C  0F40799B   JAL sound_set_note
9D01F2A0  00002821   ADDU A1, ZERO, ZERO
244:                 	sound_set_note(0,1);
9D01F2A4  00002021   ADDU A0, ZERO, ZERO
9D01F2A8  0F40799B   JAL sound_set_note
9D01F2AC  24050001   ADDIU A1, ZERO, 1
245:                 	sound_set_note(0,2);
9D01F2B0  00002021   ADDU A0, ZERO, ZERO
9D01F2B4  0F40799B   JAL sound_set_note
9D01F2B8  24050002   ADDIU A1, ZERO, 2
246:                 	IEC0bits.T5IE = 1;
9D01F2BC  8E021060   LW V0, 4192(S0)
9D01F2C0  24030001   ADDIU V1, ZERO, 1
9D01F2C4  7C62C604   INS V0, V1, 24, 1
9D01F2C8  AE021060   SW V0, 4192(S0)
247:                 	}
9D01F2CC  8FBF0024   LW RA, 36(SP)
9D01F2D0  8FB30020   LW S3, 32(SP)
9D01F2D4  8FB2001C   LW S2, 28(SP)
9D01F2D8  8FB10018   LW S1, 24(SP)
9D01F2DC  8FB00014   LW S0, 20(SP)
9D01F2E0  03E00008   JR RA
9D01F2E4  27BD0028   ADDIU SP, SP, 40
248:                 
249:                 void sound_set_note (uint8_t note, uint8_t generator)
250:                 	{
9D01E66C  27BDFFE8   ADDIU SP, SP, -24
9D01E670  AFBF0014   SW RA, 20(SP)
251:                 	sound_set_generator(tone_pr_table[note],generator);
9D01E674  00042040   SLL A0, A0, 1
9D01E678  3C029D03   LUI V0, -25341
9D01E67C  24425DF0   ADDIU V0, V0, 24048
9D01E680  00822021   ADDU A0, A0, V0
9D01E684  0F407951   JAL sound_set_generator
9D01E688  94840000   LHU A0, 0(A0)
252:                 	}
9D01E68C  8FBF0014   LW RA, 20(SP)
9D01E690  03E00008   JR RA
9D01E694  27BD0018   ADDIU SP, SP, 24
253:                 
254:                 void sound_set_generator (uint16_t period, uint8_t generator)
255:                 	{
256:                 	if (generator==0)
9D01E544  14A00018   BNE A1, ZERO, 0x9D01E5A8
9D01E548  24020001   ADDIU V0, ZERO, 1
257:                 		{
258:                 		T2CONbits.TON = 0;
9D01E54C  3C02BF80   LUI V0, -16512
9D01E550  94430800   LHU V1, 2048(V0)
9D01E554  7C037BC4   INS V1, ZERO, 15, 1
9D01E558  A4430800   SH V1, 2048(V0)
259:                 		PR2 = period;
9D01E55C  3C03BF80   LUI V1, -16512
9D01E560  AC640820   SW A0, 2080(V1)
260:                 		T2CONbits.TCKPS = 0b011;
9D01E564  94430800   LHU V1, 2048(V0)
9D01E568  24050003   ADDIU A1, ZERO, 3
9D01E56C  7CA33104   INS V1, A1, 4, 3
9D01E570  A4430800   SH V1, 2048(V0)
261:                 		if (period!=0)
9D01E574  50800007   BEQL A0, ZERO, 0x9D01E594
9D01E578  3C02BF88   LUI V0, -16504
262:                 			T2CONbits.TON = 1;
9D01E57C  94430800   LHU V1, 2048(V0)
9D01E580  24040001   ADDIU A0, ZERO, 1
9D01E584  7C837BC4   INS V1, A0, 15, 1
9D01E588  A4430800   SH V1, 2048(V0)
9D01E58C  03E00008   JR RA
9D01E590  00000000   NOP
263:                 		else
264:                 			GEN_0_PIN = 0;
9D01E594  94436330   LHU V1, 25392(V0)
9D01E598  7C030844   INS V1, ZERO, 1, 1
9D01E59C  A4436330   SH V1, 25392(V0)
9D01E5A0  03E00008   JR RA
9D01E5A4  00000000   NOP
265:                 		}
266:                 	if (generator==1)
9D01E5A8  14A20017   BNE A1, V0, 0x9D01E608
9D01E5AC  3C02BF80   LUI V0, -16512
267:                 		{
268:                 		T3CONbits.TON = 0;
9D01E5B0  94430A00   LHU V1, 2560(V0)
9D01E5B4  7C037BC4   INS V1, ZERO, 15, 1
9D01E5B8  A4430A00   SH V1, 2560(V0)
269:                 		PR3 = period;
9D01E5BC  3C03BF80   LUI V1, -16512
9D01E5C0  AC640A20   SW A0, 2592(V1)
270:                 		T3CONbits.TCKPS = 0b011;
9D01E5C4  94430A00   LHU V1, 2560(V0)
9D01E5C8  24050003   ADDIU A1, ZERO, 3
9D01E5CC  7CA33104   INS V1, A1, 4, 3
9D01E5D0  A4430A00   SH V1, 2560(V0)
271:                 		if (period!=0)
9D01E5D4  50800007   BEQL A0, ZERO, 0x9D01E5F4
9D01E5D8  3C02BF88   LUI V0, -16504
272:                 			T3CONbits.TON = 1;
9D01E5DC  94430A00   LHU V1, 2560(V0)
9D01E5E0  24040001   ADDIU A0, ZERO, 1
9D01E5E4  7C837BC4   INS V1, A0, 15, 1
9D01E5E8  A4430A00   SH V1, 2560(V0)
9D01E5EC  03E00008   JR RA
9D01E5F0  00000000   NOP
273:                 		else
274:                 			GEN_1_PIN = 0;
9D01E5F4  94436330   LHU V1, 25392(V0)
9D01E5F8  7C031084   INS V1, ZERO, 2, 1
9D01E5FC  A4436330   SH V1, 25392(V0)
9D01E600  03E00008   JR RA
9D01E604  00000000   NOP
275:                 		}
276:                 	if (generator==2)
9D01E608  24020002   ADDIU V0, ZERO, 2
9D01E60C  14A2FFDF   BNE A1, V0, 0x9D01E58C
9D01E610  3C02BF80   LUI V0, -16512
277:                 		{
278:                 		T4CONbits.TON = 0;
9D01E614  94430C00   LHU V1, 3072(V0)
9D01E618  7C037BC4   INS V1, ZERO, 15, 1
9D01E61C  A4430C00   SH V1, 3072(V0)
279:                 		PR4 = period;
9D01E620  3C03BF80   LUI V1, -16512
9D01E624  AC640C20   SW A0, 3104(V1)
280:                 		T4CONbits.TCKPS = 0b011;
9D01E628  94430C00   LHU V1, 3072(V0)
9D01E62C  24050003   ADDIU A1, ZERO, 3
9D01E630  7CA33104   INS V1, A1, 4, 3
9D01E634  A4430C00   SH V1, 3072(V0)
281:                 		if (period!=0)
9D01E638  50800007   BEQL A0, ZERO, 0x9D01E658
9D01E63C  3C02BF88   LUI V0, -16504
282:                 			T4CONbits.TON = 1;
9D01E640  94430C00   LHU V1, 3072(V0)
9D01E644  24040001   ADDIU A0, ZERO, 1
9D01E648  7C837BC4   INS V1, A0, 15, 1
9D01E64C  A4430C00   SH V1, 3072(V0)
9D01E650  03E00008   JR RA
9D01E654  00000000   NOP
283:                 		else
284:                 			GEN_2_PIN = 0;
9D01E658  94436330   LHU V1, 25392(V0)
9D01E65C  7C0318C4   INS V1, ZERO, 3, 1
9D01E660  A4436330   SH V1, 25392(V0)
9D01E664  03E00008   JR RA
9D01E668  00000000   NOP
285:                 		}
286:                 	}
287:                 
288:                 void hw_sleep (void)
289:                 	{
9D01EBB8  27BDFFE8   ADDIU SP, SP, -24
9D01EBBC  AFBF0014   SW RA, 20(SP)
290:                 	led_state = get_led_word();
9D01EBC0  0F407903   JAL get_led_word
9D01EBC4  00000000   NOP
9D01EBC8  A3828178   SB V0, -32392(GP)
291:                 	set_led_word(0);
9D01EBCC  0F407912   JAL set_led_word
9D01EBD0  00002021   ADDU A0, ZERO, ZERO
292:                 	T1CONbits.TON = 0;
9D01EBD4  3C02BF80   LUI V0, -16512
9D01EBD8  94430600   LHU V1, 1536(V0)
9D01EBDC  7C037BC4   INS V1, ZERO, 15, 1
9D01EBE0  A4430600   SH V1, 1536(V0)
293:                 	T2CONbits.TON = 0;
9D01EBE4  3C02BF80   LUI V0, -16512
9D01EBE8  94430800   LHU V1, 2048(V0)
9D01EBEC  7C037BC4   INS V1, ZERO, 15, 1
9D01EBF0  A4430800   SH V1, 2048(V0)
294:                 	T3CONbits.TON = 0;
9D01EBF4  3C02BF80   LUI V0, -16512
9D01EBF8  94430A00   LHU V1, 2560(V0)
9D01EBFC  7C037BC4   INS V1, ZERO, 15, 1
9D01EC00  A4430A00   SH V1, 2560(V0)
295:                 	T4CONbits.TON = 0;
9D01EC04  3C02BF80   LUI V0, -16512
9D01EC08  94430C00   LHU V1, 3072(V0)
9D01EC0C  7C037BC4   INS V1, ZERO, 15, 1
9D01EC10  A4430C00   SH V1, 3072(V0)
296:                 	T5CONbits.TON = 0;
9D01EC14  3C02BF80   LUI V0, -16512
9D01EC18  94430E00   LHU V1, 3584(V0)
9D01EC1C  7C037BC4   INS V1, ZERO, 15, 1
9D01EC20  A4430E00   SH V1, 3584(V0)
297:                 	SPI1CONbits.ON = 0;
9D01EC24  3C02BF80   LUI V0, -16512
9D01EC28  8C435800   LW V1, 22528(V0)
9D01EC2C  7C037BC4   INS V1, ZERO, 15, 1
9D01EC30  AC435800   SW V1, 22528(V0)
298:                 	U3MODEbits.ON = 0;
9D01EC34  3C02BF80   LUI V0, -16512
9D01EC38  94436400   LHU V1, 25600(V0)
9D01EC3C  7C037BC4   INS V1, ZERO, 15, 1
9D01EC40  A4436400   SH V1, 25600(V0)
299:                 	LCD_PWR = 1;
9D01EC44  3C03BF88   LUI V1, -16504
9D01EC48  94646230   LHU A0, 25136(V1)
9D01EC4C  24020001   ADDIU V0, ZERO, 1
9D01EC50  7C447BC4   INS A0, V0, 15, 1
9D01EC54  A4646230   SH A0, 25136(V1)
300:                 	LCD_BKLT = 1;
9D01EC58  3C04BF88   LUI A0, -16504
9D01EC5C  90836530   LBU V1, 25904(A0)
9D01EC60  7C430004   INS V1, V0, 0, 1
9D01EC64  A0836530   SB V1, 25904(A0)
301:                 	LCD_PORT = 0;
9D01EC68  3C06BF88   LUI A2, -16504
9D01EC6C  ACC06430   SW ZERO, 25648(A2)
302:                 	LCD_DC = 0;
9D01EC70  3C05BF88   LUI A1, -16504
9D01EC74  94A36630   LHU V1, 26160(A1)
9D01EC78  7C034204   INS V1, ZERO, 8, 1
9D01EC7C  A4A36630   SH V1, 26160(A1)
303:                 	LCD_RD = 0;
9D01EC80  3C03BF88   LUI V1, -16504
9D01EC84  94676330   LHU A3, 25392(V1)
9D01EC88  7C072944   INS A3, ZERO, 5, 1
9D01EC8C  A4676330   SH A3, 25392(V1)
304:                 	LCD_RES = 0;
9D01EC90  94A76630   LHU A3, 26160(A1)
9D01EC94  7C0739C4   INS A3, ZERO, 7, 1
9D01EC98  A4A76630   SH A3, 26160(A1)
305:                 	LCD_WR = 0;
9D01EC9C  94656330   LHU A1, 25392(V1)
9D01ECA0  7C052104   INS A1, ZERO, 4, 1
9D01ECA4  A4656330   SH A1, 25392(V1)
306:                 	GEN_0_PIN = 0;
9D01ECA8  94656330   LHU A1, 25392(V1)
9D01ECAC  7C050844   INS A1, ZERO, 1, 1
9D01ECB0  A4656330   SH A1, 25392(V1)
307:                 	GEN_1_PIN = 0;
9D01ECB4  94656330   LHU A1, 25392(V1)
9D01ECB8  7C051084   INS A1, ZERO, 2, 1
9D01ECBC  A4656330   SH A1, 25392(V1)
308:                 	GEN_2_PIN = 0;
9D01ECC0  94656330   LHU A1, 25392(V1)
9D01ECC4  7C0518C4   INS A1, ZERO, 3, 1
9D01ECC8  A4656330   SH A1, 25392(V1)
309:                 	TRISBbits.TRISB0 = 0;
9D01ECCC  3C03BF88   LUI V1, -16504
9D01ECD0  94656110   LHU A1, 24848(V1)
9D01ECD4  7C050004   INS A1, ZERO, 0, 1
9D01ECD8  A4656110   SH A1, 24848(V1)
310:                 	TRISBbits.TRISB1 = 0;
9D01ECDC  94656110   LHU A1, 24848(V1)
9D01ECE0  7C050844   INS A1, ZERO, 1, 1
9D01ECE4  A4656110   SH A1, 24848(V1)
311:                 	TRISG = 0;
9D01ECE8  3C03BF88   LUI V1, -16504
9D01ECEC  AC606610   SW ZERO, 26128(V1)
312:                 	TRISGbits.TRISG9 = 1;
9D01ECF0  3C03BF88   LUI V1, -16504
9D01ECF4  94656610   LHU A1, 26128(V1)
9D01ECF8  7C454A44   INS A1, V0, 9, 1
9D01ECFC  A4656610   SH A1, 26128(V1)
313:                 	TRISGbits.TRISG6 = 1;
9D01ED00  94656610   LHU A1, 26128(V1)
9D01ED04  7C453184   INS A1, V0, 6, 1
9D01ED08  A4656610   SH A1, 26128(V1)
314:                 	TRISC = 0;
9D01ED0C  3C03BF88   LUI V1, -16504
9D01ED10  AC606210   SW ZERO, 25104(V1)
315:                 	LATC = 0x8000;
9D01ED14  34058000   ORI A1, ZERO, -32768
9D01ED18  3C03BF88   LUI V1, -16504
9D01ED1C  AC656230   SW A1, 25136(V1)
316:                 	TRISD = 0X0;
9D01ED20  3C03BF88   LUI V1, -16504
9D01ED24  AC606310   SW ZERO, 25360(V1)
317:                 	LATD = 0;
9D01ED28  3C03BF88   LUI V1, -16504
9D01ED2C  AC606330   SW ZERO, 25392(V1)
318:                 	TRISDbits.TRISD9 = 1;
9D01ED30  3C03BF88   LUI V1, -16504
9D01ED34  94656310   LHU A1, 25360(V1)
9D01ED38  7C454A44   INS A1, V0, 9, 1
9D01ED3C  A4656310   SH A1, 25360(V1)
319:                 	TRISDbits.TRISD10 = 1;
9D01ED40  94656310   LHU A1, 25360(V1)
9D01ED44  7C455284   INS A1, V0, 10, 1
9D01ED48  A4656310   SH A1, 25360(V1)
320:                     CNPUDbits.CNPUD10 = 1;
9D01ED4C  3C03BF88   LUI V1, -16504
9D01ED50  94656350   LHU A1, 25424(V1)
9D01ED54  7C455284   INS A1, V0, 10, 1
9D01ED58  A4656350   SH A1, 25424(V1)
321:                     CNPUDbits.CNPUD9 = 1;
9D01ED5C  94656350   LHU A1, 25424(V1)
9D01ED60  7C454A44   INS A1, V0, 9, 1
9D01ED64  A4656350   SH A1, 25424(V1)
322:                 	TRISE = 0;
9D01ED68  3C03BF88   LUI V1, -16504
9D01ED6C  AC606410   SW ZERO, 25616(V1)
323:                 	LATE = 0;	
9D01ED70  ACC06430   SW ZERO, 25648(A2)
324:                 	TRISF = 0;
9D01ED74  3C03BF88   LUI V1, -16504
9D01ED78  AC606510   SW ZERO, 25872(V1)
325:                 	K_R1 = 1;
9D01ED7C  3C03BF88   LUI V1, -16504
9D01ED80  94656130   LHU A1, 24880(V1)
9D01ED84  7C456304   INS A1, V0, 12, 1
9D01ED88  A4656130   SH A1, 24880(V1)
326:                 	K_R2 = 1;
9D01ED8C  94656130   LHU A1, 24880(V1)
9D01ED90  7C456B44   INS A1, V0, 13, 1
9D01ED94  A4656130   SH A1, 24880(V1)
327:                 	K_R3 = 1;
9D01ED98  94656130   LHU A1, 24880(V1)
9D01ED9C  7C457384   INS A1, V0, 14, 1
9D01EDA0  A4656130   SH A1, 24880(V1)
328:                 	K_R4 = 1;
9D01EDA4  94656130   LHU A1, 24880(V1)
9D01EDA8  7C457BC4   INS A1, V0, 15, 1
9D01EDAC  A4656130   SH A1, 24880(V1)
329:                 	K_R5 = 1;
9D01EDB0  90836530   LBU V1, 25904(A0)
9D01EDB4  7C432104   INS V1, V0, 4, 1
9D01EDB8  A0836530   SB V1, 25904(A0)
330:                 	PMD1 = 0xFFFFFFFF;
9D01EDBC  3C09BF81   LUI T1, -16511
9D01EDC0  2403FFFF   ADDIU V1, ZERO, -1
9D01EDC4  AD23F240   SW V1, -3520(T1)
331:                 	PMD2 = 0xFFFFFFFF;
9D01EDC8  3C08BF81   LUI T0, -16511
9D01EDCC  AD03F250   SW V1, -3504(T0)
332:                 	PMD3 = 0xFFFFFFFF;
9D01EDD0  3C07BF81   LUI A3, -16511
9D01EDD4  ACE3F260   SW V1, -3488(A3)
333:                 	PMD4 = 0xFFFFFFFF;
9D01EDD8  3C06BF81   LUI A2, -16511
9D01EDDC  ACC3F270   SW V1, -3472(A2)
334:                 	PMD5 = 0xFFFFFFFF;
9D01EDE0  3C05BF81   LUI A1, -16511
9D01EDE4  ACA3F280   SW V1, -3456(A1)
335:                 	PMD6 = 0xFFFFFFFF;
9D01EDE8  3C04BF81   LUI A0, -16511
9D01EDEC  AC83F290   SW V1, -3440(A0)
336:                 	SYSKEY = 0x0;            // Write invalid key to force lock
9D01EDF0  3C03BF81   LUI V1, -16511
9D01EDF4  AC60F230   SW ZERO, -3536(V1)
337:                 	SYSKEY = 0xAA996655;     // Write Key1 to SYSKEY
9D01EDF8  3C0AAA99   LUI T2, -21863
9D01EDFC  254A6655   ADDIU T2, T2, 26197
9D01EE00  AC6AF230   SW T2, -3536(V1)
338:                 	SYSKEY = 0x556699AA;     // Write Key2 to SYSKEY
9D01EE04  3C0A5566   LUI T2, 21862
9D01EE08  354A99AA   ORI T2, T2, -26198
9D01EE0C  AC6AF230   SW T2, -3536(V1)
339:                 	OSCCONSET = 0x10; // set Power-Saving mode to Slee
9D01EE10  240B0010   ADDIU T3, ZERO, 16
9D01EE14  3C0ABF81   LUI T2, -16511
9D01EE18  AD4BF008   SW T3, -4088(T2)
340:                 	SYSKEY = 0x0; // Write invalid key to force lock
9D01EE1C  AC60F230   SW ZERO, -3536(V1)
341:                 
342:                 	IFS0bits.INT2IF = 0;
9D01EE20  3C03BF88   LUI V1, -16504
9D01EE24  8C6A1030   LW T2, 4144(V1)
9D01EE28  7C0A6B44   INS T2, ZERO, 13, 1
9D01EE2C  AC6A1030   SW T2, 4144(V1)
343:                 	IEC0bits.INT2IE = 1;
9D01EE30  3C03BF88   LUI V1, -16504
9D01EE34  8C6A1060   LW T2, 4192(V1)
9D01EE38  7C4A6B44   INS T2, V0, 13, 1
9D01EE3C  AC6A1060   SW T2, 4192(V1)
344:                 	IPC2bits.INT2IP = 4;
9D01EE40  3C02BF88   LUI V0, -16504
9D01EE44  8C4A10B0   LW T2, 4272(V0)
9D01EE48  240B0004   ADDIU T3, ZERO, 4
9D01EE4C  7D6AE684   INS T2, T3, 26, 3
9D01EE50  AC4A10B0   SW T2, 4272(V0)
345:                 	//asm volatile("wait"); 
346:                 	IEC0bits.INT2IE = 0;
9D01EE54  8C621060   LW V0, 4192(V1)
9D01EE58  7C026B44   INS V0, ZERO, 13, 1
9D01EE5C  AC621060   SW V0, 4192(V1)
347:                 	PMD1 = 0;
9D01EE60  AD20F240   SW ZERO, -3520(T1)
348:                 	PMD2 = 0;
9D01EE64  AD00F250   SW ZERO, -3504(T0)
349:                 	PMD3 = 0;
9D01EE68  ACE0F260   SW ZERO, -3488(A3)
350:                 	PMD4 = 0;
9D01EE6C  ACC0F270   SW ZERO, -3472(A2)
351:                 	PMD5 = 0;
9D01EE70  ACA0F280   SW ZERO, -3456(A1)
352:                 	PMD6 = 0;
9D01EE74  AC80F290   SW ZERO, -3440(A0)
353:                 	hw_init();
9D01EE78  0F4079A6   JAL hw_init
9D01EE7C  00000000   NOP
354:                 	start_after_wake();
9D01EE80  8F8281AC   LW V0, -32340(GP)
9D01EE84  0040F809   JALR V0
9D01EE88  00000000   NOP
355:                 	}
9D01EE8C  8FBF0014   LW RA, 20(SP)
9D01EE90  03E00008   JR RA
9D01EE94  27BD0018   ADDIU SP, SP, 24
356:                 
357:                 
358:                 
359:                 void hw_init (void)
360:                 	{
9D01E698  27BDFFE0   ADDIU SP, SP, -32
9D01E69C  AFBF001C   SW RA, 28(SP)
9D01E6A0  AFB20018   SW S2, 24(SP)
9D01E6A4  AFB10014   SW S1, 20(SP)
361:                     SYSTEMConfigPerformance(SYS_CLK);
362:                     OSCCONbits.FRCDIV = 0b000;
9D01E758  3C02BF81   LUI V0, -16511
9D01E75C  8C43F000   LW V1, -4096(V0)
9D01E760  7C03D604   INS V1, ZERO, 24, 3
9D01E764  AC43F000   SW V1, -4096(V0)
363:                 	ANSELB = 0;
9D01E768  3C02BF88   LUI V0, -16504
9D01E76C  AC406100   SW ZERO, 24832(V0)
364:                 	ANSELC = 0;
9D01E770  3C02BF88   LUI V0, -16504
9D01E774  AC406200   SW ZERO, 25088(V0)
365:                 	ANSELD = 0;
9D01E778  3C02BF88   LUI V0, -16504
9D01E77C  AC406300   SW ZERO, 25344(V0)
366:                 	ANSELE = 0;
9D01E780  3C02BF88   LUI V0, -16504
9D01E784  AC406400   SW ZERO, 25600(V0)
367:                 	ANSELF = 0;
9D01E788  3C02BF88   LUI V0, -16504
9D01E78C  AC406500   SW ZERO, 25856(V0)
368:                 	ANSELG = 0;
9D01E790  3C02BF88   LUI V0, -16504
9D01E794  AC406600   SW ZERO, 26112(V0)
369:                 	TRISD = 0;
9D01E798  3C02BF88   LUI V0, -16504
9D01E79C  AC406310   SW ZERO, 25360(V0)
370:                 	TRISDbits.TRISD9 = 1;
9D01E7A0  3C02BF88   LUI V0, -16504
9D01E7A4  94436310   LHU V1, 25360(V0)
9D01E7A8  7E034A44   INS V1, S0, 9, 1
9D01E7AC  A4436310   SH V1, 25360(V0)
371:                 	TRISDbits.TRISD10 = 1;
9D01E7B0  94436310   LHU V1, 25360(V0)
9D01E7B4  7E035284   INS V1, S0, 10, 1
9D01E7B8  A4436310   SH V1, 25360(V0)
372:                     TRISE = 0;
9D01E7BC  3C03BF88   LUI V1, -16504
9D01E7C0  AC606410   SW ZERO, 25616(V1)
373:                     TRISG = 0;
9D01E7C4  3C03BF88   LUI V1, -16504
9D01E7C8  AC606610   SW ZERO, 26128(V1)
374:                 	TRISGbits.TRISG6 = 1;
9D01E7CC  3C03BF88   LUI V1, -16504
9D01E7D0  94646610   LHU A0, 26128(V1)
9D01E7D4  7E043184   INS A0, S0, 6, 1
9D01E7D8  A4646610   SH A0, 26128(V1)
375:                 	TRISGbits.TRISG9 = 1;
9D01E7DC  94646610   LHU A0, 26128(V1)
9D01E7E0  7E044A44   INS A0, S0, 9, 1
9D01E7E4  A4646610   SH A0, 26128(V1)
376:                     TRISF = 0;
9D01E7E8  3C03BF88   LUI V1, -16504
9D01E7EC  AC606510   SW ZERO, 25872(V1)
377:                 	TRISFbits.TRISF5 = 1;
9D01E7F0  3C03BF88   LUI V1, -16504
9D01E7F4  90646510   LBU A0, 25872(V1)
9D01E7F8  7E042944   INS A0, S0, 5, 1
9D01E7FC  A0646510   SB A0, 25872(V1)
378:                     TRISB = 0x0FFF; 
9D01E800  24030FFF   ADDIU V1, ZERO, 4095
9D01E804  3C04BF88   LUI A0, -16504
9D01E808  AC836110   SW V1, 24848(A0)
379:                     CNPUB = 0x0FFF;
9D01E80C  3C04BF88   LUI A0, -16504
9D01E810  AC836150   SW V1, 24912(A0)
380:                     CNPUDbits.CNPUD10 = 1;
9D01E814  3C03BF88   LUI V1, -16504
9D01E818  94646350   LHU A0, 25424(V1)
9D01E81C  7E045284   INS A0, S0, 10, 1
9D01E820  A4646350   SH A0, 25424(V1)
381:                     CNPUDbits.CNPUD9 = 1;
9D01E824  94646350   LHU A0, 25424(V1)
9D01E828  7E044A44   INS A0, S0, 9, 1
9D01E82C  A4646350   SH A0, 25424(V1)
382:                 	TRISCbits.TRISC12 = 0;
9D01E830  3C03BF88   LUI V1, -16504
9D01E834  94646210   LHU A0, 25104(V1)
9D01E838  7C046304   INS A0, ZERO, 12, 1
9D01E83C  A4646210   SH A0, 25104(V1)
383:                 	TRISDbits.TRISD8 = 0;
9D01E840  94446310   LHU A0, 25360(V0)
9D01E844  7C044204   INS A0, ZERO, 8, 1
9D01E848  A4446310   SH A0, 25360(V0)
384:                 	FLASH_WP = 1;
9D01E84C  3C12BF88   LUI S2, -16504
9D01E850  96426330   LHU V0, 25392(S2)
9D01E854  7E024204   INS V0, S0, 8, 1
9D01E858  A6426330   SH V0, 25392(S2)
385:                 	FLASH_HOLD = 1;
9D01E85C  3C04BF88   LUI A0, -16504
9D01E860  94826230   LHU V0, 25136(A0)
9D01E864  7E026304   INS V0, S0, 12, 1
9D01E868  A4826230   SH V0, 25136(A0)
386:                 	CS_FLASH = 1;
9D01E86C  3C11BF88   LUI S1, -16504
9D01E870  92226530   LBU V0, 25904(S1)
9D01E874  7E021084   INS V0, S0, 2, 1
9D01E878  A2226530   SB V0, 25904(S1)
387:                     /*
388:                     MOSI	F3	
389:                     MISO	F5	
390:                     SCK		F6	
391:                 			C13	
392:                 			C14	
393:                      */
394:                     PPSUnLock;
395:                     PPSOutput(4, RPF3, SDO1);	//MOSI for FLASH
9D01E87C  3C02BF81   LUI V0, -16511
9D01E880  9045FC4C   LBU A1, -948(V0)
9D01E884  24060008   ADDIU A2, ZERO, 8
9D01E888  7CC51804   INS A1, A2, 0, 4
9D01E88C  A045FC4C   SB A1, -948(V0)
396:                 	PPSInput(1, SDI1, RPF5);	//MISO for FLASH
9D01E890  3C02BF81   LUI V0, -16511
9D01E894  9046FA84   LBU A2, -1404(V0)
9D01E898  24050002   ADDIU A1, ZERO, 2
9D01E89C  7CA61804   INS A2, A1, 0, 4
9D01E8A0  A046FA84   SB A2, -1404(V0)
397:                 								//SCK is fixed
398:                 	PPSInput(1, U3RX, RPC13);	//RX pin
9D01E8A4  3C02BF81   LUI V0, -16511
9D01E8A8  9046FA60   LBU A2, -1440(V0)
9D01E8AC  24070007   ADDIU A3, ZERO, 7
9D01E8B0  7CE61804   INS A2, A3, 0, 4
9D01E8B4  A046FA60   SB A2, -1440(V0)
399:                 	PPSOutput(1, RPC14, U3TX);	//TX pin
9D01E8B8  3C02BF81   LUI V0, -16511
9D01E8BC  9046FBB8   LBU A2, -1096(V0)
9D01E8C0  7E061804   INS A2, S0, 0, 4
9D01E8C4  A046FBB8   SB A2, -1096(V0)
400:                 	PPSInput(3, INT2, RPG6);	//power on/off, tie to external interrupt2
9D01E8C8  3C02BF81   LUI V0, -16511
9D01E8CC  9046FA08   LBU A2, -1528(V0)
9D01E8D0  7E061804   INS A2, S0, 0, 4
9D01E8D4  A046FA08   SB A2, -1528(V0)
401:                     PPSLock;
402:                 
403:                 	U3MODEbits.ON = 1;
9D01E8D8  3C02BF80   LUI V0, -16512
9D01E8DC  94466400   LHU A2, 25600(V0)
9D01E8E0  7E067BC4   INS A2, S0, 15, 1
9D01E8E4  A4466400   SH A2, 25600(V0)
404:                 //	U1MODEbits.STSEL = 1;
405:                     U3STAbits.URXEN = 1;
9D01E8E8  3C02BF80   LUI V0, -16512
9D01E8EC  8C466410   LW A2, 25616(V0)
9D01E8F0  7E066304   INS A2, S0, 12, 1
9D01E8F4  AC466410   SW A2, 25616(V0)
406:                     U3STAbits.UTXEN = 1;
9D01E8F8  8C466410   LW A2, 25616(V0)
9D01E8FC  7E065284   INS A2, S0, 10, 1
9D01E900  AC466410   SW A2, 25616(V0)
407:                     U3BRG = ((PB_CLK)/(16*19200)) - 1;
9D01E904  2407009B   ADDIU A3, ZERO, 155
9D01E908  3C06BF80   LUI A2, -16512
9D01E90C  ACC76440   SW A3, 25664(A2)
408:                 //    INTEnable(INT_SOURCE_UART_RX(UART3), INT_ENABLED);
409:                 //    IPC7bits.U3IP = 6;
410:                     U3STAbits.OERR=0;
9D01E910  8C466410   LW A2, 25616(V0)
9D01E914  7C060844   INS A2, ZERO, 1, 1
9D01E918  AC466410   SW A2, 25616(V0)
411:                 
412:                 	SPI1CONbits.MSTEN = 1;
9D01E91C  3C02BF80   LUI V0, -16512
9D01E920  8C465800   LW A2, 22528(V0)
9D01E924  7E062944   INS A2, S0, 5, 1
9D01E928  AC465800   SW A2, 22528(V0)
413:                     SPI1CONbits.CKP = 0;
9D01E92C  8C465800   LW A2, 22528(V0)
9D01E930  7C063184   INS A2, ZERO, 6, 1
9D01E934  AC465800   SW A2, 22528(V0)
414:                     SPI1CONbits.SMP = 0;
9D01E938  8C465800   LW A2, 22528(V0)
9D01E93C  7C064A44   INS A2, ZERO, 9, 1
9D01E940  AC465800   SW A2, 22528(V0)
415:                     SPI1CONbits.CKE = 1;
9D01E944  8C465800   LW A2, 22528(V0)
9D01E948  7E064204   INS A2, S0, 8, 1
9D01E94C  AC465800   SW A2, 22528(V0)
416:                     SPI1BRG = 1;
9D01E950  3C06BF80   LUI A2, -16512
9D01E954  ACD05830   SW S0, 22576(A2)
417:                     SPI1CONbits.ON = 1;
9D01E958  8C465800   LW A2, 22528(V0)
9D01E95C  7E067BC4   INS A2, S0, 15, 1
9D01E960  AC465800   SW A2, 22528(V0)
418:                     
419:                 //    TRISBbits.TRISB13 = 0;
420:                     LCD_BKLT = 1;
9D01E964  92226530   LBU V0, 25904(S1)
9D01E968  7E020004   INS V0, S0, 0, 1
9D01E96C  A2226530   SB V0, 25904(S1)
421:                     LCD_PWR = 0;
9D01E970  94826230   LHU V0, 25136(A0)
9D01E974  7C027BC4   INS V0, ZERO, 15, 1
9D01E978  A4826230   SH V0, 25136(A0)
422:                 	TRISCbits.TRISC15 = 0;
9D01E97C  94626210   LHU V0, 25104(V1)
9D01E980  7C027BC4   INS V0, ZERO, 15, 1
9D01E984  A4626210   SH V0, 25104(V1)
423:                 	
424:                     PR5 = 12 *(FPB / 64 / 1000);
9D01E988  24032328   ADDIU V1, ZERO, 9000
9D01E98C  3C02BF80   LUI V0, -16512
9D01E990  AC430E20   SW V1, 3616(V0)
425:                     T5CONbits.TCKPS = 0b110;
9D01E994  3C02BF80   LUI V0, -16512
9D01E998  94440E00   LHU A0, 3584(V0)
9D01E99C  24030006   ADDIU V1, ZERO, 6
9D01E9A0  7C643104   INS A0, V1, 4, 3
9D01E9A4  A4440E00   SH A0, 3584(V0)
426:                     T5CONbits.TON = 1;
9D01E9A8  94440E00   LHU A0, 3584(V0)
9D01E9AC  7E047BC4   INS A0, S0, 15, 1
9D01E9B0  A4440E00   SH A0, 3584(V0)
427:                     IEC0bits.T5IE = 1;	
9D01E9B4  3C02BF88   LUI V0, -16504
9D01E9B8  8C441060   LW A0, 4192(V0)
9D01E9BC  7E04C604   INS A0, S0, 24, 1
9D01E9C0  AC441060   SW A0, 4192(V0)
428:                     IPC5bits.T5IP = 3;
9D01E9C4  3C04BF88   LUI A0, -16504
9D01E9C8  8C8610E0   LW A2, 4320(A0)
9D01E9CC  24070003   ADDIU A3, ZERO, 3
9D01E9D0  7CE62084   INS A2, A3, 2, 3
9D01E9D4  AC8610E0   SW A2, 4320(A0)
429:                 
430:                     IEC0bits.T2IE = 1;	
9D01E9D8  8C441060   LW A0, 4192(V0)
9D01E9DC  7E044A44   INS A0, S0, 9, 1
9D01E9E0  AC441060   SW A0, 4192(V0)
431:                     IPC2bits.T2IP = 6;
9D01E9E4  3C04BF88   LUI A0, -16504
9D01E9E8  8C8610B0   LW A2, 4272(A0)
9D01E9EC  7C662084   INS A2, V1, 2, 3
9D01E9F0  AC8610B0   SW A2, 4272(A0)
432:                     IEC0bits.T3IE = 1;	
9D01E9F4  8C441060   LW A0, 4192(V0)
9D01E9F8  7E047384   INS A0, S0, 14, 1
9D01E9FC  AC441060   SW A0, 4192(V0)
433:                     IPC3bits.T3IP = 6;
9D01EA00  3C04BF88   LUI A0, -16504
9D01EA04  8C8610C0   LW A2, 4288(A0)
9D01EA08  7C662084   INS A2, V1, 2, 3
9D01EA0C  AC8610C0   SW A2, 4288(A0)
434:                     IEC0bits.T4IE = 1;	
9D01EA10  8C441060   LW A0, 4192(V0)
9D01EA14  7E049CC4   INS A0, S0, 19, 1
9D01EA18  AC441060   SW A0, 4192(V0)
435:                     IPC4bits.T4IP = 6;
9D01EA1C  3C04BF88   LUI A0, -16504
9D01EA20  8C8610D0   LW A2, 4304(A0)
9D01EA24  7C662084   INS A2, V1, 2, 3
9D01EA28  AC8610D0   SW A2, 4304(A0)
436:                 
437:                     PR1 = (1*(FPB / 64 / 1000)) - 1;
9D01EA2C  240402ED   ADDIU A0, ZERO, 749
9D01EA30  3C03BF80   LUI V1, -16512
9D01EA34  AC640620   SW A0, 1568(V1)
438:                     T1CONbits.TCKPS = 0b10;	//Prescale 64 makes 1ms = 750 ticks at 48 MHz
9D01EA38  3C03BF80   LUI V1, -16512
9D01EA3C  94640600   LHU A0, 1536(V1)
9D01EA40  7CA42904   INS A0, A1, 4, 2
9D01EA44  A4640600   SH A0, 1536(V1)
439:                     T1CONbits.TON = 1;
9D01EA48  94640600   LHU A0, 1536(V1)
9D01EA4C  7E047BC4   INS A0, S0, 15, 1
9D01EA50  A4640600   SH A0, 1536(V1)
440:                     IEC0bits.T1IE = 1;
9D01EA54  8C431060   LW V1, 4192(V0)
9D01EA58  7E032104   INS V1, S0, 4, 1
9D01EA5C  AC431060   SW V1, 4192(V0)
441:                     IPC1bits.T1IP = 4;
9D01EA60  3C02BF88   LUI V0, -16504
9D01EA64  8C4310A0   LW V1, 4256(V0)
9D01EA68  24040004   ADDIU A0, ZERO, 4
9D01EA6C  7C832084   INS V1, A0, 2, 3
9D01EA70  AC4310A0   SW V1, 4256(V0)
442:                 
443:                 	sound_set_generator(0,0);
9D01EA74  00002021   ADDU A0, ZERO, ZERO
9D01EA78  0F407951   JAL sound_set_generator
9D01EA7C  00002821   ADDU A1, ZERO, ZERO
444:                 	sound_set_generator(0,1);
9D01EA80  00002021   ADDU A0, ZERO, ZERO
9D01EA84  0F407951   JAL sound_set_generator
9D01EA88  24050001   ADDIU A1, ZERO, 1
445:                 	sound_set_generator(0,2);
9D01EA8C  00002021   ADDU A0, ZERO, ZERO
9D01EA90  0F407951   JAL sound_set_generator
9D01EA94  24050002   ADDIU A1, ZERO, 2
446:                 	GEN_ENABLE = 1;
9D01EA98  96426330   LHU V0, 25392(S2)
9D01EA9C  7E025AC4   INS V0, S0, 11, 1
9D01EAA0  A6426330   SH V0, 25392(S2)
447:                     INTEnableSystemMultiVectoredInt();
9D01EAA4  0F40EF0E   JAL INTEnableSystemMultiVectoredInt
9D01EAA8  00000000   NOP
448:                 	
449:                 	//wait_ms(50);
450:                     //TFT_24_7789_Init();
451:                 	//tft_fill_area(0,0,320,240,0xFFFFFF);	//fill with black color
452:                 	//wait_ms(80);					//wait a moment to avoid flicker
453:                 	LCD_BKLT = 0;					//turn backlight on
9D01EAAC  92226530   LBU V0, 25904(S1)
9D01EAB0  7C020004   INS V0, ZERO, 0, 1
9D01EAB4  A2226530   SB V0, 25904(S1)
454:                 	//fl_rst_pb();
455:                 
456:                 	//if reset is after POR or manual reset, forget LED state
457:                 	if ((RCONbits.BOR)|(RCONbits.EXTR)|(RCONbits.POR))
9D01EAB8  3C02BF81   LUI V0, -16511
9D01EABC  8C44F600   LW A0, -2560(V0)
9D01EAC0  7C840040   EXT A0, A0, 1, 1
9D01EAC4  8C45F600   LW A1, -2560(V0)
9D01EAC8  7CA501C0   EXT A1, A1, 7, 1
9D01EACC  8C43F600   LW V1, -2560(V0)
9D01EAD0  30630001   ANDI V1, V1, 1
9D01EAD4  00A41025   OR V0, A1, A0
9D01EAD8  00621025   OR V0, V1, V0
9D01EADC  10400003   BEQ V0, ZERO, 0x9D01EAEC
9D01EAE0  3C02BF81   LUI V0, -16511
458:                 		{
459:                 		RCON = 0;
9D01EAE4  AC40F600   SW ZERO, -2560(V0)
460:                 		led_state = 0;
9D01EAE8  A3808178   SB ZERO, -32392(GP)
461:                 		}
462:                 	set_led_word(led_state);	
9D01EAEC  0F407912   JAL set_led_word
9D01EAF0  93848178   LBU A0, -32392(GP)
463:                 	
464:                   	}
9D01EAF4  0B407AE9   J 0x9D01EBA4
9D01EAF8  8FBF001C   LW RA, 28(SP)
9D01EBA4  8FB20018   LW S2, 24(SP)
9D01EBA8  8FB10014   LW S1, 20(SP)
9D01EBAC  8FB00010   LW S0, 16(SP)
9D01EBB0  03E00008   JR RA
9D01EBB4  27BD0020   ADDIU SP, SP, 32
465:                 
466:                 
467:                 uint8_t keyb_tasks (void)
468:                 	{
9D01EE98  27BDFFE8   ADDIU SP, SP, -24
9D01EE9C  AFBF0014   SW RA, 20(SP)
469:                 	static int8_t shift=0;
470:                 	uint8_t retval = 0;
9D01F1E8  00001021   ADDU V0, ZERO, ZERO
471:                 	rnd_var3 = rnd_var3 + 12345;
9D01EEA0  978281BA   LHU V0, -32326(GP)
9D01EEA4  24423039   ADDIU V0, V0, 12345
472:                 	rnd_var2 = rnd_var2 + millis();
9D01EEA8  0F406E42   JAL millis
9D01EEAC  A78281BA   SH V0, -32326(GP)
9D01EEB0  978381B6   LHU V1, -32330(GP)
9D01EEB4  00431021   ADDU V0, V0, V1
9D01EEB8  A78281B6   SH V0, -32330(GP)
473:                 	K_R1 = 1;
9D01EEBC  3C02BF88   LUI V0, -16504
9D01EEC0  94446130   LHU A0, 24880(V0)
9D01EEC4  24030001   ADDIU V1, ZERO, 1
9D01EEC8  7C646304   INS A0, V1, 12, 1
9D01EECC  A4446130   SH A0, 24880(V0)
474:                 	K_R2 = 1;
9D01EED0  94446130   LHU A0, 24880(V0)
9D01EED4  7C646B44   INS A0, V1, 13, 1
9D01EED8  A4446130   SH A0, 24880(V0)
475:                 	K_R3 = 1;
9D01EEDC  94446130   LHU A0, 24880(V0)
9D01EEE0  7C647384   INS A0, V1, 14, 1
9D01EEE4  A4446130   SH A0, 24880(V0)
476:                 	K_R4 = 1;
9D01EEE8  94446130   LHU A0, 24880(V0)
9D01EEEC  7C647BC4   INS A0, V1, 15, 1
9D01EEF0  A4446130   SH A0, 24880(V0)
477:                 	K_R5 = 1;
9D01EEF4  3C02BF88   LUI V0, -16504
9D01EEF8  90446530   LBU A0, 25904(V0)
9D01EEFC  7C642104   INS A0, V1, 4, 1
9D01EF00  A0446530   SB A0, 25904(V0)
478:                 	if (key_state==0) key = 255;
9D01EF04  93828179   LBU V0, -32391(GP)
9D01EF08  54400009   BNEL V0, ZERO, 0x9D01EF30
9D01EF0C  24030001   ADDIU V1, ZERO, 1
9D01EF10  2403FFFF   ADDIU V1, ZERO, -1
9D01EF14  A38381B9   SB V1, -32327(GP)
479:                 	
480:                 	if (key_state==0) K_R1 = 0;
9D01EF18  3C03BF88   LUI V1, -16504
9D01EF1C  94646130   LHU A0, 24880(V1)
9D01EF20  7C046304   INS A0, ZERO, 12, 1
9D01EF24  A4646130   SH A0, 24880(V1)
481:                 	if (key_state==1) K_R2 = 0;
9D01EF30  14430006   BNE V0, V1, 0x9D01EF4C
9D01EF34  3C03BF88   LUI V1, -16504
9D01EF38  94646130   LHU A0, 24880(V1)
9D01EF3C  7C046B44   INS A0, ZERO, 13, 1
9D01EF40  A4646130   SH A0, 24880(V1)
482:                 	if (key_state==2) K_R3 = 0;
9D01EF4C  24030002   ADDIU V1, ZERO, 2
9D01EF50  14430006   BNE V0, V1, 0x9D01EF6C
9D01EF54  3C03BF88   LUI V1, -16504
9D01EF58  94646130   LHU A0, 24880(V1)
9D01EF5C  7C047384   INS A0, ZERO, 14, 1
9D01EF60  A4646130   SH A0, 24880(V1)
483:                 	if (key_state==3) K_R4 = 0;
9D01EF28  0B407BDC   J 0x9D01EF70
9D01EF2C  24030003   ADDIU V1, ZERO, 3
9D01EF6C  24030003   ADDIU V1, ZERO, 3
9D01EF70  14430006   BNE V0, V1, 0x9D01EF8C
9D01EF74  3C03BF88   LUI V1, -16504
9D01EF78  94646130   LHU A0, 24880(V1)
9D01EF7C  7C047BC4   INS A0, ZERO, 15, 1
9D01EF80  A4646130   SH A0, 24880(V1)
484:                 	if (key_state==4) K_R5 = 0;
9D01EF44  0B407BE4   J 0x9D01EF90
9D01EF48  24030004   ADDIU V1, ZERO, 4
9D01EF8C  24030004   ADDIU V1, ZERO, 4
9D01EF90  14430006   BNE V0, V1, 0x9D01EFAC
9D01EF94  3C03BF88   LUI V1, -16504
9D01EF98  90646530   LBU A0, 25904(V1)
9D01EF9C  7C042104   INS A0, ZERO, 4, 1
9D01EFA0  A0646530   SB A0, 25904(V1)
485:                 
486:                 	if (key_state==5)
9D01EF64  0B407BEC   J 0x9D01EFB0
9D01EF68  24030005   ADDIU V1, ZERO, 5
9D01EFAC  24030005   ADDIU V1, ZERO, 5
9D01EFB0  14430024   BNE V0, V1, 0x9D01F044
9D01EFB4  938381B9   LBU V1, -32327(GP)
487:                 		{
488:                 		if ((key<255)&(key_last!=key))
9D01EFB8  938281BE   LBU V0, -32322(GP)
9D01EFBC  1043001E   BEQ V0, V1, 0x9D01F038
9D01EFC0  00001021   ADDU V0, ZERO, ZERO
9D01EFC4  386200FF   XORI V0, V1, 255
9D01EFC8  1040001B   BEQ V0, ZERO, 0x9D01F038
9D01EFCC  00001021   ADDU V0, ZERO, ZERO
489:                 			{
490:                 			if (K_SHIFTL==0) key_char = keys_shift_l[key];
9D01EFD0  3C02BF88   LUI V0, -16504
9D01EFD4  8C426320   LW V0, 25376(V0)
9D01EFD8  30420400   ANDI V0, V0, 1024
9D01EFDC  54400007   BNEL V0, ZERO, 0x9D01EFFC
9D01EFE0  3C02BF88   LUI V0, -16504
9D01EFE4  3C029D03   LUI V0, -25341
9D01EFE8  24425F24   ADDIU V0, V0, 24356
9D01EFEC  00621021   ADDU V0, V1, V0
9D01EFF0  90420000   LBU V0, 0(V0)
9D01EFF4  0B407C0D   J 0x9D01F034
9D01EFF8  A38281B8   SB V0, -32328(GP)
491:                 			else if (K_SHIFTR==0) key_char = keys_shift_r[key];
9D01EFFC  8C426320   LW V0, 25376(V0)
9D01F000  30420200   ANDI V0, V0, 512
9D01F004  54400007   BNEL V0, ZERO, 0x9D01F024
9D01F008  3C029D03   LUI V0, -25341
9D01F00C  3C029D03   LUI V0, -25341
9D01F010  24425EF0   ADDIU V0, V0, 24304
9D01F014  00621021   ADDU V0, V1, V0
9D01F018  90420000   LBU V0, 0(V0)
9D01F01C  0B407C0D   J 0x9D01F034
9D01F020  A38281B8   SB V0, -32328(GP)
492:                 			else key_char = keys_normal[key];
9D01F024  24425F58   ADDIU V0, V0, 24408
9D01F028  00621021   ADDU V0, V1, V0
9D01F02C  90420000   LBU V0, 0(V0)
9D01F030  A38281B8   SB V0, -32328(GP)
9D01F034  938281B8   LBU V0, -32328(GP)
493:                 			retval = key_char;
494:                 			}
495:                 		key_last = key;
9D01F038  A38381BE   SB V1, -32322(GP)
9D01F03C  0B407C7B   J 0x9D01F1EC
9D01F040  A3808179   SB ZERO, -32391(GP)
496:                 		key_state = 0;
497:                 		}
498:                 	else
499:                 		{
500:                 		if (K_C1==0)	key = 0 + (key_state*10);
9D01EF84  0B407C12   J 0x9D01F048
9D01EF88  3C03BF88   LUI V1, -16504
9D01EFA4  0B407C12   J 0x9D01F048
9D01EFA8  3C03BF88   LUI V1, -16504
9D01F044  3C03BF88   LUI V1, -16504
9D01F048  8C636120   LW V1, 24864(V1)
9D01F04C  30630800   ANDI V1, V1, 2048
9D01F050  14600006   BNE V1, ZERO, 0x9D01F06C
9D01F054  3C03BF88   LUI V1, -16504
9D01F058  00021840   SLL V1, V0, 1
9D01F05C  00032080   SLL A0, V1, 2
9D01F060  00641821   ADDU V1, V1, A0
9D01F064  A38381B9   SB V1, -32327(GP)
501:                 		if (K_C2==0)	key = 1 + (key_state*10);
9D01F068  3C03BF88   LUI V1, -16504
9D01F06C  8C636120   LW V1, 24864(V1)
9D01F070  30630400   ANDI V1, V1, 1024
9D01F074  14600007   BNE V1, ZERO, 0x9D01F094
9D01F078  3C03BF88   LUI V1, -16504
9D01F07C  00021840   SLL V1, V0, 1
9D01F080  00032080   SLL A0, V1, 2
9D01F084  00641821   ADDU V1, V1, A0
9D01F088  24630001   ADDIU V1, V1, 1
9D01F08C  A38381B9   SB V1, -32327(GP)
502:                 		if (K_C3==0)	key = 2 + (key_state*10);
9D01F090  3C03BF88   LUI V1, -16504
9D01F094  8C636120   LW V1, 24864(V1)
9D01F098  30630200   ANDI V1, V1, 512
9D01F09C  14600007   BNE V1, ZERO, 0x9D01F0BC
9D01F0A0  3C03BF88   LUI V1, -16504
9D01F0A4  00021840   SLL V1, V0, 1
9D01F0A8  00032080   SLL A0, V1, 2
9D01F0AC  00641821   ADDU V1, V1, A0
9D01F0B0  24630002   ADDIU V1, V1, 2
9D01F0B4  A38381B9   SB V1, -32327(GP)
503:                 		if (K_C4==0)	key = 3 + (key_state*10);
9D01F0B8  3C03BF88   LUI V1, -16504
9D01F0BC  8C636120   LW V1, 24864(V1)
9D01F0C0  30630100   ANDI V1, V1, 256
9D01F0C4  14600007   BNE V1, ZERO, 0x9D01F0E4
9D01F0C8  3C03BF88   LUI V1, -16504
9D01F0CC  00021840   SLL V1, V0, 1
9D01F0D0  00032080   SLL A0, V1, 2
9D01F0D4  00641821   ADDU V1, V1, A0
9D01F0D8  24630003   ADDIU V1, V1, 3
9D01F0DC  A38381B9   SB V1, -32327(GP)
504:                 		if (K_C5==0)	key = 4 + (key_state*10);
9D01F0E0  3C03BF88   LUI V1, -16504
9D01F0E4  8C636120   LW V1, 24864(V1)
9D01F0E8  30630080   ANDI V1, V1, 128
9D01F0EC  14600007   BNE V1, ZERO, 0x9D01F10C
9D01F0F0  3C03BF88   LUI V1, -16504
9D01F0F4  00021840   SLL V1, V0, 1
9D01F0F8  00032080   SLL A0, V1, 2
9D01F0FC  00641821   ADDU V1, V1, A0
9D01F100  24630004   ADDIU V1, V1, 4
9D01F104  A38381B9   SB V1, -32327(GP)
505:                 		if (K_C6==0)	key = 5 + (key_state*10);
9D01F108  3C03BF88   LUI V1, -16504
9D01F10C  8C636120   LW V1, 24864(V1)
9D01F110  30630040   ANDI V1, V1, 64
9D01F114  14600007   BNE V1, ZERO, 0x9D01F134
9D01F118  3C03BF88   LUI V1, -16504
9D01F11C  00021840   SLL V1, V0, 1
9D01F120  00032080   SLL A0, V1, 2
9D01F124  00641821   ADDU V1, V1, A0
9D01F128  24630005   ADDIU V1, V1, 5
9D01F12C  A38381B9   SB V1, -32327(GP)
506:                 		if (K_C7==0)	key = 6 + (key_state*10);
9D01F130  3C03BF88   LUI V1, -16504
9D01F134  8C636120   LW V1, 24864(V1)
9D01F138  30630020   ANDI V1, V1, 32
9D01F13C  14600007   BNE V1, ZERO, 0x9D01F15C
9D01F140  3C03BF88   LUI V1, -16504
9D01F144  00021840   SLL V1, V0, 1
9D01F148  00032080   SLL A0, V1, 2
9D01F14C  00641821   ADDU V1, V1, A0
9D01F150  24630006   ADDIU V1, V1, 6
9D01F154  A38381B9   SB V1, -32327(GP)
507:                 		if (K_C8==0)	key = 7 + (key_state*10);
9D01F158  3C03BF88   LUI V1, -16504
9D01F15C  8C636120   LW V1, 24864(V1)
9D01F160  30630010   ANDI V1, V1, 16
9D01F164  14600007   BNE V1, ZERO, 0x9D01F184
9D01F168  3C03BF88   LUI V1, -16504
9D01F16C  00021840   SLL V1, V0, 1
9D01F170  00032080   SLL A0, V1, 2
9D01F174  00641821   ADDU V1, V1, A0
9D01F178  24630007   ADDIU V1, V1, 7
9D01F17C  A38381B9   SB V1, -32327(GP)
508:                 		if (K_C9==0)	key = 8 + (key_state*10);
9D01F180  3C03BF88   LUI V1, -16504
9D01F184  8C636120   LW V1, 24864(V1)
9D01F188  30630008   ANDI V1, V1, 8
9D01F18C  14600007   BNE V1, ZERO, 0x9D01F1AC
9D01F190  3C03BF88   LUI V1, -16504
9D01F194  00021840   SLL V1, V0, 1
9D01F198  00032080   SLL A0, V1, 2
9D01F19C  00641821   ADDU V1, V1, A0
9D01F1A0  24630008   ADDIU V1, V1, 8
9D01F1A4  A38381B9   SB V1, -32327(GP)
509:                 		if (K_C10==0)	key = 9 + (key_state*10);
9D01F1A8  3C03BF88   LUI V1, -16504
9D01F1AC  8C636120   LW V1, 24864(V1)
9D01F1B0  30630004   ANDI V1, V1, 4
9D01F1B4  14600007   BNE V1, ZERO, 0x9D01F1D4
9D01F1B8  938481B9   LBU A0, -32327(GP)
9D01F1BC  00021840   SLL V1, V0, 1
9D01F1C0  00032080   SLL A0, V1, 2
9D01F1C4  00641821   ADDU V1, V1, A0
9D01F1C8  24630009   ADDIU V1, V1, 9
9D01F1CC  A38381B9   SB V1, -32327(GP)
510:                 		rnd_var1 = rnd_var1  + key;
9D01F1D0  938481B9   LBU A0, -32327(GP)
9D01F1D4  978381BC   LHU V1, -32324(GP)
9D01F1D8  00831821   ADDU V1, A0, V1
9D01F1DC  A78381BC   SH V1, -32324(GP)
511:                 		key_state++;
9D01F1E0  24420001   ADDIU V0, V0, 1
9D01F1E4  A3828179   SB V0, -32391(GP)
512:                 		}
513:                 	return retval;
514:                 	}
9D01F1EC  8FBF0014   LW RA, 20(SP)
9D01F1F0  03E00008   JR RA
9D01F1F4  27BD0018   ADDIU SP, SP, 24
515:                 
516:                 
517:                 
518:                 void wait_ms (uint32_t count)
519:                 	{
9D01F1F8  27BDFFE8   ADDIU SP, SP, -24
9D01F1FC  AFBF0014   SW RA, 20(SP)
9D01F200  AFB00010   SW S0, 16(SP)
520:                 	uint32_t ticks_wait;
521:                 	ticks_wait = millis() + count;
9D01F204  0F406E42   JAL millis
9D01F208  00808021   ADDU S0, A0, ZERO
9D01F20C  00508021   ADDU S0, V0, S0
522:                 	rnd_var2 = rnd_var2  + ticks_wait;
9D01F210  978281B6   LHU V0, -32330(GP)
9D01F214  02021021   ADDU V0, S0, V0
9D01F218  A78281B6   SH V0, -32330(GP)
523:                 	while (millis()<= ticks_wait);
9D01F21C  0F406E42   JAL millis
9D01F220  00000000   NOP
9D01F224  0202102B   SLTU V0, S0, V0
9D01F228  1040FFFC   BEQ V0, ZERO, 0x9D01F21C
9D01F22C  8FBF0014   LW RA, 20(SP)
524:                 	}
9D01F230  8FB00010   LW S0, 16(SP)
9D01F234  03E00008   JR RA
9D01F238  27BD0018   ADDIU SP, SP, 24
525:                 
526:                 unsigned char	SPI_dat (uint8_t data)
527:                 	{
528:                 	SPI1BUF = data;
9D01F2E8  3C02BF80   LUI V0, -16512
9D01F2EC  AC445820   SW A0, 22560(V0)
529:                 	while (SPI1STATbits.SPIRBF==0);
9D01F2F0  3C03BF80   LUI V1, -16512
9D01F2F4  8C625810   LW V0, 22544(V1)
9D01F2F8  30420001   ANDI V0, V0, 1
9D01F2FC  1040FFFD   BEQ V0, ZERO, 0x9D01F2F4
9D01F300  3C02BF80   LUI V0, -16512
530:                 	return (SPI1BUF);
9D01F304  8C425820   LW V0, 22560(V0)
531:                 	}
9D01F308  03E00008   JR RA
9D01F30C  304200FF   ANDI V0, V0, 255
532:                 
533:                 
534:                 uint16_t get_rnd (void)
535:                 	{
536:                 	uint32_t  var;
537:                 	static uint32_t  var_prev;
538:                 	var = rnd_var1 + rnd_var2 + rnd_var3 + (var_prev*1103515245) + 12345;
9D01F310  3C0341C6   LUI V1, 16838
9D01F314  24634E6D   ADDIU V1, V1, 20077
9D01F318  8F828174   LW V0, -32396(GP)
9D01F31C  70431802   MUL V1, V0, V1
9D01F320  24633039   ADDIU V1, V1, 12345
9D01F324  978481BC   LHU A0, -32324(GP)
9D01F328  978281B6   LHU V0, -32330(GP)
9D01F32C  00821021   ADDU V0, A0, V0
9D01F330  978481BA   LHU A0, -32326(GP)
9D01F334  00441021   ADDU V0, V0, A0
9D01F338  00621021   ADDU V0, V1, V0
539:                 	var = var & 0xFFFF;
9D01F33C  3042FFFF   ANDI V0, V0, -1
540:                 	var_prev = var;
541:                 	return var;
542:                 	}
9D01F340  03E00008   JR RA
9D01F344  AF828174   SW V0, -32396(GP)
543:                 
544:                 void __ISR(_TIMER_2_VECTOR, IPL6AUTO) Timer2Handler(void)
545:                 //void __ISR(_TIMER_2_VECTOR, ipl6) Timer2Handler(void)
546:                 	{
9D01F348  415DE800   RDPGPR SP, SP
9D01F34C  401B7000   MFC0 K1, EPC
9D01F350  401A6002   MFC0 K0, SRSCtl
9D01F354  27BDFFE0   ADDIU SP, SP, -32
9D01F358  AFBB001C   SW K1, 28(SP)
9D01F35C  401B6000   MFC0 K1, Status
9D01F360  AFBA0014   SW K0, 20(SP)
9D01F364  AFBB0018   SW K1, 24(SP)
9D01F368  7C1B7844   INS K1, ZERO, 1, 15
9D01F36C  377B1800   ORI K1, K1, 6144
9D01F370  409B6000   MTC0 K1, Status
9D01F374  AFA30008   SW V1, 8(SP)
9D01F378  AFA20004   SW V0, 4(SP)
9D01F37C  AFA4000C   SW A0, 12(SP)
547:                     IFS0bits.T2IF = 0;
9D01F380  3C02BF88   LUI V0, -16504
9D01F384  8C431030   LW V1, 4144(V0)
9D01F388  7C034A44   INS V1, ZERO, 9, 1
9D01F38C  AC431030   SW V1, 4144(V0)
548:                 	GEN_0_PIN = ~ GEN_0_PIN;
9D01F390  3C02BF88   LUI V0, -16504
9D01F394  8C446330   LW A0, 25392(V0)
9D01F398  7C840040   EXT A0, A0, 1, 1
9D01F39C  38840001   XORI A0, A0, 1
9D01F3A0  94436330   LHU V1, 25392(V0)
9D01F3A4  7C830844   INS V1, A0, 1, 1
9D01F3A8  A4436330   SH V1, 25392(V0)
549:                 	rnd_var3++;
9D01F3AC  978281BA   LHU V0, -32326(GP)
9D01F3B0  24420001   ADDIU V0, V0, 1
9D01F3B4  A78281BA   SH V0, -32326(GP)
550:                 	}
9D01F3B8  8FA20014   LW V0, 20(SP)
9D01F3BC  3042000F   ANDI V0, V0, 15
9D01F3C0  14400004   BNE V0, ZERO, 0x9D01F3D4
9D01F3C4  00000000   NOP
9D01F3C8  8FA4000C   LW A0, 12(SP)
9D01F3CC  8FA30008   LW V1, 8(SP)
9D01F3D0  8FA20004   LW V0, 4(SP)
9D01F3D4  41606000   DI ZERO
9D01F3D8  000000C0   EHB
9D01F3DC  8FBA001C   LW K0, 28(SP)
9D01F3E0  8FBB0018   LW K1, 24(SP)
9D01F3E4  409A7000   MTC0 K0, EPC
9D01F3E8  8FBA0014   LW K0, 20(SP)
9D01F3EC  27BD0020   ADDIU SP, SP, 32
9D01F3F0  409A6002   MTC0 K0, SRSCtl
9D01F3F4  41DDE800   WRPGPR SP, SP
9D01F3F8  409B6000   MTC0 K1, Status
9D01F3FC  42000018   ERET
551:                 void __ISR(_TIMER_3_VECTOR, IPL6AUTO) Timer3Handler(void)
552:                 //void __ISR(_TIMER_3_VECTOR, ipl6) Timer3Handler(void)
553:                 	{
9D01F400  415DE800   RDPGPR SP, SP
9D01F404  401B7000   MFC0 K1, EPC
9D01F408  401A6002   MFC0 K0, SRSCtl
9D01F40C  27BDFFE0   ADDIU SP, SP, -32
9D01F410  AFBB001C   SW K1, 28(SP)
9D01F414  401B6000   MFC0 K1, Status
9D01F418  AFBA0014   SW K0, 20(SP)
9D01F41C  AFBB0018   SW K1, 24(SP)
9D01F420  7C1B7844   INS K1, ZERO, 1, 15
9D01F424  377B1800   ORI K1, K1, 6144
9D01F428  409B6000   MTC0 K1, Status
9D01F42C  AFA30008   SW V1, 8(SP)
9D01F430  AFA20004   SW V0, 4(SP)
9D01F434  AFA4000C   SW A0, 12(SP)
554:                     IFS0bits.T3IF = 0;
9D01F438  3C02BF88   LUI V0, -16504
9D01F43C  8C431030   LW V1, 4144(V0)
9D01F440  7C037384   INS V1, ZERO, 14, 1
9D01F444  AC431030   SW V1, 4144(V0)
555:                 	GEN_1_PIN = ~ GEN_1_PIN;
9D01F448  3C02BF88   LUI V0, -16504
9D01F44C  8C446330   LW A0, 25392(V0)
9D01F450  7C840080   EXT A0, A0, 2, 1
9D01F454  38840001   XORI A0, A0, 1
9D01F458  94436330   LHU V1, 25392(V0)
9D01F45C  7C831084   INS V1, A0, 2, 1
9D01F460  A4436330   SH V1, 25392(V0)
556:                 	rnd_var3++;
9D01F464  978281BA   LHU V0, -32326(GP)
9D01F468  24420001   ADDIU V0, V0, 1
9D01F46C  A78281BA   SH V0, -32326(GP)
557:                 	}
9D01F470  8FA20014   LW V0, 20(SP)
9D01F474  3042000F   ANDI V0, V0, 15
9D01F478  14400004   BNE V0, ZERO, 0x9D01F48C
9D01F47C  00000000   NOP
9D01F480  8FA4000C   LW A0, 12(SP)
9D01F484  8FA30008   LW V1, 8(SP)
9D01F488  8FA20004   LW V0, 4(SP)
9D01F48C  41606000   DI ZERO
9D01F490  000000C0   EHB
9D01F494  8FBA001C   LW K0, 28(SP)
9D01F498  8FBB0018   LW K1, 24(SP)
9D01F49C  409A7000   MTC0 K0, EPC
9D01F4A0  8FBA0014   LW K0, 20(SP)
9D01F4A4  27BD0020   ADDIU SP, SP, 32
9D01F4A8  409A6002   MTC0 K0, SRSCtl
9D01F4AC  41DDE800   WRPGPR SP, SP
9D01F4B0  409B6000   MTC0 K1, Status
9D01F4B4  42000018   ERET
558:                 void __ISR(_TIMER_4_VECTOR, IPL6AUTO) Timer4Handler(void)
559:                 //void __ISR(_TIMER_4_VECTOR, ipl6) Timer4Handler(void)
560:                 	{
9D01F4B8  415DE800   RDPGPR SP, SP
9D01F4BC  401B7000   MFC0 K1, EPC
9D01F4C0  401A6002   MFC0 K0, SRSCtl
9D01F4C4  27BDFFE0   ADDIU SP, SP, -32
9D01F4C8  AFBB001C   SW K1, 28(SP)
9D01F4CC  401B6000   MFC0 K1, Status
9D01F4D0  AFBA0014   SW K0, 20(SP)
9D01F4D4  AFBB0018   SW K1, 24(SP)
9D01F4D8  7C1B7844   INS K1, ZERO, 1, 15
9D01F4DC  377B1800   ORI K1, K1, 6144
9D01F4E0  409B6000   MTC0 K1, Status
9D01F4E4  AFA30008   SW V1, 8(SP)
9D01F4E8  AFA20004   SW V0, 4(SP)
9D01F4EC  AFA4000C   SW A0, 12(SP)
561:                     IFS0bits.T4IF = 0;
9D01F4F0  3C02BF88   LUI V0, -16504
9D01F4F4  8C431030   LW V1, 4144(V0)
9D01F4F8  7C039CC4   INS V1, ZERO, 19, 1
9D01F4FC  AC431030   SW V1, 4144(V0)
562:                 	GEN_2_PIN = ~ GEN_2_PIN;
9D01F500  3C02BF88   LUI V0, -16504
9D01F504  8C446330   LW A0, 25392(V0)
9D01F508  7C8400C0   EXT A0, A0, 3, 1
9D01F50C  38840001   XORI A0, A0, 1
9D01F510  94436330   LHU V1, 25392(V0)
9D01F514  7C8318C4   INS V1, A0, 3, 1
9D01F518  A4436330   SH V1, 25392(V0)
563:                 	rnd_var3++;
9D01F51C  978281BA   LHU V0, -32326(GP)
9D01F520  24420001   ADDIU V0, V0, 1
9D01F524  A78281BA   SH V0, -32326(GP)
564:                 	}
9D01F528  8FA20014   LW V0, 20(SP)
9D01F52C  3042000F   ANDI V0, V0, 15
9D01F530  14400004   BNE V0, ZERO, 0x9D01F544
9D01F534  00000000   NOP
9D01F538  8FA4000C   LW A0, 12(SP)
9D01F53C  8FA30008   LW V1, 8(SP)
9D01F540  8FA20004   LW V0, 4(SP)
9D01F544  41606000   DI ZERO
9D01F548  000000C0   EHB
9D01F54C  8FBA001C   LW K0, 28(SP)
9D01F550  8FBB0018   LW K1, 24(SP)
9D01F554  409A7000   MTC0 K0, EPC
9D01F558  8FBA0014   LW K0, 20(SP)
9D01F55C  27BD0020   ADDIU SP, SP, 32
9D01F560  409A6002   MTC0 K0, SRSCtl
9D01F564  41DDE800   WRPGPR SP, SP
9D01F568  409B6000   MTC0 K1, Status
9D01F56C  42000018   ERET
565:                 
566:                 void exp_set(uint8_t pos, uint8_t val)
567:                 	{
568:                 	if (pos==0) EXP_0_OUT = val;
9D01F570  54800007   BNEL A0, ZERO, 0x9D01F590
9D01F574  24020001   ADDIU V0, ZERO, 1
9D01F578  3C02BF88   LUI V0, -16504
9D01F57C  94436630   LHU V1, 26160(V0)
9D01F580  7CA31084   INS V1, A1, 2, 1
9D01F584  A4436630   SH V1, 26160(V0)
569:                 	if (pos==1) EXP_1_OUT = val;
9D01F590  14820006   BNE A0, V0, 0x9D01F5AC
9D01F594  3C02BF88   LUI V0, -16504
9D01F598  94436630   LHU V1, 26160(V0)
9D01F59C  7CA318C4   INS V1, A1, 3, 1
9D01F5A0  A4436630   SH V1, 26160(V0)
9D01F5A4  03E00008   JR RA
9D01F5A8  00000000   NOP
570:                 	if (pos==2) EXP_2_OUT = val;
9D01F5AC  24020002   ADDIU V0, ZERO, 2
9D01F5B0  14820006   BNE A0, V0, 0x9D01F5CC
9D01F5B4  3C02BF88   LUI V0, -16504
9D01F5B8  94436130   LHU V1, 24880(V0)
9D01F5BC  7CA30004   INS V1, A1, 0, 1
9D01F5C0  A4436130   SH V1, 24880(V0)
9D01F5C4  03E00008   JR RA
9D01F5C8  00000000   NOP
571:                 	if (pos==3) EXP_3_OUT = val;
9D01F588  0B407D74   J 0x9D01F5D0
9D01F58C  24020003   ADDIU V0, ZERO, 3
9D01F5CC  24020003   ADDIU V0, ZERO, 3
9D01F5D0  14820005   BNE A0, V0, 0x9D01F5E8
9D01F5D4  00000000   NOP
9D01F5D8  3C02BF88   LUI V0, -16504
9D01F5DC  94436130   LHU V1, 24880(V0)
9D01F5E0  7CA30844   INS V1, A1, 1, 1
9D01F5E4  A4436130   SH V1, 24880(V0)
9D01F5E8  03E00008   JR RA
9D01F5EC  00000000   NOP
572:                 	}
573:                 
574:                 void exp_ddr(uint8_t pos, uint8_t val)
575:                 	{
576:                 	if (pos==0) EXP_0_T = val;
9D01F5F0  54800007   BNEL A0, ZERO, 0x9D01F610
9D01F5F4  24020001   ADDIU V0, ZERO, 1
9D01F5F8  3C02BF88   LUI V0, -16504
9D01F5FC  94436610   LHU V1, 26128(V0)
9D01F600  7CA31084   INS V1, A1, 2, 1
9D01F604  A4436610   SH V1, 26128(V0)
577:                 	if (pos==1) EXP_1_T = val;
9D01F610  14820006   BNE A0, V0, 0x9D01F62C
9D01F614  3C02BF88   LUI V0, -16504
9D01F618  94436610   LHU V1, 26128(V0)
9D01F61C  7CA318C4   INS V1, A1, 3, 1
9D01F620  A4436610   SH V1, 26128(V0)
9D01F624  03E00008   JR RA
9D01F628  00000000   NOP
578:                 	if (pos==2) EXP_2_T = val;
9D01F62C  24020002   ADDIU V0, ZERO, 2
9D01F630  14820006   BNE A0, V0, 0x9D01F64C
9D01F634  3C02BF88   LUI V0, -16504
9D01F638  94436110   LHU V1, 24848(V0)
9D01F63C  7CA30004   INS V1, A1, 0, 1
9D01F640  A4436110   SH V1, 24848(V0)
9D01F644  03E00008   JR RA
9D01F648  00000000   NOP
579:                 	if (pos==3) EXP_3_T = val;
9D01F608  0B407D94   J 0x9D01F650
9D01F60C  24020003   ADDIU V0, ZERO, 3
9D01F64C  24020003   ADDIU V0, ZERO, 3
9D01F650  14820005   BNE A0, V0, 0x9D01F668
9D01F654  00000000   NOP
9D01F658  3C02BF88   LUI V0, -16504
9D01F65C  94436110   LHU V1, 24848(V0)
9D01F660  7CA30844   INS V1, A1, 1, 1
9D01F664  A4436110   SH V1, 24848(V0)
9D01F668  03E00008   JR RA
9D01F66C  00000000   NOP
580:                 	}
581:                 
582:                 uint8_t exp_get (uint8_t pos)
583:                 	{
584:                 	if (pos==0) return EXP_0_IN;
9D01F670  54800005   BNEL A0, ZERO, 0x9D01F688
9D01F674  24020001   ADDIU V0, ZERO, 1
9D01F678  3C02BF88   LUI V0, -16504
9D01F67C  8C426620   LW V0, 26144(V0)
9D01F680  03E00008   JR RA
9D01F684  7C420080   EXT V0, V0, 2, 1
585:                 	if (pos==1) return EXP_1_IN;
9D01F688  54820005   BNEL A0, V0, 0x9D01F6A0
9D01F68C  24020002   ADDIU V0, ZERO, 2
9D01F690  3C02BF88   LUI V0, -16504
9D01F694  8C426620   LW V0, 26144(V0)
9D01F698  03E00008   JR RA
9D01F69C  7C4200C0   EXT V0, V0, 3, 1
586:                 	if (pos==2) return EXP_2_IN;
9D01F6A0  14820005   BNE A0, V0, 0x9D01F6B8
9D01F6A4  24030003   ADDIU V1, ZERO, 3
9D01F6A8  3C02BF88   LUI V0, -16504
9D01F6AC  8C426120   LW V0, 24864(V0)
9D01F6B0  03E00008   JR RA
9D01F6B4  30420001   ANDI V0, V0, 1
587:                 	if (pos==3) return EXP_3_IN;
9D01F6B8  14830004   BNE A0, V1, 0x9D01F6CC
9D01F6BC  00001021   ADDU V0, ZERO, ZERO
9D01F6C0  3C02BF88   LUI V0, -16504
9D01F6C4  8C426120   LW V0, 24864(V0)
9D01F6C8  7C420040   EXT V0, V0, 1, 1
588:                 	return 0;
589:                 	}
9D01F6CC  03E00008   JR RA
9D01F6D0  00000000   NOP
590:                 
591:                 void serial_flush (void)
592:                 	{
9D01F6EC  27BDFFE8   ADDIU SP, SP, -24
9D01F6F0  AFBF0014   SW RA, 20(SP)
9D01F6F4  AFB00010   SW S0, 16(SP)
593:                 	while (rx_sta()) rx_read();
9D01F6F8  0B407DC1   J .LBE95, .LBE94
9D01F6FC  3C10BF80   LUI S0, -16512
9D01F704  0F407DB5   JAL rx_sta
9D01F708  00000000   NOP
9D01F70C  1440FFFC   BNE V0, ZERO, .LBB94, .LBB95
9D01F710  3C02BF80   LUI V0, -16512
594:                 	if (U3STAbits.OERR) U3STAbits.OERR = 0;
9D01F714  8C426410   LW V0, 25616(V0)
9D01F718  30420002   ANDI V0, V0, 2
9D01F71C  50400008   BEQL V0, ZERO, .LBE97, .LBE96
9D01F720  3C10BF80   LUI S0, -16512
9D01F724  3C02BF80   LUI V0, -16512
9D01F728  8C436410   LW V1, 25616(V0)
9D01F72C  7C030844   INS V1, ZERO, 1, 1
9D01F730  AC436410   SW V1, 25616(V0)
595:                 	while (rx_sta()) rx_read();
9D01F740  0F407DB5   JAL rx_sta
9D01F744  00000000   NOP
9D01F748  1440FFFC   BNE V0, ZERO, .LBB96, .LBB97
9D01F74C  8FBF0014   LW RA, 20(SP)
596:                 	}
9D01F750  8FB00010   LW S0, 16(SP)
9D01F754  03E00008   JR RA
9D01F758  27BD0018   ADDIU SP, SP, 24
597:                 
598:                 uint8_t rx_sta (void)
599:                 	{
600:                 	if (U3STAbits.URXDA==1) return 0xFF;
9D01F6D4  3C02BF80   LUI V0, -16512
9D01F6D8  8C426410   LW V0, 25616(V0)
9D01F6DC  30420001   ANDI V0, V0, 1
9D01F6E0  00021023   SUBU V0, ZERO, V0
601:                 	else return 0x00;
602:                 	}
9D01F6E4  03E00008   JR RA
9D01F6E8  304200FF   ANDI V0, V0, 255
603:                 
604:                 uint8_t rx_read (void)
605:                 	{
606:                 	uint8_t data;
607:                 	data = U3RXREG;
9D01F700  8E026430   LW V0, 25648(S0)
9D01F734  0B407DD0   J .LBE97, .LBE96
9D01F738  3C10BF80   LUI S0, -16512
9D01F73C  8E026430   LW V0, 25648(S0)
9D01F75C  3C02BF80   LUI V0, -16512
9D01F760  8C426430   LW V0, 25648(V0)
608:                 	return data;
609:                 	}
9D01F764  03E00008   JR RA
9D01F768  304200FF   ANDI V0, V0, 255
610:                 void tx_write (uint8_t data)
611:                 	{   
612:                 	U3TXREG = data;
9D01F76C  3C02BF80   LUI V0, -16512
9D01F770  AC446420   SW A0, 25632(V0)
613:                 	while (U3STAbits.UTXBF==1); 
9D01F774  3C03BF80   LUI V1, -16512
9D01F778  8C626410   LW V0, 25616(V1)
9D01F77C  30420200   ANDI V0, V0, 512
9D01F780  1440FFFD   BNE V0, ZERO, 0x9D01F778
9D01F784  00000000   NOP
614:                 	}
9D01F788  03E00008   JR RA
9D01F78C  00000000   NOP
615:                 
---  /Users/nitro/basic-badge/firmware/badge1.X/src/disp.c  ---------------------------------------------
1:                   #include <xc.h>
2:                   #include "hw.h"
3:                   #include "disp.h"
4:                   #include "vt100.h"
5:                   #include <stdint.h>
6:                   
7:                   
8:                   const int8_t font[(96+128)*12] = 
9:                   {
10:                  0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000,   
11:                  0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0000000, 0b0001000, 0b0000000, 0b0000000,   
12:                  0b0101000, 0b0101000, 0b0101000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000,   
13:                  0b0010100, 0b0010100, 0b0010100, 0b1111111, 0b0010100, 0b0010100, 0b1111111, 0b0010100, 0b0010100, 0b0010100, 0b0000000, 0b0000000,   
14:                  0b0010100, 0b0111110, 0b1010101, 0b1010100, 0b0111110, 0b0010101, 0b0010101, 0b1010101, 0b0111110, 0b0010100, 0b0000000, 0b0000000,   
15:                  0b0000000, 0b1110000, 0b1010001, 0b1110010, 0b0000100, 0b0001000, 0b0010000, 0b0100111, 0b1000101, 0b0000111, 0b0000000, 0b0000000,   
16:                  0b0111000, 0b1000100, 0b1000100, 0b1001000, 0b0110000, 0b0110000, 0b1001000, 0b1000101, 0b1000010, 0b0111101, 0b0000000, 0b0000000,   
17:                  0b0011000, 0b0011000, 0b0010000, 0b0100000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000,   
18:                  0b0000010, 0b0000100, 0b0001000, 0b0010000, 0b0010000, 0b0010000, 0b0010000, 0b0001000, 0b0000100, 0b0000010, 0b0000000, 0b0000000,   
19:                  0b0100000, 0b0010000, 0b0001000, 0b0000100, 0b0000100, 0b0000100, 0b0000100, 0b0001000, 0b0010000, 0b0100000, 0b0000000, 0b0000000,   
20:                  0b0000000, 0b0001000, 0b1001001, 0b0101010, 0b0011100, 0b1111111, 0b0011100, 0b0101010, 0b1001001, 0b0001000, 0b0000000, 0b0000000,   
21:                  0b0000000, 0b0000000, 0b0001000, 0b0001000, 0b0001000, 0b1111111, 0b0001000, 0b0001000, 0b0001000, 0b0000000, 0b0000000, 0b0000000,   
22:                  0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0011000, 0b0011000, 0b0010000, 0b0100000, 0b0000000, 0b0000000,   
23:                  0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b1111111, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000,   
24:                  0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0110000, 0b0110000, 0b0000000, 0b0000000,   
25:                  0b0000000, 0b0000000, 0b0000001, 0b0000010, 0b0000100, 0b0001000, 0b0010000, 0b0100000, 0b1000000, 0b0000000, 0b0000000, 0b0000000,   
26:                  0b0011100, 0b0100010, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b0100010, 0b0011100, 0b0000000, 0b0000000,   
27:                  0b0001000, 0b0011000, 0b0101000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0111110, 0b0000000, 0b0000000,   
28:                  0b0111110, 0b1000001, 0b1000001, 0b0000001, 0b0000010, 0b0000100, 0b0001000, 0b0010000, 0b0100000, 0b1111111, 0b0000000, 0b0000000,   
29:                  0b0111110, 0b1000001, 0b0000001, 0b0000010, 0b0001100, 0b0000010, 0b0000001, 0b0000001, 0b1000001, 0b0111110, 0b0000000, 0b0000000,   
30:                  0b0000010, 0b0000110, 0b0001010, 0b0010010, 0b0100010, 0b1000010, 0b1000010, 0b1111111, 0b0000010, 0b0000010, 0b0000000, 0b0000000,   
31:                  0b1111111, 0b1000000, 0b1000000, 0b1111100, 0b0000010, 0b0000001, 0b0000001, 0b0000001, 0b1000010, 0b0111100, 0b0000000, 0b0000000,   
32:                  0b0001110, 0b0010000, 0b0100000, 0b1000000, 0b1111110, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b0111110, 0b0000000, 0b0000000,   
33:                  0b1111111, 0b0000001, 0b0000001, 0b0000010, 0b0000100, 0b0001000, 0b0010000, 0b0100000, 0b0100000, 0b0100000, 0b0000000, 0b0000000,   
34:                  0b0111110, 0b1000001, 0b1000001, 0b0100010, 0b0011100, 0b0100010, 0b1000001, 0b1000001, 0b1000001, 0b0111110, 0b0000000, 0b0000000,   
35:                  0b0111110, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b0111111, 0b0000001, 0b0000010, 0b0000100, 0b0111000, 0b0000000, 0b0000000,   
36:                  0b0000000, 0b0011000, 0b0011000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0011000, 0b0011000, 0b0000000, 0b0000000, 0b0000000,   
37:                  0b0000000, 0b0011000, 0b0011000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0011000, 0b0011000, 0b0010000, 0b0000000, 0b0000000,   
38:                  0b0000000, 0b0000010, 0b0000100, 0b0001000, 0b0010000, 0b0100000, 0b0010000, 0b0001000, 0b0000100, 0b0000010, 0b0000000, 0b0000000,   
39:                  0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b1111111, 0b0000000, 0b1111111, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000,   
40:                  0b0000000, 0b0100000, 0b0010000, 0b0001000, 0b0000100, 0b0000010, 0b0000100, 0b0001000, 0b0010000, 0b0100000, 0b0000000, 0b0000000,   
41:                  0b0111110, 0b1000001, 0b0000001, 0b0000010, 0b0000100, 0b0001000, 0b0010000, 0b0010000, 0b0000000, 0b0010000, 0b0000000, 0b0000000,   
42:                  0b0011100, 0b0100010, 0b1000001, 0b1001001, 0b1010101, 0b1010110, 0b1001000, 0b1000000, 0b0100001, 0b0011110, 0b0000000, 0b0000000,   
43:                  0b0001000, 0b0010100, 0b0100010, 0b1000001, 0b1000001, 0b1000001, 0b1111111, 0b1000001, 0b1000001, 0b1000001, 0b0000000, 0b0000000,   
44:                  0b1111110, 0b1000001, 0b1000001, 0b1000010, 0b1111100, 0b1000010, 0b1000001, 0b1000001, 0b1000001, 0b1111110, 0b0000000, 0b0000000,   
45:                  0b0111110, 0b1000001, 0b1000000, 0b1000000, 0b1000000, 0b1000000, 0b1000000, 0b1000000, 0b1000001, 0b0111110, 0b0000000, 0b0000000,   
46:                  0b1111100, 0b1000010, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000010, 0b1111100, 0b0000000, 0b0000000,  
47:                  0b1111111, 0b1000000, 0b1000000, 0b1000000, 0b1000000, 0b1111110, 0b1000000, 0b1000000, 0b1000000, 0b1111111, 0b0000000, 0b0000000,   
48:                  0b1111111, 0b1000000, 0b1000000, 0b1000000, 0b1000000, 0b1111110, 0b1000000, 0b1000000, 0b1000000, 0b1000000, 0b0000000, 0b0000000,   
49:                  0b0111110, 0b1000001, 0b1000000, 0b1000000, 0b1000000, 0b1001111, 0b1000001, 0b1000001, 0b1000001, 0b0111110, 0b0000000, 0b0000000,   
50:                  0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1111111, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b0000000, 0b0000000,   
51:                  0b0011100, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0011100, 0b0000000, 0b0000000,   
52:                  0b0000001, 0b0000001, 0b0000001, 0b0000001, 0b0000001, 0b0000001, 0b1000001, 0b1000001, 0b0100010, 0b0011100, 0b0000000, 0b0000000,   
53:                  0b1000001, 0b1000010, 0b1000100, 0b1001000, 0b1110000, 0b1010000, 0b1001000, 0b1000100, 0b1000010, 0b1000001, 0b0000000, 0b0000000,   
54:                  0b1000000, 0b1000000, 0b1000000, 0b1000000, 0b1000000, 0b1000000, 0b1000000, 0b1000000, 0b1000000, 0b1111111, 0b0000000, 0b0000000,   
55:                  0b1000001, 0b1100011, 0b1010101, 0b1001001, 0b1001001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b0000000, 0b0000000,   
56:                  0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1100001, 0b1010001, 0b1001001, 0b1000101, 0b1000011, 0b1000001, 0b0000000, 0b0000000,   
57:                  0b0111110, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b0111110, 0b0000000, 0b0000000,   
58:                  0b1111110, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1111110, 0b1000000, 0b1000000, 0b1000000, 0b1000000, 0b0000000, 0b0000000,   
59:                  0b0111110, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000101, 0b1000010, 0b0111101, 0b0000000, 0b0000000,   
60:                  0b1111110, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1111110, 0b1001000, 0b1000100, 0b1000010, 0b1000001, 0b0000000, 0b0000000,   
61:                  0b0111110, 0b1000001, 0b1000000, 0b0100000, 0b0011100, 0b0000010, 0b0000001, 0b0000001, 0b1000001, 0b0111110, 0b0000000, 0b0000000,   
62:                  0b1111111, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0000000, 0b0000000,   
63:                  0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b0111110, 0b0000000, 0b0000000,   
64:                  0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b0100010, 0b0010100, 0b0001000, 0b0000000, 0b0000000,   
65:                  0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1001001, 0b1010101, 0b1100011, 0b1000001, 0b0000000, 0b0000000,   
66:                  0b1000001, 0b1000001, 0b1000001, 0b0100010, 0b0010100, 0b0001000, 0b0010100, 0b0100010, 0b1000001, 0b1000001, 0b0000000, 0b0000000,   
67:                  0b1000001, 0b1000001, 0b1000001, 0b0100010, 0b0010100, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0000000, 0b0000000,   
68:                  0b1111111, 0b0000001, 0b0000001, 0b0000010, 0b0000100, 0b0001000, 0b0010000, 0b0100000, 0b1000000, 0b1111111, 0b0000000, 0b0000000,   
69:                  0b0011100, 0b0010000, 0b0010000, 0b0010000, 0b0010000, 0b0010000, 0b0010000, 0b0010000, 0b0010000, 0b0011100, 0b0000000, 0b0000000,   
70:                  0b0000000, 0b0000000, 0b1000000, 0b0100000, 0b0010000, 0b0001000, 0b0000100, 0b0000010, 0b0000001, 0b0000000, 0b0000000, 0b0000000,   
71:                  0b0011100, 0b0000100, 0b0000100, 0b0000100, 0b0000100, 0b0000100, 0b0000100, 0b0000100, 0b0000100, 0b0011100, 0b0000000, 0b0000000,   
72:                  0b0001000, 0b0010100, 0b0100010, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000,   
73:                  0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b1111111, 0b0000000, 0b0000000,   
74:                  0b0010000, 0b0001000, 0b0000100, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000,   
75:                  0b0000000, 0b0000000, 0b0000000, 0b0111100, 0b0000010, 0b0000001, 0b0111111, 0b1000001, 0b1000011, 0b0111101, 0b0000000, 0b0000000,   
76:                  0b1000000, 0b1000000, 0b1000000, 0b1111100, 0b1000010, 0b1000001, 0b1000001, 0b1000001, 0b1000010, 0b1111100, 0b0000000, 0b0000000,   
77:                  0b0000000, 0b0000000, 0b0000000, 0b0011111, 0b0100000, 0b1000000, 0b1000000, 0b1000000, 0b0100000, 0b0011111, 0b0000000, 0b0000000,   
78:                  0b0000001, 0b0000001, 0b0000001, 0b0011111, 0b0100001, 0b1000001, 0b1000001, 0b1000001, 0b0100001, 0b0011111, 0b0000000, 0b0000000,   
79:                  0b0000000, 0b0000000, 0b0000000, 0b0111110, 0b1000001, 0b1000001, 0b1111111, 0b1000000, 0b1000000, 0b0111111, 0b0000000, 0b0000000,   
80:                  0b0000110, 0b0001000, 0b0001000, 0b0001000, 0b0011110, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0011100, 0b0000000, 0b0000000,   
81:                  0b0000000, 0b0000000, 0b0000000, 0b0011100, 0b0100010, 0b1000001, 0b1000001, 0b0100001, 0b0011111, 0b0000001, 0b0000001, 0b0011110,   
82:                  0b1000000, 0b1000000, 0b1000000, 0b1000000, 0b1011100, 0b1100010, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b0000000, 0b0000000,   
83:                  0b0000000, 0b0001000, 0b0000000, 0b0011000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0011100, 0b0000000, 0b0000000,   
84:                  0b0000000, 0b0000100, 0b0000000, 0b0001100, 0b0000100, 0b0000100, 0b0000100, 0b0000100, 0b0000100, 0b0000100, 0b0100100, 0b0011000,   
85:                  0b1000000, 0b1000000, 0b1000000, 0b1000011, 0b1000100, 0b1001000, 0b1011000, 0b1100100, 0b1000010, 0b1000001, 0b0000000, 0b0000000,   
86:                  0b0011000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0011100, 0b0000000, 0b0000000,   
87:                  0b0000000, 0b0000000, 0b0000000, 0b1010110, 0b1101001, 0b1001001, 0b1001001, 0b1001001, 0b1001001, 0b1001001, 0b0000000, 0b0000000,   
88:                  0b0000000, 0b0000000, 0b0000000, 0b1011100, 0b1100010, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b0000000, 0b0000000,   
89:                  0b0000000, 0b0000000, 0b0000000, 0b0011100, 0b0100010, 0b1000001, 0b1000001, 0b1000001, 0b0100010, 0b0011100, 0b0000000, 0b0000000,   
90:                  0b0000000, 0b0000000, 0b0000000, 0b1111100, 0b1000010, 0b1000001, 0b1000001, 0b1000010, 0b1111100, 0b1000000, 0b1000000, 0b1000000,   
91:                  0b0000000, 0b0000000, 0b0000000, 0b0011111, 0b0100001, 0b1000001, 0b1000001, 0b0100001, 0b0011111, 0b0000001, 0b0000001, 0b0000001,   
92:                  0b0000000, 0b0000000, 0b0000000, 0b1011110, 0b1100001, 0b1000000, 0b1000000, 0b1000000, 0b1000000, 0b1000000, 0b0000000, 0b0000000,   
93:                  0b0000000, 0b0000000, 0b0000000, 0b0111111, 0b1000000, 0b1000000, 0b0111110, 0b0000001, 0b0000001, 0b1111110, 0b0000000, 0b0000000,   
94:                  0b0010000, 0b0010000, 0b0010000, 0b0111100, 0b0010000, 0b0010000, 0b0010000, 0b0010000, 0b0010010, 0b0001100, 0b0000000, 0b0000000,   
95:                  0b0000000, 0b0000000, 0b0000000, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000011, 0b0111101, 0b0000000, 0b0000000,   
96:                  0b0000000, 0b0000000, 0b0000000, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b0100010, 0b0010100, 0b0001000, 0b0000000, 0b0000000,   
97:                  0b0000000, 0b0000000, 0b0000000, 0b1000001, 0b1000001, 0b1000001, 0b1001001, 0b1010101, 0b1100011, 0b1000001, 0b0000000, 0b0000000,   
98:                  0b0000000, 0b0000000, 0b0000000, 0b1000001, 0b0100010, 0b0010100, 0b0001000, 0b0010100, 0b0100010, 0b1000001, 0b0000000, 0b0000000,   
99:                  0b0000000, 0b0000000, 0b0000000, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b0100001, 0b0011111, 0b0000001, 0b0000010, 0b0111100,   
100:                 0b0000000, 0b0000000, 0b0000000, 0b1111111, 0b0000010, 0b0000100, 0b0001000, 0b0010000, 0b0100000, 0b1111111, 0b0000000, 0b0000000,   
101:                 0b0000110, 0b0001000, 0b0001000, 0b0001000, 0b0010000, 0b0100000, 0b0010000, 0b0001000, 0b0001000, 0b0001000, 0b0000110, 0b0000000,   
102:                 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0000000, 0b0000000,   
103:                 0b0110000, 0b0001000, 0b0001000, 0b0001000, 0b0000100, 0b0000010, 0b0000100, 0b0001000, 0b0001000, 0b0001000, 0b0110000, 0b0000000,   
104:                 0b0000000, 0b0000000, 0b0000000, 0b0110000, 0b1001000, 0b0001001, 0b0000110, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000,   
105:                 0b1111111, 0b1111111, 0b1111111, 0b1111111, 0b1111111, 0b1111111, 0b1111111, 0b1111111, 0b1111111, 0b1111111, 0b0000000, 0b0000000,
106:                 
107:                 0b0011100, 0b0100010, 0b1000001, 0b1000000, 0b1000000, 0b1000000, 0b1000000, 0b1000001, 0b0100010, 0b0011100, 0b0001000, 0b0111000, 
108:                 0b0000000, 0b0100010, 0b0000000, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000011, 0b0111101, 0b0000000, 0b0000000, 
109:                 0b0000100, 0b0001000, 0b0000000, 0b0111110, 0b1000001, 0b1000001, 0b1111111, 0b1000000, 0b1000000, 0b0111111, 0b0000000, 0b0000000, 
110:                 0b0001000, 0b0010100, 0b0000000, 0b0111100, 0b0000010, 0b0000001, 0b0111111, 0b1000001, 0b1000011, 0b0111101, 0b0000000, 0b0000000, 
111:                 0b0000000, 0b0100010, 0b0000000, 0b0111100, 0b0000010, 0b0000001, 0b0111111, 0b1000001, 0b1000011, 0b0111101, 0b0000000, 0b0000000, 
112:                 0b0010000, 0b0001000, 0b0000000, 0b0111100, 0b0000010, 0b0000001, 0b0111111, 0b1000001, 0b1000011, 0b0111101, 0b0000000, 0b0000000, 
113:                 0b0001000, 0b0010100, 0b0001000, 0b0111100, 0b0000010, 0b0000001, 0b0111111, 0b1000001, 0b1000011, 0b0111101, 0b0000000, 0b0000000, 
114:                 0b0000000, 0b0000000, 0b0000000, 0b0011111, 0b0100000, 0b1000000, 0b1000000, 0b1000000, 0b0100000, 0b0011111, 0b0000100, 0b0011100, 
115:                 0b0001000, 0b0010100, 0b0000000, 0b0111110, 0b1000001, 0b1000001, 0b1111111, 0b1000000, 0b1000000, 0b0111111, 0b0000000, 0b0000000, 
116:                 0b0000000, 0b0100010, 0b0000000, 0b0111110, 0b1000001, 0b1000001, 0b1111111, 0b1000000, 0b1000000, 0b0111111, 0b0000000, 0b0000000, 
117:                 0b0001000, 0b0000100, 0b0000000, 0b0111110, 0b1000001, 0b1000001, 0b1111111, 0b1000000, 0b1000000, 0b0111111, 0b0000000, 0b0000000, 
118:                 0b0000000, 0b0100100, 0b0000000, 0b0011000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0011100, 0b0000000, 0b0000000, 
119:                 0b0001000, 0b0010100, 0b0000000, 0b0011000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0011100, 0b0000000, 0b0000000, 
120:                 0b0001000, 0b0000100, 0b0000000, 0b0011000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0011100, 0b0000000, 0b0000000, 
121:                 0b0100010, 0b0001000, 0b0010100, 0b0100010, 0b1000001, 0b1000001, 0b1111111, 0b1000001, 0b1000001, 0b1000001, 0b0000000, 0b0000000, 
122:                 0b0001000, 0b0010100, 0b0001000, 0b0010100, 0b0100010, 0b1000001, 0b1000001, 0b1111111, 0b1000001, 0b1000001, 0b0000000, 0b0000000, 
123:                 0b0001000, 0b0010000, 0b1111111, 0b1000000, 0b1000000, 0b1000000, 0b1111110, 0b1000000, 0b1000000, 0b1111111, 0b0000000, 0b0000000, 
124:                 0b0000000, 0b0000000, 0b0000000, 0b0110110, 0b0001001, 0b0001001, 0b0111111, 0b1001000, 0b1001000, 0b0111111, 0b0000000, 0b0000000, 
125:                 0b0011111, 0b0101000, 0b1001000, 0b1001000, 0b1001111, 0b1111000, 0b1001000, 0b1001000, 0b1001000, 0b1001111, 0b0000000, 0b0000000, 
126:                 0b0001000, 0b0010100, 0b0000000, 0b0011100, 0b0100010, 0b1000001, 0b1000001, 0b1000001, 0b0100010, 0b0011100, 0b0000000, 0b0000000, 
127:                 0b0000000, 0b0100010, 0b0000000, 0b0011100, 0b0100010, 0b1000001, 0b1000001, 0b1000001, 0b0100010, 0b0011100, 0b0000000, 0b0000000, 
128:                 0b0010000, 0b0001000, 0b0000000, 0b0011100, 0b0100010, 0b1000001, 0b1000001, 0b1000001, 0b0100010, 0b0011100, 0b0000000, 0b0000000, 
129:                 0b0001000, 0b0010100, 0b0000000, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000011, 0b0111101, 0b0000000, 0b0000000, 
130:                 0b0010000, 0b0001000, 0b0000000, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000011, 0b0111101, 0b0000000, 0b0000000, 
131:                 0b0000000, 0b0100010, 0b0000000, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b0100001, 0b0011111, 0b0000001, 0b0000010, 0b0111100, 
132:                 0b0100010, 0b0000000, 0b0111110, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b0111110, 0b0000000, 0b0000000, 
133:                 0b0100010, 0b0000000, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b0111110, 0b0000000, 0b0000000, 
134:                 0b0000000, 0b0000100, 0b0000100, 0b0011111, 0b0100100, 0b1000100, 0b1000100, 0b1000100, 0b0100100, 0b0011111, 0b0000100, 0b0000100, 
135:                 0b0111100, 0b1000010, 0b1000001, 0b0100000, 0b0100000, 0b1111000, 0b0100000, 0b0100000, 0b1000000, 0b1111111, 0b0000000, 0b0000000, 
136:                 0b1000001, 0b1000001, 0b0100010, 0b0010100, 0b0001000, 0b0001000, 0b0111110, 0b0001000, 0b0111110, 0b0001000, 0b0000000, 0b0000000, 
137:                 0b1111100, 0b1000010, 0b1000001, 0b1000010, 0b1111100, 0b1000011, 0b1010010, 0b1111101, 0b1010001, 0b1011011, 0b0000000, 0b0000000, 
138:                 0b0000000, 0b0000000, 0b0000011, 0b0000100, 0b0001000, 0b0111110, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0010000, 0b1100000, 
139:                 0b0000100, 0b0001000, 0b0000000, 0b0111100, 0b0000010, 0b0000001, 0b0111111, 0b1000001, 0b1000011, 0b0111101, 0b0000000, 0b0000000, 
140:                 0b0000100, 0b0001000, 0b0000000, 0b0011000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0011100, 0b0000000, 0b0000000, 
141:                 0b0000100, 0b0001000, 0b0000000, 0b0011100, 0b0100010, 0b1000001, 0b1000001, 0b1000001, 0b0100010, 0b0011100, 0b0000000, 0b0000000, 
142:                 0b0000100, 0b0001000, 0b0000000, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000011, 0b0111101, 0b0000000, 0b0000000, 
143:                 0b0010000, 0b0101010, 0b0000100, 0b1011100, 0b1100010, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b0000000, 0b0000000, 
144:                 0b0010000, 0b0101010, 0b0000100, 0b1000001, 0b1100001, 0b1010001, 0b1001001, 0b1000101, 0b1000011, 0b1000001, 0b0000000, 0b0000000, 
145:                 0b0011100, 0b0000010, 0b0011110, 0b0100010, 0b0011110, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 
146:                 0b0011000, 0b0100100, 0b0100100, 0b0011000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 
147:                 0b0000000, 0b0001000, 0b0000000, 0b0001000, 0b0001000, 0b0010000, 0b0100000, 0b1000000, 0b1000001, 0b0100010, 0b0011100, 0b0000000, 
148:                 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b1111111, 0b1000000, 0b1000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 
149:                 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b1111111, 0b0000001, 0b0000001, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 
150:                 0b0000000, 0b0000000, 0b0100000, 0b0100001, 0b0100010, 0b0000100, 0b0001000, 0b0010111, 0b0100001, 0b1000111, 0b0000100, 0b0000111, 
151:                 0b0000000, 0b0100000, 0b0100000, 0b0100001, 0b0000010, 0b0000100, 0b0001000, 0b0010101, 0b0100101, 0b1000111, 0b0000001, 0b0000001, 
152:                 0b0000000, 0b0001000, 0b0000000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0000000, 0b0000000, 
153:                 0b0000000, 0b0000000, 0b0001001, 0b0010010, 0b0100100, 0b1001000, 0b0100100, 0b0010010, 0b0001001, 0b0000000, 0b0000000, 0b0000000, 
154:                 0b0000000, 0b0000000, 0b1001000, 0b0100100, 0b0010010, 0b0001001, 0b0010010, 0b0100100, 0b1001000, 0b0000000, 0b0000000, 0b0000000, 
155:                 0b10001000, 0b00100010, 0b10001000, 0b00100010, 0b10001000, 0b00100010, 0b10001000, 0b00100010, 0b10001000, 0b00100010, 0b10001000, 
156:                 0b00100010, 0b10101010, 0b01010101, 0b10101010, 0b01010101, 0b10101010, 0b01010101, 0b10101010, 0b01010101, 0b10101010, 0b01010101, 
157:                 0b10101010, 0b01010101, 0b01110111, 0b11011101, 0b01110111, 0b11011101, 0b01110111, 0b11011101, 0b01110111, 0b11011101, 0b01110111, 
158:                 0b11011101, 0b01110111, 0b11011101, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 
159:                 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b11111000, 0b00001000, 
160:                 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b11111000, 0b00001000, 
161:                 0b00001000, 0b11111000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 
162:                 0b11100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 
163:                 0b00000000, 0b11111100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00000000, 0b00000000, 0b00000000, 
164:                 0b00000000, 0b11111000, 0b00001000, 0b00001000, 0b11111000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00100100, 0b00100100, 
165:                 0b00100100, 0b00100100, 0b11100100, 0b00000100, 0b00000100, 0b11100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 
166:                 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 
167:                 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b11111100, 0b00000100, 0b00000100, 0b11100100, 0b00100100, 0b00100100, 0b00100100, 
168:                 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b11100100, 0b00000100, 0b00000100, 0b11111100, 0b00000000, 0b00000000, 
169:                 0b00000000, 0b00000000, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b11111100, 0b00000000, 0b00000000, 0b00000000, 
170:                 0b00000000, 0b00000000, 0b00000000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b11111000, 0b00001000, 0b00001000, 0b11111000, 
171:                 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b11111000, 0b00001000, 
172:                 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001111, 
173:                 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 
174:                 0b11111111, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 
175:                 0b00000000, 0b11111111, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 
176:                 0b00001000, 0b00001000, 0b00001111, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00000000, 0b00000000, 
177:                 0b00000000, 0b00000000, 0b00000000, 0b11111111, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00001000, 
178:                 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b11111111, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 
179:                 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001111, 0b00001000, 0b00001000, 0b00001111, 0b00001000, 0b00001000, 0b00001000, 
180:                 0b00001000, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100111, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 
181:                 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100111, 0b00100000, 0b00100000, 0b00111111, 0b00000000, 
182:                 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00111111, 0b00100000, 0b00100000, 0b00100111, 
183:                 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b11100111, 0b00000000, 0b00000000, 
184:                 0b11111111, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b11111111, 0b00000000, 
185:                 0b00000000, 0b11100111, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100111, 
186:                 0b00100000, 0b00100000, 0b00100111, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 
187:                 0b11111111, 0b00000000, 0b00000000, 0b11111111, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00100100, 0b00100100, 0b00100100, 
188:                 0b00100100, 0b11100111, 0b00000000, 0b00000000, 0b11100111, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00001000, 0b00001000, 
189:                 0b00001000, 0b00001000, 0b11111111, 0b00000000, 0b00000000, 0b11111111, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00100100, 
190:                 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b11111111, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 
191:                 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b11111111, 0b00000000, 0b00000000, 0b11111111, 0b00001000, 0b00001000, 0b00001000, 
192:                 0b00001000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b11111111, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 
193:                 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00111111, 0b00000000, 0b00000000, 0b00000000, 
194:                 0b00000000, 0b00000000, 0b00000000, 0b00010000, 0b00010000, 0b00010000, 0b00010000, 0b00011111, 0b00010000, 0b00010000, 0b00011111, 
195:                 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00011111, 0b00010000, 0b00010000, 
196:                 0b00011111, 0b00010000, 0b00010000, 0b00010000, 0b00010000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00111111, 
197:                 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 
198:                 0b11111111, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00100100, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 
199:                 0b11111111, 0b00001000, 0b00001000, 0b11111111, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 
200:                 0b00001000, 0b00001000, 0b11111000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 
201:                 0b00000000, 0b00000000, 0b00000000, 0b00001111, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b11111111, 
202:                 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 
203:                 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 
204:                 0b11111111, 0b11110000, 0b11110000, 0b11110000, 0b11110000, 0b11110000, 0b11110000, 0b11110000, 0b11110000, 0b11110000, 0b11110000, 
205:                 0b11110000, 0b11110000, 0b00001111, 0b00001111, 0b00001111, 0b00001111, 0b00001111, 0b00001111, 0b00001111, 0b00001111, 0b00001111, 
206:                 0b00001111, 0b00001111, 0b00001111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b11111111, 0b00000000, 0b00000000, 
207:                 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b0000000, 0b0000000, 0b0000000, 0b0111001, 0b1000110, 0b1000010, 0b1000010, 
208:                 0b1000010, 0b1000110, 0b0111001, 0b0000000, 0b0000000, 0b0001110, 0b0010001, 0b0100001, 0b0100010, 0b0111100, 0b0100010, 
209:                 0b0100001, 0b0100001, 0b0110001, 0b0101110, 0b1000000, 0b0000000, 0b0111111, 0b0100001, 0b0100000, 0b0100000, 0b0100000, 
210:                 0b0100000, 0b0100000, 0b0100000, 0b0100000, 0b0100000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b1111111, 
211:                 0b0100010, 0b0100010, 0b0100010, 0b0100010, 0b0100010, 0b0100010, 0b0000000, 0b0000000, 0b1111111, 0b1000001, 0b0100000, 
212:                 0b0010000, 0b0001000, 0b0010000, 0b0100000, 0b1000000, 0b1000001, 0b1111111, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 
213:                 0b0000000, 0b0111111, 0b1000100, 0b1000010, 0b1000001, 0b1000001, 0b1000001, 0b0111110, 0b0000000, 0b0000000, 0b0000000, 
214:                 0b0000000, 0b0000000, 0b1000010, 0b1000010, 0b1000010, 0b1000010, 0b1000010, 0b1100010, 0b1011101, 0b1000000, 0b1000000, 
215:                 0b0000000, 0b0000000, 0b0000000, 0b1111111, 0b0010000, 0b0010000, 0b0010000, 0b0010000, 0b0010000, 0b0001110, 0b0000000, 
216:                 0b0000000, 0b0011100, 0b0001000, 0b0111110, 0b1001001, 0b1001001, 0b1001001, 0b1001001, 0b0111110, 0b0001000, 0b0011100, 
217:                 0b0000000, 0b0000000, 0b0011100, 0b0100010, 0b1000001, 0b1000001, 0b1011101, 0b1000001, 0b1000001, 0b1000001, 0b0100010, 
218:                 0b0011100, 0b0000000, 0b0000000, 0b0111110, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b0100010, 
219:                 0b0100010, 0b1100011, 0b0000000, 0b0000000, 0b0000000, 0b1111111, 0b0100000, 0b0010000, 0b0011000, 0b0100100, 0b1000010, 
220:                 0b1000001, 0b1000001, 0b0111110, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0100000, 0b1010110, 0b1001001, 
221:                 0b0110101, 0b0000010, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0100000, 0b1000110, 0b1001001, 0b1001001, 
222:                 0b1001001, 0b0111110, 0b0001000, 0b0001000, 0b0001000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0111111, 
223:                 0b1000000, 0b1000000, 0b0111000, 0b1000000, 0b1000001, 0b0111110, 0b0000000, 0b0000000, 0b0011100, 0b0100010, 0b1000001, 
224:                 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 
225:                 0b0000000, 0b1111111, 0b0000000, 0b1111111, 0b0000000, 0b1111111, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0001000, 
226:                 0b0001000, 0b0001000, 0b1111111, 0b0001000, 0b0001000, 0b0001000, 0b0000000, 0b1111111, 0b0000000, 0b0000000, 0b0000000, 
227:                 0b0000000, 0b1000000, 0b0110000, 0b0001100, 0b0000011, 0b0001100, 0b0110000, 0b1000000, 0b0000000, 0b1111111, 0b0000000, 
228:                 0b0000000, 0b0000000, 0b0000001, 0b0000110, 0b0011000, 0b1100000, 0b0011000, 0b0000110, 0b0000001, 0b0000000, 0b1111111, 
229:                 0b0000000, 0b0000000, 0b0001100, 0b0010000, 0b0010000, 0b0010000, 0b0010000, 0b0010000, 0b0010000, 0b0010000, 0b0010000, 
230:                 0b0010000, 0b0010000, 0b0010000, 0b0000100, 0b0000100, 0b0000100, 0b0000100, 0b0000100, 0b0000100, 0b0000100, 0b0000100, 
231:                 0b0000100, 0b0000100, 0b0000100, 0b0011000, 0b0000000, 0b0000000, 0b0000000, 0b0001000, 0b0000000, 0b1111111, 0b0000000, 
232:                 0b0001000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0110000, 0b1001001, 0b0000110, 0b0000000, 
233:                 0b0110000, 0b1001001, 0b0000110, 0b0000000, 0b0000000, 0b0000000, 0b0011000, 0b0100100, 0b0100100, 0b0011000, 0b0000000, 
234:                 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 
235:                 0b0011000, 0b0111100, 0b0111100, 0b0011000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 
236:                 0b0000000, 0b0000000, 0b0001000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000111, 0b0000100, 
237:                 0b1100100, 0b0100100, 0b0100100, 0b0100100, 0b0100100, 0b0100100, 0b0010100, 0b0001000, 0b0000000, 0b0000000, 0b0101100, 
238:                 0b0110010, 0b0100010, 0b0100010, 0b0100010, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 
239:                 0b0111000, 0b0000100, 0b0011000, 0b0100000, 0b0111100, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 
240:                 0b0000000, 0b0000000, 0b0000000, 0b1111111, 0b1111111, 0b1111111, 0b1111111, 0b1111111, 0b1111111, 0b1111111, 0b0000000, 
241:                 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 0b0000000, 
242:                 0b0000000, 0b0000000, 0b0000000,
243:                 
244:                 
245:                 	};
246:                 
247:                 
248:                 uint32_t color_table[16] = {
249:                 	0x000000,	//0
250:                 	0x0000AA,	//1
251:                 	0x00AA00,	//2
252:                 	0x00AAAA,	//3
253:                 	0xAA0000,	//4
254:                 	0xAA00AA,	//5
255:                 	0xAA5500,	//6
256:                 	0xAAAAAA,	//7
257:                 	0x555555,	//8
258:                 	0x5555FF,	//9
259:                 	0x55FF55,	//10
260:                 	0x55FFFF,	//11
261:                 	0xFF5555,	//12
262:                 	0xFF55FF,	//13
263:                 	0xFFFF55,	//14
264:                 	0xFFFFFF,	//15	
265:                 	
266:                 	};
267:                 
268:                 uint16_t cursor_blink_cnt;
269:                 uint8_t cursor_blink_state, cursor_visible;
270:                 
271:                 
272:                 void set_cursor_state (uint8_t state)
273:                 	{
274:                 	if (state==0)
9D013AA8  14800003   BNE A0, ZERO, 0x9D013AB8
9D013AAC  24020001   ADDIU V0, ZERO, 1
9D013AB0  03E00008   JR RA
9D013AB4  A38081B4   SB ZERO, -32332(GP)
275:                 		cursor_visible = 0;
276:                 	else
277:                 		cursor_visible = 1;
9D013AB8  03E00008   JR RA
9D013ABC  A38281B4   SB V0, -32332(GP)
278:                 	}
279:                 
280:                 void disp_tasks (void)
281:                 	{
282:                 	cursor_blink_cnt++;
9D013AC0  978281B2   LHU V0, -32334(GP)
9D013AC4  24420001   ADDIU V0, V0, 1
9D013AC8  3042FFFF   ANDI V0, V0, -1
9D013AD8  03E00008   JR RA
9D013ADC  A78281B2   SH V0, -32334(GP)
283:                 	if (cursor_blink_cnt> 40)
9D013ACC  2C430029   SLTIU V1, V0, 41
9D013AD0  50600003   BEQL V1, ZERO, 0x9D013AE0
9D013AD4  A78081B2   SH ZERO, -32334(GP)
284:                 		{
285:                 		cursor_blink_cnt = 0;
286:                 		if (cursor_blink_state)
9D013AE0  938281B5   LBU V0, -32331(GP)
9D013AE4  10400003   BEQ V0, ZERO, 0x9D013AF4
9D013AE8  24020001   ADDIU V0, ZERO, 1
9D013AEC  03E00008   JR RA
9D013AF0  A38081B5   SB ZERO, -32331(GP)
287:                 			cursor_blink_state = 0;
288:                 		else
289:                 			cursor_blink_state = 1;
9D013AF4  03E00008   JR RA
9D013AF8  A38281B5   SB V0, -32331(GP)
290:                 		}
291:                 	}
292:                 
293:                 void tft_disp_buffer_refresh(uint8_t * buff, uint8_t * color_buff)
294:                 	{
9D014FD0  27BDFF88   ADDIU SP, SP, -120
9D014FD4  AFBF0074   SW RA, 116(SP)
9D014FD8  AFBE0070   SW FP, 112(SP)
9D014FDC  AFB7006C   SW S7, 108(SP)
9D014FE0  AFB60068   SW S6, 104(SP)
9D014FE4  AFB50064   SW S5, 100(SP)
9D014FE8  AFB40060   SW S4, 96(SP)
9D014FEC  AFB3005C   SW S3, 92(SP)
9D014FF0  AFB20058   SW S2, 88(SP)
9D014FF4  AFB10054   SW S1, 84(SP)
9D014FF8  AFB00050   SW S0, 80(SP)
9D014FFC  AFA40078   SW A0, 120(SP)
295:                 	uint16_t i,j,ad,col,back,cur_x,cur_y;
296:                 	cur_x = video_getx();
9D015000  0F406A1C   JAL video_getx
9D015004  AFA5007C   SW A1, 124(SP)
9D015008  3042FFFF   ANDI V0, V0, -1
297:                 	cur_y = video_gety();
9D01500C  0F406A1E   JAL .LFB47, .LFE46, video_gety
9D015010  AFA20038   SW V0, 56(SP)
9D015014  3042FFFF   ANDI V0, V0, -1
9D015018  AFA2004C   SW V0, 76(SP)
9D01501C  AFA00020   SW ZERO, 32(SP)
9D015020  2402000B   ADDIU V0, ZERO, 11
9D015024  AFA20044   SW V0, 68(SP)
298:                 	for (i=0;i<20;i++)
9D015028  AFA00048   SW ZERO, 72(SP)
9D015A54  8FA30048   LW V1, 72(SP)
9D015A58  24620001   ADDIU V0, V1, 1
9D015A5C  3042FFFF   ANDI V0, V0, -1
9D015A60  AFA20048   SW V0, 72(SP)
9D015A64  8FA40044   LW A0, 68(SP)
9D015A68  2484000C   ADDIU A0, A0, 12
9D015A6C  AFA40044   SW A0, 68(SP)
9D015A70  8FA60020   LW A2, 32(SP)
9D015A74  24C60028   ADDIU A2, A2, 40
9D015A78  AFA60020   SW A2, 32(SP)
9D015A7C  24020014   ADDIU V0, ZERO, 20
9D015A80  8FA30048   LW V1, 72(SP)
9D015A84  10620016   BEQ V1, V0, 0x9D015AE0
9D015A88  8FBF0074   LW RA, 116(SP)
9D015A8C  8FA40044   LW A0, 68(SP)
9D015A90  3082FFFF   ANDI V0, A0, -1
9D015A94  2443FFF5   ADDIU V1, V0, -11
9D015A98  3063FFFF   ANDI V1, V1, -1
299:                 		for (j=0;j<40;j++)	
9D015A48  24020028   ADDIU V0, ZERO, 40
9D015A4C  1482FD83   BNE A0, V0, 0x9D01505C
9D015A50  AFA60014   SW A2, 20(SP)
300:                 			{
301:                 			col = color_buff[j+(i*40)]&0xF;
9D015070  90420000   LBU V0, 0(V0)
9D015074  3073FFFF   ANDI S3, V1, -1
302:                 			back = (color_buff[j+(i*40)]>>4)&0xF;
303:                 			if ((cur_x==j)&(cur_y==i)&(cursor_blink_state==1)&(cursor_visible!=0))
9D015078  938481B4   LBU A0, -32332(GP)
9D01507C  0004202B   SLTU A0, ZERO, A0
9D015080  938381B5   LBU V1, -32331(GP)
9D015084  38630001   XORI V1, V1, 1
9D015088  2C630001   SLTIU V1, V1, 1
9D01508C  00831824   AND V1, A0, V1
9D015090  8FA40024   LW A0, 36(SP)
9D015094  00831824   AND V1, A0, V1
9D015098  10600106   BEQ V1, ZERO, 0x9D0154B4
9D01509C  00022902   SRL A1, V0, 4
9D0150A0  8FA60038   LW A2, 56(SP)
9D0150A4  54D30104   BNEL A2, S3, 0x9D0154B8
9D0150A8  8FA40078   LW A0, 120(SP)
9D0150AC  001398C0   SLL S3, S3, 3
9D0150B0  3273FFFF   ANDI S3, S3, -1
9D0150B4  AFB30018   SW S3, 24(SP)
9D015AC8  8FA6004C   LW A2, 76(SP)
9D015ACC  8FA30048   LW V1, 72(SP)
9D015AD0  00C31026   XOR V0, A2, V1
9D015AD4  2C420001   SLTIU V0, V0, 1
9D015AD8  0B405417   J 0x9D01505C
9D015ADC  AFA20024   SW V0, 36(SP)
304:                 				tft_print_char(219,j*8,i*12,color_table[15],color_table[back]);
9D0150B8  8FA2001C   LW V0, 28(SP)
9D0150BC  8C51003C   LW S1, 60(V0)
9D0150C0  00052880   SLL A1, A1, 2
9D0150C4  00A22821   ADDU A1, A1, V0
9D0150C8  8CA20000   LW V0, 0(A1)
305:                 			else
306:                 				tft_print_char(buff[j+(i*40)],j*8,i*12,color_table[col],color_table[back]);
9D01502C  3C02A001   LUI V0, -24575
9D015030  2442B658   ADDIU V0, V0, -18856
9D015034  AFA2001C   SW V0, 28(SP)
9D0154C8  90630000   LBU V1, 0(V1)
9D0154CC  AFA30018   SW V1, 24(SP)
9D0154D0  001398C0   SLL S3, S3, 3
9D0154D4  3273FFFF   ANDI S3, S3, -1
9D0154D8  3042000F   ANDI V0, V0, 15
9D0154DC  00021080   SLL V0, V0, 2
9D0154E0  8FA6001C   LW A2, 28(SP)
9D0154E4  00461021   ADDU V0, V0, A2
9D0154E8  8C550000   LW S5, 0(V0)
9D0154EC  00052880   SLL A1, A1, 2
9D0154F0  00A62821   ADDU A1, A1, A2
9D0154F4  8CB10000   LW S1, 0(A1)
307:                 			}
308:                 	}
9D015AE0  8FBE0070   LW FP, 112(SP)
9D015AE4  8FB7006C   LW S7, 108(SP)
9D015AE8  8FB60068   LW S6, 104(SP)
9D015AEC  8FB50064   LW S5, 100(SP)
9D015AF0  8FB40060   LW S4, 96(SP)
9D015AF4  8FB3005C   LW S3, 92(SP)
9D015AF8  8FB20058   LW S2, 88(SP)
9D015AFC  8FB10054   LW S1, 84(SP)
9D015B00  8FB00050   LW S0, 80(SP)
9D015B04  03E00008   JR RA
9D015B08  27BD0078   ADDIU SP, SP, 120
309:                 
310:                 void tft_disp_buffer_refresh_part(uint8_t * buff, uint8_t * color_buff)
311:                 	{
9D014454  27BDFF90   ADDIU SP, SP, -112
9D014458  AFBF006C   SW RA, 108(SP)
9D01445C  AFBE0068   SW FP, 104(SP)
9D014460  AFB70064   SW S7, 100(SP)
9D014464  AFB60060   SW S6, 96(SP)
9D014468  AFB5005C   SW S5, 92(SP)
9D01446C  AFB40058   SW S4, 88(SP)
9D014470  AFB30054   SW S3, 84(SP)
9D014474  AFB20050   SW S2, 80(SP)
9D014478  AFB1004C   SW S1, 76(SP)
9D01447C  AFB00048   SW S0, 72(SP)
9D014480  AFA40070   SW A0, 112(SP)
312:                     static uint8_t dr_cnt=0,col,back,cur_x,cur_y;
313:                 	uint16_t i,j,ad;
314:                 	cur_x = video_getx();
9D014484  0F406A1C   JAL video_getx
9D014488  AFA50074   SW A1, 116(SP)
315:                 	cur_y = video_gety();
9D01448C  0F406A1E   JAL .LFB47, .LFE46, video_gety
9D014490  A3828172   SB V0, -32398(GP)
9D014494  A3828171   SB V0, -32399(GP)
316:                 	for (i=(dr_cnt);i<(dr_cnt+2);i++)
9D014498  93828170   LBU V0, -32400(GP)
9D01449C  24440002   ADDIU A0, V0, 2
9D0144A0  0044202A   SLT A0, V0, A0
9D0144A4  108002B8   BEQ A0, ZERO, 0x9D014F88
9D0144A8  AFA20024   SW V0, 36(SP)
9D0144AC  00401821   ADDU V1, V0, ZERO
9D0144B0  00021080   SLL V0, V0, 2
9D0144B4  00022080   SLL A0, V0, 2
9D0144B8  00821023   SUBU V0, A0, V0
9D0144BC  3042FFFF   ANDI V0, V0, -1
9D0144C0  AFA20044   SW V0, 68(SP)
9D014EF4  8FA30024   LW V1, 36(SP)
9D014EF8  24620001   ADDIU V0, V1, 1
9D014EFC  3042FFFF   ANDI V0, V0, -1
9D014F00  AFA20024   SW V0, 36(SP)
9D014F04  00401821   ADDU V1, V0, ZERO
9D014F08  93828170   LBU V0, -32400(GP)
9D014F0C  8FA50044   LW A1, 68(SP)
9D014F10  24A4000C   ADDIU A0, A1, 12
9D014F14  3084FFFF   ANDI A0, A0, -1
9D014F18  AFA40044   SW A0, 68(SP)
9D014F1C  24440002   ADDIU A0, V0, 2
9D014F20  0064202A   SLT A0, V1, A0
9D014F24  10800019   BEQ A0, ZERO, 0x9D014F8C
9D014F28  24420002   ADDIU V0, V0, 2
317:                 		for (j=0;j<40;j++)	
9D014EE8  24020028   ADDIU V0, ZERO, 40
9D014EEC  1482FD81   BNE A0, V0, 0x9D0144F4
9D014EF0  AFA60014   SW A2, 20(SP)
318:                 			{
319:                 			col = color_buff[j+(i*40)]&0xF;
9D0144FC  8FA40018   LW A0, 24(SP)
9D014500  90820000   LBU V0, 0(A0)
9D014F5C  000310C0   SLL V0, V1, 3
9D014F60  00031940   SLL V1, V1, 5
9D014F64  00431821   ADDU V1, V0, V1
9D014F68  AFA30038   SW V1, 56(SP)
9D014F6C  8FA60074   LW A2, 116(SP)
9D014F70  00C33021   ADDU A2, A2, V1
9D014F74  AFA60018   SW A2, 24(SP)
320:                 			back = (color_buff[j+(i*40)]>>4)&0xF;
321:                 			if ((cur_x==j)&(cur_y==i)&(cursor_blink_state==1)&(cursor_visible!=0))
9D014504  938481B4   LBU A0, -32332(GP)
9D014508  0004202B   SLTU A0, ZERO, A0
9D01450C  938381B5   LBU V1, -32331(GP)
9D014510  38630001   XORI V1, V1, 1
9D014514  2C630001   SLTIU V1, V1, 1
9D014518  00832024   AND A0, A0, V1
9D01451C  93838171   LBU V1, -32399(GP)
9D014520  8FA60024   LW A2, 36(SP)
9D014524  00661826   XOR V1, V1, A2
9D014528  2C630001   SLTIU V1, V1, 1
9D01452C  00641824   AND V1, V1, A0
9D014530  10600105   BEQ V1, ZERO, 0x9D014948
9D014534  00022902   SRL A1, V0, 4
9D014538  93838172   LBU V1, -32398(GP)
9D01453C  14730103   BNE V1, S3, 0x9D01494C
9D014540  8FA60070   LW A2, 112(SP)
9D014544  001398C0   SLL S3, S3, 3
9D014548  3273FFFF   ANDI S3, S3, -1
9D01454C  AFB3001C   SW S3, 28(SP)
322:                 				tft_print_char(219,j*8,i*12,color_table[15],color_table[back]);
9D014550  8FA20020   LW V0, 32(SP)
9D014554  8C51003C   LW S1, 60(V0)
9D014558  00052880   SLL A1, A1, 2
9D01455C  00A22821   ADDU A1, A1, V0
9D014560  8CA20000   LW V0, 0(A1)
323:                 			else
324:                 				tft_print_char(buff[j+(i*40)],j*8,i*12,color_table[col],color_table[back]);
9D0144C4  3C02A001   LUI V0, -24575
9D0144C8  2442B658   ADDIU V0, V0, -18856
9D0144CC  AFA20020   SW V0, 32(SP)
9D01495C  90630000   LBU V1, 0(V1)
9D014960  AFA3001C   SW V1, 28(SP)
9D014964  001398C0   SLL S3, S3, 3
9D014968  3273FFFF   ANDI S3, S3, -1
9D01496C  3042000F   ANDI V0, V0, 15
9D014970  00021080   SLL V0, V0, 2
9D014974  8FA30020   LW V1, 32(SP)
9D014978  00431021   ADDU V0, V0, V1
9D01497C  8C550000   LW S5, 0(V0)
9D014980  00052880   SLL A1, A1, 2
9D014984  00A32821   ADDU A1, A1, V1
9D014988  8CB10000   LW S1, 0(A1)
325:                 			}
326:                     dr_cnt = dr_cnt + 2;
9D014F88  24420002   ADDIU V0, V0, 2
9D014F8C  304200FF   ANDI V0, V0, 255
327:                     if (dr_cnt == 20)
9D014F90  24030014   ADDIU V1, ZERO, 20
9D014F94  50430002   BEQL V0, V1, 0x9D014FA0
9D014F98  A3808170   SB ZERO, -32400(GP)
9D014F9C  A3828170   SB V0, -32400(GP)
328:                         dr_cnt = 0;
329:                 
330:                     }
9D014FA0  8FBF006C   LW RA, 108(SP)
9D014FA4  8FBE0068   LW FP, 104(SP)
9D014FA8  8FB70064   LW S7, 100(SP)
9D014FAC  8FB60060   LW S6, 96(SP)
9D014FB0  8FB5005C   LW S5, 92(SP)
9D014FB4  8FB40058   LW S4, 88(SP)
9D014FB8  8FB30054   LW S3, 84(SP)
9D014FBC  8FB20050   LW S2, 80(SP)
9D014FC0  8FB1004C   LW S1, 76(SP)
9D014FC4  8FB00048   LW S0, 72(SP)
9D014FC8  03E00008   JR RA
9D014FCC  27BD0070   ADDIU SP, SP, 112
331:                 
332:                 
333:                 
334:                 inline void tft_print_char (uint8_t val, uint16_t x, uint16_t y, uint32_t col, uint32_t back)
335:                 	{
9D013E78  27BDFFC8   ADDIU SP, SP, -56
9D013E7C  AFBF0034   SW RA, 52(SP)
9D013E80  AFBE0030   SW FP, 48(SP)
9D013E84  AFB7002C   SW S7, 44(SP)
9D013E88  AFB60028   SW S6, 40(SP)
9D013E8C  AFB50024   SW S5, 36(SP)
9D013E90  AFB40020   SW S4, 32(SP)
9D013E94  AFB3001C   SW S3, 28(SP)
9D013E98  AFB20018   SW S2, 24(SP)
9D013E9C  AFB10014   SW S1, 20(SP)
9D013EA0  AFB00010   SW S0, 16(SP)
9D013EA4  AFA40038   SW A0, 56(SP)
9D013EA8  00A0F021   ADDU FP, A1, ZERO
9D013EAC  00C0B821   ADDU S7, A2, ZERO
9D013EB0  AFA70044   SW A3, 68(SP)
9D013EB4  8FB20048   LW S2, 72(SP)
336:                 	uint16_t fl,i,j;
337:                 	uint16_t c1,c2,c3,b1,b2,b3;
338:                 	c1 = (col>>16)&0xFF;
9D0140D0  7C4A3C00   EXT T2, V0, 16, 8
9D014564  7E333C00   EXT S3, S1, 16, 8
9D0150CC  7E333C00   EXT S3, S1, 16, 8
339:                 	c2 = (col>>8)&0xFF;
9D0140D4  7C493A00   EXT T1, V0, 8, 8
9D014568  7E323A00   EXT S2, S1, 8, 8
9D014B88  7EA53A00   EXT A1, S5, 8, 8
9D0150D0  7E323A00   EXT S2, S1, 8, 8
9D0156F4  7EA53A00   EXT A1, S5, 8, 8
340:                 	c3 = (col>>0)&0xFF;
9D0140D8  304800FF   ANDI T0, V0, 255
9D01456C  323100FF   ANDI S1, S1, 255
9D014B8C  32B500FF   ANDI S5, S5, 255
9D0150D4  323100FF   ANDI S1, S1, 255
9D0156F8  32B500FF   ANDI S5, S5, 255
341:                 	b1 = (back>>16)&0xFF;
9D013EB8  7E503C00   EXT S0, S2, 16, 8
9D014570  7C503C00   EXT S0, V0, 16, 8
9D01498C  7E343C00   EXT S4, S1, 16, 8
9D0150D8  7C503C00   EXT S0, V0, 16, 8
9D0154F8  7E343C00   EXT S4, S1, 16, 8
342:                 	b2 = (back>>8)&0xFF;
9D013EBC  7E513A00   EXT S1, S2, 8, 8
9D014574  7C543A00   EXT S4, V0, 8, 8
9D014990  7E303A00   EXT S0, S1, 8, 8
9D0150DC  7C543A00   EXT S4, V0, 8, 8
9D0154FC  7E303A00   EXT S0, S1, 8, 8
343:                 	b3 = (back>>0)&0xFF;
9D013EC0  325200FF   ANDI S2, S2, 255
9D014578  305500FF   ANDI S5, V0, 255
9D014994  323100FF   ANDI S1, S1, 255
9D0150E0  305500FF   ANDI S5, V0, 255
9D015500  323100FF   ANDI S1, S1, 255
344:                 	tft_set_write_area(x,y,7,11);
345:                 	TFT_24_7789_Write_Command(0x2C);
9D013F6C  0F404EBF   JAL TFT_24_7789_Write_Command
9D013F70  2404002C   ADDIU A0, ZERO, 44
9D01461C  0F404EBF   JAL TFT_24_7789_Write_Command
9D014620  2404002C   ADDIU A0, ZERO, 44
9D014624  3C049D03   LUI A0, -25341
9D014628  24848840   ADDIU A0, A0, -30656
9D014A30  0F404EBF   JAL TFT_24_7789_Write_Command
9D014A34  2404002C   ADDIU A0, ZERO, 44
9D015188  0F404EBF   JAL TFT_24_7789_Write_Command
9D01518C  2404002C   ADDIU A0, ZERO, 44
9D015190  3C049D03   LUI A0, -25341
9D015194  24848840   ADDIU A0, A0, -30656
9D01559C  0F404EBF   JAL TFT_24_7789_Write_Command
9D0155A0  2404002C   ADDIU A0, ZERO, 44
346:                 	if (val<' ')
9D013F74  8FA30038   LW V1, 56(SP)
9D013F78  2C620020   SLTIU V0, V1, 32
9D013F7C  10400054   BEQ V0, ZERO, 0x9D0140D0
9D013F80  8FA20044   LW V0, 68(SP)
9D013F84  2406000C   ADDIU A2, ZERO, 12
9D014A38  8FA4001C   LW A0, 28(SP)
9D014A3C  2C820020   SLTIU V0, A0, 32
9D014A40  10400051   BEQ V0, ZERO, 0x9D014B88
9D014A44  7EA63C00   EXT A2, S5, 16, 8
9D014A48  2403000C   ADDIU V1, ZERO, 12
9D0155A4  8FA40018   LW A0, 24(SP)
9D0155A8  2C820020   SLTIU V0, A0, 32
9D0155AC  10400051   BEQ V0, ZERO, 0x9D0156F4
9D0155B0  7EA63C00   EXT A2, S5, 16, 8
9D0155B4  2403000C   ADDIU V1, ZERO, 12
347:                 		{
348:                 		for (i=0;i<12;i++)
9D0140C0  14C0FFB5   BNE A2, ZERO, 0x9D013F98
9D0140C4  8FBF0034   LW RA, 52(SP)
9D0140C8  0B40510B   J 0x9D01442C
9D0140CC  8FBE0030   LW FP, 48(SP)
9D014B78  1460FFB5   BNE V1, ZERO, 0x9D014A50
9D014B7C  8FA40010   LW A0, 16(SP)
9D014B80  0B4053B4   J 0x9D014ED0
9D014B84  24840001   ADDIU A0, A0, 1
9D0156E4  1460FFB5   BNE V1, ZERO, 0x9D0155BC
9D0156E8  8FA40010   LW A0, 16(SP)
9D0156EC  0B40568F   J 0x9D015A3C
9D0156F0  24840001   ADDIU A0, A0, 1
349:                 			{
350:                 			TFT_24_7789_Write_Data3(b1,b2,b3);
351:                 			TFT_24_7789_Write_Data3(b1,b2,b3);
352:                 			TFT_24_7789_Write_Data3(b1,b2,b3);
353:                 			TFT_24_7789_Write_Data3(b1,b2,b3);
354:                 			TFT_24_7789_Write_Data3(b1,b2,b3);
355:                 			TFT_24_7789_Write_Data3(b1,b2,b3);
356:                 			TFT_24_7789_Write_Data3(b1,b2,b3);
357:                 			TFT_24_7789_Write_Data3(b1,b2,b3);
358:                 			}
359:                 				
360:                 		}
361:                 	else
362:                 		{
363:                 		for (i=0;i<12;i++)
9D014110  240C000C   ADDIU T4, ZERO, 12
9D014114  01A73021   ADDU A2, T5, A3
9D01441C  14ECFF3E   BNE A3, T4, 0x9D014118
9D014420  01A73021   ADDU A2, T5, A3
9D014938  5486FF3F   BNEL A0, A2, 0x9D014638
9D01493C  80830000   LB V1, 0(A0)
9D014940  0B4053B3   J 0x9D014ECC
9D014944  8FA40010   LW A0, 16(SP)
9D014948  8FA60070   LW A2, 112(SP)
9D01494C  8FA40038   LW A0, 56(SP)
9D014950  00C41821   ADDU V1, A2, A0
9D014954  8FA60010   LW A2, 16(SP)
9D014958  00661821   ADDU V1, V1, A2
9D014BB4  2408000C   ADDIU T0, ZERO, 12
9D014BB8  01241821   ADDU V1, T1, A0
9D014EC0  1488FF3E   BNE A0, T0, 0x9D014BBC
9D014EC4  01241821   ADDU V1, T1, A0
9D014EC8  8FA40010   LW A0, 16(SP)
9D014ECC  24840001   ADDIU A0, A0, 1
9D014ED0  AFA40010   SW A0, 16(SP)
9D014ED4  8FA50018   LW A1, 24(SP)
9D014ED8  24A50001   ADDIU A1, A1, 1
9D014EDC  AFA50018   SW A1, 24(SP)
9D014EE0  8FA60014   LW A2, 20(SP)
9D014EE4  24C60008   ADDIU A2, A2, 8
9D0154A4  5486FF3F   BNEL A0, A2, 0x9D0151A4
9D0154A8  80830000   LB V1, 0(A0)
9D0154AC  0B40568E   J 0x9D015A38
9D0154B0  8FA40010   LW A0, 16(SP)
9D0154B4  8FA40078   LW A0, 120(SP)
9D0154B8  8FA60020   LW A2, 32(SP)
9D0154BC  00861821   ADDU V1, A0, A2
9D0154C0  8FA40010   LW A0, 16(SP)
9D0154C4  00641821   ADDU V1, V1, A0
9D015720  2408000C   ADDIU T0, ZERO, 12
9D015724  01241821   ADDU V1, T1, A0
9D015A2C  1488FF3E   BNE A0, T0, 0x9D015728
9D015A30  01241821   ADDU V1, T1, A0
9D015A34  8FA40010   LW A0, 16(SP)
9D015A38  24840001   ADDIU A0, A0, 1
9D015A3C  AFA40010   SW A0, 16(SP)
9D015A40  8FA60014   LW A2, 20(SP)
9D015A44  24C60008   ADDIU A2, A2, 8
364:                 			{
365:                 			fl = font[i+12*(val-' ')];
9D0140DC  8FA30038   LW V1, 56(SP)
9D0140E0  2462FFE0   ADDIU V0, V1, -32
9D0140E4  00021880   SLL V1, V0, 2
9D0140E8  00021100   SLL V0, V0, 4
9D0140EC  00431023   SUBU V0, V0, V1
9D0140F0  00003821   ADDU A3, ZERO, ZERO
9D0140F4  3C0D9D02   LUI T5, -25342
9D0140F8  25AD7F7C   ADDIU T5, T5, 32636
9D0140FC  01A26821   ADDU T5, T5, V0
9D014118  80C60000   LB A2, 0(A2)
9D014634  80830000   LB V1, 0(A0)
9D014B90  8FA2001C   LW V0, 28(SP)
9D014B94  2443FFE0   ADDIU V1, V0, -32
9D014B98  00031080   SLL V0, V1, 2
9D014B9C  00034900   SLL T1, V1, 4
9D014BA0  01224823   SUBU T1, T1, V0
9D014BA4  00002021   ADDU A0, ZERO, ZERO
9D014BA8  8FA30040   LW V1, 64(SP)
9D014BAC  00694821   ADDU T1, V1, T1
9D014BBC  80630000   LB V1, 0(V1)
9D0151A0  80830000   LB V1, 0(A0)
9D0156FC  8FA20018   LW V0, 24(SP)
9D015700  2443FFE0   ADDIU V1, V0, -32
9D015704  00031080   SLL V0, V1, 2
9D015708  00034900   SLL T1, V1, 4
9D01570C  01224823   SUBU T1, T1, V0
9D015710  00002021   ADDU A0, ZERO, ZERO
9D015714  8FA30040   LW V1, 64(SP)
9D015718  00694821   ADDU T1, V1, T1
9D015728  80630000   LB V1, 0(V1)
366:                 			if (fl&0x80)
9D01411C  30CB0080   ANDI T3, A2, 128
9D014120  316BFFFF   ANDI T3, T3, -1
9D014124  1160000C   BEQ T3, ZERO, 0x9D014158
9D014128  00000000   NOP
9D014638  30650080   ANDI A1, V1, 128
9D01463C  30A5FFFF   ANDI A1, A1, -1
9D014640  10A0000C   BEQ A1, ZERO, 0x9D014674
9D014644  00000000   NOP
9D014BC0  30670080   ANDI A3, V1, 128
9D014BC4  30E7FFFF   ANDI A3, A3, -1
9D014BC8  10E0000C   BEQ A3, ZERO, 0x9D014BFC
9D014BCC  00000000   NOP
9D0151A4  30650080   ANDI A1, V1, 128
9D0151A8  30A5FFFF   ANDI A1, A1, -1
9D0151AC  10A0000C   BEQ A1, ZERO, 0x9D0151E0
9D0151B0  00000000   NOP
9D01572C  30670080   ANDI A3, V1, 128
9D015730  30E7FFFF   ANDI A3, A3, -1
9D015734  10E0000C   BEQ A3, ZERO, 0x9D015768
9D015738  00000000   NOP
367:                 				TFT_24_7789_Write_Data3(c1,c2,c3);
368:                 			else
369:                 				TFT_24_7789_Write_Data3(b1,b2,b3);
370:                 			if (fl&0x40)
9D014150  0B405060   J 0x9D014180
9D014154  30CB0040   ANDI T3, A2, 64
9D01417C  30CB0040   ANDI T3, A2, 64
9D014180  7C0B5C20   SEB T3, T3
9D014184  1160000C   BEQ T3, ZERO, .LBB426
9D014188  00000000   NOP
9D01466C  0B4051A7   J 0x9D01469C
9D014670  30650040   ANDI A1, V1, 64
9D014698  30650040   ANDI A1, V1, 64
9D01469C  7C052C20   SEB A1, A1
9D0146A0  10A0000C   BEQ A1, ZERO, .LBB710
9D0146A4  00000000   NOP
9D014BF4  0B405309   J 0x9D014C24
9D014BF8  30670040   ANDI A3, V1, 64
9D014C20  30670040   ANDI A3, V1, 64
9D014C24  7C073C20   SEB A3, A3
9D014C28  10E0000C   BEQ A3, ZERO, .LBB636
9D014C2C  00000000   NOP
9D0151D8  0B405482   J 0x9D015208
9D0151DC  30650040   ANDI A1, V1, 64
9D015204  30650040   ANDI A1, V1, 64
9D015208  7C052C20   SEB A1, A1
9D01520C  10A0000C   BEQ A1, ZERO, .LBB1019
9D015210  00000000   NOP
9D015760  0B4055E4   J 0x9D015790
9D015764  30670040   ANDI A3, V1, 64
9D01578C  30670040   ANDI A3, V1, 64
9D015790  7C073C20   SEB A3, A3
9D015794  10E0000C   BEQ A3, ZERO, .LBB948
9D015798  00000000   NOP
371:                 				TFT_24_7789_Write_Data3(c1,c2,c3);
372:                 			else
373:                 				TFT_24_7789_Write_Data3(b1,b2,b3);
374:                 			if (fl&0x20)
9D0141B0  0B405078   J 0x9D0141E0
9D0141B4  30CB0020   ANDI T3, A2, 32
9D0141DC  30CB0020   ANDI T3, A2, 32
9D0141E0  7C0B5C20   SEB T3, T3
9D0141E4  1160000C   BEQ T3, ZERO, .LBB430
9D0141E8  00000000   NOP
9D0146CC  0B4051BF   J 0x9D0146FC
9D0146D0  30650020   ANDI A1, V1, 32
9D0146F8  30650020   ANDI A1, V1, 32
9D0146FC  7C052C20   SEB A1, A1
9D014700  10A0000C   BEQ A1, ZERO, .LBB714
9D014704  00000000   NOP
9D014C54  0B405321   J 0x9D014C84
9D014C58  30670020   ANDI A3, V1, 32
9D014C80  30670020   ANDI A3, V1, 32
9D014C84  7C073C20   SEB A3, A3
9D014C88  10E0000C   BEQ A3, ZERO, .LBB640
9D014C8C  00000000   NOP
9D015238  0B40549A   J 0x9D015268
9D01523C  30650020   ANDI A1, V1, 32
9D015264  30650020   ANDI A1, V1, 32
9D015268  7C052C20   SEB A1, A1
9D01526C  10A0000C   BEQ A1, ZERO, .LBB1023
9D015270  00000000   NOP
9D0157C0  0B4055FC   J 0x9D0157F0
9D0157C4  30670020   ANDI A3, V1, 32
9D0157EC  30670020   ANDI A3, V1, 32
9D0157F0  7C073C20   SEB A3, A3
9D0157F4  10E0000C   BEQ A3, ZERO, .LBB952
9D0157F8  00000000   NOP
375:                 				TFT_24_7789_Write_Data3(c1,c2,c3);
376:                 			else
377:                 				TFT_24_7789_Write_Data3(b1,b2,b3);
378:                 			if (fl&0x10)
9D014210  0B405090   J 0x9D014240
9D014214  30CB0010   ANDI T3, A2, 16
9D01423C  30CB0010   ANDI T3, A2, 16
9D014240  7C0B5C20   SEB T3, T3
9D014244  1160000C   BEQ T3, ZERO, .LBB434
9D014248  00000000   NOP
9D01472C  0B4051D7   J 0x9D01475C
9D014730  30650010   ANDI A1, V1, 16
9D014758  30650010   ANDI A1, V1, 16
9D01475C  7C052C20   SEB A1, A1
9D014760  10A0000C   BEQ A1, ZERO, .LBB718
9D014764  00000000   NOP
9D014CB4  0B405339   J 0x9D014CE4
9D014CB8  30670010   ANDI A3, V1, 16
9D014CE0  30670010   ANDI A3, V1, 16
9D014CE4  7C073C20   SEB A3, A3
9D014CE8  10E0000C   BEQ A3, ZERO, .LBB644
9D014CEC  00000000   NOP
9D015298  0B4054B2   J 0x9D0152C8
9D01529C  30650010   ANDI A1, V1, 16
9D0152C4  30650010   ANDI A1, V1, 16
9D0152C8  7C052C20   SEB A1, A1
9D0152CC  10A0000C   BEQ A1, ZERO, .LBB1027
9D0152D0  00000000   NOP
9D015820  0B405614   J 0x9D015850
9D015824  30670010   ANDI A3, V1, 16
9D01584C  30670010   ANDI A3, V1, 16
9D015850  7C073C20   SEB A3, A3
9D015854  10E0000C   BEQ A3, ZERO, .LBB956
9D015858  00000000   NOP
379:                 				TFT_24_7789_Write_Data3(c1,c2,c3);
380:                 			else
381:                 				TFT_24_7789_Write_Data3(b1,b2,b3);
382:                 			if (fl&0x08)
9D014270  0B4050A8   J 0x9D0142A0
9D014274  30CB0008   ANDI T3, A2, 8
9D01429C  30CB0008   ANDI T3, A2, 8
9D0142A0  7C0B5C20   SEB T3, T3
9D0142A4  1160000C   BEQ T3, ZERO, .LBB438
9D0142A8  00000000   NOP
9D01478C  0B4051EF   J 0x9D0147BC
9D014790  30650008   ANDI A1, V1, 8
9D0147B8  30650008   ANDI A1, V1, 8
9D0147BC  7C052C20   SEB A1, A1
9D0147C0  10A0000C   BEQ A1, ZERO, .LBB722
9D0147C4  00000000   NOP
9D014D14  0B405351   J 0x9D014D44
9D014D18  30670008   ANDI A3, V1, 8
9D014D40  30670008   ANDI A3, V1, 8
9D014D44  7C073C20   SEB A3, A3
9D014D48  10E0000C   BEQ A3, ZERO, .LBB648
9D014D4C  00000000   NOP
9D0152F8  0B4054CA   J 0x9D015328
9D0152FC  30650008   ANDI A1, V1, 8
9D015324  30650008   ANDI A1, V1, 8
9D015328  7C052C20   SEB A1, A1
9D01532C  10A0000C   BEQ A1, ZERO, .LBB1031
9D015330  00000000   NOP
9D015880  0B40562C   J 0x9D0158B0
9D015884  30670008   ANDI A3, V1, 8
9D0158AC  30670008   ANDI A3, V1, 8
9D0158B0  7C073C20   SEB A3, A3
9D0158B4  10E0000C   BEQ A3, ZERO, .LBB960
9D0158B8  00000000   NOP
383:                 				TFT_24_7789_Write_Data3(c1,c2,c3);
384:                 			else
385:                 				TFT_24_7789_Write_Data3(b1,b2,b3);
386:                 			if (fl&0x04)
9D0142D0  0B4050C0   J 0x9D014300
9D0142D4  30CB0004   ANDI T3, A2, 4
9D0142FC  30CB0004   ANDI T3, A2, 4
9D014300  7C0B5C20   SEB T3, T3
9D014304  1160000C   BEQ T3, ZERO, .LBB442
9D014308  00000000   NOP
9D0147EC  0B405207   J 0x9D01481C
9D0147F0  30650004   ANDI A1, V1, 4
9D014818  30650004   ANDI A1, V1, 4
9D01481C  7C052C20   SEB A1, A1
9D014820  10A0000C   BEQ A1, ZERO, .LBB726
9D014824  00000000   NOP
9D014D74  0B405369   J 0x9D014DA4
9D014D78  30670004   ANDI A3, V1, 4
9D014DA0  30670004   ANDI A3, V1, 4
9D014DA4  7C073C20   SEB A3, A3
9D014DA8  10E0000C   BEQ A3, ZERO, .LBB652
9D014DAC  00000000   NOP
9D015358  0B4054E2   J 0x9D015388
9D01535C  30650004   ANDI A1, V1, 4
9D015384  30650004   ANDI A1, V1, 4
9D015388  7C052C20   SEB A1, A1
9D01538C  10A0000C   BEQ A1, ZERO, .LBB1035
9D015390  00000000   NOP
9D0158E0  0B405644   J 0x9D015910
9D0158E4  30670004   ANDI A3, V1, 4
9D01590C  30670004   ANDI A3, V1, 4
9D015910  7C073C20   SEB A3, A3
9D015914  10E0000C   BEQ A3, ZERO, .LBB964
9D015918  00000000   NOP
387:                 				TFT_24_7789_Write_Data3(c1,c2,c3);
388:                 			else
389:                 				TFT_24_7789_Write_Data3(b1,b2,b3);				
390:                 			if (fl&0x02)
9D014330  0B4050D8   J 0x9D014360
9D014334  30CB0002   ANDI T3, A2, 2
9D01435C  30CB0002   ANDI T3, A2, 2
9D014360  7C0B5C20   SEB T3, T3
9D014364  1160000C   BEQ T3, ZERO, .LBB446
9D014368  00000000   NOP
9D01484C  0B40521F   J 0x9D01487C
9D014850  30650002   ANDI A1, V1, 2
9D014878  30650002   ANDI A1, V1, 2
9D01487C  7C052C20   SEB A1, A1
9D014880  10A0000C   BEQ A1, ZERO, .LBB730
9D014884  00000000   NOP
9D014DD4  0B405381   J 0x9D014E04
9D014DD8  30670002   ANDI A3, V1, 2
9D014E00  30670002   ANDI A3, V1, 2
9D014E04  7C073C20   SEB A3, A3
9D014E08  10E0000C   BEQ A3, ZERO, .LBB656
9D014E0C  00000000   NOP
9D0153B8  0B4054FA   J 0x9D0153E8
9D0153BC  30650002   ANDI A1, V1, 2
9D0153E4  30650002   ANDI A1, V1, 2
9D0153E8  7C052C20   SEB A1, A1
9D0153EC  10A0000C   BEQ A1, ZERO, .LBB1039
9D0153F0  00000000   NOP
9D015940  0B40565C   J 0x9D015970
9D015944  30670002   ANDI A3, V1, 2
9D01596C  30670002   ANDI A3, V1, 2
9D015970  7C073C20   SEB A3, A3
9D015974  10E0000C   BEQ A3, ZERO, .LBB968
9D015978  00000000   NOP
391:                 				TFT_24_7789_Write_Data3(c1,c2,c3);
392:                 			else
393:                 				TFT_24_7789_Write_Data3(b1,b2,b3);
394:                 			if (fl&0x01)
9D014390  0B4050F0   J 0x9D0143C0
9D014394  30C60001   ANDI A2, A2, 1
9D0143BC  30C60001   ANDI A2, A2, 1
9D0143C0  10C0000C   BEQ A2, ZERO, .LBE448, .LBB450
9D0143C4  00000000   NOP
9D0148AC  0B405237   J 0x9D0148DC
9D0148B0  30630001   ANDI V1, V1, 1
9D0148D8  30630001   ANDI V1, V1, 1
9D0148DC  1060000C   BEQ V1, ZERO, .LBE732, .LBB734
9D0148E0  00000000   NOP
9D014E34  0B405399   J 0x9D014E64
9D014E38  30630001   ANDI V1, V1, 1
9D014E60  30630001   ANDI V1, V1, 1
9D014E64  1060000C   BEQ V1, ZERO, .LBE658, .LBB660
9D014E68  00000000   NOP
9D015418  0B405512   J 0x9D015448
9D01541C  30630001   ANDI V1, V1, 1
9D015444  30630001   ANDI V1, V1, 1
9D015448  1060000C   BEQ V1, ZERO, .LBE1041, .LBB1043
9D01544C  00000000   NOP
9D0159A0  0B405674   J 0x9D0159D0
9D0159A4  30630001   ANDI V1, V1, 1
9D0159CC  30630001   ANDI V1, V1, 1
9D0159D0  1060000C   BEQ V1, ZERO, .LBE970, .LBB972
9D0159D4  00000000   NOP
395:                 				TFT_24_7789_Write_Data3(c1,c2,c3);
396:                 			else
397:                 				TFT_24_7789_Write_Data3(b1,b2,b3);	
398:                 			}
399:                 		}
400:                 	}
9D014424  8FBF0034   LW RA, 52(SP)
9D014428  8FBE0030   LW FP, 48(SP)
9D01442C  8FB7002C   LW S7, 44(SP)
9D014430  8FB60028   LW S6, 40(SP)
9D014434  8FB50024   LW S5, 36(SP)
9D014438  8FB40020   LW S4, 32(SP)
9D01443C  8FB3001C   LW S3, 28(SP)
9D014440  8FB20018   LW S2, 24(SP)
9D014444  8FB10014   LW S1, 20(SP)
9D014448  8FB00010   LW S0, 16(SP)
9D01444C  03E00008   JR RA
9D014450  27BD0038   ADDIU SP, SP, 56
401:                 
402:                 
403:                 void tft_fill_area (uint16_t x, uint16_t y, uint16_t xlen, uint16_t ylen, uint32_t back)
404:                 {
9D013CF8  27BDFFC8   ADDIU SP, SP, -56
9D013CFC  AFBF0034   SW RA, 52(SP)
9D013D00  AFBE0030   SW FP, 48(SP)
9D013D04  AFB7002C   SW S7, 44(SP)
9D013D08  AFB60028   SW S6, 40(SP)
9D013D0C  AFB50024   SW S5, 36(SP)
9D013D10  AFB40020   SW S4, 32(SP)
9D013D14  AFB3001C   SW S3, 28(SP)
9D013D18  AFB20018   SW S2, 24(SP)
9D013D1C  AFB10014   SW S1, 20(SP)
9D013D20  AFB00010   SW S0, 16(SP)
9D013D24  0080B021   ADDU S6, A0, ZERO
9D013D28  00A0A821   ADDU S5, A1, ZERO
9D013D2C  00C0F021   ADDU FP, A2, ZERO
9D013D30  00E0B821   ADDU S7, A3, ZERO
9D013D34  8FB10048   LW S1, 72(SP)
405:                     uint32_t i,j;
406:                     tft_set_write_area(x,y,xlen,ylen);
407:                     TFT_24_7789_Write_Command(0x2C);
9D013DE0  0F404EBF   JAL TFT_24_7789_Write_Command
9D013DE4  2404002C   ADDIU A0, ZERO, 44
408:                     //FIXME: Why do I need these +1 adjustments. Off-by-one in tft_set_write_area?
409:                     for (i=0; i<((xlen+1)*(ylen+1)); i++)
9D013DE8  27C70001   ADDIU A3, FP, 1
9D013DEC  26F70001   ADDIU S7, S7, 1
9D013DF0  70F73802   MUL A3, A3, S7
9D013DF4  10E00015   BEQ A3, ZERO, 0x9D013E4C
9D013DF8  8FBF0034   LW RA, 52(SP)
9D013E04  00003021   ADDU A2, ZERO, ZERO
9D013E40  24C60001   ADDIU A2, A2, 1
9D013E44  14C7FFF5   BNE A2, A3, 0x9D013E1C
9D013E48  8FBF0034   LW RA, 52(SP)
410:                     {
411:                         TFT_24_7789_Write_Data3((back>>16)&0xFF,(back>>8)&0xFF,(back>>0)&0xFF);
412:                     }
413:                 }
9D013E4C  8FBE0030   LW FP, 48(SP)
9D013E50  8FB7002C   LW S7, 44(SP)
9D013E54  8FB60028   LW S6, 40(SP)
9D013E58  8FB50024   LW S5, 36(SP)
9D013E5C  8FB40020   LW S4, 32(SP)
9D013E60  8FB3001C   LW S3, 28(SP)
9D013E64  8FB20018   LW S2, 24(SP)
9D013E68  8FB10014   LW S1, 20(SP)
9D013E6C  8FB00010   LW S0, 16(SP)
9D013E70  03E00008   JR RA
9D013E74  27BD0038   ADDIU SP, SP, 56
414:                 
415:                 extern uint16_t myPalette[256];
416:                 
417:                 inline void tft_writebuf (const uint8_t *buf[], uint16_t xlen, uint16_t ylen)
418:                 {
9D013C5C  27BDFFE0   ADDIU SP, SP, -32
9D013C60  AFBF001C   SW RA, 28(SP)
9D013C64  AFB10018   SW S1, 24(SP)
9D013C68  AFB00014   SW S0, 20(SP)
9D013C6C  00808821   ADDU S1, A0, ZERO
419:                     uint32_t i,j;
420:                     tft_set_write_area(0,0,99,99);
9D013C70  00002021   ADDU A0, ZERO, ZERO
9D013C74  00002821   ADDU A1, ZERO, ZERO
9D013C78  24060063   ADDIU A2, ZERO, 99
9D013C7C  0F404ED4   JAL .LFB14, .LFE15, tft_set_write_area
9D013C80  24070063   ADDIU A3, ZERO, 99
421:                     TFT_24_7789_Write_Command(0x2C);
9D013C84  0F404EBF   JAL TFT_24_7789_Write_Command
9D013C88  2404002C   ADDIU A0, ZERO, 44
422:                     //FIXME: Why do I need these +1 adjustments. Off-by-one in tft_set_write_area?
423:                 //    for (i=0; i<((xlen)*(ylen)); i++)
424:                 //    {
425:                 //        //TFT_24_7789_Write_Data3(buf[(3*i)+2],buf[(3*i)+1],buf[3*i]);
426:                 //        //TFT_24_7789_Write_Data33(buf[i], buf[i], buf[i]); 
427:                 //        TFT_24_7789_Write_Data33(buf[i], buf[i], buf[i]);
428:                 //    }
429:                     
430:                     int x,y;
431:                     uint8_t a;
432:                     for (y=0; y<100; y++) {
433:                         for (x=0; x<100; y++) {
9D013C98  0B404F3A   J .LBE218
9D013C9C  3C03BF88   LUI V1, -16504
434:                             
435:                             if (buf == NULL)
9D013CE8  1220FFED   BEQ S1, ZERO, 0x9D013CA0
9D013CEC  00000000   NOP
9D013CF0  0B404F31   J .LBB218
9D013CF4  92300000   LBU S0, 0(S1)
436:                                 TFT_24_7789_Write_Data33(0, 0, 0);
437:                             else
438:                                 a = buf[y*x];
439:                                 TFT_24_7789_Write_Data33(a, a, a);
440:                         }
441:                     }
442:                 }
443:                 
444:                 inline void tft_set_write_area (uint16_t x, uint16_t y, uint16_t xlen, uint16_t ylen)
445:                 	{
9D013B50  27BDFFC8   ADDIU SP, SP, -56
9D013B54  AFBF0034   SW RA, 52(SP)
9D013B58  AFB70030   SW S7, 48(SP)
9D013B5C  AFB6002C   SW S6, 44(SP)
9D013B60  AFB50028   SW S5, 40(SP)
9D013B64  AFB40024   SW S4, 36(SP)
9D013B68  AFB30020   SW S3, 32(SP)
9D013B6C  AFB2001C   SW S2, 28(SP)
9D013B70  AFB10018   SW S1, 24(SP)
9D013B74  AFB00014   SW S0, 20(SP)
9D013B78  0080A821   ADDU S5, A0, ZERO
9D013B7C  00A0A021   ADDU S4, A1, ZERO
9D013B80  00C0B821   ADDU S7, A2, ZERO
9D013B84  00E0B021   ADDU S6, A3, ZERO
446:                 	TFT_24_7789_Write_Command(0x002A);
9D013B88  0F404EBF   JAL TFT_24_7789_Write_Command
9D013B8C  2404002A   ADDIU A0, ZERO, 42
9D013D38  0F404EBF   JAL TFT_24_7789_Write_Command
9D013EC4  0F404EBF   JAL TFT_24_7789_Write_Command
9D01457C  0F404EBF   JAL TFT_24_7789_Write_Command
9D014580  2404002A   ADDIU A0, ZERO, 42
9D014998  0F404EBF   JAL TFT_24_7789_Write_Command
9D01499C  2404002A   ADDIU A0, ZERO, 42
9D0150E4  0F404EBF   JAL TFT_24_7789_Write_Command
9D0150E8  2404002A   ADDIU A0, ZERO, 42
9D015504  0F404EBF   JAL TFT_24_7789_Write_Command
9D015508  2404002A   ADDIU A0, ZERO, 42
447:                 	TFT_24_7789_Write_Data((x>>8)&0xFF);
448:                 	TFT_24_7789_Write_Data((x>>0)&0xFF);
449:                 	TFT_24_7789_Write_Data(((x+xlen)>>8)&0xFF);
9D013BC4  02B7A821   ADDU S5, S5, S7
9D013D74  02DEB021   ADDU S6, S6, FP
9D013F00  27DE0007   ADDIU FP, FP, 7
450:                 	TFT_24_7789_Write_Data(((x+xlen)>>0)&0xFF);
451:                 	TFT_24_7789_Write_Command(0x2B);
9D013BE4  0F404EBF   JAL TFT_24_7789_Write_Command
9D013BE8  2404002B   ADDIU A0, ZERO, 43
9D013D94  0F404EBF   JAL TFT_24_7789_Write_Command
9D013F20  0F404EBF   JAL TFT_24_7789_Write_Command
9D0145D0  0F404EBF   JAL TFT_24_7789_Write_Command
9D0145D4  2404002B   ADDIU A0, ZERO, 43
9D0149E8  0F404EBF   JAL TFT_24_7789_Write_Command
9D0149EC  2404002B   ADDIU A0, ZERO, 43
9D015138  0F404EBF   JAL TFT_24_7789_Write_Command
9D01513C  2404002B   ADDIU A0, ZERO, 43
9D015554  0F404EBF   JAL TFT_24_7789_Write_Command
9D015558  2404002B   ADDIU A0, ZERO, 43
452:                 	TFT_24_7789_Write_Data((y>>8)&0xFF);
453:                 	TFT_24_7789_Write_Data((y>>0)&0xFF);
454:                 	TFT_24_7789_Write_Data(((y+ylen)>>8)&0xFF);
9D013C10  0296A021   ADDU S4, S4, S6
9D013DC0  02B7A821   ADDU S5, S5, S7
9D013F4C  26F7000B   ADDIU S7, S7, 11
9D014F44  8FA40044   LW A0, 68(SP)
9D014F48  2482000B   ADDIU V0, A0, 11
455:                 	TFT_24_7789_Write_Data(((y+ylen)>>0)&0xFF);
456:                 	}
9D013C30  8FBF0034   LW RA, 52(SP)
9D013C34  8FB70030   LW S7, 48(SP)
9D013C38  8FB6002C   LW S6, 44(SP)
9D013C3C  8FB50028   LW S5, 40(SP)
9D013C40  8FB40024   LW S4, 36(SP)
9D013C44  8FB30020   LW S3, 32(SP)
9D013C48  8FB2001C   LW S2, 28(SP)
9D013C4C  8FB10018   LW S1, 24(SP)
9D013C50  8FB00014   LW S0, 20(SP)
9D013C54  03E00008   JR RA
9D013C58  27BD0038   ADDIU SP, SP, 56
457:                 
458:                 
459:                 
460:                 /*******************************************************************************/
461:                 void TFT_24_7789_Write_Command(uint16_t command)
462:                 	{
463:                 	LCD_RD = 1;
9D013AFC  3C02BF88   LUI V0, -16504
9D013B00  94436330   LHU V1, 25392(V0)
9D013B04  24050001   ADDIU A1, ZERO, 1
9D013B08  7CA32944   INS V1, A1, 5, 1
9D013B0C  A4436330   SH V1, 25392(V0)
464:                 	LCD_DC = 0;
9D013B10  3C02BF88   LUI V0, -16504
9D013B14  94436630   LHU V1, 26160(V0)
9D013B18  7C034204   INS V1, ZERO, 8, 1
9D013B1C  A4436630   SH V1, 26160(V0)
465:                 	LCD_WR_CLR;
9D013B20  24030010   ADDIU V1, ZERO, 16
9D013B24  3C06BF88   LUI A2, -16504
9D013B28  ACC36324   SW V1, 25380(A2)
466:                 	LCD_PORT = command;
9D013B2C  3C06BF88   LUI A2, -16504
9D013B30  ACC46430   SW A0, 25648(A2)
467:                 	LCD_WR_SET;
9D013B34  3C04BF88   LUI A0, -16504
9D013B38  AC836328   SW V1, 25384(A0)
468:                 	LCD_DC = 1;
9D013B3C  94436630   LHU V1, 26160(V0)
9D013B40  7CA34204   INS V1, A1, 8, 1
9D013B44  A4436630   SH V1, 26160(V0)
9D013B48  03E00008   JR RA
9D013B4C  00000000   NOP
469:                 	}
470:                 /*******************************************************************************/
471:                 inline void TFT_24_7789_Write_Data(uint16_t data1)
472:                 	{
473:                 	LCD_WR_CLR;
9D013B90  3C13BF88   LUI S3, -16504
9D013BB0  AE706324   SW S0, 25380(S3)
9D013BC0  AE706324   SW S0, 25380(S3)
9D013BD4  AE706324   SW S0, 25380(S3)
9D013BEC  AE706324   SW S0, 25380(S3)
9D013BFC  AE706324   SW S0, 25380(S3)
9D013C0C  AE706324   SW S0, 25380(S3)
9D013C20  AE706324   SW S0, 25380(S3)
9D013D40  3C14BF88   LUI S4, -16504
9D013D60  AE906324   SW S0, 25380(S4)
9D013D70  AE906324   SW S0, 25380(S4)
9D013D84  AE906324   SW S0, 25380(S4)
9D013D9C  AE906324   SW S0, 25380(S4)
9D013DAC  AE906324   SW S0, 25380(S4)
9D013DBC  AE906324   SW S0, 25380(S4)
9D013DD0  AE906324   SW S0, 25380(S4)
9D013ECC  3C16BF88   LUI S6, -16504
9D013EEC  AED36324   SW S3, 25380(S6)
9D013EFC  AED36324   SW S3, 25380(S6)
9D013F10  AED36324   SW S3, 25380(S6)
9D013F28  AED36324   SW S3, 25380(S6)
9D013F38  AED36324   SW S3, 25380(S6)
9D013F48  AED36324   SW S3, 25380(S6)
9D013F5C  AED36324   SW S3, 25380(S6)
9D0144D0  3C16BF88   LUI S6, -16504
9D014584  24030010   ADDIU V1, ZERO, 16
9D014588  AEC36324   SW V1, 25380(S6)
9D01459C  AEC36324   SW V1, 25380(S6)
9D0145AC  AEC36324   SW V1, 25380(S6)
9D0145C0  AEC36324   SW V1, 25380(S6)
9D0145D8  24060010   ADDIU A2, ZERO, 16
9D0145DC  AEC66324   SW A2, 25380(S6)
9D0145EC  AEC66324   SW A2, 25380(S6)
9D0145FC  AEC66324   SW A2, 25380(S6)
9D01460C  AEC66324   SW A2, 25380(S6)
9D0149A0  24120010   ADDIU S2, ZERO, 16
9D0149A4  AED26324   SW S2, 25380(S6)
9D0149B4  AED26324   SW S2, 25380(S6)
9D0149C4  AED26324   SW S2, 25380(S6)
9D0149D8  AED26324   SW S2, 25380(S6)
9D0149F0  AED26324   SW S2, 25380(S6)
9D014A00  AED26324   SW S2, 25380(S6)
9D014A10  AED26324   SW S2, 25380(S6)
9D014A20  AED26324   SW S2, 25380(S6)
9D015038  3C16BF88   LUI S6, -16504
9D0150EC  24030010   ADDIU V1, ZERO, 16
9D0150F0  AEC36324   SW V1, 25380(S6)
9D015104  AEC36324   SW V1, 25380(S6)
9D015114  AEC36324   SW V1, 25380(S6)
9D015128  AEC36324   SW V1, 25380(S6)
9D015140  24020010   ADDIU V0, ZERO, 16
9D015144  AEC26324   SW V0, 25380(S6)
9D015154  AEC26324   SW V0, 25380(S6)
9D015164  AEC26324   SW V0, 25380(S6)
9D015174  AEC26324   SW V0, 25380(S6)
9D01550C  24120010   ADDIU S2, ZERO, 16
9D015510  AED26324   SW S2, 25380(S6)
9D015520  AED26324   SW S2, 25380(S6)
9D015530  AED26324   SW S2, 25380(S6)
9D015544  AED26324   SW S2, 25380(S6)
9D01555C  AED26324   SW S2, 25380(S6)
9D01556C  AED26324   SW S2, 25380(S6)
9D01557C  AED26324   SW S2, 25380(S6)
9D01558C  AED26324   SW S2, 25380(S6)
9D015B0C  24020010   ADDIU V0, ZERO, 16
9D015B10  3C03BF88   LUI V1, -16504
9D015B14  AC626324   SW V0, 25380(V1)
9D015C30  3C13BF88   LUI S3, -16504
9D015C58  AE706324   SW S0, 25380(S3)
9D015C70  AE706324   SW S0, 25380(S3)
9D015C80  AE706324   SW S0, 25380(S3)
9D015C8C  AE706324   SW S0, 25380(S3)
9D015C98  AE706324   SW S0, 25380(S3)
9D015CA8  AE706324   SW S0, 25380(S3)
9D015CBC  AE706324   SW S0, 25380(S3)
9D015CD4  AE706324   SW S0, 25380(S3)
9D015CEC  AE706324   SW S0, 25380(S3)
9D015D04  AE706324   SW S0, 25380(S3)
9D015D10  AE706324   SW S0, 25380(S3)
9D015D28  AE706324   SW S0, 25380(S3)
9D015D40  AE706324   SW S0, 25380(S3)
9D015D58  AE706324   SW S0, 25380(S3)
9D015D70  AE706324   SW S0, 25380(S3)
9D015D80  AE706324   SW S0, 25380(S3)
9D015D98  AE706324   SW S0, 25380(S3)
9D015DA8  AE706324   SW S0, 25380(S3)
9D015DB4  AE706324   SW S0, 25380(S3)
9D015DC4  AE706324   SW S0, 25380(S3)
9D015DD4  AE706324   SW S0, 25380(S3)
9D015DE4  AE706324   SW S0, 25380(S3)
9D015DF4  AE706324   SW S0, 25380(S3)
9D015E04  AE706324   SW S0, 25380(S3)
9D015E14  AE706324   SW S0, 25380(S3)
9D015E24  AE706324   SW S0, 25380(S3)
9D015E34  AE706324   SW S0, 25380(S3)
9D015E40  AE706324   SW S0, 25380(S3)
9D015E50  AE706324   SW S0, 25380(S3)
9D015E60  AE706324   SW S0, 25380(S3)
9D015E78  AE706324   SW S0, 25380(S3)
9D015E84  AE706324   SW S0, 25380(S3)
9D015E90  AE706324   SW S0, 25380(S3)
9D015E9C  AE706324   SW S0, 25380(S3)
9D015EA8  AE706324   SW S0, 25380(S3)
9D015EB4  AE706324   SW S0, 25380(S3)
9D015EC4  AE706324   SW S0, 25380(S3)
9D015ED4  AE706324   SW S0, 25380(S3)
9D015EE4  AE706324   SW S0, 25380(S3)
9D015EF4  AE706324   SW S0, 25380(S3)
9D015F04  AE706324   SW S0, 25380(S3)
9D015F14  AE706324   SW S0, 25380(S3)
9D015F24  AE706324   SW S0, 25380(S3)
9D015F34  AE706324   SW S0, 25380(S3)
9D015F4C  AE706324   SW S0, 25380(S3)
9D015F58  AE706324   SW S0, 25380(S3)
9D015F64  AE706324   SW S0, 25380(S3)
9D015F70  AE706324   SW S0, 25380(S3)
9D015F88  AE706324   SW S0, 25380(S3)
9D015F94  AE706324   SW S0, 25380(S3)
9D015FA0  AE706324   SW S0, 25380(S3)
9D015FAC  AE706324   SW S0, 25380(S3)
474:                 	LCD_PORT = data1;
9D013B9C  00151202   SRL V0, S5, 8
9D013BB4  32A200FF   ANDI V0, S5, 255
9D013BC8  7EA23A00   EXT V0, S5, 8, 8
9D013BCC  AE426430   SW V0, 25648(S2)
9D013BD8  32B500FF   ANDI S5, S5, 255
9D013BF0  00141202   SRL V0, S4, 8
9D013C00  328200FF   ANDI V0, S4, 255
9D013C14  7E823A00   EXT V0, S4, 8, 8
9D013C18  AE426430   SW V0, 25648(S2)
9D013C24  329400FF   ANDI S4, S4, 255
9D013D4C  00161202   SRL V0, S6, 8
9D013D64  32C200FF   ANDI V0, S6, 255
9D013D78  7EC23A00   EXT V0, S6, 8, 8
9D013D88  32D600FF   ANDI S6, S6, 255
9D013DA0  00151202   SRL V0, S5, 8
9D013DB0  32A200FF   ANDI V0, S5, 255
9D013DC4  7EA23A00   EXT V0, S5, 8, 8
9D013DD4  32B500FF   ANDI S5, S5, 255
9D013ED8  001E1202   SRL V0, FP, 8
9D013EF0  33C200FF   ANDI V0, FP, 255
9D013F04  7FC23A00   EXT V0, FP, 8, 8
9D013F14  33DE00FF   ANDI FP, FP, 255
9D013F2C  00171202   SRL V0, S7, 8
9D013F3C  32E200FF   ANDI V0, S7, 255
9D013F50  7EE23A00   EXT V0, S7, 8, 8
9D013F60  32F700FF   ANDI S7, S7, 255
9D0144D4  3C1EBF88   LUI FP, -16504
9D01458C  8FA4001C   LW A0, 28(SP)
9D014590  00041202   SRL V0, A0, 8
9D014594  AFC26430   SW V0, 25648(FP)
9D0145A0  308200F8   ANDI V0, A0, 248
9D0145A4  AFC26430   SW V0, 25648(FP)
9D0145B0  8FA50014   LW A1, 20(SP)
9D0145B4  7CA23A00   EXT V0, A1, 8, 8
9D0145B8  AFC26430   SW V0, 25648(FP)
9D0145C4  30A200FF   ANDI V0, A1, 255
9D0145C8  AFC26430   SW V0, 25648(FP)
9D0145E0  8FA20028   LW V0, 40(SP)
9D0145E4  AFC26430   SW V0, 25648(FP)
9D0145F0  8FA3002C   LW V1, 44(SP)
9D0145F4  AFC36430   SW V1, 25648(FP)
9D014600  8FA40030   LW A0, 48(SP)
9D014604  AFC46430   SW A0, 25648(FP)
9D014610  8FA50034   LW A1, 52(SP)
9D014614  AFC56430   SW A1, 25648(FP)
9D0149A8  00131202   SRL V0, S3, 8
9D0149AC  AFC26430   SW V0, 25648(FP)
9D0149B8  327300F8   ANDI S3, S3, 248
9D0149C8  8FA40014   LW A0, 20(SP)
9D0149DC  308200FF   ANDI V0, A0, 255
9D0149F4  8FA50028   LW A1, 40(SP)
9D014A04  8FA6002C   LW A2, 44(SP)
9D014A14  8FA20030   LW V0, 48(SP)
9D014A24  8FA30034   LW V1, 52(SP)
9D014A28  AFC36430   SW V1, 25648(FP)
9D014F2C  8FA60044   LW A2, 68(SP)
9D014F30  00063202   SRL A2, A2, 8
9D014F34  AFA60028   SW A2, 40(SP)
9D014F38  8FA20044   LW V0, 68(SP)
9D014F3C  304200FF   ANDI V0, V0, 255
9D014F40  AFA2002C   SW V0, 44(SP)
9D014F4C  7C453A00   EXT A1, V0, 8, 8
9D014F50  AFA50030   SW A1, 48(SP)
9D014F54  304200FF   ANDI V0, V0, 255
9D014F58  AFA20034   SW V0, 52(SP)
9D014F78  24020007   ADDIU V0, ZERO, 7
9D014F7C  AFA20014   SW V0, 20(SP)
9D014F80  0B40513D   J 0x9D0144F4
9D014F84  AFA00010   SW ZERO, 16(SP)
9D01503C  3C17BF88   LUI S7, -16504
9D015040  3C029D02   LUI V0, -25342
9D015044  24427F7C   ADDIU V0, V0, 32636
9D015048  AFA20040   SW V0, 64(SP)
9D01504C  244308D0   ADDIU V1, V0, 2256
9D015050  AFA3003C   SW V1, 60(SP)
9D0150F4  8FA40018   LW A0, 24(SP)
9D0150F8  00041202   SRL V0, A0, 8
9D0150FC  AEE26430   SW V0, 25648(S7)
9D015108  308200F8   ANDI V0, A0, 248
9D01510C  AEE26430   SW V0, 25648(S7)
9D015118  8FA60014   LW A2, 20(SP)
9D01511C  7CC23A00   EXT V0, A2, 8, 8
9D015120  AEE26430   SW V0, 25648(S7)
9D01512C  30C200FF   ANDI V0, A2, 255
9D015130  AEE26430   SW V0, 25648(S7)
9D015148  8FA30028   LW V1, 40(SP)
9D01514C  AEE36430   SW V1, 25648(S7)
9D015158  8FA4002C   LW A0, 44(SP)
9D01515C  AEE46430   SW A0, 25648(S7)
9D015168  8FA60030   LW A2, 48(SP)
9D01516C  AEE66430   SW A2, 25648(S7)
9D015178  8FA20034   LW V0, 52(SP)
9D01517C  AEE26430   SW V0, 25648(S7)
9D015514  00131202   SRL V0, S3, 8
9D015518  AEE26430   SW V0, 25648(S7)
9D015524  327300F8   ANDI S3, S3, 248
9D015534  8FA30014   LW V1, 20(SP)
9D015548  306200FF   ANDI V0, V1, 255
9D015560  8FA40028   LW A0, 40(SP)
9D015570  8FA6002C   LW A2, 44(SP)
9D015580  8FA20030   LW V0, 48(SP)
9D015590  8FA30034   LW V1, 52(SP)
9D015594  AEE36430   SW V1, 25648(S7)
9D015A9C  00033202   SRL A2, V1, 8
9D015AA0  AFA60028   SW A2, 40(SP)
9D015AA4  306300FF   ANDI V1, V1, 255
9D015AA8  AFA3002C   SW V1, 44(SP)
9D015AAC  7C833A00   EXT V1, A0, 8, 8
9D015AB0  AFA30030   SW V1, 48(SP)
9D015AB4  304200FF   ANDI V0, V0, 255
9D015AB8  AFA20034   SW V0, 52(SP)
9D015ABC  24040007   ADDIU A0, ZERO, 7
9D015AC0  AFA40014   SW A0, 20(SP)
9D015AC4  AFA00010   SW ZERO, 16(SP)
9D015B18  3C03BF88   LUI V1, -16504
9D015B1C  AC646430   SW A0, 25648(V1)
9D015C3C  3C12BF88   LUI S2, -16504
9D015C5C  24020066   ADDIU V0, ZERO, 102
9D015C74  2415000C   ADDIU S5, ZERO, 12
9D015C84  AE556430   SW S5, 25648(S2)
9D015C90  AE406430   SW ZERO, 25648(S2)
9D015C9C  24020033   ADDIU V0, ZERO, 51
9D015CAC  AE426430   SW V0, 25648(S2)
9D015CC0  24020035   ADDIU V0, ZERO, 53
9D015CC4  AE426430   SW V0, 25648(S2)
9D015CD8  2402002B   ADDIU V0, ZERO, 43
9D015CDC  AE426430   SW V0, 25648(S2)
9D015CF0  2402002C   ADDIU V0, ZERO, 44
9D015CF4  AE426430   SW V0, 25648(S2)
9D015D08  AE546430   SW S4, 25648(S2)
9D015D14  240200FF   ADDIU V0, ZERO, 255
9D015D18  AE426430   SW V0, 25648(S2)
9D015D2C  24020011   ADDIU V0, ZERO, 17
9D015D30  AE426430   SW V0, 25648(S2)
9D015D44  24020020   ADDIU V0, ZERO, 32
9D015D48  AE426430   SW V0, 25648(S2)
9D015D5C  2402000F   ADDIU V0, ZERO, 15
9D015D60  AE426430   SW V0, 25648(S2)
9D015D74  240200A4   ADDIU V0, ZERO, 164
9D015D78  AE426430   SW V0, 25648(S2)
9D015D84  240200A1   ADDIU V0, ZERO, 161
9D015D88  AE426430   SW V0, 25648(S2)
9D015D9C  241E00D0   ADDIU FP, ZERO, 208
9D015DA0  AE5E6430   SW FP, 25648(S2)
9D015DAC  AE406430   SW ZERO, 25648(S2)
9D015DB8  24170005   ADDIU S7, ZERO, 5
9D015DBC  AE576430   SW S7, 25648(S2)
9D015DC8  2402000E   ADDIU V0, ZERO, 14
9D015DCC  AE426430   SW V0, 25648(S2)
9D015DD8  24020015   ADDIU V0, ZERO, 21
9D015DDC  AE426430   SW V0, 25648(S2)
9D015DE8  2416000D   ADDIU S6, ZERO, 13
9D015DEC  AE566430   SW S6, 25648(S2)
9D015DF8  24030037   ADDIU V1, ZERO, 55
9D015DFC  AE436430   SW V1, 25648(S2)
9D015E08  24030043   ADDIU V1, ZERO, 67
9D015E0C  AE436430   SW V1, 25648(S2)
9D015E18  24030047   ADDIU V1, ZERO, 71
9D015E1C  AE436430   SW V1, 25648(S2)
9D015E28  24030009   ADDIU V1, ZERO, 9
9D015E2C  AE436430   SW V1, 25648(S2)
9D015E38  AE426430   SW V0, 25648(S2)
9D015E44  24020012   ADDIU V0, ZERO, 18
9D015E48  AE426430   SW V0, 25648(S2)
9D015E54  24020016   ADDIU V0, ZERO, 22
9D015E58  AE426430   SW V0, 25648(S2)
9D015E64  24020019   ADDIU V0, ZERO, 25
9D015E68  AE426430   SW V0, 25648(S2)
9D015E7C  AE5E6430   SW FP, 25648(S2)
9D015E88  AE406430   SW ZERO, 25648(S2)
9D015E94  AE576430   SW S7, 25648(S2)
9D015EA0  AE566430   SW S6, 25648(S2)
9D015EAC  AE556430   SW S5, 25648(S2)
9D015EB8  24020006   ADDIU V0, ZERO, 6
9D015EBC  AE426430   SW V0, 25648(S2)
9D015EC8  2402002D   ADDIU V0, ZERO, 45
9D015ECC  AE426430   SW V0, 25648(S2)
9D015ED8  24020044   ADDIU V0, ZERO, 68
9D015EDC  AE426430   SW V0, 25648(S2)
9D015EE8  24020040   ADDIU V0, ZERO, 64
9D015EEC  AE426430   SW V0, 25648(S2)
9D015EF8  2402000E   ADDIU V0, ZERO, 14
9D015EFC  AE426430   SW V0, 25648(S2)
9D015F08  2402001C   ADDIU V0, ZERO, 28
9D015F0C  AE426430   SW V0, 25648(S2)
9D015F18  24020018   ADDIU V0, ZERO, 24
9D015F1C  AE426430   SW V0, 25648(S2)
9D015F28  24020016   ADDIU V0, ZERO, 22
9D015F2C  AE426430   SW V0, 25648(S2)
9D015F38  24020019   ADDIU V0, ZERO, 25
9D015F3C  AE426430   SW V0, 25648(S2)
9D015F50  AE406430   SW ZERO, 25648(S2)
9D015F5C  AE406430   SW ZERO, 25648(S2)
9D015F68  AE546430   SW S4, 25648(S2)
9D015F74  2402003F   ADDIU V0, ZERO, 63
9D015F78  AE426430   SW V0, 25648(S2)
9D015F8C  AE406430   SW ZERO, 25648(S2)
9D015F98  AE406430   SW ZERO, 25648(S2)
9D015FA4  AE406430   SW ZERO, 25648(S2)
9D015FB0  240200EF   ADDIU V0, ZERO, 239
9D015FB4  AE426430   SW V0, 25648(S2)
475:                 	LCD_WR_SET;
9D013BA8  3C11BF88   LUI S1, -16504
9D013BBC  AE306328   SW S0, 25384(S1)
9D013BD0  AE306328   SW S0, 25384(S1)
9D013BE0  AE306328   SW S0, 25384(S1)
9D013BF8  AE306328   SW S0, 25384(S1)
9D013C08  AE306328   SW S0, 25384(S1)
9D013C1C  AE306328   SW S0, 25384(S1)
9D013C2C  AE306328   SW S0, 25384(S1)
9D013D58  3C12BF88   LUI S2, -16504
9D013D6C  AE506328   SW S0, 25384(S2)
9D013D80  AE506328   SW S0, 25384(S2)
9D013D90  AE506328   SW S0, 25384(S2)
9D013DA8  AE506328   SW S0, 25384(S2)
9D013DB8  AE506328   SW S0, 25384(S2)
9D013DCC  AE506328   SW S0, 25384(S2)
9D013DDC  AE506328   SW S0, 25384(S2)
9D013EE4  3C14BF88   LUI S4, -16504
9D013EF8  AE936328   SW S3, 25384(S4)
9D013F0C  AE936328   SW S3, 25384(S4)
9D013F1C  AE936328   SW S3, 25384(S4)
9D013F34  AE936328   SW S3, 25384(S4)
9D013F44  AE936328   SW S3, 25384(S4)
9D013F58  AE936328   SW S3, 25384(S4)
9D013F68  AE936328   SW S3, 25384(S4)
9D0144D8  3C17BF88   LUI S7, -16504
9D0144DC  3C029D02   LUI V0, -25342
9D0144E0  24427F7C   ADDIU V0, V0, 32636
9D0144E4  AFA20040   SW V0, 64(SP)
9D0144E8  244208D0   ADDIU V0, V0, 2256
9D0144EC  0B4053CB   J 0x9D014F2C
9D0144F0  AFA2003C   SW V0, 60(SP)
9D0144F4  8FA30010   LW V1, 16(SP)
9D0144F8  3073FFFF   ANDI S3, V1, -1
9D014598  AEE36328   SW V1, 25384(S7)
9D0145A8  AEE36328   SW V1, 25384(S7)
9D0145BC  AEE36328   SW V1, 25384(S7)
9D0145CC  AEE36328   SW V1, 25384(S7)
9D0145E8  AEE66328   SW A2, 25384(S7)
9D0145F8  AEE66328   SW A2, 25384(S7)
9D014608  AEE66328   SW A2, 25384(S7)
9D014618  AEE66328   SW A2, 25384(S7)
9D0149B0  AEF26328   SW S2, 25384(S7)
9D0149C0  AEF26328   SW S2, 25384(S7)
9D0149D4  AEF26328   SW S2, 25384(S7)
9D0149E4  AEF26328   SW S2, 25384(S7)
9D0149FC  AEF26328   SW S2, 25384(S7)
9D014A0C  AEF26328   SW S2, 25384(S7)
9D014A1C  AEF26328   SW S2, 25384(S7)
9D014A2C  AEF26328   SW S2, 25384(S7)
9D015054  0B4056A3   J 0x9D015A8C
9D015058  3C1EBF88   LUI FP, -16504
9D01505C  8FA4007C   LW A0, 124(SP)
9D015060  8FA60020   LW A2, 32(SP)
9D015064  00861021   ADDU V0, A0, A2
9D015068  8FA30010   LW V1, 16(SP)
9D01506C  00431021   ADDU V0, V0, V1
9D015100  AFC36328   SW V1, 25384(FP)
9D015110  AFC36328   SW V1, 25384(FP)
9D015124  AFC36328   SW V1, 25384(FP)
9D015134  AFC36328   SW V1, 25384(FP)
9D015150  AFC26328   SW V0, 25384(FP)
9D015160  AFC26328   SW V0, 25384(FP)
9D015170  AFC26328   SW V0, 25384(FP)
9D015180  24030010   ADDIU V1, ZERO, 16
9D015184  AFC36328   SW V1, 25384(FP)
9D01551C  AFD26328   SW S2, 25384(FP)
9D01552C  AFD26328   SW S2, 25384(FP)
9D015540  AFD26328   SW S2, 25384(FP)
9D015550  AFD26328   SW S2, 25384(FP)
9D015568  AFD26328   SW S2, 25384(FP)
9D015578  AFD26328   SW S2, 25384(FP)
9D015588  AFD26328   SW S2, 25384(FP)
9D015598  AFD26328   SW S2, 25384(FP)
9D015B20  3C03BF88   LUI V1, -16504
9D015B24  AC626328   SW V0, 25384(V1)
9D015B28  03E00008   JR RA
9D015B2C  00000000   NOP
9D015C48  3C11BF88   LUI S1, -16504
9D015C64  AE306328   SW S0, 25384(S1)
9D015C7C  AE306328   SW S0, 25384(S1)
9D015C88  AE306328   SW S0, 25384(S1)
9D015C94  AE306328   SW S0, 25384(S1)
9D015CA4  AE306328   SW S0, 25384(S1)
9D015CB0  AE306328   SW S0, 25384(S1)
9D015CC8  AE306328   SW S0, 25384(S1)
9D015CE0  AE306328   SW S0, 25384(S1)
9D015CF8  AE306328   SW S0, 25384(S1)
9D015D0C  AE306328   SW S0, 25384(S1)
9D015D1C  AE306328   SW S0, 25384(S1)
9D015D34  AE306328   SW S0, 25384(S1)
9D015D4C  AE306328   SW S0, 25384(S1)
9D015D64  AE306328   SW S0, 25384(S1)
9D015D7C  AE306328   SW S0, 25384(S1)
9D015D8C  AE306328   SW S0, 25384(S1)
9D015DA4  AE306328   SW S0, 25384(S1)
9D015DB0  AE306328   SW S0, 25384(S1)
9D015DC0  AE306328   SW S0, 25384(S1)
9D015DD0  AE306328   SW S0, 25384(S1)
9D015DE0  AE306328   SW S0, 25384(S1)
9D015DF0  AE306328   SW S0, 25384(S1)
9D015E00  AE306328   SW S0, 25384(S1)
9D015E10  AE306328   SW S0, 25384(S1)
9D015E20  AE306328   SW S0, 25384(S1)
9D015E30  AE306328   SW S0, 25384(S1)
9D015E3C  AE306328   SW S0, 25384(S1)
9D015E4C  AE306328   SW S0, 25384(S1)
9D015E5C  AE306328   SW S0, 25384(S1)
9D015E6C  AE306328   SW S0, 25384(S1)
9D015E80  AE306328   SW S0, 25384(S1)
9D015E8C  AE306328   SW S0, 25384(S1)
9D015E98  AE306328   SW S0, 25384(S1)
9D015EA4  AE306328   SW S0, 25384(S1)
9D015EB0  AE306328   SW S0, 25384(S1)
9D015EC0  AE306328   SW S0, 25384(S1)
9D015ED0  AE306328   SW S0, 25384(S1)
9D015EE0  AE306328   SW S0, 25384(S1)
9D015EF0  AE306328   SW S0, 25384(S1)
9D015F00  AE306328   SW S0, 25384(S1)
9D015F10  AE306328   SW S0, 25384(S1)
9D015F20  AE306328   SW S0, 25384(S1)
9D015F30  AE306328   SW S0, 25384(S1)
9D015F40  AE306328   SW S0, 25384(S1)
9D015F54  AE306328   SW S0, 25384(S1)
9D015F60  AE306328   SW S0, 25384(S1)
9D015F6C  AE306328   SW S0, 25384(S1)
9D015F7C  AE306328   SW S0, 25384(S1)
9D015F90  AE306328   SW S0, 25384(S1)
9D015F9C  AE306328   SW S0, 25384(S1)
9D015FA8  AE306328   SW S0, 25384(S1)
9D015FB8  AE306328   SW S0, 25384(S1)
476:                 	}
477:                 
478:                 inline void TFT_24_7789_Write_Data3(uint16_t data1,uint16_t data2, uint16_t data3)
479:                 	{
480:                 	LCD_WR_CLR;
9D013E08  02802821   ADDU A1, S4, ZERO
9D013E0C  24020010   ADDIU V0, ZERO, 16
9D013E1C  ACA26324   SW V0, 25380(A1)
9D013F88  02C02821   ADDU A1, S6, ZERO
9D013F8C  24020010   ADDIU V0, ZERO, 16
9D013F98  ACA26324   SW V0, 25380(A1)
9D013FBC  ACA26324   SW V0, 25380(A1)
9D013FE0  ACA26324   SW V0, 25380(A1)
9D014004  ACA26324   SW V0, 25380(A1)
9D014028  ACA26324   SW V0, 25380(A1)
9D01404C  ACA26324   SW V0, 25380(A1)
9D014070  ACA26324   SW V0, 25380(A1)
9D014094  ACA26324   SW V0, 25380(A1)
9D014100  3C05BF88   LUI A1, -16504
9D014104  24020010   ADDIU V0, ZERO, 16
9D01412C  ACA26324   SW V0, 25380(A1)
9D014158  ACA26324   SW V0, 25380(A1)
9D01418C  ACA26324   SW V0, 25380(A1)
9D0141B8  ACA26324   SW V0, 25380(A1)
9D0141EC  ACA26324   SW V0, 25380(A1)
9D014218  ACA26324   SW V0, 25380(A1)
9D01424C  ACA26324   SW V0, 25380(A1)
9D014278  ACA26324   SW V0, 25380(A1)
9D0142AC  ACA26324   SW V0, 25380(A1)
9D0142D8  ACA26324   SW V0, 25380(A1)
9D01430C  ACA26324   SW V0, 25380(A1)
9D014338  ACA26324   SW V0, 25380(A1)
9D01436C  ACA26324   SW V0, 25380(A1)
9D014398  ACA26324   SW V0, 25380(A1)
9D0143C8  ACA26324   SW V0, 25380(A1)
9D0143F4  ACA26324   SW V0, 25380(A1)
9D01462C  24020010   ADDIU V0, ZERO, 16
9D014630  8FA6003C   LW A2, 60(SP)
9D014648  AEC26324   SW V0, 25380(S6)
9D014674  AEC26324   SW V0, 25380(S6)
9D0146A8  AEC26324   SW V0, 25380(S6)
9D0146D4  AEC26324   SW V0, 25380(S6)
9D014708  AEC26324   SW V0, 25380(S6)
9D014734  AEC26324   SW V0, 25380(S6)
9D014768  AEC26324   SW V0, 25380(S6)
9D014794  AEC26324   SW V0, 25380(S6)
9D0147C8  AEC26324   SW V0, 25380(S6)
9D0147F4  AEC26324   SW V0, 25380(S6)
9D014828  AEC26324   SW V0, 25380(S6)
9D014854  AEC26324   SW V0, 25380(S6)
9D014888  AEC26324   SW V0, 25380(S6)
9D0148B4  AEC26324   SW V0, 25380(S6)
9D0148E4  AEC26324   SW V0, 25380(S6)
9D014910  AEC26324   SW V0, 25380(S6)
9D014A4C  24020010   ADDIU V0, ZERO, 16
9D014A50  AEC26324   SW V0, 25380(S6)
9D014A74  AEC26324   SW V0, 25380(S6)
9D014A98  AEC26324   SW V0, 25380(S6)
9D014ABC  AEC26324   SW V0, 25380(S6)
9D014AE0  AEC26324   SW V0, 25380(S6)
9D014B04  AEC26324   SW V0, 25380(S6)
9D014B28  AEC26324   SW V0, 25380(S6)
9D014B4C  AEC26324   SW V0, 25380(S6)
9D014BB0  24020010   ADDIU V0, ZERO, 16
9D014BD0  AEC26324   SW V0, 25380(S6)
9D014BFC  AEC26324   SW V0, 25380(S6)
9D014C30  AEC26324   SW V0, 25380(S6)
9D014C5C  AEC26324   SW V0, 25380(S6)
9D014C90  AEC26324   SW V0, 25380(S6)
9D014CBC  AEC26324   SW V0, 25380(S6)
9D014CF0  AEC26324   SW V0, 25380(S6)
9D014D1C  AEC26324   SW V0, 25380(S6)
9D014D50  AEC26324   SW V0, 25380(S6)
9D014D7C  AEC26324   SW V0, 25380(S6)
9D014DB0  AEC26324   SW V0, 25380(S6)
9D014DDC  AEC26324   SW V0, 25380(S6)
9D014E10  AEC26324   SW V0, 25380(S6)
9D014E3C  AEC26324   SW V0, 25380(S6)
9D014E6C  AEC26324   SW V0, 25380(S6)
9D014E98  AEC26324   SW V0, 25380(S6)
9D015198  24020010   ADDIU V0, ZERO, 16
9D01519C  8FA6003C   LW A2, 60(SP)
9D0151B4  AEC26324   SW V0, 25380(S6)
9D0151E0  AEC26324   SW V0, 25380(S6)
9D015214  AEC26324   SW V0, 25380(S6)
9D015240  AEC26324   SW V0, 25380(S6)
9D015274  AEC26324   SW V0, 25380(S6)
9D0152A0  AEC26324   SW V0, 25380(S6)
9D0152D4  AEC26324   SW V0, 25380(S6)
9D015300  AEC26324   SW V0, 25380(S6)
9D015334  AEC26324   SW V0, 25380(S6)
9D015360  AEC26324   SW V0, 25380(S6)
9D015394  AEC26324   SW V0, 25380(S6)
9D0153C0  AEC26324   SW V0, 25380(S6)
9D0153F4  AEC26324   SW V0, 25380(S6)
9D015420  AEC26324   SW V0, 25380(S6)
9D015450  AEC26324   SW V0, 25380(S6)
9D01547C  AEC26324   SW V0, 25380(S6)
9D0155B8  24020010   ADDIU V0, ZERO, 16
9D0155BC  AEC26324   SW V0, 25380(S6)
9D0155E0  AEC26324   SW V0, 25380(S6)
9D015604  AEC26324   SW V0, 25380(S6)
9D015628  AEC26324   SW V0, 25380(S6)
9D01564C  AEC26324   SW V0, 25380(S6)
9D015670  AEC26324   SW V0, 25380(S6)
9D015694  AEC26324   SW V0, 25380(S6)
9D0156B8  AEC26324   SW V0, 25380(S6)
9D01571C  24020010   ADDIU V0, ZERO, 16
9D01573C  AEC26324   SW V0, 25380(S6)
9D015768  AEC26324   SW V0, 25380(S6)
9D01579C  AEC26324   SW V0, 25380(S6)
9D0157C8  AEC26324   SW V0, 25380(S6)
9D0157FC  AEC26324   SW V0, 25380(S6)
9D015828  AEC26324   SW V0, 25380(S6)
9D01585C  AEC26324   SW V0, 25380(S6)
9D015888  AEC26324   SW V0, 25380(S6)
9D0158BC  AEC26324   SW V0, 25380(S6)
9D0158E8  AEC26324   SW V0, 25380(S6)
9D01591C  AEC26324   SW V0, 25380(S6)
9D015948  AEC26324   SW V0, 25380(S6)
9D01597C  AEC26324   SW V0, 25380(S6)
9D0159A8  AEC26324   SW V0, 25380(S6)
9D0159D8  AEC26324   SW V0, 25380(S6)
9D015A04  AEC26324   SW V0, 25380(S6)
9D015B30  3C08BF88   LUI T0, -16504
9D015B34  24020010   ADDIU V0, ZERO, 16
9D015B38  AD026324   SW V0, 25380(T0)
481:                 	LCD_PORT = data1;
9D013DFC  7E2A3C00   EXT T2, S1, 16, 8
9D013E10  02602021   ADDU A0, S3, ZERO
9D013E20  AC8A6430   SW T2, 25648(A0)
9D013F90  02A02021   ADDU A0, S5, ZERO
9D013F9C  AC906430   SW S0, 25648(A0)
9D013FC0  AC906430   SW S0, 25648(A0)
9D013FE4  AC906430   SW S0, 25648(A0)
9D014008  AC906430   SW S0, 25648(A0)
9D01402C  AC906430   SW S0, 25648(A0)
9D014050  AC906430   SW S0, 25648(A0)
9D014074  AC906430   SW S0, 25648(A0)
9D014098  AC906430   SW S0, 25648(A0)
9D014108  3C04BF88   LUI A0, -16504
9D014130  AC8A6430   SW T2, 25648(A0)
9D01415C  AC906430   SW S0, 25648(A0)
9D014190  AC8A6430   SW T2, 25648(A0)
9D0141BC  AC906430   SW S0, 25648(A0)
9D0141F0  AC8A6430   SW T2, 25648(A0)
9D01421C  AC906430   SW S0, 25648(A0)
9D014250  AC8A6430   SW T2, 25648(A0)
9D01427C  AC906430   SW S0, 25648(A0)
9D0142B0  AC8A6430   SW T2, 25648(A0)
9D0142DC  AC906430   SW S0, 25648(A0)
9D014310  AC8A6430   SW T2, 25648(A0)
9D01433C  AC906430   SW S0, 25648(A0)
9D014370  AC8A6430   SW T2, 25648(A0)
9D01439C  AC906430   SW S0, 25648(A0)
9D0143CC  AC8A6430   SW T2, 25648(A0)
9D0143F8  AC906430   SW S0, 25648(A0)
9D01464C  AFD36430   SW S3, 25648(FP)
9D014678  AFD06430   SW S0, 25648(FP)
9D0146AC  AFD36430   SW S3, 25648(FP)
9D0146D8  AFD06430   SW S0, 25648(FP)
9D01470C  AFD36430   SW S3, 25648(FP)
9D014738  AFD06430   SW S0, 25648(FP)
9D01476C  AFD36430   SW S3, 25648(FP)
9D014798  AFD06430   SW S0, 25648(FP)
9D0147CC  AFD36430   SW S3, 25648(FP)
9D0147F8  AFD06430   SW S0, 25648(FP)
9D01482C  AFD36430   SW S3, 25648(FP)
9D014858  AFD06430   SW S0, 25648(FP)
9D01488C  AFD36430   SW S3, 25648(FP)
9D0148B8  AFD06430   SW S0, 25648(FP)
9D0148E8  AFD36430   SW S3, 25648(FP)
9D014914  AFD06430   SW S0, 25648(FP)
9D014A54  AFD46430   SW S4, 25648(FP)
9D014A78  AFD46430   SW S4, 25648(FP)
9D014A9C  AFD46430   SW S4, 25648(FP)
9D014AC0  AFD46430   SW S4, 25648(FP)
9D014AE4  AFD46430   SW S4, 25648(FP)
9D014B08  AFD46430   SW S4, 25648(FP)
9D014B2C  AFD46430   SW S4, 25648(FP)
9D014B50  AFD46430   SW S4, 25648(FP)
9D014BD4  AFC66430   SW A2, 25648(FP)
9D014C00  AFD46430   SW S4, 25648(FP)
9D014C34  AFC66430   SW A2, 25648(FP)
9D014C60  AFD46430   SW S4, 25648(FP)
9D014C94  AFC66430   SW A2, 25648(FP)
9D014CC0  AFD46430   SW S4, 25648(FP)
9D014CF4  AFC66430   SW A2, 25648(FP)
9D014D20  AFD46430   SW S4, 25648(FP)
9D014D54  AFC66430   SW A2, 25648(FP)
9D014D80  AFD46430   SW S4, 25648(FP)
9D014DB4  AFC66430   SW A2, 25648(FP)
9D014DE0  AFD46430   SW S4, 25648(FP)
9D014E14  AFC66430   SW A2, 25648(FP)
9D014E40  AFD46430   SW S4, 25648(FP)
9D014E70  AFC66430   SW A2, 25648(FP)
9D014E9C  AFD46430   SW S4, 25648(FP)
9D0151B8  AEF36430   SW S3, 25648(S7)
9D0151E4  AEF06430   SW S0, 25648(S7)
9D015218  AEF36430   SW S3, 25648(S7)
9D015244  AEF06430   SW S0, 25648(S7)
9D015278  AEF36430   SW S3, 25648(S7)
9D0152A4  AEF06430   SW S0, 25648(S7)
9D0152D8  AEF36430   SW S3, 25648(S7)
9D015304  AEF06430   SW S0, 25648(S7)
9D015338  AEF36430   SW S3, 25648(S7)
9D015364  AEF06430   SW S0, 25648(S7)
9D015398  AEF36430   SW S3, 25648(S7)
9D0153C4  AEF06430   SW S0, 25648(S7)
9D0153F8  AEF36430   SW S3, 25648(S7)
9D015424  AEF06430   SW S0, 25648(S7)
9D015454  AEF36430   SW S3, 25648(S7)
9D015480  AEF06430   SW S0, 25648(S7)
9D0155C0  AEF46430   SW S4, 25648(S7)
9D0155E4  AEF46430   SW S4, 25648(S7)
9D015608  AEF46430   SW S4, 25648(S7)
9D01562C  AEF46430   SW S4, 25648(S7)
9D015650  AEF46430   SW S4, 25648(S7)
9D015674  AEF46430   SW S4, 25648(S7)
9D015698  AEF46430   SW S4, 25648(S7)
9D0156BC  AEF46430   SW S4, 25648(S7)
9D015740  AEE66430   SW A2, 25648(S7)
9D01576C  AEF46430   SW S4, 25648(S7)
9D0157A0  AEE66430   SW A2, 25648(S7)
9D0157CC  AEF46430   SW S4, 25648(S7)
9D015800  AEE66430   SW A2, 25648(S7)
9D01582C  AEF46430   SW S4, 25648(S7)
9D015860  AEE66430   SW A2, 25648(S7)
9D01588C  AEF46430   SW S4, 25648(S7)
9D0158C0  AEE66430   SW A2, 25648(S7)
9D0158EC  AEF46430   SW S4, 25648(S7)
9D015920  AEE66430   SW A2, 25648(S7)
9D01594C  AEF46430   SW S4, 25648(S7)
9D015980  AEE66430   SW A2, 25648(S7)
9D0159AC  AEF46430   SW S4, 25648(S7)
9D0159DC  AEE66430   SW A2, 25648(S7)
9D015A08  AEF46430   SW S4, 25648(S7)
9D015B3C  3C07BF88   LUI A3, -16504
9D015B40  ACE46430   SW A0, 25648(A3)
482:                 	LCD_WR_SET;
9D013E14  02401821   ADDU V1, S2, ZERO
9D013E24  AC626328   SW V0, 25384(V1)
9D013F94  02801821   ADDU V1, S4, ZERO
9D013FA0  AC626328   SW V0, 25384(V1)
9D013FC4  AC626328   SW V0, 25384(V1)
9D013FE8  AC626328   SW V0, 25384(V1)
9D01400C  AC626328   SW V0, 25384(V1)
9D014030  AC626328   SW V0, 25384(V1)
9D014054  AC626328   SW V0, 25384(V1)
9D014078  AC626328   SW V0, 25384(V1)
9D01409C  AC626328   SW V0, 25384(V1)
9D01410C  3C03BF88   LUI V1, -16504
9D014134  AC626328   SW V0, 25384(V1)
9D014160  AC626328   SW V0, 25384(V1)
9D014194  AC626328   SW V0, 25384(V1)
9D0141C0  AC626328   SW V0, 25384(V1)
9D0141F4  AC626328   SW V0, 25384(V1)
9D014220  AC626328   SW V0, 25384(V1)
9D014254  AC626328   SW V0, 25384(V1)
9D014280  AC626328   SW V0, 25384(V1)
9D0142B4  AC626328   SW V0, 25384(V1)
9D0142E0  AC626328   SW V0, 25384(V1)
9D014314  AC626328   SW V0, 25384(V1)
9D014340  AC626328   SW V0, 25384(V1)
9D014374  AC626328   SW V0, 25384(V1)
9D0143A0  AC626328   SW V0, 25384(V1)
9D0143D0  AC626328   SW V0, 25384(V1)
9D0143FC  AC626328   SW V0, 25384(V1)
9D014650  AEE26328   SW V0, 25384(S7)
9D01467C  AEE26328   SW V0, 25384(S7)
9D0146B0  AEE26328   SW V0, 25384(S7)
9D0146DC  AEE26328   SW V0, 25384(S7)
9D014710  AEE26328   SW V0, 25384(S7)
9D01473C  AEE26328   SW V0, 25384(S7)
9D014770  AEE26328   SW V0, 25384(S7)
9D01479C  AEE26328   SW V0, 25384(S7)
9D0147D0  AEE26328   SW V0, 25384(S7)
9D0147FC  AEE26328   SW V0, 25384(S7)
9D014830  AEE26328   SW V0, 25384(S7)
9D01485C  AEE26328   SW V0, 25384(S7)
9D014890  AEE26328   SW V0, 25384(S7)
9D0148BC  AEE26328   SW V0, 25384(S7)
9D0148EC  AEE26328   SW V0, 25384(S7)
9D014918  AEE26328   SW V0, 25384(S7)
9D014A58  AEE26328   SW V0, 25384(S7)
9D014A7C  AEE26328   SW V0, 25384(S7)
9D014AA0  AEE26328   SW V0, 25384(S7)
9D014AC4  AEE26328   SW V0, 25384(S7)
9D014AE8  AEE26328   SW V0, 25384(S7)
9D014B0C  AEE26328   SW V0, 25384(S7)
9D014B30  AEE26328   SW V0, 25384(S7)
9D014B54  AEE26328   SW V0, 25384(S7)
9D014BD8  AEE26328   SW V0, 25384(S7)
9D014C04  AEE26328   SW V0, 25384(S7)
9D014C38  AEE26328   SW V0, 25384(S7)
9D014C64  AEE26328   SW V0, 25384(S7)
9D014C98  AEE26328   SW V0, 25384(S7)
9D014CC4  AEE26328   SW V0, 25384(S7)
9D014CF8  AEE26328   SW V0, 25384(S7)
9D014D24  AEE26328   SW V0, 25384(S7)
9D014D58  AEE26328   SW V0, 25384(S7)
9D014D84  AEE26328   SW V0, 25384(S7)
9D014DB8  AEE26328   SW V0, 25384(S7)
9D014DE4  AEE26328   SW V0, 25384(S7)
9D014E18  AEE26328   SW V0, 25384(S7)
9D014E44  AEE26328   SW V0, 25384(S7)
9D014E74  AEE26328   SW V0, 25384(S7)
9D014EA0  AEE26328   SW V0, 25384(S7)
9D0151BC  AFC26328   SW V0, 25384(FP)
9D0151E8  AFC26328   SW V0, 25384(FP)
9D01521C  AFC26328   SW V0, 25384(FP)
9D015248  AFC26328   SW V0, 25384(FP)
9D01527C  AFC26328   SW V0, 25384(FP)
9D0152A8  AFC26328   SW V0, 25384(FP)
9D0152DC  AFC26328   SW V0, 25384(FP)
9D015308  AFC26328   SW V0, 25384(FP)
9D01533C  AFC26328   SW V0, 25384(FP)
9D015368  AFC26328   SW V0, 25384(FP)
9D01539C  AFC26328   SW V0, 25384(FP)
9D0153C8  AFC26328   SW V0, 25384(FP)
9D0153FC  AFC26328   SW V0, 25384(FP)
9D015428  AFC26328   SW V0, 25384(FP)
9D015458  AFC26328   SW V0, 25384(FP)
9D015484  AFC26328   SW V0, 25384(FP)
9D0155C4  AFC26328   SW V0, 25384(FP)
9D0155E8  AFC26328   SW V0, 25384(FP)
9D01560C  AFC26328   SW V0, 25384(FP)
9D015630  AFC26328   SW V0, 25384(FP)
9D015654  AFC26328   SW V0, 25384(FP)
9D015678  AFC26328   SW V0, 25384(FP)
9D01569C  AFC26328   SW V0, 25384(FP)
9D0156C0  AFC26328   SW V0, 25384(FP)
9D015744  AFC26328   SW V0, 25384(FP)
9D015770  AFC26328   SW V0, 25384(FP)
9D0157A4  AFC26328   SW V0, 25384(FP)
9D0157D0  AFC26328   SW V0, 25384(FP)
9D015804  AFC26328   SW V0, 25384(FP)
9D015830  AFC26328   SW V0, 25384(FP)
9D015864  AFC26328   SW V0, 25384(FP)
9D015890  AFC26328   SW V0, 25384(FP)
9D0158C4  AFC26328   SW V0, 25384(FP)
9D0158F0  AFC26328   SW V0, 25384(FP)
9D015924  AFC26328   SW V0, 25384(FP)
9D015950  AFC26328   SW V0, 25384(FP)
9D015984  AFC26328   SW V0, 25384(FP)
9D0159B0  AFC26328   SW V0, 25384(FP)
9D0159E0  AFC26328   SW V0, 25384(FP)
9D015A0C  AFC26328   SW V0, 25384(FP)
9D015B44  3C03BF88   LUI V1, -16504
9D015B48  AC626328   SW V0, 25384(V1)
483:                 	LCD_WR_CLR;
9D013E28  ACA26324   SW V0, 25380(A1)
9D013FA4  ACA26324   SW V0, 25380(A1)
9D013FC8  ACA26324   SW V0, 25380(A1)
9D013FEC  ACA26324   SW V0, 25380(A1)
9D014010  ACA26324   SW V0, 25380(A1)
9D014034  ACA26324   SW V0, 25380(A1)
9D014058  ACA26324   SW V0, 25380(A1)
9D01407C  ACA26324   SW V0, 25380(A1)
9D0140A0  ACA26324   SW V0, 25380(A1)
9D014138  ACA26324   SW V0, 25380(A1)
9D014164  ACA26324   SW V0, 25380(A1)
9D014198  ACA26324   SW V0, 25380(A1)
9D0141C4  ACA26324   SW V0, 25380(A1)
9D0141F8  ACA26324   SW V0, 25380(A1)
9D014224  ACA26324   SW V0, 25380(A1)
9D014258  ACA26324   SW V0, 25380(A1)
9D014284  ACA26324   SW V0, 25380(A1)
9D0142B8  ACA26324   SW V0, 25380(A1)
9D0142E4  ACA26324   SW V0, 25380(A1)
9D014318  ACA26324   SW V0, 25380(A1)
9D014344  ACA26324   SW V0, 25380(A1)
9D014378  ACA26324   SW V0, 25380(A1)
9D0143A4  ACA26324   SW V0, 25380(A1)
9D0143D4  ACA26324   SW V0, 25380(A1)
9D014400  ACA26324   SW V0, 25380(A1)
9D014654  AEC26324   SW V0, 25380(S6)
9D014680  AEC26324   SW V0, 25380(S6)
9D0146B4  AEC26324   SW V0, 25380(S6)
9D0146E0  AEC26324   SW V0, 25380(S6)
9D014714  AEC26324   SW V0, 25380(S6)
9D014740  AEC26324   SW V0, 25380(S6)
9D014774  AEC26324   SW V0, 25380(S6)
9D0147A0  AEC26324   SW V0, 25380(S6)
9D0147D4  AEC26324   SW V0, 25380(S6)
9D014800  AEC26324   SW V0, 25380(S6)
9D014834  AEC26324   SW V0, 25380(S6)
9D014860  AEC26324   SW V0, 25380(S6)
9D014894  AEC26324   SW V0, 25380(S6)
9D0148C0  AEC26324   SW V0, 25380(S6)
9D0148F0  AEC26324   SW V0, 25380(S6)
9D01491C  AEC26324   SW V0, 25380(S6)
9D014A5C  AEC26324   SW V0, 25380(S6)
9D014A80  AEC26324   SW V0, 25380(S6)
9D014AA4  AEC26324   SW V0, 25380(S6)
9D014AC8  AEC26324   SW V0, 25380(S6)
9D014AEC  AEC26324   SW V0, 25380(S6)
9D014B10  AEC26324   SW V0, 25380(S6)
9D014B34  AEC26324   SW V0, 25380(S6)
9D014B58  AEC26324   SW V0, 25380(S6)
9D014BDC  AEC26324   SW V0, 25380(S6)
9D014C08  AEC26324   SW V0, 25380(S6)
9D014C3C  AEC26324   SW V0, 25380(S6)
9D014C68  AEC26324   SW V0, 25380(S6)
9D014C9C  AEC26324   SW V0, 25380(S6)
9D014CC8  AEC26324   SW V0, 25380(S6)
9D014CFC  AEC26324   SW V0, 25380(S6)
9D014D28  AEC26324   SW V0, 25380(S6)
9D014D5C  AEC26324   SW V0, 25380(S6)
9D014D88  AEC26324   SW V0, 25380(S6)
9D014DBC  AEC26324   SW V0, 25380(S6)
9D014DE8  AEC26324   SW V0, 25380(S6)
9D014E1C  AEC26324   SW V0, 25380(S6)
9D014E48  AEC26324   SW V0, 25380(S6)
9D014E78  AEC26324   SW V0, 25380(S6)
9D014EA4  AEC26324   SW V0, 25380(S6)
9D0151C0  AEC26324   SW V0, 25380(S6)
9D0151EC  AEC26324   SW V0, 25380(S6)
9D015220  AEC26324   SW V0, 25380(S6)
9D01524C  AEC26324   SW V0, 25380(S6)
9D015280  AEC26324   SW V0, 25380(S6)
9D0152AC  AEC26324   SW V0, 25380(S6)
9D0152E0  AEC26324   SW V0, 25380(S6)
9D01530C  AEC26324   SW V0, 25380(S6)
9D015340  AEC26324   SW V0, 25380(S6)
9D01536C  AEC26324   SW V0, 25380(S6)
9D0153A0  AEC26324   SW V0, 25380(S6)
9D0153CC  AEC26324   SW V0, 25380(S6)
9D015400  AEC26324   SW V0, 25380(S6)
9D01542C  AEC26324   SW V0, 25380(S6)
9D01545C  AEC26324   SW V0, 25380(S6)
9D015488  AEC26324   SW V0, 25380(S6)
9D0155C8  AEC26324   SW V0, 25380(S6)
9D0155EC  AEC26324   SW V0, 25380(S6)
9D015610  AEC26324   SW V0, 25380(S6)
9D015634  AEC26324   SW V0, 25380(S6)
9D015658  AEC26324   SW V0, 25380(S6)
9D01567C  AEC26324   SW V0, 25380(S6)
9D0156A0  AEC26324   SW V0, 25380(S6)
9D0156C4  AEC26324   SW V0, 25380(S6)
9D015748  AEC26324   SW V0, 25380(S6)
9D015774  AEC26324   SW V0, 25380(S6)
9D0157A8  AEC26324   SW V0, 25380(S6)
9D0157D4  AEC26324   SW V0, 25380(S6)
9D015808  AEC26324   SW V0, 25380(S6)
9D015834  AEC26324   SW V0, 25380(S6)
9D015868  AEC26324   SW V0, 25380(S6)
9D015894  AEC26324   SW V0, 25380(S6)
9D0158C8  AEC26324   SW V0, 25380(S6)
9D0158F4  AEC26324   SW V0, 25380(S6)
9D015928  AEC26324   SW V0, 25380(S6)
9D015954  AEC26324   SW V0, 25380(S6)
9D015988  AEC26324   SW V0, 25380(S6)
9D0159B4  AEC26324   SW V0, 25380(S6)
9D0159E4  AEC26324   SW V0, 25380(S6)
9D015A10  AEC26324   SW V0, 25380(S6)
9D015B4C  AD026324   SW V0, 25380(T0)
484:                 	LCD_PORT = data2;
9D013E00  7E293A00   EXT T1, S1, 8, 8
9D013E2C  AC896430   SW T1, 25648(A0)
9D013FA8  AC916430   SW S1, 25648(A0)
9D013FCC  AC916430   SW S1, 25648(A0)
9D013FF0  AC916430   SW S1, 25648(A0)
9D014014  AC916430   SW S1, 25648(A0)
9D014038  AC916430   SW S1, 25648(A0)
9D01405C  AC916430   SW S1, 25648(A0)
9D014080  AC916430   SW S1, 25648(A0)
9D0140A4  AC916430   SW S1, 25648(A0)
9D01413C  AC896430   SW T1, 25648(A0)
9D014168  AC916430   SW S1, 25648(A0)
9D01419C  AC896430   SW T1, 25648(A0)
9D0141C8  AC916430   SW S1, 25648(A0)
9D0141FC  AC896430   SW T1, 25648(A0)
9D014228  AC916430   SW S1, 25648(A0)
9D01425C  AC896430   SW T1, 25648(A0)
9D014288  AC916430   SW S1, 25648(A0)
9D0142BC  AC896430   SW T1, 25648(A0)
9D0142E8  AC916430   SW S1, 25648(A0)
9D01431C  AC896430   SW T1, 25648(A0)
9D014348  AC916430   SW S1, 25648(A0)
9D01437C  AC896430   SW T1, 25648(A0)
9D0143A8  AC916430   SW S1, 25648(A0)
9D0143D8  AC896430   SW T1, 25648(A0)
9D014404  AC916430   SW S1, 25648(A0)
9D014658  AFD26430   SW S2, 25648(FP)
9D014684  AFD46430   SW S4, 25648(FP)
9D0146B8  AFD26430   SW S2, 25648(FP)
9D0146E4  AFD46430   SW S4, 25648(FP)
9D014718  AFD26430   SW S2, 25648(FP)
9D014744  AFD46430   SW S4, 25648(FP)
9D014778  AFD26430   SW S2, 25648(FP)
9D0147A4  AFD46430   SW S4, 25648(FP)
9D0147D8  AFD26430   SW S2, 25648(FP)
9D014804  AFD46430   SW S4, 25648(FP)
9D014838  AFD26430   SW S2, 25648(FP)
9D014864  AFD46430   SW S4, 25648(FP)
9D014898  AFD26430   SW S2, 25648(FP)
9D0148C4  AFD46430   SW S4, 25648(FP)
9D0148F4  AFD26430   SW S2, 25648(FP)
9D014920  AFD46430   SW S4, 25648(FP)
9D014A60  AFD06430   SW S0, 25648(FP)
9D014A84  AFD06430   SW S0, 25648(FP)
9D014AA8  AFD06430   SW S0, 25648(FP)
9D014ACC  AFD06430   SW S0, 25648(FP)
9D014AF0  AFD06430   SW S0, 25648(FP)
9D014B14  AFD06430   SW S0, 25648(FP)
9D014B38  AFD06430   SW S0, 25648(FP)
9D014B5C  AFD06430   SW S0, 25648(FP)
9D014BE0  AFC56430   SW A1, 25648(FP)
9D014C0C  AFD06430   SW S0, 25648(FP)
9D014C40  AFC56430   SW A1, 25648(FP)
9D014C6C  AFD06430   SW S0, 25648(FP)
9D014CA0  AFC56430   SW A1, 25648(FP)
9D014CCC  AFD06430   SW S0, 25648(FP)
9D014D00  AFC56430   SW A1, 25648(FP)
9D014D2C  AFD06430   SW S0, 25648(FP)
9D014D60  AFC56430   SW A1, 25648(FP)
9D014D8C  AFD06430   SW S0, 25648(FP)
9D014DC0  AFC56430   SW A1, 25648(FP)
9D014DEC  AFD06430   SW S0, 25648(FP)
9D014E20  AFC56430   SW A1, 25648(FP)
9D014E4C  AFD06430   SW S0, 25648(FP)
9D014E7C  AFC56430   SW A1, 25648(FP)
9D014EA8  AFD06430   SW S0, 25648(FP)
9D0151C4  AEF26430   SW S2, 25648(S7)
9D0151F0  AEF46430   SW S4, 25648(S7)
9D015224  AEF26430   SW S2, 25648(S7)
9D015250  AEF46430   SW S4, 25648(S7)
9D015284  AEF26430   SW S2, 25648(S7)
9D0152B0  AEF46430   SW S4, 25648(S7)
9D0152E4  AEF26430   SW S2, 25648(S7)
9D015310  AEF46430   SW S4, 25648(S7)
9D015344  AEF26430   SW S2, 25648(S7)
9D015370  AEF46430   SW S4, 25648(S7)
9D0153A4  AEF26430   SW S2, 25648(S7)
9D0153D0  AEF46430   SW S4, 25648(S7)
9D015404  AEF26430   SW S2, 25648(S7)
9D015430  AEF46430   SW S4, 25648(S7)
9D015460  AEF26430   SW S2, 25648(S7)
9D01548C  AEF46430   SW S4, 25648(S7)
9D0155CC  AEF06430   SW S0, 25648(S7)
9D0155F0  AEF06430   SW S0, 25648(S7)
9D015614  AEF06430   SW S0, 25648(S7)
9D015638  AEF06430   SW S0, 25648(S7)
9D01565C  AEF06430   SW S0, 25648(S7)
9D015680  AEF06430   SW S0, 25648(S7)
9D0156A4  AEF06430   SW S0, 25648(S7)
9D0156C8  AEF06430   SW S0, 25648(S7)
9D01574C  AEE56430   SW A1, 25648(S7)
9D015778  AEF06430   SW S0, 25648(S7)
9D0157AC  AEE56430   SW A1, 25648(S7)
9D0157D8  AEF06430   SW S0, 25648(S7)
9D01580C  AEE56430   SW A1, 25648(S7)
9D015838  AEF06430   SW S0, 25648(S7)
9D01586C  AEE56430   SW A1, 25648(S7)
9D015898  AEF06430   SW S0, 25648(S7)
9D0158CC  AEE56430   SW A1, 25648(S7)
9D0158F8  AEF06430   SW S0, 25648(S7)
9D01592C  AEE56430   SW A1, 25648(S7)
9D015958  AEF06430   SW S0, 25648(S7)
9D01598C  AEE56430   SW A1, 25648(S7)
9D0159B8  AEF06430   SW S0, 25648(S7)
9D0159E8  AEE56430   SW A1, 25648(S7)
9D015A14  AEF06430   SW S0, 25648(S7)
9D015B50  ACE56430   SW A1, 25648(A3)
485:                 	LCD_WR_SET;
9D013E30  AC626328   SW V0, 25384(V1)
9D013FAC  AC626328   SW V0, 25384(V1)
9D013FD0  AC626328   SW V0, 25384(V1)
9D013FF4  AC626328   SW V0, 25384(V1)
9D014018  AC626328   SW V0, 25384(V1)
9D01403C  AC626328   SW V0, 25384(V1)
9D014060  AC626328   SW V0, 25384(V1)
9D014084  AC626328   SW V0, 25384(V1)
9D0140A8  AC626328   SW V0, 25384(V1)
9D014140  AC626328   SW V0, 25384(V1)
9D01416C  AC626328   SW V0, 25384(V1)
9D0141A0  AC626328   SW V0, 25384(V1)
9D0141CC  AC626328   SW V0, 25384(V1)
9D014200  AC626328   SW V0, 25384(V1)
9D01422C  AC626328   SW V0, 25384(V1)
9D014260  AC626328   SW V0, 25384(V1)
9D01428C  AC626328   SW V0, 25384(V1)
9D0142C0  AC626328   SW V0, 25384(V1)
9D0142EC  AC626328   SW V0, 25384(V1)
9D014320  AC626328   SW V0, 25384(V1)
9D01434C  AC626328   SW V0, 25384(V1)
9D014380  AC626328   SW V0, 25384(V1)
9D0143AC  AC626328   SW V0, 25384(V1)
9D0143DC  AC626328   SW V0, 25384(V1)
9D014408  AC626328   SW V0, 25384(V1)
9D01465C  AEE26328   SW V0, 25384(S7)
9D014688  AEE26328   SW V0, 25384(S7)
9D0146BC  AEE26328   SW V0, 25384(S7)
9D0146E8  AEE26328   SW V0, 25384(S7)
9D01471C  AEE26328   SW V0, 25384(S7)
9D014748  AEE26328   SW V0, 25384(S7)
9D01477C  AEE26328   SW V0, 25384(S7)
9D0147A8  AEE26328   SW V0, 25384(S7)
9D0147DC  AEE26328   SW V0, 25384(S7)
9D014808  AEE26328   SW V0, 25384(S7)
9D01483C  AEE26328   SW V0, 25384(S7)
9D014868  AEE26328   SW V0, 25384(S7)
9D01489C  AEE26328   SW V0, 25384(S7)
9D0148C8  AEE26328   SW V0, 25384(S7)
9D0148F8  AEE26328   SW V0, 25384(S7)
9D014924  AEE26328   SW V0, 25384(S7)
9D014A64  AEE26328   SW V0, 25384(S7)
9D014A88  AEE26328   SW V0, 25384(S7)
9D014AAC  AEE26328   SW V0, 25384(S7)
9D014AD0  AEE26328   SW V0, 25384(S7)
9D014AF4  AEE26328   SW V0, 25384(S7)
9D014B18  AEE26328   SW V0, 25384(S7)
9D014B3C  AEE26328   SW V0, 25384(S7)
9D014B60  AEE26328   SW V0, 25384(S7)
9D014BE4  AEE26328   SW V0, 25384(S7)
9D014C10  AEE26328   SW V0, 25384(S7)
9D014C44  AEE26328   SW V0, 25384(S7)
9D014C70  AEE26328   SW V0, 25384(S7)
9D014CA4  AEE26328   SW V0, 25384(S7)
9D014CD0  AEE26328   SW V0, 25384(S7)
9D014D04  AEE26328   SW V0, 25384(S7)
9D014D30  AEE26328   SW V0, 25384(S7)
9D014D64  AEE26328   SW V0, 25384(S7)
9D014D90  AEE26328   SW V0, 25384(S7)
9D014DC4  AEE26328   SW V0, 25384(S7)
9D014DF0  AEE26328   SW V0, 25384(S7)
9D014E24  AEE26328   SW V0, 25384(S7)
9D014E50  AEE26328   SW V0, 25384(S7)
9D014E80  AEE26328   SW V0, 25384(S7)
9D014EAC  AEE26328   SW V0, 25384(S7)
9D0151C8  AFC26328   SW V0, 25384(FP)
9D0151F4  AFC26328   SW V0, 25384(FP)
9D015228  AFC26328   SW V0, 25384(FP)
9D015254  AFC26328   SW V0, 25384(FP)
9D015288  AFC26328   SW V0, 25384(FP)
9D0152B4  AFC26328   SW V0, 25384(FP)
9D0152E8  AFC26328   SW V0, 25384(FP)
9D015314  AFC26328   SW V0, 25384(FP)
9D015348  AFC26328   SW V0, 25384(FP)
9D015374  AFC26328   SW V0, 25384(FP)
9D0153A8  AFC26328   SW V0, 25384(FP)
9D0153D4  AFC26328   SW V0, 25384(FP)
9D015408  AFC26328   SW V0, 25384(FP)
9D015434  AFC26328   SW V0, 25384(FP)
9D015464  AFC26328   SW V0, 25384(FP)
9D015490  AFC26328   SW V0, 25384(FP)
9D0155D0  AFC26328   SW V0, 25384(FP)
9D0155F4  AFC26328   SW V0, 25384(FP)
9D015618  AFC26328   SW V0, 25384(FP)
9D01563C  AFC26328   SW V0, 25384(FP)
9D015660  AFC26328   SW V0, 25384(FP)
9D015684  AFC26328   SW V0, 25384(FP)
9D0156A8  AFC26328   SW V0, 25384(FP)
9D0156CC  AFC26328   SW V0, 25384(FP)
9D015750  AFC26328   SW V0, 25384(FP)
9D01577C  AFC26328   SW V0, 25384(FP)
9D0157B0  AFC26328   SW V0, 25384(FP)
9D0157DC  AFC26328   SW V0, 25384(FP)
9D015810  AFC26328   SW V0, 25384(FP)
9D01583C  AFC26328   SW V0, 25384(FP)
9D015870  AFC26328   SW V0, 25384(FP)
9D01589C  AFC26328   SW V0, 25384(FP)
9D0158D0  AFC26328   SW V0, 25384(FP)
9D0158FC  AFC26328   SW V0, 25384(FP)
9D015930  AFC26328   SW V0, 25384(FP)
9D01595C  AFC26328   SW V0, 25384(FP)
9D015990  AFC26328   SW V0, 25384(FP)
9D0159BC  AFC26328   SW V0, 25384(FP)
9D0159EC  AFC26328   SW V0, 25384(FP)
9D015A18  AFC26328   SW V0, 25384(FP)
9D015B54  AC626328   SW V0, 25384(V1)
486:                 	LCD_WR_CLR;
9D013E34  ACA26324   SW V0, 25380(A1)
9D013FB0  ACA26324   SW V0, 25380(A1)
9D013FD4  ACA26324   SW V0, 25380(A1)
9D013FF8  ACA26324   SW V0, 25380(A1)
9D01401C  ACA26324   SW V0, 25380(A1)
9D014040  ACA26324   SW V0, 25380(A1)
9D014064  ACA26324   SW V0, 25380(A1)
9D014088  ACA26324   SW V0, 25380(A1)
9D0140AC  ACA26324   SW V0, 25380(A1)
9D014144  ACA26324   SW V0, 25380(A1)
9D014170  ACA26324   SW V0, 25380(A1)
9D0141A4  ACA26324   SW V0, 25380(A1)
9D0141D0  ACA26324   SW V0, 25380(A1)
9D014204  ACA26324   SW V0, 25380(A1)
9D014230  ACA26324   SW V0, 25380(A1)
9D014264  ACA26324   SW V0, 25380(A1)
9D014290  ACA26324   SW V0, 25380(A1)
9D0142C4  ACA26324   SW V0, 25380(A1)
9D0142F0  ACA26324   SW V0, 25380(A1)
9D014324  ACA26324   SW V0, 25380(A1)
9D014350  ACA26324   SW V0, 25380(A1)
9D014384  ACA26324   SW V0, 25380(A1)
9D0143B0  ACA26324   SW V0, 25380(A1)
9D0143E0  ACA26324   SW V0, 25380(A1)
9D01440C  ACA26324   SW V0, 25380(A1)
9D014660  AEC26324   SW V0, 25380(S6)
9D01468C  AEC26324   SW V0, 25380(S6)
9D0146C0  AEC26324   SW V0, 25380(S6)
9D0146EC  AEC26324   SW V0, 25380(S6)
9D014720  AEC26324   SW V0, 25380(S6)
9D01474C  AEC26324   SW V0, 25380(S6)
9D014780  AEC26324   SW V0, 25380(S6)
9D0147AC  AEC26324   SW V0, 25380(S6)
9D0147E0  AEC26324   SW V0, 25380(S6)
9D01480C  AEC26324   SW V0, 25380(S6)
9D014840  AEC26324   SW V0, 25380(S6)
9D01486C  AEC26324   SW V0, 25380(S6)
9D0148A0  AEC26324   SW V0, 25380(S6)
9D0148CC  AEC26324   SW V0, 25380(S6)
9D0148FC  AEC26324   SW V0, 25380(S6)
9D014928  AEC26324   SW V0, 25380(S6)
9D014A68  AEC26324   SW V0, 25380(S6)
9D014A8C  AEC26324   SW V0, 25380(S6)
9D014AB0  AEC26324   SW V0, 25380(S6)
9D014AD4  AEC26324   SW V0, 25380(S6)
9D014AF8  AEC26324   SW V0, 25380(S6)
9D014B1C  AEC26324   SW V0, 25380(S6)
9D014B40  AEC26324   SW V0, 25380(S6)
9D014B64  AEC26324   SW V0, 25380(S6)
9D014BE8  AEC26324   SW V0, 25380(S6)
9D014C14  AEC26324   SW V0, 25380(S6)
9D014C48  AEC26324   SW V0, 25380(S6)
9D014C74  AEC26324   SW V0, 25380(S6)
9D014CA8  AEC26324   SW V0, 25380(S6)
9D014CD4  AEC26324   SW V0, 25380(S6)
9D014D08  AEC26324   SW V0, 25380(S6)
9D014D34  AEC26324   SW V0, 25380(S6)
9D014D68  AEC26324   SW V0, 25380(S6)
9D014D94  AEC26324   SW V0, 25380(S6)
9D014DC8  AEC26324   SW V0, 25380(S6)
9D014DF4  AEC26324   SW V0, 25380(S6)
9D014E28  AEC26324   SW V0, 25380(S6)
9D014E54  AEC26324   SW V0, 25380(S6)
9D014E84  AEC26324   SW V0, 25380(S6)
9D014EB0  AEC26324   SW V0, 25380(S6)
9D0151CC  AEC26324   SW V0, 25380(S6)
9D0151F8  AEC26324   SW V0, 25380(S6)
9D01522C  AEC26324   SW V0, 25380(S6)
9D015258  AEC26324   SW V0, 25380(S6)
9D01528C  AEC26324   SW V0, 25380(S6)
9D0152B8  AEC26324   SW V0, 25380(S6)
9D0152EC  AEC26324   SW V0, 25380(S6)
9D015318  AEC26324   SW V0, 25380(S6)
9D01534C  AEC26324   SW V0, 25380(S6)
9D015378  AEC26324   SW V0, 25380(S6)
9D0153AC  AEC26324   SW V0, 25380(S6)
9D0153D8  AEC26324   SW V0, 25380(S6)
9D01540C  AEC26324   SW V0, 25380(S6)
9D015438  AEC26324   SW V0, 25380(S6)
9D015468  AEC26324   SW V0, 25380(S6)
9D015494  AEC26324   SW V0, 25380(S6)
9D0155D4  AEC26324   SW V0, 25380(S6)
9D0155F8  AEC26324   SW V0, 25380(S6)
9D01561C  AEC26324   SW V0, 25380(S6)
9D015640  AEC26324   SW V0, 25380(S6)
9D015664  AEC26324   SW V0, 25380(S6)
9D015688  AEC26324   SW V0, 25380(S6)
9D0156AC  AEC26324   SW V0, 25380(S6)
9D0156D0  AEC26324   SW V0, 25380(S6)
9D015754  AEC26324   SW V0, 25380(S6)
9D015780  AEC26324   SW V0, 25380(S6)
9D0157B4  AEC26324   SW V0, 25380(S6)
9D0157E0  AEC26324   SW V0, 25380(S6)
9D015814  AEC26324   SW V0, 25380(S6)
9D015840  AEC26324   SW V0, 25380(S6)
9D015874  AEC26324   SW V0, 25380(S6)
9D0158A0  AEC26324   SW V0, 25380(S6)
9D0158D4  AEC26324   SW V0, 25380(S6)
9D015900  AEC26324   SW V0, 25380(S6)
9D015934  AEC26324   SW V0, 25380(S6)
9D015960  AEC26324   SW V0, 25380(S6)
9D015994  AEC26324   SW V0, 25380(S6)
9D0159C0  AEC26324   SW V0, 25380(S6)
9D0159F0  AEC26324   SW V0, 25380(S6)
9D015A1C  AEC26324   SW V0, 25380(S6)
9D015B58  AD026324   SW V0, 25380(T0)
487:                 	LCD_PORT = data3;
9D013E18  322800FF   ANDI T0, S1, 255
9D013E38  AC886430   SW T0, 25648(A0)
9D013FB4  AC926430   SW S2, 25648(A0)
9D013FD8  AC926430   SW S2, 25648(A0)
9D013FFC  AC926430   SW S2, 25648(A0)
9D014020  AC926430   SW S2, 25648(A0)
9D014044  AC926430   SW S2, 25648(A0)
9D014068  AC926430   SW S2, 25648(A0)
9D01408C  AC926430   SW S2, 25648(A0)
9D0140B0  AC926430   SW S2, 25648(A0)
9D014148  AC886430   SW T0, 25648(A0)
9D014174  AC926430   SW S2, 25648(A0)
9D0141A8  AC886430   SW T0, 25648(A0)
9D0141D4  AC926430   SW S2, 25648(A0)
9D014208  AC886430   SW T0, 25648(A0)
9D014234  AC926430   SW S2, 25648(A0)
9D014268  AC886430   SW T0, 25648(A0)
9D014294  AC926430   SW S2, 25648(A0)
9D0142C8  AC886430   SW T0, 25648(A0)
9D0142F4  AC926430   SW S2, 25648(A0)
9D014328  AC886430   SW T0, 25648(A0)
9D014354  AC926430   SW S2, 25648(A0)
9D014388  AC886430   SW T0, 25648(A0)
9D0143B4  AC926430   SW S2, 25648(A0)
9D0143E4  AC886430   SW T0, 25648(A0)
9D014410  AC926430   SW S2, 25648(A0)
9D014664  AFD16430   SW S1, 25648(FP)
9D014690  AFD56430   SW S5, 25648(FP)
9D0146C4  AFD16430   SW S1, 25648(FP)
9D0146F0  AFD56430   SW S5, 25648(FP)
9D014724  AFD16430   SW S1, 25648(FP)
9D014750  AFD56430   SW S5, 25648(FP)
9D014784  AFD16430   SW S1, 25648(FP)
9D0147B0  AFD56430   SW S5, 25648(FP)
9D0147E4  AFD16430   SW S1, 25648(FP)
9D014810  AFD56430   SW S5, 25648(FP)
9D014844  AFD16430   SW S1, 25648(FP)
9D014870  AFD56430   SW S5, 25648(FP)
9D0148A4  AFD16430   SW S1, 25648(FP)
9D0148D0  AFD56430   SW S5, 25648(FP)
9D014900  AFD16430   SW S1, 25648(FP)
9D01492C  AFD56430   SW S5, 25648(FP)
9D014A6C  AFD16430   SW S1, 25648(FP)
9D014A90  AFD16430   SW S1, 25648(FP)
9D014AB4  AFD16430   SW S1, 25648(FP)
9D014AD8  AFD16430   SW S1, 25648(FP)
9D014AFC  AFD16430   SW S1, 25648(FP)
9D014B20  AFD16430   SW S1, 25648(FP)
9D014B44  AFD16430   SW S1, 25648(FP)
9D014B68  AFD16430   SW S1, 25648(FP)
9D014BEC  AFD56430   SW S5, 25648(FP)
9D014C18  AFD16430   SW S1, 25648(FP)
9D014C4C  AFD56430   SW S5, 25648(FP)
9D014C78  AFD16430   SW S1, 25648(FP)
9D014CAC  AFD56430   SW S5, 25648(FP)
9D014CD8  AFD16430   SW S1, 25648(FP)
9D014D0C  AFD56430   SW S5, 25648(FP)
9D014D38  AFD16430   SW S1, 25648(FP)
9D014D6C  AFD56430   SW S5, 25648(FP)
9D014D98  AFD16430   SW S1, 25648(FP)
9D014DCC  AFD56430   SW S5, 25648(FP)
9D014DF8  AFD16430   SW S1, 25648(FP)
9D014E2C  AFD56430   SW S5, 25648(FP)
9D014E58  AFD16430   SW S1, 25648(FP)
9D014E88  AFD56430   SW S5, 25648(FP)
9D014EB4  AFD16430   SW S1, 25648(FP)
9D0151D0  AEF16430   SW S1, 25648(S7)
9D0151FC  AEF56430   SW S5, 25648(S7)
9D015230  AEF16430   SW S1, 25648(S7)
9D01525C  AEF56430   SW S5, 25648(S7)
9D015290  AEF16430   SW S1, 25648(S7)
9D0152BC  AEF56430   SW S5, 25648(S7)
9D0152F0  AEF16430   SW S1, 25648(S7)
9D01531C  AEF56430   SW S5, 25648(S7)
9D015350  AEF16430   SW S1, 25648(S7)
9D01537C  AEF56430   SW S5, 25648(S7)
9D0153B0  AEF16430   SW S1, 25648(S7)
9D0153DC  AEF56430   SW S5, 25648(S7)
9D015410  AEF16430   SW S1, 25648(S7)
9D01543C  AEF56430   SW S5, 25648(S7)
9D01546C  AEF16430   SW S1, 25648(S7)
9D015498  AEF56430   SW S5, 25648(S7)
9D0155D8  AEF16430   SW S1, 25648(S7)
9D0155FC  AEF16430   SW S1, 25648(S7)
9D015620  AEF16430   SW S1, 25648(S7)
9D015644  AEF16430   SW S1, 25648(S7)
9D015668  AEF16430   SW S1, 25648(S7)
9D01568C  AEF16430   SW S1, 25648(S7)
9D0156B0  AEF16430   SW S1, 25648(S7)
9D0156D4  AEF16430   SW S1, 25648(S7)
9D015758  AEF56430   SW S5, 25648(S7)
9D015784  AEF16430   SW S1, 25648(S7)
9D0157B8  AEF56430   SW S5, 25648(S7)
9D0157E4  AEF16430   SW S1, 25648(S7)
9D015818  AEF56430   SW S5, 25648(S7)
9D015844  AEF16430   SW S1, 25648(S7)
9D015878  AEF56430   SW S5, 25648(S7)
9D0158A4  AEF16430   SW S1, 25648(S7)
9D0158D8  AEF56430   SW S5, 25648(S7)
9D015904  AEF16430   SW S1, 25648(S7)
9D015938  AEF56430   SW S5, 25648(S7)
9D015964  AEF16430   SW S1, 25648(S7)
9D015998  AEF56430   SW S5, 25648(S7)
9D0159C4  AEF16430   SW S1, 25648(S7)
9D0159F4  AEF56430   SW S5, 25648(S7)
9D015A20  AEF16430   SW S1, 25648(S7)
9D015B5C  ACE66430   SW A2, 25648(A3)
488:                 	LCD_WR_SET;
9D013E3C  AC626328   SW V0, 25384(V1)
9D013FB8  AC626328   SW V0, 25384(V1)
9D013FDC  AC626328   SW V0, 25384(V1)
9D014000  AC626328   SW V0, 25384(V1)
9D014024  AC626328   SW V0, 25384(V1)
9D014048  AC626328   SW V0, 25384(V1)
9D01406C  AC626328   SW V0, 25384(V1)
9D014090  AC626328   SW V0, 25384(V1)
9D0140B4  AC626328   SW V0, 25384(V1)
9D0140B8  24C6FFFF   ADDIU A2, A2, -1
9D0140BC  30C6FFFF   ANDI A2, A2, -1
9D01414C  AC626328   SW V0, 25384(V1)
9D014178  AC626328   SW V0, 25384(V1)
9D0141AC  AC626328   SW V0, 25384(V1)
9D0141D8  AC626328   SW V0, 25384(V1)
9D01420C  AC626328   SW V0, 25384(V1)
9D014238  AC626328   SW V0, 25384(V1)
9D01426C  AC626328   SW V0, 25384(V1)
9D014298  AC626328   SW V0, 25384(V1)
9D0142CC  AC626328   SW V0, 25384(V1)
9D0142F8  AC626328   SW V0, 25384(V1)
9D01432C  AC626328   SW V0, 25384(V1)
9D014358  AC626328   SW V0, 25384(V1)
9D01438C  AC626328   SW V0, 25384(V1)
9D0143B8  AC626328   SW V0, 25384(V1)
9D0143E8  AC626328   SW V0, 25384(V1)
9D0143EC  0B405107   J .LBE450
9D0143F0  24E70001   ADDIU A3, A3, 1
9D014414  AC626328   SW V0, 25384(V1)
9D014418  24E70001   ADDIU A3, A3, 1
9D014668  AEE26328   SW V0, 25384(S7)
9D014694  AEE26328   SW V0, 25384(S7)
9D0146C8  AEE26328   SW V0, 25384(S7)
9D0146F4  AEE26328   SW V0, 25384(S7)
9D014728  AEE26328   SW V0, 25384(S7)
9D014754  AEE26328   SW V0, 25384(S7)
9D014788  AEE26328   SW V0, 25384(S7)
9D0147B4  AEE26328   SW V0, 25384(S7)
9D0147E8  AEE26328   SW V0, 25384(S7)
9D014814  AEE26328   SW V0, 25384(S7)
9D014848  AEE26328   SW V0, 25384(S7)
9D014874  AEE26328   SW V0, 25384(S7)
9D0148A8  AEE26328   SW V0, 25384(S7)
9D0148D4  AEE26328   SW V0, 25384(S7)
9D014904  AEE26328   SW V0, 25384(S7)
9D014908  0B40524E   J .LBE734
9D01490C  24840001   ADDIU A0, A0, 1
9D014930  AEE26328   SW V0, 25384(S7)
9D014934  24840001   ADDIU A0, A0, 1
9D014A70  AEE26328   SW V0, 25384(S7)
9D014A94  AEE26328   SW V0, 25384(S7)
9D014AB8  AEE26328   SW V0, 25384(S7)
9D014ADC  AEE26328   SW V0, 25384(S7)
9D014B00  AEE26328   SW V0, 25384(S7)
9D014B24  AEE26328   SW V0, 25384(S7)
9D014B48  AEE26328   SW V0, 25384(S7)
9D014B6C  AEE26328   SW V0, 25384(S7)
9D014B70  2463FFFF   ADDIU V1, V1, -1
9D014B74  3063FFFF   ANDI V1, V1, -1
9D014BF0  AEE26328   SW V0, 25384(S7)
9D014C1C  AEE26328   SW V0, 25384(S7)
9D014C50  AEE26328   SW V0, 25384(S7)
9D014C7C  AEE26328   SW V0, 25384(S7)
9D014CB0  AEE26328   SW V0, 25384(S7)
9D014CDC  AEE26328   SW V0, 25384(S7)
9D014D10  AEE26328   SW V0, 25384(S7)
9D014D3C  AEE26328   SW V0, 25384(S7)
9D014D70  AEE26328   SW V0, 25384(S7)
9D014D9C  AEE26328   SW V0, 25384(S7)
9D014DD0  AEE26328   SW V0, 25384(S7)
9D014DFC  AEE26328   SW V0, 25384(S7)
9D014E30  AEE26328   SW V0, 25384(S7)
9D014E5C  AEE26328   SW V0, 25384(S7)
9D014E8C  AEE26328   SW V0, 25384(S7)
9D014E90  0B4053B0   J .LBE660
9D014E94  24840001   ADDIU A0, A0, 1
9D014EB8  AEE26328   SW V0, 25384(S7)
9D014EBC  24840001   ADDIU A0, A0, 1
9D0151D4  AFC26328   SW V0, 25384(FP)
9D015200  AFC26328   SW V0, 25384(FP)
9D015234  AFC26328   SW V0, 25384(FP)
9D015260  AFC26328   SW V0, 25384(FP)
9D015294  AFC26328   SW V0, 25384(FP)
9D0152C0  AFC26328   SW V0, 25384(FP)
9D0152F4  AFC26328   SW V0, 25384(FP)
9D015320  AFC26328   SW V0, 25384(FP)
9D015354  AFC26328   SW V0, 25384(FP)
9D015380  AFC26328   SW V0, 25384(FP)
9D0153B4  AFC26328   SW V0, 25384(FP)
9D0153E0  AFC26328   SW V0, 25384(FP)
9D015414  AFC26328   SW V0, 25384(FP)
9D015440  AFC26328   SW V0, 25384(FP)
9D015470  AFC26328   SW V0, 25384(FP)
9D015474  0B405529   J .LBE1043
9D015478  24840001   ADDIU A0, A0, 1
9D01549C  AFC26328   SW V0, 25384(FP)
9D0154A0  24840001   ADDIU A0, A0, 1
9D0155DC  AFC26328   SW V0, 25384(FP)
9D015600  AFC26328   SW V0, 25384(FP)
9D015624  AFC26328   SW V0, 25384(FP)
9D015648  AFC26328   SW V0, 25384(FP)
9D01566C  AFC26328   SW V0, 25384(FP)
9D015690  AFC26328   SW V0, 25384(FP)
9D0156B4  AFC26328   SW V0, 25384(FP)
9D0156D8  AFC26328   SW V0, 25384(FP)
9D0156DC  2463FFFF   ADDIU V1, V1, -1
9D0156E0  3063FFFF   ANDI V1, V1, -1
9D01575C  AFC26328   SW V0, 25384(FP)
9D015788  AFC26328   SW V0, 25384(FP)
9D0157BC  AFC26328   SW V0, 25384(FP)
9D0157E8  AFC26328   SW V0, 25384(FP)
9D01581C  AFC26328   SW V0, 25384(FP)
9D015848  AFC26328   SW V0, 25384(FP)
9D01587C  AFC26328   SW V0, 25384(FP)
9D0158A8  AFC26328   SW V0, 25384(FP)
9D0158DC  AFC26328   SW V0, 25384(FP)
9D015908  AFC26328   SW V0, 25384(FP)
9D01593C  AFC26328   SW V0, 25384(FP)
9D015968  AFC26328   SW V0, 25384(FP)
9D01599C  AFC26328   SW V0, 25384(FP)
9D0159C8  AFC26328   SW V0, 25384(FP)
9D0159F8  AFC26328   SW V0, 25384(FP)
9D0159FC  0B40568B   J .LBE972
9D015A00  24840001   ADDIU A0, A0, 1
9D015A24  AFC26328   SW V0, 25384(FP)
9D015A28  24840001   ADDIU A0, A0, 1
9D015B60  AC626328   SW V0, 25384(V1)
9D015B64  03E00008   JR RA
9D015B68  00000000   NOP
489:                 	}
490:                 
491:                 inline void TFT_24_7789_Write_Data33(uint8_t data1,uint8_t data2, uint8_t data3)
492:                 	{
493:                 	LCD_WR_CLR;
9D013C8C  3C06BF88   LUI A2, -16504
9D013C90  24020010   ADDIU V0, ZERO, 16
9D013CA0  ACC26324   SW V0, 25380(A2)
9D013CC4  ACC26324   SW V0, 25380(A2)
9D015B6C  3C08BF88   LUI T0, -16504
9D015B70  24020010   ADDIU V0, ZERO, 16
9D015B74  AD026324   SW V0, 25380(T0)
494:                 	LCD_PORT = data1;
9D013C94  3C05BF88   LUI A1, -16504
9D013CA4  ACA06430   SW ZERO, 25648(A1)
9D013CC8  ACB06430   SW S0, 25648(A1)
9D015B78  3C07BF88   LUI A3, -16504
9D015B7C  ACE46430   SW A0, 25648(A3)
495:                 	LCD_WR_SET;
9D013CA8  AC626328   SW V0, 25384(V1)
9D013CCC  AC626328   SW V0, 25384(V1)
9D015B80  3C03BF88   LUI V1, -16504
9D015B84  AC626328   SW V0, 25384(V1)
496:                 	LCD_WR_CLR;
9D013CAC  ACC26324   SW V0, 25380(A2)
9D013CD0  ACC26324   SW V0, 25380(A2)
9D015B88  AD026324   SW V0, 25380(T0)
497:                 	LCD_PORT = data2;
9D013CB0  ACA06430   SW ZERO, 25648(A1)
9D013CD4  ACB06430   SW S0, 25648(A1)
9D015B8C  ACE56430   SW A1, 25648(A3)
498:                 	LCD_WR_SET;
9D013CB4  AC626328   SW V0, 25384(V1)
9D013CD8  AC626328   SW V0, 25384(V1)
9D015B90  AC626328   SW V0, 25384(V1)
499:                 	LCD_WR_CLR;
9D013CB8  ACC26324   SW V0, 25380(A2)
9D013CDC  ACC26324   SW V0, 25380(A2)
9D015B94  AD026324   SW V0, 25380(T0)
500:                 	LCD_PORT = data3;
9D013CBC  ACA06430   SW ZERO, 25648(A1)
9D013CE0  ACB06430   SW S0, 25648(A1)
9D015B98  ACE66430   SW A2, 25648(A3)
501:                 	LCD_WR_SET;
9D013CC0  AC626328   SW V0, 25384(V1)
9D013CE4  AC626328   SW V0, 25384(V1)
9D015B9C  AC626328   SW V0, 25384(V1)
9D015BA0  03E00008   JR RA
9D015BA4  00000000   NOP
502:                 	}
503:                 
504:                 /*******************************************************************************/
505:                 void TFT_24_7789_Init(void)
506:                 	{
9D015BA8  27BDFFC8   ADDIU SP, SP, -56
9D015BAC  AFBF0034   SW RA, 52(SP)
9D015BB0  AFBE0030   SW FP, 48(SP)
9D015BB4  AFB7002C   SW S7, 44(SP)
9D015BB8  AFB60028   SW S6, 40(SP)
9D015BBC  AFB50024   SW S5, 36(SP)
9D015BC0  AFB40020   SW S4, 32(SP)
9D015BC4  AFB3001C   SW S3, 28(SP)
9D015BC8  AFB20018   SW S2, 24(SP)
9D015BCC  AFB10014   SW S1, 20(SP)
9D015BD0  AFB00010   SW S0, 16(SP)
507:                 	LCD_RES = 0;
9D015BD4  3C02BF88   LUI V0, -16504
9D015BD8  94436630   LHU V1, 26160(V0)
9D015BDC  7C0339C4   INS V1, ZERO, 7, 1
9D015BE0  A4436630   SH V1, 26160(V0)
508:                 	LCD_RD = 1;
9D015BE4  3C03BF88   LUI V1, -16504
9D015BE8  94646330   LHU A0, 25392(V1)
9D015BEC  24140001   ADDIU S4, ZERO, 1
9D015BF0  7E842944   INS A0, S4, 5, 1
9D015BF4  A4646330   SH A0, 25392(V1)
509:                 	LCD_WR = 1;
9D015BF8  94646330   LHU A0, 25392(V1)
9D015BFC  7E842104   INS A0, S4, 4, 1
9D015C00  A4646330   SH A0, 25392(V1)
510:                 	//wait_ms(2);
511:                 	LCD_RES = 1;
9D015C04  94436630   LHU V1, 26160(V0)
9D015C08  7E8339C4   INS V1, S4, 7, 1
9D015C0C  A4436630   SH V1, 26160(V0)
512:                 	wait_ms(2);
9D015C10  0F407C7E   JAL wait_ms
9D015C14  24040002   ADDIU A0, ZERO, 2
513:                 	TFT_24_7789_Write_Command(0x0029);//exit SLEEP mode
9D015C18  0F404EBF   JAL TFT_24_7789_Write_Command
9D015C1C  24040029   ADDIU A0, ZERO, 41
514:                 	wait_ms(2);
9D015C20  0F407C7E   JAL wait_ms
9D015C24  24040002   ADDIU A0, ZERO, 2
515:                 	TFT_24_7789_Write_Command(0x0036);
9D015C28  0F404EBF   JAL TFT_24_7789_Write_Command
9D015C2C  24040036   ADDIU A0, ZERO, 54
516:                 	TFT_24_7789_Write_Data(0x70);//MADCTL: memory data access control
517:                 	TFT_24_7789_Write_Command(0x003A);
9D015C50  0F404EBF   JAL TFT_24_7789_Write_Command
9D015C54  2404003A   ADDIU A0, ZERO, 58
518:                 	TFT_24_7789_Write_Data(0x0066);//COLMOD: Interface Pixel format
519:                 	TFT_24_7789_Write_Command(0x00B2);
9D015C68  0F404EBF   JAL TFT_24_7789_Write_Command
9D015C6C  240400B2   ADDIU A0, ZERO, 178
520:                 	TFT_24_7789_Write_Data(0x0C);
521:                 	TFT_24_7789_Write_Data(0x0C);
522:                 	TFT_24_7789_Write_Data(0x00);
523:                 	TFT_24_7789_Write_Data(0x33);
524:                 	TFT_24_7789_Write_Data(0x33);//PORCTRK: Porch setting
525:                 	TFT_24_7789_Write_Command(0x00B7);
9D015CB4  0F404EBF   JAL TFT_24_7789_Write_Command
9D015CB8  240400B7   ADDIU A0, ZERO, 183
526:                 	TFT_24_7789_Write_Data(0x0035);//GCTRL: Gate Control
527:                 	TFT_24_7789_Write_Command(0x00BB);
9D015CCC  0F404EBF   JAL TFT_24_7789_Write_Command
9D015CD0  240400BB   ADDIU A0, ZERO, 187
528:                 	TFT_24_7789_Write_Data(0x002B);//VCOMS: VCOM setting
529:                 	TFT_24_7789_Write_Command(0x00C0);
9D015CE4  0F404EBF   JAL TFT_24_7789_Write_Command
9D015CE8  240400C0   ADDIU A0, ZERO, 192
530:                 	TFT_24_7789_Write_Data(0x002C);//LCMCTRL: LCM Control
531:                 	TFT_24_7789_Write_Command(0x00C2);
9D015CFC  0F404EBF   JAL TFT_24_7789_Write_Command
9D015D00  240400C2   ADDIU A0, ZERO, 194
532:                 	TFT_24_7789_Write_Data(0x0001);
533:                 	TFT_24_7789_Write_Data(0xFF);//VDVVRHEN: VDV and VRH Command Enable
534:                 	TFT_24_7789_Write_Command(0x00C3);
9D015D20  0F404EBF   JAL TFT_24_7789_Write_Command
9D015D24  240400C3   ADDIU A0, ZERO, 195
535:                 	TFT_24_7789_Write_Data(0x0011);//VRHS: VRH Set
536:                 	TFT_24_7789_Write_Command(0x00C4);
9D015D38  0F404EBF   JAL TFT_24_7789_Write_Command
9D015D3C  240400C4   ADDIU A0, ZERO, 196
537:                 	TFT_24_7789_Write_Data(0x0020);//VDVS: VDV Set[10]
538:                 	TFT_24_7789_Write_Command(0x00C6);
9D015D50  0F404EBF   JAL TFT_24_7789_Write_Command
9D015D54  240400C6   ADDIU A0, ZERO, 198
539:                 	TFT_24_7789_Write_Data(0x000F);//FRCTRL2: Frame Rate control in normal mode
540:                 	TFT_24_7789_Write_Command(0x00D0);
9D015D68  0F404EBF   JAL TFT_24_7789_Write_Command
9D015D6C  240400D0   ADDIU A0, ZERO, 208
541:                 	TFT_24_7789_Write_Data(0x00A4);
542:                 	TFT_24_7789_Write_Data(0xA1);//PWCTRL1: Power Control 1
543:                 	TFT_24_7789_Write_Command(0x00E0);
9D015D90  0F404EBF   JAL TFT_24_7789_Write_Command
9D015D94  240400E0   ADDIU A0, ZERO, 224
544:                 	TFT_24_7789_Write_Data(0x00D0);
545:                 	TFT_24_7789_Write_Data(0x0000);
546:                 	TFT_24_7789_Write_Data(0x0005);
547:                 	TFT_24_7789_Write_Data(0x000E);
548:                 	TFT_24_7789_Write_Data(0x0015);
549:                 	TFT_24_7789_Write_Data(0x000D);
550:                 	TFT_24_7789_Write_Data(0x0037);
551:                 	TFT_24_7789_Write_Data(0x0043);
552:                 	TFT_24_7789_Write_Data(0x0047);
553:                 	TFT_24_7789_Write_Data(0x0009);
554:                 	TFT_24_7789_Write_Data(0x0015);
555:                 	TFT_24_7789_Write_Data(0x0012);
556:                 	TFT_24_7789_Write_Data(0x0016);
557:                 	TFT_24_7789_Write_Data(0x0019);//PVGAMCTRL: Positive Voltage Gamma control
558:                 	TFT_24_7789_Write_Command(0x00E1);
9D015E70  0F404EBF   JAL TFT_24_7789_Write_Command
9D015E74  240400E1   ADDIU A0, ZERO, 225
559:                 	TFT_24_7789_Write_Data(0x00D0);
560:                 	TFT_24_7789_Write_Data(0x0000);
561:                 	TFT_24_7789_Write_Data(0x0005);
562:                 	TFT_24_7789_Write_Data(0x000D);
563:                 	TFT_24_7789_Write_Data(0x000C);
564:                 	TFT_24_7789_Write_Data(0x0006);
565:                 	TFT_24_7789_Write_Data(0x002D);
566:                 	TFT_24_7789_Write_Data(0x0044);
567:                 	TFT_24_7789_Write_Data(0x0040);
568:                 	TFT_24_7789_Write_Data(0x000E);
569:                 	TFT_24_7789_Write_Data(0x001C);
570:                 	TFT_24_7789_Write_Data(0x0018);
571:                 	TFT_24_7789_Write_Data(0x0016);
572:                 	TFT_24_7789_Write_Data(0x0019);//NVGAMCTRL: Negative Voltage Gamma control
573:                 	TFT_24_7789_Write_Command(0x002A);
9D015F44  0F404EBF   JAL TFT_24_7789_Write_Command
9D015F48  2404002A   ADDIU A0, ZERO, 42
574:                 	TFT_24_7789_Write_Data(0x0000);
575:                 	TFT_24_7789_Write_Data(0x0000);
576:                 	TFT_24_7789_Write_Data(0x0001);
577:                 	TFT_24_7789_Write_Data(0x003F);//X address set
578:                 	TFT_24_7789_Write_Command(0x002B);
9D015F80  0F404EBF   JAL TFT_24_7789_Write_Command
9D015F84  2404002B   ADDIU A0, ZERO, 43
579:                 	TFT_24_7789_Write_Data(0x0000);
580:                 	TFT_24_7789_Write_Data(0x0000);
581:                 	TFT_24_7789_Write_Data(0x0000);
582:                 	TFT_24_7789_Write_Data(0x00EF);//Y address set
583:                 	TFT_24_7789_Write_Command(0x11);
9D015FBC  0F404EBF   JAL TFT_24_7789_Write_Command
9D015FC0  24040011   ADDIU A0, ZERO, 17
584:                 	TFT_24_7789_Write_Command(0x38);
9D015FC4  0F404EBF   JAL TFT_24_7789_Write_Command
9D015FC8  24040038   ADDIU A0, ZERO, 56
585:                 	TFT_24_7789_Write_Command(0x13);
9D015FCC  0F404EBF   JAL TFT_24_7789_Write_Command
9D015FD0  24040013   ADDIU A0, ZERO, 19
586:                 
587:                 	}
9D015FD4  8FBF0034   LW RA, 52(SP)
9D015FD8  8FBE0030   LW FP, 48(SP)
9D015FDC  8FB7002C   LW S7, 44(SP)
9D015FE0  8FB60028   LW S6, 40(SP)
9D015FE4  8FB50024   LW S5, 36(SP)
9D015FE8  8FB40020   LW S4, 32(SP)
9D015FEC  8FB3001C   LW S3, 28(SP)
9D015FF0  8FB20018   LW S2, 24(SP)
9D015FF4  8FB10014   LW S1, 20(SP)
9D015FF8  8FB00010   LW S0, 16(SP)
9D015FFC  03E00008   JR RA
9D016000  27BD0038   ADDIU SP, SP, 56
588:                 /*******************************************************************************/
589:                 
---  /Users/nitro/basic-badge/firmware/badge1.X/src/badge.c  --------------------------------------------
1:                   #include <xc.h>
2:                   #include "badge.h"
3:                   #include "basic/ubasic.h"
4:                   #include "basic/tokenizer.h"
5:                   #include <plib.h>
6:                   #include <stdlib.h>
7:                   #include <string.h>
8:                   #include <stdio.h>
9:                   #include <ctype.h>
10:                  #include <stdint.h>
11:                  #include <setjmp.h>
12:                  #include "Z80/sim.h"
13:                  #include "Z80/simglb.h"
14:                  
15:                  
16:                  
17:                  uint16_t basic_loads (int8_t * data, uint16_t maxlen);
18:                  uint16_t basic_saves (int8_t * data, uint16_t maxlen);
19:                  void init_z80_cpm (void);
20:                  void init_basic (void);
21:                  void init_userprog(void);
22:                  void loop_z80_cpm (void);
23:                  void loop_basic (void);
24:                  void loop_userprog(void);
25:                  void boot_animation(void);
26:                  void init_8080_basic (void);
27:                  void loop_8080_basic (void);
28:                  uint8_t cmd_exec (int8_t * cmd);
29:                  uint8_t basic_save_program (uint8_t * data, uint8_t slot);
30:                  uint8_t basic_load_program (uint8_t * data, uint8_t slot);
31:                  uint16_t get_free_mem(uint8_t * prog, uint16_t max_mem);
32:                  uint8_t add_prog_line (int8_t * line, int8_t * prog, int16_t linenum);
33:                  void list_more (void);
34:                  void menu(void);
35:                  void show_help(void);
36:                  uint32_t hash(int8_t *);
37:                  uint8_t get_command_index(uint32_t );
38:                  uint8_t wisecrack(int8_t *, uint16_t , unsigned char, uint8_t);
39:                  void clear_crack(void);
40:                  uint8_t random_crack(void);
41:                  void showmenu(void);
42:                  void show_version(void);
43:                  void fancyframe(void);
44:                  void clear_prompt(void);
45:                  void show_wrencher(void);
46:                  uint8_t playriff(unsigned char);
47:                  
48:                  /************ Defines ****************************/
49:                  #define STDIO_LOCAL_BUFF_SIZE	25
50:                  
51:                  //Prompt handling defines
52:                  #define COMMAND_MAX 32
53:                  #define TEXT_LEFT	4
54:                  #define PROMPT_Y	15
55:                  #define CRACK_Y		17
56:                  #define VERSION_X	33
57:                  #define VERSION_Y	18
58:                  #define CRACK_TIMEOUT 4000
59:                  //Menu color values
60:                  #define MENU_FRAME_FG	12
61:                  #define MENU_FRAME_BG	0
62:                  #define MENU_BANNER_FG	0
63:                  #define MENU_BANNER_BG	15
64:                  #define MENU_HEADER_FG	15
65:                  #define MENU_HEADER_BG	8
66:                  #define MENU_ENTRY_FG	15
67:                  #define MENU_ENTRY_BG	9
68:                  #define MENU_DEFAULT_FG 15
69:                  #define MENU_DEFAULT_BG 0
70:                  #define MENU_VERSION_FG	8
71:                  #define MENU_SECRET_COLOR 10
72:                  #define MENU_CRACK_COLOR 14
73:                  /********** End Defines **************************/
74:                  
75:                  /************* Function Prototypes ***************/
76:                  /*** End Function Prototypes **********************88*/
77:                  
78:                  int8_t bprog[BPROG_LEN+1];
79:                  int8_t bprog_init[700] =
80:                  "10 c = 1 + rnd 4\n\
81:                  20 color c,c+8\n\
82:                  30 for i=1 to 800\n\
83:                  40 chr 200 + (rnd 6)\n\
84:                  50 next i\n\
85:                  60 wait 100\n\
86:                  70 tune 60,64,67,800\n\
87:                  80 tune 57,62,66,800\n\
88:                  90 tune 59,64,47,800\n\
89:                  100 tune 59,62,67,800\n\
90:                  110 for i=60 to 72\n\
91:                  120 led (rnd 2),1\n\
92:                  130 led (rnd 2),0\n\
93:                  140 tune 0,0,i,20\n\
94:                  150 next i\n\
95:                  160 tune 67,71,74,1600\n\
96:                  170 for i=0 to 2\n\
97:                  180 led i,0\n\
98:                  190 next i\n\
99:                  200 color 15,0\n\
100:                 210 println \"Type more to see code\"\n\
101:                 220 println \" \"\n\
102:                 230 println \"Find documentation: hac.io/Mz3r \" \n";
103:                 
104:                 //a lot of magic numbers here, should be done properly
105:                 int8_t tprog[100],stdio_buff[50],key_buffer[10],char_out, stdio_local_buff[STDIO_LOCAL_BUFF_SIZE];
106:                 
107:                 uint8_t get_stat,key_buffer_ptr =0,cmd_line_buff[30], cmd_line_pointer,cmd_line_key_stat_old,prompt;
108:                 uint8_t stdio_local_len=0;
109:                 uint16_t term_pointer,vertical_shift;
110:                 int16_t prog_ptr;
111:                 int32_t i,j,len;
112:                 jmp_buf jbuf;
113:                 volatile uint8_t handle_display = 0;
114:                 volatile int8_t brk_key,stdio_src;
115:                 extern volatile uint16_t bufsize;
116:                 volatile uint32_t ticks;			// millisecond timer incremented in ISR
117:                 
118:                 extern const uint8_t ram_image[65536];
119:                 extern const uint8_t b2_rom[2048];
120:                 extern const uint8_t ram_init [30];
121:                 extern uint8_t ram_disk[RAMDISK_SIZE];
122:                 
123:                 
124:                 int8_t disp_buffer[DISP_BUFFER_HIGH+1][DISP_BUFFER_WIDE];
125:                 int8_t color_buffer[DISP_BUFFER_HIGH+1][DISP_BUFFER_WIDE];
126:                 
127:                 #define HASH_TABLE_LENGTH	13
128:                 const uint32_t  hashtable[HASH_TABLE_LENGTH] =
129:                 	{
130:                 	0,				//0
131:                 	0,				//1
132:                 	4080429,		//2
133:                 	3914880981u,	//3
134:                 	1670,			//4
135:                 	121730,			//5
136:                 	4108351,		//6
137:                 	138097304,		//7
138:                 	110149,			//8
139:                 	3174374908u,	//9
140:                 	132593272,		//10
141:                 	2802956003u,	//11
142:                 	3638929			//12
143:                 	};
144:                 
145:                 const uint8_t wrencher[18][41] = {
146:                 "    +mmy/                      /ymm+    ",
147:                 "      sMMh                    hMMs      ",
148:                 "h/  .hMMMM.                  -MMMMh.  /h",
149:                 "sMmyMMMMMMNo`              `oNMMMMMMymMs",
150:                 " :hNMMMMMMMMMo`:shmNNmhs:`oMMMMMMMMMNh: ",
151:                 "       :hMMN+sNMMMMMMMMMMNo+NMMh:       ",
152:                 "         -s:mMMMMMMMMMMMMMMm:s.         ",
153:                 "          `mMMMMMMMMMMMMMMMMm`          ",
154:                 "          +MMh.  -mMMd-  .hMM/          ",
155:                 "          oMM.  -+NMMN+-  .MMo          ",
156:                 "          -MMd/NMMMmmMMMN/dMM-          ",
157:                 "         -/sMMMMMMM::MMMMMMMs/-         ",
158:                 "       /dMMsoMMMMMMNNMMMMMNosMMd/       ",
159:                 " :hNMMMMMMMMd-hMMMMMMMMMMh-dMMMMMMMMNy: ",
160:                 "sMmyMMMMMMm+` /mNsoNm+sNm/ `omMMMMMNymMo",
161:                 "h:  .yMMMM.                  .MMMMy.  :h",
162:                 "      sMMh                    hMMs      ",
163:                 "   `ommh/                      /hmm+    "};
164:                 
165:                 const uint8_t rand_crack00[] = "Have you been into Branko's rakija?";
166:                 const uint8_t rand_crack01[] = "Prove you're human: 0b101010";
167:                 const uint8_t rand_crack02[] = "I don't think that mean what you think it means.";
168:                 const uint8_t rand_crack03[] = "Want to play a game?";
169:                 const uint8_t rand_crack04[] = "How do I get 30 extra live?";
170:                 const uint8_t rand_crack05[] = "Maybe you should RTFM: https://hac.io/Mz3r";
171:                 const uint8_t rand_crack06[] = "Erm... It's supposed to do that";
172:                 const uint8_t rand_crack07[] = "Too many errors on one line (make fewer)";
173:                 const uint8_t rand_crack08[] = "You are in a maze of twisty compiler features, all different";
174:                 const uint8_t rand_crack09[] = "Parse error: unexpected idoiot at the keyboard";
175:                 const uint8_t rand_crack10[] = "Program Lost -- Sorry.";
176:                 const uint8_t rand_crack11[] = "I find your lack of faith disturbing";
177:                 const uint8_t rand_crack12[] = "There are people who know what they're doing, then there's you";
178:                 const uint8_t rand_crack13[] = "My brain just exploded.";
179:                 const uint8_t rand_crack14[] = "You can't just start making up commands";
180:                 const uint8_t rand_crack15[] = "Try restarting shockwave";
181:                 const uint8_t rand_crack16[] = "That really grinds my ALU";
182:                 const uint8_t rand_crack17[] = "Erq ureevat";
183:                 const uint8_t rand_crack18[] = "I'm drawing a blank";
184:                 const uint8_t blanks[] = "                                      ";
185:                 
186:                 #define CRACKCOUNT 19
187:                 const uint8_t * cracks[CRACKCOUNT] =
188:                 	{
189:                 	rand_crack00,
190:                 	rand_crack01,
191:                 	rand_crack02,
192:                 	rand_crack03,
193:                 	rand_crack04,
194:                 	rand_crack05,
195:                 	rand_crack06,
196:                 	rand_crack07,
197:                 	rand_crack08,
198:                 	rand_crack09,
199:                 	rand_crack10,
200:                 	rand_crack11,
201:                 	rand_crack12,
202:                 	rand_crack13,
203:                 	rand_crack14,
204:                 	rand_crack15,
205:                 	rand_crack16,
206:                 	rand_crack17,
207:                 	rand_crack18
208:                 	};
209:                 
210:                 void show_help(void)
211:                 	{
9D01BE40  27BDFFE8   ADDIU SP, SP, -24
9D01BE44  AFBF0014   SW RA, 20(SP)
212:                 	clr_buffer();
9D01BE48  0F406E45   JAL clr_buffer
9D01BE4C  00000000   NOP
213:                 	set_cursor_state(0);
9D01BE50  0F404EAA   JAL set_cursor_state
9D01BE54  00002021   ADDU A0, ZERO, ZERO
214:                 	video_gotoxy(0,0);
9D01BE58  00002021   ADDU A0, ZERO, ZERO
9D01BE5C  0F40697A   JAL video_gotoxy
9D01BE60  00002821   ADDU A1, ZERO, ZERO
215:                 	video_set_color(3,1);
9D01BE64  24040003   ADDIU A0, ZERO, 3
9D01BE68  0F4068DD   JAL .LFB8, .LFE58, video_set_color
9D01BE6C  24050001   ADDIU A1, ZERO, 1
216:                 	stdio_write("Badge keyboard shortcuts:\n");
9D01BE70  3C049D03   LUI A0, -25341
9D01BE74  0F406F61   JAL stdio_write
9D01BE78  24849488   ADDIU A0, A0, -27512
217:                 	video_set_color(15,0);
9D01BE7C  2404000F   ADDIU A0, ZERO, 15
9D01BE80  0F4068DD   JAL .LFB8, .LFE58, video_set_color
9D01BE84  00002821   ADDU A1, ZERO, ZERO
218:                 	stdio_write("  Reset badge : shift-RESET\n");
9D01BE88  3C049D03   LUI A0, -25341
9D01BE8C  0F406F61   JAL stdio_write
9D01BE90  248494A4   ADDIU A0, A0, -27484
219:                 	stdio_write("  Type underscore: Rshift-dash\n");
9D01BE94  3C049D03   LUI A0, -25341
9D01BE98  0F406F61   JAL stdio_write
9D01BE9C  248494C4   ADDIU A0, A0, -27452
220:                 	stdio_write("  Fast reset: Lshift-Rshift-RESET\n");
9D01BEA0  3C049D03   LUI A0, -25341
9D01BEA4  0F406F61   JAL stdio_write
9D01BEA8  248494E4   ADDIU A0, A0, -27420
221:                 	stdio_write("  Serial console: Lshift-Rshift-BRK\n");
9D01BEAC  3C049D03   LUI A0, -25341
9D01BEB0  0F406F61   JAL stdio_write
9D01BEB4  24849508   ADDIU A0, A0, -27384
222:                 	video_set_color(1,11);
9D01BEB8  24040001   ADDIU A0, ZERO, 1
9D01BEBC  0F4068DD   JAL .LFB8, .LFE58, video_set_color
9D01BEC0  2405000B   ADDIU A1, ZERO, 11
223:                 	stdio_write("Badge Documentation:\n");
9D01BEC4  3C049D03   LUI A0, -25341
9D01BEC8  0F406F61   JAL stdio_write
9D01BECC  24849530   ADDIU A0, A0, -27344
224:                 	video_set_color(15,0);
9D01BED0  2404000F   ADDIU A0, ZERO, 15
9D01BED4  0F4068DD   JAL .LFB8, .LFE58, video_set_color
9D01BED8  00002821   ADDU A1, ZERO, ZERO
225:                 	stdio_write("  hac.io/Mz3r");
9D01BEDC  3C049D03   LUI A0, -25341
9D01BEE0  0F406F61   JAL stdio_write
9D01BEE4  24849548   ADDIU A0, A0, -27320
226:                 	}
9D01BEE8  8FBF0014   LW RA, 20(SP)
9D01BEEC  03E00008   JR RA
9D01BEF0  27BD0018   ADDIU SP, SP, 24
227:                 
228:                 //B_BDG005
229:                 void wake_return(void)
230:                 	{
9D01B788  03E00008   JR RA
9D01B78C  00000000   NOP
231:                 	//By default, this will be called after waking from sleep. It should do
232:                 	//noting. This is a placeholder for user programs to set the function pointer.
233:                 	return;
234:                 	}
235:                 
236:                 void badge_init (void)
237:                 	{
238:                 	//B_BDG009
239:                 //	start_after_wake = &wake_return; //Function pointer for waking from sleep
240:                 	ticks = 0;
9D01B790  AF8081E0   SW ZERO, -32288(GP)
241:                 	stdio_src = STDIO_LOCAL;
9D01B794  A38081D5   SB ZERO, -32299(GP)
242:                 //	stdio_src = STDIO_TTY1;
243:                 //	term_init();
244:                 //	strcpy(bprog,bprog_init);
245:                 //	set_cursor_state(1);
246:                     handle_display = 0;
9D01B798  A3808195   SB ZERO, -32363(GP)
9D01B79C  03E00008   JR RA
9D01B7A0  00000000   NOP
247:                 	}
248:                 
249:                 ////B_BDG002
250:                 //void badge_menu(void)
251:                 //	{
252:                 //	showmenu();
253:                 //	
254:                 //	int8_t char_out;
255:                 //	uint8_t menu_buff[COMMAND_MAX], menu_pointer;
256:                 //	menu_pointer=0;
257:                 //	int16_t len, i;
258:                 //	uint8_t clear_flag = 0;
259:                 //	uint32_t  wait_to_clear = 0;
260:                 //	
261:                 //	uint8_t random_has_been_seeded = 0;
262:                 //	
263:                 //	while (1)
264:                 //		{
265:                 //		if (clear_flag)
266:                 //			{
267:                 //			if (millis() > wait_to_clear)
268:                 //				{
269:                 //				clear_flag = 0;
270:                 //				clear_crack();
271:                 //				}
272:                 //			}
273:                 //		uint8_t get_stat = stdio_get(&char_out);
274:                 //		if (get_stat!=0)
275:                 //			{
276:                 //			
277:                 //			//Seed random number if we haven't already
278:                 //			if (random_has_been_seeded == 0)
279:                 //				{
280:                 //				//Pull seed directly from TIMER1 register
281:                 //				srand(*(char*)0xBF800610);
282:                 //				++random_has_been_seeded;
283:                 //				}
284:                 //			if (char_out==K_UP) char_out='U';
285:                 //			if (char_out==K_DN) char_out='D';
286:                 //			if (char_out==K_LT) char_out='L';
287:                 //			if (char_out==K_RT) char_out='R';
288:                 //			stdio_c(char_out);
289:                 //			if (char_out==BACKSPACE)
290:                 //				{
291:                 //				if (menu_pointer)
292:                 //					{
293:                 //					//We only need to do this if we're not at position 0
294:                 //					--menu_pointer;
295:                 //					menu_buff[menu_pointer] = 0;
296:                 //					int16_t cursorx, cursory;
297:                 //					cursorx = video_getx();
298:                 //					cursory = video_gety();
299:                 //					stdio_write(" ");
300:                 //					video_gotoxy(cursorx, cursory);
301:                 //					}
302:                 //				else
303:                 //					{
304:                 //					//Don't let backspace key move left of input position
305:                 //					video_gotoxy(TEXT_LEFT+2,PROMPT_Y);
306:                 //					}
307:                 //				}
308:                 //			else if (char_out==NEWLINE)
309:                 //				{
310:                 //				//Erase where the funny messages are written
311:                 //				clear_crack();
312:                 //							
313:                 //				menu_buff[menu_pointer] = 0;	//add zero terminator
314:                 //				//Check entry and react
315:                 //				
316:                 //				if (menu_buff[0] == 0)
317:                 //					{
318:                 //					//No characters were input, this stops user from just
319:                 //					//hitting enter to display all funny messages
320:                 //					clear_prompt();
321:                 //					menu_pointer = 0;
322:                 //					continue;
323:                 //					}
324:                 //				if (strcmp(menu_buff,"1")==0)
325:                 //					{
326:                 //					video_clrscr();
327:                 //					init_basic();
328:                 //					while (1) loop_basic();
329:                 //					}
330:                 //				else if (strcmp(menu_buff,"2")==0)
331:                 //					{
332:                 //					video_clrscr();
333:                 //					init_z80_cpm();
334:                 //					while (1) loop_z80_cpm();
335:                 //					}			
336:                 //				else if (strcmp(menu_buff,"3")==0)
337:                 //					{
338:                 //					init_8080_basic();
339:                 //					while (1) loop_8080_basic();
340:                 //					}
341:                 //				else if (strcmp(menu_buff,"4")==0)
342:                 //					{
343:                 //					enable_display_scanning(0); //Shut off auto-scanning of character buffer
344:                 //					tetrapuzz();
345:                 //					}
346:                 //				//B_BDG006		
347:                 //				else if (strcmp(menu_buff,"5")==0)
348:                 //					{
349:                 //					stdio_local_buffer_puts("c:\nzork1\n");
350:                 //					video_clrscr();
351:                 //					video_set_color(0,14);
352:                 //					stdio_write("\n\n\n\n\n\nPROTIP:\n\tUse Shift-Enter when playing ZORK!\n\n");
353:                 //					video_set_color(15,0);
354:                 //					wait_ms(2000);
355:                 //					init_z80_cpm();
356:                 //					while (1) loop_z80_cpm();
357:                 //					}
358:                 //				else if (strcmp(menu_buff,"6")==0)
359:                 //					{
360:                 //					init_userprog();
361:                 //					while (1) loop_userprog();
362:                 //					}	
363:                 //				else
364:                 //					{
365:                 //					switch (get_command_index(hash(menu_buff)))
366:                 //						{
367:                 //						//case 0: break;
368:                 //						case 2: clear_flag = wisecrack("Make your own sandwich",TEXT_LEFT,CRACK_Y, 0); break;
369:                 //						case 3: clear_flag = wisecrack("Existence itself is not a hack", TEXT_LEFT,CRACK_Y, 0); break;
370:                 //						case 4: clear_flag = wisecrack("101010 *IS* the answer", TEXT_LEFT,CRACK_Y, 0); break;
371:                 //						case 5: clear_flag = wisecrack("Hackers don't need manuals", TEXT_LEFT,CRACK_Y, 0); break;
372:                 //						case 6: clear_flag = wisecrack("Han shot first", TEXT_LEFT,CRACK_Y, 0); break;
373:                 //						case 7: clear_flag = wisecrack("You're in a room filled with hackers", TEXT_LEFT,CRACK_Y, 0); break;
374:                 //						case 8: clear_flag = wisecrack("I am afraid I can't do that Dave", TEXT_LEFT,CRACK_Y, 0); break;
375:                 //						case 9: show_wrencher(); break;
376:                 //						case 10: play_mario_tune(); break;
377:                 //						case 11: 
378:                 //							handle_display = 0;
379:                 //							play_snake();
380:                 //							break;
381:                 //						case 12: show_help(); while(1) { ;; };
382:                 //						default: clear_flag = random_crack(); break;
383:                 //						}
384:                 //					}
385:                 //
386:                 //				
387:                 //				clear_prompt();
388:                 //				menu_pointer = 0;
389:                 //				menu_buff[menu_pointer] = 0;
390:                 //				}
391:                 //				
392:                 //			else
393:                 //				{
394:                 //				menu_buff[menu_pointer++] = char_out;
395:                 //				if (menu_pointer >= COMMAND_MAX-1) 
396:                 //					{
397:                 //					menu_pointer = 0;
398:                 //					menu_buff[menu_pointer] = 0;
399:                 //					clear_flag = wisecrack("Boo, too big.",TEXT_LEFT,CRACK_Y,1);
400:                 //					clear_prompt();
401:                 //					}
402:                 //				}
403:                 //			if (clear_flag)
404:                 //				{
405:                 //				wait_to_clear = millis() + CRACK_TIMEOUT;
406:                 //				}
407:                 //			}
408:                 //		}
409:                 //	}
410:                 
411:                 uint32_t  hash(int8_t *command)
412:                 	{
9D01B7A4  24860066   ADDIU A2, A0, 102
413:                 	uint32_t  hash = 0;
414:                 	uint8_t infinite_loop_breaker = 0;
415:                 	uint8_t c;
416:                 	while (c = *command++)
9D01B7A8  0B406DEF   J 0x9D01B7BC
9D01B7AC  00001021   ADDU V0, ZERO, ZERO
9D01B7BC  24840001   ADDIU A0, A0, 1
9D01B7C0  9083FFFF   LBU V1, -1(A0)
9D01B7C4  1460FFFA   BNE V1, ZERO, 0x9D01B7B0
9D01B7C8  00022940   SLL A1, V0, 5
9D01B7CC  03E00008   JR RA
9D01B7D0  00000000   NOP
417:                 		{
418:                 		hash = (hash*33)^c;
9D01B7B0  00A21021   ADDU V0, A1, V0
419:                 		if (infinite_loop_breaker++ > 100) return 0;	//In case we get stuck
9D01B7B4  10860007   BEQ A0, A2, 0x9D01B7D4
9D01B7B8  00431026   XOR V0, V0, V1
420:                 		}
421:                 	//sprintf(stdio_buff, "has %d\n", hash);
422:                 	return hash;
423:                 	}
9D01B7D4  03E00008   JR RA
9D01B7D8  00001021   ADDU V0, ZERO, ZERO
424:                 
425:                 uint8_t get_command_index(uint32_t  hash_value)
426:                 	{
427:                 	uint8_t i;
428:                 	for (i=0; i<HASH_TABLE_LENGTH; i++)
9D01B7E8  24020001   ADDIU V0, ZERO, 1
9D01B7EC  2406000D   ADDIU A2, ZERO, 13
9D01B7FC  24420001   ADDIU V0, V0, 1
9D01B800  304200FF   ANDI V0, V0, 255
9D01B804  1446FFFA   BNE V0, A2, 0x9D01B7F0
9D01B808  24630004   ADDIU V1, V1, 4
9D01B80C  03E00008   JR RA
9D01B810  00001021   ADDU V0, ZERO, ZERO
9D01B814  03E00008   JR RA
9D01B818  00001021   ADDU V0, ZERO, ZERO
429:                 		{
430:                 		if (hashtable[i] == hash_value) return i;
9D01B7DC  1080000D   BEQ A0, ZERO, 0x9D01B814
9D01B7E0  3C039D03   LUI V1, -25341
9D01B7E4  24639C70   ADDIU V1, V1, -25488
9D01B7F0  8C650000   LW A1, 0(V1)
9D01B7F4  10A40009   BEQ A1, A0, 0x9D01B81C
9D01B7F8  00000000   NOP
431:                 		}
432:                 	return 0;
433:                 	}
9D01B81C  03E00008   JR RA
9D01B820  00000000   NOP
434:                 
435:                 uint8_t random_crack(void)
436:                 	{
9D01BFFC  27BDFFE8   ADDIU SP, SP, -24
9D01C000  AFBF0014   SW RA, 20(SP)
437:                 	uint8_t i = (uint8_t)rand()%CRACKCOUNT;
9D01C004  0F40ED55   JAL .Letext0, .LFE0, rand
9D01C008  00000000   NOP
9D01C00C  304200FF   ANDI V0, V0, 255
9D01C010  3C04AF28   LUI A0, -20696
9D01C014  24846BCB   ADDIU A0, A0, 27595
9D01C018  00440019   MULTU 0, V0, A0
9D01C01C  00002010   MFHI A0
9D01C020  00441823   SUBU V1, V0, A0
9D01C024  00031842   SRL V1, V1, 1
9D01C028  00831821   ADDU V1, A0, V1
9D01C02C  00031902   SRL V1, V1, 4
9D01C030  00032880   SLL A1, V1, 2
9D01C034  00032100   SLL A0, V1, 4
9D01C038  00A42021   ADDU A0, A1, A0
9D01C03C  00831823   SUBU V1, A0, V1
9D01C040  00431023   SUBU V0, V0, V1
438:                 	return wisecrack((uint8_t *)cracks[i],TEXT_LEFT, CRACK_Y,1);
9D01C044  304200FF   ANDI V0, V0, 255
9D01C048  00021080   SLL V0, V0, 2
9D01C04C  3C04A001   LUI A0, -24575
9D01C050  24849BA4   ADDIU A0, A0, -25692
9D01C054  00441021   ADDU V0, V0, A0
9D01C058  8C440000   LW A0, 0(V0)
9D01C05C  24050004   ADDIU A1, ZERO, 4
9D01C060  24060011   ADDIU A2, ZERO, 17
9D01C064  0F406FBD   JAL wisecrack
9D01C068  24070001   ADDIU A3, ZERO, 1
439:                 	}
9D01C06C  8FBF0014   LW RA, 20(SP)
9D01C070  03E00008   JR RA
9D01C074  27BD0018   ADDIU SP, SP, 24
440:                 
441:                 uint8_t wisecrack(int8_t * quip, uint16_t x, uint8_t y, uint8_t type)
442:                 	{
9D01BEF4  27BDFF98   ADDIU SP, SP, -104
9D01BEF8  AFBF0064   SW RA, 100(SP)
9D01BEFC  AFB10060   SW S1, 96(SP)
9D01BF00  AFB0005C   SW S0, 92(SP)
9D01BF04  00A08821   ADDU S1, A1, ZERO
9D01BF08  00C08021   ADDU S0, A2, ZERO
443:                 	uint8_t index, line1index, line2index;
444:                 	uint8_t line1[33];
445:                 	uint8_t line2[33];
446:                 	index = 0;
447:                 	line1index = 0;
9D01BF14  00005021   ADDU T2, ZERO, ZERO
448:                 	line2index = 0;
9D01BF10  00005821   ADDU T3, ZERO, ZERO
449:                 	while (quip[index] != 0)
9D01BF0C  00001021   ADDU V0, ZERO, ZERO
9D01BF18  0B406FDB   J 0x9D01BF6C
9D01BF1C  24050040   ADDIU A1, ZERO, 64
9D01BF70  80630000   LB V1, 0(V1)
9D01BF74  1460FFEA   BNE V1, ZERO, 0x9D01BF20
9D01BF78  304800FF   ANDI T0, V0, 255
450:                 		{
451:                 		if (index < 32)
9D01BF20  2D090020   SLTIU T1, T0, 32
9D01BF24  11200007   BEQ T1, ZERO, 0x9D01BF44
9D01BF28  2D080040   SLTIU T0, T0, 64
452:                 			{
453:                 			line1[line1index++] = quip[index];
9D01BF2C  25460001   ADDIU A2, T2, 1
9D01BF30  27A80010   ADDIU T0, SP, 16
9D01BF34  010A5021   ADDU T2, T0, T2
9D01BF38  A1430000   SB V1, 0(T2)
9D01BF3C  0B406FD8   J 0x9D01BF60
9D01BF40  30CA00FF   ANDI T2, A2, 255
454:                 			}
455:                 		else if (index < 64)
9D01BF44  51000007   BEQL T0, ZERO, 0x9D01BF64
9D01BF48  24420001   ADDIU V0, V0, 1
456:                 			{
457:                 			line2[line2index++] = quip[index];
9D01BF4C  25660001   ADDIU A2, T3, 1
9D01BF50  27A80010   ADDIU T0, SP, 16
9D01BF54  010B5821   ADDU T3, T0, T3
9D01BF58  A1630024   SB V1, 36(T3)
9D01BF5C  30CB00FF   ANDI T3, A2, 255
9D01BF60  24420001   ADDIU V0, V0, 1
458:                 			}
459:                 		if (++index >= 64) break;
9D01BF64  50450006   BEQL V0, A1, 0x9D01BF80
9D01BF68  27A20010   ADDIU V0, SP, 16
9D01BF6C  00821821   ADDU V1, A0, V0
460:                 		}
461:                 	line1[line1index] = 0;
9D01BF7C  27A20010   ADDIU V0, SP, 16
9D01BF80  004A5021   ADDU T2, V0, T2
9D01BF84  A1400000   SB ZERO, 0(T2)
462:                 	line2[line2index] = 0;
9D01BF88  004B5821   ADDU T3, V0, T3
463:                 	
464:                 	if (type == 0)
9D01BF8C  14E00006   BNE A3, ZERO, 0x9D01BFA8
9D01BF90  A1600024   SB ZERO, 36(T3)
465:                 		{
466:                 		video_set_color(MENU_SECRET_COLOR, MENU_DEFAULT_BG);
9D01BF94  2404000A   ADDIU A0, ZERO, 10
9D01BF98  0F4068DD   JAL .LFB8, .LFE58, video_set_color
9D01BF9C  00002821   ADDU A1, ZERO, ZERO
9D01BFA0  0B406FEE   J 0x9D01BFB8
9D01BFA4  7C118C20   SEB S1, S1
467:                 		}
468:                 	else video_set_color(MENU_CRACK_COLOR, MENU_DEFAULT_BG);
9D01BFA8  2404000E   ADDIU A0, ZERO, 14
9D01BFAC  0F4068DD   JAL .LFB8, .LFE58, video_set_color
9D01BFB0  00002821   ADDU A1, ZERO, ZERO
469:                 	video_gotoxy(x,y);
9D01BFB4  7C118C20   SEB S1, S1
9D01BFB8  02202021   ADDU A0, S1, ZERO
9D01BFBC  0F40697A   JAL video_gotoxy
9D01BFC0  7C102C20   SEB A1, S0
470:                 	stdio_write(line1);
9D01BFC4  0F406F61   JAL stdio_write
9D01BFC8  27A40010   ADDIU A0, SP, 16
471:                 	video_gotoxy(x,y+1);
9D01BFCC  26050001   ADDIU A1, S0, 1
9D01BFD0  02202021   ADDU A0, S1, ZERO
9D01BFD4  0F40697A   JAL video_gotoxy
9D01BFD8  7C052C20   SEB A1, A1
472:                 	stdio_write(line2);
9D01BFDC  0F406F61   JAL stdio_write
9D01BFE0  27A40034   ADDIU A0, SP, 52
473:                 	return 1;
474:                 	}
9D01BFE4  24020001   ADDIU V0, ZERO, 1
9D01BFE8  8FBF0064   LW RA, 100(SP)
9D01BFEC  8FB10060   LW S1, 96(SP)
9D01BFF0  8FB0005C   LW S0, 92(SP)
9D01BFF4  03E00008   JR RA
9D01BFF8  27BD0068   ADDIU SP, SP, 104
475:                 
476:                 void clear_crack(void)
477:                 	{
9D01C078  27BDFFE0   ADDIU SP, SP, -32
9D01C07C  AFBF001C   SW RA, 28(SP)
9D01C080  AFB20018   SW S2, 24(SP)
9D01C084  AFB10014   SW S1, 20(SP)
478:                 	int16_t cursorx, cursory;
479:                 	cursorx = video_getx();
9D01C088  0F406A1C   JAL video_getx
9D01C08C  AFB00010   SW S0, 16(SP)
480:                 	cursory = video_gety();
9D01C090  0F406A1E   JAL .LFB47, .LFE46, video_gety
9D01C094  00409021   ADDU S2, V0, ZERO
9D01C098  00408821   ADDU S1, V0, ZERO
481:                 	video_gotoxy(1,CRACK_Y);
9D01C09C  24040001   ADDIU A0, ZERO, 1
9D01C0A0  0F40697A   JAL video_gotoxy
9D01C0A4  24050011   ADDIU A1, ZERO, 17
482:                 	stdio_write((uint8_t *)blanks);
9D01C0A8  3C109D03   LUI S0, -25341
9D01C0AC  0F406F61   JAL stdio_write
9D01C0B0  260496B4   ADDIU A0, S0, -26956
483:                 	video_gotoxy(1,CRACK_Y+1);
9D01C0B4  24040001   ADDIU A0, ZERO, 1
9D01C0B8  0F40697A   JAL video_gotoxy
9D01C0BC  24050012   ADDIU A1, ZERO, 18
484:                 	stdio_write((uint8_t *)blanks);
9D01C0C0  0F406F61   JAL stdio_write
9D01C0C4  260496B4   ADDIU A0, S0, -26956
485:                 	video_gotoxy(cursorx,cursory);
9D01C0C8  02402021   ADDU A0, S2, ZERO
9D01C0CC  0F40697A   JAL video_gotoxy
9D01C0D0  02202821   ADDU A1, S1, ZERO
486:                 	}
9D01C0D4  8FBF001C   LW RA, 28(SP)
9D01C0D8  8FB20018   LW S2, 24(SP)
9D01C0DC  8FB10014   LW S1, 20(SP)
9D01C0E0  8FB00010   LW S0, 16(SP)
9D01C0E4  03E00008   JR RA
9D01C0E8  27BD0020   ADDIU SP, SP, 32
487:                 
488:                 void showmenu(void)
489:                 	{
9D01C304  27BDFFE8   ADDIU SP, SP, -24
9D01C308  AFBF0014   SW RA, 20(SP)
490:                 	//Set some background boxes
491:                 	video_clrscr();
9D01C30C  0F406A2B   JAL video_clrscr
9D01C310  AFB00010   SW S0, 16(SP)
492:                 	video_set_color(MENU_BANNER_FG,MENU_BANNER_BG);
9D01C314  00002021   ADDU A0, ZERO, ZERO
9D01C318  0F4068DD   JAL .LFB8, .LFE58, video_set_color
9D01C31C  2405000F   ADDIU A1, ZERO, 15
493:                 	video_gotoxy(1,1);
9D01C320  24040001   ADDIU A0, ZERO, 1
9D01C324  0F40697A   JAL video_gotoxy
9D01C328  24050001   ADDIU A1, ZERO, 1
494:                 	stdio_write((uint8_t *)blanks);
9D01C32C  3C109D03   LUI S0, -25341
9D01C330  0F406F61   JAL stdio_write
9D01C334  260496B4   ADDIU A0, S0, -26956
495:                 	video_gotoxy(1,2);
9D01C338  24040001   ADDIU A0, ZERO, 1
9D01C33C  0F40697A   JAL video_gotoxy
9D01C340  24050002   ADDIU A1, ZERO, 2
496:                 	stdio_write((uint8_t *)blanks);
9D01C344  0F406F61   JAL stdio_write
9D01C348  260496B4   ADDIU A0, S0, -26956
497:                 	video_gotoxy(1,3);
9D01C34C  24040001   ADDIU A0, ZERO, 1
9D01C350  0F40697A   JAL video_gotoxy
9D01C354  24050003   ADDIU A1, ZERO, 3
498:                 	stdio_write((uint8_t *)blanks);
9D01C358  0F406F61   JAL stdio_write
9D01C35C  260496B4   ADDIU A0, S0, -26956
499:                 	
500:                 	video_set_color(MENU_HEADER_FG,MENU_HEADER_BG);
9D01C360  2404000F   ADDIU A0, ZERO, 15
9D01C364  0F4068DD   JAL .LFB8, .LFE58, video_set_color
9D01C368  24050008   ADDIU A1, ZERO, 8
501:                 	video_gotoxy(3,5);
9D01C36C  24040003   ADDIU A0, ZERO, 3
9D01C370  0F40697A   JAL video_gotoxy
9D01C374  24050005   ADDIU A1, ZERO, 5
502:                 	stdio_write("                                  ");
9D01C378  3C109D03   LUI S0, -25341
9D01C37C  0F406F61   JAL stdio_write
9D01C380  26049564   ADDIU A0, S0, -27292
503:                 	video_set_color(MENU_ENTRY_FG,MENU_ENTRY_BG);
9D01C384  2404000F   ADDIU A0, ZERO, 15
9D01C388  0F4068DD   JAL .LFB8, .LFE58, video_set_color
9D01C38C  24050009   ADDIU A1, ZERO, 9
504:                 	video_gotoxy(3,6);
9D01C390  24040003   ADDIU A0, ZERO, 3
9D01C394  0F40697A   JAL video_gotoxy
9D01C398  24050006   ADDIU A1, ZERO, 6
505:                 	stdio_write("                                  ");
9D01C39C  0F406F61   JAL stdio_write
9D01C3A0  26049564   ADDIU A0, S0, -27292
506:                 	video_gotoxy(3,7);
9D01C3A4  24040003   ADDIU A0, ZERO, 3
9D01C3A8  0F40697A   JAL video_gotoxy
9D01C3AC  24050007   ADDIU A1, ZERO, 7
507:                 	stdio_write("                                  ");
9D01C3B0  0F406F61   JAL stdio_write
9D01C3B4  26049564   ADDIU A0, S0, -27292
508:                 	video_gotoxy(3,8);
9D01C3B8  24040003   ADDIU A0, ZERO, 3
9D01C3BC  0F40697A   JAL video_gotoxy
9D01C3C0  24050008   ADDIU A1, ZERO, 8
509:                 	stdio_write("                                  ");
9D01C3C4  0F406F61   JAL stdio_write
9D01C3C8  26049564   ADDIU A0, S0, -27292
510:                 	video_gotoxy(3,9);
9D01C3CC  24040003   ADDIU A0, ZERO, 3
9D01C3D0  0F40697A   JAL video_gotoxy
9D01C3D4  24050009   ADDIU A1, ZERO, 9
511:                 	stdio_write("                                  ");
9D01C3D8  0F406F61   JAL stdio_write
9D01C3DC  26049564   ADDIU A0, S0, -27292
512:                 	video_gotoxy(3,10);
9D01C3E0  24040003   ADDIU A0, ZERO, 3
9D01C3E4  0F40697A   JAL video_gotoxy
9D01C3E8  2405000A   ADDIU A1, ZERO, 10
513:                 	stdio_write("                                  ");
9D01C3EC  0F406F61   JAL stdio_write
9D01C3F0  26049564   ADDIU A0, S0, -27292
514:                 	video_gotoxy(3,11);
9D01C3F4  24040003   ADDIU A0, ZERO, 3
9D01C3F8  0F40697A   JAL video_gotoxy
9D01C3FC  2405000B   ADDIU A1, ZERO, 11
515:                 	stdio_write("                                  ");
9D01C400  0F406F61   JAL stdio_write
9D01C404  26049564   ADDIU A0, S0, -27292
516:                 	
517:                 	//Draw frame
518:                 	video_set_color(MENU_FRAME_FG,MENU_FRAME_BG);
9D01C408  2404000C   ADDIU A0, ZERO, 12
9D01C40C  0F4068DD   JAL .LFB8, .LFE58, video_set_color
9D01C410  00002821   ADDU A1, ZERO, ZERO
519:                 	fancyframe();
9D01C414  0F407089   JAL fancyframe
9D01C418  00000000   NOP
520:                 	
521:                 	//Print menu text
522:                 	video_set_color(MENU_BANNER_FG,MENU_BANNER_BG);
9D01C41C  00002021   ADDU A0, ZERO, ZERO
9D01C420  0F4068DD   JAL .LFB8, .LFE58, video_set_color
9D01C424  2405000F   ADDIU A1, ZERO, 15
523:                 	video_gotoxy(TEXT_LEFT,2);
9D01C428  24040004   ADDIU A0, ZERO, 4
9D01C42C  0F40697A   JAL video_gotoxy
9D01C430  24050002   ADDIU A1, ZERO, 2
524:                 	stdio_write("Hackaday Belgrade Conference");
9D01C434  3C049D03   LUI A0, -25341
9D01C438  0F406F61   JAL stdio_write
9D01C43C  24849588   ADDIU A0, A0, -27256
525:                 	video_gotoxy(TEXT_LEFT,5);
9D01C440  24040004   ADDIU A0, ZERO, 4
9D01C444  0F40697A   JAL video_gotoxy
9D01C448  24050005   ADDIU A1, ZERO, 5
526:                 	video_set_color(MENU_HEADER_FG,MENU_HEADER_BG);
9D01C44C  2404000F   ADDIU A0, ZERO, 15
9D01C450  0F4068DD   JAL .LFB8, .LFE58, video_set_color
9D01C454  24050008   ADDIU A1, ZERO, 8
527:                 	stdio_write("Type a command and hit ENTER");
9D01C458  3C049D03   LUI A0, -25341
9D01C45C  0F406F61   JAL stdio_write
9D01C460  248495A8   ADDIU A0, A0, -27224
528:                 	video_gotoxy(TEXT_LEFT,6);
9D01C464  24040004   ADDIU A0, ZERO, 4
9D01C468  0F40697A   JAL video_gotoxy
9D01C46C  24050006   ADDIU A1, ZERO, 6
529:                 	video_set_color(MENU_ENTRY_FG,MENU_ENTRY_BG);
9D01C470  2404000F   ADDIU A0, ZERO, 15
9D01C474  0F4068DD   JAL .LFB8, .LFE58, video_set_color
9D01C478  24050009   ADDIU A1, ZERO, 9
530:                 	stdio_write("1 - Hackaday BASIC");
9D01C47C  3C049D03   LUI A0, -25341
9D01C480  0F406F61   JAL stdio_write
9D01C484  248495C8   ADDIU A0, A0, -27192
531:                 	video_gotoxy(TEXT_LEFT,7);
9D01C488  24040004   ADDIU A0, ZERO, 4
9D01C48C  0F40697A   JAL video_gotoxy
9D01C490  24050007   ADDIU A1, ZERO, 7
532:                 	stdio_write("2 - CP/M @ Z80");
9D01C494  3C049D03   LUI A0, -25341
9D01C498  0F406F61   JAL stdio_write
9D01C49C  248495DC   ADDIU A0, A0, -27172
533:                 	video_gotoxy(TEXT_LEFT,8);
9D01C4A0  24040004   ADDIU A0, ZERO, 4
9D01C4A4  0F40697A   JAL video_gotoxy
9D01C4A8  24050008   ADDIU A1, ZERO, 8
534:                 	stdio_write("3 - Tiny Basic @ 8080");
9D01C4AC  3C049D03   LUI A0, -25341
9D01C4B0  0F406F61   JAL stdio_write
9D01C4B4  248495EC   ADDIU A0, A0, -27156
535:                 	video_gotoxy(TEXT_LEFT,9);
9D01C4B8  24040004   ADDIU A0, ZERO, 4
9D01C4BC  0F40697A   JAL video_gotoxy
9D01C4C0  24050009   ADDIU A1, ZERO, 9
536:                 	stdio_write("4 - Play Badgetris!");
9D01C4C4  3C049D03   LUI A0, -25341
9D01C4C8  0F406F61   JAL stdio_write
9D01C4CC  24849604   ADDIU A0, A0, -27132
537:                 	video_gotoxy(TEXT_LEFT,10);
9D01C4D0  24040004   ADDIU A0, ZERO, 4
9D01C4D4  0F40697A   JAL video_gotoxy
9D01C4D8  2405000A   ADDIU A1, ZERO, 10
538:                 	stdio_write("5 - Zork @ CP/M @ Z80");
9D01C4DC  3C049D03   LUI A0, -25341
9D01C4E0  0F406F61   JAL stdio_write
9D01C4E4  24849618   ADDIU A0, A0, -27112
539:                 	video_gotoxy(TEXT_LEFT,11);
9D01C4E8  24040004   ADDIU A0, ZERO, 4
9D01C4EC  0F40697A   JAL video_gotoxy
9D01C4F0  2405000B   ADDIU A1, ZERO, 11
540:                 	stdio_write("6 - User Program");
9D01C4F4  3C049D03   LUI A0, -25341
9D01C4F8  0F406F61   JAL stdio_write
9D01C4FC  24849630   ADDIU A0, A0, -27088
541:                 	
542:                 	show_version();
9D01C500  0F40703B   JAL show_version
9D01C504  00000000   NOP
543:                 	clear_prompt();
9D01C508  0F40704C   JAL clear_prompt
9D01C50C  00000000   NOP
544:                 	}
9D01C510  8FBF0014   LW RA, 20(SP)
9D01C514  8FB00010   LW S0, 16(SP)
9D01C518  03E00008   JR RA
9D01C51C  27BD0018   ADDIU SP, SP, 24
545:                 
546:                 void show_version(void)
547:                 	{
9D01C0EC  27BDFFE8   ADDIU SP, SP, -24
9D01C0F0  AFBF0014   SW RA, 20(SP)
548:                 	video_set_color(MENU_VERSION_FG,MENU_DEFAULT_BG);
9D01C0F4  24040008   ADDIU A0, ZERO, 8
9D01C0F8  0F4068DD   JAL .LFB8, .LFE58, video_set_color
9D01C0FC  00002821   ADDU A1, ZERO, ZERO
549:                 	video_gotoxy(VERSION_X,VERSION_Y);
9D01C100  24040021   ADDIU A0, ZERO, 33
9D01C104  0F40697A   JAL video_gotoxy
9D01C108  24050012   ADDIU A1, ZERO, 18
550:                 	stdio_write("v");
9D01C10C  3C049D03   LUI A0, -25341
9D01C110  0F406F61   JAL stdio_write
9D01C114  24849558   ADDIU A0, A0, -27304
551:                 	stdio_write((int8_t *)get_firmware_string());
9D01C118  3C049D03   LUI A0, -25341
9D01C11C  0F406F61   JAL stdio_write
9D01C120  2484946C   ADDIU A0, A0, -27540
552:                 	}
9D01C124  8FBF0014   LW RA, 20(SP)
9D01C128  03E00008   JR RA
9D01C12C  27BD0018   ADDIU SP, SP, 24
553:                 
554:                 void fancyframe(void)
555:                 	{
9D01C224  27BDFFE0   ADDIU SP, SP, -32
9D01C228  AFBF001C   SW RA, 28(SP)
9D01C22C  AFB20018   SW S2, 24(SP)
9D01C230  AFB10014   SW S1, 20(SP)
9D01C234  AFB00010   SW S0, 16(SP)
556:                 	uint16_t i;
557:                 	video_gotoxy(0,0);
9D01C238  00002021   ADDU A0, ZERO, ZERO
9D01C23C  0F40697A   JAL video_gotoxy
9D01C240  00002821   ADDU A1, ZERO, ZERO
558:                 	stdio_c(201);
9D01C244  0F407069   JAL stdio_c
9D01C248  240400C9   ADDIU A0, ZERO, 201
9D01C24C  24100026   ADDIU S0, ZERO, 38
559:                 	for (i=0; i<38; i++) stdio_c(205);
9D01C250  0F407069   JAL stdio_c
9D01C254  240400CD   ADDIU A0, ZERO, 205
9D01C258  2610FFFF   ADDIU S0, S0, -1
9D01C25C  3210FFFF   ANDI S0, S0, -1
9D01C260  1600FFFB   BNE S0, ZERO, 0x9D01C250
9D01C264  00000000   NOP
560:                 	stdio_c(187);
9D01C268  0F407069   JAL stdio_c
9D01C26C  240400BB   ADDIU A0, ZERO, 187
561:                 	video_gotoxy(0,39);
9D01C270  00002021   ADDU A0, ZERO, ZERO
9D01C274  0F40697A   JAL video_gotoxy
9D01C278  24050027   ADDIU A1, ZERO, 39
562:                 	stdio_c(200);
9D01C27C  0F407069   JAL stdio_c
9D01C280  240400C8   ADDIU A0, ZERO, 200
9D01C284  24100026   ADDIU S0, ZERO, 38
563:                 	for (i=0; i<38; i++) stdio_c(205);
9D01C288  0F407069   JAL stdio_c
9D01C28C  240400CD   ADDIU A0, ZERO, 205
9D01C290  2610FFFF   ADDIU S0, S0, -1
9D01C294  3210FFFF   ANDI S0, S0, -1
9D01C298  1600FFFB   BNE S0, ZERO, 0x9D01C288
9D01C29C  00000000   NOP
564:                 	stdio_c(188);
9D01C2A0  0F407069   JAL stdio_c
9D01C2A4  240400BC   ADDIU A0, ZERO, 188
565:                 	for (i=1; i<19; i++)
9D01C2A8  24100001   ADDIU S0, ZERO, 1
9D01C2AC  24120013   ADDIU S2, ZERO, 19
9D01C2DC  26100001   ADDIU S0, S0, 1
9D01C2E0  3210FFFF   ANDI S0, S0, -1
9D01C2E4  1612FFF3   BNE S0, S2, 0x9D01C2B4
9D01C2E8  7C108C20   SEB S1, S0
566:                 		{
567:                 		video_gotoxy(0,i);
9D01C2B0  7C108C20   SEB S1, S0
9D01C2B4  00002021   ADDU A0, ZERO, ZERO
9D01C2B8  0F40697A   JAL video_gotoxy
9D01C2BC  02202821   ADDU A1, S1, ZERO
568:                 		stdio_c(186);
9D01C2C0  0F407069   JAL stdio_c
9D01C2C4  240400BA   ADDIU A0, ZERO, 186
569:                 		video_gotoxy(39,i);
9D01C2C8  24040027   ADDIU A0, ZERO, 39
9D01C2CC  0F40697A   JAL video_gotoxy
9D01C2D0  02202821   ADDU A1, S1, ZERO
570:                 		stdio_c(186);
9D01C2D4  0F407069   JAL stdio_c
9D01C2D8  240400BA   ADDIU A0, ZERO, 186
571:                 		}
572:                 	}
9D01C2EC  8FBF001C   LW RA, 28(SP)
9D01C2F0  8FB20018   LW S2, 24(SP)
9D01C2F4  8FB10014   LW S1, 20(SP)
9D01C2F8  8FB00010   LW S0, 16(SP)
9D01C2FC  03E00008   JR RA
9D01C300  27BD0020   ADDIU SP, SP, 32
573:                 
574:                 void clear_prompt(void)
575:                 	{
9D01C130  27BDFFE0   ADDIU SP, SP, -32
9D01C134  AFBF001C   SW RA, 28(SP)
9D01C138  AFB10018   SW S1, 24(SP)
9D01C13C  AFB00014   SW S0, 20(SP)
576:                 	//Clear prompt area
577:                 	video_gotoxy(TEXT_LEFT,PROMPT_Y);
9D01C140  24040004   ADDIU A0, ZERO, 4
9D01C144  0F40697A   JAL video_gotoxy
9D01C148  2405000F   ADDIU A1, ZERO, 15
9D01C14C  24100023   ADDIU S0, ZERO, 35
578:                 	int16_t i;
579:                 	for (i=TEXT_LEFT; i<39; i++) stdio_write(" ");
9D01C150  3C119D03   LUI S1, -25341
9D01C154  2631955C   ADDIU S1, S1, -27300
9D01C158  0F406F61   JAL stdio_write
9D01C15C  02202021   ADDU A0, S1, ZERO
9D01C160  2610FFFF   ADDIU S0, S0, -1
9D01C164  3210FFFF   ANDI S0, S0, -1
9D01C168  1600FFFB   BNE S0, ZERO, 0x9D01C158
9D01C16C  2404000F   ADDIU A0, ZERO, 15
580:                 	
581:                 	video_set_color(MENU_DEFAULT_FG, MENU_DEFAULT_BG);
9D01C170  0F4068DD   JAL .LFB8, .LFE58, video_set_color
9D01C174  00002821   ADDU A1, ZERO, ZERO
582:                 	video_gotoxy(TEXT_LEFT,PROMPT_Y);
9D01C178  24040004   ADDIU A0, ZERO, 4
9D01C17C  0F40697A   JAL video_gotoxy
9D01C180  2405000F   ADDIU A1, ZERO, 15
583:                 	stdio_write("> ");
9D01C184  3C049D03   LUI A0, -25341
9D01C188  0F406F61   JAL stdio_write
9D01C18C  24849560   ADDIU A0, A0, -27296
584:                 	}
9D01C190  8FBF001C   LW RA, 28(SP)
9D01C194  8FB10018   LW S1, 24(SP)
9D01C198  8FB00014   LW S0, 20(SP)
9D01C19C  03E00008   JR RA
9D01C1A0  27BD0020   ADDIU SP, SP, 32
585:                 
586:                 void show_wrencher(void)
587:                 	{
9D01C828  27BDFFE0   ADDIU SP, SP, -32
9D01C82C  AFBF001C   SW RA, 28(SP)
9D01C830  AFB10018   SW S1, 24(SP)
588:                 	int8_t i;
589:                 	video_clrscr();
9D01C834  0F406A2B   JAL video_clrscr
9D01C838  AFB00014   SW S0, 20(SP)
590:                 	video_set_color(2,0);
9D01C83C  24040002   ADDIU A0, ZERO, 2
9D01C840  0F4068DD   JAL .LFB8, .LFE58, video_set_color
9D01C844  00002821   ADDU A1, ZERO, ZERO
591:                 	video_gotoxy(0,1);
9D01C848  00002021   ADDU A0, ZERO, ZERO
9D01C84C  0F40697A   JAL video_gotoxy
9D01C850  24050001   ADDIU A1, ZERO, 1
9D01C854  3C109D03   LUI S0, -25341
9D01C858  26109988   ADDIU S0, S0, -26232
9D01C85C  261102E2   ADDIU S1, S0, 738
592:                 	for (i=0; i<18; i++)
9D01C86C  1611FFFC   BNE S0, S1, 0x9D01C860
9D01C870  00000000   NOP
593:                 		{
594:                 		stdio_write((int8_t *)wrencher[i]);
9D01C860  0F406F61   JAL stdio_write
9D01C864  02002021   ADDU A0, S0, ZERO
9D01C868  26100029   ADDIU S0, S0, 41
595:                 		}
596:                 	wait_ms(200);
9D01C874  0F407C7E   JAL wait_ms
9D01C878  240400C8   ADDIU A0, ZERO, 200
597:                 	i = 0;
9D01C87C  00002021   ADDU A0, ZERO, ZERO
598:                 	uint8_t loopbreak = 0;
599:                 	while(1)
600:                 		{
601:                 		loopbreak = playriff(i++);
9D01C880  24900001   ADDIU S0, A0, 1
9D01C884  7C108420   SEB S0, S0
9D01C888  0F4071C4   JAL playriff
9D01C88C  308400FF   ANDI A0, A0, 255
9D01C898  0004800A   MOVZ S0, ZERO, A0
9D01C89C  0B407220   J 0x9D01C880
9D01C8A0  02002021   ADDU A0, S0, ZERO
602:                 		if (loopbreak) break;
9D01C890  14400004   BNE V0, ZERO, 0x9D01C8A4
9D01C894  2A040004   SLTI A0, S0, 4
603:                 		if (i > 3) i = 0;
604:                 		}
605:                 	showmenu();
9D01C8A4  0F4070C1   JAL showmenu
9D01C8A8  00000000   NOP
606:                 	}
9D01C8AC  8FBF001C   LW RA, 28(SP)
9D01C8B0  8FB10018   LW S1, 24(SP)
9D01C8B4  8FB00014   LW S0, 20(SP)
9D01C8B8  03E00008   JR RA
9D01C8BC  27BD0020   ADDIU SP, SP, 32
607:                 
608:                 uint8_t playriff(uint8_t raisetop)
609:                 	{
9D01C710  27BDFFA0   ADDIU SP, SP, -96
9D01C714  AFBF005C   SW RA, 92(SP)
9D01C718  AFB00058   SW S0, 88(SP)
9D01C71C  00808021   ADDU S0, A0, ZERO
610:                 	const uint16_t riffdelays[3] = {78,236,393};
9D01C720  3C029D03   LUI V0, -25341
9D01C724  24439644   ADDIU V1, V0, -27068
9D01C728  88640003   LWL A0, 3(V1)
9D01C72C  98449644   LWR A0, -27068(V0)
9D01C730  AFA40010   SW A0, 16(SP)
9D01C734  94620004   LHU V0, 4(V1)
9D01C738  A7A20014   SH V0, 20(SP)
611:                 	const uint8_t riff[14][4] =
9D01C73C  3C029D03   LUI V0, -25341
9D01C740  2442964C   ADDIU V0, V0, -27060
9D01C744  27A30018   ADDIU V1, SP, 24
9D01C748  24440030   ADDIU A0, V0, 48
9D01C74C  88480003   LWL T0, 3(V0)
9D01C750  98480000   LWR T0, 0(V0)
9D01C754  88470007   LWL A3, 7(V0)
9D01C758  98470004   LWR A3, 4(V0)
9D01C75C  8846000B   LWL A2, 11(V0)
9D01C760  98460008   LWR A2, 8(V0)
9D01C764  8845000F   LWL A1, 15(V0)
9D01C768  9845000C   LWR A1, 12(V0)
9D01C76C  AC680000   SW T0, 0(V1)
9D01C770  AC670004   SW A3, 4(V1)
9D01C774  AC660008   SW A2, 8(V1)
9D01C778  AC65000C   SW A1, 12(V1)
9D01C77C  24420010   ADDIU V0, V0, 16
9D01C780  1444FFF2   BNE V0, A0, 0x9D01C74C
9D01C784  24630010   ADDIU V1, V1, 16
9D01C788  88440003   LWL A0, 3(V0)
9D01C78C  98440000   LWR A0, 0(V0)
9D01C790  88450007   LWL A1, 7(V0)
9D01C794  98450004   LWR A1, 4(V0)
9D01C798  AC640000   SW A0, 0(V1)
9D01C79C  AC650004   SW A1, 4(V1)
612:                 		{
613:                 			{0,62,69,0},
614:                 			{0,0,0,0},
615:                 			{0,62,69,0},
616:                 			{0,0,0,0},
617:                 			{0,62,69,1},
618:                 			{0,0,0,2},
619:                 			{0,62,69,0},
620:                 			{0,0,0,0},
621:                 			{0,62,69,0},
622:                 			{0,0,0,0},
623:                 			{0,62,69,1},
624:                 			{0,0,0,0},
625:                 			{50,0,0,1},
626:                 			{0,0,0,0}
627:                 		};
628:                 	uint8_t i;
629:                 	for (i=0; i<14; i++)
9D01C7A0  A3A00050   SB ZERO, 80(SP)
9D01C7A4  00001021   ADDU V0, ZERO, ZERO
9D01C7F4  93A20050   LBU V0, 80(SP)
9D01C7F8  24420001   ADDIU V0, V0, 1
9D01C7FC  304200FF   ANDI V0, V0, 255
9D01C800  2C43000E   SLTIU V1, V0, 14
9D01C804  1460FFE8   BNE V1, ZERO, .LBB4
9D01C808  A3A20050   SB V0, 80(SP)
630:                 		{
631:                 		uint8_t top = 0;
632:                 		if (riff[i][2] != 0)
9D01C7A8  00402021   ADDU A0, V0, ZERO
9D01C7AC  00021080   SLL V0, V0, 2
9D01C7B0  27A30010   ADDIU V1, SP, 16
9D01C7B4  00621021   ADDU V0, V1, V0
9D01C7B8  9043000A   LBU V1, 10(V0)
9D01C7BC  10600003   BEQ V1, ZERO, 0x9D01C7CC
9D01C7C0  00003021   ADDU A2, ZERO, ZERO
633:                 			{
634:                 			top = riff[i][2] + raisetop;
9D01C7C4  02033021   ADDU A2, S0, V1
9D01C7C8  30C600FF   ANDI A2, A2, 255
635:                 			}
636:                 		sound_play_notes(riff[i][0],riff[i][1],top,riffdelays[riff[i][3]]);	
9D01C7CC  00041080   SLL V0, A0, 2
9D01C7D0  27A40010   ADDIU A0, SP, 16
9D01C7D4  00821021   ADDU V0, A0, V0
9D01C7D8  9043000B   LBU V1, 11(V0)
9D01C7DC  00031840   SLL V1, V1, 1
9D01C7E0  00831821   ADDU V1, A0, V1
9D01C7E4  90440008   LBU A0, 8(V0)
9D01C7E8  90450009   LBU A1, 9(V0)
9D01C7EC  0F407C8F   JAL sound_play_notes
9D01C7F0  94670000   LHU A3, 0(V1)
637:                 		}
638:                 		if (stdio_get(&i) != 0) { return 1; }
9D01C80C  0F40719E   JAL stdio_get
9D01C810  27A40050   ADDIU A0, SP, 80
639:                 	return 0;
640:                 	}
9D01C814  0002102B   SLTU V0, ZERO, V0
9D01C818  8FBF005C   LW RA, 92(SP)
9D01C81C  8FB00058   LW S0, 88(SP)
9D01C820  03E00008   JR RA
9D01C824  27BD0060   ADDIU SP, SP, 96
641:                 
642:                 
643:                 //housekeeping stuff. call this function often
644:                 void loop_badge(void)
645:                 	{
9D01B824  27BDFFE0   ADDIU SP, SP, -32
9D01B828  AFBF001C   SW RA, 28(SP)
646:                 	volatile uint16_t dbg;
647:                 	static uint8_t brk_is_pressed;
648:                 	dbg = PORTD;
9D01B82C  3C02BF88   LUI V0, -16504
9D01B830  8C426320   LW V0, 25376(V0)
9D01B834  3042FFFF   ANDI V0, V0, -1
9D01B838  A7A20010   SH V0, 16(SP)
649:                 	if (K_PWR==0)
9D01B83C  3C02BF88   LUI V0, -16504
9D01B840  8C436620   LW V1, 26144(V0)
650:                 		{
651:                 //		while (K_PWR==0);
652:                 //		wait_ms(100);
653:                 //		hw_sleep();
654:                 //		wait_ms(30);
655:                 //		while (K_PWR==0);
656:                 //		wait_ms(300);
657:                 		}
658:                 	if (KEY_BRK==0)
9D01B844  8C426620   LW V0, 26144(V0)
9D01B848  30420200   ANDI V0, V0, 512
9D01B84C  54400023   BNEL V0, ZERO, 0x9D01B8DC
9D01B850  A3808194   SB ZERO, -32364(GP)
659:                 		{
660:                 		if ((K_SHIFTL==0)&(K_SHIFTR==0)&(brk_is_pressed==9))
9D01B854  3C02BF88   LUI V0, -16504
9D01B858  8C436320   LW V1, 25376(V0)
9D01B85C  8C426320   LW V0, 25376(V0)
9D01B860  38630400   XORI V1, V1, 1024
9D01B864  7C630280   EXT V1, V1, 10, 1
9D01B868  38420200   XORI V0, V0, 512
9D01B86C  7C420240   EXT V0, V0, 9, 1
9D01B870  00621024   AND V0, V1, V0
9D01B874  10400012   BEQ V0, ZERO, 0x9D01B8C0
9D01B878  24020001   ADDIU V0, ZERO, 1
9D01B87C  93828194   LBU V0, -32364(GP)
9D01B880  38420009   XORI V0, V0, 9
9D01B884  1440000E   BNE V0, ZERO, 0x9D01B8C0
9D01B888  24020001   ADDIU V0, ZERO, 1
661:                 			{
662:                 			serial_flush();
9D01B88C  0F407DBB   JAL serial_flush
9D01B890  00000000   NOP
663:                 			if (stdio_src == STDIO_TTY1)
9D01B894  938381D5   LBU V1, -32299(GP)
9D01B898  7C031C20   SEB V1, V1
9D01B89C  24020001   ADDIU V0, ZERO, 1
9D01B8A0  54620004   BNEL V1, V0, 0x9D01B8B4
9D01B8A4  24020001   ADDIU V0, ZERO, 1
664:                 				stdio_src = STDIO_LOCAL;
9D01B8A8  A38081D5   SB ZERO, -32299(GP)
9D01B8AC  0B406E32   J 0x9D01B8C8
9D01B8B0  93828194   LBU V0, -32364(GP)
665:                 			else
666:                 				stdio_src = STDIO_TTY1;
9D01B8B4  A38281D5   SB V0, -32299(GP)
667:                 			}
668:                 		else
669:                 			brk_key = 1;
9D01B8C0  A38281DD   SB V0, -32291(GP)
670:                 		if (brk_is_pressed<10) brk_is_pressed++;
9D01B8B8  0B406E32   J 0x9D01B8C8
9D01B8BC  93828194   LBU V0, -32364(GP)
9D01B8C4  93828194   LBU V0, -32364(GP)
9D01B8C8  2C43000A   SLTIU V1, V0, 10
9D01B8CC  10600004   BEQ V1, ZERO, 0x9D01B8E0
9D01B8D0  8FBF001C   LW RA, 28(SP)
9D01B8D4  24420001   ADDIU V0, V0, 1
9D01B8D8  A3828194   SB V0, -32364(GP)
671:                 		}
672:                 	else
673:                 		brk_is_pressed = 0;
674:                 	}
9D01B8DC  8FBF001C   LW RA, 28(SP)
9D01B8E0  03E00008   JR RA
9D01B8E4  27BD0020   ADDIU SP, SP, 32
675:                 
676:                 //B_BDG004
677:                 void enable_display_scanning(uint8_t onoff)
678:                 	{
679:                 	//Turns vt100 scanning on or off
680:                 	if (onoff) handle_display = 1;
9D01B8E8  10800004   BEQ A0, ZERO, 0x9D01B8FC
9D01B8EC  24020001   ADDIU V0, ZERO, 1
9D01B8F0  A3828195   SB V0, -32363(GP)
9D01B8F4  03E00008   JR RA
9D01B8F8  00000000   NOP
681:                 	else handle_display = 0;
9D01B8FC  A3808195   SB ZERO, -32363(GP)
9D01B900  03E00008   JR RA
9D01B904  00000000   NOP
682:                 	}
683:                 
684:                 uint32_t millis(void)
685:                 	{
686:                 	return ticks;
9D01B908  8F8281E0   LW V0, -32288(GP)
687:                 	}
9D01B90C  03E00008   JR RA
9D01B910  00000000   NOP
688:                 
689:                 //void init_8080_basic (void)
690:                 //	{
691:                 //	video_set_color(15,0);
692:                 //	for (i=0;i<2048;i++) ram[i] = b2_rom[i];
693:                 //	for (i=0;i<30;i++) ram[i+0x1000] = ram_init[i];
694:                 //	wrk_ram	= PC = STACK = ram;
695:                 //	init_io(IO_BASIC_MODE);
696:                 //	}
697:                 //
698:                 //void loop_8080_basic (void)
699:                 //	{
700:                 //	cpu_error = NONE;
701:                 //	cpu();	
702:                 //	}
703:                 
704:                 //void init_z80_cpm (void)
705:                 //	{
706:                 //	video_set_color(15,0);
707:                 //#ifdef	USE_RAM_IMAGE	
708:                 //	for (i=0;i<65536;i++) ram[i] = ram_image[i];
709:                 //#endif	
710:                 //#ifdef	USE_RAMDISK
711:                 //	for (i=0;i<RAMDISK_SIZE;i++) ram_disk[i] = 0xE5;
712:                 //#endif
713:                 //	wrk_ram	= PC = STACK = ram;
714:                 //	init_io(IO_CPM_MODE);
715:                 //	}
716:                 
717:                 //void loop_z80_cpm (void)
718:                 //	{
719:                 //	cpu_error = NONE;
720:                 //	cpu();	
721:                 //	}
722:                 
723:                 //B_BAS005
724:                 //void init_basic (void)
725:                 //	{
726:                 //	stdio_write("BASIC interpreter\n");
727:                 //	prompt = 1;
728:                 //	brk_key = 0;
729:                 //	cmd_line_pointer=0;
730:                 //	cmd_line_buff[0] = 0;
731:                 //	video_set_color(15,0);
732:                 //	}
733:                 ////B_BAS006
734:                 //void loop_basic (void)
735:                 //	{
736:                 //	if (prompt==1)
737:                 //	    {
738:                 //	    stdio_write(">");	
739:                 //	    prompt = 0;
740:                 //	    }
741:                 //	get_stat = stdio_get(&char_out);
742:                 //	if (get_stat!=0)
743:                 //	    {
744:                 //	    stdio_c(char_out);	
745:                 //	    if (char_out==NEWLINE) 
746:                 //			{
747:                 //			cmd_line_buff[cmd_line_pointer] = 0;
748:                 //			cmd_exec (cmd_line_buff);
749:                 //			cmd_line_pointer=0;
750:                 //			cmd_line_buff[0] = 0;
751:                 //			prompt = 1;			
752:                 //			}
753:                 //	    else
754:                 //			{
755:                 //			if ((char_out>=' ')&(char_out<0x7F)) cmd_line_buff[cmd_line_pointer++] = char_out;
756:                 //			else if (char_out==BACKSPACE)
757:                 //				{
758:                 //				if (cmd_line_pointer>0) 
759:                 //					cmd_line_buff[--cmd_line_pointer]=0;
760:                 //				}
761:                 //
762:                 //			}
763:                 //	    }	
764:                 //	}
765:                 
766:                 ////B_BDG007
767:                 //void init_userprog (void)
768:                 //{
769:                 //	user_program_init();
770:                 //}
771:                 //
772:                 ////B_BDG008
773:                 //void loop_userprog (void)
774:                 //{
775:                 //	user_program_loop();
776:                 //}
777:                 
778:                 void clr_buffer (void)
779:                 	{
780:                 	for (i=0; i<DISP_BUFFER_HIGH+1; i++)
9D01B914  00004021   ADDU T0, ZERO, ZERO
9D01B918  3C0BA000   LUI T3, -24576
9D01B91C  256B1E64   ADDIU T3, T3, 7780
9D01B920  3C0AA000   LUI T2, -24576
9D01B924  254A1B1C   ADDIU T2, T2, 6940
9D01B930  24090348   ADDIU T1, ZERO, 840
9D01B934  00001021   ADDU V0, ZERO, ZERO
9D01B938  01682821   ADDU A1, T3, T0
9D01B93C  01482021   ADDU A0, T2, T0
9D01B940  00A21821   ADDU V1, A1, V0
9D01B95C  1509FFF6   BNE T0, T1, 0x9D01B938
9D01B960  00001021   ADDU V0, ZERO, ZERO
9D01B964  24020028   ADDIU V0, ZERO, 40
9D01B968  AF8281D0   SW V0, -32304(GP)
9D01B96C  24020015   ADDIU V0, ZERO, 21
9D01B970  03E00008   JR RA
9D01B974  AF8281A0   SW V0, -32352(GP)
781:                 		{
782:                 		for (j=0; j<DISP_BUFFER_WIDE; j++) 
9D01B92C  24060028   ADDIU A2, ZERO, 40
9D01B950  1446FFFB   BNE V0, A2, 0x9D01B940
9D01B954  A0670000   SB A3, 0(V1)
9D01B958  25080028   ADDIU T0, T0, 40
783:                 			{
784:                 			disp_buffer[i][j] = 0;		//Blank the buffer
9D01B944  A0600000   SB ZERO, 0(V1)
9D01B948  00821821   ADDU V1, A0, V0
9D01B94C  24420001   ADDIU V0, V0, 1
785:                 			color_buffer[i][j] = 0x0F;	//White text on black background
9D01B928  2407000F   ADDIU A3, ZERO, 15
9D01B92C  24060028   ADDIU A2, ZERO, 40
9D01B930  24090348   ADDIU T1, ZERO, 840
9D01B934  00001021   ADDU V0, ZERO, ZERO
9D01B938  01682821   ADDU A1, T3, T0
9D01B93C  01482021   ADDU A0, T2, T0
9D01B940  00A21821   ADDU V1, A1, V0
9D01B944  A0600000   SB ZERO, 0(V1)
9D01B948  00821821   ADDU V1, A0, V0
9D01B94C  24420001   ADDIU V0, V0, 1
9D01B950  1446FFFB   BNE V0, A2, 0x9D01B940
9D01B954  A0670000   SB A3, 0(V1)
9D01B958  25080028   ADDIU T0, T0, 40
9D01B95C  1509FFF6   BNE T0, T1, 0x9D01B938
9D01B960  00001021   ADDU V0, ZERO, ZERO
9D01B964  24020028   ADDIU V0, ZERO, 40
9D01B968  AF8281D0   SW V0, -32304(GP)
9D01B96C  24020015   ADDIU V0, ZERO, 21
9D01B970  03E00008   JR RA
9D01B974  AF8281A0   SW V0, -32352(GP)
786:                 			}
787:                 		}
788:                 	}
789:                 
790:                 const char* get_firmware_string(void) {
791:                 	return FIRMWARE_VERSION;
792:                 	}
9D01B978  3C029D03   LUI V0, -25341
9D01B97C  03E00008   JR RA
9D01B980  2442946C   ADDIU V0, V0, -27540
793:                 
794:                 uint16_t get_free_mem(uint8_t * prog, uint16_t max_mem)
795:                 	{
9D01B984  27BDFFE8   ADDIU SP, SP, -24
9D01B988  AFBF0014   SW RA, 20(SP)
9D01B98C  AFB00010   SW S0, 16(SP)
796:                 	uint16_t prog_len;
797:                 	prog_len = strlen(prog);
9D01B990  0F40D9CB   JAL strlen
9D01B994  00A08021   ADDU S0, A1, ZERO
798:                 	return (max_mem-prog_len);
9D01B998  02021023   SUBU V0, S0, V0
799:                 	}
9D01B99C  3042FFFF   ANDI V0, V0, -1
9D01B9A0  8FBF0014   LW RA, 20(SP)
9D01B9A4  8FB00010   LW S0, 16(SP)
9D01B9A8  03E00008   JR RA
9D01B9AC  27BD0018   ADDIU SP, SP, 24
800:                 
801:                 //B_BAS008
802:                 uint8_t add_prog_line (int8_t * line, int8_t * prog, int16_t linenum)
803:                     {
9D01B9B0  27BDFF58   ADDIU SP, SP, -168
9D01B9B4  AFBF00A4   SW RA, 164(SP)
9D01B9B8  AFBE00A0   SW FP, 160(SP)
9D01B9BC  AFB7009C   SW S7, 156(SP)
9D01B9C0  AFB60098   SW S6, 152(SP)
9D01B9C4  AFB50094   SW S5, 148(SP)
9D01B9C8  AFB40090   SW S4, 144(SP)
9D01B9CC  AFB3008C   SW S3, 140(SP)
9D01B9D0  AFB20088   SW S2, 136(SP)
9D01B9D4  AFB10084   SW S1, 132(SP)
9D01B9D8  AFB00080   SW S0, 128(SP)
9D01B9DC  0080F021   ADDU FP, A0, ZERO
9D01B9E0  00A0B021   ADDU S6, A1, ZERO
9D01B9E4  00C0A821   ADDU S5, A2, ZERO
804:                     uint8_t * prog_ptr=prog, * prog_ptr_prev, * prog_ptr_dest;
805:                     int16_t linenum_now,linenum_prev=0,line_exp_len,cnt, prog_len;
806:                     int8_t line_rest[50],line_exp[50],ret;
807:                     sprintf(line_exp,"%d %s\n",linenum,line);
9D01B9E8  27A40048   ADDIU A0, SP, 72
9D01B9EC  3C059D03   LUI A1, -25341
9D01B9F0  24A59474   ADDIU A1, A1, -27532
9D01B9F4  0F40EBB1   JAL _sprintf_cdnopuxX, _sprintf_cdnopsuxX
9D01B9F8  03C03821   ADDU A3, FP, ZERO
808:                     line_exp_len = strlen(line_exp);
9D01B9FC  0F40D9CB   JAL strlen
9D01BA00  27A40048   ADDIU A0, SP, 72
9D01BA04  7C02BE20   SEH S7, V0
809:                 	prog_len = strlen(prog);
9D01BA08  0F40D9CB   JAL strlen
9D01BA0C  02C02021   ADDU A0, S6, ZERO
810:                 	if ((prog_len + line_exp_len)>BPROG_LEN) return 1;
9D01BA10  7C021620   SEH V0, V0
9D01BA14  00571821   ADDU V1, V0, S7
9D01BA18  28634001   SLTI V1, V1, 16385
9D01BA1C  1060004D   BEQ V1, ZERO, 0x9D01BB54
9D01BA20  24020001   ADDIU V0, ZERO, 1
9D01BA24  02C08021   ADDU S0, S6, ZERO
9D01BA28  00009821   ADDU S3, ZERO, ZERO
811:                     while (1)
812:                 	{
813:                 	ret = sscanf(prog_ptr,"%d %[^\n]s",&linenum_now,line_rest);
9D01BA2C  3C129D03   LUI S2, -25341
9D01BA30  2652947C   ADDIU S2, S2, -27524
9D01BA3C  02002021   ADDU A0, S0, ZERO
9D01BA40  02402821   ADDU A1, S2, ZERO
9D01BA44  27A60010   ADDIU A2, SP, 16
9D01BA48  0F40EB5C   JAL .Letext0, .LFE1, _sscanf_cdnopuxX
9D01BA4C  27A70014   ADDIU A3, SP, 20
9D01BA50  7C021420   SEB V0, V0
814:                 	if (ret==2)
9D01BA34  24110002   ADDIU S1, ZERO, 2
9D01BA54  14510033   BNE V0, S1, 0x9D01BB24
9D01BA58  00000000   NOP
815:                 	    {
816:                 	    if ((linenum>linenum_prev)&(linenum<linenum_now))
9D01BA5C  87A20010   LH V0, 16(SP)
9D01BA60  02A2182A   SLT V1, S5, V0
9D01BA64  10600010   BEQ V1, ZERO, 0x9D01BAA8
9D01BA68  0275982A   SLT S3, S3, S5
9D01BA6C  1260000E   BEQ S3, ZERO, 0x9D01BAA8
9D01BA70  00000000   NOP
817:                 			{
818:                 			cnt = strlen(prog_ptr) +1;
9D01BA74  0F40D9CB   JAL strlen
9D01BA78  02002021   ADDU A0, S0, ZERO
9D01BA7C  24420001   ADDIU V0, V0, 1
819:                 			prog_ptr_dest = prog_ptr + line_exp_len;
820:                 			memmove(prog_ptr_dest,prog_ptr,cnt);
9D01BA80  02172021   ADDU A0, S0, S7
9D01BA84  02002821   ADDU A1, S0, ZERO
9D01BA88  0F40EC01   JAL .Letext0, .LFE0, memmove
9D01BA8C  7C023620   SEH A2, V0
821:                 			memcpy(prog_ptr,line_exp,line_exp_len);
9D01BA90  02002021   ADDU A0, S0, ZERO
9D01BA94  27A50048   ADDIU A1, SP, 72
9D01BA98  0F40D971   JAL .Letext0, .LFE1, memcpy
9D01BA9C  02E03021   ADDU A2, S7, ZERO
822:                 			return 0;
9D01BAA0  0B406ED5   J 0x9D01BB54
9D01BAA4  00001021   ADDU V0, ZERO, ZERO
823:                 			}
824:                 	    if (linenum==linenum_now)
9D01BAA8  16A20025   BNE S5, V0, 0x9D01BB40
9D01BAAC  87B30010   LH S3, 16(SP)
825:                 			{
826:                 			prog_ptr_prev = prog_ptr;
827:                 			prog_ptr = strchr(prog_ptr,'\n')+1;
9D01BAB0  02002021   ADDU A0, S0, ZERO
9D01BAB4  0F40E2E0   JAL strchr
9D01BAB8  2405000A   ADDIU A1, ZERO, 10
9D01BABC  24510001   ADDIU S1, V0, 1
828:                 			cnt = strlen(prog_ptr)+1;
9D01BAC0  0F40D9CB   JAL strlen
9D01BAC4  02202021   ADDU A0, S1, ZERO
9D01BAC8  24420001   ADDIU V0, V0, 1
829:                 			memmove(prog_ptr_prev,prog_ptr,cnt);
9D01BACC  02002021   ADDU A0, S0, ZERO
9D01BAD0  02202821   ADDU A1, S1, ZERO
9D01BAD4  0F40EC01   JAL .Letext0, .LFE0, memmove
9D01BAD8  7C023620   SEH A2, V0
830:                 			if (strlen(line)>1)
9D01BADC  0F40D9CB   JAL strlen
9D01BAE0  03C02021   ADDU A0, FP, ZERO
9D01BAE4  2C430002   SLTIU V1, V0, 2
9D01BAE8  1460001A   BNE V1, ZERO, 0x9D01BB54
9D01BAEC  00001021   ADDU V0, ZERO, ZERO
831:                 				{
832:                 				prog_ptr = prog_ptr_prev;
833:                 				cnt = strlen(prog_ptr);
9D01BAF0  0F40D9CB   JAL strlen
9D01BAF4  02002021   ADDU A0, S0, ZERO
834:                 				prog_ptr_dest = prog_ptr + line_exp_len;
835:                 				memmove(prog_ptr_dest,prog_ptr,cnt+1);
9D01BAF8  7C021620   SEH V0, V0
9D01BAFC  02172021   ADDU A0, S0, S7
9D01BB00  02002821   ADDU A1, S0, ZERO
9D01BB04  0F40EC01   JAL .Letext0, .LFE0, memmove
9D01BB08  24460001   ADDIU A2, V0, 1
836:                 				memcpy(prog_ptr,line_exp,line_exp_len);		
9D01BB0C  02002021   ADDU A0, S0, ZERO
9D01BB10  27A50048   ADDIU A1, SP, 72
9D01BB14  0F40D971   JAL .Letext0, .LFE1, memcpy
9D01BB18  02E03021   ADDU A2, S7, ZERO
837:                 				}
838:                 			return 0;
9D01BB1C  0B406ED5   J 0x9D01BB54
9D01BB20  00001021   ADDU V0, ZERO, ZERO
839:                 			}
840:                 	    }
841:                 	if (ret==-1)
9D01BA38  2414FFFF   ADDIU S4, ZERO, -1
9D01BB24  14540006   BNE V0, S4, 0x9D01BB40
9D01BB28  87B30010   LH S3, 16(SP)
842:                 	    {
843:                 	    strcat(prog,line_exp);
9D01BB2C  02C02021   ADDU A0, S6, ZERO
9D01BB30  0F40E86E   JAL strcat
9D01BB34  27A50048   ADDIU A1, SP, 72
844:                 	    return 0;
9D01BB38  0B406ED5   J 0x9D01BB54
9D01BB3C  00001021   ADDU V0, ZERO, ZERO
845:                 	    }
846:                 	linenum_prev = linenum_now;
847:                 	prog_ptr_prev = prog_ptr;
848:                 	prog_ptr = strchr(prog_ptr,'\n')+1;
9D01BB40  02002021   ADDU A0, S0, ZERO
9D01BB44  0F40E2E0   JAL strchr
9D01BB48  2405000A   ADDIU A1, ZERO, 10
849:                 	}
9D01BB4C  0B406E8F   J 0x9D01BA3C
9D01BB50  24500001   ADDIU S0, V0, 1
850:                     }
9D01BB54  8FBF00A4   LW RA, 164(SP)
9D01BB58  8FBE00A0   LW FP, 160(SP)
9D01BB5C  8FB7009C   LW S7, 156(SP)
9D01BB60  8FB60098   LW S6, 152(SP)
9D01BB64  8FB50094   LW S5, 148(SP)
9D01BB68  8FB40090   LW S4, 144(SP)
9D01BB6C  8FB3008C   LW S3, 140(SP)
9D01BB70  8FB20088   LW S2, 136(SP)
9D01BB74  8FB10084   LW S1, 132(SP)
9D01BB78  8FB00080   LW S0, 128(SP)
9D01BB7C  03E00008   JR RA
9D01BB80  27BD00A8   ADDIU SP, SP, 168
851:                 
852:                 ////B_BAS007
853:                 //uint8_t cmd_exec (int8_t * cmd)
854:                 //    {
855:                 //    int8_t cmd_clean[25];
856:                 //    int32_t linenum,prognum;
857:                 //    if (isdigit(cmd[0]))
858:                 //		{
859:                 //		sscanf(cmd,"%d %[^\n]s",&linenum,cmd_clean);
860:                 //		add_prog_line (cmd_clean,bprog, linenum);
861:                 //		}
862:                 //    else
863:                 //		{
864:                 //		if (strcmp("list",cmd)==0) stdio_write(bprog);
865:                 //		else if (strcmp("memclr",cmd)==0) bprog[0]=0;
866:                 //		else if (strcmp("free",cmd)==0)
867:                 //			{
868:                 //			sprintf(stdio_buff,"%d B of memory free\n",get_free_mem(bprog,BPROG_LEN));
869:                 //			stdio_write(stdio_buff);
870:                 //			}	
871:                 //		else if (strcmp("more",cmd)==0) list_more();
872:                 //		else if (strcmp("help",cmd)==0) 
873:                 //			{
874:                 //			stdio_write("Basic BASIC help:\n");
875:                 //			stdio_write("Type more to list the program in buffer, ");
876:                 //			stdio_write("or run to run it.\n");
877:                 //			stdio_write(" For more documentation see hac.io/Mz3r\n");
878:                 //			}
879:                 //		else if (strncmp("load",cmd,4)==0)
880:                 //			{
881:                 //			sscanf (cmd+4,"%d",&prognum);
882:                 //			if ((prognum>=0)&(prognum<BASIC_SAVNUM))
883:                 //				{
884:                 //				stdio_write("loading...");
885:                 //				basic_load_program(bprog,prognum);
886:                 //				stdio_write("OK\n");
887:                 //				}
888:                 //			}
889:                 //		else if (strncmp("save",cmd,4)==0)
890:                 //			{
891:                 //			sscanf (cmd+4,"%d",&prognum);
892:                 //			if ((prognum>=0)&(prognum<BASIC_SAVNUM))
893:                 //				{
894:                 //				stdio_write("saving...");
895:                 //				basic_save_program(bprog,prognum);
896:                 //				stdio_write("OK\n");
897:                 //				}
898:                 //			}	
899:                 //		else if (strncmp("ssave",cmd,5)==0)
900:                 //			{
901:                 //			stdio_write("Transmitting via serial port...\n");
902:                 //			i = basic_saves(bprog,BPROG_LEN);
903:                 //			sprintf(stdio_buff,"\nOK, transmitted %d bytes.\n",i);
904:                 //			stdio_write(stdio_buff);
905:                 //			}	
906:                 //		else if (strncmp("sload",cmd,5)==0)
907:                 //			{
908:                 //			stdio_write("Loading new program from serial port\n");
909:                 //			stdio_write("Press BRK to exit...\n");
910:                 //			serial_flush();
911:                 //			handle_display = 0;
912:                 //			display_refresh_force();
913:                 //			i = basic_loads(bprog,BPROG_LEN);
914:                 //			handle_display = 1;
915:                 //			sprintf(stdio_buff,"\nOK, received %d bytes.\n",i);
916:                 //			stdio_write(stdio_buff);
917:                 //			}	
918:                 //		else if (strcmp("run",cmd)==0)
919:                 //			{
920:                 //			ubasic_init(bprog,0);
921:                 //			brk_key = 0;
922:                 //			do 
923:                 //				{
924:                 //				if (brk_key) 
925:                 //					{
926:                 //					brk_key = 0;
927:                 //					stdio_write("\nBRK pressed\n");
928:                 //					break;
929:                 //					}
930:                 //				if (!setjmp(jbuf)) ubasic_run();
931:                 //				else
932:                 //					{
933:                 //					stdio_write("\nBASIC error\n");
934:                 //					break;
935:                 //					}
936:                 //				} 	while(!ubasic_finished());
937:                 //			handle_display = 1;
938:                 //			stdio_write("\n");
939:                 //			}
940:                 //		else 
941:                 //			{
942:                 //			if (strlen(cmd)>0)
943:                 //				{
944:                 //				sprintf(tprog,"0 %s\n",cmd);
945:                 //				ubasic_init(tprog,1);
946:                 //				do 
947:                 //					{
948:                 //					if (!setjmp(jbuf)) ubasic_run();
949:                 //					else
950:                 //						{
951:                 //						stdio_write("BASIC error\n");
952:                 //						break;
953:                 //						}
954:                 //					} 	while(!ubasic_finished());	
955:                 //				}		
956:                 //			}
957:                 //		}
958:                 //    }
959:                 
960:                 
961:                 uint16_t basic_loads (int8_t * data, uint16_t maxlen)
962:                 	{
9D01BB84  27BDFFE0   ADDIU SP, SP, -32
9D01BB88  AFBF001C   SW RA, 28(SP)
9D01BB8C  AFB20018   SW S2, 24(SP)
9D01BB90  AFB10014   SW S1, 20(SP)
9D01BB94  AFB00010   SW S0, 16(SP)
9D01BB98  00809021   ADDU S2, A0, ZERO
9D01BB9C  00A08821   ADDU S1, A1, ZERO
963:                 	uint8_t rx_char;
964:                 	uint16_t len=0;
9D01BBA0  00008021   ADDU S0, ZERO, ZERO
965:                 	while (1)
966:                 		{
967:                 		if (rx_sta())
9D01BBA4  0F407DB5   JAL rx_sta
9D01BBA8  00000000   NOP
9D01BBAC  10400012   BEQ V0, ZERO, 0x9D01BBF8
9D01BBB0  00000000   NOP
968:                 			{
969:                 			rx_char = rx_read();
9D01BBB4  0F407DD7   JAL .LFB100, .LFE98, rx_read
9D01BBB8  00000000   NOP
970:                 			if ((rx_char>=' ')|(rx_char==NEWLINE)|(rx_char==0))
9D01BBBC  2443FFFF   ADDIU V1, V0, -1
9D01BBC0  306300FF   ANDI V1, V1, 255
9D01BBC4  2C63001F   SLTIU V1, V1, 31
9D01BBC8  10600004   BEQ V1, ZERO, 0x9D01BBDC
9D01BBCC  26030001   ADDIU V1, S0, 1
9D01BBD0  3843000A   XORI V1, V0, 10
9D01BBD4  14600004   BNE V1, ZERO, 0x9D01BBE8
9D01BBD8  26030001   ADDIU V1, S0, 1
971:                 				data[len++] = rx_char;
9D01BBDC  02508021   ADDU S0, S2, S0
9D01BBE0  A2020000   SB V0, 0(S0)
9D01BBE4  3070FFFF   ANDI S0, V1, -1
972:                 			if (rx_char==0) return len;
9D01BBE8  1040000C   BEQ V0, ZERO, 0x9D01BC1C
9D01BBEC  02001021   ADDU V0, S0, ZERO
973:                 			if (len==maxlen) return len;
9D01BBF0  1211000B   BEQ S0, S1, 0x9D01BC20
9D01BBF4  8FBF001C   LW RA, 28(SP)
974:                 			}
975:                 		if (brk_key) 
9D01BBF8  938381DD   LBU V1, -32291(GP)
9D01BBFC  7C031C20   SEB V1, V1
9D01BC00  1060FFE8   BEQ V1, ZERO, 0x9D01BBA4
9D01BC04  00000000   NOP
976:                 			{
977:                 			if (len>0) data[len] = 0;
9D01BC08  12000002   BEQ S0, ZERO, 0x9D01BC14
9D01BC0C  02509021   ADDU S2, S2, S0
9D01BC10  A2400000   SB ZERO, 0(S2)
978:                 			brk_key = 0;
9D01BC14  A38081DD   SB ZERO, -32291(GP)
979:                 			return len;
980:                 			}
981:                 		}
982:                 	return 0;
983:                 	}
9D01BC18  02001021   ADDU V0, S0, ZERO
9D01BC1C  8FBF001C   LW RA, 28(SP)
9D01BC20  8FB20018   LW S2, 24(SP)
9D01BC24  8FB10014   LW S1, 20(SP)
9D01BC28  8FB00010   LW S0, 16(SP)
9D01BC2C  03E00008   JR RA
9D01BC30  27BD0020   ADDIU SP, SP, 32
984:                 
985:                 uint16_t basic_saves (int8_t * data, uint16_t maxlen)
986:                 	{
9D01BC34  27BDFFD8   ADDIU SP, SP, -40
9D01BC38  AFBF0024   SW RA, 36(SP)
9D01BC3C  AFB30020   SW S3, 32(SP)
9D01BC40  AFB2001C   SW S2, 28(SP)
9D01BC44  AFB10018   SW S1, 24(SP)
9D01BC48  AFB00014   SW S0, 20(SP)
9D01BC4C  00809021   ADDU S2, A0, ZERO
9D01BC50  00A09821   ADDU S3, A1, ZERO
987:                 	uint16_t len=0;
9D01BC54  00008021   ADDU S0, ZERO, ZERO
988:                 	while (1)
989:                 		{
990:                 		tx_write(data[len]);
9D01BC58  02508821   ADDU S1, S2, S0
9D01BC5C  0F407DDB   JAL tx_write
9D01BC60  92240000   LBU A0, 0(S1)
991:                 		if (data[len]==0) return len;
9D01BC64  82220000   LB V0, 0(S1)
9D01BC68  10400006   BEQ V0, ZERO, 0x9D01BC84
9D01BC6C  02001021   ADDU V0, S0, ZERO
992:                 		if (len==maxlen) return len;
9D01BC70  12130005   BEQ S0, S3, 0x9D01BC88
9D01BC74  8FBF0024   LW RA, 36(SP)
993:                 		len++;
9D01BC78  26100001   ADDIU S0, S0, 1
994:                 		}
9D01BC7C  0B406F16   J 0x9D01BC58
9D01BC80  3210FFFF   ANDI S0, S0, -1
995:                 	return 0;
996:                 	}
9D01BC84  8FBF0024   LW RA, 36(SP)
9D01BC88  8FB30020   LW S3, 32(SP)
9D01BC8C  8FB2001C   LW S2, 28(SP)
9D01BC90  8FB10018   LW S1, 24(SP)
9D01BC94  8FB00014   LW S0, 20(SP)
9D01BC98  03E00008   JR RA
9D01BC9C  27BD0028   ADDIU SP, SP, 40
997:                 
998:                 //B_BAS011
999:                 uint8_t basic_save_program (uint8_t * data, uint8_t slot)
1000:                	{
9D01BCA0  27BDFFD8   ADDIU SP, SP, -40
9D01BCA4  AFBF0024   SW RA, 36(SP)
9D01BCA8  AFB40020   SW S4, 32(SP)
9D01BCAC  AFB3001C   SW S3, 28(SP)
9D01BCB0  AFB20018   SW S2, 24(SP)
9D01BCB4  AFB10014   SW S1, 20(SP)
9D01BCB8  AFB00010   SW S0, 16(SP)
9D01BCBC  0080A021   ADDU S4, A0, ZERO
1001:                	uint32_t  addr;
1002:                	uint16_t  cnt;
1003:                	addr = slot;
1004:                	addr = addr * BPROG_SECSIZ * BPROG_SECNUM;
9D01BCC0  00059B80   SLL S3, A1, 14
9D01BCC4  00008021   ADDU S0, ZERO, ZERO
1005:                	addr = addr + BASIC_BASEADDR;
1006:                	for (cnt = 0;cnt<BPROG_SECNUM;cnt++)
9D01BCC8  24124000   ADDIU S2, ZERO, 16384
9D01BCCC  02138821   ADDU S1, S0, S3
9D01BCE8  1612FFF9   BNE S0, S2, 0x9D01BCD0
9D01BCEC  02138821   ADDU S1, S0, S3
1007:                		{
1008:                		fl_erase_4k(addr + cnt*BPROG_SECSIZ);
9D01BCD0  0F40B0DE   JAL fl_erase_4k
9D01BCD4  02202021   ADDU A0, S1, ZERO
1009:                		fl_write_4k(addr + cnt*BPROG_SECSIZ,data + cnt*BPROG_SECSIZ);	
9D01BCD8  02202021   ADDU A0, S1, ZERO
9D01BCDC  0F40B131   JAL fl_write_4k
9D01BCE0  02902821   ADDU A1, S4, S0
9D01BCE4  26101000   ADDIU S0, S0, 4096
1010:                		}
1011:                	return 1;
1012:                	}
9D01BCF0  24020001   ADDIU V0, ZERO, 1
9D01BCF4  8FBF0024   LW RA, 36(SP)
9D01BCF8  8FB40020   LW S4, 32(SP)
9D01BCFC  8FB3001C   LW S3, 28(SP)
9D01BD00  8FB20018   LW S2, 24(SP)
9D01BD04  8FB10014   LW S1, 20(SP)
9D01BD08  8FB00010   LW S0, 16(SP)
9D01BD0C  03E00008   JR RA
9D01BD10  27BD0028   ADDIU SP, SP, 40
1013:                
1014:                
1015:                //B_BAS012
1016:                uint8_t basic_load_program (uint8_t * data, uint8_t slot)
1017:                	{
9D01BD14  27BDFFD8   ADDIU SP, SP, -40
9D01BD18  AFBF0024   SW RA, 36(SP)
9D01BD1C  AFB30020   SW S3, 32(SP)
9D01BD20  AFB2001C   SW S2, 28(SP)
9D01BD24  AFB10018   SW S1, 24(SP)
9D01BD28  AFB00014   SW S0, 20(SP)
9D01BD2C  00808821   ADDU S1, A0, ZERO
1018:                	uint32_t  addr;
1019:                	uint16_t  cnt;
1020:                	addr = slot;
1021:                	addr = addr * BPROG_SECSIZ * BPROG_SECNUM;
9D01BD30  00059B80   SLL S3, A1, 14
9D01BD34  00008021   ADDU S0, ZERO, ZERO
1022:                	addr = addr + BASIC_BASEADDR;
1023:                	for (cnt = 0;cnt<BPROG_SECNUM;cnt++)
9D01BD38  24124000   ADDIU S2, ZERO, 16384
9D01BD4C  1612FFFC   BNE S0, S2, 0x9D01BD40
9D01BD50  02132021   ADDU A0, S0, S3
1024:                		fl_read_4k(addr + cnt*BPROG_SECSIZ,data + cnt*BPROG_SECSIZ);	
9D01BD3C  02132021   ADDU A0, S0, S3
9D01BD40  0F40B082   JAL fl_read_4k
9D01BD44  02302821   ADDU A1, S1, S0
9D01BD48  26101000   ADDIU S0, S0, 4096
1025:                	if (data[0] == 0xFF) data[0] = 0;
9D01BD54  92230000   LBU V1, 0(S1)
9D01BD58  240200FF   ADDIU V0, ZERO, 255
9D01BD5C  50620001   BEQL V1, V0, 0x9D01BD64
9D01BD60  A2200000   SB ZERO, 0(S1)
1026:                	return 1;
1027:                	}
9D01BD64  24020001   ADDIU V0, ZERO, 1
9D01BD68  8FBF0024   LW RA, 36(SP)
9D01BD6C  8FB30020   LW S3, 32(SP)
9D01BD70  8FB2001C   LW S2, 28(SP)
9D01BD74  8FB10018   LW S1, 24(SP)
9D01BD78  8FB00014   LW S0, 20(SP)
9D01BD7C  03E00008   JR RA
9D01BD80  27BD0028   ADDIU SP, SP, 40
1028:                
1029:                void list_more (void)
1030:                	{
9D01C8D0  27BDFFD0   ADDIU SP, SP, -48
9D01C8D4  AFBF002C   SW RA, 44(SP)
9D01C8D8  AFB40028   SW S4, 40(SP)
9D01C8DC  AFB30024   SW S3, 36(SP)
9D01C8E0  AFB20020   SW S2, 32(SP)
9D01C8E4  AFB1001C   SW S1, 28(SP)
9D01C8E8  AFB00018   SW S0, 24(SP)
1031:                	uint8_t retval;
1032:                	uint16_t list_cnt=0,list_nl_cnt=0;
9D01C8F0  00009821   ADDU S3, ZERO, ZERO
9D01C8F4  00008021   ADDU S0, ZERO, ZERO
1033:                	while (bprog[list_cnt]!=0)
9D01C8C0  3C02A000   LUI V0, -24576
9D01C8C4  804221E8   LB V0, 8680(V0)
9D01C8C8  10400036   BEQ V0, ZERO, 0x9D01C9A4
9D01C8CC  00000000   NOP
9D01C8EC  00009021   ADDU S2, ZERO, ZERO
9D01C978  02111021   ADDU V0, S0, S1
9D01C97C  80420000   LB V0, 0(V0)
9D01C980  1440FFE1   BNE V0, ZERO, 0x9D01C908
9D01C984  02009021   ADDU S2, S0, ZERO
1034:                		{
1035:                		if (bprog[list_cnt]==NEWLINE)
9D01C908  2403000A   ADDIU V1, ZERO, 10
9D01C90C  14430003   BNE V0, V1, 0x9D01C91C
9D01C910  24020013   ADDIU V0, ZERO, 19
1036:                			list_nl_cnt++;
9D01C914  26730001   ADDIU S3, S3, 1
9D01C918  3273FFFF   ANDI S3, S3, -1
1037:                		if (list_nl_cnt==(DISP_BUFFER_HIGH-1))
9D01C91C  56620012   BNEL S3, V0, 0x9D01C968
9D01C920  26100001   ADDIU S0, S0, 1
1038:                			{
1039:                			stdio_c(NEWLINE);
9D01C924  0F407069   JAL stdio_c
9D01C928  2404000A   ADDIU A0, ZERO, 10
1040:                			stdio_write("---hit any key for more, q to quit---");
9D01C8F8  3C149D03   LUI S4, -25341
9D01C8FC  26949684   ADDIU S4, S4, -27004
9D01C92C  0F406F61   JAL stdio_write
9D01C930  02802021   ADDU A0, S4, ZERO
1041:                			while (stdio_get(&retval)==0);
9D01C934  0F40719E   JAL stdio_get
9D01C938  27A40010   ADDIU A0, SP, 16
9D01C93C  1040FFFD   BEQ V0, ZERO, .LVL280
9D01C940  00000000   NOP
1042:                			stdio_c(NEWLINE);
9D01C944  0F407069   JAL stdio_c
9D01C948  2404000A   ADDIU A0, ZERO, 10
1043:                			if (retval == 'q') return;
9D01C94C  93A30010   LBU V1, 16(SP)
9D01C950  24020071   ADDIU V0, ZERO, 113
9D01C954  1062000D   BEQ V1, V0, 0x9D01C98C
9D01C958  8FBF002C   LW RA, 44(SP)
1044:                			list_nl_cnt = 0;
1045:                			video_clrscr();
9D01C95C  0F406A2B   JAL video_clrscr
9D01C960  00009821   ADDU S3, ZERO, ZERO
1046:                			}
1047:                		stdio_c(bprog[list_cnt++]);
9D01C900  3C11A000   LUI S1, -24576
9D01C904  263121E8   ADDIU S1, S1, 8680
9D01C964  26100001   ADDIU S0, S0, 1
9D01C968  3210FFFF   ANDI S0, S0, -1
9D01C96C  02519021   ADDU S2, S2, S1
9D01C970  0F407069   JAL stdio_c
9D01C974  92440000   LBU A0, 0(S2)
1048:                		}	
1049:                	}
9D01C988  8FBF002C   LW RA, 44(SP)
9D01C98C  8FB40028   LW S4, 40(SP)
9D01C990  8FB30024   LW S3, 36(SP)
9D01C994  8FB20020   LW S2, 32(SP)
9D01C998  8FB1001C   LW S1, 28(SP)
9D01C99C  8FB00018   LW S0, 24(SP)
9D01C9A0  27BD0030   ADDIU SP, SP, 48
9D01C9A4  03E00008   JR RA
9D01C9A8  00000000   NOP
1050:                
1051:                //B_BDG003
1052:                
1053:                //write null-terminated string to standard output
1054:                uint8_t stdio_write (int8_t * data)
1055:                	{
9D01BD84  27BDFFE8   ADDIU SP, SP, -24
9D01BD88  AFBF0014   SW RA, 20(SP)
9D01BD8C  AFB00010   SW S0, 16(SP)
9D01BD90  00808021   ADDU S0, A0, ZERO
1056:                	if (stdio_src==STDIO_LOCAL)
9D01BD94  938281D5   LBU V0, -32299(GP)
9D01BD98  7C021420   SEB V0, V0
9D01BD9C  14400016   BNE V0, ZERO, 0x9D01BDF8
9D01BDA0  00000000   NOP
9D01BDA4  0B406F7A   J 0x9D01BDE8
9D01BDA8  82040000   LB A0, 0(S0)
1057:                		{
1058:                		while (*data!=0x00)
9D01BDE4  82040000   LB A0, 0(S0)
9D01BDE8  1480FFF0   BNE A0, ZERO, 0x9D01BDAC
9D01BDEC  26100001   ADDIU S0, S0, 1
9D01BDF0  0B406F8D   J 0x9D01BE34
9D01BDF4  8FBF0014   LW RA, 20(SP)
1059:                			{
1060:                			buf_enqueue (*data++);
9D01BDAC  0F4068E2   JAL buf_enqueue
9D01BDB0  308400FF   ANDI A0, A0, 255
1061:                			while (bufsize)
9D01BDB4  978281C0   LHU V0, -32320(GP)
9D01BDB8  3042FFFF   ANDI V0, V0, -1
9D01BDBC  5040000A   BEQL V0, ZERO, 0x9D01BDE8
9D01BDC0  82040000   LB A0, 0(S0)
9D01BDD4  978281C0   LHU V0, -32320(GP)
9D01BDD8  3042FFFF   ANDI V0, V0, -1
9D01BDDC  1440FFF9   BNE V0, ZERO, 0x9D01BDC4
9D01BDE0  00000000   NOP
1062:                				receive_char(buf_dequeue());	
9D01BDC4  0F4068FA   JAL buf_dequeue
9D01BDC8  00000000   NOP
9D01BDCC  0F406D07   JAL receive_char
9D01BDD0  00402021   ADDU A0, V0, ZERO
1063:                			}
1064:                		}
1065:                	else if (stdio_src==STDIO_TTY1)
9D01BDF8  938381D5   LBU V1, -32299(GP)
9D01BDFC  7C031C20   SEB V1, V1
9D01BE00  24020001   ADDIU V0, ZERO, 1
9D01BE04  1462000B   BNE V1, V0, 0x9D01BE34
9D01BE08  8FBF0014   LW RA, 20(SP)
1066:                		{
1067:                		while (*data!=0x00)
9D01BE0C  80840000   LB A0, 0(A0)
9D01BE10  50800009   BEQL A0, ZERO, 0x9D01BE38
9D01BE14  8FB00010   LW S0, 16(SP)
9D01BE24  82040000   LB A0, 0(S0)
9D01BE28  1480FFFC   BNE A0, ZERO, 0x9D01BE1C
9D01BE2C  26100001   ADDIU S0, S0, 1
1068:                		tx_write(*data++);
9D01BE18  26100001   ADDIU S0, S0, 1
9D01BE1C  0F407DDB   JAL tx_write
9D01BE20  308400FF   ANDI A0, A0, 255
1069:                		}
1070:                	}
9D01BE30  8FBF0014   LW RA, 20(SP)
9D01BE34  8FB00010   LW S0, 16(SP)
9D01BE38  03E00008   JR RA
9D01BE3C  27BD0018   ADDIU SP, SP, 24
1071:                
1072:                //write one character to standard output
1073:                uint8_t stdio_c (uint8_t data)
1074:                	{
9D01C1A4  27BDFFE8   ADDIU SP, SP, -24
9D01C1A8  AFBF0014   SW RA, 20(SP)
1075:                	int8_t tmp[3];
1076:                	if (stdio_src==STDIO_LOCAL)
9D01C1AC  938281D5   LBU V0, -32299(GP)
9D01C1B0  7C021420   SEB V0, V0
9D01C1B4  14400011   BNE V0, ZERO, 0x9D01C1FC
9D01C1B8  00000000   NOP
1077:                		{
1078:                		tmp[0] = data;
1079:                		tmp[1] = 0;
1080:                		buf_enqueue (data);
9D01C1BC  0F4068E2   JAL buf_enqueue
9D01C1C0  00000000   NOP
1081:                		while (bufsize)
9D01C1C4  978281C0   LHU V0, -32320(GP)
9D01C1C8  3042FFFF   ANDI V0, V0, -1
9D01C1CC  10400013   BEQ V0, ZERO, 0x9D01C21C
9D01C1D0  8FBF0014   LW RA, 20(SP)
9D01C1E4  978281C0   LHU V0, -32320(GP)
9D01C1E8  3042FFFF   ANDI V0, V0, -1
9D01C1EC  1440FFF9   BNE V0, ZERO, 0x9D01C1D4
9D01C1F0  8FBF0014   LW RA, 20(SP)
9D01C1F4  0B407087   J 0x9D01C21C
9D01C1F8  00000000   NOP
1082:                			receive_char(buf_dequeue());
9D01C1D4  0F4068FA   JAL buf_dequeue
9D01C1D8  00000000   NOP
9D01C1DC  0F406D07   JAL receive_char
9D01C1E0  00402021   ADDU A0, V0, ZERO
1083:                		}
1084:                	else if (stdio_src==STDIO_TTY1)
9D01C1FC  938381D5   LBU V1, -32299(GP)
9D01C200  7C031C20   SEB V1, V1
9D01C204  24020001   ADDIU V0, ZERO, 1
9D01C208  14620004   BNE V1, V0, 0x9D01C21C
9D01C20C  8FBF0014   LW RA, 20(SP)
1085:                		tx_write(data);
9D01C210  0F407DDB   JAL tx_write
9D01C214  00000000   NOP
1086:                	}
9D01C218  8FBF0014   LW RA, 20(SP)
9D01C21C  03E00008   JR RA
9D01C220  27BD0018   ADDIU SP, SP, 24
1087:                
1088:                //check, whether is there something to read from standard input
1089:                //zero is returned when empty, nonzero when character is available
1090:                int8_t stdio_get_state (void)
1091:                	{
9D01C5BC  27BDFFE8   ADDIU SP, SP, -24
9D01C5C0  AFBF0014   SW RA, 20(SP)
1092:                	if (stdio_local_buffer_state()!=0)
9D01C5C4  0F40716C   JAL stdio_local_buffer_state
9D01C5C8  00000000   NOP
9D01C5CC  14400011   BNE V0, ZERO, 0x9D01C614
9D01C5D0  24020001   ADDIU V0, ZERO, 1
1093:                		return 1;
1094:                	if (stdio_src==STDIO_LOCAL)
9D01C5D4  938281D5   LBU V0, -32299(GP)
9D01C5D8  7C021420   SEB V0, V0
9D01C5DC  14400005   BNE V0, ZERO, 0x9D01C5F4
9D01C5E0  00000000   NOP
1095:                		return term_k_stat();
9D01C5E4  0F407148   JAL term_k_stat
9D01C5E8  00000000   NOP
9D01C5EC  0B407186   J 0x9D01C618
9D01C5F0  8FBF0014   LW RA, 20(SP)
1096:                	else if (stdio_src==STDIO_TTY1)
9D01C5F4  938381D5   LBU V1, -32299(GP)
9D01C5F8  7C031C20   SEB V1, V1
9D01C5FC  24020001   ADDIU V0, ZERO, 1
9D01C600  14620005   BNE V1, V0, 0x9D01C618
9D01C604  8FBF0014   LW RA, 20(SP)
1097:                		return rx_sta();
9D01C608  0F407DB5   JAL rx_sta
9D01C60C  00000000   NOP
9D01C610  7C021420   SEB V0, V0
1098:                	}
9D01C614  8FBF0014   LW RA, 20(SP)
9D01C618  03E00008   JR RA
9D01C61C  27BD0018   ADDIU SP, SP, 24
1099:                //get character from stdio
1100:                //zero when there is nothing to read
1101:                int8_t stdio_get (int8_t * dat)
1102:                	{
9D01C678  27BDFFE8   ADDIU SP, SP, -24
9D01C67C  AFBF0014   SW RA, 20(SP)
9D01C680  AFB00010   SW S0, 16(SP)
1103:                	if (stdio_local_buffer_state()!=0)
9D01C684  0F40716C   JAL stdio_local_buffer_state
9D01C688  00808021   ADDU S0, A0, ZERO
9D01C68C  10400006   BEQ V0, ZERO, 0x9D01C6A8
9D01C690  00000000   NOP
1104:                		{
1105:                		*dat = stdio_local_buffer_get();
9D01C694  0F407188   JAL stdio_local_buffer_get
9D01C698  00000000   NOP
9D01C69C  A2020000   SB V0, 0(S0)
1106:                		return 1;
9D01C6A0  0B4071BF   J 0x9D01C6FC
9D01C6A4  24030001   ADDIU V1, ZERO, 1
1107:                		}
1108:                	if (stdio_src==STDIO_LOCAL)
9D01C6A8  938281D5   LBU V0, -32299(GP)
9D01C6AC  7C021420   SEB V0, V0
9D01C6B0  14400005   BNE V0, ZERO, 0x9D01C6C8
9D01C6B4  00000000   NOP
1109:                		{
1110:                		return term_k_char(dat);
9D01C6B8  0F407153   JAL term_k_char
9D01C6BC  02002021   ADDU A0, S0, ZERO
9D01C6C0  0B4071BF   J 0x9D01C6FC
9D01C6C4  00401821   ADDU V1, V0, ZERO
1111:                		}
1112:                	else if (stdio_src==STDIO_TTY1)
9D01C6C8  938481D5   LBU A0, -32299(GP)
9D01C6CC  7C042420   SEB A0, A0
9D01C6D0  24020001   ADDIU V0, ZERO, 1
9D01C6D4  14820009   BNE A0, V0, 0x9D01C6FC
9D01C6D8  00001821   ADDU V1, ZERO, ZERO
1113:                		{
1114:                		if (rx_sta()!=0)
9D01C6DC  0F407DB5   JAL rx_sta
9D01C6E0  00000000   NOP
9D01C6E4  10400005   BEQ V0, ZERO, 0x9D01C6FC
9D01C6E8  00001821   ADDU V1, ZERO, ZERO
1115:                			{
1116:                			*dat=rx_read();
9D01C6EC  0F407DD7   JAL .LFB100, .LFE98, rx_read
9D01C6F0  00000000   NOP
9D01C6F4  A2020000   SB V0, 0(S0)
1117:                			return 1;
9D01C6F8  24030001   ADDIU V1, ZERO, 1
1118:                			}
1119:                		else
1120:                			return 0;
1121:                		}
1122:                	return 0;
1123:                	}
9D01C6FC  00601021   ADDU V0, V1, ZERO
9D01C700  8FBF0014   LW RA, 20(SP)
9D01C704  8FB00010   LW S0, 16(SP)
9D01C708  03E00008   JR RA
9D01C70C  27BD0018   ADDIU SP, SP, 24
1124:                
1125:                
1126:                int8_t term_k_stat (void)
1127:                	{
1128:                	uint8_t key_len;
1129:                	IEC0bits.T2IE = 0;
9D01C520  3C03BF88   LUI V1, -16504
9D01C524  8C621060   LW V0, 4192(V1)
9D01C528  7C024A44   INS V0, ZERO, 9, 1
9D01C52C  AC621060   SW V0, 4192(V1)
1130:                	key_len = key_buffer_ptr;
9D01C530  93828197   LBU V0, -32361(GP)
1131:                	IEC0bits.T2IE = 1;
9D01C534  8C641060   LW A0, 4192(V1)
9D01C538  24050001   ADDIU A1, ZERO, 1
9D01C53C  7CA44A44   INS A0, A1, 9, 1
9D01C540  AC641060   SW A0, 4192(V1)
1132:                	if (key_len == 0)
1133:                		return 0;
1134:                	else 
1135:                		return 1;
1136:                	}
9D01C544  03E00008   JR RA
9D01C548  0002102B   SLTU V0, ZERO, V0
1137:                
1138:                int8_t term_k_char (int8_t * out)
1139:                	{
9D01C54C  27BDFFE8   ADDIU SP, SP, -24
9D01C550  AFBF0014   SW RA, 20(SP)
9D01C554  AFB00010   SW S0, 16(SP)
1140:                	uint8_t retval;
1141:                	IEC0bits.T2IE = 0;
9D01C558  3C02BF88   LUI V0, -16504
9D01C55C  8C431060   LW V1, 4192(V0)
9D01C560  7C034A44   INS V1, ZERO, 9, 1
9D01C564  AC431060   SW V1, 4192(V0)
1142:                	retval = key_buffer_ptr;
9D01C568  93908197   LBU S0, -32361(GP)
1143:                	if (key_buffer_ptr>0)
9D01C56C  12000007   BEQ S0, ZERO, 0x9D01C58C
9D01C570  3C02BF88   LUI V0, -16504
1144:                		{
1145:                		strncpy(out,key_buffer,key_buffer_ptr);
9D01C574  3C05A000   LUI A1, -24576
9D01C578  24A519E8   ADDIU A1, A1, 6632
9D01C57C  0F40E164   JAL .LFE23, strncpy
9D01C580  02003021   ADDU A2, S0, ZERO
1146:                		key_buffer_ptr = 0;
9D01C584  A3808197   SB ZERO, -32361(GP)
1147:                		}
1148:                	IEC0bits.T2IE = 1;
9D01C588  3C02BF88   LUI V0, -16504
9D01C58C  8C431060   LW V1, 4192(V0)
9D01C590  24040001   ADDIU A0, ZERO, 1
9D01C594  7C834A44   INS V1, A0, 9, 1
9D01C598  AC431060   SW V1, 4192(V0)
1149:                	return retval;
1150:                	}
9D01C59C  7C101420   SEB V0, S0
9D01C5A0  8FBF0014   LW RA, 20(SP)
9D01C5A4  8FB00010   LW S0, 16(SP)
9D01C5A8  03E00008   JR RA
9D01C5AC  27BD0018   ADDIU SP, SP, 24
1151:                
1152:                
1153:                //void boot_animation(void)
1154:                //	{
1155:                //	handle_display = 0; //Shut off auto-scanning of character buffer
1156:                //	animate_splash();
1157:                //	uint16_t waitfor = ticks+1000;	//Wait for 1 second
1158:                //	while (ticks<waitfor) { ;; }
1159:                //	tft_fill_area(0,0,320,240,0x000000);    //Make display black
1160:                //	handle_display = 1; //Go back to character display
1161:                //}
1162:                
1163:                uint8_t stdio_local_buffer_state (void)
1164:                	{
1165:                	if (stdio_local_len>0) return 1;
9D01C5B0  93828196   LBU V0, -32362(GP)
1166:                	else return 0;
1167:                	}
9D01C5B4  03E00008   JR RA
9D01C5B8  0002102B   SLTU V0, ZERO, V0
1168:                
1169:                int8_t stdio_local_buffer_get (void)
1170:                	{
1171:                	int8_t retval=0;
1172:                	if (stdio_local_len>0)
9D01C620  93868196   LBU A2, -32362(GP)
9D01C624  10C00012   BEQ A2, ZERO, 0x9D01C670
9D01C628  00001021   ADDU V0, ZERO, ZERO
1173:                		{
1174:                		retval = stdio_local_buff[0];
9D01C62C  3C05A000   LUI A1, -24576
9D01C630  80A221AC   LB V0, 8620(A1)
9D01C634  3C03A000   LUI V1, -24576
9D01C638  246321AD   ADDIU V1, V1, 8621
9D01C63C  24A521AC   ADDIU A1, A1, 8620
9D01C640  24A50019   ADDIU A1, A1, 25
1175:                		for (i=1;i<STDIO_LOCAL_BUFF_SIZE;i++) stdio_local_buff[i-1] = stdio_local_buff[i];
9D01C644  90640000   LBU A0, 0(V1)
9D01C648  A064FFFF   SB A0, -1(V1)
9D01C64C  24630001   ADDIU V1, V1, 1
9D01C650  5465FFFD   BNEL V1, A1, 0x9D01C648
9D01C654  90640000   LBU A0, 0(V1)
9D01C658  24030019   ADDIU V1, ZERO, 25
9D01C65C  AF8381A0   SW V1, -32352(GP)
1176:                		stdio_local_buff[STDIO_LOCAL_BUFF_SIZE-1]=0;
9D01C660  3C03A000   LUI V1, -24576
9D01C664  A06021C4   SB ZERO, 8644(V1)
1177:                		stdio_local_len--;
9D01C668  24C6FFFF   ADDIU A2, A2, -1
9D01C66C  A3868196   SB A2, -32362(GP)
1178:                		}
1179:                	return retval;
1180:                	}
9D01C670  03E00008   JR RA
9D01C674  00000000   NOP
1181:                
1182:                void stdio_local_buffer_put (int8_t data)
1183:                	{
1184:                	if (stdio_local_len<(STDIO_LOCAL_BUFF_SIZE-1))
9D01C9AC  93828196   LBU V0, -32362(GP)
9D01C9B0  2C430018   SLTIU V1, V0, 24
9D01C9B4  10600006   BEQ V1, ZERO, 0x9D01C9D0
9D01C9B8  24430001   ADDIU V1, V0, 1
1185:                		stdio_local_buff[stdio_local_len++] = data;
9D01C9BC  A3838196   SB V1, -32362(GP)
9D01C9C0  3C03A000   LUI V1, -24576
9D01C9C4  246321AC   ADDIU V1, V1, 8620
9D01C9C8  00431021   ADDU V0, V0, V1
9D01C9CC  A0440000   SB A0, 0(V0)
9D01C9D0  03E00008   JR RA
9D01C9D4  00000000   NOP
1186:                	}
1187:                
1188:                void stdio_local_buffer_puts (int8_t * data)
1189:                	{
9D01C9D8  27BDFFE8   ADDIU SP, SP, -24
9D01C9DC  AFBF0014   SW RA, 20(SP)
9D01C9E0  AFB00010   SW S0, 16(SP)
9D01C9E4  00808021   ADDU S0, A0, ZERO
1190:                	while (*data!=0) stdio_local_buffer_put(*data++);
9D01C9E8  80840000   LB A0, 0(A0)
9D01C9EC  10800006   BEQ A0, ZERO, 0x9D01CA08
9D01C9F0  8FBF0014   LW RA, 20(SP)
9D01C9F4  0F40726B   JAL stdio_local_buffer_put
9D01C9F8  26100001   ADDIU S0, S0, 1
9D01C9FC  82040000   LB A0, 0(S0)
9D01CA00  1480FFFC   BNE A0, ZERO, 0x9D01C9F4
9D01CA04  8FBF0014   LW RA, 20(SP)
1191:                	}
9D01CA08  8FB00010   LW S0, 16(SP)
9D01CA0C  03E00008   JR RA
9D01CA10  27BD0018   ADDIU SP, SP, 24
1192:                
1193:                //************************************************************************
1194:                //some hardware stuff
1195:                
1196:                
1197:                //B_BDG003
1198:                void __ISR(_TIMER_5_VECTOR, IPL3AUTO) Timer5Handler(void)
1199:                {
9D01CA14  415DE800   RDPGPR SP, SP
9D01CA18  401B7000   MFC0 K1, EPC
9D01CA1C  401A6002   MFC0 K0, SRSCtl
9D01CA20  27BDFF90   ADDIU SP, SP, -112
9D01CA24  AFBB006C   SW K1, 108(SP)
9D01CA28  401B6000   MFC0 K1, Status
9D01CA2C  AFBA0064   SW K0, 100(SP)
9D01CA30  AFBB0068   SW K1, 104(SP)
9D01CA34  7C1B7844   INS K1, ZERO, 1, 15
9D01CA38  377B0C00   ORI K1, K1, 3072
9D01CA3C  409B6000   MTC0 K1, Status
9D01CA40  AFA30018   SW V1, 24(SP)
9D01CA44  AFA20014   SW V0, 20(SP)
9D01CA48  8FA30064   LW V1, 100(SP)
9D01CA4C  3063000F   ANDI V1, V1, 15
9D01CA50  14600011   BNE V1, ZERO, 0x9D01CA98
9D01CA54  00000000   NOP
9D01CA58  AFBF0054   SW RA, 84(SP)
9D01CA5C  AFB90050   SW T9, 80(SP)
9D01CA60  AFB8004C   SW T8, 76(SP)
9D01CA64  AFAF0048   SW T7, 72(SP)
9D01CA68  AFAE0044   SW T6, 68(SP)
9D01CA6C  AFAD0040   SW T5, 64(SP)
9D01CA70  AFAC003C   SW T4, 60(SP)
9D01CA74  AFAB0038   SW T3, 56(SP)
9D01CA78  AFAA0034   SW T2, 52(SP)
9D01CA7C  AFA90030   SW T1, 48(SP)
9D01CA80  AFA8002C   SW T0, 44(SP)
9D01CA84  AFA70028   SW A3, 40(SP)
9D01CA88  AFA60024   SW A2, 36(SP)
9D01CA8C  AFA50020   SW A1, 32(SP)
9D01CA90  AFA4001C   SW A0, 28(SP)
9D01CA94  AFA10010   SW AT, 16(SP)
9D01CA98  00001012   MFLO V0
9D01CA9C  AFA2005C   SW V0, 92(SP)
9D01CAA0  00001810   MFHI V1
9D01CAA4  AFA30058   SW V1, 88(SP)
1200:                    uint8_t key_temp;
1201:                    IFS0bits.T5IF = 0;
9D01CAA8  3C02BF88   LUI V0, -16504
9D01CAAC  8C431030   LW V1, 4144(V0)
9D01CAB0  7C03C604   INS V1, ZERO, 24, 1
9D01CAB4  AC431030   SW V1, 4144(V0)
1202:                	disp_tasks();
9D01CAB8  0F404EB0   JAL disp_tasks
9D01CABC  00000000   NOP
1203:                	loop_badge();
9D01CAC0  0F406E09   JAL loop_badge
9D01CAC4  00000000   NOP
1204:                    if (handle_display)
9D01CAC8  93828195   LBU V0, -32363(GP)
9D01CACC  304200FF   ANDI V0, V0, 255
9D01CAD0  10400005   BEQ V0, ZERO, .LVL297
9D01CAD4  3C04A000   LUI A0, -24576
1205:                		tft_disp_buffer_refresh_part((uint8_t *)(disp_buffer),(uint8_t *)color_buffer);
9D01CAD8  24841E64   ADDIU A0, A0, 7780
9D01CADC  3C05A000   LUI A1, -24576
9D01CAE0  0F405115   JAL tft_disp_buffer_refresh_part
9D01CAE4  24A51B1C   ADDIU A1, A1, 6940
1206:                    key_temp = keyb_tasks();
9D01CAE8  0F407BA6   JAL keyb_tasks
9D01CAEC  00000000   NOP
1207:                    if (key_temp>0)
9D01CAF0  10400007   BEQ V0, ZERO, 0x9D01CB10
9D01CAF4  93838197   LBU V1, -32361(GP)
1208:                		key_buffer[key_buffer_ptr++] = key_temp;
9D01CAF8  24640001   ADDIU A0, V1, 1
9D01CAFC  A3848197   SB A0, -32361(GP)
9D01CB00  3C04A000   LUI A0, -24576
9D01CB04  248419E8   ADDIU A0, A0, 6632
9D01CB08  00641821   ADDU V1, V1, A0
9D01CB0C  A0620000   SB V0, 0(V1)
1209:                }
9D01CB10  8FA2005C   LW V0, 92(SP)
9D01CB14  00400013   MTLO V0
9D01CB18  8FA30058   LW V1, 88(SP)
9D01CB1C  00600011   MTHI V1
9D01CB20  8FA20064   LW V0, 100(SP)
9D01CB24  3042000F   ANDI V0, V0, 15
9D01CB28  14400013   BNE V0, ZERO, 0x9D01CB78
9D01CB2C  00000000   NOP
9D01CB30  8FBF0054   LW RA, 84(SP)
9D01CB34  8FB90050   LW T9, 80(SP)
9D01CB38  8FB8004C   LW T8, 76(SP)
9D01CB3C  8FAF0048   LW T7, 72(SP)
9D01CB40  8FAE0044   LW T6, 68(SP)
9D01CB44  8FAD0040   LW T5, 64(SP)
9D01CB48  8FAC003C   LW T4, 60(SP)
9D01CB4C  8FAB0038   LW T3, 56(SP)
9D01CB50  8FAA0034   LW T2, 52(SP)
9D01CB54  8FA90030   LW T1, 48(SP)
9D01CB58  8FA8002C   LW T0, 44(SP)
9D01CB5C  8FA70028   LW A3, 40(SP)
9D01CB60  8FA60024   LW A2, 36(SP)
9D01CB64  8FA50020   LW A1, 32(SP)
9D01CB68  8FA4001C   LW A0, 28(SP)
9D01CB6C  8FA30018   LW V1, 24(SP)
9D01CB70  8FA20014   LW V0, 20(SP)
9D01CB74  8FA10010   LW AT, 16(SP)
9D01CB78  41606000   DI ZERO
9D01CB7C  000000C0   EHB
9D01CB80  8FBA006C   LW K0, 108(SP)
9D01CB84  8FBB0068   LW K1, 104(SP)
9D01CB88  409A7000   MTC0 K0, EPC
9D01CB8C  8FBA0064   LW K0, 100(SP)
9D01CB90  27BD0070   ADDIU SP, SP, 112
9D01CB94  409A6002   MTC0 K0, SRSCtl
9D01CB98  41DDE800   WRPGPR SP, SP
9D01CB9C  409B6000   MTC0 K1, Status
9D01CBA0  42000018   ERET
1210:                
1211:                extern volatile int nofrendo_ticks;
1212:                
1213:                void __ISR(_TIMER_1_VECTOR, IPL4AUTO) Timer1Handler(void)
1214:                	{
9D01CBA4  415DE800   RDPGPR SP, SP
9D01CBA8  401B7000   MFC0 K1, EPC
9D01CBAC  401A6002   MFC0 K0, SRSCtl
9D01CBB0  27BDFFE8   ADDIU SP, SP, -24
9D01CBB4  AFBB0014   SW K1, 20(SP)
9D01CBB8  401B6000   MFC0 K1, Status
9D01CBBC  AFBA000C   SW K0, 12(SP)
9D01CBC0  AFBB0010   SW K1, 16(SP)
9D01CBC4  7C1B7844   INS K1, ZERO, 1, 15
9D01CBC8  377B1000   ORI K1, K1, 4096
9D01CBCC  409B6000   MTC0 K1, Status
9D01CBD0  AFA30004   SW V1, 4(SP)
9D01CBD4  AFA20000   SW V0, 0(SP)
1215:                    IFS0bits.T1IF = 0;
9D01CBD8  3C02BF88   LUI V0, -16504
9D01CBDC  8C431030   LW V1, 4144(V0)
9D01CBE0  7C032104   INS V1, ZERO, 4, 1
9D01CBE4  AC431030   SW V1, 4144(V0)
1216:                    ++ticks;
9D01CBE8  8F8281E0   LW V0, -32288(GP)
9D01CBEC  24420001   ADDIU V0, V0, 1
9D01CBF0  AF8281E0   SW V0, -32288(GP)
1217:                    //if (ticks % 16 == 0)
1218:                        nofrendo_ticks++;
9D01CBF4  8F82816C   LW V0, -32404(GP)
9D01CBF8  24420001   ADDIU V0, V0, 1
9D01CBFC  AF82816C   SW V0, -32404(GP)
1219:                	}
9D01CC00  8FA2000C   LW V0, 12(SP)
9D01CC04  3042000F   ANDI V0, V0, 15
9D01CC08  14400003   BNE V0, ZERO, 0x9D01CC18
9D01CC0C  00000000   NOP
9D01CC10  8FA30004   LW V1, 4(SP)
9D01CC14  8FA20000   LW V0, 0(SP)
9D01CC18  41606000   DI ZERO
9D01CC1C  000000C0   EHB
9D01CC20  8FBA0014   LW K0, 20(SP)
9D01CC24  8FBB0010   LW K1, 16(SP)
9D01CC28  409A7000   MTC0 K0, EPC
9D01CC2C  8FBA000C   LW K0, 12(SP)
9D01CC30  27BD0018   ADDIU SP, SP, 24
9D01CC34  409A6002   MTC0 K0, SRSCtl
9D01CC38  41DDE800   WRPGPR SP, SP
9D01CC3C  409B6000   MTC0 K1, Status
9D01CC40  42000018   ERET
1220:                void __ISR(_EXTERNAL_2_VECTOR, IPL4AUTO) Int2Handler(void)
1221:                	{
9D01CC44  415DE800   RDPGPR SP, SP
9D01CC48  401B7000   MFC0 K1, EPC
9D01CC4C  401A6002   MFC0 K0, SRSCtl
9D01CC50  27BDFFE8   ADDIU SP, SP, -24
9D01CC54  AFBB0014   SW K1, 20(SP)
9D01CC58  401B6000   MFC0 K1, Status
9D01CC5C  AFBA000C   SW K0, 12(SP)
9D01CC60  AFBB0010   SW K1, 16(SP)
9D01CC64  7C1B7844   INS K1, ZERO, 1, 15
9D01CC68  377B1000   ORI K1, K1, 4096
9D01CC6C  409B6000   MTC0 K1, Status
9D01CC70  AFA30004   SW V1, 4(SP)
9D01CC74  AFA20000   SW V0, 0(SP)
1222:                	IEC0bits.INT2IE = 0;
9D01CC78  3C02BF88   LUI V0, -16504
9D01CC7C  8C431060   LW V1, 4192(V0)
9D01CC80  7C036B44   INS V1, ZERO, 13, 1
9D01CC84  AC431060   SW V1, 4192(V0)
1223:                	}
9D01CC88  8FA2000C   LW V0, 12(SP)
9D01CC8C  3042000F   ANDI V0, V0, 15
9D01CC90  14400003   BNE V0, ZERO, 0x9D01CCA0
9D01CC94  00000000   NOP
9D01CC98  8FA30004   LW V1, 4(SP)
9D01CC9C  8FA20000   LW V0, 0(SP)
9D01CCA0  41606000   DI ZERO
9D01CCA4  000000C0   EHB
9D01CCA8  8FBA0014   LW K0, 20(SP)
9D01CCAC  8FBB0010   LW K1, 16(SP)
9D01CCB0  409A7000   MTC0 K0, EPC
9D01CCB4  8FBA000C   LW K0, 12(SP)
9D01CCB8  27BD0018   ADDIU SP, SP, 24
9D01CCBC  409A6002   MTC0 K0, SRSCtl
9D01CCC0  41DDE800   WRPGPR SP, SP
9D01CCC4  409B6000   MTC0 K1, Status
9D01CCC8  42000018   ERET
1224:                
1225:                uint16_t get_user_value (void)
1226:                	{
9D01CCCC  27BDFFC0   ADDIU SP, SP, -64
9D01CCD0  AFBF003C   SW RA, 60(SP)
9D01CCD4  AFB20038   SW S2, 56(SP)
9D01CCD8  AFB10034   SW S1, 52(SP)
9D01CCDC  AFB00030   SW S0, 48(SP)
1227:                	int8_t temp_arr[20];
1228:                	uint8_t temp_arr_p=0,char_val,stat;
9D01CCEC  00008821   ADDU S1, ZERO, ZERO
1229:                	uint32_t retval;
1230:                	stdio_write(" :");
9D01CCE0  3C049D03   LUI A0, -25341
9D01CCE4  0F406F61   JAL stdio_write
9D01CCE8  248496AC   ADDIU A0, A0, -26964
1231:                	while (1)
1232:                		{
1233:                		stat = stdio_get(&char_val);
9D01CCF4  0F40719E   JAL stdio_get
9D01CCF8  27A40024   ADDIU A0, SP, 36
1234:                		if ((char_val!=NEWLINE)&(stat!=0))
9D01CCFC  0002802B   SLTU S0, ZERO, V0
9D01CD00  12000017   BEQ S0, ZERO, 0x9D01CD60
9D01CD04  93A40024   LBU A0, 36(SP)
9D01CD08  3882000A   XORI V0, A0, 10
9D01CD0C  10400014   BEQ V0, ZERO, 0x9D01CD60
9D01CD10  00000000   NOP
1235:                			{
1236:                			stdio_c(char_val);
9D01CD14  0F407069   JAL stdio_c
9D01CD18  00000000   NOP
1237:                			if (char_val>=' ') temp_arr[temp_arr_p++] = char_val;
9D01CD1C  93A20024   LBU V0, 36(SP)
9D01CD20  2C430020   SLTIU V1, V0, 32
9D01CD24  14600006   BNE V1, ZERO, 0x9D01CD40
9D01CD28  26230001   ADDIU V1, S1, 1
9D01CD2C  27A40010   ADDIU A0, SP, 16
9D01CD30  00918821   ADDU S1, A0, S1
9D01CD34  A2220000   SB V0, 0(S1)
9D01CD38  0B407358   J 0x9D01CD60
9D01CD3C  307100FF   ANDI S1, V1, 255
1238:                			else if (char_val==BACKSPACE)
9D01CCF0  24120008   ADDIU S2, ZERO, 8
9D01CD40  14520007   BNE V0, S2, 0x9D01CD60
9D01CD44  00000000   NOP
1239:                				{
1240:                				if (temp_arr_p>0) temp_arr[--temp_arr_p]=0;
9D01CD48  12200014   BEQ S1, ZERO, 0x9D01CD9C
9D01CD4C  27A30010   ADDIU V1, SP, 16
9D01CD50  2631FFFF   ADDIU S1, S1, -1
9D01CD54  323100FF   ANDI S1, S1, 255
9D01CD58  00711021   ADDU V0, V1, S1
9D01CD5C  A0400000   SB ZERO, 0(V0)
1241:                				}
1242:                			}
1243:                	    if ((char_val==NEWLINE)&(stat!=0))
9D01CD60  1200000E   BEQ S0, ZERO, 0x9D01CD9C
9D01CD64  93A20024   LBU V0, 36(SP)
9D01CD68  3842000A   XORI V0, V0, 10
9D01CD6C  1440000B   BNE V0, ZERO, 0x9D01CD9C
9D01CD70  27A40010   ADDIU A0, SP, 16
1244:                			{
1245:                			temp_arr[temp_arr_p] = 0;
9D01CD74  00918821   ADDU S1, A0, S1
9D01CD78  A2200000   SB ZERO, 0(S1)
1246:                			sscanf(temp_arr,"%d",&retval);
9D01CD7C  3C059D03   LUI A1, -25341
9D01CD80  24A596B0   ADDIU A1, A1, -26960
9D01CD84  0F40EB5C   JAL .Letext0, .LFE1, _sscanf_cdnopuxX
9D01CD88  27A60028   ADDIU A2, SP, 40
1247:                			stdio_c('\n');
9D01CD8C  0F407069   JAL stdio_c
9D01CD90  2404000A   ADDIU A0, ZERO, 10
1248:                			return retval;
9D01CD94  0B40736B   J 0x9D01CDAC
9D01CD98  97A20028   LHU V0, 40(SP)
1249:                			}
1250:                		if (brk_key) return 0;
9D01CD9C  938281DD   LBU V0, -32291(GP)
9D01CDA0  7C021420   SEB V0, V0
9D01CDA4  1040FFD3   BEQ V0, ZERO, 0x9D01CCF4
9D01CDA8  00001021   ADDU V0, ZERO, ZERO
1251:                		}
1252:                	}
9D01CDAC  8FBF003C   LW RA, 60(SP)
9D01CDB0  8FB20038   LW S2, 56(SP)
9D01CDB4  8FB10034   LW S1, 52(SP)
9D01CDB8  8FB00030   LW S0, 48(SP)
9D01CDBC  03E00008   JR RA
9D01CDC0  27BD0040   ADDIU SP, SP, 64
1253:                
1254:                
1255:                void display_refresh_force (void)
1256:                	{
9D01CDC4  27BDFFE8   ADDIU SP, SP, -24
9D01CDC8  AFBF0014   SW RA, 20(SP)
1257:                	tft_disp_buffer_refresh((uint8_t *)disp_buffer,(uint8_t *)color_buffer);
9D01CDCC  3C04A000   LUI A0, -24576
9D01CDD0  24841E64   ADDIU A0, A0, 7780
9D01CDD4  3C05A000   LUI A1, -24576
9D01CDD8  0F4053F4   JAL tft_disp_buffer_refresh
9D01CDDC  24A51B1C   ADDIU A1, A1, 6940
1258:                	}
9D01CDE0  8FBF0014   LW RA, 20(SP)
9D01CDE4  03E00008   JR RA
9D01CDE8  27BD0018   ADDIU SP, SP, 24
---  /Users/nitro/basic-badge/firmware/badge1.X/src/Z80/hwz.c  ------------------------------------------
1:                   #include "hwz.h"
2:                   #include <xc.h>
3:                   #include <plib.h>
4:                   #include <stdio.h>
5:                   #include <fcntl.h>
6:                   #include <sys/appio.h>
7:                   
8:                   #include "sim.h"
9:                   #include "simglb.h"
10:                  #include "../hw.h"
11:                  
12:                  extern const uint8_t rom_image[65536];
13:                  extern const uint8_t rd_image[131072];
14:                  extern const uint8_t rd_image2[ROMDISK2_SIZE];
15:                  uint8_t drive, sector, track,disk_temp_pointer;
16:                  uint8_t disk_temp[128],flash_buff[4096], conin_buffer[30], conin_buffer_pointer;
17:                  
18:                  uint32_t last_addr = 0xFFFFF000;
19:                  uint8_t unwritten;
20:                  
21:                  uint8_t fl_rdsr(void);
22:                  uint32_t fl_rdid(void);
23:                  
24:                  #ifdef	USE_RAM_IMAGE
25:                  extern const uint8_t ram_image[65536];
26:                  #endif
27:                  
28:                  #ifdef	USE_RAMDISK
29:                  uint8_t ram_disk[RAMDISK_SIZE];
30:                  #endif
31:                  
32:                  //void reload_cpm_warm (void)
33:                  //{
34:                  //uint16_t i;
35:                  //#ifdef	USE_RAM_IMAGE	
36:                  //	for (i=0xD400;i<(0xD400+0x1EFF);i++) ram[i] = ram_image[i];
37:                  //#endif
38:                  //}
39:                  
40:                  //-------------------device at 0x68-----------------
41:                  uint8_t rxm_sta (void)
42:                  {
43:                  /*
44:                  if (U3BSTAbits.URXDA==1) return 0xFF;
45:                  	else return 0x00;
46:                   */
47:                  }
9D02C0F0  03E00008   JR RA
9D02C0F4  00000000   NOP
48:                  uint8_t rxm_read (void)
49:                  {
50:                  /*
51:                  return U3BRXREG;
52:                   */
53:                  }
9D02C0F8  03E00008   JR RA
9D02C0FC  00000000   NOP
54:                  void txm_write (uint8_t data)
55:                  {
9D02C100  03E00008   JR RA
9D02C104  00000000   NOP
56:                  /*
57:                  U3BTXREG = data;
58:                  while (U3BSTAbits.UTXBF==1);
59:                   */
60:                  }
61:                  
62:                  void set_drive (uint8_t dat)
63:                  {
64:                  drive = dat;
9D02C108  A38481A8   SB A0, -32344(GP)
65:                  disk_temp_pointer = 0;
9D02C10C  03E00008   JR RA
9D02C110  A38081A7   SB ZERO, -32345(GP)
66:                  }
67:                  void set_sector (uint8_t dat)
68:                  {
69:                  sector = dat;
9D02C114  A38481A6   SB A0, -32346(GP)
70:                  disk_temp_pointer = 0;
9D02C118  03E00008   JR RA
9D02C11C  A38081A7   SB ZERO, -32345(GP)
71:                  }
72:                  void set_track (uint8_t dat)
73:                  {
74:                  track = dat;
9D02C120  A38481B0   SB A0, -32336(GP)
75:                  disk_temp_pointer = 0;
9D02C124  03E00008   JR RA
9D02C128  A38081A7   SB ZERO, -32345(GP)
76:                  }
77:                  
78:                  //uint8_t read_disk_byte (void)
79:                  //{
80:                  //uint8_t temp;
81:                  //uint32_t  base,ptr;
82:                  //base = (((uint32_t )(track))*16) + sector;
83:                  //if (drive==0)
84:                  //	{
85:                  //	base = base*128;
86:                  //#ifdef USE_RAMDISK
87:                  //	ptr = base + disk_temp_pointer;
88:                  //	if (ptr<RAMDISK_SIZE)
89:                  //		temp = ram_disk[ptr];
90:                  //#endif
91:                  //#ifndef	USE_RAMDISK
92:                  //	temp = 0xA5;
93:                  //#endif
94:                  //	}
95:                  //if (drive==1)
96:                  //	{
97:                  //	base = base*128;
98:                  //#ifdef	USE_ROMDISK
99:                  //	temp = rd_image[base + disk_temp_pointer];
100:                 //#endif
101:                 //	}
102:                 //if (drive==2)
103:                 //	{
104:                 //#ifdef USE_EEPROM
105:                 //	if (disk_temp_pointer==0) read_sector(disk_temp,base);
106:                 //	temp = disk_temp[disk_temp_pointer];
107:                 //#endif
108:                 //	base = base*128;
109:                 //#ifdef	USE_ROMDISK2
110:                 //	temp = rd_image2[base + disk_temp_pointer];
111:                 //#endif
112:                 //	}
113:                 //
114:                 //if (drive==3)
115:                 //	{
116:                 //	if (disk_temp_pointer==0) fl_read_128(base+(CPM1_DISK1_OFFSET),disk_temp);
117:                 //	temp = disk_temp[disk_temp_pointer];
118:                 //	}
119:                 //if (drive==4)
120:                 //	{
121:                 //	}
122:                 //if (drive==5)
123:                 //	{
124:                 //	}
125:                 //if (drive==6)
126:                 //	{
127:                 //	}
128:                 //
129:                 //disk_temp_pointer++;
130:                 //return temp;
131:                 //}
132:                 //
133:                 //void write_disk_byte (uint8_t dat)
134:                 //{
135:                 //uint8_t temp;
136:                 //uint32_t base;
137:                 //uint32_t  ptr;
138:                 //base = (((unsigned int)(track))*16) + sector;
139:                 //if (drive==0)
140:                 //	{
141:                 //#ifdef	USE_RAMDISK
142:                 //	base = base*128;
143:                 //	ptr = base + disk_temp_pointer;
144:                 //	if (ptr<RAMDISK_SIZE)
145:                 //		ram_disk[ptr] = dat;
146:                 //#endif
147:                 //	}
148:                 //if (drive==1)
149:                 //	{
150:                 //	//rom disk, no writes allowed
151:                 //	}
152:                 //if (drive==2)
153:                 //	{
154:                 //#ifdef USE_EEPROM
155:                 //	disk_temp[disk_temp_pointer] = dat;
156:                 //	if (disk_temp_pointer==127) 
157:                 //		{
158:                 //		ee_wren();
159:                 //		write_sector(disk_temp,base);
160:                 //		}
161:                 //#endif
162:                 //	}
163:                 //if (drive==3)
164:                 //	{
165:                 //	disk_temp[disk_temp_pointer] = dat;
166:                 //	if (disk_temp_pointer==127) 
167:                 //		{
168:                 //		fl_write_128(base+(CPM1_DISK1_OFFSET),disk_temp);
169:                 //		}
170:                 //	}
171:                 //if (drive==4)
172:                 //	{
173:                 //	}
174:                 //if (drive==5)
175:                 //	{
176:                 //	}
177:                 //if (drive==6)
178:                 //	{
179:                 //	}
180:                 //disk_temp_pointer++;
181:                 //}
182:                 
183:                 uint8_t fl_rdsr(void)
184:                 {
9D02C12C  27BDFFE0   ADDIU SP, SP, -32
9D02C130  AFBF001C   SW RA, 28(SP)
9D02C134  AFB00018   SW S0, 24(SP)
185:                 volatile uint8_t temp;
186:                 CS_FLASH = 0;
9D02C138  3C10BF88   LUI S0, -16504
9D02C13C  92026530   LBU V0, 25904(S0)
9D02C140  7C021084   INS V0, ZERO, 2, 1
9D02C144  A2026530   SB V0, 25904(S0)
187:                 SPI_dat(0x05);
9D02C148  0F407CBA   JAL SPI_dat
9D02C14C  24040005   ADDIU A0, ZERO, 5
188:                 temp = SPI_dat(0xFF);
9D02C150  0F407CBA   JAL SPI_dat
9D02C154  240400FF   ADDIU A0, ZERO, 255
9D02C158  A3A20010   SB V0, 16(SP)
189:                 CS_FLASH = 1;
9D02C15C  92026530   LBU V0, 25904(S0)
9D02C160  24030001   ADDIU V1, ZERO, 1
9D02C164  7C621084   INS V0, V1, 2, 1
9D02C168  A2026530   SB V0, 25904(S0)
190:                 return temp;
9D02C16C  93A20010   LBU V0, 16(SP)
191:                 }
9D02C170  304200FF   ANDI V0, V0, 255
9D02C174  8FBF001C   LW RA, 28(SP)
9D02C178  8FB00018   LW S0, 24(SP)
9D02C17C  03E00008   JR RA
9D02C180  27BD0020   ADDIU SP, SP, 32
192:                 
193:                 
194:                 uint32_t fl_rdid(void)
195:                 {
9D02C184  27BDFFE0   ADDIU SP, SP, -32
9D02C188  AFBF001C   SW RA, 28(SP)
9D02C18C  AFB20018   SW S2, 24(SP)
9D02C190  AFB10014   SW S1, 20(SP)
9D02C194  AFB00010   SW S0, 16(SP)
196:                 uint8_t temp1,temp2,temp3;
197:                 uint32_t retval;
198:                 CS_FLASH = 0;
9D02C198  3C10BF88   LUI S0, -16504
9D02C19C  92026530   LBU V0, 25904(S0)
9D02C1A0  7C021084   INS V0, ZERO, 2, 1
9D02C1A4  A2026530   SB V0, 25904(S0)
199:                 SPI_dat(0x9F);
9D02C1A8  0F407CBA   JAL SPI_dat
9D02C1AC  2404009F   ADDIU A0, ZERO, 159
200:                 temp3 = SPI_dat(0xFF);
9D02C1B0  0F407CBA   JAL SPI_dat
9D02C1B4  240400FF   ADDIU A0, ZERO, 255
9D02C1B8  00409021   ADDU S2, V0, ZERO
201:                 temp2 = SPI_dat(0x55);
9D02C1BC  0F407CBA   JAL SPI_dat
9D02C1C0  24040055   ADDIU A0, ZERO, 85
9D02C1C4  00408821   ADDU S1, V0, ZERO
202:                 temp1 = SPI_dat(0xAA);
9D02C1C8  0F407CBA   JAL SPI_dat
9D02C1CC  240400AA   ADDIU A0, ZERO, 170
203:                 CS_FLASH = 1;
9D02C1D0  92036530   LBU V1, 25904(S0)
9D02C1D4  24040001   ADDIU A0, ZERO, 1
9D02C1D8  7C831084   INS V1, A0, 2, 1
9D02C1DC  A2036530   SB V1, 25904(S0)
204:                 retval = (((uint32_t)(temp3))<<16)|(((uint32_t)(temp2))<<8)|(((uint32_t)(temp1))<<0);
9D02C1E0  00129400   SLL S2, S2, 16
9D02C1E4  00118A00   SLL S1, S1, 8
9D02C1E8  02518825   OR S1, S2, S1
205:                 return retval;
206:                 }
9D02C1EC  02221025   OR V0, S1, V0
9D02C1F0  8FBF001C   LW RA, 28(SP)
9D02C1F4  8FB20018   LW S2, 24(SP)
9D02C1F8  8FB10014   LW S1, 20(SP)
9D02C1FC  8FB00010   LW S0, 16(SP)
9D02C200  03E00008   JR RA
9D02C204  27BD0020   ADDIU SP, SP, 32
207:                 
208:                 void fl_read_4k(uint32_t  addr, uint8_t * data)
209:                 {
9D02C208  27BDFFE0   ADDIU SP, SP, -32
9D02C20C  AFBF001C   SW RA, 28(SP)
9D02C210  AFB10018   SW S1, 24(SP)
9D02C214  AFB00014   SW S0, 20(SP)
9D02C218  00808821   ADDU S1, A0, ZERO
9D02C21C  00A08021   ADDU S0, A1, ZERO
210:                 uint16_t i;
211:                 CS_FLASH = 0;
9D02C220  3C02BF88   LUI V0, -16504
9D02C224  90436530   LBU V1, 25904(V0)
9D02C228  7C031084   INS V1, ZERO, 2, 1
9D02C22C  A0436530   SB V1, 25904(V0)
212:                 SPI_dat(0x03);
9D02C230  0F407CBA   JAL SPI_dat
9D02C234  24040003   ADDIU A0, ZERO, 3
213:                 SPI_dat((addr>>16)&0xFF);
9D02C238  0F407CBA   JAL SPI_dat
9D02C23C  7E243C00   EXT A0, S1, 16, 8
214:                 SPI_dat((addr>>8)&0xFF);
9D02C240  0F407CBA   JAL SPI_dat
9D02C244  7E243A00   EXT A0, S1, 8, 8
215:                 SPI_dat((addr>>0)&0xFF);
9D02C248  0F407CBA   JAL SPI_dat
9D02C24C  322400FF   ANDI A0, S1, 255
9D02C250  26111000   ADDIU S1, S0, 4096
216:                 for (i=0;i<4096;i++) *data++ = SPI_dat(0xFF);
9D02C254  26100001   ADDIU S0, S0, 1
9D02C258  0F407CBA   JAL SPI_dat
9D02C25C  240400FF   ADDIU A0, ZERO, 255
9D02C260  1611FFFC   BNE S0, S1, 0x9D02C254
9D02C264  A202FFFF   SB V0, -1(S0)
217:                 CS_FLASH = 1;
9D02C268  3C02BF88   LUI V0, -16504
9D02C26C  90436530   LBU V1, 25904(V0)
9D02C270  24040001   ADDIU A0, ZERO, 1
9D02C274  7C831084   INS V1, A0, 2, 1
9D02C278  A0436530   SB V1, 25904(V0)
218:                 }
9D02C27C  8FBF001C   LW RA, 28(SP)
9D02C280  8FB10018   LW S1, 24(SP)
9D02C284  8FB00014   LW S0, 20(SP)
9D02C288  03E00008   JR RA
9D02C28C  27BD0020   ADDIU SP, SP, 32
219:                 
220:                 void fl_read_nk(uint32_t  addr, uint8_t * data, uint16_t n)
221:                 {
9D02C290  27BDFFE0   ADDIU SP, SP, -32
9D02C294  AFBF001C   SW RA, 28(SP)
9D02C298  AFB20018   SW S2, 24(SP)
9D02C29C  AFB10014   SW S1, 20(SP)
9D02C2A0  AFB00010   SW S0, 16(SP)
9D02C2A4  00808821   ADDU S1, A0, ZERO
9D02C2A8  00A08021   ADDU S0, A1, ZERO
9D02C2AC  00C09021   ADDU S2, A2, ZERO
222:                 uint16_t i;
223:                 CS_FLASH = 0;
9D02C2B0  3C02BF88   LUI V0, -16504
9D02C2B4  90436530   LBU V1, 25904(V0)
9D02C2B8  7C031084   INS V1, ZERO, 2, 1
9D02C2BC  A0436530   SB V1, 25904(V0)
224:                 SPI_dat(0x03);
9D02C2C0  0F407CBA   JAL SPI_dat
9D02C2C4  24040003   ADDIU A0, ZERO, 3
225:                 SPI_dat((addr>>16)&0xFF);
9D02C2C8  0F407CBA   JAL SPI_dat
9D02C2CC  7E243C00   EXT A0, S1, 16, 8
226:                 SPI_dat((addr>>8)&0xFF);
9D02C2D0  0F407CBA   JAL SPI_dat
9D02C2D4  7E243A00   EXT A0, S1, 8, 8
227:                 SPI_dat((addr>>0)&0xFF);
9D02C2D8  0F407CBA   JAL SPI_dat
9D02C2DC  322400FF   ANDI A0, S1, 255
228:                 for (i=0;i<n;i++) *data++ = SPI_dat(0xFF);
9D02C2E0  12400009   BEQ S2, ZERO, 0x9D02C308
9D02C2E4  2651FFFF   ADDIU S1, S2, -1
9D02C2E8  3231FFFF   ANDI S1, S1, -1
9D02C2EC  26310001   ADDIU S1, S1, 1
9D02C2F0  02118821   ADDU S1, S0, S1
9D02C2F4  26100001   ADDIU S0, S0, 1
9D02C2F8  0F407CBA   JAL SPI_dat
9D02C2FC  240400FF   ADDIU A0, ZERO, 255
9D02C300  1611FFFC   BNE S0, S1, 0x9D02C2F4
9D02C304  A202FFFF   SB V0, -1(S0)
229:                 CS_FLASH = 1;
9D02C308  3C02BF88   LUI V0, -16504
9D02C30C  90436530   LBU V1, 25904(V0)
9D02C310  24040001   ADDIU A0, ZERO, 1
9D02C314  7C831084   INS V1, A0, 2, 1
9D02C318  A0436530   SB V1, 25904(V0)
230:                 }
9D02C31C  8FBF001C   LW RA, 28(SP)
9D02C320  8FB20018   LW S2, 24(SP)
9D02C324  8FB10014   LW S1, 20(SP)
9D02C328  8FB00010   LW S0, 16(SP)
9D02C32C  03E00008   JR RA
9D02C330  27BD0020   ADDIU SP, SP, 32
231:                 
232:                 
233:                 void fl_erase_4k(uint32_t  addr)
234:                 {
9D02C378  27BDFFE0   ADDIU SP, SP, -32
9D02C37C  AFBF001C   SW RA, 28(SP)
9D02C380  AFB10018   SW S1, 24(SP)
9D02C384  AFB00014   SW S0, 20(SP)
235:                 uint16_t i;
236:                 fl_wren();
9D02C388  0F40B0CD   JAL fl_wren
9D02C38C  00808821   ADDU S1, A0, ZERO
237:                 CS_FLASH = 0;
9D02C390  3C10BF88   LUI S0, -16504
9D02C394  92026530   LBU V0, 25904(S0)
9D02C398  7C021084   INS V0, ZERO, 2, 1
9D02C39C  A2026530   SB V0, 25904(S0)
238:                 SPI_dat(0x20);
9D02C3A0  0F407CBA   JAL SPI_dat
9D02C3A4  24040020   ADDIU A0, ZERO, 32
239:                 SPI_dat((addr>>16)&0xFF);
9D02C3A8  0F407CBA   JAL SPI_dat
9D02C3AC  7E243C00   EXT A0, S1, 16, 8
240:                 SPI_dat((addr>>8)&0xFF);
9D02C3B0  0F407CBA   JAL SPI_dat
9D02C3B4  7E243A00   EXT A0, S1, 8, 8
241:                 SPI_dat((addr>>0)&0xFF);
9D02C3B8  0F407CBA   JAL SPI_dat
9D02C3BC  322400FF   ANDI A0, S1, 255
242:                 CS_FLASH = 1;
9D02C3C0  92026530   LBU V0, 25904(S0)
9D02C3C4  24030001   ADDIU V1, ZERO, 1
9D02C3C8  7C621084   INS V0, V1, 2, 1
9D02C3CC  A2026530   SB V0, 25904(S0)
243:                 while ((fl_rdsr())&0x01);
9D02C3D0  0F40B04B   JAL fl_rdsr
9D02C3D4  00000000   NOP
9D02C3D8  30420001   ANDI V0, V0, 1
9D02C3DC  1440FFFC   BNE V0, ZERO, 0x9D02C3D0
9D02C3E0  8FBF001C   LW RA, 28(SP)
244:                 }
9D02C3E4  8FB10018   LW S1, 24(SP)
9D02C3E8  8FB00014   LW S0, 20(SP)
9D02C3EC  03E00008   JR RA
9D02C3F0  27BD0020   ADDIU SP, SP, 32
245:                 
246:                 
247:                 void fl_write(uint32_t  addr,uint8_t data)
248:                 {
9D02C3F4  27BDFFE0   ADDIU SP, SP, -32
9D02C3F8  AFBF001C   SW RA, 28(SP)
9D02C3FC  AFB20018   SW S2, 24(SP)
9D02C400  AFB10014   SW S1, 20(SP)
9D02C404  AFB00010   SW S0, 16(SP)
9D02C408  00808821   ADDU S1, A0, ZERO
249:                 uint16_t i;
250:                 fl_wren();
9D02C40C  0F40B0CD   JAL fl_wren
9D02C410  00A09021   ADDU S2, A1, ZERO
251:                 CS_FLASH = 0;
9D02C414  3C10BF88   LUI S0, -16504
9D02C418  92026530   LBU V0, 25904(S0)
9D02C41C  7C021084   INS V0, ZERO, 2, 1
9D02C420  A2026530   SB V0, 25904(S0)
252:                 SPI_dat(0x02);
9D02C424  0F407CBA   JAL SPI_dat
9D02C428  24040002   ADDIU A0, ZERO, 2
253:                 SPI_dat((addr>>16)&0xFF);
9D02C42C  0F407CBA   JAL SPI_dat
9D02C430  7E243C00   EXT A0, S1, 16, 8
254:                 SPI_dat((addr>>8)&0xFF);
9D02C434  0F407CBA   JAL SPI_dat
9D02C438  7E243A00   EXT A0, S1, 8, 8
255:                 SPI_dat((addr>>0)&0xFF);
9D02C43C  0F407CBA   JAL SPI_dat
9D02C440  322400FF   ANDI A0, S1, 255
256:                 SPI_dat(data);
9D02C444  0F407CBA   JAL SPI_dat
9D02C448  02402021   ADDU A0, S2, ZERO
257:                 CS_FLASH = 1;
9D02C44C  92026530   LBU V0, 25904(S0)
9D02C450  24030001   ADDIU V1, ZERO, 1
9D02C454  7C621084   INS V0, V1, 2, 1
9D02C458  A2026530   SB V0, 25904(S0)
258:                 }
9D02C45C  8FBF001C   LW RA, 28(SP)
9D02C460  8FB20018   LW S2, 24(SP)
9D02C464  8FB10014   LW S1, 20(SP)
9D02C468  8FB00010   LW S0, 16(SP)
9D02C46C  03E00008   JR RA
9D02C470  27BD0020   ADDIU SP, SP, 32
259:                 
260:                 void fl_rst_pb(void)
261:                 {
9D02C474  27BDFFE8   ADDIU SP, SP, -24
9D02C478  AFBF0014   SW RA, 20(SP)
262:                 /*
263:                 CS_FLASH = 0;
264:                 SPI_dat(0x50);
265:                 CS_FLASH = 1;
266:                 */
267:                 fl_wren();
9D02C47C  0F40B0CD   JAL fl_wren
9D02C480  AFB00010   SW S0, 16(SP)
268:                 CS_FLASH = 0;
9D02C484  3C10BF88   LUI S0, -16504
9D02C488  92026530   LBU V0, 25904(S0)
9D02C48C  7C021084   INS V0, ZERO, 2, 1
9D02C490  A2026530   SB V0, 25904(S0)
269:                 SPI_dat(0x01);
9D02C494  0F407CBA   JAL SPI_dat
9D02C498  24040001   ADDIU A0, ZERO, 1
270:                 SPI_dat(0x00);
9D02C49C  0F407CBA   JAL SPI_dat
9D02C4A0  00002021   ADDU A0, ZERO, ZERO
271:                 CS_FLASH = 1;
9D02C4A4  92026530   LBU V0, 25904(S0)
9D02C4A8  24030001   ADDIU V1, ZERO, 1
9D02C4AC  7C621084   INS V0, V1, 2, 1
9D02C4B0  A2026530   SB V0, 25904(S0)
272:                 }
9D02C4B4  8FBF0014   LW RA, 20(SP)
9D02C4B8  8FB00010   LW S0, 16(SP)
9D02C4BC  03E00008   JR RA
9D02C4C0  27BD0018   ADDIU SP, SP, 24
273:                 
274:                 void fl_wren(void)
275:                 {
9D02C334  27BDFFE8   ADDIU SP, SP, -24
9D02C338  AFBF0014   SW RA, 20(SP)
9D02C33C  AFB00010   SW S0, 16(SP)
276:                 CS_FLASH = 0;
9D02C340  3C10BF88   LUI S0, -16504
9D02C344  92026530   LBU V0, 25904(S0)
9D02C348  7C021084   INS V0, ZERO, 2, 1
9D02C34C  A2026530   SB V0, 25904(S0)
277:                 SPI_dat(0x06);
9D02C350  0F407CBA   JAL SPI_dat
9D02C354  24040006   ADDIU A0, ZERO, 6
278:                 CS_FLASH = 1;
9D02C358  92026530   LBU V0, 25904(S0)
9D02C35C  24030001   ADDIU V1, ZERO, 1
9D02C360  7C621084   INS V0, V1, 2, 1
9D02C364  A2026530   SB V0, 25904(S0)
279:                 }
9D02C368  8FBF0014   LW RA, 20(SP)
9D02C36C  8FB00010   LW S0, 16(SP)
9D02C370  03E00008   JR RA
9D02C374  27BD0018   ADDIU SP, SP, 24
280:                 
281:                 
282:                 void fl_write_4k(uint32_t  addr, uint8_t * data)
283:                 {
9D02C4C4  27BDFFE0   ADDIU SP, SP, -32
9D02C4C8  AFBF001C   SW RA, 28(SP)
9D02C4CC  AFB20018   SW S2, 24(SP)
9D02C4D0  AFB10014   SW S1, 20(SP)
9D02C4D4  AFB00010   SW S0, 16(SP)
9D02C4D8  24B21000   ADDIU S2, A1, 4096
9D02C4DC  00A08021   ADDU S0, A1, ZERO
9D02C4E0  00858823   SUBU S1, A0, A1
9D02C4E4  02112021   ADDU A0, S0, S1
284:                 uint16_t i;
285:                 for (i=0;i<4096;i++) 
9D02C508  1612FFF7   BNE S0, S2, 0x9D02C4E8
9D02C50C  02112021   ADDU A0, S0, S1
286:                 	{
287:                 	fl_write(addr+i,*data++);
9D02C4E8  26100001   ADDIU S0, S0, 1
9D02C4EC  0F40B0FD   JAL fl_write
9D02C4F0  9205FFFF   LBU A1, -1(S0)
288:                 	while ((fl_rdsr())&0x01);
9D02C4F4  0F40B04B   JAL fl_rdsr
9D02C4F8  00000000   NOP
9D02C4FC  30420001   ANDI V0, V0, 1
9D02C500  1440FFFC   BNE V0, ZERO, .LVL62
9D02C504  00000000   NOP
289:                 	}
290:                 }
9D02C510  8FBF001C   LW RA, 28(SP)
9D02C514  8FB20018   LW S2, 24(SP)
9D02C518  8FB10014   LW S1, 20(SP)
9D02C51C  8FB00010   LW S0, 16(SP)
9D02C520  03E00008   JR RA
9D02C524  27BD0020   ADDIU SP, SP, 32
291:                 
292:                 void fl_write_128(uint32_t sector,uint8_t * data)
293:                 {
9D02C528  27BDFFE0   ADDIU SP, SP, -32
9D02C52C  AFBF001C   SW RA, 28(SP)
9D02C530  AFB20018   SW S2, 24(SP)
9D02C534  AFB10014   SW S1, 20(SP)
9D02C538  AFB00010   SW S0, 16(SP)
294:                 uint32_t  addr;
295:                 uint8_t i;
296:                 addr = ((uint32_t )(sector))*128UL;
9D02C53C  000491C0   SLL S2, A0, 7
297:                 addr = addr&0xFFFFF000;
9D02C540  2402F000   ADDIU V0, ZERO, -4096
9D02C544  02428824   AND S1, S2, V0
298:                 #ifdef	FLASH_BUFFERING	
299:                 if (last_addr!=addr)
9D02C548  8F848044   LW A0, -32700(GP)
9D02C54C  10910017   BEQ A0, S1, 0x9D02C5AC
9D02C550  00A08021   ADDU S0, A1, ZERO
300:                 	{
301:                 	if (last_addr!=0xFFFFF000)
9D02C554  50820008   BEQL A0, V0, 0x9D02C578
9D02C558  02202021   ADDU A0, S1, ZERO
302:                 		{
303:                 		fl_erase_4k(last_addr);
9D02C55C  0F40B0DE   JAL fl_erase_4k
9D02C560  00000000   NOP
304:                 		fl_write_4k(last_addr,flash_buff);
9D02C564  8F848044   LW A0, -32700(GP)
9D02C568  3C05A000   LUI A1, -24576
9D02C56C  0F40B131   JAL fl_write_4k
9D02C570  24A50980   ADDIU A1, A1, 2432
305:                 		}
306:                 	fl_read_4k(addr,flash_buff);
9D02C574  02202021   ADDU A0, S1, ZERO
9D02C578  3C05A000   LUI A1, -24576
9D02C57C  0F40B082   JAL fl_read_4k
9D02C580  24A50980   ADDIU A1, A1, 2432
307:                 	last_addr = addr;
9D02C584  0B40B16B   J 0x9D02C5AC
9D02C588  AF918044   SW S1, -32700(GP)
9D02C58C  02021821   ADDU V1, S0, V0
308:                 	}
309:                 unwritten = 1;
9D02C5AC  24020001   ADDIU V0, ZERO, 1
9D02C5B0  A38281A5   SB V0, -32347(GP)
310:                 #endif
311:                 #ifndef	FLASH_BUFFERING	
312:                 fl_read_4k(addr,flash_buff);
313:                 #endif
314:                 addr = ((uint32_t )(sector))*128UL;
315:                 addr = addr&0x00000FFF;
9D02C5B4  32520FFF   ANDI S2, S2, 4095
9D02C5B8  00001021   ADDU V0, ZERO, ZERO
9D02C5BC  3C06A000   LUI A2, -24576
9D02C5C0  24C60980   ADDIU A2, A2, 2432
9D02C5C4  00D23021   ADDU A2, A2, S2
316:                 for (i=0;i<128;i++) flash_buff[addr+i] = data[i];
9D02C590  90640000   LBU A0, 0(V1)
9D02C594  00C21821   ADDU V1, A2, V0
9D02C598  24420001   ADDIU V0, V0, 1
9D02C59C  1445FFFB   BNE V0, A1, 0x9D02C58C
9D02C5A0  A0640000   SB A0, 0(V1)
9D02C5A4  0B40B174   J 0x9D02C5D0
9D02C5A8  8FBF001C   LW RA, 28(SP)
9D02C5C8  0B40B163   J 0x9D02C58C
9D02C5CC  24050080   ADDIU A1, ZERO, 128
317:                 addr = ((uint32_t )(sector))*128UL;
318:                 addr = addr&0xFFFFF000;
319:                 #ifndef	FLASH_BUFFERING	
320:                 fl_erase_4k(addr);
321:                 fl_write_4k(addr,flash_buff);
322:                 #endif
323:                 }
9D02C5D0  8FB20018   LW S2, 24(SP)
9D02C5D4  8FB10014   LW S1, 20(SP)
9D02C5D8  8FB00010   LW S0, 16(SP)
9D02C5DC  03E00008   JR RA
9D02C5E0  27BD0020   ADDIU SP, SP, 32
324:                 
325:                 void fl_read_128(uint32_t sector,uint8_t * data)
326:                 {
9D02C5E4  27BDFFE0   ADDIU SP, SP, -32
9D02C5E8  AFBF001C   SW RA, 28(SP)
9D02C5EC  AFB10018   SW S1, 24(SP)
9D02C5F0  AFB00014   SW S0, 20(SP)
9D02C5F4  00808821   ADDU S1, A0, ZERO
327:                 uint32_t  addr;
328:                 #ifdef	FLASH_BUFFERING	
329:                 if (unwritten == 1)
9D02C5F8  938381A5   LBU V1, -32347(GP)
9D02C5FC  24020001   ADDIU V0, ZERO, 1
9D02C600  1462000A   BNE V1, V0, 0x9D02C62C
9D02C604  00A08021   ADDU S0, A1, ZERO
330:                 	{
331:                 	fl_erase_4k(last_addr);
9D02C608  0F40B0DE   JAL fl_erase_4k
9D02C60C  8F848044   LW A0, -32700(GP)
332:                 	fl_write_4k(last_addr,flash_buff);
9D02C610  8F848044   LW A0, -32700(GP)
9D02C614  3C05A000   LUI A1, -24576
9D02C618  0F40B131   JAL fl_write_4k
9D02C61C  24A50980   ADDIU A1, A1, 2432
333:                 	unwritten = 0;	
9D02C620  A38081A5   SB ZERO, -32347(GP)
334:                 	last_addr = 0xFFFFF000;
9D02C624  2402F000   ADDIU V0, ZERO, -4096
9D02C628  AF828044   SW V0, -32700(GP)
335:                 	}
336:                 #endif
337:                 addr = ((uint32_t )(sector))*128UL;
338:                 fl_read_nk(addr,data,128);
9D02C62C  001121C0   SLL A0, S1, 7
9D02C630  02002821   ADDU A1, S0, ZERO
9D02C634  0F40B0A4   JAL fl_read_nk
9D02C638  24060080   ADDIU A2, ZERO, 128
339:                 }
9D02C63C  8FBF001C   LW RA, 28(SP)
9D02C640  8FB10018   LW S1, 24(SP)
9D02C644  8FB00014   LW S0, 20(SP)
9D02C648  03E00008   JR RA
9D02C64C  27BD0020   ADDIU SP, SP, 32
340:                 
341:                 uint8_t init_first_x_sects (uint8_t i, uint8_t verify)			//format directory area
342:                 {
9D02C650  27BDFFD0   ADDIU SP, SP, -48
9D02C654  AFBF002C   SW RA, 44(SP)
9D02C658  AFB60028   SW S6, 40(SP)
9D02C65C  AFB50024   SW S5, 36(SP)
9D02C660  AFB40020   SW S4, 32(SP)
9D02C664  AFB3001C   SW S3, 28(SP)
9D02C668  AFB20018   SW S2, 24(SP)
9D02C66C  AFB10014   SW S1, 20(SP)
9D02C670  AFB00010   SW S0, 16(SP)
9D02C674  0080A021   ADDU S4, A0, ZERO
9D02C678  00A0A821   ADDU S5, A1, ZERO
9D02C67C  3C02A000   LUI V0, -24576
9D02C680  244208E0   ADDIU V0, V0, 2272
9D02C684  24500080   ADDIU S0, V0, 128
343:                 uint32_t j,k;
344:                 for (j=0;j<128;j++) disk_temp[j]=0xE5;
9D02C688  2403FFE5   ADDIU V1, ZERO, -27
9D02C68C  A0430000   SB V1, 0(V0)
9D02C690  24420001   ADDIU V0, V0, 1
9D02C694  5450FFFE   BNEL V0, S0, 0x9D02C690
9D02C698  A0430000   SB V1, 0(V0)
345:                 #ifdef USE_EEPROM
346:                 for (j=0;j<i;j++) 
347:                 	{
348:                 	ee_wren();
349:                 	write_sector(disk_temp,j);
350:                 	}
351:                 #endif
352:                 for (j=0;j<i;j++) 
9D02C69C  12800023   BEQ S4, ZERO, 0x9D02C72C
9D02C6A0  26931000   ADDIU S3, S4, 4096
9D02C6A4  24111000   ADDIU S1, ZERO, 4096
9D02C6C0  1633FFFC   BNE S1, S3, 0x9D02C6B4
9D02C6C4  02202021   ADDU A0, S1, ZERO
9D02C6C8  0B40B1CF   J 0x9D02C73C
9D02C6CC  00000000   NOP
353:                 	{
354:                 	fl_write_128(j+(1*4096),disk_temp);
9D02C6A8  3C12A000   LUI S2, -24576
9D02C6AC  265208E0   ADDIU S2, S2, 2272
9D02C6B0  02202021   ADDU A0, S1, ZERO
9D02C6B4  0F40B14A   JAL fl_write_128
9D02C6B8  02402821   ADDU A1, S2, ZERO
9D02C6BC  26310001   ADDIU S1, S1, 1
355:                 	}
356:                 
357:                 if (verify!=0)
9D02C6D0  24131000   ADDIU S3, ZERO, 4096
9D02C73C  16A0FFE4   BNE S5, ZERO, 0x9D02C6D0
9D02C740  26961000   ADDIU S6, S4, 4096
358:                 	{
359:                 	for (j=0;j<i;j++) 
9D02C71C  1676FFF2   BNE S3, S6, 0x9D02C6E8
9D02C720  02602021   ADDU A0, S3, ZERO
9D02C724  0B40B1CD   J 0x9D02C734
9D02C728  00001021   ADDU V0, ZERO, ZERO
360:                 		{
361:                 		fl_read_128(j+(1*4096),disk_temp);
9D02C6D4  3C12A000   LUI S2, -24576
9D02C6D8  265508E0   ADDIU S5, S2, 2272
9D02C6E4  02602021   ADDU A0, S3, ZERO
9D02C6E8  0F40B179   JAL fl_read_128
9D02C6EC  02A02821   ADDU A1, S5, ZERO
362:                 		for (k=0;k<128;k++) 
9D02C710  5602FFFC   BNEL S0, V0, 0x9D02C704
9D02C714  90430000   LBU V1, 0(V0)
9D02C718  26730001   ADDIU S3, S3, 1
363:                 			{
364:                 			if (disk_temp[k]!=0xE5)
9D02C6DC  241100E5   ADDIU S1, ZERO, 229
9D02C6E0  3C14A000   LUI S4, -24576
9D02C6F0  924208E0   LBU V0, 2272(S2)
9D02C6F4  14510014   BNE V0, S1, 0x9D02C748
9D02C6F8  24020001   ADDIU V0, ZERO, 1
9D02C6FC  268208E1   ADDIU V0, S4, 2273
9D02C700  90430000   LBU V1, 0(V0)
9D02C704  54710010   BNEL V1, S1, 0x9D02C748
9D02C708  24020001   ADDIU V0, ZERO, 1
9D02C70C  24420001   ADDIU V0, V0, 1
365:                 				{
366:                 				return 1;
367:                 				}
368:                 			}
369:                 		}
370:                 	}
371:                 return 0;
9D02C72C  0B40B1D2   J 0x9D02C748
9D02C730  00001021   ADDU V0, ZERO, ZERO
9D02C744  00001021   ADDU V0, ZERO, ZERO
372:                 }
9D02C734  0B40B1D3   J 0x9D02C74C
9D02C738  8FBF002C   LW RA, 44(SP)
9D02C748  8FBF002C   LW RA, 44(SP)
9D02C74C  8FB60028   LW S6, 40(SP)
9D02C750  8FB50024   LW S5, 36(SP)
9D02C754  8FB40020   LW S4, 32(SP)
9D02C758  8FB3001C   LW S3, 28(SP)
9D02C75C  8FB20018   LW S2, 24(SP)
9D02C760  8FB10014   LW S1, 20(SP)
9D02C764  8FB00010   LW S0, 16(SP)
9D02C768  03E00008   JR RA
9D02C76C  27BD0030   ADDIU SP, SP, 48
373:                 
374:                 
375:                 
376:                 #ifdef USE_EEPROM
377:                 void write_sector (unsigned char *data, unsigned int addr)
378:                 {
379:                 unsigned char i,temp;
380:                 CS_MEM = 0;
381:                 SPI_dat(0x02);
382:                 temp = (addr>>9);
383:                 SPI_dat(temp);
384:                 temp = (addr>>1);
385:                 SPI_dat(temp);
386:                 temp = (addr<<7);
387:                 SPI_dat(temp);
388:                 
389:                 for (i=0;i<128;i++) 
390:                 	SPI_dat(data[i]);
391:                 
392:                 CS_MEM = 1;
393:                 temp = ee_rs();
394:                 temp = temp&0x01;
395:                 
396:                 while (temp>0)
397:                 	{
398:                 	temp = ee_rs();
399:                 	temp = temp&0x01;
400:                 	}
401:                 }
402:                 
403:                 void read_sector (unsigned char *data, unsigned int addr)
404:                 {
405:                 unsigned char i,temp;
406:                 CS_MEM = 0;
407:                 SPI_dat(0x03);
408:                 temp = (addr>>9);
409:                 SPI_dat(temp);
410:                 temp = (addr>>1);
411:                 SPI_dat(temp);
412:                 temp = (addr<<7);
413:                 SPI_dat(temp);
414:                 
415:                 
416:                 for (i=0;i<128;i++) 
417:                 	{
418:                 	*data = SPI_dat(0xFF);
419:                 	*data++;
420:                 	}
421:                 
422:                 CS_MEM = 1;
423:                 }
424:                 unsigned char ee_rs (void)
425:                 {
426:                 unsigned char temp;
427:                 CS_MEM = 0;
428:                 SPI_dat(0x05);
429:                 temp = SPI_dat(0xFF);
430:                 CS_MEM = 1;
431:                 return temp;
432:                 }
433:                 
434:                 void ee_wren (void)
435:                 {
436:                 CS_MEM = 0;
437:                 SPI_dat(0x06);
438:                 CS_MEM = 1;
439:                 }
440:                 
441:                 void ee_wrdi (void)
442:                 {
443:                 CS_MEM = 0;
444:                 SPI_dat(0x04);
445:                 CS_MEM = 1;
446:                 }
447:                 
448:                 #endif
---  /Users/bamboo/Applications/Bamboo-agent/build/bamboo-agent1/xml-data/build-dir/XC32-TBC-TY/builddir/pic32m-source/src48x/gcc/libgcc/libgcc2.c
9D03BB08  10C00009   BEQ A2, ZERO, 0x9D03BB30
9D03BB0C  00801021   ADDU V0, A0, ZERO
9D03BB10  24020020   ADDIU V0, ZERO, 32
9D03BB14  00461023   SUBU V0, V0, A2
9D03BB18  18400007   BLEZ V0, 0x9D03BB38
9D03BB1C  00C42006   SRLV A0, A0, A2
9D03BB3C  00001821   ADDU V1, ZERO, ZERO
9D03BB38  00021023   SUBU V0, ZERO, V0
9D03BB20  00451004   SLLV V0, A1, V0
9D03BB24  00C51806   SRLV V1, A1, A2
9D03BB28  03E00008   JR RA
9D03BB2C  00441025   OR V0, V0, A0
9D03BB30  03E00008   JR RA
9D03BB34  00A01821   ADDU V1, A1, ZERO
9D03BB38  00021023   SUBU V0, ZERO, V0
9D03BB3C  00001821   ADDU V1, ZERO, ZERO
9D03BB40  03E00008   JR RA
9D03BB44  00451006   SRLV V0, A1, V0
9D03BB48  10C00009   BEQ A2, ZERO, 0x9D03BB70
9D03BB4C  00801021   ADDU V0, A0, ZERO
9D03BB50  24030020   ADDIU V1, ZERO, 32
9D03BB54  00661823   SUBU V1, V1, A2
9D03BB58  18600007   BLEZ V1, 0x9D03BB78
9D03BB5C  00C52804   SLLV A1, A1, A2
9D03BB7C  00001021   ADDU V0, ZERO, ZERO
9D03BB78  00031823   SUBU V1, ZERO, V1
9D03BB60  00641806   SRLV V1, A0, V1
9D03BB64  00C41004   SLLV V0, A0, A2
9D03BB68  03E00008   JR RA
9D03BB6C  00651825   OR V1, V1, A1
9D03BB70  03E00008   JR RA
9D03BB74  00A01821   ADDU V1, A1, ZERO
9D03BB78  00031823   SUBU V1, ZERO, V1
9D03BB7C  00001021   ADDU V0, ZERO, ZERO
9D03BB80  03E00008   JR RA
9D03BB84  00641804   SLLV V1, A0, V1
9D02DDD4  00C04021   ADDU T0, A2, ZERO
9D02E6F0  00C04021   ADDU T0, A2, ZERO
9D02EB54  00C04021   ADDU T0, A2, ZERO
9D02DDD8  00805021   ADDU T2, A0, ZERO
9D02E6F4  00804821   ADDU T1, A0, ZERO
9D02EB58  00801021   ADDU V0, A0, ZERO
9D02DDDC  14E00046   BNE A3, ZERO, 0x9D02DEF8
9D02DDE0  00A01821   ADDU V1, A1, ZERO
9D02E6F8  14E0003B   BNE A3, ZERO, 0x9D02E7E8
9D02E6FC  00A01821   ADDU V1, A1, ZERO
9D02EB5C  14E0003F   BNE A3, ZERO, 0x9D02EC5C
9D02EB60  00A04821   ADDU T1, A1, ZERO
9D02DDE4  00A6102B   SLTU V0, A1, A2
9D02DDE8  1040005D   BEQ V0, ZERO, 0x9D02DF60
9D02DDEC  70C21020   CLZ V0, A2
9D02E700  00A6102B   SLTU V0, A1, A2
9D02E704  10400048   BEQ V0, ZERO, 0x9D02E828
9D02E708  70C21020   CLZ V0, A2
9D02EB64  00A6182B   SLTU V1, A1, A2
9D02EB68  10600047   BEQ V1, ZERO, 0x9D02EC88
9D02EB6C  70C31820   CLZ V1, A2
9D02DDF0  50400008   BEQL V0, ZERO, 0x9D02DE14
9D02DDF4  00082C02   SRL A1, T0, 16
9D02E70C  50400008   BEQL V0, ZERO, 0x9D02E730
9D02E710  00083402   SRL A2, T0, 16
9D02EB70  50600008   BEQL V1, ZERO, 0x9D02EB94
9D02EB74  00081C02   SRL V1, T0, 16
9D02DE04  00464004   SLLV T0, A2, V0
9D02E720  00464004   SLLV T0, A2, V0
9D02EB84  00664004   SLLV T0, A2, V1
9D02DDF8  00022023   SUBU A0, ZERO, V0
9D02DDFC  008A2006   SRLV A0, T2, A0
9D02DE00  00451804   SLLV V1, A1, V0
9D02DE08  00831825   OR V1, A0, V1
9D02E714  00021823   SUBU V1, ZERO, V0
9D02E718  00452804   SLLV A1, A1, V0
9D02E71C  00641806   SRLV V1, A0, V1
9D02E724  00651825   OR V1, V1, A1
9D02EB78  00034823   SUBU T1, ZERO, V1
9D02EB7C  00652804   SLLV A1, A1, V1
9D02EB80  01244806   SRLV T1, A0, T1
9D02EB88  01254825   OR T1, T1, A1
9D02DE0C  004A5004   SLLV T2, T2, V0
9D02E728  00444804   SLLV T1, A0, V0
9D02EB8C  00641004   SLLV V0, A0, V1
9D02DE10  00082C02   SRL A1, T0, 16
9D02DE14  0065001B   DIVU V1, A1
9D02DE18  00A001F4   TEQ A1, ZERO
9D02DE1C  00006010   MFHI T4
9D02DE20  00005812   MFLO T3
9D02DE24  3107FFFF   ANDI A3, T0, -1
9D02DE28  000A2402   SRL A0, T2, 16
9D02DE2C  00001012   MFLO V0
9D02DE30  71673002   MUL A2, T3, A3
9D02DE34  000C6400   SLL T4, T4, 16
9D02DE38  01842025   OR A0, T4, A0
9D02DE3C  0086602B   SLTU T4, A0, A2
9D02DE40  0065001B   DIVU V1, A1
9D02DE44  00A001F4   TEQ A1, ZERO
9D02DE48  1180000B   BEQ T4, ZERO, 0x9D02DE78
9D02DE4C  00861823   SUBU V1, A0, A2
9D02DE50  00882021   ADDU A0, A0, T0
9D02DE54  0088182B   SLTU V1, A0, T0
9D02DE58  14600006   BNE V1, ZERO, 0x9D02DE74
9D02DE5C  2562FFFF   ADDIU V0, T3, -1
9D02DE60  0086182B   SLTU V1, A0, A2
9D02DE64  10600004   BEQ V1, ZERO, 0x9D02DE78
9D02DE68  00861823   SUBU V1, A0, A2
9D02DE6C  2562FFFE   ADDIU V0, T3, -2
9D02DE70  00882021   ADDU A0, A0, T0
9D02DE74  00861823   SUBU V1, A0, A2
9D02DE78  314AFFFF   ANDI T2, T2, -1
9D02DE7C  0065001B   DIVU V1, A1
9D02DE80  00A001F4   TEQ A1, ZERO
9D02DE84  00005810   MFHI T3
9D02DE88  00003012   MFLO A2
9D02DE8C  00002012   MFLO A0
9D02DE90  70C73802   MUL A3, A2, A3
9D02DE94  000B5C00   SLL T3, T3, 16
9D02DE98  016A5025   OR T2, T3, T2
9D02DE9C  0147582B   SLTU T3, T2, A3
9D02DEA0  0065001B   DIVU V1, A1
9D02DEA4  00A001F4   TEQ A1, ZERO
9D02DEA8  51600009   BEQL T3, ZERO, 0x9D02DED0
9D02DEAC  00021400   SLL V0, V0, 16
9D02DEB0  01485021   ADDU T2, T2, T0
9D02DEB4  0148402B   SLTU T0, T2, T0
9D02DEB8  15000004   BNE T0, ZERO, 0x9D02DECC
9D02DEBC  24C4FFFF   ADDIU A0, A2, -1
9D02DEC0  0147382B   SLTU A3, T2, A3
9D02DEC4  24C6FFFE   ADDIU A2, A2, -2
9D02DEC8  00C7200B   MOVN A0, A2, A3
9D02DECC  00021400   SLL V0, V0, 16
9D02DED0  00821025   OR V0, A0, V0
9D02DED4  00001821   ADDU V1, ZERO, ZERO
9D02E72C  00083402   SRL A2, T0, 16
9D02E730  0066001B   DIVU V1, A2
9D02E734  00C001F4   TEQ A2, ZERO
9D02E738  00002010   MFHI A0
9D02E73C  00005812   MFLO T3
9D02E740  310CFFFF   ANDI T4, T0, -1
9D02E744  00095402   SRL T2, T1, 16
9D02E748  716C5802   MUL T3, T3, T4
9D02E74C  00042400   SLL A0, A0, 16
9D02E750  008A5025   OR T2, A0, T2
9D02E754  014B682B   SLTU T5, T2, T3
9D02E758  0066001B   DIVU V1, A2
9D02E75C  00C001F4   TEQ A2, ZERO
9D02E760  51A00009   BEQL T5, ZERO, 0x9D02E788
9D02E764  014B5023   SUBU T2, T2, T3
9D02E768  01485021   ADDU T2, T2, T0
9D02E76C  0148182B   SLTU V1, T2, T0
9D02E770  54600005   BNEL V1, ZERO, 0x9D02E788
9D02E774  014B5023   SUBU T2, T2, T3
9D02E778  014B202B   SLTU A0, T2, T3
9D02E77C  01481821   ADDU V1, T2, T0
9D02E780  0064500B   MOVN T2, V1, A0
9D02E784  014B5023   SUBU T2, T2, T3
9D02E788  3123FFFF   ANDI V1, T1, -1
9D02E78C  0146001B   DIVU T2, A2
9D02E790  00C001F4   TEQ A2, ZERO
9D02E794  00004810   MFHI T1
9D02E798  00002012   MFLO A0
9D02E79C  708C2002   MUL A0, A0, T4
9D02E7A0  00094C00   SLL T1, T1, 16
9D02E7A4  01234825   OR T1, T1, V1
9D02E7A8  0124182B   SLTU V1, T1, A0
9D02E7AC  0146001B   DIVU T2, A2
9D02E7B0  00C001F4   TEQ A2, ZERO
9D02E7B4  50600009   BEQL V1, ZERO, .LBE15
9D02E7B8  01244823   SUBU T1, T1, A0
9D02E7BC  01284821   ADDU T1, T1, T0
9D02E7C0  0128182B   SLTU V1, T1, T0
9D02E7C4  54600005   BNEL V1, ZERO, .LBE15
9D02E7C8  01244823   SUBU T1, T1, A0
9D02E7CC  0124182B   SLTU V1, T1, A0
9D02E7D0  01284021   ADDU T0, T1, T0
9D02E7D4  0103480B   MOVN T1, T0, V1
9D02E7D8  01244823   SUBU T1, T1, A0
9D02EB90  00081C02   SRL V1, T0, 16
9D02EB94  0123001B   DIVU T1, V1
9D02EB98  006001F4   TEQ V1, ZERO
9D02EB9C  00006010   MFHI T4
9D02EBA0  00005812   MFLO T3
9D02EBA4  310AFFFF   ANDI T2, T0, -1
9D02EBA8  00022402   SRL A0, V0, 16
9D02EBAC  00003012   MFLO A2
9D02EBB0  716A3802   MUL A3, T3, T2
9D02EBB4  000C6400   SLL T4, T4, 16
9D02EBB8  01842025   OR A0, T4, A0
9D02EBBC  0087602B   SLTU T4, A0, A3
9D02EBC0  0123001B   DIVU T1, V1
9D02EBC4  006001F4   TEQ V1, ZERO
9D02EBC8  1180000B   BEQ T4, ZERO, 0x9D02EBF8
9D02EBCC  00872823   SUBU A1, A0, A3
9D02EBD0  00882021   ADDU A0, A0, T0
9D02EBD4  0088282B   SLTU A1, A0, T0
9D02EBD8  14A00006   BNE A1, ZERO, 0x9D02EBF4
9D02EBDC  2566FFFF   ADDIU A2, T3, -1
9D02EBE0  0087282B   SLTU A1, A0, A3
9D02EBE4  10A00004   BEQ A1, ZERO, 0x9D02EBF8
9D02EBE8  00872823   SUBU A1, A0, A3
9D02EBEC  2566FFFE   ADDIU A2, T3, -2
9D02EBF0  00882021   ADDU A0, A0, T0
9D02EBF4  00872823   SUBU A1, A0, A3
9D02EBF8  3042FFFF   ANDI V0, V0, -1
9D02EBFC  00A3001B   DIVU A1, V1
9D02EC00  006001F4   TEQ V1, ZERO
9D02EC04  00004810   MFHI T1
9D02EC08  00003812   MFLO A3
9D02EC0C  00002012   MFLO A0
9D02EC10  70EA5002   MUL T2, A3, T2
9D02EC14  00094C00   SLL T1, T1, 16
9D02EC18  01221025   OR V0, T1, V0
9D02EC1C  004A482B   SLTU T1, V0, T2
9D02EC20  00A3001B   DIVU A1, V1
9D02EC24  006001F4   TEQ V1, ZERO
9D02EC28  51200009   BEQL T1, ZERO, 0x9D02EC50
9D02EC2C  00061400   SLL V0, A2, 16
9D02EC30  00481021   ADDU V0, V0, T0
9D02EC34  0048402B   SLTU T0, V0, T0
9D02EC38  15000004   BNE T0, ZERO, 0x9D02EC4C
9D02EC3C  24E4FFFF   ADDIU A0, A3, -1
9D02EC40  004A502B   SLTU T2, V0, T2
9D02EC44  24E7FFFE   ADDIU A3, A3, -2
9D02EC48  00EA200B   MOVN A0, A3, T2
9D02EC4C  00061400   SLL V0, A2, 16
9D02EC50  00821025   OR V0, A0, V0
9D02EC54  03E00008   JR RA
9D02EC58  00001821   ADDU V1, ZERO, ZERO
9D02DF60  14C00006   BNE A2, ZERO, 0x9D02DF7C
9D02DF64  71021020   CLZ V0, T0
9D02E828  14C00006   BNE A2, ZERO, 0x9D02E844
9D02E82C  71021020   CLZ V0, T0
9D02EC88  14C00006   BNE A2, ZERO, 0x9D02ECA4
9D02EC8C  71031820   CLZ V1, T0
9D02DF68  24080001   ADDIU T0, ZERO, 1
9D02DF6C  0107001B   DIVU T0, A3
9D02DF70  00E001F4   TEQ A3, ZERO
9D02DF74  00004012   MFLO T0
9D02E830  24020001   ADDIU V0, ZERO, 1
9D02E834  0046001B   DIVU V0, A2
9D02E838  00C001F4   TEQ A2, ZERO
9D02E83C  00004012   MFLO T0
9D02EC90  24030001   ADDIU V1, ZERO, 1
9D02EC94  0066001B   DIVU V1, A2
9D02EC98  00C001F4   TEQ A2, ZERO
9D02EC9C  00004012   MFLO T0
9D02DF78  71021020   CLZ V0, T0
9D02E840  71021020   CLZ V0, T0
9D02ECA0  71031820   CLZ V1, T0
9D02DF7C  54400033   BNEL V0, ZERO, 0x9D02E04C
9D02DF80  00484004   SLLV T0, T0, V0
9D02E844  5440007D   BNEL V0, ZERO, 0x9D02EA3C
9D02E848  00484004   SLLV T0, T0, V0
9D02ECA4  5460007B   BNEL V1, ZERO, 0x9D02EE94
9D02ECA8  00684004   SLLV T0, T0, V1
9D02DF84  00A82023   SUBU A0, A1, T0
9D02DF88  00083C02   SRL A3, T0, 16
9D02DF8C  310CFFFF   ANDI T4, T0, -1
9D02DF90  24030001   ADDIU V1, ZERO, 1
9D02E84C  00A82823   SUBU A1, A1, T0
9D02E850  00081C02   SRL V1, T0, 16
9D02E854  3107FFFF   ANDI A3, T0, -1
9D02ECAC  00A82023   SUBU A0, A1, T0
9D02ECB0  00083C02   SRL A3, T0, 16
9D02ECB4  310BFFFF   ANDI T3, T0, -1
9D02ECB8  24030001   ADDIU V1, ZERO, 1
9D02E04C  24030020   ADDIU V1, ZERO, 32
9D02E050  00621823   SUBU V1, V1, V0
9D02EA3C  24090020   ADDIU T1, ZERO, 32
9D02EA40  01224823   SUBU T1, T1, V0
9D02EE94  24020020   ADDIU V0, ZERO, 32
9D02EE98  00431023   SUBU V0, V0, V1
9D02E054  00653006   SRLV A2, A1, V1
9D02EA44  01255006   SRLV T2, A1, T1
9D02EE9C  00454806   SRLV T1, A1, V0
9D02E070  00452804   SLLV A1, A1, V0
9D02E074  00641806   SRLV V1, A0, V1
9D02E078  00652825   OR A1, V1, A1
9D02EA60  00452804   SLLV A1, A1, V0
9D02EA64  01244806   SRLV T1, A0, T1
9D02EA68  01252825   OR A1, T1, A1
9D02EEB8  00652804   SLLV A1, A1, V1
9D02EEBC  00441006   SRLV V0, A0, V0
9D02EEC0  00452825   OR A1, V0, A1
9D02E080  00445004   SLLV T2, A0, V0
9D02EA70  00444804   SLLV T1, A0, V0
9D02EEC8  00641004   SLLV V0, A0, V1
9D02E058  00083C02   SRL A3, T0, 16
9D02E05C  00C7001B   DIVU A2, A3
9D02E060  00E001F4   TEQ A3, ZERO
9D02E064  00007810   MFHI T7
9D02E068  00006812   MFLO T5
9D02E06C  310CFFFF   ANDI T4, T0, -1
9D02E07C  00057402   SRL T6, A1, 16
9D02E084  00001812   MFLO V1
9D02E088  71AC5802   MUL T3, T5, T4
9D02E08C  000F1400   SLL V0, T7, 16
9D02E090  01C21025   OR V0, T6, V0
9D02E094  004B202B   SLTU A0, V0, T3
9D02E098  00C7001B   DIVU A2, A3
9D02E09C  00E001F4   TEQ A3, ZERO
9D02E0A0  5080000B   BEQL A0, ZERO, 0x9D02E0D0
9D02E0A4  004B1023   SUBU V0, V0, T3
9D02E0A8  00481021   ADDU V0, V0, T0
9D02E0AC  0048202B   SLTU A0, V0, T0
9D02E0B0  14800006   BNE A0, ZERO, 0x9D02E0CC
9D02E0B4  25A3FFFF   ADDIU V1, T5, -1
9D02E0B8  004B202B   SLTU A0, V0, T3
9D02E0BC  50800004   BEQL A0, ZERO, 0x9D02E0D0
9D02E0C0  004B1023   SUBU V0, V0, T3
9D02E0C4  25A3FFFE   ADDIU V1, T5, -2
9D02E0C8  00481021   ADDU V0, V0, T0
9D02E0CC  004B1023   SUBU V0, V0, T3
9D02E0D0  30ADFFFF   ANDI T5, A1, -1
9D02E0D4  0047001B   DIVU V0, A3
9D02E0D8  00E001F4   TEQ A3, ZERO
9D02E0DC  00002010   MFHI A0
9D02E0E0  00005812   MFLO T3
9D02E0E4  00003012   MFLO A2
9D02E0E8  716C2802   MUL A1, T3, T4
9D02E0EC  00042400   SLL A0, A0, 16
9D02E0F0  008D2025   OR A0, A0, T5
9D02E0F4  0085682B   SLTU T5, A0, A1
9D02E0F8  0047001B   DIVU V0, A3
9D02E0FC  00E001F4   TEQ A3, ZERO
9D02E100  51A0000B   BEQL T5, ZERO, 0x9D02E130
9D02E104  00031C00   SLL V1, V1, 16
9D02E108  00882021   ADDU A0, A0, T0
9D02E10C  0088102B   SLTU V0, A0, T0
9D02E110  14400006   BNE V0, ZERO, 0x9D02E12C
9D02E114  2566FFFF   ADDIU A2, T3, -1
9D02E118  0085102B   SLTU V0, A0, A1
9D02E11C  50400004   BEQL V0, ZERO, 0x9D02E130
9D02E120  00031C00   SLL V1, V1, 16
9D02E124  2566FFFE   ADDIU A2, T3, -2
9D02E128  00882021   ADDU A0, A0, T0
9D02E12C  00031C00   SLL V1, V1, 16
9D02E130  00852023   SUBU A0, A0, A1
9D02E134  0B40B7E5   J .LBB16
9D02E138  00C31825   OR V1, A2, V1
9D02EA48  00081C02   SRL V1, T0, 16
9D02EA4C  0143001B   DIVU T2, V1
9D02EA50  006001F4   TEQ V1, ZERO
9D02EA54  00003010   MFHI A2
9D02EA58  00005812   MFLO T3
9D02EA5C  3107FFFF   ANDI A3, T0, -1
9D02EA6C  00056402   SRL T4, A1, 16
9D02EA74  71675802   MUL T3, T3, A3
9D02EA78  00063400   SLL A2, A2, 16
9D02EA7C  01863025   OR A2, T4, A2
9D02EA80  00CB202B   SLTU A0, A2, T3
9D02EA84  0143001B   DIVU T2, V1
9D02EA88  006001F4   TEQ V1, ZERO
9D02EA8C  50800006   BEQL A0, ZERO, 0x9D02EAA8
9D02EA90  00CB3023   SUBU A2, A2, T3
9D02EA94  00C83021   ADDU A2, A2, T0
9D02EA98  00C8202B   SLTU A0, A2, T0
9D02EA9C  10800024   BEQ A0, ZERO, 0x9D02EB30
9D02EAA0  00CB502B   SLTU T2, A2, T3
9D02EAA4  00CB3023   SUBU A2, A2, T3
9D02EAA8  30AAFFFF   ANDI T2, A1, -1
9D02EAAC  00C3001B   DIVU A2, V1
9D02EAB0  006001F4   TEQ V1, ZERO
9D02EAB4  00002010   MFHI A0
9D02EAB8  00002812   MFLO A1
9D02EABC  70A72802   MUL A1, A1, A3
9D02EAC0  00042400   SLL A0, A0, 16
9D02EAC4  008A2025   OR A0, A0, T2
9D02EAC8  0085502B   SLTU T2, A0, A1
9D02EACC  00C3001B   DIVU A2, V1
9D02EAD0  006001F4   TEQ V1, ZERO
9D02EAD4  5140FF60   BEQL T2, ZERO, .LBB17
9D02EAD8  00852823   SUBU A1, A0, A1
9D02EADC  00882021   ADDU A0, A0, T0
9D02EAE0  0088302B   SLTU A2, A0, T0
9D02EAE4  54C0FF5C   BNEL A2, ZERO, .LBB17
9D02EAE8  00852823   SUBU A1, A0, A1
9D02EAEC  0085502B   SLTU T2, A0, A1
9D02EAF0  00883021   ADDU A2, A0, T0
9D02EAF4  00CA200B   MOVN A0, A2, T2
9D02EAF8  0B40BA16   J .LBB17
9D02EAFC  00852823   SUBU A1, A0, A1
9D02EB30  00C82021   ADDU A0, A2, T0
9D02EB34  0B40BAA9   J 0x9D02EAA4
9D02EB38  008A300B   MOVN A2, A0, T2
9D02EEA0  00083C02   SRL A3, T0, 16
9D02EEA4  0127001B   DIVU T1, A3
9D02EEA8  00E001F4   TEQ A3, ZERO
9D02EEAC  00003010   MFHI A2
9D02EEB0  00006012   MFLO T4
9D02EEB4  310BFFFF   ANDI T3, T0, -1
9D02EEC4  00056C02   SRL T5, A1, 16
9D02EECC  00001812   MFLO V1
9D02EED0  718B5002   MUL T2, T4, T3
9D02EED4  00063400   SLL A2, A2, 16
9D02EED8  01A63025   OR A2, T5, A2
9D02EEDC  00CA202B   SLTU A0, A2, T2
9D02EEE0  0127001B   DIVU T1, A3
9D02EEE4  00E001F4   TEQ A3, ZERO
9D02EEE8  5080000B   BEQL A0, ZERO, 0x9D02EF18
9D02EEEC  00CA3023   SUBU A2, A2, T2
9D02EEF0  00C83021   ADDU A2, A2, T0
9D02EEF4  00C8202B   SLTU A0, A2, T0
9D02EEF8  14800006   BNE A0, ZERO, 0x9D02EF14
9D02EEFC  2583FFFF   ADDIU V1, T4, -1
9D02EF00  00CA202B   SLTU A0, A2, T2
9D02EF04  50800004   BEQL A0, ZERO, 0x9D02EF18
9D02EF08  00CA3023   SUBU A2, A2, T2
9D02EF0C  2583FFFE   ADDIU V1, T4, -2
9D02EF10  00C83021   ADDU A2, A2, T0
9D02EF14  00CA3023   SUBU A2, A2, T2
9D02EF18  30ACFFFF   ANDI T4, A1, -1
9D02EF1C  00C7001B   DIVU A2, A3
9D02EF20  00E001F4   TEQ A3, ZERO
9D02EF24  00002010   MFHI A0
9D02EF28  00005012   MFLO T2
9D02EF2C  00004812   MFLO T1
9D02EF30  714B2802   MUL A1, T2, T3
9D02EF34  00042400   SLL A0, A0, 16
9D02EF38  008C2025   OR A0, A0, T4
9D02EF3C  0085602B   SLTU T4, A0, A1
9D02EF40  00C7001B   DIVU A2, A3
9D02EF44  00E001F4   TEQ A3, ZERO
9D02EF48  5180000B   BEQL T4, ZERO, 0x9D02EF78
9D02EF4C  00031C00   SLL V1, V1, 16
9D02EF50  00882021   ADDU A0, A0, T0
9D02EF54  0088302B   SLTU A2, A0, T0
9D02EF58  14C00006   BNE A2, ZERO, 0x9D02EF74
9D02EF5C  2549FFFF   ADDIU T1, T2, -1
9D02EF60  0085302B   SLTU A2, A0, A1
9D02EF64  50C00004   BEQL A2, ZERO, 0x9D02EF78
9D02EF68  00031C00   SLL V1, V1, 16
9D02EF6C  2549FFFE   ADDIU T1, T2, -2
9D02EF70  00882021   ADDU A0, A0, T0
9D02EF74  00031C00   SLL V1, V1, 16
9D02EF78  00852023   SUBU A0, A0, A1
9D02EF7C  0B40BB2F   J .LBB16
9D02EF80  01231825   OR V1, T1, V1
9D02DF94  000A3402   SRL A2, T2, 16
9D02DF98  0087001B   DIVU A0, A3
9D02DF9C  00E001F4   TEQ A3, ZERO
9D02DFA0  00007010   MFHI T6
9D02DFA4  00006812   MFLO T5
9D02DFA8  00001012   MFLO V0
9D02DFAC  71AC5802   MUL T3, T5, T4
9D02DFB0  000E7400   SLL T6, T6, 16
9D02DFB4  01C63025   OR A2, T6, A2
9D02DFB8  00CB702B   SLTU T6, A2, T3
9D02DFBC  0087001B   DIVU A0, A3
9D02DFC0  00E001F4   TEQ A3, ZERO
9D02DFC4  11C00009   BEQ T6, ZERO, 0x9D02DFEC
9D02DFC8  00CB2823   SUBU A1, A2, T3
9D02DFCC  00C83021   ADDU A2, A2, T0
9D02DFD0  00C8202B   SLTU A0, A2, T0
9D02DFD4  14800004   BNE A0, ZERO, 0x9D02DFE8
9D02DFD8  25A2FFFF   ADDIU V0, T5, -1
9D02DFDC  00CB202B   SLTU A0, A2, T3
9D02DFE0  548000A3   BNEL A0, ZERO, 0x9D02E270
9D02DFE4  25A2FFFE   ADDIU V0, T5, -2
9D02DFE8  00CB2823   SUBU A1, A2, T3
9D02DFEC  314AFFFF   ANDI T2, T2, -1
9D02DFF0  00A7001B   DIVU A1, A3
9D02DFF4  00E001F4   TEQ A3, ZERO
9D02DFF8  00005810   MFHI T3
9D02DFFC  00003012   MFLO A2
9D02E000  00002012   MFLO A0
9D02E004  70CC6002   MUL T4, A2, T4
9D02E008  000B5C00   SLL T3, T3, 16
9D02E00C  016A5025   OR T2, T3, T2
9D02E010  014C582B   SLTU T3, T2, T4
9D02E014  00A7001B   DIVU A1, A3
9D02E018  00E001F4   TEQ A3, ZERO
9D02E01C  51600009   BEQL T3, ZERO, .LBE16
9D02E020  00021400   SLL V0, V0, 16
9D02E024  01485021   ADDU T2, T2, T0
9D02E028  0148402B   SLTU T0, T2, T0
9D02E02C  15000004   BNE T0, ZERO, 0x9D02E040
9D02E030  24C4FFFF   ADDIU A0, A2, -1
9D02E034  014C502B   SLTU T2, T2, T4
9D02E038  24C6FFFE   ADDIU A2, A2, -2
9D02E03C  00CA200B   MOVN A0, A2, T2
9D02E040  00021400   SLL V0, V0, 16
9D02E044  0B40B7B6   J .LBE15
9D02E048  00821025   OR V0, A0, V0
9D02E270  0B40B7FA   J 0x9D02DFE8
9D02E858  00092402   SRL A0, T1, 16
9D02E85C  00A3001B   DIVU A1, V1
9D02E860  006001F4   TEQ V1, ZERO
9D02E864  00005010   MFHI T2
9D02E868  00003012   MFLO A2
9D02E86C  70C73002   MUL A2, A2, A3
9D02E870  000A5400   SLL T2, T2, 16
9D02E874  01442025   OR A0, T2, A0
9D02E878  0086502B   SLTU T2, A0, A2
9D02E87C  00A3001B   DIVU A1, V1
9D02E880  006001F4   TEQ V1, ZERO
9D02E884  51400009   BEQL T2, ZERO, 0x9D02E8AC
9D02E888  00862023   SUBU A0, A0, A2
9D02E88C  00882021   ADDU A0, A0, T0
9D02E890  0088282B   SLTU A1, A0, T0
9D02E894  54A00005   BNEL A1, ZERO, 0x9D02E8AC
9D02E898  00862023   SUBU A0, A0, A2
9D02E89C  0086502B   SLTU T2, A0, A2
9D02E8A0  00882821   ADDU A1, A0, T0
9D02E8A4  00AA200B   MOVN A0, A1, T2
9D02E8A8  00862023   SUBU A0, A0, A2
9D02E8AC  3126FFFF   ANDI A2, T1, -1
9D02E8B0  0083001B   DIVU A0, V1
9D02E8B4  006001F4   TEQ V1, ZERO
9D02E8B8  00004810   MFHI T1
9D02E8BC  00002812   MFLO A1
9D02E8C0  70A72802   MUL A1, A1, A3
9D02E8C4  00094C00   SLL T1, T1, 16
9D02E8C8  01264825   OR T1, T1, A2
9D02E8CC  0125302B   SLTU A2, T1, A1
9D02E8D0  0083001B   DIVU A0, V1
9D02E8D4  006001F4   TEQ V1, ZERO
9D02E8D8  50C00009   BEQL A2, ZERO, .LBE17
9D02E8DC  01254823   SUBU T1, T1, A1
9D02E8E0  01284821   ADDU T1, T1, T0
9D02E8E4  0128182B   SLTU V1, T1, T0
9D02E8E8  54600005   BNEL V1, ZERO, .LBE17
9D02E8EC  01254823   SUBU T1, T1, A1
9D02E8F0  0125182B   SLTU V1, T1, A1
9D02E8F4  01284021   ADDU T0, T1, T0
9D02E8F8  0103480B   MOVN T1, T0, V1
9D02E8FC  01254823   SUBU T1, T1, A1
9D02ECBC  00023402   SRL A2, V0, 16
9D02ECC0  0087001B   DIVU A0, A3
9D02ECC4  00E001F4   TEQ A3, ZERO
9D02ECC8  00006810   MFHI T5
9D02ECCC  00006012   MFLO T4
9D02ECD0  00004812   MFLO T1
9D02ECD4  718B5002   MUL T2, T4, T3
9D02ECD8  000D6C00   SLL T5, T5, 16
9D02ECDC  01A63025   OR A2, T5, A2
9D02ECE0  00CA682B   SLTU T5, A2, T2
9D02ECE4  0087001B   DIVU A0, A3
9D02ECE8  00E001F4   TEQ A3, ZERO
9D02ECEC  11A00009   BEQ T5, ZERO, 0x9D02ED14
9D02ECF0  00CA2823   SUBU A1, A2, T2
9D02ECF4  00C83021   ADDU A2, A2, T0
9D02ECF8  00C8202B   SLTU A0, A2, T0
9D02ECFC  14800004   BNE A0, ZERO, 0x9D02ED10
9D02ED00  2589FFFF   ADDIU T1, T4, -1
9D02ED04  00CA202B   SLTU A0, A2, T2
9D02ED08  548000A6   BNEL A0, ZERO, 0x9D02EFA4
9D02ED0C  2589FFFE   ADDIU T1, T4, -2
9D02ED10  00CA2823   SUBU A1, A2, T2
9D02ED14  3042FFFF   ANDI V0, V0, -1
9D02ED18  00A7001B   DIVU A1, A3
9D02ED1C  00E001F4   TEQ A3, ZERO
9D02ED20  00005010   MFHI T2
9D02ED24  00003012   MFLO A2
9D02ED28  00002012   MFLO A0
9D02ED2C  70CB5802   MUL T3, A2, T3
9D02ED30  000A5400   SLL T2, T2, 16
9D02ED34  01421025   OR V0, T2, V0
9D02ED38  004B502B   SLTU T2, V0, T3
9D02ED3C  00A7001B   DIVU A1, A3
9D02ED40  00E001F4   TEQ A3, ZERO
9D02ED44  51400009   BEQL T2, ZERO, .LBE16
9D02ED48  00091400   SLL V0, T1, 16
9D02ED4C  00481021   ADDU V0, V0, T0
9D02ED50  0048402B   SLTU T0, V0, T0
9D02ED54  15000004   BNE T0, ZERO, 0x9D02ED68
9D02ED58  24C4FFFF   ADDIU A0, A2, -1
9D02ED5C  004B582B   SLTU T3, V0, T3
9D02ED60  24C6FFFE   ADDIU A2, A2, -2
9D02ED64  00CB200B   MOVN A0, A2, T3
9D02ED68  00091400   SLL V0, T1, 16
9D02ED6C  03E00008   JR RA
9D02ED70  00821025   OR V0, A0, V0
9D02EFA4  0B40BB44   J 0x9D02ED10
9D02E7DC  00491006   SRLV V0, T1, V0
9D02E900  00491006   SRLV V0, T1, V0
9D02E7E0  03E00008   JR RA
9D02E7E4  00001821   ADDU V1, ZERO, ZERO
9D02E904  03E00008   JR RA
9D02E908  00001821   ADDU V1, ZERO, ZERO
9D02DEF8  00A7102B   SLTU V0, A1, A3
9D02DEFC  10400010   BEQ V0, ZERO, 0x9D02DF40
9D02DF00  70E84020   CLZ T0, A3
9D02DF04  00001821   ADDU V1, ZERO, ZERO
9D02DF08  0B40B7B6   J .LBE15
9D02DF0C  00001021   ADDU V0, ZERO, ZERO
9D02E7E8  00A7102B   SLTU V0, A1, A3
9D02E7EC  14400047   BNE V0, ZERO, 0x9D02E90C
9D02E7F0  70EA5020   CLZ T2, A3
9D02EC5C  00A7102B   SLTU V0, A1, A3
9D02EC60  14400044   BNE V0, ZERO, 0x9D02ED74
9D02EC64  70E84020   CLZ T0, A3
9D02ED74  00001821   ADDU V1, ZERO, ZERO
9D02ED78  03E00008   JR RA
9D02ED7C  00001021   ADDU V0, ZERO, ZERO
9D02E90C  00801021   ADDU V0, A0, ZERO
9D02E910  03E00008   JR RA
9D02E914  00A01821   ADDU V1, A1, ZERO
9D02DF40  1500007E   BNE T0, ZERO, 0x9D02E13C
9D02DF44  24020020   ADDIU V0, ZERO, 32
9D02E7F4  15400048   BNE T2, ZERO, 0x9D02E918
9D02E7F8  240B0020   ADDIU T3, ZERO, 32
9D02EC68  55000045   BNEL T0, ZERO, 0x9D02ED80
9D02EC6C  24020020   ADDIU V0, ZERO, 32
9D02DF48  00E5282B   SLTU A1, A3, A1
9D02DF4C  14A000C6   BNE A1, ZERO, 0x9D02E268
9D02DF50  00001821   ADDU V1, ZERO, ZERO
9D02DF54  0086102B   SLTU V0, A0, A2
9D02DF58  0B40B7B6   J .LBE15
9D02DF5C  38420001   XORI V0, V0, 1
9D02E268  0B40B7B6   J .LBE15
9D02E26C  24020001   ADDIU V0, ZERO, 1
9D02E7FC  00E5102B   SLTU V0, A3, A1
9D02E800  14400005   BNE V0, ZERO, 0x9D02E818
9D02E804  00861023   SUBU V0, A0, A2
9D02E808  0086402B   SLTU T0, A0, A2
9D02E80C  15000089   BNE T0, ZERO, 0x9D02EA34
9D02E810  00801021   ADDU V0, A0, ZERO
9D02EC70  00E5282B   SLTU A1, A3, A1
9D02EC74  14A000C8   BNE A1, ZERO, 0x9D02EF98
9D02EC78  0086302B   SLTU A2, A0, A2
9D02EC7C  38C20001   XORI V0, A2, 1
9D02EC80  03E00008   JR RA
9D02EC84  00001821   ADDU V1, ZERO, ZERO
9D02EF98  00001821   ADDU V1, ZERO, ZERO
9D02E814  00861023   SUBU V0, A0, A2
9D02E818  00A72823   SUBU A1, A1, A3
9D02E81C  0082202B   SLTU A0, A0, V0
9D02E820  03E00008   JR RA
9D02E824  00A41823   SUBU V1, A1, A0
9D02E13C  00481023   SUBU V0, V0, T0
9D02E918  016A5823   SUBU T3, T3, T2
9D02ED80  00481023   SUBU V0, V0, T0
9D02E140  01073804   SLLV A3, A3, T0
9D02E144  00461806   SRLV V1, A2, V0
9D02E148  00673825   OR A3, V1, A3
9D02E91C  01473804   SLLV A3, A3, T2
9D02E920  01661006   SRLV V0, A2, T3
9D02E924  00473825   OR A3, V0, A3
9D02ED84  01073804   SLLV A3, A3, T0
9D02ED88  00461806   SRLV V1, A2, V0
9D02ED8C  00673825   OR A3, V1, A3
9D02E954  01463004   SLLV A2, A2, T2
9D02E14C  00455806   SRLV T3, A1, V0
9D02E928  01656806   SRLV T5, A1, T3
9D02ED90  00455006   SRLV T2, A1, V0
9D02E168  01052804   SLLV A1, A1, T0
9D02E16C  00441006   SRLV V0, A0, V0
9D02E170  00452825   OR A1, V0, A1
9D02E944  01452804   SLLV A1, A1, T2
9D02E948  01641006   SRLV V0, A0, T3
9D02E94C  00451025   OR V0, V0, A1
9D02EDAC  01052804   SLLV A1, A1, T0
9D02EDB0  00441006   SRLV V0, A0, V0
9D02EDB4  00452825   OR A1, V0, A1
9D02E150  00071C02   SRL V1, A3, 16
9D02E154  0163001B   DIVU T3, V1
9D02E158  006001F4   TEQ V1, ZERO
9D02E15C  00005010   MFHI T2
9D02E160  00007012   MFLO T6
9D02E164  30ECFFFF   ANDI T4, A3, -1
9D02E174  00057C02   SRL T7, A1, 16
9D02E178  00001012   MFLO V0
9D02E17C  71CC6802   MUL T5, T6, T4
9D02E180  000A5400   SLL T2, T2, 16
9D02E184  014F5025   OR T2, T2, T7
9D02E188  014D782B   SLTU T7, T2, T5
9D02E18C  0163001B   DIVU T3, V1
9D02E190  006001F4   TEQ V1, ZERO
9D02E194  11E0000A   BEQ T7, ZERO, 0x9D02E1C0
9D02E198  01063004   SLLV A2, A2, T0
9D02E19C  01475021   ADDU T2, T2, A3
9D02E1A0  0147582B   SLTU T3, T2, A3
9D02E1A4  15600006   BNE T3, ZERO, 0x9D02E1C0
9D02E1A8  25C2FFFF   ADDIU V0, T6, -1
9D02E1AC  014D582B   SLTU T3, T2, T5
9D02E1B0  51600004   BEQL T3, ZERO, 0x9D02E1C4
9D02E1B4  014D5023   SUBU T2, T2, T5
9D02E1B8  25C2FFFE   ADDIU V0, T6, -2
9D02E1BC  01475021   ADDU T2, T2, A3
9D02E1C0  014D5023   SUBU T2, T2, T5
9D02E1C4  30A5FFFF   ANDI A1, A1, -1
9D02E1C8  0143001B   DIVU T2, V1
9D02E1CC  006001F4   TEQ V1, ZERO
9D02E1D0  00007010   MFHI T6
9D02E1D4  00006812   MFLO T5
9D02E1D8  00005812   MFLO T3
9D02E1DC  71AC6002   MUL T4, T5, T4
9D02E1E0  000E7400   SLL T6, T6, 16
9D02E1E4  01C52825   OR A1, T6, A1
9D02E1E8  00AC702B   SLTU T6, A1, T4
9D02E1EC  0143001B   DIVU T2, V1
9D02E1F0  006001F4   TEQ V1, ZERO
9D02E1F4  51C0000B   BEQL T6, ZERO, 0x9D02E224
9D02E1F8  00021400   SLL V0, V0, 16
9D02E1FC  00A72821   ADDU A1, A1, A3
9D02E200  00A7182B   SLTU V1, A1, A3
9D02E204  14600006   BNE V1, ZERO, 0x9D02E220
9D02E208  25ABFFFF   ADDIU T3, T5, -1
9D02E20C  00AC182B   SLTU V1, A1, T4
9D02E210  50600004   BEQL V1, ZERO, 0x9D02E224
9D02E214  00021400   SLL V0, V0, 16
9D02E218  25ABFFFE   ADDIU T3, T5, -2
9D02E21C  00A72821   ADDU A1, A1, A3
9D02E220  00021400   SLL V0, V0, 16
9D02E224  01621025   OR V0, T3, V0
9D02E228  00AC2823   SUBU A1, A1, T4
9D02E92C  00074C02   SRL T1, A3, 16
9D02E930  01A9001B   DIVU T5, T1
9D02E934  012001F4   TEQ T1, ZERO
9D02E938  00006010   MFHI T4
9D02E93C  00001812   MFLO V1
9D02E940  30EEFFFF   ANDI T6, A3, -1
9D02E950  00022C02   SRL A1, V0, 16
9D02E958  00004012   MFLO T0
9D02E95C  706E7802   MUL T7, V1, T6
9D02E960  000C6400   SLL T4, T4, 16
9D02E964  01856025   OR T4, T4, A1
9D02E968  018F282B   SLTU A1, T4, T7
9D02E96C  01A9001B   DIVU T5, T1
9D02E970  012001F4   TEQ T1, ZERO
9D02E974  10A0000A   BEQ A1, ZERO, 0x9D02E9A0
9D02E978  01442004   SLLV A0, A0, T2
9D02E97C  01876021   ADDU T4, T4, A3
9D02E980  0187282B   SLTU A1, T4, A3
9D02E984  14A00006   BNE A1, ZERO, 0x9D02E9A0
9D02E988  2468FFFF   ADDIU T0, V1, -1
9D02E98C  018F282B   SLTU A1, T4, T7
9D02E990  50A00004   BEQL A1, ZERO, 0x9D02E9A4
9D02E994  018F6023   SUBU T4, T4, T7
9D02E998  2468FFFE   ADDIU T0, V1, -2
9D02E99C  01876021   ADDU T4, T4, A3
9D02E9A0  018F6023   SUBU T4, T4, T7
9D02E9A4  3042FFFF   ANDI V0, V0, -1
9D02E9A8  0189001B   DIVU T4, T1
9D02E9AC  012001F4   TEQ T1, ZERO
9D02E9B0  00002810   MFHI A1
9D02E9B4  00001812   MFLO V1
9D02E9B8  00006812   MFLO T5
9D02E9BC  706E7002   MUL T6, V1, T6
9D02E9C0  00052C00   SLL A1, A1, 16
9D02E9C4  00A21025   OR V0, A1, V0
9D02E9C8  004E282B   SLTU A1, V0, T6
9D02E9CC  0189001B   DIVU T4, T1
9D02E9D0  012001F4   TEQ T1, ZERO
9D02E9D4  50A00006   BEQL A1, ZERO, 0x9D02E9F0
9D02E9D8  00084400   SLL T0, T0, 16
9D02E9DC  00471021   ADDU V0, V0, A3
9D02E9E0  0047282B   SLTU A1, V0, A3
9D02E9E4  10A0004C   BEQ A1, ZERO, .LBE25
9D02E9E8  246DFFFF   ADDIU T5, V1, -1
9D02E9EC  00084400   SLL T0, T0, 16
9D02E9F0  01A84025   OR T0, T5, T0
9D02E9F4  004E1023   SUBU V0, V0, T6
9D02EB18  004E282B   SLTU A1, V0, T6
9D02EB1C  50A0FFB4   BEQL A1, ZERO, 0x9D02E9F0
9D02EB20  00084400   SLL T0, T0, 16
9D02EB24  246DFFFE   ADDIU T5, V1, -2
9D02EB28  0B40BA7B   J 0x9D02E9EC
9D02EB2C  00471021   ADDU V0, V0, A3
9D02ED94  00071C02   SRL V1, A3, 16
9D02ED98  0143001B   DIVU T2, V1
9D02ED9C  006001F4   TEQ V1, ZERO
9D02EDA0  00004810   MFHI T1
9D02EDA4  00006812   MFLO T5
9D02EDA8  30EBFFFF   ANDI T3, A3, -1
9D02EDB8  00057402   SRL T6, A1, 16
9D02EDBC  00001012   MFLO V0
9D02EDC0  71AB6002   MUL T4, T5, T3
9D02EDC4  00094C00   SLL T1, T1, 16
9D02EDC8  012E4825   OR T1, T1, T6
9D02EDCC  012C702B   SLTU T6, T1, T4
9D02EDD0  0143001B   DIVU T2, V1
9D02EDD4  006001F4   TEQ V1, ZERO
9D02EDD8  11C0000A   BEQ T6, ZERO, 0x9D02EE04
9D02EDDC  01063004   SLLV A2, A2, T0
9D02EDE0  01274821   ADDU T1, T1, A3
9D02EDE4  0127502B   SLTU T2, T1, A3
9D02EDE8  15400006   BNE T2, ZERO, 0x9D02EE04
9D02EDEC  25A2FFFF   ADDIU V0, T5, -1
9D02EDF0  012C502B   SLTU T2, T1, T4
9D02EDF4  51400004   BEQL T2, ZERO, 0x9D02EE08
9D02EDF8  012C4823   SUBU T1, T1, T4
9D02EDFC  25A2FFFE   ADDIU V0, T5, -2
9D02EE00  01274821   ADDU T1, T1, A3
9D02EE04  012C4823   SUBU T1, T1, T4
9D02EE08  30A5FFFF   ANDI A1, A1, -1
9D02EE0C  0123001B   DIVU T1, V1
9D02EE10  006001F4   TEQ V1, ZERO
9D02EE14  00006810   MFHI T5
9D02EE18  00006012   MFLO T4
9D02EE1C  00005012   MFLO T2
9D02EE20  718B5802   MUL T3, T4, T3
9D02EE24  000D6C00   SLL T5, T5, 16
9D02EE28  01A52825   OR A1, T5, A1
9D02EE2C  00AB682B   SLTU T5, A1, T3
9D02EE30  0123001B   DIVU T1, V1
9D02EE34  006001F4   TEQ V1, ZERO
9D02EE38  51A0000B   BEQL T5, ZERO, 0x9D02EE68
9D02EE3C  00021400   SLL V0, V0, 16
9D02EE40  00A72821   ADDU A1, A1, A3
9D02EE44  00A7182B   SLTU V1, A1, A3
9D02EE48  14600006   BNE V1, ZERO, 0x9D02EE64
9D02EE4C  258AFFFF   ADDIU T2, T4, -1
9D02EE50  00AB182B   SLTU V1, A1, T3
9D02EE54  50600004   BEQL V1, ZERO, 0x9D02EE68
9D02EE58  00021400   SLL V0, V0, 16
9D02EE5C  258AFFFE   ADDIU T2, T4, -2
9D02EE60  00A72821   ADDU A1, A1, A3
9D02EE64  00021400   SLL V0, V0, 16
9D02EE68  01421025   OR V0, T2, V0
9D02EE6C  00AB2823   SUBU A1, A1, T3
9D02E22C  00460019   MULTU 0, V0, A2
9D02E230  00003810   MFHI A3
9D02E9F8  01060019   MULTU 0, T0, A2
9D02E9FC  00004810   MFHI T1
9D02EA14  00003012   MFLO A2
9D02EE70  00460019   MULTU 0, V0, A2
9D02EE74  00003810   MFHI A3
9D02E234  00A7182B   SLTU V1, A1, A3
9D02E238  14600008   BNE V1, ZERO, 0x9D02E25C
9D02E23C  00003012   MFLO A2
9D02E240  50A70003   BEQL A1, A3, 0x9D02E250
9D02E244  01042004   SLLV A0, A0, T0
9D02E250  0086302B   SLTU A2, A0, A2
9D02E254  50C0FF20   BEQL A2, ZERO, .LBE15
9D02E258  00001821   ADDU V1, ZERO, ZERO
9D02EA00  0049182B   SLTU V1, V0, T1
9D02EA04  1460003E   BNE V1, ZERO, .LBB25
9D02EA08  00004012   MFLO T0
9D02EA0C  1049004B   BEQ V0, T1, 0x9D02EB3C
9D02EA10  00491823   SUBU V1, V0, T1
9D02EB3C  0088182B   SLTU V1, A0, T0
9D02EE78  00A7182B   SLTU V1, A1, A3
9D02EE7C  14600044   BNE V1, ZERO, 0x9D02EF90
9D02EE80  00003012   MFLO A2
9D02EE84  10A7003F   BEQ A1, A3, 0x9D02EF84
9D02EE88  01042004   SLLV A0, A0, T0
9D02EF84  0086302B   SLTU A2, A0, A2
9D02EF88  10C0FFC0   BEQ A2, ZERO, 0x9D02EE8C
9D02EF8C  00000000   NOP
9D02E248  0B40B7B6   J .LBE15
9D02E24C  00001821   ADDU V1, ZERO, ZERO
9D02E25C  2442FFFF   ADDIU V0, V0, -1
9D02E260  0B40B7B6   J .LBE15
9D02E264  00001821   ADDU V1, ZERO, ZERO
9D02EE8C  03E00008   JR RA
9D02EE90  00001821   ADDU V1, ZERO, ZERO
9D02EF90  0B40BBA3   J 0x9D02EE8C
9D02EF94  2442FFFF   ADDIU V0, V0, -1
9D02EB00  01063023   SUBU A2, T0, A2
9D02EB04  01271823   SUBU V1, T1, A3
9D02EB08  0106402B   SLTU T0, T0, A2
9D02EB0C  00681823   SUBU V1, V1, T0
9D02EB10  0B40BA86   J .LBB24
9D02EB14  00431823   SUBU V1, V0, V1
9D02EA18  00863023   SUBU A2, A0, A2
9D02EA1C  0086202B   SLTU A0, A0, A2
9D02EA20  00641823   SUBU V1, V1, A0
9D02EA24  01631004   SLLV V0, V1, T3
9D02EA28  01463006   SRLV A2, A2, T2
9D02EA2C  00461025   OR V0, V0, A2
9D02EA30  01431806   SRLV V1, V1, T2
9D02DDC4  04A00052   BLTZ A1, 0x9D02DF10
9D02DDC8  00004821   ADDU T1, ZERO, ZERO
9D02DF10  00042023   SUBU A0, ZERO, A0
9D02DF14  0004102B   SLTU V0, ZERO, A0
9D02DF18  00052823   SUBU A1, ZERO, A1
9D02DF1C  00A22823   SUBU A1, A1, V0
9D02DDCC  04E20057   BLTZL A3, 0x9D02DF2C
9D02DDD0  00063023   SUBU A2, ZERO, A2
9D02DF20  04E1FFAC   BGEZ A3, .LBB13
9D02DF24  2409FFFF   ADDIU T1, ZERO, -1
9D02DF34  00094827   NOR T1, ZERO, T1
9D02DF28  00063023   SUBU A2, ZERO, A2
9D02DF2C  0006102B   SLTU V0, ZERO, A2
9D02DF30  00073823   SUBU A3, ZERO, A3
9D02DF38  0B40B775   J .LBB13
9D02DF3C  00E23823   SUBU A3, A3, V0
9D02DED8  11200005   BEQ T1, ZERO, 0x9D02DEF0
9D02DEDC  00000000   NOP
9D02DEE0  00021023   SUBU V0, ZERO, V0
9D02DEE4  0002202B   SLTU A0, ZERO, V0
9D02DEE8  00031823   SUBU V1, ZERO, V1
9D02DEEC  00641823   SUBU V1, V1, A0
9D02DEF0  03E00008   JR RA
9D02DEF4  00000000   NOP
9D02DEF8  00A7102B   SLTU V0, A1, A3
9D02DEFC  10400010   BEQ V0, ZERO, 0x9D02DF40
9D02DF00  70E84020   CLZ T0, A3
9D02DF04  00001821   ADDU V1, ZERO, ZERO
9D02DF08  0B40B7B6   J .LBE15
9D02DF0C  00001021   ADDU V0, ZERO, ZERO
9D02DF10  00042023   SUBU A0, ZERO, A0
9D02DF14  0004102B   SLTU V0, ZERO, A0
9D02DF18  00052823   SUBU A1, ZERO, A1
9D02DF1C  00A22823   SUBU A1, A1, V0
9D02DF20  04E1FFAC   BGEZ A3, .LBB13
9D02DF24  2409FFFF   ADDIU T1, ZERO, -1
9D02DF28  00063023   SUBU A2, ZERO, A2
9D02DF2C  0006102B   SLTU V0, ZERO, A2
9D02DF30  00073823   SUBU A3, ZERO, A3
9D02DF34  00094827   NOR T1, ZERO, T1
9D02DF38  0B40B775   J .LBB13
9D02DF3C  00E23823   SUBU A3, A3, V0
9D02DF40  1500007E   BNE T0, ZERO, 0x9D02E13C
9D02DF44  24020020   ADDIU V0, ZERO, 32
9D02DF48  00E5282B   SLTU A1, A3, A1
9D02DF4C  14A000C6   BNE A1, ZERO, 0x9D02E268
9D02DF50  00001821   ADDU V1, ZERO, ZERO
9D02DF54  0086102B   SLTU V0, A0, A2
9D02DF58  0B40B7B6   J .LBE15
9D02DF5C  38420001   XORI V0, V0, 1
9D02DF60  14C00006   BNE A2, ZERO, 0x9D02DF7C
9D02DF64  71021020   CLZ V0, T0
9D02DF68  24080001   ADDIU T0, ZERO, 1
9D02DF6C  0107001B   DIVU T0, A3
9D02DF70  00E001F4   TEQ A3, ZERO
9D02DF74  00004012   MFLO T0
9D02DF78  71021020   CLZ V0, T0
9D02DF7C  54400033   BNEL V0, ZERO, 0x9D02E04C
9D02DF80  00484004   SLLV T0, T0, V0
9D02DF84  00A82023   SUBU A0, A1, T0
9D02DF88  00083C02   SRL A3, T0, 16
9D02DF8C  310CFFFF   ANDI T4, T0, -1
9D02DF90  24030001   ADDIU V1, ZERO, 1
9D02DF94  000A3402   SRL A2, T2, 16
9D02DF98  0087001B   DIVU A0, A3
9D02DF9C  00E001F4   TEQ A3, ZERO
9D02DFA0  00007010   MFHI T6
9D02DFA4  00006812   MFLO T5
9D02DFA8  00001012   MFLO V0
9D02DFAC  71AC5802   MUL T3, T5, T4
9D02DFB0  000E7400   SLL T6, T6, 16
9D02DFB4  01C63025   OR A2, T6, A2
9D02DFB8  00CB702B   SLTU T6, A2, T3
9D02DFBC  0087001B   DIVU A0, A3
9D02DFC0  00E001F4   TEQ A3, ZERO
9D02DFC4  11C00009   BEQ T6, ZERO, 0x9D02DFEC
9D02DFC8  00CB2823   SUBU A1, A2, T3
9D02DFCC  00C83021   ADDU A2, A2, T0
9D02DFD0  00C8202B   SLTU A0, A2, T0
9D02DFD4  14800004   BNE A0, ZERO, 0x9D02DFE8
9D02DFD8  25A2FFFF   ADDIU V0, T5, -1
9D02DFDC  00CB202B   SLTU A0, A2, T3
9D02DFE0  548000A3   BNEL A0, ZERO, 0x9D02E270
9D02DFE4  25A2FFFE   ADDIU V0, T5, -2
9D02DFE8  00CB2823   SUBU A1, A2, T3
9D02DFEC  314AFFFF   ANDI T2, T2, -1
9D02DFF0  00A7001B   DIVU A1, A3
9D02DFF4  00E001F4   TEQ A3, ZERO
9D02DFF8  00005810   MFHI T3
9D02DFFC  00003012   MFLO A2
9D02E000  00002012   MFLO A0
9D02E004  70CC6002   MUL T4, A2, T4
9D02E008  000B5C00   SLL T3, T3, 16
9D02E00C  016A5025   OR T2, T3, T2
9D02E010  014C582B   SLTU T3, T2, T4
9D02E014  00A7001B   DIVU A1, A3
9D02E018  00E001F4   TEQ A3, ZERO
9D02E01C  51600009   BEQL T3, ZERO, .LBE16
9D02E020  00021400   SLL V0, V0, 16
9D02E024  01485021   ADDU T2, T2, T0
9D02E028  0148402B   SLTU T0, T2, T0
9D02E02C  15000004   BNE T0, ZERO, 0x9D02E040
9D02E030  24C4FFFF   ADDIU A0, A2, -1
9D02E034  014C502B   SLTU T2, T2, T4
9D02E038  24C6FFFE   ADDIU A2, A2, -2
9D02E03C  00CA200B   MOVN A0, A2, T2
9D02E040  00021400   SLL V0, V0, 16
9D02E044  0B40B7B6   J .LBE15
9D02E048  00821025   OR V0, A0, V0
9D02E04C  24030020   ADDIU V1, ZERO, 32
9D02E050  00621823   SUBU V1, V1, V0
9D02E054  00653006   SRLV A2, A1, V1
9D02E058  00083C02   SRL A3, T0, 16
9D02E05C  00C7001B   DIVU A2, A3
9D02E060  00E001F4   TEQ A3, ZERO
9D02E064  00007810   MFHI T7
9D02E068  00006812   MFLO T5
9D02E06C  310CFFFF   ANDI T4, T0, -1
9D02E070  00452804   SLLV A1, A1, V0
9D02E074  00641806   SRLV V1, A0, V1
9D02E078  00652825   OR A1, V1, A1
9D02E07C  00057402   SRL T6, A1, 16
9D02E080  00445004   SLLV T2, A0, V0
9D02E084  00001812   MFLO V1
9D02E088  71AC5802   MUL T3, T5, T4
9D02E08C  000F1400   SLL V0, T7, 16
9D02E090  01C21025   OR V0, T6, V0
9D02E094  004B202B   SLTU A0, V0, T3
9D02E098  00C7001B   DIVU A2, A3
9D02E09C  00E001F4   TEQ A3, ZERO
9D02E0A0  5080000B   BEQL A0, ZERO, 0x9D02E0D0
9D02E0A4  004B1023   SUBU V0, V0, T3
9D02E0A8  00481021   ADDU V0, V0, T0
9D02E0AC  0048202B   SLTU A0, V0, T0
9D02E0B0  14800006   BNE A0, ZERO, 0x9D02E0CC
9D02E0B4  25A3FFFF   ADDIU V1, T5, -1
9D02E0B8  004B202B   SLTU A0, V0, T3
9D02E0BC  50800004   BEQL A0, ZERO, 0x9D02E0D0
9D02E0C0  004B1023   SUBU V0, V0, T3
9D02E0C4  25A3FFFE   ADDIU V1, T5, -2
9D02E0C8  00481021   ADDU V0, V0, T0
9D02E0CC  004B1023   SUBU V0, V0, T3
9D02E0D0  30ADFFFF   ANDI T5, A1, -1
9D02E0D4  0047001B   DIVU V0, A3
9D02E0D8  00E001F4   TEQ A3, ZERO
9D02E0DC  00002010   MFHI A0
9D02E0E0  00005812   MFLO T3
9D02E0E4  00003012   MFLO A2
9D02E0E8  716C2802   MUL A1, T3, T4
9D02E0EC  00042400   SLL A0, A0, 16
9D02E0F0  008D2025   OR A0, A0, T5
9D02E0F4  0085682B   SLTU T5, A0, A1
9D02E0F8  0047001B   DIVU V0, A3
9D02E0FC  00E001F4   TEQ A3, ZERO
9D02E100  51A0000B   BEQL T5, ZERO, 0x9D02E130
9D02E104  00031C00   SLL V1, V1, 16
9D02E108  00882021   ADDU A0, A0, T0
9D02E10C  0088102B   SLTU V0, A0, T0
9D02E110  14400006   BNE V0, ZERO, 0x9D02E12C
9D02E114  2566FFFF   ADDIU A2, T3, -1
9D02E118  0085102B   SLTU V0, A0, A1
9D02E11C  50400004   BEQL V0, ZERO, 0x9D02E130
9D02E120  00031C00   SLL V1, V1, 16
9D02E124  2566FFFE   ADDIU A2, T3, -2
9D02E128  00882021   ADDU A0, A0, T0
9D02E12C  00031C00   SLL V1, V1, 16
9D02E130  00852023   SUBU A0, A0, A1
9D02E134  0B40B7E5   J .LBB16
9D02E138  00C31825   OR V1, A2, V1
9D02E13C  00481023   SUBU V0, V0, T0
9D02E140  01073804   SLLV A3, A3, T0
9D02E144  00461806   SRLV V1, A2, V0
9D02E148  00673825   OR A3, V1, A3
9D02E14C  00455806   SRLV T3, A1, V0
9D02E150  00071C02   SRL V1, A3, 16
9D02E154  0163001B   DIVU T3, V1
9D02E158  006001F4   TEQ V1, ZERO
9D02E15C  00005010   MFHI T2
9D02E160  00007012   MFLO T6
9D02E164  30ECFFFF   ANDI T4, A3, -1
9D02E168  01052804   SLLV A1, A1, T0
9D02E16C  00441006   SRLV V0, A0, V0
9D02E170  00452825   OR A1, V0, A1
9D02E174  00057C02   SRL T7, A1, 16
9D02E178  00001012   MFLO V0
9D02E17C  71CC6802   MUL T5, T6, T4
9D02E180  000A5400   SLL T2, T2, 16
9D02E184  014F5025   OR T2, T2, T7
9D02E188  014D782B   SLTU T7, T2, T5
9D02E18C  0163001B   DIVU T3, V1
9D02E190  006001F4   TEQ V1, ZERO
9D02E194  11E0000A   BEQ T7, ZERO, 0x9D02E1C0
9D02E198  01063004   SLLV A2, A2, T0
9D02E19C  01475021   ADDU T2, T2, A3
9D02E1A0  0147582B   SLTU T3, T2, A3
9D02E1A4  15600006   BNE T3, ZERO, 0x9D02E1C0
9D02E1A8  25C2FFFF   ADDIU V0, T6, -1
9D02E1AC  014D582B   SLTU T3, T2, T5
9D02E1B0  51600004   BEQL T3, ZERO, 0x9D02E1C4
9D02E1B4  014D5023   SUBU T2, T2, T5
9D02E1B8  25C2FFFE   ADDIU V0, T6, -2
9D02E1BC  01475021   ADDU T2, T2, A3
9D02E1C0  014D5023   SUBU T2, T2, T5
9D02E1C4  30A5FFFF   ANDI A1, A1, -1
9D02E1C8  0143001B   DIVU T2, V1
9D02E1CC  006001F4   TEQ V1, ZERO
9D02E1D0  00007010   MFHI T6
9D02E1D4  00006812   MFLO T5
9D02E1D8  00005812   MFLO T3
9D02E1DC  71AC6002   MUL T4, T5, T4
9D02E1E0  000E7400   SLL T6, T6, 16
9D02E1E4  01C52825   OR A1, T6, A1
9D02E1E8  00AC702B   SLTU T6, A1, T4
9D02E1EC  0143001B   DIVU T2, V1
9D02E1F0  006001F4   TEQ V1, ZERO
9D02E1F4  51C0000B   BEQL T6, ZERO, 0x9D02E224
9D02E1F8  00021400   SLL V0, V0, 16
9D02E1FC  00A72821   ADDU A1, A1, A3
9D02E200  00A7182B   SLTU V1, A1, A3
9D02E204  14600006   BNE V1, ZERO, 0x9D02E220
9D02E208  25ABFFFF   ADDIU T3, T5, -1
9D02E20C  00AC182B   SLTU V1, A1, T4
9D02E210  50600004   BEQL V1, ZERO, 0x9D02E224
9D02E214  00021400   SLL V0, V0, 16
9D02E218  25ABFFFE   ADDIU T3, T5, -2
9D02E21C  00A72821   ADDU A1, A1, A3
9D02E220  00021400   SLL V0, V0, 16
9D02E224  01621025   OR V0, T3, V0
9D02E228  00AC2823   SUBU A1, A1, T4
9D02E22C  00460019   MULTU 0, V0, A2
9D02E230  00003810   MFHI A3
9D02E234  00A7182B   SLTU V1, A1, A3
9D02E238  14600008   BNE V1, ZERO, 0x9D02E25C
9D02E23C  00003012   MFLO A2
9D02E240  50A70003   BEQL A1, A3, 0x9D02E250
9D02E244  01042004   SLLV A0, A0, T0
9D02E248  0B40B7B6   J .LBE15
9D02E24C  00001821   ADDU V1, ZERO, ZERO
9D02E250  0086302B   SLTU A2, A0, A2
9D02E254  50C0FF20   BEQL A2, ZERO, .LBE15
9D02E258  00001821   ADDU V1, ZERO, ZERO
9D02E25C  2442FFFF   ADDIU V0, V0, -1
9D02E260  0B40B7B6   J .LBE15
9D02E264  00001821   ADDU V1, ZERO, ZERO
9D02E268  0B40B7B6   J .LBE15
9D02E26C  24020001   ADDIU V0, ZERO, 1
9D02E270  0B40B7FA   J 0x9D02DFE8
9D02E274  00C83021   ADDU A2, A2, T0
9D02EA34  03E00008   JR RA
9D02EA38  00000000   NOP
9D02EA3C  24090020   ADDIU T1, ZERO, 32
9D02EA40  01224823   SUBU T1, T1, V0
9D02EA44  01255006   SRLV T2, A1, T1
9D02EA48  00081C02   SRL V1, T0, 16
9D02EA4C  0143001B   DIVU T2, V1
9D02EA50  006001F4   TEQ V1, ZERO
9D02EA54  00003010   MFHI A2
9D02EA58  00005812   MFLO T3
9D02EA5C  3107FFFF   ANDI A3, T0, -1
9D02EA60  00452804   SLLV A1, A1, V0
9D02EA64  01244806   SRLV T1, A0, T1
9D02EA68  01252825   OR A1, T1, A1
9D02EA6C  00056402   SRL T4, A1, 16
9D02EA70  00444804   SLLV T1, A0, V0
9D02EA74  71675802   MUL T3, T3, A3
9D02EA78  00063400   SLL A2, A2, 16
9D02EA7C  01863025   OR A2, T4, A2
9D02EA80  00CB202B   SLTU A0, A2, T3
9D02EA84  0143001B   DIVU T2, V1
9D02EA88  006001F4   TEQ V1, ZERO
9D02EA8C  50800006   BEQL A0, ZERO, 0x9D02EAA8
9D02EA90  00CB3023   SUBU A2, A2, T3
9D02EA94  00C83021   ADDU A2, A2, T0
9D02EA98  00C8202B   SLTU A0, A2, T0
9D02EA9C  10800024   BEQ A0, ZERO, 0x9D02EB30
9D02EAA0  00CB502B   SLTU T2, A2, T3
9D02EAA4  00CB3023   SUBU A2, A2, T3
9D02EAA8  30AAFFFF   ANDI T2, A1, -1
9D02EAAC  00C3001B   DIVU A2, V1
9D02EAB0  006001F4   TEQ V1, ZERO
9D02EAB4  00002010   MFHI A0
9D02EAB8  00002812   MFLO A1
9D02EABC  70A72802   MUL A1, A1, A3
9D02EAC0  00042400   SLL A0, A0, 16
9D02EAC4  008A2025   OR A0, A0, T2
9D02EAC8  0085502B   SLTU T2, A0, A1
9D02EACC  00C3001B   DIVU A2, V1
9D02EAD0  006001F4   TEQ V1, ZERO
9D02EAD4  5140FF60   BEQL T2, ZERO, .LBB17
9D02EAD8  00852823   SUBU A1, A0, A1
9D02EADC  00882021   ADDU A0, A0, T0
9D02EAE0  0088302B   SLTU A2, A0, T0
9D02EAE4  54C0FF5C   BNEL A2, ZERO, .LBB17
9D02EAE8  00852823   SUBU A1, A0, A1
9D02EAEC  0085502B   SLTU T2, A0, A1
9D02EAF0  00883021   ADDU A2, A0, T0
9D02EAF4  00CA200B   MOVN A0, A2, T2
9D02EAF8  0B40BA16   J .LBB17
9D02EAFC  00852823   SUBU A1, A0, A1
9D02EB00  01063023   SUBU A2, T0, A2
9D02EB04  01271823   SUBU V1, T1, A3
9D02EB08  0106402B   SLTU T0, T0, A2
9D02EB0C  00681823   SUBU V1, V1, T0
9D02EB10  0B40BA86   J .LBB24
9D02EB14  00431823   SUBU V1, V0, V1
9D02EB18  004E282B   SLTU A1, V0, T6
9D02EB1C  50A0FFB4   BEQL A1, ZERO, 0x9D02E9F0
9D02EB20  00084400   SLL T0, T0, 16
9D02EB24  246DFFFE   ADDIU T5, V1, -2
9D02EB28  0B40BA7B   J 0x9D02E9EC
9D02EB2C  00471021   ADDU V0, V0, A3
9D02EB30  00C82021   ADDU A0, A2, T0
9D02EB34  0B40BAA9   J 0x9D02EAA4
9D02EB38  008A300B   MOVN A2, A0, T2
9D02EB3C  0088182B   SLTU V1, A0, T0
9D02EB40  5460FFF0   BNEL V1, ZERO, 0x9D02EB04
9D02EB44  01063023   SUBU A2, T0, A2
9D02EB48  00003012   MFLO A2
9D02EB4C  0B40BA86   J .LBB24
9D02EB50  00001821   ADDU V1, ZERO, ZERO
9D02EF9C  03E00008   JR RA
9D02EFA0  24020001   ADDIU V0, ZERO, 1
9D02EFA4  0B40BB44   J 0x9D02ED10
9D02EFA8  00C83021   ADDU A2, A2, T0
---  /Applications/microchip/xc32/v2.05/pic32mx/include/lega-c/peripheral/system.h  ---------------------
1:                   /********************************************************************
2:                   
3:                   	System Library Interface Definition
4:                   	
5:                   	Summary:
6:                   		This file contains the interface definition for the System
7:                   		peripheral library.
8:                   		
9:                   	Description:
10:                  		This library provides functions for configuring the peripheral
11:                  		clock, cache settings, and wait states.  For details on the
12:                  		register and bit settings used by these functions, refer to the
13:                  		PIC32 Family Reference Manual.
14:                  
15:                  
16:                   ********************************************************************/
17:                  //DOM-IGNORE-BEGIN
18:                  /********************************************************************
19:                   * FileName:		System.h
20:                   * Dependencies:
21:                   * Processor:		PIC32
22:                   * Hardware:		N/A
23:                   * Assembler:		N/A
24:                   * Linker:		    N/A
25:                   * Company:		    Microchip Technology Inc.
26:                   *
27:                   * Software License Agreement:
28:                   * The software supplied herewith by Microchip Technology Incorporated
29:                   * (the Company) for its PICmicro Microcontroller is intended and
30:                   * supplied to you, the Companys customer, for use solely and
31:                   * exclusively on Microchip PICmicro Microcontroller products. The
32:                   * software is owned by the Company and/or its supplier, and is
33:                   * protected under applicable copyright laws. All rights are reserved.
34:                   * Any use in violation of the foregoing restrictions may subject the
35:                   * user to criminal sanctions under applicable laws, as well as to
36:                   * civil liability for the breach of the terms and conditions of this
37:                   * license.
38:                   *
39:                   * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
40:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
41:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
42:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
43:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
44:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
45:                   *
46:                   * $Id: CoreTimer.h,v 1.2 2006/11/03 15:07:21 C12923 Exp $
47:                   * $Name:  $
48:                   ********************************************************************/
49:                  //DOM-IGNORE-END
50:                   
51:                   
52:                  #ifndef _SYSTEM_HEADER_FILE
53:                  #define _SYSTEM_HEADER_FILE
54:                  
55:                  #include <xc.h>
56:                  #include <peripheral/int.h>
57:                  #include <peripheral/pcache.h>
58:                  #include <peripheral/osc.h>
59:                  #include <peripheral/dma.h>
60:                  #include <peripheral/bmx.h>
61:                  #include <peripheral/lock.h>
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  
67:                  /*
68:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
69:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
70:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
71:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
72:                  */
73:                  #ifndef _SUPPRESS_PLIB_WARNING
74:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
75:                  #endif
76:                  
77:                  
78:                  
79:                  #define FLASH_SPEED_HZ          30000000 //Max Flash speed
80:                  #define PB_BUS_MAX_FREQ_HZ      80000000 //Max Peripheral bus speed
81:                  
82:                  /*********************************************************************
83:                   * SYSTEMConfig Flags
84:                   *********************************************************************/
85:                  #define SYS_CFG_WAIT_STATES     0x00000001 //SYSTEMConfig wait states
86:                  #define SYS_CFG_PB_BUS          0x00000002 //SYSTEMConfig pb bus
87:                  #define SYS_CFG_PCACHE          0x00000004 //SYSTEMConfig cache
88:                  #define SYS_CFG_ALL             0xFFFFFFFF //SYSTEMConfig All
89:                  
90:                  /*********************************************************************
91:                   Function:       
92:                  	unsigned int SYSTEMConfigPB(unsigned int sys_clock)
93:                   
94:                   Description:
95:                  	The function sets the PB divider to the optimum value.
96:                   
97:                   PreCondition:    
98:                  	None
99:                   
100:                  Parameters:           
101:                 	sys_clock - system clock in Hz
102:                  
103:                  Returns:          
104:                 	the PB clock frequency in Hz
105:                  
106:                  Side Effects:
107:                 	The PB clock may be changed
108:                 	
109:                  Overview:	    
110:                 	The function sets the PB divider to the optimum value.
111:                  
112:                  Remarks:            
113:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
114:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
115:                  
116:                  Example:
117:                 	<code>
118:                 	SYSTEMConfigPB(72000000);
119:                 	</code>
120:                  ********************************************************************/
121:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPB(unsigned int sys_clock)
122:                 {
123:                     unsigned int pb_div;
124:                     unsigned int pb_clock;
125:                 
126:                     pb_clock = sys_clock;
127:                 
128:                     if(sys_clock > PB_BUS_MAX_FREQ_HZ)
129:                     {
130:                         pb_div=OSC_PB_DIV_2;
131:                         pb_clock >>= 1;
132:                     }
133:                     else
134:                     {
135:                         pb_div=OSC_PB_DIV_1;
136:                     }
137:                 
138:                     OSCSetPBDIV(pb_div);
139:                 
140:                     return pb_clock;
141:                 }
142:                 
143:                 
144:                 /*********************************************************************
145:                   Function:        
146:                 	void SYSTEMConfigWaitStates(unsigned int sys_clock)
147:                  
148:                   Description:
149:                 	The function sets the Flash Wait states to the optimum value.
150:                  
151:                   PreCondition:    
152:                 	None
153:                  
154:                   Parameters:           
155:                 	sys_clock - system clock in Hz
156:                  
157:                   Returns:          
158:                 	None
159:                  
160:                   Side Effects:    
161:                 	The Wait States may be changed  
162:                  
163:                   Remarks:         
164:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
165:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
166:                  
167:                   Example:
168:                 	<code>
169:                 	SYSTEMConfigWaitStates(72000000);
170:                 	</code>
171:                  ********************************************************************/
172:                 extern inline void __attribute__((always_inline)) SYSTEMConfigWaitStates(unsigned int sys_clock)
173:                 {
174:                 #ifdef _PCACHE
175:                     unsigned int wait_states;
176:                     unsigned int int_status;
177:                 #endif
178:                 
179:                 #ifdef _PCACHE
180:                     wait_states = 0;
181:                 
182:                     while(sys_clock > FLASH_SPEED_HZ)
183:                     {
184:                         wait_states++;
185:                         sys_clock -= FLASH_SPEED_HZ;
186:                     }
187:                 
188:                     int_status=INTDisableInterrupts();
189:                     mCheConfigure(wait_states);
190:                     INTRestoreInterrupts(int_status);
191:                 
192:                 #endif
193:                 }
194:                 
195:                 /*********************************************************************
196:                   Function:        
197:                 		unsigned int SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
198:                   
199:                   Description:
200:                 	The function sets the PB divider and the Flash Wait states to the optimum value.
201:                  
202:                   PreCondition:    
203:                 	None
204:                  
205:                   Parameters:           
206:                 	sys_clock - system clock in Hz
207:                  
208:                   Returns:          
209:                 	the PB clock frequency in Hz
210:                  
211:                   Side Effects:    
212:                 	The PB clock and wait states may be changed
213:                 
214:                   Remarks:            
215:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
216:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
217:                  
218:                   Example:
219:                 	<code>
220:                 	SYSTEMConfigWaitStatesAndPB(72000000);
221:                 	</code>
222:                  ********************************************************************/
223:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
224:                 {
225:                 #ifdef _PCACHE
226:                     unsigned int wait_states;
227:                 #endif
228:                     unsigned int pb_clock;
229:                     unsigned int int_status;
230:                 
231:                     pb_clock = SYSTEMConfigPB(sys_clock);
232:                 
233:                 
234:                     // set the flash wait states based on 1 wait state
235:                     // for every 20 MHz
236:                 #ifdef _PCACHE
237:                     wait_states = 0;
238:                 
239:                     while(sys_clock > FLASH_SPEED_HZ)
240:                     {
241:                         wait_states++;
242:                         sys_clock -= FLASH_SPEED_HZ;
243:                     }
244:                 
245:                     int_status=INTDisableInterrupts();
9D01E70C  0F40F0FB   JAL INTDisableInterrupts
9D01E710  3C11BF88   LUI S1, -16504
246:                     mCheConfigure(wait_states);
9D01E714  24100001   ADDIU S0, ZERO, 1
9D01E718  AE304000   SW S0, 16384(S1)
247:                     INTRestoreInterrupts(int_status);
9D01E71C  0F40EFF2   JAL INTRestoreInterrupts
9D01E720  00402021   ADDU A0, V0, ZERO
248:                 
249:                 #endif
250:                 
251:                     return pb_clock;
252:                 }
253:                 /*********************************************************************
254:                   Function:       
255:                 	unsigned int SYSTEMConfigPerformance(unsigned int sys_clock)
256:                  
257:                   Description:
258:                 	The function sets the PB divider, the Flash Wait states and the DRM wait states to the optimum value.
259:                     It also enables the cacheability for the K0 segment.
260:                 	
261:                   PreCondition:    
262:                 	None
263:                  
264:                   Parameters:           
265:                 	sys_clock - system clock in Hz
266:                  
267:                   Output:          
268:                 	the PB clock frequency in Hz
269:                  
270:                   Side Effects:    
271:                 	Sets the PB and Flash Wait states
272:                  	
273:                   Remarks:            
274:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
275:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
276:                  
277:                   Example:
278:                 	<code>
279:                 	SYSTEMConfigPerformance(72000000);
280:                 	</code>
281:                  ********************************************************************/
282:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPerformance(unsigned int sys_clock)
283:                 {
284:                     // set up the wait states
285:                     unsigned int pb_clk;
286:                 #ifdef _PCACHE
287:                     unsigned int cache_status;
288:                 #endif
289:                     unsigned int int_status;
290:                 
291:                     pb_clk = SYSTEMConfigWaitStatesAndPB(sys_clock);
292:                 
293:                     int_status=INTDisableInterrupts();
9D01E724  0F40F0FB   JAL INTDisableInterrupts
9D01E728  00000000   NOP
9D01E72C  00409021   ADDU S2, V0, ZERO
294:                 
295:                     mBMXDisableDRMWaitState();
9D01E730  24030040   ADDIU V1, ZERO, 64
9D01E734  3C02BF88   LUI V0, -16504
9D01E738  AC432004   SW V1, 8196(V0)
296:                 
297:                 #ifdef _PCACHE
298:                     cache_status = mCheGetCon();
9D01E73C  8E224000   LW V0, 16384(S1)
299:                     cache_status |= CHE_CONF_PF_ALL;
9D01E740  34420030   ORI V0, V0, 48
300:                     mCheConfigure(cache_status);
9D01E744  AE224000   SW V0, 16384(S1)
301:                     CheKseg0CacheOn();
9D01E748  0F40F043   JAL CheKseg0CacheOn
9D01E74C  00000000   NOP
302:                 #endif
303:                 
304:                     INTRestoreInterrupts(int_status);
9D01E750  0F40EFF2   JAL INTRestoreInterrupts
9D01E754  02402021   ADDU A0, S2, ZERO
305:                 
306:                     return pb_clk;
307:                 
308:                 }
309:                 /*********************************************************************
310:                   Function:       
311:                 	unsigned int SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
312:                  
313:                   Description:
314:                 	The function sets the PB divider, the Flash Wait states or the DRM wait states to the optimum value, 
315:                 	based on the flags selected and on the frequency of the system clock.
316:                     It also enables the cacheability for the K0 segment.
317:                 				   
318:                   PreCondition:    
319:                 	None
320:                  
321:                   Parameters:           
322:                 	sys_clock - system clock frequency in Hz
323:                     flags -
324:                 		*    SYS_CFG_WAIT_STATES  - configure the flash wait states from the system clock
325:                         *    SYS_CFG_PB_BUS       - configure the PB bus from the system clock
326:                         *    SYS_CFG_PCACHE      - configure the pCache (if used)
327:                         *    SYS_CFG_ALL          - configure all based on system clock
328:                  
329:                   Returns:          
330:                 	the PB clock frequency in Hz
331:                  
332:                   Side Effects:    
333:                 	Could change the wait state, pb clock and turn on the pre-fetch buffer and cache. Sets the RAM
334:                     wait state to 0.
335:                   
336:                  
337:                   Remarks:
338:                 	The interrupts are disabled shortly, the DMA is suspended and the system is unlocked while performing the operation.
339:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
340:                  
341:                   Example:
342:                 	<code>
343:                 	SYSTEMConfig(72000000, SYS_CFG_ALL);
344:                 	</code>
345:                  ********************************************************************/
346:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
347:                 {
348:                     unsigned int pb_clk;
349:                     unsigned int int_status;
350:                 #ifdef _PCACHE
351:                     unsigned int cache_status;
352:                 #endif
353:                 
354:                     int_status=INTDisableInterrupts();
355:                 
356:                     mBMXDisableDRMWaitState();
357:                 
358:                     if(flags & SYS_CFG_WAIT_STATES)
359:                     {
360:                         SYSTEMConfigWaitStates(sys_clock);
361:                     }
362:                 
363:                     if(flags & SYS_CFG_PB_BUS)
364:                     {
365:                         SYSTEMConfigPB(sys_clock);
366:                     }
367:                 
368:                 
369:                 #ifdef _PCACHE
370:                     if(flags & SYS_CFG_PCACHE)
371:                     {
372:                         cache_status = mCheGetCon();
373:                         cache_status |= CHE_CONF_PF_ALL;
374:                         mCheConfigure(cache_status);
375:                         CheKseg0CacheOn();
376:                     }
377:                 #endif
378:                 
379:                     pb_clk = sys_clock;
380:                     pb_clk >>= OSCCONbits.PBDIV;
381:                 
382:                     INTRestoreInterrupts(int_status);
383:                 
384:                     return pb_clk;
385:                 
386:                 }
387:                 #ifdef __cplusplus
388:                   }
389:                 #endif
390:                 #endif
391:                 
---  /Applications/microchip/xc32/v2.05/pic32mx/include/lega-c/peripheral/osc.h  ------------------------
1:                   /*********************************************************************
2:                    *
3:                    *                  OSC API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        OSC.h
7:                    * Dependencies:
8:                    * Processor:       PIC32
9:                    *
10:                   *
11:                   * Compiler:        MPLAB XC32
12:                   *                  MPLAB IDE
13:                   * Company:         Microchip Technology Inc.
14:                   *
15:                   * Software License Agreement
16:                   *
17:                   * The software supplied herewith by Microchip Technology Incorporated
18:                   * (the Company) for its PIC Microcontroller is intended
19:                   * and supplied to you, the Companys customer, for use solely and
20:                   * exclusively on Microchip PIC Microcontroller products.
21:                   * The software is owned by the Company and/or its supplier, and is
22:                   * protected under applicable copyright laws. All rights are reserved.
23:                   * Any use in violation of the foregoing restrictions may subject the
24:                   * user to criminal sanctions under applicable laws, as well as to
25:                   * civil liability for the breach of the terms and conditions of this
26:                   * license.
27:                   *
28:                   * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
29:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
30:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
31:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
32:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
33:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
34:                   *
35:                   *
36:                   * $Id: OSC.h,v 1.6 2006/10/13 21:24:31 C12532 Exp $
37:                   * $Name:  $
38:                   ********************************************************************/
39:                  
40:                  #ifndef OSC_H_
41:                  #define OSC_H_
42:                  
43:                  #include <xc.h>
44:                  #include <peripheral/lock.h>
45:                  
46:                  /*
47:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
48:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
49:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
50:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
51:                  */
52:                  #ifndef _SUPPRESS_PLIB_WARNING
53:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
54:                  #endif
55:                  
56:                  
57:                  #define _OSC_
58:                  
59:                  /*********************************************************************
60:                   * Function:        OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div)
61:                   *
62:                   * Description:     Sets Osc options and clock source
63:                   *
64:                   * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
65:                   *
66:                   * Inputs:          Clock source, PLL multiplier, PLL postscaler, FRC divisor - see below
67:                   *
68:                   * Output:          None
69:                   *
70:                   * Example:         OSCConfig( OSC_POSC, OSC_PLL_MULT_24, OSC_PLL_POST_256, OSC_FRC_POST_64 )
71:                   *
72:                   * Note:            Forces cpu clock source to FRC(no divisor, no PLL), configures new clock
73:                   *                  source and then switches to the new clock source
74:                   *
75:                   *                  Unused parameters are set to zero/default values.
76:                   ********************************************************************/
77:                  void OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div);
78:                  
79:                      /******************************************************************************
80:                       * Available options for source parameter
81:                       *****************************************************************************/
82:                          // CPU Oscillator modes - values are mutually exclusive
83:                          #define OSC_FRC_DIV     (7 << _OSCCON_NOSC_POSITION)
84:                          #define OSC_FRC_DIV16   (6 << _OSCCON_NOSC_POSITION)
85:                          #define OSC_LPRC        (5 << _OSCCON_NOSC_POSITION)
86:                          #define OSC_SOSC        (4 << _OSCCON_NOSC_POSITION)
87:                          #define OSC_POSC_PLL    (3 << _OSCCON_NOSC_POSITION)
88:                          #define OSC_POSC        (2 << _OSCCON_NOSC_POSITION)
89:                          #define OSC_FRC_PLL     (1 << _OSCCON_NOSC_POSITION)
90:                          #define OSC_FRC         (0 << _OSCCON_NOSC_POSITION)
91:                  
92:                      /******************************************************************************
93:                       * Available options for mult parameter
94:                       *****************************************************************************/
95:                          // CPU PLL multiplier values - values are mutually exclusive
96:                          #define OSC_PLL_MULT_24 (7 << _OSCCON_PLLMULT_POSITION)
97:                          #define OSC_PLL_MULT_21 (6 << _OSCCON_PLLMULT_POSITION)
98:                          #define OSC_PLL_MULT_20 (5 << _OSCCON_PLLMULT_POSITION)
99:                          #define OSC_PLL_MULT_19 (4 << _OSCCON_PLLMULT_POSITION)
100:                         #define OSC_PLL_MULT_18 (3 << _OSCCON_PLLMULT_POSITION)
101:                         #define OSC_PLL_MULT_17 (2 << _OSCCON_PLLMULT_POSITION)
102:                         #define OSC_PLL_MULT_16 (1 << _OSCCON_PLLMULT_POSITION)
103:                         #define OSC_PLL_MULT_15 (0 << _OSCCON_PLLMULT_POSITION)
104:                 
105:                     /******************************************************************************
106:                      * Available options for post parameter
107:                      *****************************************************************************/
108:                         // CPU PLL output divisor values - values are mutuallye exclusive
109:                         #define OSC_PLL_POST_256 (7 << _OSCCON_PLLODIV_POSITION)
110:                         #define OSC_PLL_POST_64  (6 << _OSCCON_PLLODIV_POSITION)
111:                         #define OSC_PLL_POST_32  (5 << _OSCCON_PLLODIV_POSITION)
112:                         #define OSC_PLL_POST_16  (4 << _OSCCON_PLLODIV_POSITION)
113:                         #define OSC_PLL_POST_8   (3 << _OSCCON_PLLODIV_POSITION)
114:                         #define OSC_PLL_POST_4   (2 << _OSCCON_PLLODIV_POSITION)
115:                         #define OSC_PLL_POST_2   (1 << _OSCCON_PLLODIV_POSITION)
116:                         #define OSC_PLL_POST_1   (0 << _OSCCON_PLLODIV_POSITION)
117:                 
118:                     /******************************************************************************
119:                      * Available options for div parameter
120:                      *****************************************************************************/
121:                         // CPU FRC output divisor values - values are mutually exclusive
122:                         #define OSC_FRC_POST_256 (7 << _OSCCON_FRCDIV_POSITION)
123:                         #define OSC_FRC_POST_64  (6 << _OSCCON_FRCDIV_POSITION)
124:                         #define OSC_FRC_POST_32  (5 << _OSCCON_FRCDIV_POSITION)
125:                         #define OSC_FRC_POST_16  (4 << _OSCCON_FRCDIV_POSITION)
126:                         #define OSC_FRC_POST_8   (3 << _OSCCON_FRCDIV_POSITION)
127:                         #define OSC_FRC_POST_4   (2 << _OSCCON_FRCDIV_POSITION)
128:                         #define OSC_FRC_POST_2   (1 << _OSCCON_FRCDIV_POSITION)
129:                         #define OSC_FRC_POST_1   (0 << _OSCCON_FRCDIV_POSITION)
130:                     /***********************************
131:                      * End parameter values
132:                      ************************************/
133:                 
134:                 #if defined(__32MX120F064H__) || \
135:                     defined(__32MX130F128H__) || \
136:                     defined(__32MX130F128L__) || \
137:                     defined(__32MX150F256H__) || \
138:                     defined(__32MX150F256L__) || \
139:                     defined(__32MX170F512H__) || \
140:                     defined(__32MX170F512L__) || \
141:                     defined(__32MX230F128H__) || \
142:                     defined(__32MX230F128L__) || \
143:                     defined(__32MX250F256H__) || \
144:                     defined(__32MX250F256L__) || \
145:                     defined(__32MX270F512H__) || \
146:                     defined(__32MX270F512L__) || \
147:                     defined(__32MX530F128H__) || \
148:                     defined(__32MX530F128L__) || \
149:                     defined(__32MX550F256H__) || \
150:                     defined(__32MX550F256L__) || \
151:                     defined(__32MX570F512H__) || \
152:                     defined(__32MX570F512L__)
153:                   #define NEED_OSCREFCONFIG_FLAGS
154:                 #elif (__PIC32_FEATURE_SET__ >= 100) && (__PIC32_FEATURE_SET__ <= 299)
155:                   #define NEED_OSCREFCONFIG_FLAGS
156:                 #elif (__PIC32_FEATURE_SET__ == 330) || \
157:                       (__PIC32_FEATURE_SET__ == 350) || \
158:                       (__PIC32_FEATURE_SET__ == 370) || \
159:                       (__PIC32_FEATURE_SET__ == 430) || \
160:                       (__PIC32_FEATURE_SET__ == 450) || \
161:                       (__PIC32_FEATURE_SET__ == 470)
162:                   #define NEED_OSCREFCONFIG_FLAGS
163:                 #else
164:                   #undef  NEED_OSCREFCONFIG_FLAGS
165:                 #endif
166:                 
167:                 #if defined( NEED_OSCREFCONFIG_FLAGS )
168:                   // Reference Oscillator Source Select bits - values are mutually exclusive
169:                   #define OSC_REFOCON_REFCLKI     (7 << _REFOCON_ROSEL_POSITION )
170:                   #define OSC_REFOCON_SYSPLL      (7 << _REFOCON_ROSEL_POSITION )
171:                   #define OSC_REFOCON_USBPLL      (6 << _REFOCON_ROSEL_POSITION )
172:                   #define OSC_REFOCON_SOSC        (5 << _REFOCON_ROSEL_POSITION )
173:                   #define OSC_REFOCON_LPRC        (4 << _REFOCON_ROSEL_POSITION )
174:                   #define OSC_REFOCON_FRC         (3 << _REFOCON_ROSEL_POSITION )
175:                   #define OSC_REFOCON_POSC        (2 << _REFOCON_ROSEL_POSITION )
176:                   #define OSC_REFOCON_PBCLK       (1 << _REFOCON_ROSEL_POSITION )
177:                   #define OSC_REFOCON_SYSCLK      (0 << _REFOCON_ROSEL_POSITION )
178:                 
179:                   typedef enum
180:                   {
181:                       OSC_REFOCON_RLSPEN      =(1 << _REFOCON_RSLP_POSITION ) ,
182:                       OSC_REFOCON_OE          =(1 << _REFOCON_OE_POSITION ),
183:                       OSC_REFOCON_SIDLEN      =(1 << _REFOCON_SIDL_POSITION ),
184:                       OSC_REFOCON_ON          =(1 << _REFOCON_ON_POSITION )
185:                   } OSCREFConfigFlags;
186:                 
187:                   void OSCREFConfig(unsigned long int source, OSCREFConfigFlags config, unsigned long int div);
188:                 
189:                   #define mOSCREFOTRIMSet(trim)       (REFOTRIM = (trim << _REFOTRIM_ROTRIM_POSITION))
190:                 
191:                 #endif//defined( NEED_OSCREFCONFIG_FLAGS )
192:                 
193:                 #undef  NEED_OSCREFCONFIG_FLAGS
194:                 
195:                 
196:                 /*********************************************************************
197:                  * Function:    OSCSetPBDIV(unsigned int oscPbDiv)
198:                  *
199:                  * Description: Configures peripheral bus divisor
200:                  *
201:                  * PreCondition: oscPbDiv one of the OSC_PB_DIV_X valid values
202:                  *
203:                  * Inputs:    oscPbDiv - desired PB divider
204:                  *
205:                  * Output:      None
206:                  *
207:                  * Example:   OSCSetPBDIV(  OSC_PB_DIV_8 )
208:                  *
209:                  ********************************************************************/
210:                 extern inline void __attribute__((always_inline)) OSCSetPBDIV(unsigned int oscPbDiv)
211:                 {
212:                     unsigned int dma_status;
213:                     unsigned int int_status;
214:                     __OSCCONbits_t oscBits;
215:                 
216:                     mSYSTEMUnlock(int_status, dma_status);
9D01E6A8  0F40F0FB   JAL INTDisableInterrupts
9D01E6AC  AFB00010   SW S0, 16(SP)
9D01E6E4  0B407ABF   J 0x9D01EAFC
9D01E6E8  3C05BF81   LUI A1, -16511
9D01EAFC  ACA0F230   SW ZERO, -3536(A1)
9D01EB00  3C03AA99   LUI V1, -21863
9D01EB04  24636655   ADDIU V1, V1, 26197
9D01EB08  ACA3F230   SW V1, -3536(A1)
9D01EB0C  3C035566   LUI V1, 21862
9D01EB10  346399AA   ORI V1, V1, -26198
9D01EB14  ACA3F230   SW V1, -3536(A1)
9D01EB4C  ACA0F230   SW ZERO, -3536(A1)
9D01EB50  3C03AA99   LUI V1, -21863
9D01EB54  24636655   ADDIU V1, V1, 26197
9D01EB58  ACA3F230   SW V1, -3536(A1)
9D01EB5C  3C035566   LUI V1, 21862
9D01EB60  346399AA   ORI V1, V1, -26198
9D01EB64  ACA3F230   SW V1, -3536(A1)
217:                 
218:                     oscBits.w=OSCCON;       // read to be in sync. flush any pending write
9D01EB18  3C04BF81   LUI A0, -16511
9D01EB1C  8C83F000   LW V1, -4096(A0)
9D01EB68  3C04BF81   LUI A0, -16511
9D01EB6C  8C83F000   LW V1, -4096(A0)
219:                     oscBits.PBDIV=0;
9D01EB20  7C03A4C4   INS V1, ZERO, 19, 2
9D01EB70  7C03A4C4   INS V1, ZERO, 19, 2
220:                     oscBits.w|=oscPbDiv;
221:                     OSCCON=oscBits.w;       // write back
9D01EB24  AC83F000   SW V1, -4096(A0)
9D01EB74  AC83F000   SW V1, -4096(A0)
222:                     oscBits.w=OSCCON;       // make sure the write occurred before returning from this function
9D01EB28  8C83F000   LW V1, -4096(A0)
9D01EB78  8C83F000   LW V1, -4096(A0)
223:                 
224:                     mSYSTEMLock(int_status, dma_status);
9D01E704  0F40EFF2   JAL INTRestoreInterrupts
9D01E708  00402021   ADDU A0, V0, ZERO
9D01EB2C  3C033333   LUI V1, 13107
9D01EB30  24633333   ADDIU V1, V1, 13107
9D01EB34  ACA3F230   SW V1, -3536(A1)
9D01EB7C  3C033333   LUI V1, 13107
9D01EB80  24633333   ADDIU V1, V1, 13107
9D01EB84  ACA3F230   SW V1, -3536(A1)
225:                 }
226:                 
227:                 #define     mOSCSetPBDIV        OSCSetPBDIV     // backward compatibility
228:                 
229:                 
230:                 
231:                     /******************************************************************************
232:                      * Available options for config parameter
233:                      *****************************************************************************/
234:                         // CPU Peripheral Bus divisor values - values are mutually exclusive
235:                         #define OSC_PB_DIV_8    (3 << _OSCCON_PBDIV_POSITION)
236:                         #define OSC_PB_DIV_4    (2 << _OSCCON_PBDIV_POSITION)
237:                         #define OSC_PB_DIV_2    (1 << _OSCCON_PBDIV_POSITION)
238:                         #define OSC_PB_DIV_1    (0 << _OSCCON_PBDIV_POSITION)
239:                     /***********************************
240:                      * End config parameter values
241:                      ************************************/
242:                 
243:                 
244:                 /*********************************************************************
245:                  * Function:    mOSCGetPBDIV()
246:                  *
247:                  * Description: Reads peripheral bus divisor
248:                  *
249:                  * PreCondition:None
250:                  *
251:                  * Inputs:      None
252:                  *
253:                  * Output:      None
254:                  *
255:                  * Example:     mOSCGetPBDIV()
256:                  *
257:                  ********************************************************************/
258:                 #define mOSCGetPBDIV() (OSCCONbits.PBDIV)
259:                 
260:                 
261:                 /*********************************************************************
262:                  * Function:    mOSCClockFailStatus()
263:                  *
264:                  * Description: Returns Clock Fail status. 1 = clock fail, 0 = no clock fail
265:                  *
266:                  * PreCondition: None
267:                  *
268:                  * Inputs:      None
269:                  *
270:                  * Output:      None
271:                  *
272:                  * Example:     mOSCClockFailStatus()
273:                  *
274:                  ********************************************************************/
275:                 #define mOSCClockFailStatus (OSCCONbits.CF)
276:                 
277:                 
278:                 /*********************************************************************
279:                  * Function:        mOSCEnableSOSC()
280:                  *
281:                  * Description:     Enables the LPRC
282:                  *
283:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
284:                  *
285:                  * Inputs:          None
286:                  *
287:                  * Output:          None
288:                  *
289:                  * Example:         mOSCEnableSOSC()
290:                  *
291:                  ********************************************************************/
292:                 #define mOSCEnableSOSC() mSysUnlockOpLock(OSCCONSET = _OSCCON_SOSCEN_MASK)
293:                 
294:                 
295:                 /*********************************************************************
296:                  * Function:        mOSCDisableSOSC(config)
297:                  *
298:                  * Description:     Disables SOSC
299:                  *
300:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
301:                  *
302:                  * Inputs:          None
303:                  *
304:                  * Output:          None
305:                  *
306:                  * Example:         mOSCDisableSOSC()
307:                  *
308:                  ********************************************************************/
309:                 #define mOSCDisableSOSC() mSysUnlockOpLock(OSCCONCLR = _OSCCON_SOSCEN_MASK)
310:                 
311:                 
312:                 
313:                 #endif
---  /Applications/microchip/xc32/v2.05/pic32mx/include/lega-c/peripheral/dma_1xx_2xx.h  ----------------
1:                   /*********************************************************************
2:                    *
3:                    *                  DMA API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        Dma.h
7:                    * Dependencies:    xc.h
8:                    *                  int.h
9:                    *
10:                   * Processor:       PIC32
11:                   *
12:                   * Compiler:        MPLAB XC32
13:                   *                  MPLAB IDE
14:                   * Company:         Microchip Technology Inc.
15:                   *
16:                   * Software License Agreement
17:                   *
18:                   * The software supplied herewith by Microchip Technology Incorporated
19:                   * (the Company) for its PIC32/PIC24F Microcontroller is intended
20:                   * and supplied to you, the Companys customer, for use solely and
21:                   * exclusively on Microchip PIC32/PIC24F Microcontroller products.
22:                   * The software is owned by the Company and/or its supplier, and is
23:                   * protected under applicable copyright laws. All rights are reserved.
24:                   * Any use in violation of the foregoing restrictions may subject the
25:                   * user to criminal sanctions under applicable laws, as well as to
26:                   * civil liability for the breach of the terms and conditions of this
27:                   * license.
28:                   *
29:                   * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
30:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
31:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
32:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
33:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
34:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
35:                   *
36:                   *
37:                   * $Id: Dma.h,v 1.9 2007/01/17 21:35:46 C12878 Exp $
38:                   * $Name:  $
39:                   *
40:                   ********************************************************************/
41:                  
42:                  #ifndef _DMA_1XX_2XX_H_
43:                  #define _DMA_1XX_2XX_H_
44:                  
45:                  #include <xc.h>
46:                  
47:                  /*
48:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
49:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
50:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
51:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
52:                  */
53:                  #ifndef _SUPPRESS_PLIB_WARNING
54:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
55:                  #endif
56:                  
57:                  
58:                  // DMA definitions
59:                  
60:                  #ifdef _DMAC0
61:                      #define _DMA_CHANNELS       // DMA channels exist
62:                  
63:                  
64:                  // existent DMA channels
65:                      typedef enum
66:                      {
67:                          DMA_CHANNEL0,
68:                      #ifdef _DMAC1
69:                          DMA_CHANNEL1,
70:                      # ifdef _DMAC2
71:                          DMA_CHANNEL2,
72:                      #  ifdef _DMAC3
73:                          DMA_CHANNEL3,
74:                      #  endif// _DMAC3
75:                      # endif // _DMAC2
76:                      #endif  // _DMAC1
77:                          //  add/remove DMA channel as needed here
78:                  
79:                          DMA_CHANNELS    // number of current available channels
80:                      }DmaChannel;
81:                  
82:                  
83:                      // Relative Dma channels priority, between each other
84:                      typedef enum
85:                      {
86:                          DMA_CHN_PRI0,
87:                          DMA_CHN_PRI1,
88:                          DMA_CHN_PRI2,
89:                          DMA_CHN_PRI3
90:                      }DmaChannelPri;
91:                  
92:                  
93:                  
94:                      // high level definitions for the API functions
95:                  
96:                      typedef enum
97:                      {
98:                          DMA_OPEN_DEFAULT = 0,                                   // DMA default operation
99:                          DMA_OPEN_AUTO   = _DCH0CON_CHAEN_MASK,                  // DMA channel is auto enabled
100:                         DMA_OPEN_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK),   // DMA channel is chained to lower channel
101:                         DMA_OPEN_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),             // DMA channel is chained to higher channel
102:                         DMA_OPEN_DET_EN = _DCH0CON_CHAED_MASK,                  // events detection enabled while channel off
103:                         DMA_OPEN_ENABLE = _DCH0CON_CHEN_MASK,                   // DMA channel is enabled after open
104:                         DMA_OPEN_MATCH  = 0x80000000,                           // DMA channel stops on match
105:                     }DmaOpenFlags;  // flags for the channel open
106:                 
107:                 
108:                     typedef enum
109:                     {
110:                         DMA_EV_ERR =            0x1,        // address error event
111:                         DMA_EV_ABORT =          0x2,        // transfer abort event
112:                         DMA_EV_CELL_DONE =      0x4,        // cell transfer complete event
113:                         DMA_EV_BLOCK_DONE =     0x8,        // block transfer complete event
114:                         DMA_EV_DST_HALF =       0x10,       // destination half event
115:                         DMA_EV_DST_FULL =       0x20,       // destination full event
116:                         DMA_EV_SRC_HALF =       0x40,       // source half event
117:                         DMA_EV_SRC_FULL =       0x80,       // source full event
118:                 
119:                         DMA_EV_ALL_EVNTS=       (DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_CELL_DONE|DMA_EV_BLOCK_DONE|DMA_EV_DST_HALF|
120:                                                     DMA_EV_DST_FULL|DMA_EV_SRC_HALF|DMA_EV_SRC_FULL)                // all available events
121:                     }DmaEvFlags;    // flags for controlling the DMA channel events; Bit fields from the processor header file.
122:                 
123:                 
124:                     typedef enum
125:                     {
126:                         DMA_TXFER_OK,           // the transfer was performed successfully
127:                         DMA_TXFER_ADD_ERR,      // address error while performing the transfer
128:                         DMA_TXFER_ABORT,        // the DMA transfer was aborted
129:                         DMA_TXFER_BC_ERR,       // block complete not set after the DMA transfer performed
130:                         DMA_TXFER_CC_ERR,       // cell complete not set after the DMA transfer performed
131:                         DMA_TXFER_TMO           // DMA transfer timeout
132:                     }DmaTxferRes;       // DMA transfer result
133:                 
134:                     typedef enum
135:                     {
136:                         DMA_WAIT_NOT,       // don't wait for the transfer to complete, return immediately
137:                         DMA_WAIT_CELL,      // wait for the cell transfer to complete, than return
138:                         DMA_WAIT_BLOCK      // wait for the block transfer to complete, than return
139:                     }DmaWaitMode;       // DMA transfer wait mode
140:                 
141:                     typedef enum
142:                     {
143:                         DMA_CHKSUM_CRC,     // LFSR CRC
144:                         DMA_CHKSUM_IP,      // IP Checksum
145:                     }DmaChksumType;     // DMA SFM supported checksum types
146:                 
147:                     typedef enum
148:                     {
149:                         DMA_BITO_MSb,       // MSb first (not reflected)
150:                         DMA_BITO_LSb,       // LSb first (reflected)
151:                     }DmaBitOrder;       // DMA SFM supported bit ordering
152:                 
153:                     typedef enum
154:                     {
155:                         DMA_REORDER_NOT,    // no reordering, destination matches the source
156:                         DMA_REORDER_ENDIAN, // change endianess on word (32 bit) boundaries: LE<->BE
157:                         DMA_REORDER_SWAP_HALF,  // swap half words (16 bit) within word (32 bit)
158:                         DMA_REORDER_SWAP_BYTE,  // swap bytes within half word (16 bit)
159:                     }DmaReorderMode;    // DMA SFM supported re-ordering modes
160:                 
161:                 
162:                     /*********************************************************************
163:                      * Function:        void DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags)
164:                      *
165:                      * PreCondition:    chPri  - valid channel priority, 0-3
166:                      *
167:                      * Input:           chn    - channel to be configured in the DMA controller
168:                      *                  chPri  - the priority given to the channel, 0-3
169:                      *                  oFlags - orred flags specifying the open mode:
170:                      *                           DMA_OPEN_DEFAULT: DMA default operation mode
171:                      *                           DMA_OPEN_AUTO: DMA channel is auto enabled
172:                      *                           DMA_OPEN_CHAIN_LOW: DMA channel is chained to lower channel
173:                      *                           DMA_OPEN_CHAIN_HI: DMA channel is chained to higher channel
174:                      *                           DMA_OPEN_DET_EN: events detection enabled while channel off
175:                      *                           DMA_OPEN_ENABLE: DMA channel is enabled when opened
176:                      *                           DMA_OPEN_MATCH:    DMA channel stops on match
177:                      *
178:                      *
179:                      *
180:                      * Output:          None
181:                      *
182:                      * Side Effects:    None
183:                      *
184:                      * Overview:        The function opens and configures the selected DMA channel using the supplied user flags and priority.
185:                      *
186:                      * Note:            - This is a high level access function that doesn't give access to all the settings possible for a DMA channel.
187:                      *                  Use the low level functions to address special settings.
188:                      *                  - The channel is turned off, the pending interrupts are cleared, interrupts are disabled.
189:                      *                  After that the channel is configured.
190:                      *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
191:                      *                  if DMA_OPEN_ENABLE flag was not specified.
192:                      *                  - If the CRC is attached to the submitted channel, the CRC append mode will be turned off.
193:                      *                  This way, the transfer will occur correctly together with CRC calculation.
194:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
195:                      *                  User has to call event channel functions to enable the event flags if needed.
196:                      *
197:                      * Example:         DmaChnOpen(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_OPEN_AUTO|DMA_OPEN_MATCH|DMA_OPEN_ENABLE);
198:                      ********************************************************************/
199:                      void           DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags);
200:                 
201:                     /*********************************************************************
202:                      * Function:        void DmaChnEnable(DmaChannel chn)
203:                      *
204:                      * PreCondition:    None
205:                      *
206:                      * Input:           chn     - channel to be enabled
207:                      *
208:                      * Output:          None
209:                      *
210:                      * Side Effects:    None
211:                      *
212:                      * Overview:        The function enables a previously configured DMA channel.
213:                      *
214:                      * Note:            DmaChnOpen()/DmaChnConfigure() should have been called before.
215:                      *
216:                      * Example:         DmaChnEnable(DMA_CHANNEL3);
217:                      ********************************************************************/
218:                      void           DmaChnEnable(DmaChannel chn);
219:                 
220:                     /*********************************************************************
221:                      * Function:        void DmaChnDisable(DmaChannel chn)
222:                      *
223:                      * PreCondition:    None
224:                      *
225:                      * Input:           chn     - selected channel in the DMA controller
226:                      *
227:                      * Output:          None
228:                      *
229:                      * Side Effects:    None
230:                      *
231:                      * Overview:        The function disables a DMA channel. The channel operation stops.
232:                      *
233:                      * Note:            None.
234:                      *
235:                      * Example:         DmaChnDisable(DMA_CHANNEL3);
236:                      ********************************************************************/
237:                      void           DmaChnDisable(DmaChannel chn);
238:                 
239:                     /*********************************************************************
240:                      * Function:        void DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize)
241:                      *
242:                      * PreCondition:    chn     - valid DMA channel
243:                      *              - vSrcAdd, vDstAdd  - valid pointers
244:                      *                              - 0 < srcSize <= DmaGetMaxTxferSize()
245:                      *                              - 0 < dstSize <= DmaGetMaxTxferSize()
246:                      *                              - 0 < cellSize <= DmaGetMaxTxferSize()
247:                      *
248:                      * Input:           chn         - DMA channel number
249:                      *                              - vSrcAdd: source of the DMA transfer
250:                      *                              - vDstAdd: destination of the DMA transfer
251:                      *                              - srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
252:                      *                              - dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
253:                      *                              - cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
254:                      *
255:                      * Output:          None
256:                      *
257:                      * Side Effects:    None
258:                      *
259:                      * Overview:        The function sets the transfer characteristics for a DMA channel transfer:
260:                      *                  the source and the destination addresses.
261:                      *                  the source and destination lengths
262:                      *                  and the number of bytes transferred per event.
263:                      *
264:                      * Note:            The function clears the existing DMA channel event flags.
265:                      *                  The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
266:                      *
267:                      * Example:         DmaChnSetTxfer(DMA_CHANNEL3, &U2RXREG, dstBuff, 1, 200, 1);
268:                      ********************************************************************/
269:                      void           DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize);
270:                 
271:                 
272:                     /*********************************************************************
273:                      * Function:        void DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd)
274:                      *
275:                      * PreCondition:    chn     - valid DMA channel
276:                      *
277:                      * Input:           chn     - DMA channel number
278:                      *              - vSrcAdd: source (virtual) of the DMA transfer
279:                      * Output:          None
280:                      *
281:                      * Side Effects:    None
282:                      *
283:                      * Overview:        The function is a helper to set directly the transfer source address.
284:                      *
285:                      * Note:            None.
286:                      *
287:                      * Example:         DmaChnSetSrcAdd(DMA_CHANNEL2, srcBuff+sizeof(srcBuff));
288:                      ********************************************************************/
289:                      void           DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd);
290:                 
291:                     /*********************************************************************
292:                      * Function:        void DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd)
293:                      *
294:                      * PreCondition:    chn     - valid DMA channel
295:                      *
296:                      * Input:           chn         - DMA channel number
297:                      *                              - vDstAdd: destination (virtual) of the DMA transfer
298:                      * Output:          None
299:                      *
300:                      * Side Effects:    None
301:                      *
302:                      * Overview:        The function is a helper to set directly the transfer destination address.
303:                      *
304:                      * Note:            None
305:                      *
306:                      * Example:         DmaChnSetDstAdd(DMA_CHANNEL2, dstBuff+sizeof(dstBuff));
307:                      ********************************************************************/
308:                      void           DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd);
309:                 
310:                     /*********************************************************************
311:                      * Function:        void DmaChnSetMatchPattern(DmaChannel chn, int pattern)
312:                      *
313:                      * PreCondition:    chn - valid DMA channel
314:                      *
315:                      * Input:           chn     - DMA channel number
316:                      *                  pattern -  the match pattern
317:                      *
318:                      * Output:          None
319:                      *
320:                      * Side Effects:    None
321:                      *
322:                      * Overview:        The function sets the curent match pattern for the selected DMA channel.
323:                      *
324:                      * Note:            None.
325:                      *
326:                      * Example:         DmaChnSetMatchPattern(DMA_CHANNEL3, '\r');
327:                      ********************************************************************/
328:                      void           DmaChnSetMatchPattern(DmaChannel chn, int pattern);
329:                 
330:                     /*********************************************************************
331:                      * Function:        int DmaChnGetMatchPattern(DmaChannel chn)
332:                      *
333:                      * PreCondition:    chn - valid DMA channel
334:                      *
335:                      * Input:           chn     - DMA channel number
336:                      *
337:                      * Output:          The channel match pattern.
338:                      *
339:                      * Side Effects:    None
340:                      *
341:                      * Overview:        The function retrieves the curent match pattern for the selected DMA channel.
342:                      *
343:                      * Note:            None.
344:                      *
345:                      * Example:         int pattern=DmaChnGetMatchPattern(DMA_CHANNEL3);
346:                      ********************************************************************/
347:                      int            DmaChnGetMatchPattern(DmaChannel chn);
348:                 
349:                     /*********************************************************************
350:                      * Function:        DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries)
351:                      *
352:                      * PreCondition:    chn - valid DMA channel
353:                      *
354:                      * Input:           chn     - DMA channel number
355:                      *                  wMode   - if DMA_WAIT_NOT, return immediately
356:                      *                          - if DMA_WAIT_CELL, return after the cell transfer complete
357:                      *                          - if DMA_WAIT_BLOCK, return after the whole transfer is done
358:                      *                  retries - retry counter: if transfer not complete after so many retries, return with tmo.
359:                      *                              If 0, wait forever.
360:                      *
361:                      * Output:          DMA_TXFER_OK if not waiting for the transfer completion or if the transfer ended normally,
362:                      *                  an DmaTxferRes error code  otherwise
363:                      *
364:                      * Side Effects:    None
365:                      *
366:                      * Overview:        The function initiates (forces) a DMA transfer for the selected DMA channel.
367:                      *                  The DMA channel is enabled.
368:                      *                  If waiting for the transfer completion needed (user doesn't use an ISR to catch
369:                      *                  this event) the function will periodically query the DMA controller for the
370:                      *                  transfer completion status.
371:                      *                  If DMA_WAIT_BLOCK is specified and multiple cell transfers are needed to complete
372:                      *                  the block transfer than the function will re-force the transfer for each cell.
373:                      *
374:                      * Note:            This function can not ne used when the DMA channel is triggerred
375:                      *                  by hardware interrupt requests.
376:                      *                  This is because the transfers are software forced, theere is no
377:                      *                  wait for the occurrence of the hardware trigger.
378:                      *
379:                      * Example:         DmaChnStartTxfer(DMA_CHANNEL2, DMA_WAIT_BLOCK, 0);
380:                      ********************************************************************/
381:                      DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries);
382:                 
383:                     /*********************************************************************
384:                      * Function:        void DmaChnForceTxfer(DmaChannel chn)
385:                      *
386:                      * PreCondition:    chn - valid DMA channel
387:                      *
388:                      * Input:           chn     - DMA channel number
389:                      *
390:                      * Output:          None
391:                      *
392:                      * Side Effects:    None
393:                      *
394:                      * Overview:        The function forces a DMA transfer to occur for the selected DMA channel.
395:                      *
396:                      * Note:            None.
397:                      *
398:                      * Example:         DmaChnForceTxfer(DMA_CHANNEL3);
399:                      ********************************************************************/
400:                      void           DmaChnForceTxfer(DmaChannel chn);
401:                 
402:                     /*********************************************************************
403:                      * Function:        void DmaChnAbortTxfer(DmaChannel chn)
404:                      *
405:                      * PreCondition:    chn - valid DMA channel
406:                      *
407:                      * Input:           chn     - DMA channel number
408:                      *
409:                      * Output:          None
410:                      *
411:                      * Side Effects:    None
412:                      *
413:                      * Overview:        The function aborts a current undergoing DMA transfer for the selected DMA channel.
414:                      *
415:                      * Note:            None.
416:                      *
417:                      * Example:         DmaChnAbortTxfer(DMA_CHANNEL3);
418:                      ********************************************************************/
419:                      void           DmaChnAbortTxfer(DmaChannel chn);
420:                 
421:                     // High level channel event and interrupt control functions
422:                 
423:                     /*********************************************************************
424:                      * Function:        void DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
425:                      *
426:                      * PreCondition:    chn - valid DMA channel
427:                      *
428:                      * Input:           chn     - DMA channel number
429:                      *                  eFlags  - event flags with the following significance:
430:                      *                              - DMA_EV_ERR: address error event
431:                      *                              - DMA_EV_ABORT: transfer abort event
432:                      *                              - DMA_EV_CELL_DONE: cell transfer complete event
433:                      *                              - DMA_EV_BLOCK_DONE: block transfer complete event
434:                      *                              - DMA_EV_DST_HALF: destination half event
435:                      *                              - DMA_EV_DST_FULL: destination full event
436:                      *                              - DMA_EV_SRC_HALF: source half event
437:                      *                              - DMA_EV_SRC_FULL: source full event
438:                      *                              - DMA_EV_ALL_EVNTS: all of the above flags
439:                      *
440:                      * Output:          None
441:                      *
442:                      * Side Effects:    None
443:                      *
444:                      * Overview:        The function sets the event enable flags for the selected DMA channel.
445:                      *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
446:                      *                  enabled for the selected channel, the other channel event flags won't be touched.
447:                      *
448:                      * Note:            None.
449:                      *
450:                      * Example:         DmaChnSetEvEnableFlags(DMA_CHANNEL3, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
451:                      ********************************************************************/
452:                      void           DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
453:                 
454:                     /*********************************************************************
455:                      * Function:        void DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
456:                      *
457:                      * PreCondition:    chn - valid DMA channel
458:                      *
459:                      * Input:           chn     - DMA channel number
460:                      *                  eFlags  - event flags with the following significance:
461:                      *                              - DMA_EV_ERR: address error event
462:                      *                              - DMA_EV_ABORT: transfer abort event
463:                      *                              - DMA_EV_CELL_DONE: cell transfer complete event
464:                      *                              - DMA_EV_BLOCK_DONE: block transfer complete event
465:                      *                              - DMA_EV_DST_HALF: destination half event
466:                      *                              - DMA_EV_DST_FULL: destination full event
467:                      *                              - DMA_EV_SRC_HALF: source half event
468:                      *                              - DMA_EV_SRC_FULL: source full event
469:                      *                              - DMA_EV_ALL_EVNTS: all of the above flags
470:                      *
471:                      * Output:          None
472:                      *
473:                      * Side Effects:    None
474:                      *
475:                      * Overview:        The function clears the event enable flags for the selected DMA channel.
476:                      *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
477:                      *                  disabled for the selected channel, the other channel event flags won't be touched.
478:                      *
479:                      * Note:            None.
480:                      *
481:                      * Example:         DmaChnClrEvEnableFlags(DMA_CHANNEL3, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
482:                      ********************************************************************/
483:                      void           DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
484:                 
485:                     /*********************************************************************
486:                      * Function:        void DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
487:                      *
488:                      * PreCondition:    chn - valid DMA channel
489:                      *
490:                      * Input:           chn     - DMA channel number
491:                      *                  eFlags  - event flags with the following significance:
492:                      *                              - DMA_EV_ERR: address error event
493:                      *                              - DMA_EV_ABORT: transfer abort event
494:                      *                              - DMA_EV_CELL_DONE: cell transfer complete event
495:                      *                              - DMA_EV_BLOCK_DONE: block transfer complete event
496:                      *                              - DMA_EV_DST_HALF: destination half event
497:                      *                              - DMA_EV_DST_FULL: destination full event
498:                      *                              - DMA_EV_SRC_HALF: source half event
499:                      *                              - DMA_EV_SRC_FULL: source full event
500:                      *                              - DMA_EV_ALL_EVNTS: all of the above flags
501:                      *
502:                      * Output:          None
503:                      *
504:                      * Side Effects:    None
505:                      *
506:                      * Overview:        The function sets the event enable flags for the selected DMA channel.
507:                      *                  The channel event flags are forced to the eFlags value.
508:                      *
509:                      * Note:            None.
510:                      *
511:                      * Example:         DmaChnWriteEvEnableFlags(DMA_CHANNEL3, DMA_EV_ALL_EVNTS);
512:                      ********************************************************************/
513:                      void           DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
514:                 
515:                     /*********************************************************************
516:                      * Function:        DmaEvFlags DmaChnGetEvEnableFlags(DmaChannel chn)
517:                      *
518:                      * PreCondition:    chn - valid DMA channel
519:                      *
520:                      * Input:           chn     - DMA channel number
521:                      *
522:                      * Output:          - event flags with the following significance:
523:                      *                      - DMA_EV_ERR: address error event
524:                      *                      - DMA_EV_ABORT: transfer abort event
525:                      *                      - DMA_EV_CELL_DONE: cell transfer complete event
526:                      *                      - DMA_EV_BLOCK_DONE: block transfer complete event
527:                      *                      - DMA_EV_DST_HALF: destination half event
528:                      *                      - DMA_EV_DST_FULL: destination full event
529:                      *                      - DMA_EV_SRC_HALF: source half event
530:                      *                      - DMA_EV_SRC_FULL: source full event
531:                      *                      - DMA_EV_ALL_EVNTS: all of the above flags
532:                      *
533:                      * Side Effects:    None
534:                      *
535:                      * Overview:        The function returns the event enabled flags for the selected DMA channel.
536:                      *
537:                      * Note:            None.
538:                      *
539:                      * Example:         DmaEvFlags enabledFlags=DmaChnGetEvEnableFlags(DMA_CHANNEL3);
540:                      ********************************************************************/
541:                      DmaEvFlags DmaChnGetEvEnableFlags(DmaChannel chn);
542:                 
543:                     /*********************************************************************
544:                      * Function:        void DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags)
545:                      *
546:                      * PreCondition:    chn - valid DMA channel
547:                      *
548:                      * Input:           chn     - DMA channel number
549:                      *                  eFlags  - event flags with the following significance:
550:                      *                              - DMA_EV_ERR: address error event
551:                      *                              - DMA_EV_ABORT: transfer abort event
552:                      *                              - DMA_EV_CELL_DONE: cell transfer complete event
553:                      *                              - DMA_EV_BLOCK_DONE: block transfer complete event
554:                      *                              - DMA_EV_DST_HALF: destination half event
555:                      *                              - DMA_EV_DST_FULL: destination full event
556:                      *                              - DMA_EV_SRC_HALF: source half event
557:                      *                              - DMA_EV_SRC_FULL: source full event
558:                      *                              - DMA_EV_ALL_EVNTS: all of the above flags
559:                      *
560:                      * Output:          None
561:                      *
562:                      * Side Effects:    None
563:                      *
564:                      * Overview:        The function clears the event flags for the selected DMA channel.
565:                      *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
566:                      *                  cleared for the selected channel, the other channel event flags won't be touched.
567:                      *
568:                      * Note:            None.
569:                      *
570:                      * Example:         DmaChnClrEvFlags(DMA_CHANNEL3, DMA_EV_ALL_EVNTS);
571:                      ********************************************************************/
572:                      void           DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags);
573:                 
574:                     /*********************************************************************
575:                      * Function:        DmaEvFlags DmaChnGetEvFlags(DmaChannel chn)
576:                      *
577:                      * PreCondition:    chn - valid DMA channel
578:                      *
579:                      * Input:           chn     - DMA channel number
580:                      *
581:                      * Output:          event flags with the following significance:
582:                      *                      - DMA_EV_ERR: address error event
583:                      *                      - DMA_EV_ABORT: transfer abort event
584:                      *                      - DMA_EV_CELL_DONE: cell transfer complete event
585:                      *                      - DMA_EV_BLOCK_DONE: block transfer complete event
586:                      *                      - DMA_EV_DST_HALF: destination half event
587:                      *                      - DMA_EV_DST_FULL: destination full event
588:                      *                      - DMA_EV_SRC_HALF: source half event
589:                      *                      - DMA_EV_SRC_FULL: source full event
590:                      *                      - DMA_EV_ALL_EVNTS: all of the above flags
591:                      *
592:                      * Side Effects:    None
593:                      *
594:                      * Overview:        The function returns the event flags for the selected DMA channel.
595:                      *
596:                      * Note:            None.
597:                      *
598:                      * Example:         DmaEvFlags intSetFlags=DmaChnGetEvFlags(DMA_CHANNEL3);
599:                      ********************************************************************/
600:                      DmaEvFlags DmaChnGetEvFlags(DmaChannel chn);
601:                 
602:                 
603:                     // high level helpers for fast strcpy/memcpy transfers
604:                 
605:                     /*********************************************************************
606:                      * Function:        DmaTxferRes DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri)
607:                      *
608:                      * PreCondition:    chn     - a valid DMA channel
609:                      *                  s1, s2  - valid memory pointers
610:                      *                  n>0, n<=DmaGetMaxTxferSize()
611:                      *
612:                      * Input:           s1      - destination pointer
613:                      *                  s2      - source pointer
614:                      *                  n       - number of bytes to transfer
615:                      *                  chn     - the DMA channel to perform the transfer
616:                      *                  chPri   - the desired channel priority
617:                      *
618:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
619:                      *                  an DmaTxferRes error code  otherwise
620:                      *
621:                      * Side Effects:    None
622:                      *
623:                      * Overview:        The function configures a DMA channel for a fast memory transfer.
624:                      *          Then it copies one block of memory from source to destination.
625:                      *
626:                      *
627:                      * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
628:                      *                    This way, the transfer will occur correctly together with checksum calculation.
629:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
630:                      *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
631:                      *                  - The function clears the suspend state and resumes the operation of the DMA controller.
632:                      *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
633:                      *
634:                      * Example:     res=DmaChnMemcpy(pDst, pSrc, buffSz, DMA_CHANNEL0, DMA_CHN_PRI3);
635:                      ********************************************************************/
636:                      DmaTxferRes    DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri);
637:                 
638:                     /*********************************************************************
639:                      * Function:        DmaTxferRes DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri)
640:                      *
641:                      * PreCondition:    chn     - a valid DMA channel
642:                      *                  s1, s2  - valid memory pointers
643:                      *
644:                      * Input:           s1      - destination pointer
645:                      *                  s2      - source pointer
646:                      *                  chn     - the DMA channel to perform the transfer
647:                      *                  chPri   - the desired channel priority
648:                      *
649:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
650:                      *                  an DmaTxferRes error code  otherwise
651:                      *
652:                      * Side Effects:    None
653:                      *
654:                      * Overview:        The function configures a DMA channel for a fast memory transfer.
655:                      *          Then it copies one zero terminated string from source to destination.
656:                      *
657:                      *
658:                      * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
659:                      *                    This way, the transfer will occur correctly together with checksum calculation.
660:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
661:                      *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
662:                      *                  - The function clears the suspend state and resumes the operation of the DMA controller.
663:                      *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
664:                      *
665:                      *
666:                      * Example:     res=DmaChnStrcpy(str1, str2, DMA_CHANNEL1, DMA_CHN_PRI3);
667:                      *********************************************************************/
668:                      DmaTxferRes    DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri);
669:                 
670:                     /*********************************************************************
671:                      * Function:        DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri)
672:                      *
673:                      * PreCondition:    chn     - a valid DMA channel
674:                      *              - s1, s2    - valid memory pointers
675:                      *                              - 0 < n <= DmaGetMaxTxferSize()
676:                      *
677:                      * Input:           s1      - destination pointer
678:                      *                  s2      - source pointer
679:                      *                  n   - max number of bytes to transfer
680:                      *                  chn     - the DMA channel to perform the transfer
681:                      *                  chPri   - the desired channel priority
682:                      *
683:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
684:                      *                  an DmaTxferRes error code  otherwise
685:                      *
686:                      * Side Effects:    None
687:                      *
688:                      * Overview:        The function configures a DMA channel for a fast memory transfer.
689:                      *          Then it copies one zero terminated string from source to destination.
690:                      *          It copies no more than n characters from s2.
691:                      *
692:                      *
693:                      * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
694:                      *                    This way, the transfer will occur correctly together with checksum calculation.
695:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
696:                      *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
697:                      *                  - The function clears the suspend state and resumes the operation of the DMA controller.
698:                      *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
699:                      *
700:                      *
701:                      * Example:     res=DmaChnStrncpy(str1, str2, MAX_STR_LEN, DMA_CHANNEL1, DMA_CHN_PRI3);
702:                      ********************************************************************/
703:                      DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri);
704:                 
705:                     /*********************************************************************
706:                      * Function:        DmaTxferRes DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri)
707:                      *
708:                      * PreCondition:    chn    - a valid DMA channel
709:                      *                  d, s   - valid memory pointer
710:                      *                  n>0, n<=DmaGetMaxTxferSize()
711:                      *
712:                      * Input:           d     - address where to deposit the result
713:                      *                  s     - source buffer pointer
714:                      *                  n     - number of bytes in the pointer
715:                      *                  chn   - the DMA channel to use
716:                      *                  chPri - the desired channel priority
717:                      *
718:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
719:                      *                  an DmaTxferRes error code  otherwise
720:                      *
721:                      * Side Effects:    None
722:                      *
723:                      * Overview:        The function is a helper that calculates the CRC of a memory block.
724:                      *                  The function configures the DMA channel for a fast memory transfer and calculates the CRC.
725:                      *
726:                      *
727:                      * Note:            - The CRC generator must have been previously configured using DmaSfmCrcConfigure()
728:                      *                  - No transfer is done, just the CRC is calculated.
729:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
730:                      *                  - Append mode is enabled and the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
731:                      *                  - The checksum type is switched to CRC.
732:                      *                  - The way the data is fed into the checksum calculation block is affected by DmaSfmConfigure().
733:                      *
734:                      * Example:          int myCrc; DmaChnMemCrc(&myCrc, srcBuff, sizeof(srcBuff), DMA_CHANNEL2, DMA_CHN_PRI3);
735:                      ********************************************************************/
736:                      DmaTxferRes    DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri);
737:                 
738:                     /*********************************************************************
739:                      * Function:        DmaTxferRes DmaChnMemChecksum(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri)
740:                      *
741:                      * PreCondition:    chn    - a valid DMA channel
742:                      *                  d, s   - valid memory pointer
743:                      *                  n>0, n<=DmaGetMaxTxferSize()
744:                      *
745:                      * Input:           d     - address where to deposit the result
746:                      *                  s     - source buffer pointer
747:                      *                  n     - number of bytes in the pointer
748:                      *                  chn   - the DMA channel to use
749:                      *                  chPri - the desired channel priority
750:                      *
751:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
752:                      *                  an DmaTxferRes error code  otherwise
753:                      *
754:                      * Side Effects:    None
755:                      *
756:                      * Overview:        The function is a helper that calculates the IP checksum of a memory block.
757:                      *                  The function configures the DMA channel for a fast memory transfer and calculates the IP checksum.
758:                      *
759:                      *
760:                      * Note:            - The checksum generator must have been previously seeded using DmaSfmSetSeed()
761:                      *                  - No transfer is done, just the checksum is calculated.
762:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
763:                      *                  - Append mode is enabled and the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
764:                      *                  - The checksum type is switched to IP checksum.
765:                      *                  - The way the data is fed into the checksum calculation block is affected by DmaSfmConfigure().
766:                      *
767:                      * Example:          int myChecksum; DmaChnMemChecksum(&myChecksum, srcBuff, sizeof(srcBuff), DMA_CHANNEL1, DMA_CHN_PRI3);
768:                      ********************************************************************/
769:                      DmaTxferRes    DmaChnMemChecksum(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri);
770:                 
771:                     // High level Special Function Module (SFM) functions
772:                 
773:                     /*********************************************************************
774:                      * Function:        void DmaSfmConfigure(DmaChksumType cType, DmaBitOrder bitO, DmaReorderMode rMode)
775:                      *
776:                      * PreCondition:    cType, bitO, rMode - valid values
777:                      *
778:                      * Input:           cType - checksum type to be calculated: CRC or IP Checksum
779:                      *                  bitO  - the bit order to be used MSb or LSb first
780:                      *                  rMode - the reordering mode of the bytes when calculating the checksum
781:                      *
782:                      * Output:          None
783:                      *
784:                      * Side Effects:    Whenever the Transfer re-ordering is enabled the rMode setting will influence the destination data layout
785:                      *
786:                      * Overview:        The function configures the SFM module by setting the parameters that define the behavior:
787:                      *                      - the type of the checksum to be calculated (either CRC or IP checksum are supported)
788:                      *                      - the bit ordering (how a specific byte is used in the checksum calculation: MSb or LSb first)
789:                      *                      - the data re-ordering (how bytes are re-ordered before calculating the checksum).
790:                      *                      All these values affect the way the checksum is calculated.
791:                      *
792:                      * Note:            None
793:                      *
794:                      * Example:         DmaSfmConfigure(DMA_CHKSUM_CRC, DMA_BITO_LSb, DMA_REORDER_ENDIAN);
795:                      ********************************************************************/
796:                     extern __inline__ void __attribute__((always_inline)) DmaSfmConfigure(DmaChksumType cType, DmaBitOrder bitO, DmaReorderMode rMode)
797:                     {
798:                         DCRCCONCLR=_DCRCCON_CRCTYP_MASK|_DCRCCON_BITO_MASK|_DCRCCON_BYTO_MASK;
799:                         DCRCCONSET=(cType<<_DCRCCON_CRCTYP_POSITION)|(bitO<<_DCRCCON_BITO_POSITION)|(rMode<<_DCRCCON_BYTO_POSITION);
800:                     }
801:                 
802:                     /*********************************************************************
803:                      * Function:        void DmaSfmTxferReorder(int enable)
804:                      *
805:                      * PreCondition:    None
806:                      *
807:                      * Input:           enable - boolean to enable/disable the re-ordering of the data transfer
808:                      *
809:                      * Output:          None
810:                      *
811:                      * Side Effects:    None
812:                      *
813:                      * Overview:        The function configures the data transfer re-ordering of the SFM module.
814:                      *                  If the re-ordering is enabled, the data is read from the source, re-ordered accordingly and then written to the destination.
815:                      *                  Otherwise the data is written to the destination un-modified.
816:                      *                  The re-ordering is the one specified by the DmaReorderMode parameter in the DmaSfmConfigure() call.
817:                      *
818:                      *
819:                      * Note:            - The data transfer re-ordering should be used only for normal (background mode) data transfers.
820:                      *                  - In append mode the data transfer re-ordering should not be enabled (undefined behavior)!
821:                      *                  - Whenever the data re-ordering is enabled, the transfer should be aligned at both ends (source and destination).
822:                      *                    Un-aligned transfers are not supported (undefined behavior)!
823:                      *
824:                      * Example:         DmaSfmTxferReorder();
825:                      ********************************************************************/
826:                     extern __inline__ void __attribute__((always_inline)) DmaSfmTxferReorder(int enable)
827:                     {
828:                         DCRCCONCLR=_DCRCCON_WBO_MASK;
829:                         DCRCCONSET=(enable<<_DCRCCON_WBO_POSITION);
830:                     }
831:                 
832:                 
833:                      /*********************************************************************
834:                      * Function:        void DmaSfmCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
835:                      *
836:                      * PreCondition:    pLen   - valid polynomial length within 1-32
837:                      *
838:                      * Input:           polynomial  - the layout of the CRC generator
839:                      *                  pLen        - the length of the CRC generator polynomial
840:                      *                  seed        - the initial seed of the CRC generator
841:                      *
842:                      * Output:          None
843:                      *
844:                      * Side Effects:    None
845:                      *
846:                      * Overview:        The function configures the SFM CRC module by setting the parameters that define the generator polynomial:
847:                      *                  - the length of the CRC generator polynomial, pLen;
848:                      *                  - the function sets the layout of the shift stages that take place in the CRC generation.
849:                      *                    Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
850:                      *                    If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
851:                      *                    Note that in a proper CRC polynomial, both the most significant bit (MSb) and least significant bit(LSb)
852:                      *                    are always a '1'. Considering the generator polynomial: X^16+X^15+X^2+1, the value to be written as
853:                      *                    feedback should be 0x8005, or 0x8004, but not 0x018005;
854:                      *                  - the function sets the seed of the CRC generator. This is the initial data present in the
855:                      *                   CRC shift register before the CRC calculation begins. A good initial value is usually 0xffffffff.
856:                      *
857:                      * Note:            - Bit 0 of the generator polynomial is always XOR'ed.
858:                      *                  - When the append mode is set, the attached DMA channel has to have destination size <=4.
859:                      *                    Upon the transfer completion the calculated CRC is stored at the destination address.
860:                      *                  - When append mode is cleared, the DMA transfer occurs normally, and the CRC value is available using
861:                      *                    the CrcResult() function.
862:                      *                  - The CRC module should be configured before enabled.
863:                      *                  - These settings are relevant only when the SFM is configured for the CRC type of checksum.
864:                      *                  - The checksum register is the same for CRC or IP checksum mode. Therefore, this function changes also the seed for the IP checksum.
865:                      *                  - The way the data is fed into the checksum calculation block and the type of the checksum performed is affected by DmaSfmConfigure().
866:                      *
867:                      * Example:         DmaSfmCrcConfigure(0x04c11db7, 32, 0xffffffff);
868:                      ********************************************************************/
869:                     extern __inline__ void __attribute__((always_inline)) DmaSfmCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
870:                     {
871:                         DCRCCONCLR=_DCRCCON_PLEN_MASK;
872:                         DCRCCONSET=(pLen-1)<<_DCRCCON_PLEN_POSITION;
873:                         DCRCDATA=seed;
874:                         DCRCXOR=polynomial;
875:                     }
876:                 
877:                     #define DmaCrcConfigure DmaSfmCrcConfigure  // PIC32_3xx backward compatibility name
878:                 
879:                 
880:                     /*********************************************************************
881:                      * Function:        void DmaSfmAttachChannel(DmaChannel chn, int appendMode)
882:                      *
883:                      * PreCondition:    chn    - valid DMA channel
884:                      *
885:                      * Input:           chn         - the DMA channel to be attached to the checksum module.
886:                      *                  appendMode  - if TRUE the data passed to the checksum generator is not transferred to destination
887:                      *                                but it's written to the destination address when the block transfer is complete.
888:                      *                              - if FALSE the data is transferred normally while the checksum is calculated.
889:                      *                                The checksum will be available using the DmaSfmChecksum function.
890:                      *
891:                      * Output:          None
892:                      *
893:                      * Side Effects:    None
894:                      *
895:                      * Overview:        The function attaches the SFM checksum module to a DMA channel and enables the checksum generator.
896:                      *                  From now on, all the DMA traffic is directed to the SFM checksum generator. Once the DMA block transfer
897:                      *                  is complete, the checksum result is available in the checksum data register.
898:                      *                  If append mode is enabled, no data transfer takes place but the checksum result will be deposited at the DMA destination address.
899:                 
900:                      *
901:                      * Note:            If append mode is enabled the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
902:                      *
903:                      * Example:         DmaSfmAttachChannel(DMA_CHANNEL0, TRUE);
904:                      ********************************************************************/
905:                     void            DmaSfmAttachChannel(DmaChannel chn, int appendMode);
906:                     #define         CrcAttachChannel    DmaSfmAttachChannel     // PIC32_3xx backward compatibility name
907:                 
908:                     /*********************************************************************
909:                      * Function:        unsigned int DmaSfmChecksum(void)
910:                      *
911:                      * PreCondition:    None
912:                      *
913:                      * Input:           None
914:                      *
915:                      * Output:          the current value of the checksum generator.
916:                      *
917:                      * Side Effects:    None
918:                      *
919:                      * Overview:        The function returns the calculated checksum value.
920:                      *
921:                      * Note:            - The function returns the valid checksum result. The masking out the unused MSbits in the checksum register is done by the hardware.
922:                      *                  - The way the data is fed into the checksum calculation block and the type of the checksum performed is affected by DmaSfmConfigure().
923:                      *
924:                      * Example:         unsigned int myChk=DmaSfmChecksum();
925:                      ********************************************************************/
926:                     extern __inline__ int __attribute__((always_inline)) DmaSfmChecksum(void)
927:                     {
928:                         return DCRCDATA;
929:                     }
930:                     #define     CrcResult   DmaSfmChecksum      // PIC32_3xx backward compatibility name
931:                     #define     DmaCrcGetValue  DmaSfmChecksum      // PIC32_3xx backward compatibility name
932:                 
933:                 
934:                     /*********************************************************************
935:                      * Function:        void DmaSfmSetSeed(unsigned int seed)
936:                      *
937:                      * PreCondition:    None
938:                      *
939:                      * Input:           seed    - the initial seed of the checksum generator
940:                      *
941:                      * Output:          None
942:                      *
943:                      * Side Effects:    None
944:                      *
945:                      * Overview:        The function sets the seed of the checksum generator. This is the initial data present in the
946:                      *                  CRC shift register or the IP checksum calculator before the actual transfer/calculation begins.
947:                      *
948:                      * Note:            When the SFM is configured for IP checksum mode, only the least significant 16 bits are relevant.
949:                      *
950:                      * Example:         DmaSfmSetSeed(0xffffffff);
951:                      ********************************************************************/
952:                     extern __inline__ void __attribute__((always_inline)) DmaSfmSetSeed(unsigned int seed)
953:                     {
954:                         DCRCDATA=seed;
955:                     }
956:                     #define     DmaCrcSetSeed   DmaSfmSetSeed       // PIC32_3xx backward compatibility name
957:                 
958:                 
959:                 /*********************  end of high level functions ****************************************/
960:                 
961:                     // low level definitions for the API functions
962:                 
963:                 
964:                     typedef struct
965:                     {
966:                         union
967:                         {
968:                             struct
969:                             {
970:                                 unsigned int chn:   3;      // last active DMA channel
971:                                 unsigned int rdOp:  1;      // last DMA operation, read if 1, write if 0
972:                             };
973:                             unsigned int    w;                      // word access
974:                         }lastAccess;
975:                         void*   lastAddress;        // most recent DMA address
976:                     }DmaStatus;         // DMA controller status
977:                 
978:                     typedef enum
979:                     {
980:                         DMA_GFLG_SUSPEND =  _DMACON_SUSPEND_MASK,   // suspend DMA controller operation
981:                         DMA_GFLG_ON =       _DMACON_ON_MASK,        // DMA module enabled/desabled
982:                         //
983:                         DMA_GFLG_ALL_FLAGS= DMA_GFLG_SUSPEND|DMA_GFLG_ON        // all flags
984:                     }DmaGlblFlags;  // flags for controlling global DMA controller behavior. From processor header file.
985:                 
986:                 
987:                 
988:                 
989:                     typedef enum
990:                     {
991:                         DMA_EV_ABORT_IRQ_EN =       _DCH0ECON_AIRQEN_MASK,
992:                         DMA_EV_START_IRQ_EN =       _DCH0ECON_SIRQEN_MASK,
993:                         // use DMA_EV_START_IRQ() and DMA_EV_ABORT_IRQ() below for selecting
994:                         // the start and abort IRQ signals
995:                         DMA_EV_MATCH_EN =           _DCH0ECON_PATEN_MASK,
996:                 
997:                 
998:                         // compiler use only field
999:                         _DMA_EV_MAX_MASK =     _DCH0ECON_CHAIRQ_MASK,
1000:                    }DmaEvCtrlFlags;    // DMA channel event control fields accessibile as flags
1001:                    // also part of DmaEvCtrlFlags:
1002:                    #define DMA_EV_START_IRQ(irq)   (DMA_EV_START_IRQ_EN | ((irq)<<_DCH0ECON_CHSIRQ_POSITION))  // NOTE: irq has to be a symbol from the processor header file
1003:                    #define DMA_EV_ABORT_IRQ(irq)   (DMA_EV_ABORT_IRQ_EN | ((irq)<<_DCH0ECON_CHAIRQ_POSITION))  // NOTE: irq has to be a symbol from the processor header file
1004:                
1005:                    // DMA channel event control as a structure:
1006:                    #define DmaEvCtrl   __DCH0ECONbits_t
1007:                
1008:                
1009:                
1010:                
1011:                    typedef enum
1012:                    {
1013:                        DMA_CTL_AUTO_EN =       _DCH0CON_CHAEN_MASK,
1014:                        DMA_CTL_CHAIN_EN =      _DCH0CON_CHCHN_MASK,
1015:                        DMA_CTL_DET_EN =        _DCH0CON_CHAED_MASK,
1016:                        DMA_CTL_CHN_EN =        _DCH0CON_CHEN_MASK,
1017:                        DMA_CTL_CHAIN_DIR =     _DCH0CON_CHCHNS_MASK,
1018:                        // use the DMA_CTL_PRI() below for selecting the DMA
1019:                        // channel priority
1020:                    }DmaChnCtrlFlags;   // controlling the DMA channel with flags
1021:                    // also part of DmaChnCtrlFlags:
1022:                    #define DMA_CTL_PRI(pri)    ((pri)&_DCH0CON_CHPRI_MASK) // DMA Control channel priority
1023:                
1024:                    // DMA channel control as a structure:
1025:                    #define DmaChnCtrl      __DCH0CONbits_t
1026:                
1027:                    typedef struct
1028:                    {
1029:                        void*   vSrcAdd;        // source of the DMA transfer, virtual
1030:                        void*   vDstAdd;        // destination of the DMA transfer, virtual
1031:                        int srcSize;        // source buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
1032:                        int dstSize;        // destination buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
1033:                        int cellSize;       // no of bytes txferred per event, 1 to DmaGetMaxTxferSize().
1034:                    }DmaTxferCtrl;      // transfer setting: the transfer source, destination addresses and size, cell size
1035:                
1036:                
1037:                    /********************** low level DMA channel functions *******************************/
1038:                
1039:                
1040:                
1041:                    // Global DMA controller functions
1042:                
1043:                    /*********************************************************************
1044:                     * Function:        void DmaEnable(int enable)
1045:                     *
1046:                     * PreCondition:    None
1047:                     *
1048:                     * Input:           enable - boolean to enable/disable the DMA controller
1049:                     *
1050:                     * Output:          None
1051:                     *
1052:                     * Side Effects:    None
1053:                     *
1054:                     * Overview:       The function enables/disables the DMA controller.
1055:                     *
1056:                     * Note:           None.
1057:                     *
1058:                     * Example:        DmaEnable(1);
1059:                     ********************************************************************/
1060:                    extern __inline__ void __attribute__((always_inline)) DmaEnable(int enable)
1061:                    {
1062:                        if(enable)
1063:                        {
1064:                            DMACONSET=_DMACON_ON_MASK;
1065:                        }
1066:                        else
1067:                        {
1068:                            DMACONCLR=_DMACON_ON_MASK;
1069:                            while(DMACONbits.ON);       // wait to take effect
1070:                        }
1071:                    }
1072:                
1073:                    /*********************************************************************
1074:                     * Function:        void DmaReset(void)
1075:                     *
1076:                     * PreCondition:    None
1077:                     *
1078:                     * Input:       None
1079:                     *
1080:                     * Output:          None
1081:                     *
1082:                     * Side Effects:    None
1083:                     *
1084:                     * Overview:        The function resets the DMA controller.
1085:                     *
1086:                     * Note:            None.
1087:                     *
1088:                     * Example:        DmaReset();
1089:                     ********************************************************************/
1090:                    #define            DmaReset()   DmaEnable(0)
1091:                
1092:                
1093:                    /*********************************************************************
1094:                     * Function:        int DmaSuspend(void)
1095:                     *
1096:                     * PreCondition:    None
1097:                     *
1098:                     * Input:       None
1099:                     *
1100:                     * Output:          true if the DMA was previously suspended, false otherwise
1101:                     *
1102:                     *
1103:                     * Side Effects:    None
1104:                     *
1105:                     * Overview:        The function suspends the DMA controller.
1106:                     *
1107:                     * Note:            After the execution of this function the DMA operation is supposed to be suspended.
1108:                     *                  I.e. the function has to wait for the suspension to take place!
1109:                     *
1110:                     * Example:         int susp=DmaSuspend();
1111:                     ********************************************************************/
1112:                        extern __inline__ int __attribute__((always_inline)) DmaSuspend(void)
1113:                    {
1114:                        int suspSt;
1115:                        if(!(suspSt=DMACONbits.SUSPEND))
9D01E6B0  3C03BF88   LUI V1, -16504
9D01EB88  3C03BF88   LUI V1, -16504
9D01EB8C  8C633000   LW V1, 12288(V1)
9D01EB90  7C630300   EXT V1, V1, 12, 1
9D01EB94  1460FEDB   BNE V1, ZERO, 0x9D01E704
9D01EB98  24041000   ADDIU A0, ZERO, 4096
1116:                        {
1117:                            DMACONSET=_DMACON_SUSPEND_MASK;     // suspend
9D01E6C4  24041000   ADDIU A0, ZERO, 4096
9D01E6EC  AC643008   SW A0, 12296(V1)
9D01EB9C  0B4079BB   J .LBB64, .LBB66
9D01EBA0  3C03BF88   LUI V1, -16504
1118:                            while((DMACONbits.DMABUSY));    // wait to be actually suspended
9D01E6D0  3C05BF88   LUI A1, -16504
9D01E6F0  3C05BF88   LUI A1, -16504
9D01E6F4  8CA33000   LW V1, 12288(A1)
9D01E6F8  30630800   ANDI V1, V1, 2048
9D01E6FC  1460FFFD   BNE V1, ZERO, 0x9D01E6F4
9D01E700  00000000   NOP
1119:                        }
1120:                        return suspSt;
1121:                    }
1122:                
1123:                
1124:                
1125:                    /*********************************************************************
1126:                     * Function:        void DmaResume(int susp)
1127:                     *
1128:                     * PreCondition:    None
1129:                     *
1130:                     * Input:       the desired DMA suspended state.
1131:                     *
1132:                     * Output:          None
1133:                     *
1134:                     * Side Effects:    None
1135:                     *
1136:                     * Overview:        The function restores the DMA controller activity to the old suspended mode.
1137:                     *
1138:                     * Note:            None.
1139:                     *
1140:                     * Example:         int isSusp=DmaSuspend(); {....}; DmaResume(isSusp);
1141:                     ********************************************************************/
1142:                        extern __inline__ void __attribute__((always_inline)) DmaResume(int susp)
1143:                    {
1144:                        if(susp)
1145:                        {
1146:                            DmaSuspend();
1147:                        }
1148:                        else
1149:                        {
1150:                            DMACONCLR=_DMACON_SUSPEND_MASK;     // resume DMA activity
9D01EB38  24041000   ADDIU A0, ZERO, 4096
9D01EB3C  3C03BF88   LUI V1, -16504
9D01EB40  AC643004   SW A0, 12292(V1)
9D01EB44  0B4079C1   J 0x9D01E704
9D01EB48  00000000   NOP
1151:                        }
1152:                    }
1153:                
1154:                    /*********************************************************************
1155:                     * Function:        void DmaGetStatus(DmaStatus* pStat)
1156:                     *
1157:                     * PreCondition:    pStat   - valid pointer
1158:                     *
1159:                     * Input:           pStat   - pointer to a DmaStatus structure to store the current DMA controller
1160:                     *                          status, carrying the following info:
1161:                     *                              - chn:  the last active DMA channel
1162:                     *                              - rdOp: the last DMA operation, read/write
1163:                     *                              - lastAddress: the most recent DMA address
1164:                     *
1165:                     * Output:          None
1166:                     *
1167:                     * Side Effects:    None
1168:                     *
1169:                     * Overview:        The function updates the info for the current DMA controller status.
1170:                     *                  It updates the last DMA: operation, channel used and address.
1171:                     *
1172:                     * Note:            None.
1173:                     *
1174:                     * Example:         DmaStatus stat; DmaGetStatus(&stat);
1175:                     ********************************************************************/
1176:                     void           DmaGetStatus(DmaStatus* pStat);
1177:                
1178:                    /*********************************************************************
1179:                     * Function:        void DmaSetGlobalFlags(DmaGlblFlags gFlags)
1180:                     *
1181:                     * PreCondition:    None
1182:                     *
1183:                     * Input:           gFlags - flags to be set, having the following fields:
1184:                     *          - DMA_GFLG_SUSPEND: DMA controller operation suspend
1185:                     *          - DMA_GFLG_ON: DMA controller enabled/desabled
1186:                     *          - DMA_GFLG_ALL_FLAGS: all flags
1187:                     *
1188:                     * Output:          None
1189:                     *
1190:                     * Side Effects:    None
1191:                     *
1192:                     * Overview:        The function affects the global behavior of the DMA controller.
1193:                     *                  It sets the specified flags. Any flag that is set in the gFlags will be
1194:                     *                  enabled, the other flags won't be touched.
1195:                     *
1196:                     * Note:            None.
1197:                     *
1198:                     * Example:         DmaSetGlobalFlags(DMA_GFLG_ON);
1199:                     ********************************************************************/
1200:                        extern __inline__ void __attribute__((always_inline)) DmaSetGlobalFlags(DmaGlblFlags gFlags)
1201:                    {
1202:                        DMACONSET=gFlags;
1203:                    }
1204:                
1205:                    /*********************************************************************
1206:                     * Function:        void DmaClrGlobalFlags(DmaGlblFlags gFlags)
1207:                     *
1208:                     * PreCondition:    None
1209:                     *
1210:                     * Input:           gFlags - flags to be cleared, having the following fields:
1211:                     *                               - DMA_GFLG_SUSPEND: DMA controller operation suspend
1212:                     *                               - DMA_GFLG_ON: DMA controller enabled/desabled
1213:                     *                               - DMA_GFLG_ALL_FLAGS: all flags
1214:                     *
1215:                     * Output:          None
1216:                     *
1217:                     * Side Effects:    None
1218:                     *
1219:                     * Overview:        The function affects the global behavior of the DMA controller.
1220:                     *                  It clears the specified flags. Any flag that is set in the gFlags will be
1221:                     *                  cleared, the other flags won't be touched.
1222:                     *
1223:                     * Note:            None.
1224:                     *
1225:                     * Example:         DmaClrGlobalFlags(DMA_GFLG_SUSPEND);
1226:                     ********************************************************************/
1227:                        extern __inline__ void __attribute__((always_inline)) DmaClrGlobalFlags(DmaGlblFlags gFlags)
1228:                    {
1229:                        DMACONCLR=gFlags;
1230:                    }
1231:                
1232:                
1233:                    /*********************************************************************
1234:                     * Function:        void DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1235:                     *
1236:                     * PreCondition:    None
1237:                     *
1238:                     * Input:           gFlags - flags to be set, having the following fields:
1239:                     *                                 - DMA_GFLG_SUSPEND: DMA controller operation suspend
1240:                     *                                 - DMA_GFLG_ON: DMA controller enabled/desabled
1241:                     *                                 - DMA_GFLG_ALL_FLAGS: all flags
1242:                     *
1243:                     * Output:          None
1244:                     *
1245:                     * Side Effects:    None
1246:                     *
1247:                     * Overview:        The function affects the global behavior of the DMA controller.
1248:                     *                  It forces the flags to have the specified gFlags value.
1249:                     *
1250:                     * Note:            None.
1251:                     *
1252:                     * Example:         DmaWriteGlobalFlags(DMA_GFLG_ALL_FLAGS);
1253:                     ********************************************************************/
1254:                        extern __inline__ void __attribute__((always_inline)) DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1255:                    {
1256:                        DMACON=gFlags;
1257:                    }
1258:                
1259:                    /*********************************************************************
1260:                     * Function:        DmaGlblFlags DmaGetGlobalFlags(void)
1261:                     *
1262:                     * PreCondition:    None
1263:                     *
1264:                     * Input:           None
1265:                     *
1266:                     * Output:          The current DMA controller flags settings.
1267:                     *                              - DMA_GFLG_SUSPEND: DMA controller operation suspend
1268:                     *                              - DMA_GFLG_ON: DMA controller enabled/desabled
1269:                     *
1270:                     * Side Effects:    None
1271:                     *
1272:                     * Overview:        The function returns the global flags of the DMA controller.
1273:                     *
1274:                     * Note:            None.
1275:                     *
1276:                     * Example:         DmaGlblFlags dmaFlags=DmaGetGlobalFlags();
1277:                     ********************************************************************/
1278:                        extern __inline__ DmaGlblFlags __attribute__((always_inline)) DmaGetGlobalFlags(void)
1279:                    {
1280:                        return (DmaGlblFlags)DMACON;
1281:                    }
1282:                
1283:                
1284:                    /*********************************************************************
1285:                     * Function:        int DmaGetMaxTxferSize(void)
1286:                     *
1287:                     * PreCondition:    None
1288:                     *
1289:                     * Input:           None
1290:                     *
1291:                     * Output:          The maximum transfer capacity for a DMA channel, in bytes.
1292:                     *
1293:                     * Side Effects:    None
1294:                     *
1295:                     * Overview:        The function returns the maximum number of bytes that can be transferred by a DMA channel.
1296:                     *
1297:                     * Note:            Revision dependant.
1298:                     *
1299:                     * Example:         int dmaMaxSz=DmaGetMaxTxferSize();
1300:                     ********************************************************************/
1301:                    extern __inline__ int __attribute__((always_inline)) DmaGetMaxTxferSize(void)
1302:                    {
1303:                        return 65536;
1304:                    }
1305:                
1306:                    // Direct Channel control functions
1307:                
1308:                    typedef enum
1309:                    {
1310:                        DMA_CONFIG_DEFAULT = 0,                             // DMA default operation
1311:                        DMA_CONFIG_AUTO = _DCH0CON_CHAEN_MASK,              // DMA channel is auto enabled
1312:                        DMA_CONFIG_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK), // DMA channel is chained to lower channel
1313:                        DMA_CONFIG_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),       // DMA channel is chained to higher channel
1314:                        DMA_CONFIG_DET_EN = _DCH0CON_CHAED_MASK,            // events detection enabled while channel off
1315:                        DMA_CONFIG_ENABLE = _DCH0CON_CHEN_MASK,             // DMA channel is enabled after open
1316:                        DMA_CONFIG_MATCH    = 0x80000000,                   // DMA channel stops on match
1317:                    }DmaConfigFlags;    // flags for the channel configuration
1318:                
1319:                
1320:                
1321:                    /*********************************************************************
1322:                     * Function:        void DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags)
1323:                     *
1324:                     * PreCondition:    chPri  - valid channel priority, 0-3
1325:                     *
1326:                     * Input:           chn    - channel to be configured in the DMA controller
1327:                     *                  chPri  - the priority given to the channel, 0-3
1328:                     *                  cFlags - orred flags specifying the configuration:
1329:                     *                           DMA_CONFIG_DEFAULT: DMA default operation mode
1330:                     *                           DMA_CONFIG_AUTO:   DMA channel is auto enabled
1331:                     *                           DMA_CONFIG_CHAIN_LOW: DMA channel is chained to lower channel
1332:                     *                           DMA_CONFIG_CHAIN_HI: DMA channel is chained to higher channel
1333:                     *                           DMA_CONFIG_DET_EN: events detection enabled while channel off
1334:                     *                           DMA_CONFIG_ENABLE: DMA channel is enabled when opened
1335:                     *                           DMA_CONFIG_MATCH:  DMA channel stops on match
1336:                     *
1337:                     *
1338:                     *
1339:                     * Output:          None
1340:                     *
1341:                     * Side Effects:    None
1342:                     *
1343:                     * Overview:        The function configures the selected DMA channel using the supplied user flags and priority.
1344:                     *
1345:                     * Note:            - The channel is NOT turned off. It should be turned off before calling this function.
1346:                     *                  The channel is just configured.
1347:                     *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
1348:                     *                  if DMA_CONFIG_ENABLE flag was not specified.
1349:                     *                  - The function does not touch the interrupt flags, interrupt enables, etc.
1350:                     *                  The interrupt flags should have been previously cleared and interrupts disabled before calling this function.
1351:                     *                  - The start and abort Irqs, the channel event enable flags are not touched/cleared by this function.
1352:                     *                  User has to call event channel functions to clear/enable the event flags if needed.
1353:                     *
1354:                     * Example:         DmaChnDisable(DMA_CHANNEL2); DmaChnConfigure(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_CONFIG_AUTO|DMA_CONFIG_MATCH|DMA_CONFIG_ENABLE);
1355:                     ********************************************************************/
1356:                    void            DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags);
1357:                
1358:                
1359:                    /*********************************************************************
1360:                     * Function:        int DmaChnGetSrcPnt(DmaChannel chn)
1361:                     *
1362:                     * PreCondition:    chn - valid DMA channel
1363:                     *
1364:                     * Input:           chn     - DMA channel number
1365:                     *
1366:                     * Output:          Current channel source pointer.
1367:                     *
1368:                     * Side Effects:    None
1369:                     *
1370:                     * Overview:        The function retrieves the current source pointer for the selected DMA channel.
1371:                     *                  It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the source transfer buffer.
1372:                     *
1373:                     * Note:            None
1374:                     *
1375:                     * Example:         int srcPnt=DmaChnGetSrcPnt(DMA_CHANNEL3);
1376:                     ********************************************************************/
1377:                     int            DmaChnGetSrcPnt(DmaChannel chn);
1378:                
1379:                    /*********************************************************************
1380:                     * Function:        int DmaChnGetDstPnt(DmaChannel chn)
1381:                     *
1382:                     * PreCondition:    chn - valid DMA channel
1383:                     *
1384:                     * Input:           chn     - DMA channel number
1385:                     *
1386:                     * Output:          Current channel destination pointer.
1387:                     *
1388:                     * Side Effects:    None
1389:                     *
1390:                     * Overview:        The function retrieves the current destination pointer for the selected DMA channel.
1391:                     *                  It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the destination transfer buffer.
1392:                     *
1393:                     * Note:            None
1394:                     *
1395:                     * Example:         int dstPnt=DmaChnGetDstPnt(DMA_CHANNEL3);
1396:                     ********************************************************************/
1397:                     int            DmaChnGetDstPnt(DmaChannel chn);
1398:                
1399:                    /*********************************************************************
1400:                     * Function:        int DmaChnGetCellPnt(DmaChannel chn)
1401:                     *
1402:                     * PreCondition:    chn - valid DMA channel
1403:                     *
1404:                     * Input:           chn     - DMA channel number
1405:                     *
1406:                     * Output:          Current channel transfer pointer.
1407:                     *
1408:                     * Side Effects:    None
1409:                     *
1410:                     * Overview:        The function retrieves the current transfer progress pointer for the selected DMA channel.
1411:                     *                  It ranges 0 to DmaGetMaxTxferSize()-1.
1412:                     *
1413:                     * Note:            None
1414:                     *
1415:                     * Example:         int cellPnt=DmaChnGetCellPnt(DMA_CHANNEL3);
1416:                     ********************************************************************/
1417:                     int            DmaChnGetCellPnt(DmaChannel chn);
1418:                
1419:                
1420:                
1421:                    /*********************************************************************
1422:                     * Function:        void DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1423:                     *
1424:                     * PreCondition:    chn - valid DMA channel
1425:                     *
1426:                     * Input:           chn         - DMA channel number
1427:                     *                  dmaEvCtrl   -   either a DmaEvCtrl structure field, carrying the following info:
1428:                     *                                      - AIRQEN: enable/disable the abort IRQ action
1429:                     *                                      - SIRQEN: enable/disable the start IRQ action
1430:                     *                                      - PATEN: enable/disable the pattern match and abort
1431:                     *                                  or any of the DmaEvCtrlFlags:
1432:                     *                                      DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1433:                     *
1434:                     *
1435:                     * Output:          None
1436:                     *
1437:                     * Side Effects:    None
1438:                     *
1439:                     * Overview:        The function sets the events that start and abort the transfer
1440:                     *                  for the selected DMA channel.
1441:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1442:                     *                  enabled for the selected channel, the other channel event flags won't be touched.
1443:                     *
1444:                     * Note:            None.
1445:                     *
1446:                     * Example:         either:
1447:                     *                      DmaChnSetEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN;
1448:                     *                  or:
1449:                     *                      DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.SIRQEN=1;
1450:                     *                      DmaChnSetEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1451:                     *
1452:                     ********************************************************************/
1453:                     void           DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1454:                
1455:                
1456:                    /*********************************************************************
1457:                     * Function:        void DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1458:                     *
1459:                     * PreCondition:    chn - valid DMA channel
1460:                     *
1461:                     * Input:           chn         - DMA channel number
1462:                     *                  dmaEvCtrl   -   either a DmaEvCtrl structure field, carrying the following info:
1463:                     *                                      - AIRQEN: enable/disable the abort IRQ action
1464:                     *                                      - SIRQEN: enable/disable the start IRQ action
1465:                     *                                      - PATEN: enable/disable the pattern match and abort
1466:                     *                                  or any of the DmaEvCtrlFlags:
1467:                     *                                      DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1468:                     *
1469:                     *
1470:                     * Output:          None
1471:                     *
1472:                     * Side Effects:    None
1473:                     *
1474:                     * Overview:        The function clears the events that start and abort the transfer
1475:                     *                  for the selected DMA channel.
1476:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1477:                     *                  disabled for the selected channel, the other channel event flags won't be touched.
1478:                     *
1479:                     * Note:            None.
1480:                     *
1481:                     * Example:         either:
1482:                     *                      DmaChnClrEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN);
1483:                     *                  or:
1484:                     *                      DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.AIRQEN=1;
1485:                     *                      DmaChnClrEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1486:                     *
1487:                     ********************************************************************/
1488:                     void           DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1489:                
1490:                
1491:                
1492:                    /*********************************************************************
1493:                     * Function:        void DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1494:                     *
1495:                     * PreCondition:    chn - valid DMA channel
1496:                     *
1497:                     * Input:           chn         - DMA channel number
1498:                     *                  dmaEvCtrl   -   either a DmaEvCtrl structure field, carrying the following info:
1499:                     *                                      - AIRQEN: enable/disable the abort IRQ action
1500:                     *                                      - SIRQEN: enable/disable the start IRQ action
1501:                     *                                      - PATEN: enable/disable the pattern match and abort
1502:                     *                                      - CHSIRQ: IRQ number to start the DMA channel transfer
1503:                     *                                      - CHAIRQ: IRQ number to abort the DMA channel transfer
1504:                     *                                  or any of the DmaEvCtrlFlags:
1505:                     *                                      DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1506:                     *
1507:                     *
1508:                     * Output:          None
1509:                     *
1510:                     * Side Effects:    None
1511:                     *
1512:                     * Overview:        The function writes the events that start and abort the transfer
1513:                     *                  for the selected DMA channel.
1514:                     *
1515:                     * Note:            None.
1516:                     *
1517:                     * Example:         either:
1518:                     *                      DmaChnWriteEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1519:                     *                  or:
1520:                     *                      DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1521:                     *                      DmaChnWriteEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1522:                     *
1523:                     ********************************************************************/
1524:                     void           DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1525:                
1526:                
1527:                
1528:                    /*********************************************************************
1529:                     * Function:        void DmaChnSetEventControl(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1530:                     *
1531:                     * PreCondition:    chn - valid DMA channel
1532:                     *
1533:                     * Input:           chn         - DMA channel number
1534:                     *                  dmaEvCtrl   -   either a DmaEvCtrl structure field, carrying the following info:
1535:                     *                                      - AIRQEN: enable/disable the abort IRQ action
1536:                     *                                      - SIRQEN: enable/disable the start IRQ action
1537:                     *                                      - PATEN: enable/disable the pattern match and abort
1538:                     *                                      - CHSIRQ: IRQ number to start the DMA channel transfer
1539:                     *                                      - CHAIRQ: IRQ number to abort the DMA channel transfer
1540:                     *                                  or any of the DmaEvCtrlFlags:
1541:                     *                                      DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1542:                     *
1543:                     *
1544:                     * Output:          None
1545:                     *
1546:                     * Side Effects:    None
1547:                     *
1548:                     * Overview:        The function sets the events that start and abort the transfer
1549:                     *                  for the selected DMA channel.
1550:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1551:                     *                  enabled for the selected channel, the other channel event flags won't be touched.
1552:                     *
1553:                     * Note:           A shorter name for DmaChnWriteEventControlFlags();
1554:                     *
1555:                     * Example:         either:
1556:                     *                      DmaChnSetEventControl(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1557:                     *                  or:
1558:                     *                      DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1559:                     *                      DmaChnSetEventControl(DMA_CHANNEL3, evCtrl.w);
1560:                     *
1561:                     ********************************************************************/
1562:                    #define         DmaChnSetEventControl(chn, dmaEvCtrl)   DmaChnWriteEventControlFlags(chn, dmaEvCtrl)
1563:                
1564:                
1565:                    /*********************************************************************
1566:                     * Function:        DmaEvCtrlFlags DmaChnGetEventControl(DmaChannel chn)
1567:                     *
1568:                     * PreCondition:    chn - valid DMA channel
1569:                     *
1570:                     * Input:           chn     - DMA channel number
1571:                     *
1572:                     * Output:          -   either a DmaEvCtrl structure field, carrying the following info:
1573:                     *                          - AIRQEN: enable/disable the abort IRQ action
1574:                     *                          - SIRQEN: enable/disable the start IRQ action
1575:                     *                          - PATEN: enable/disable the pattern match and abort
1576:                     *                          - CHSIRQ: IRQ number to start the DMA channel transfer
1577:                     *                          - CHAIRQ: IRQ number to abort the DMA channel transfer
1578:                     *                      or any of the DmaEvCtrlFlags:
1579:                     *                          DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1580:                     *
1581:                     *
1582:                     * Side Effects:    None
1583:                     *
1584:                     * Overview:        The function retrieves the events that start and abort the transfer
1585:                     *                  for the selected DMA channel.
1586:                     *
1587:                     * Note:            None.
1588:                     *
1589:                     * Example:         either:
1590:                     *                      DmaEvCtrlFlags evCtrlW=DmaChnGetEventControl(DMA_CHANNEL3); if(evCtrlW&DMA_EV_MATCH_EN) {...}
1591:                     *                  or:
1592:                     *                      DmaEvCtrl evCtrl; evCtrl.w=DmaChnGetEventControl(DMA_CHANNEL3); if(evCtrl.PATEN){...}
1593:                     *
1594:                     ********************************************************************/
1595:                     DmaEvCtrlFlags DmaChnGetEventControl(DmaChannel chn);
1596:                
1597:                
1598:                    /*********************************************************************
1599:                     * Function:        void DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1600:                     *
1601:                     * PreCondition:    chn - valid DMA channel
1602:                     *
1603:                     * Input:           chn         - DMA channel number
1604:                     *                  dmaChnCtrl  -   either a DmaChnCtrl structure field, carrying the following info:
1605:                     *                                      - autoEn: enable/disable the automatic mode
1606:                     *                                      - chainEn: enable/disable channel chaining
1607:                     *                                      - detectEn: enable/disable events detection when channel disabled
1608:                     *                                      - chEn: enable/disable channel functionality
1609:                     *                                      - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1610:                     *                                  or any of the DmaChnCtrlFlags flags:
1611:                     *                                      DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1612:                     *
1613:                     * Output:          None
1614:                     *
1615:                     * Side Effects:    None
1616:                     *
1617:                     * Overview:        The function sets the selected DMA channel control flags:
1618:                     *                  the chaining or auto mode, and events detection.
1619:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1620:                     *                  set for the selected channel, the other channel control flags won't be touched.
1621:                     *
1622:                     * Note:            None.
1623:                     *
1624:                     * Example:         either:
1625:                     *                      DmaChnSetControlFlags(DMA_CHANNEL3, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1626:                     *                  or:
1627:                     *                      DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1628:                     *                      DmaChnSetControlFlags(DMA_CHANNEL3, chCtrl.w);
1629:                     *
1630:                     ********************************************************************/
1631:                     void           DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1632:                
1633:                    /*********************************************************************
1634:                     * Function:        void DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1635:                     *
1636:                     * PreCondition:    chn - valid DMA channel
1637:                     *
1638:                     * Input:           chn         - DMA channel number
1639:                     *                  dmaChnCtrl  -   either a DmaChnCtrl structure field, carrying the following info:
1640:                     *                                      - autoEn: enable/disable the automatic mode
1641:                     *                                      - chainEn: enable/disable channel chaining
1642:                     *                                      - detectEn: enable/disable events detection when channel disabled
1643:                     *                                      - chEn: enable/disable channel functionality
1644:                     *                                      - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1645:                     *                                  or any of the DmaChnCtrlFlags flags:
1646:                     *                                      DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1647:                     *
1648:                     * Output:          None
1649:                     *
1650:                     * Side Effects:    None
1651:                     *
1652:                     * Overview:        The function clears the selected DMA channel control flags:
1653:                     *                  the chaining or auto mode and events detection.
1654:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1655:                     *                  cleared for the selected channel, the other channel control flags won't be touched.
1656:                     *
1657:                     * Note:            None.
1658:                     *
1659:                     * Example:         either:
1660:                     *                      DmaChnClrControlFlags(DMA_CHANNEL3, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1661:                     *                  or:
1662:                     *                      DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1663:                     *                      DmaChnClrControlFlags(DMA_CHANNEL3, chCtrl.w);
1664:                     *
1665:                     ********************************************************************/
1666:                     void           DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1667:                
1668:                    /*********************************************************************
1669:                     * Function:        void DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1670:                     *
1671:                     * PreCondition:    chn - valid DMA channel
1672:                     *
1673:                     * Input:           chn         - DMA channel number
1674:                     *                  dmaChnCtrl  -   either a DmaChnCtrl structure field, carrying the following info:
1675:                     *                                      - chPri: channel priority 0-3
1676:                     *                                      - autoEn: enable/disable the automatic mode
1677:                     *                                      - chainEn: enable/disable channel chaining
1678:                     *                                      - detectEn: enable/disable events detection when channel disabled
1679:                     *                                      - chEn: enable/disable channel functionality
1680:                     *                                      - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1681:                     *                                  or any of the DmaChnCtrlFlags flags:
1682:                     *                                      DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1683:                     *
1684:                     * Output:          None
1685:                     *
1686:                     * Side Effects:    None
1687:                     *
1688:                     * Overview:        The function enables/disables the selected DMA channel and also sets
1689:                     *                  the channel priority, chaining mode or auto and events detection.
1690:                     *
1691:                     * Note:            None.
1692:                     *
1693:                     * Example:         either:
1694:                     *                      DmaChnWriteControlFlags(DMA_CHANNEL3, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1695:                     *                  or:
1696:                     *                      DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1697:                     *                      DmaChnWriteControlFlags(DMA_CHANNEL3, chCtrl.w);
1698:                     *
1699:                     ********************************************************************/
1700:                     void           DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1701:                
1702:                    /*********************************************************************
1703:                     * Function:        void DmaChnSetControl(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1704:                     *
1705:                     * PreCondition:    chn - valid DMA channel
1706:                     *
1707:                     * Input:       chn     - DMA channel number
1708:                     *                  dmaChnCtrl  -   either a DmaChnCtrl structure field, carrying the following info:
1709:                     *                      - chPri: channel priority 0-3
1710:                     *                      - autoEn: enable/disable the automatic mode
1711:                     *                      - chainEn: enable/disable channel chaining
1712:                     *                      - detectEn: enable/disable events detection when channel disabled
1713:                     *                      - chEn: enable/disable channel functionality
1714:                     *                      - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1715:                     *                  or any of the DmaChnCtrlFlags flags:
1716:                     *                      DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1717:                     *
1718:                     * Output:          None
1719:                     *
1720:                     * Side Effects:    None
1721:                     *
1722:                     * Overview:        The function enables/disables the selected DMA channel and also sets
1723:                     *                  the channel priority, chaining mode or auto and events detection.
1724:                     *
1725:                     * Note:            Another name ( backward compatible) for DmaChnWriteControlFlags().
1726:                     *
1727:                     * Example:         either:
1728:                     *                      DmaChnSetControl(DMA_CHANNEL3, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1729:                     *                  or:
1730:                     *                      DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1731:                     *          DmaChnSetControl(DMA_CHANNEL3, chCtrl.w);
1732:                     *
1733:                     ********************************************************************/
1734:                    #define     DmaChnSetControl(chn, dmaChnCtrl)   DmaChnWriteControlFlags(chn, dmaChnCtrl)
1735:                
1736:                    /*********************************************************************
1737:                     * Function:        DmaChnCtrlFlags DmaChnGetControlFlags(DmaChannel chn)
1738:                     *
1739:                     * PreCondition:    chn - valid DMA channel
1740:                     *
1741:                     * Input:           chn         - DMA channel number
1742:                     *
1743:                     * Output:          - either a DmaChnCtrl structure field, carrying the following info:
1744:                     *                          - chPri: channel priority 0-3
1745:                     *                          - autoEn: enable/disable the automatic mode
1746:                     *                          - chainEn: enable/disable channel chaining
1747:                     *                          - detectEn: enable/disable events detection when channel disabled
1748:                     *                          - chEn: enable/disable channel functionality
1749:                     *                          - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1750:                     *                      or any of the DmaChnCtrlFlags flags:
1751:                     *                          DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1752:                     *
1753:                     * Side Effects:    None
1754:                     *
1755:                     * Overview:        The function retrieves the current control settings for the selected DMA channel,
1756:                     *                  including the channel enable/disable status, the channel priority,
1757:                     *                  chaining mode, auto mode and events detection.
1758:                     *
1759:                     * Note:            None.
1760:                     *
1761:                     * Example:         either:
1762:                     *                      DmaChnCtrlFlags ctrl=DmaChnGetControlFlags(DMA_CHANNEL3); if(ctrl&DMA_CTL_AUTO_EN) {...}
1763:                     *                  or:
1764:                     *                      DmaChnCtrl chnCtrl; chnCtrl.w=DmaChnGetControlFlags(DMA_CHANNEL3); if(chnCtrl.autoEn) {...}
1765:                     *
1766:                     ********************************************************************/
1767:                     DmaChnCtrlFlags    DmaChnGetControlFlags(DmaChannel chn);
1768:                
1769:                
1770:                    /*********************************************************************
1771:                     * Function:        int DmaChnGetEvDetect(DmaChannel chn)
1772:                     *
1773:                     * PreCondition:    chn - valid DMA channel
1774:                     *
1775:                     * Input:           chn     - DMA channel number
1776:                     *
1777:                     * Output:          TRUE if an DMA event was detected, FALSE otherwise.
1778:                     *
1779:                     * Side Effects:    None
1780:                     *
1781:                     * Overview:        The function returns the current event detection for the selected DMA channel.
1782:                     *
1783:                     * Note:            None.
1784:                     *
1785:                     * Example:         int evDetect=DmaChnGetEvDetect(DMA_CHANNEL3);
1786:                     *
1787:                     ********************************************************************/
1788:                     int            DmaChnGetEvDetect(DmaChannel chn);
1789:                
1790:                    /*********************************************************************
1791:                     * Function:        void DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0)
1792:                     *
1793:                     * PreCondition:    chn     - valid DMA channel
1794:                     *                  pTxCtrl - valid pointer
1795:                     *
1796:                     * Input:           chn         - DMA channel number
1797:                     *                  pTxCtrl     - pointer to a DmaTxferCtrl that will carry the following info:
1798:                     *                              - vSrcAdd: source of the DMA transfer
1799:                     *                              - vDstAdd: destination of the DMA transfer
1800:                     *                              - srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
1801:                     *                              - dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
1802:                     *                              - cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
1803:                     *                  mapToK0     - if TRUE, a Kernel address is mapped to KSeg0, else KSeg1.
1804:                     *
1805:                     * Output:          None
1806:                     *
1807:                     * Side Effects:    None
1808:                     *
1809:                     * Overview:        The function retrieves the transfer characteristics for a DMA channel transfer:
1810:                     *                  the source and the destination addresses.
1811:                     *                  It also retrieves the source and destination lengths
1812:                     *                  and the number of bytes transferred per event.
1813:                     *
1814:                     * Note:            None
1815:                     *
1816:                     * Example:         DmaTxferCtrl txCtl; DmaChnGetTxfer(DMA_CHANNEL3, &txCtl, FALSE);
1817:                     ********************************************************************/
1818:                     void           DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0);
1819:                
1820:                    // Low level checksum functions
1821:                
1822:                    /*********************************************************************
1823:                     * Function:        void DmaSfmEnable(int enable)
1824:                     *
1825:                     * PreCondition:    None
1826:                     *
1827:                     * Input:           enable _ boolean to enable/disable the SFM functionality
1828:                     *
1829:                     * Output:          None
1830:                     *
1831:                     * Side Effects:    None
1832:                     *
1833:                     * Overview:        The function enables/diables the checksum module functionality.
1834:                     *                  When enabled the attached DMA channel transfers are routed to the SFM module.
1835:                     *
1836:                     * Note:            The SFM module should be properly configured before enabled.
1837:                     *
1838:                     * Example:         DmaSfmEnable(1);
1839:                     ********************************************************************/
1840:                    extern __inline__ void __attribute__((always_inline)) DmaSfmEnable(int enable)
1841:                    {
1842:                        if(enable)
1843:                        {
1844:                            DCRCCONSET=_DCRCCON_CRCEN_MASK;
1845:                        }
1846:                        else
1847:                        {
1848:                            DCRCCONCLR=_DCRCCON_CRCEN_MASK;
1849:                        }
1850:                    }
1851:                    #define DmaCrcEnable    DmaSfmEnable        // PIC32_3xx backward compatibility
1852:                
1853:                
1854:                    /*********************************************************************
1855:                     * Function:        int DmaSfmGetEnable(void)
1856:                     *
1857:                     * PreCondition:    None
1858:                     *
1859:                     * Input:           None
1860:                     *
1861:                     * Output:          TRUE, if the SFM module is enabled
1862:                     *          FALSE otherwise
1863:                     *
1864:                     * Side Effects:    None
1865:                     *
1866:                     * Overview:        The function returns the SFM module enabling status.
1867:                     *
1868:                     * Note:            None
1869:                     *
1870:                     * Example:     int isSfmEnabled=DmaSfmGetEnable();
1871:                     ********************************************************************/
1872:                    extern __inline__ int __attribute__((always_inline)) DmaSfmGetEnable(void)
1873:                    {
1874:                        return DCRCCONbits.CRCEN!=0;
1875:                    }
1876:                    #define     DmaCrcGetEnable     DmaSfmGetEnable     // PIC32_3xx backward compatibility
1877:                
1878:                
1879:                    /*********************************************************************
1880:                     * Function:        void DmaSfmAppendEnable(int enable)
1881:                     *
1882:                     * PreCondition:    None
1883:                     *
1884:                     * Input:           enable _ boolean to enable/disable the SFM append mode
1885:                     *
1886:                     * Output:          None
1887:                     *
1888:                     * Side Effects:    None
1889:                     *
1890:                     * Overview:        The function enables the SFM append mode. In this mode, the attached DMA channel reads
1891:                     *                  the source data but does not write it to the destination address. The data it's just passed
1892:                     *                  to the checksum generator for CRC/IP checksum calculation.
1893:                     *                  When the block transfer is completed, the checksum result is written to the
1894:                     *                  DMA channel destination address.
1895:                     *
1896:                     * Note:            The SFM module should be properly configured before enabled.
1897:                     *
1898:                     * Example:         DmaSfmAppendModeEnable(TRUE);
1899:                     ********************************************************************/
1900:                    extern __inline__ void __attribute__((always_inline)) DmaSfmAppendEnable(int enable)
1901:                    {
1902:                        if(enable)
1903:                        {
1904:                            DCRCCONSET=_DCRCCON_CRCAPP_MASK;
1905:                        }
1906:                        else
1907:                        {
1908:                            DCRCCONCLR=_DCRCCON_CRCAPP_MASK;
1909:                        }
1910:                    }
1911:                    #define     DmaCrcAppendModeEnable  DmaSfmAppendEnable  // PIC32_3xx backward compatibility
1912:                
1913:                
1914:                    /*********************************************************************
1915:                     * Function:        int DmaSfmGetAppendMode(void)
1916:                     *
1917:                     * PreCondition:    None
1918:                     *
1919:                     * Input:           None
1920:                     *
1921:                     * Output:          TRUE, if the SFM append mode is enabled
1922:                     *                  FALSE otherwise
1923:                     *
1924:                     * Side Effects:    None
1925:                     *
1926:                     * Overview:        The function returns the SFM module enabling status.
1927:                     *
1928:                     * Note:            None
1929:                     *
1930:                     * Example:         int isAppendEnabled=DmaSfmGetAppendMode();
1931:                     ********************************************************************/
1932:                    extern __inline__ int __attribute__((always_inline)) DmaSfmGetAppendMode(void)
1933:                    {
1934:                        return DCRCCONbits.CRCAPP!=0;
1935:                    }
1936:                    #define DmaCrcGetAppendMode DmaSfmGetAppendMode     // PIC32_3xx backward compatibility
1937:                
1938:                
1939:                    /*********************************************************************
1940:                     * Function:        void DmaSfmSetAttach(DmaChannel chn)
1941:                     *
1942:                     * PreCondition:    chn     - valid DMA channel
1943:                     *
1944:                     * Input:           chn - the DMA channel to be attached to the SFM module (the DMA channel transfers will be routed to the SFM module)
1945:                     *
1946:                     * Output:          None
1947:                     *
1948:                     * Side Effects:    None
1949:                     *
1950:                     * Overview:        The function directly attaches a DMA channel to the SFM module.
1951:                     *
1952:                     * Note:            None
1953:                     *
1954:                     * Example:         DmaSfmSetAttach(DMA_CHANNEL3);
1955:                     ********************************************************************/
1956:                    extern __inline__ void __attribute__((always_inline)) DmaSfmSetAttach(DmaChannel chn)
1957:                    {
1958:                        DCRCCONCLR=_DCRCCON_CRCCH_MASK;
1959:                        DCRCCONSET=chn;
1960:                    }
1961:                    #define     DmaCrcSetAttach     DmaSfmSetAttach     // PIC32_3xx backward compatibility
1962:                
1963:                
1964:                    /*********************************************************************
1965:                     * Function:        DmaChannel DmaSfmGetAttach(void)
1966:                     *
1967:                     * PreCondition:    None
1968:                     *
1969:                     * Input:           None
1970:                     *
1971:                     * Output:          the DMA channel that is currently attached to the CRC module
1972:                     *
1973:                     * Side Effects:    None
1974:                     *
1975:                     * Overview:        The function returns the DMA channel number that is currently attached to the SFM module.
1976:                     *
1977:                     * Note:            None
1978:                     *
1979:                     * Example:         DmaChannel chn=DmaSfmGetAttach();
1980:                     ********************************************************************/
1981:                    extern __inline__ DmaChannel __attribute__((always_inline)) DmaSfmGetAttach(void)
1982:                    {
1983:                        return (DmaChannel)DCRCCONbits.CRCCH;
1984:                    }
1985:                    #define     DmaCrcGetAttach     DmaSfmGetAttach     // PIC32_3xx backward compatibility
1986:                
1987:                    /*********************************************************************
1988:                     * Function:        void DmaCrcSetPLen(int pLen)
1989:                     *
1990:                     * PreCondition:    pLen - valid polynomial length within 1-32
1991:                     *
1992:                     * Input:           pLen    - the length of the CRC generator polynomial
1993:                     *
1994:                     * Output:          None
1995:                     *
1996:                     * Side Effects:    None
1997:                     *
1998:                     * Overview:        The length of the CRC generator polynomial is set as being pLen;
1999:                     *
2000:                     * Note:            None
2001:                     *
2002:                     * Example:         DmaCrcSetPLen(32);
2003:                     ********************************************************************/
2004:                    extern __inline__ void __attribute__((always_inline)) DmaCrcSetPLen(int pLen)
2005:                    {
2006:                        DCRCCONCLR=_DCRCCON_PLEN_MASK;
2007:                        DCRCCONSET=(pLen)-1;
2008:                    }
2009:                
2010:                    /*********************************************************************
2011:                     * Function:        int DmaCrcGetPLen(void)
2012:                     *
2013:                     * PreCondition:    None
2014:                     *
2015:                     * Input:           None
2016:                     *
2017:                     * Output:          the length of the CRC generator polynomial
2018:                     *
2019:                     * Side Effects:    None
2020:                     *
2021:                     * Overview:        The function returns the current length of the CRC generator polynomial.
2022:                     *                  It's always a number between 1 and 32.
2023:                     *
2024:                     * Note:            None
2025:                     *
2026:                     * Example:         int polyLen=DmaCrcGetPLen();
2027:                     ********************************************************************/
2028:                    extern __inline__ int __attribute__((always_inline)) DmaCrcGetPLen(void)
2029:                    {
2030:                        return  DCRCCONbits.PLEN+1;
2031:                    }
2032:                
2033:                    /*********************************************************************
2034:                     * Function:        void DmaCrcSetShiftFeedback(unsigned int feedback)
2035:                     *
2036:                     * PreCondition:    None
2037:                     *
2038:                     * Input:           feedback - the layout of the CRC generator
2039:                     *
2040:                     * Output:          None
2041:                     *
2042:                     * Side Effects:    None
2043:                     *
2044:                     * Overview:        The function sets the layout of the shift stages that take place in the CRC generation.
2045:                     *                  Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
2046:                     *                  If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
2047:                     *
2048:                     * Note:            Bit 0 of the generator polynomial is always XOR'ed.
2049:                     *
2050:                     * Example:         DmaCrcSetShiftFeedback(0x04c11db7);
2051:                     ********************************************************************/
2052:                    extern __inline__ void __attribute__((always_inline)) DmaCrcSetShiftFeedback(unsigned int feedback)
2053:                    {
2054:                        DCRCXOR=feedback;
2055:                    }
2056:                
2057:                
2058:                    /*********************************************************************
2059:                     * Function:        unsigned int DmaCrcGetShiftFeedback(void)
2060:                     *
2061:                     * PreCondition:    None
2062:                     *
2063:                     * Input:           None
2064:                     *
2065:                     * Output:          the current layout of the CRC generator
2066:                     *
2067:                     * Side Effects:    None
2068:                     *
2069:                     * Overview:        The function returns the layout of the shift stages that take place in the CRC generation.
2070:                     *                  A bit set to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
2071:                     *                  If a bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
2072:                     *
2073:                     * Note:            Bit 0 of the generator polynomial is always XOR'ed.
2074:                     *
2075:                     * Example:         int feedback=DmaCrcGetShiftFeedback();
2076:                     ********************************************************************/
2077:                    extern __inline__ unsigned int __attribute__((always_inline)) DmaCrcGetShiftFeedback(void)
2078:                    {
2079:                        return DCRCXOR;
2080:                    }
2081:                
2082:                
2083:                
2084:                    // Channel test/debug and special functions
2085:                
2086:                    /*********************************************************************
2087:                     * Function:        void DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags)
2088:                     *
2089:                     * PreCondition:    chn - valid DMA channel
2090:                     *
2091:                     * Input:           chn     - DMA channel number
2092:                     *                  eFlags  - event flags with the following significance:
2093:                     *                              - DMA_EV_ERR: address error event
2094:                     *                              - DMA_EV_ABORT: transfer abort event
2095:                     *                              - DMA_EV_CELL_DONE: cell transfer complete event
2096:                     *                              - DMA_EV_BLOCK_DONE: block transfer complete event
2097:                     *                              - DMA_EV_DST_HALF: destination half event
2098:                     *                              - DMA_EV_DST_FULL: destination full event
2099:                     *                              - DMA_EV_SRC_HALF: source half event
2100:                     *                              - DMA_EV_SRC_FULL: source full event
2101:                     *                              - DMA_EV_ALL_EVNTS: all of the above flags
2102:                     *
2103:                     * Output:          None
2104:                     *
2105:                     * Side Effects:    None
2106:                     *
2107:                     * Overview:        The function sets the event flags for the selected DMA channel.
2108:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
2109:                     *                  set for the selected channel, the other channel event flags won't be touched.
2110:                     *
2111:                     * Note:            This is intended as a channel test function.
2112:                     *
2113:                     * Example:         DmaChnSetEvFlags(DMA_CHANNEL0, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2114:                     ********************************************************************/
2115:                     void           DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2116:                
2117:                    /*********************************************************************
2118:                     * Function:        void DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags)
2119:                     *
2120:                     * PreCondition:    chn - valid DMA channel
2121:                     *
2122:                     * Input:           chn     - DMA channel number
2123:                     *                  eFlags  - event flags with the following significance:
2124:                     *                              - DMA_EV_ERR: address error event
2125:                     *                              - DMA_EV_ABORT: transfer abort event
2126:                     *                              - DMA_EV_CELL_DONE: cell transfer complete event
2127:                     *                              - DMA_EV_BLOCK_DONE: block transfer complete event
2128:                     *                              - DMA_EV_DST_HALF: destination half event
2129:                     *                              - DMA_EV_DST_FULL: destination full event
2130:                     *                              - DMA_EV_SRC_HALF: source half event
2131:                     *                              - DMA_EV_SRC_FULL: source full event
2132:                     *                              - DMA_EV_ALL_EVNTS: all of the above flags
2133:                     *
2134:                     * Output:          None
2135:                     *
2136:                     * Side Effects:    None
2137:                     *
2138:                     * Overview:        The function writes the event flags for the selected DMA channel.
2139:                     *                  The channel event flags are forced to the eFlags value.
2140:                     *
2141:                     * Note:            This is intended as a channel test function.
2142:                     *
2143:                     * Example:         DmaChnWriteEvFlags(DMA_CHANNEL0, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2144:                     ********************************************************************/
2145:                     void           DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2146:                
2147:                
2148:                    /********************************************************************
2149:                     * Include legacy DMA functions
2150:                     * New projects should not use them!
2151:                     * Note that interrupt functions are no longer provided.
2152:                     * The functions in the int.h should be used instead.
2153:                     ********************************************************************/
2154:                    #ifndef _PLIB_DISABLE_LEGACY
2155:                        #include <peripheral/legacy/dma_legacy.h>
2156:                    #endif
2157:                
2158:                
2159:                #else
2160:                    #undef _DMA_CHANNELS        // no DMA channels
2161:                #endif  // _DMAC0
2162:                
2163:                #endif /*_DMA_1XX_2XX_H_*/
2164:                
2165:                
